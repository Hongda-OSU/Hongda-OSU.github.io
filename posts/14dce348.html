<!DOCTYPE html><html lang="zh-CN" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>算法 Algorithm • 上 | 鴻鵠誌達</title><meta name="author" content="鴻達"><meta name="copyright" content="鴻達"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#1a1a1a"><meta name="description" content="算法学习，基础数据结构使用">
<meta property="og:type" content="article">
<meta property="og:title" content="算法 Algorithm • 上">
<meta property="og:url" content="https://hongdalin.blog/posts/14dce348.html">
<meta property="og:site_name" content="鴻鵠誌達">
<meta property="og:description" content="算法学习，基础数据结构使用">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/imgj1udos782ybmzugwd1ltkozc9zxj3gz.jpg">
<meta property="article:published_time" content="2023-08-10T06:46:05.000Z">
<meta property="article:modified_time" content="2024-04-26T08:13:07.806Z">
<meta property="article:author" content="鴻達">
<meta property="article:tag" content="算法">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/imgj1udos782ybmzugwd1ltkozc9zxj3gz.jpg"><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/Hongda-OSU/PicGo/image/德克萨斯.GIF"><link rel="canonical" href="https://hongdalin.blog/posts/14dce348.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '算法 Algorithm • 上',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-04-26 03:13:07'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = url => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      link.onload = () => resolve()
      link.onerror = () => reject()
      document.head.appendChild(link)
    })
  
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/color.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="/css/font.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="/css/icon.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="/css/layout.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.css" media="defer" onload="this.media='all'"><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://cdn.jsdelivr.net/gh/Hongda-OSU/PicGo/image/德狗子.GIF" onerror="onerror=null;src='https://cdn.jsdelivr.net/gh/Hongda-OSU/PicGo/image/404.GIF'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">13</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">7</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 链接</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/imgj1udos782ybmzugwd1ltkozc9zxj3gz.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="鴻鵠誌達"><span class="site-name">鴻鵠誌達</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 链接</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">算法 Algorithm • 上</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-08-10T06:46:05.000Z" title="发表于 2023-08-10 01:46:05">2023-08-10</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-04-26T08:13:07.806Z" title="更新于 2024-04-26 03:13:07">2024-04-26</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">12.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>43分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="算法 Algorithm • 上"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>本读书笔记节选自<code>krahets</code>大佬编写的<a target="_blank" rel="noopener" href="https://www.hello-algo.com/">《Hello 算法》</a>。勉励自己开始系统的算法学习。</p>
</blockquote>
<hr>
<h2 id="1-初识算法"><a href="#1-初识算法" class="headerlink" title="1. 初识算法"></a>1. 初识算法</h2><p>当我们听到“算法”这个词时，很自然地会想到数学。然而实际上，许多算法并不涉及复杂数学，而是更多地依赖于基本逻辑，这些逻辑在我们的日常生活中处处可见。</p>
<p>（1）查阅字典</p>
<p>在字典里，每个汉字都对应一个拼音，而字典是按照拼音的英文字母顺序排列的。假设需要查找一个拼音首字母为<code>r</code>的字，通常会这样操作。</p>
<ul>
<li>翻开字典约一半的页数，查看该页首字母是什么，假设首字母为<code>m</code>。</li>
<li>由于在英文字母表中<code>r</code>位于<code>m</code>之后，所以排除字典前半部分，查找范围缩小到后半部分。</li>
<li>不断重复上面两个步骤，直至找到拼音首字母为<code>r</code>的页码为止。</li>
</ul>
<div class="tabs" id="placeholder"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#placeholder-1"><1></button></li><li class="tab"><button type="button" data-href="#placeholder-2"><2></button></li><li class="tab"><button type="button" data-href="#placeholder-3"><3></button></li><li class="tab"><button type="button" data-href="#placeholder-4"><4></button></li><li class="tab"><button type="button" data-href="#placeholder-5"><5></button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="placeholder-1"><p><img src="https://cdn.jsdelivr.net/gh/Hongda-OSU/PicGo/image/binary_search_dictionary_step1.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="placeholder-2"><p><img src="https://cdn.jsdelivr.net/gh/Hongda-OSU/PicGo/image/binary_search_dictionary_step2.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="placeholder-3"><p><img src="https://cdn.jsdelivr.net/gh/Hongda-OSU/PicGo/image/binary_search_dictionary_step3.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="placeholder-4"><p><img src="https://cdn.jsdelivr.net/gh/Hongda-OSU/PicGo/image/binary_search_dictionary_step4.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="placeholder-5"><p><img src="https://cdn.jsdelivr.net/gh/Hongda-OSU/PicGo/image/binary_search_dictionary_step5.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>

<p>查阅字典这个必备技能，实际上就是「二分查找」。从数据结构的角度，我们可以把字典视为一个<ins>已排序</ins>的「数组」。从算法的角度，我们可以将上述查字典的一系列操作看作是「二分查找」算法。</p>
<p>（2）整理扑克</p>
<p>打牌时，每局都需要整理扑克牌，使其从小到大排列，实现流程如下。</p>
<ul>
<li>将扑克牌划分为“有序”和“无序”两部分，并假设初始状态下最左<code>1</code>张扑克牌已经有序。</li>
<li>在无序部分抽出一张扑克牌，插入至有序部分的正确位置。此时最左<code>2</code>张扑克已经有序。</li>
<li>不断循环上面步骤，每一轮将一张扑克牌从无序部分插入至有序部分，直至所有扑克牌都有序。</li>
</ul>
<p><img src="https://www.hello-algo.com/chapter_introduction/algorithms_are_everywhere.assets/playing_cards_sorting.png"></p>
<p>上述整理扑克牌的方法本质上是「插入排序」算法，它在处理小型数据集时非常高效。许多编程语言的排序库函数中都存在插入排序的身影。</p>
<p>（3）货币找零</p>
<p>假设我们在超市购买了<code>69</code>元的商品，给收银员付了<code>100</code>元，则收银员需要给我们找<code>31</code>元。他会很自然地完成以下思考。</p>
<ul>
<li>可选项是比<code>31</code>元面值更小的货币，包括<code>1</code>，<code>5</code>，<code>10</code>，<code>20</code>元。</li>
<li>从可选项中拿出最大的<code>20</code>元，剩余<code>11</code> 元。</li>
<li>从剩余可选项中拿出最大的<code>10</code>元，剩余<code>1</code> 元。</li>
<li>从剩余可选项中拿出最大的<code>1</code>元，剩余<code>0</code> 元。</li>
<li>完成找零，方案为<code>20 + 10 + 1 = 31</code>元。</li>
</ul>
<p><img src="https://www.hello-algo.com/chapter_introduction/algorithms_are_everywhere.assets/greedy_change.png"></p>
<p>在以上步骤中，我们每一步都采取当前看来最好的选择（尽可能用大面额的货币），最终得到了可行的找零方案。从数据结构与算法的角度看，这种方法本质上是「贪心算法」。</p>
<p><img src="https://www.hello-algo.com/chapter_introduction/what_is_dsa.assets/relationship_between_data_structure_and_algorithm.png"></p>
<hr>
<h2 id="2-复杂度"><a href="#2-复杂度" class="headerlink" title="2. 复杂度"></a>2. 复杂度</h2><h3 id="2-1-迭代与递归"><a href="#2-1-迭代与递归" class="headerlink" title="2.1 迭代与递归"></a>2.1 迭代与递归</h3><p>在数据结构与算法中，重复执行某个任务是很常见的，通常会选用两种基本的程序结构。</p>
<p>「迭代 <code>iteration</code>」是一种重复执行某个任务的控制结构。在迭代中，程序会在满足一定的条件下重复执行某段代码，直到这个条件不再满足。（例如常见的<code>for</code>循环和<code>while</code>循环）</p>
<p>「递归 <code>recursion</code>」是一种算法策略，<ins>通过函数调用自身来解决问题</ins>。它主要包含两个阶段。</p>
<ul>
<li>递：程序不断深入地调用自身，通常传入更小或更简化的参数，直到达到“终止条件”。</li>
<li>归：触发“终止条件”后，程序从最深层的递归函数开始逐层返回，汇聚每一层的结果。</li>
</ul>
<p>下面代码中，只需调用函数<code>recur(n)</code>，就可以完成<code>1 + 2 + ... + n</code>的计算。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 递归 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">recur</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="comment">// 终止条件</span></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 递：递归调用</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> recur(n - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 归：返回结果</span></span><br><span class="line">    <span class="keyword">return</span> n + res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://www.hello-algo.com/chapter_computational_complexity/iteration_and_recursion.assets/recursion_sum.png"></p>
<p>从计算角度看，迭代与递归可以得到相同的结果，但代表了两种不同的思考和解决问题的方式。</p>
<ul>
<li>迭代：从最基础的步骤开始，然后不断重复或累加这些步骤，直到任务完成。</li>
<li>递归：将原问题分解为更小的子问题，这些子问题和原问题具有相同的形式。接下来将子问题继续分解为更小的子问题，直到基本情况时停止。</li>
</ul>
<hr>
<h3 id="2-2-时间复杂度"><a href="#2-2-时间复杂度" class="headerlink" title="2.2 时间复杂度"></a>2.2 时间复杂度</h3><p>「时间复杂度分析」统计的是算法运行时间随着数据量变大时的增长趋势。下面例子中，假设输入数据大小为<code>n</code>，给定三个算法函数<code>A</code>，<code>B</code>，<code>C</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 算法 A 时间复杂度：常数阶</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">algorithm_A</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    System.out.println(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 算法 B 时间复杂度：线性阶</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">algorithm_B</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        System.out.println(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 算法 C 时间复杂度：常数阶</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">algorithm_C</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++) &#123;</span><br><span class="line">        System.out.println(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>算法<code>A</code>只有<code>1</code>个打印操作，算法运行时间不随着<code>n</code>增大而增长。此算法的时间复杂度为「常数阶」。</li>
<li>算法<code>B</code>中的打印操作要循环<code>n</code>次，算法运行时间随着<code>n</code>增大呈线性增长。此算法的时间复杂度被称为「线性阶」。</li>
<li>算法<code>C</code>中的打印操作要循环<code>1000000</code>次，虽然运行时间很长，但它与输入数据大小<code>n</code>无关。因此<code>C</code>的时间复杂度和<code>A</code>相同，仍为「常数阶」。</li>
</ul>
<p><img src="https://www.hello-algo.com/chapter_computational_complexity/time_complexity.assets/time_complexity_simple_example.png"></p>
<p>时间复杂度分析有哪些特点呢？</p>
<ul>
<li><p>时间复杂度能够有效评估算法效率。算法<code>B</code>的运行时间呈线性增长，在<code>n &gt; 1</code>时比算法<code>A</code>更慢，在<code>n &gt; 1000000</code>时比算法<code>C</code>更慢。而且只要输入数据大小<code>n</code>足够大，复杂度为“常数阶”的算法一定优于“线性阶”的算法。</p>
</li>
<li><p>时间复杂度也存在一定的局限性。算法<code>A</code>和<code>C</code>的时间复杂度相同，但实际运行时间差别很大。同样，算法<code>B</code>的时间复杂度比<code>C</code>高，但在输入数据大小<code>n</code>较小时，算法<code>B</code>明显优于<code>C</code>。</p>
</li>
</ul>
<h4 id="函数渐近上界"><a href="#函数渐近上界" class="headerlink" title="函数渐近上界"></a>函数渐近上界</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">algorithm</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;  <span class="comment">// +1</span></span><br><span class="line">    a = a + <span class="number">1</span>;  <span class="comment">// +1</span></span><br><span class="line">    a = a * <span class="number">2</span>;  <span class="comment">// +1</span></span><br><span class="line">    <span class="comment">// 循环 n 次</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123; <span class="comment">// +1（每轮都执行 i ++）</span></span><br><span class="line">        System.out.println(<span class="number">0</span>);    <span class="comment">// +1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>设上面函数的计算操作数量是一个关于输入数据大小<code>n</code>的函数，记为<code>T(n)</code>，则其操作数量为<code>T(n) = 3 + 2n</code>。其中<code>T(n)</code>是一次函数，说明时间的增长趋势是线性的，时间复杂度是线性阶。</p>
<p>我们将线性阶的时间复杂度记为<code>O(n)</code>，这个数学符号称为「<code>Big-O Notation</code>」，用来表示函数<code>T(n)</code>的「渐近上界 <code>Asymptotic Upper Bound</code>」。</p>
<p><img src="https://www.hello-algo.com/chapter_computational_complexity/time_complexity.assets/asymptotic_upper_bound.png"></p>
<p>总的来说，计算渐近上界就是寻找一个函数<code>f(n)</code>，使得当<code>n</code>趋向于无穷大时，<code>T(n)</code>和<code>f(n)</code>处于相同的增长级别，仅相差一个常数项<code>c</code>的倍数。</p>
<h4 id="推算方法"><a href="#推算方法" class="headerlink" title="推算方法"></a>推算方法</h4><p>根据定义，确定<code>f(n)</code>之后，我们便可推算时间复杂度<code>O(f(n))</code>。那么如何确定渐近上界<code>f(n)</code>呢？总体分为两步，统计操作数量，判断渐近上界。</p>
<p><strong>第一步：统计操作数量</strong></p>
<p>针对代码，逐行从上到下计算即可。然而，由于上述<code>c·f(n)</code>中的常数项<code>c</code>可以取任意大小，因此操作数量 <code>T(n)</code>中的各种系数、常数项都可以被忽略。</p>
<ul>
<li>忽略常数项。因为它们都与<code>n</code>无关，所以对时间复杂度不产生影响。</li>
<li>省略所有系数。例如，循环<code>2n</code>次、<code>5n + 1</code>次等，都可以简化记为<code>n</code>次，因为<code>n</code>前面的系数对时间复杂度没有影响。</li>
<li>循环嵌套时使用乘法。总操作数量等于外层循环和内层循环操作数量之积，每一层循环依然可以分别套用上述两个技巧。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">algorithm</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;  <span class="comment">// +0（技巧 1）</span></span><br><span class="line">    a = a + n;  <span class="comment">// +0（技巧 1）</span></span><br><span class="line">    <span class="comment">// +n（技巧 2）</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span> * n + <span class="number">1</span>; i++) &#123;</span><br><span class="line">        System.out.println(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// +n*n（技巧 3）</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">2</span> * n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n + <span class="number">1</span>; j++) &#123;</span><br><span class="line">            System.out.println(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面展示了使用上述技巧前、后的统计结果。两者推出的时间复杂度相同，即为<code>O(n^2)</code>。</p>
<ul>
<li><code>T(n) = 2n(n + 1) + (5n + 1) + 2 = 2n^2 + 7n + 3</code>（完整统计）</li>
<li><code>T(n) = n^2 + n</code>（偷懒统计）</li>
</ul>
<p><strong>第二步：判断渐近上界</strong></p>
<p>时间复杂度由多项式<code>T(n)</code>中最高阶的项来决定。这是因为在<code>n</code>趋于无穷大时，最高阶的项将发挥主导作用，其他项的影响都可以被忽略。</p>
<table>
<thead>
<tr>
<th align="left">操作数量<code>T(n)</code></th>
<th align="left">时间复杂度<code>O(f(n))</code></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>100000</code></td>
<td align="left"><code>O(1)</code></td>
</tr>
<tr>
<td align="left"><code>3n + 2</code></td>
<td align="left"><code>O(n)</code></td>
</tr>
<tr>
<td align="left"><code>2n^2 + 3n + 2</code></td>
<td align="left"><code>O(n^2)</code></td>
</tr>
<tr>
<td align="left"><code>n^3 + 100000n^2</code></td>
<td align="left"><code>O(n^3)</code></td>
</tr>
<tr>
<td align="left"><code>2^n + 100000n^100000</code></td>
<td align="left"><code>O(2^n)</code></td>
</tr>
</tbody></table>
<h4 id="常见类型"><a href="#常见类型" class="headerlink" title="常见类型"></a>常见类型</h4><p>设输入数据大小为<code>n</code>，常见的时间复杂度类型包括（按照从低到高的顺序排列）</p>
<p><img src="https://cdn.jsdelivr.net/gh/Hongda-OSU/PicGo/image/pic.png"></p>
<p><img src="https://www.hello-algo.com/chapter_computational_complexity/time_complexity.assets/time_complexity_common_types.png"></p>
<p><strong>常数阶<code>O(1)</code></strong></p>
<p>常数阶的操作数量与输入数据大小<code>n</code>无关，不会随着<code>n</code>的变化而变化。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 常数阶 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">constant</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">100000</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">        count++;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，尽管操作数量<code>size</code>很大，但由于其与数据大小<code>n</code>无关，因此时间复杂度仍为<code>O(1)</code>。</p>
<p><strong>线性阶<code>O(n)</code></strong></p>
<p>线性阶的操作数量相对于输入数据大小以线性级别增长。线性阶通常出现在单层循环中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 线性阶 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">linear</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        count++;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>遍历数组和遍历链表等操作的时间复杂度均为<code>O(n)</code>，其中<code>n</code>为数组或链表的长度。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 线性阶（遍历数组） */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">arrayTraversal</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 循环次数与数组长度成正比</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，数据大小<code>n</code>需根据输入数据的类型来具体确定。比如在第一个示例中，变量<code>n</code>为输入数据大小。在第二个示例中，<code>n</code>为数组长度大小。</p>
<p><strong>平方阶<code>O(n^2)</code></strong></p>
<p>平方阶的操作数量相对于输入数据大小以平方级别增长。平方阶通常出现在嵌套循环中，外层循环和内层循环都为<code>O(n)</code>，因此总体为<code>O(n^2)</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 平方阶 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">quadratic</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 循环次数与数组长度成平方关系</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://www.hello-algo.com/chapter_computational_complexity/time_complexity.assets/time_complexity_constant_linear_quadratic.png"></p>
<p>以「冒泡排序」为例，外层循环执行<code>n - 1</code>次，内层循环执行<code>n - 1, n - 2, ... , 2, 1</code>次，平均为<code>n / 2</code>次，因此时间复杂度为<code>O(n^2)</code>。</p>
<p>时间复杂度: <code>O((n - 1) · n / 2) = O(n^2)</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 平方阶（冒泡排序） */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">bubbleSort</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 计数器</span></span><br><span class="line">    <span class="comment">// 外循环：未排序区间为 [0, i]</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> nums.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="comment">// 内循环：将未排序区间 [0, i] 中的最大元素交换至该区间的最右端</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[j] &gt; nums[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="comment">// 交换 nums[j] 与 nums[j + 1]</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> nums[j];</span><br><span class="line">                nums[j] = nums[j + <span class="number">1</span>];</span><br><span class="line">                nums[j + <span class="number">1</span>] = tmp;</span><br><span class="line">                count += <span class="number">3</span>; <span class="comment">// 元素交换包含 3 个单元操作</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>指数阶<code>O(2^n)</code></strong></p>
<p>生物学中的“细胞分裂”是指数阶增长的典型例子。初始状态为<code>1</code>个细胞，分裂一轮后变为<code>2</code>个，分裂两轮后变为<code>4</code>个，以此类推，分裂<code>n</code>轮后有<code>2^n</code>个细胞。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 指数阶（循环实现） */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">exponential</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>, base = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 细胞每轮一分为二，形成数列 1, 2, 4, 8, ..., 2^(n-1)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; base; j++) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        base *= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// count = 1 + 2 + 4 + 8 + .. + 2^(n-1) = 2^n - 1</span></span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://www.hello-algo.com/chapter_computational_complexity/time_complexity.assets/time_complexity_exponential.png"></p>
<p>实际算法中，指数阶常出现于递归函数。例如以下代码，其递归地一分为二，经过<code>n</code>次分裂后停止。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 指数阶（递归实现） */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">expRecur</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> expRecur(n - <span class="number">1</span>) + expRecur(n - <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>指数阶增长非常迅速，在穷举法（暴力搜索、回溯等）中比较常见。对于数据规模较大的问题，指数阶是不可接受的，通常需要使用「动态规划」或「贪心」等算法来解决。</p>
<p><strong>对数阶<code>O(logn)</code></strong></p>
<p>与指数阶相反，对数阶反映了“每轮缩减到一半”的情况。设输入数据大小为<code>n</code>，由于每轮缩减到一半，因此循环次数是<code>log2(n)</code>，即<code>2^n</code>的反函数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 对数阶（循环实现） */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">logarithmic</span><span class="params">(<span class="type">float</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        n = n / <span class="number">2</span>;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://www.hello-algo.com/chapter_computational_complexity/time_complexity.assets/time_complexity_logarithmic.png"></p>
<p>与指数阶类似，对数阶也常出现于递归函数。以下代码形成了一个高度为<code>log2(n)</code>的递归树。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 对数阶（递归实现） */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">logRecur</span><span class="params">(<span class="type">float</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> logRecur(n / <span class="number">2</span>) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对数阶常出现于基于「分治」的算法中，体现了“一分为多”和“化繁为简”的算法思想。它增长缓慢，是理想的时间复杂度，仅次于常数阶。</p>
<p><strong>线性对数阶<code>O(nlogn)</code></strong></p>
<p>线性对数阶常出现于嵌套循环中，两层循环的时间复杂度分别为<code>O(logn)</code>和<code>O(n)</code>。主流排序算法的时间复杂度通常为<code>O(nlogn)</code>，例如快速排序、归并排序、堆排序等。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 线性对数阶 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">linearLogRecur</span><span class="params">(<span class="type">float</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> linearLogRecur(n / <span class="number">2</span>) +</span><br><span class="line">            linearLogRecur(n / <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://www.hello-algo.com/chapter_computational_complexity/time_complexity.assets/time_complexity_logarithmic_linear.png"></p>
<p><strong>阶乘阶<code>O(n!)</code></strong></p>
<p>阶乘阶对应数学上的“全排列”问题。给定<code>n</code>个互不重复的元素，求其所有可能的排列方案，方案数量为<code>n! = n * (n - 1) * (n - 2) * ... * 2 * 1</code>。</p>
<p>阶乘通常使用递归实现。例如以下代码，第一层分裂出<code>n</code>个，第二层分裂出<code>n-1</code>个，以此类推，直至第<code>n</code>层时终止分裂。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 阶乘阶（递归实现） */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">factorialRecur</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 从 1 个分裂出 n 个</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        count += factorialRecur(n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://www.hello-algo.com/chapter_computational_complexity/time_complexity.assets/time_complexity_factorial.png"></p>
<p>请注意，因为<code>n! &gt; 2^n</code>，所以阶乘阶比指数阶增长地更快，在<code>n</code>较大时也是不可接受的。</p>
<h4 id="最差、最佳、平均"><a href="#最差、最佳、平均" class="headerlink" title="最差、最佳、平均"></a>最差、最佳、平均</h4><p>算法的时间效率往往不是固定的，而是与输入数据的分布有关。假设输入一个长度为<code>n</code>的数组<code>nums</code>，其中<code>nums</code>由从<code>1</code>至<code>n</code>的数字组成，但元素顺序是随机打乱的，任务目标是返回元素<code>1</code>的索引。可以得出以下结论。</p>
<ul>
<li>当末尾元素是<code>1</code>时，需要完整遍历数组，达到最差时间复杂度<code>O(n)</code>。</li>
<li>当首个数字为<code>1</code>时，无论数组多长都不需要继续遍历，达到最佳时间复杂度<code>Ω(1)</code>。</li>
</ul>
<p>「最差时间复杂度」对应函数渐近上界，使用<code>O</code>记号表示。相应地，「最佳时间复杂度」对应函数渐近下界，用<code>Ω</code>记号表示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 查找数组 nums 中数字 1 所在索引 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">findOne</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="comment">// 当元素 1 在数组头部时，达到最佳时间复杂度 O(1)</span></span><br><span class="line">        <span class="comment">// 当元素 1 在数组尾部时，达到最差时间复杂度 O(n)</span></span><br><span class="line">        <span class="keyword">if</span> (nums[i] == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然而，实际中很少使用「最佳时间复杂度」，因为通常只有在很小概率下才能达到，并且可能会带来一定的误导性。<ins>因此「最差时间复杂度」更为实用，因为它给出了一个效率安全值</ins>。</p>
<p>从上面代码可以看出，最差或最佳时间复杂度只出现于“特殊的数据分布”，这些情况的出现概率可能很小。相比之下，「平均时间复杂度」可以体现算法在随机输入数据下的运行效率，用<code>Θ</code>记号来表示。</p>
<ul>
<li>上面代码中，输入数组是被打乱的，元素<code>1</code>出现在任意索引的概率都是相等的，那么算法的平均循环次数则是数组长度的一半<code>n / 2</code>，平均时间复杂度为<code>Θ(n / 2) = Θ(n)</code>。</li>
</ul>
<p>值得说明的是，由于计算平均时间复杂度往往比较困难，因为很难分析出在数据分布下的整体数学期望。所以，<ins>我们通常使用最差时间复杂度作为算法效率的评判标准</ins>。</p>
<hr>
<h3 id="2-3-空间复杂度"><a href="#2-3-空间复杂度" class="headerlink" title="2.3 空间复杂度"></a>2.3 空间复杂度</h3><p>「空间复杂度」用于衡量算法占用内存空间随着数据量变大时的增长趋势。这个概念与时间复杂度非常类似，只需将“运行时间”替换为“占用内存空间”。</p>
<p><img src="https://www.hello-algo.com/chapter_computational_complexity/space_complexity.assets/space_types.png"></p>
<h4 id="推算方法-1"><a href="#推算方法-1" class="headerlink" title="推算方法"></a>推算方法</h4><p>空间复杂度的推算方法与时间复杂度大致相同，只需将统计对象从“操作数量”转为“使用空间大小”。</p>
<p>而与时间复杂度不同的是，<ins>通常只关注最差空间复杂度</ins>。因为内存空间是一项硬性要求，必须确保在所有输入数据下都有足够的内存空间预留。</p>
<p>下面代码中，最差空间复杂度中的“最差”有两层含义。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">algorithm</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;                   <span class="comment">// O(1)</span></span><br><span class="line">    <span class="type">int</span>[] b = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10000</span>];    <span class="comment">// O(1)</span></span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">10</span>)</span><br><span class="line">        <span class="type">int</span>[] nums = <span class="keyword">new</span> <span class="title class_">int</span>[n]; <span class="comment">// O(n)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>以最差输入数据为准。当<code>n &lt; 10</code>时，空间复杂度为<code>O(1)</code>。当<code>n &gt; 10</code>时，初始化的数组<code>nums</code>占用<code>O(n)</code>空间，因此最差空间复杂度为<code>O(n)</code>。</li>
<li>以算法运行中的峰值内存为准。程序在执行最后一行之前，占用<code>O(1)</code>空间。当初始化数组<code>nums</code>时，程序占用<code>O(n)</code>空间；因此最差空间复杂度为<code>O(n)</code>。</li>
</ul>
<p>在递归函数中，则需要注意统计栈帧空间。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">function</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 执行某些操作</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 循环 O(1) */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">loop</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        function();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 递归 O(n) */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">recur</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">return</span> recur(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>函数<code>loop()</code>在循环中调用了<code>n</code>次<code>function()</code>，每轮中<code>function()</code>都返回并释放了栈帧空间，因此空间复杂度仍为<code>O(1)</code>。</li>
<li>递归函数<code>recur()</code>在运行过程中会同时存在<code>n</code>个未返回的<code>recur()</code>，从而占用<code>O(n)</code>的栈帧空间。</li>
</ul>
<h4 id="常见类型-1"><a href="#常见类型-1" class="headerlink" title="常见类型"></a>常见类型</h4><p>设输入数据大小为<code>n</code>，下图展示了常见的空间复杂度类型（从低到高排列）。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Hongda-OSU/PicGo/image/pic2.png"></p>
<p><img src="https://www.hello-algo.com/chapter_computational_complexity/space_complexity.assets/space_complexity_common_types.png"></p>
<p><strong>常数阶<code>O(1)</code></strong></p>
<p>常数阶常见于数量与输入数据大小<code>n</code>无关的常量、变量、对象。</p>
<p>注意，在循环中初始化变量或调用函数而占用的内存，在进入下一循环后就会被释放，因此不会累积占用空间，空间复杂度仍为<code>O(1)</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 函数 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">function</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 执行某些操作</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 常数阶 */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">constant</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="comment">// 常量、变量、对象占用 O(1) 空间</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span>[] nums = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10000</span>];</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 循环中的变量占用 O(1) 空间</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 循环中的函数占用 O(1) 空间</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        function();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>线性阶<code>O(n)</code></strong></p>
<p>线性阶常见于元素数量与<code>n</code>成正比的数组、链表、栈、队列等。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 线性阶 */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">linear</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="comment">// 长度为 n 的数组占用 O(n) 空间</span></span><br><span class="line">    <span class="type">int</span>[] nums = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    <span class="comment">// 长度为 n 的列表占用 O(n) 空间</span></span><br><span class="line">    List&lt;ListNode&gt; nodes = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        nodes.add(<span class="keyword">new</span> <span class="title class_">ListNode</span>(i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 长度为 n 的哈希表占用 O(n) 空间</span></span><br><span class="line">    Map&lt;Integer, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        map.put(i, String.valueOf(i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如下图所示，下面代码的递归深度为<code>n</code>，即同时存在<code>n</code>个未返回的<code>linear_recur()</code>函数，使用<code>O(n)</code>大小的栈帧空间。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 线性阶（递归实现） */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">linearRecur</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;递归 n = &quot;</span> + n);</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    linearRecur(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://www.hello-algo.com/chapter_computational_complexity/space_complexity.assets/space_complexity_recursive_linear.png"></p>
<p><strong>平方阶<code>O(n^2)</code></strong></p>
<p>平方阶常见于矩阵和图，元素数量与<code>n</code>成平方关系。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 平方阶 */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">quadratic</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="comment">// 矩阵占用 O(n^2) 空间</span></span><br><span class="line">    <span class="type">int</span>[][] numMatrix = <span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line">    <span class="comment">// 二维列表占用 O(n^2) 空间</span></span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; numList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        List&lt;Integer&gt; tmp = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            tmp.add(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        numList.add(tmp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如下图所示，下面代码的递归深度为<code>n</code>，每个递归函数中都初始化了一个数组，长度分别为<code>n, n - 1, n - 2, ..., 2, 1</code>，平均长度为<code>n / 2</code>，因此总体占用<code>O(n^2)</code>空间。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 平方阶（递归实现） */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">quadraticRecur</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 数组 nums 长度为 n, n-1, ..., 2, 1</span></span><br><span class="line">    <span class="type">int</span>[] nums = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    System.out.println(<span class="string">&quot;递归 n = &quot;</span> + n + <span class="string">&quot; 中的 nums 长度 = &quot;</span> + nums.length);</span><br><span class="line">    <span class="keyword">return</span> quadraticRecur(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://www.hello-algo.com/chapter_computational_complexity/space_complexity.assets/space_complexity_recursive_quadratic.png"></p>
<p><strong>指数阶<code>O(2^n)</code></strong></p>
<p>指数阶常见于二叉树。下图，高度为<code>n</code>的“满二叉树”的节点数量为<code>2^n - 1</code>，占用<code>O(2^n)</code>空间。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 指数阶（建立满二叉树） */</span></span><br><span class="line">TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(<span class="number">0</span>);</span><br><span class="line">    root.left = buildTree(n - <span class="number">1</span>);</span><br><span class="line">    root.right = buildTree(n - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://www.hello-algo.com/chapter_computational_complexity/space_complexity.assets/space_complexity_exponential.png"></p>
<p><strong>对数阶<code>O(logn)</code></strong></p>
<p>对数阶常见于分治算法。例如归并排序，输入长度为<code>n</code>的数组，每轮递归将数组从中点划分为两半，形成高度为<code>logn</code>的递归树，使用<code>O(logn)</code>栈帧空间。</p>
<h4 id="权衡时间与空间"><a href="#权衡时间与空间" class="headerlink" title="权衡时间与空间"></a>权衡时间与空间</h4><p>理想情况下，我们希望算法的时间复杂度和空间复杂度都能达到最优。然而在实际情况中，同时优化时间复杂度和空间复杂度通常是非常困难的。</p>
<p><strong>降低时间复杂度通常需要以提升空间复杂度为代价，反之亦然。</strong>在大多数情况下，时间比空间更宝贵，因此“以空间换时间”通常是更常用的策略。当然，在数据量很大的情况下，控制空间复杂度也是非常重要的。</p>
<hr>
<h2 id="3-数据结构"><a href="#3-数据结构" class="headerlink" title="3. 数据结构"></a>3. 数据结构</h2><p>常见的数据结构包括数组（<code>Array</code>）、链表（<code>List</code>）、栈（<code>Stack</code>）、队列（<code>Queue</code>）、哈希表（<code>Hash Table</code>）、树（<code>Tree</code>）、堆（<code>Heap</code>）、图（<code>Graph</code>），它们可以从“逻辑结构”和“物理结构”两个维度进行分类。</p>
<h3 id="3-1-数据结构分类"><a href="#3-1-数据结构分类" class="headerlink" title="3.1 数据结构分类"></a>3.1 数据结构分类</h3><p><strong>逻辑结构揭示了数据元素之间的逻辑关系</strong>。在数组和链表中，数据按照顺序依次排列，体现了数据之间的线性关系。而在树中，数据从顶部向下按层次排列，表现出祖先与后代之间的派生关系。图则由节点和边构成，反映了复杂的网络关系。</p>
<p>如下图所示，逻辑结构可被分为“线性”和“非线性”两大类。线性结构比较直观，指数据在逻辑关系上呈线性排列。非线性结构则相反，呈非线性排列。</p>
<ul>
<li>线性数据结构：数组、链表、栈、队列、哈希表。</li>
<li>非线性数据结构：树、堆、图、哈希表。</li>
</ul>
<p><img src="https://www.hello-algo.com/chapter_data_structure/classification_of_data_structure.assets/classification_logic_structure.png"></p>
<p>非线性数据结构可以进一步被划分为树形结构和网状结构。</p>
<ul>
<li>线性结构：数组、链表、队列、栈、哈希表，元素之间是一对一的顺序关系。</li>
<li>树形结构：树、堆、哈希表，元素之间是一对多的关系。</li>
<li>网状结构：图，元素之间是多对多的关系。</li>
</ul>
<p><strong>物理结构反映了数据在计算机内存中的存储方式</strong>。在算法运行过程中，数据都存储在内存中，系统通过内存地址来访问目标位置的数据。如下图所示，存储方式可分为连续空间存储和离散空间存储。</p>
<p><img src="https://www.hello-algo.com/chapter_data_structure/classification_of_data_structure.assets/classification_phisical_structure.png"></p>
<hr>
<h3 id="3-2-基本数据类型"><a href="#3-2-基本数据类型" class="headerlink" title="3.2 基本数据类型"></a>3.2 基本数据类型</h3><p>基本数据类型是<code>CPU</code>可以直接进行运算的类型，在算法中直接被使用。</p>
<ul>
<li>整数类型<code>byte</code>,<code>short</code>,<code>int</code>,<code>long</code>。</li>
<li>浮点数类型<code>float</code>,<code>double</code>，用于表示小数。</li>
<li>字符类型<code>char</code>，用于表示各种语言的字母、标点符号、甚至表情符号等。</li>
<li>布尔类型<code>bool</code>，用于表示“是”与“否”判断。</li>
</ul>
<p>基本数据类型以二进制的形式存储在计算机中。一个二进制位即为<code>1</code>比特。在绝大多数现代系统中，<code>1</code>字节（<code>byte</code>）由<code>8</code>比特（<code>bits</code>）组成。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Hongda-OSU/PicGo/image/pic4.png"></p>
<hr>
<h2 id="4-数组与链表"><a href="#4-数组与链表" class="headerlink" title="4. 数组与链表"></a>4. 数组与链表</h2><h3 id="4-1-数组"><a href="#4-1-数组" class="headerlink" title="4.1 数组"></a>4.1 数组</h3><p>「数组 <code>array</code>」是一种线性数据结构，其将相同类型元素存储在连续的内存空间中。而元素在数组中的位置称为该元素的「索引 <code>index</code>」。</p>
<p><img src="https://www.hello-algo.com/chapter_array_and_linkedlist/array.assets/array_definition.png"></p>
<h4 id="数组常用操作"><a href="#数组常用操作" class="headerlink" title="数组常用操作"></a>数组常用操作</h4><p>（1）初始化数组</p>
<p>可以根据需求选用数组的两种初始化方式，无初始值、给定初始值。在未指定初始值的情况下，大多数编程语言会将数组元素初始化为<code>0</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">array.java</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始化数组 */</span></span><br><span class="line"><span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">5</span>]; <span class="comment">// &#123; 0, 0, 0, 0, 0 &#125;</span></span><br><span class="line"><span class="type">int</span>[] nums = &#123; <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">4</span> &#125;;</span><br></pre></td></tr></table></figure>

<p>（2）访问元素</p>
<p>数组元素被存储在连续的内存空间中，这意味着计算数组元素的内存地址非常容易。给定数组内存地址（即首元素内存地址）和某个元素的索引，可以使用以下公式计算得到该元素的内存地址，从而直接访问此元素。</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line"># 元素内存地址 = 数组内存地址 + 元素长度 * 元素索引</span><br><span class="line">elementAddr = firtstElementAddr + elementLength * elementIndex</span><br></pre></td></tr></table></figure>

<p><img src="https://www.hello-algo.com/chapter_array_and_linkedlist/array.assets/array_memory_location_calculation.png"></p>
<p>在数组中访问元素是非常高效的，我们可以在<code>O(1)</code>时间内随机访问数组中的任意一个元素。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 随机访问元素 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">randomAccess</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="comment">// 在区间 [0, nums.length) 中随机抽取一个数字</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">randomIndex</span> <span class="operator">=</span> ThreadLocalRandom.current().nextInt(<span class="number">0</span>, nums.length);</span><br><span class="line">    <span class="comment">// 获取并返回随机元素</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">randomNum</span> <span class="operator">=</span> nums[randomIndex];</span><br><span class="line">    <span class="keyword">return</span> randomNum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（3）插入元素</p>
<p>数组元素在内存中是“紧挨着的”，它们之间没有空间再存放任何数据。如下图所示，如果想要在数组中间插入一个元素，则需要将该元素之后的所有元素都向后移动一位，之后再把元素赋值给该索引。</p>
<p><img src="https://www.hello-algo.com/chapter_array_and_linkedlist/array.assets/array_insert_element.png"></p>
<p>注意，由于数组的长度是固定的，因此插入一个元素必定会导致数组尾部元素的“丢失”。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 在数组的索引 index 处插入元素 num */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> num, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="comment">// 把索引 index 以及之后的所有元素向后移动一位</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> nums.length - <span class="number">1</span>; i &gt; index; i--) &#123;</span><br><span class="line">        nums[i] = nums[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将 num 赋给 index 处元素</span></span><br><span class="line">    nums[index] = num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（4）删除元素</p>
<p>同理，如下图所示，若想要删除索引<code>i</code>处的元素，则需要把索引<code>i</code>之后的元素都向前移动一位。</p>
<p><img src="https://www.hello-algo.com/chapter_array_and_linkedlist/array.assets/array_remove_element.png"></p>
<p>注意，删除元素完成后，原先末尾的元素变得“无意义”了，所以我们无须特意去修改它。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 删除索引 index 处元素 */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="comment">// 把索引 index 之后的所有元素向前移动一位</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index; i &lt; nums.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        nums[i] = nums[i + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总的来看，数组的插入与删除操作有以下缺点。</p>
<ul>
<li>时间复杂度高：数组的插入和删除的平均时间复杂度均为<code>O(n)</code>，其中<code>n</code>为数组长度。</li>
<li>丢失元素：由于数组的长度不可变，因此在插入元素后，超出数组长度范围的元素会丢失。</li>
<li>内存浪费：我们可以初始化一个比较长的数组，只用前面一部分，这样在插入数据时，丢失的末尾元素都是“无意义”的，但这样做也会造成部分内存空间的浪费。</li>
</ul>
<p>（5）遍历数组</p>
<p>大多数编程语言中，我们既可以通过索引遍历数组，也可以直接遍历获取数组中的每个元素。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 遍历数组 */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 通过索引遍历数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 直接遍历数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（6）查找元素</p>
<p>在数组中查找指定元素需要遍历数组，每轮判断元素值是否匹配，若匹配则输出对应索引。因为数组是线性数据结构，所以上述查找操作被称为“线性查找”。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 在数组中查找指定元素 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] == target)</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（7）扩容数组</p>
<p>大多数编程语言中，<strong>数组的长度是不可变的</strong>。如果希望扩容数组，则需重新建立一个更大的数组，然后把原数组元素依次拷贝到新数组。这是一个<code>O(n)</code>的操作，在数组很大的情况下是非常耗时。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 扩展数组长度 */</span></span><br><span class="line"><span class="type">int</span>[] extend(<span class="type">int</span>[] nums, <span class="type">int</span> enlarge) &#123;</span><br><span class="line">    <span class="comment">// 初始化一个扩展长度后的数组</span></span><br><span class="line">    <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length + enlarge];</span><br><span class="line">    <span class="comment">// 将原数组中的所有元素复制到新数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        res[i] = nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回扩展后的新数组</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="4-2-链表"><a href="#4-2-链表" class="headerlink" title="4.2 链表"></a>4.2 链表</h3><p>「链表 <code>linked list</code>」是一种线性数据结构，其中的每个元素都是一个节点对象，各个节点通过“引用”相连接。引用记录了下一个节点的内存地址，通过它可以从当前节点访问到下一个节点。</p>
<p>链表的设计使得各个节点可以被分散存储在内存各处，它们的内存地址是无须连续的。链表的组成单位是「节点 <code>node</code>」对象。每个节点都包含两项数据，节点的“值”和指向下一节点的“引用”。</p>
<p><img src="https://www.hello-algo.com/chapter_array_and_linkedlist/linked_list.assets/linkedlist_definition.png"></p>
<h4 id="链表常用操作"><a href="#链表常用操作" class="headerlink" title="链表常用操作"></a>链表常用操作</h4><p>（1）初始化链表</p>
<p>建立链表分为两步，第一步是初始化各个节点对象，第二步是构建引用指向关系。初始化完成后，就可以从链表的头节点出发，通过引用指向<code>next</code>依次访问所有节点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 初始化链表 1 -&gt; 3 -&gt; 2 -&gt; 5 -&gt; 4 */</span></span><br><span class="line"><span class="comment">// 初始化各个节点</span></span><br><span class="line"><span class="type">ListNode</span> <span class="variable">n0</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">1</span>);</span><br><span class="line"><span class="type">ListNode</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">3</span>);</span><br><span class="line"><span class="type">ListNode</span> <span class="variable">n2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">2</span>);</span><br><span class="line"><span class="type">ListNode</span> <span class="variable">n3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">5</span>);</span><br><span class="line"><span class="type">ListNode</span> <span class="variable">n4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">4</span>);</span><br><span class="line"><span class="comment">// 构建引用指向</span></span><br><span class="line">n0.next = n1;</span><br><span class="line">n1.next = n2;</span><br><span class="line">n2.next = n3;</span><br><span class="line">n3.next = n4;</span><br></pre></td></tr></table></figure>

<p>数组整体是一个变量，比如数组<code>nums</code>包含元素<code>nums[0]</code>，<code>nums[1]</code>等，而链表是由多个独立的节点对象组成的。我们通常将头节点当作链表的代称，比如以上代码中的链表可被记做链表<code>n0</code>。</p>
<p>（2）插入节点</p>
<p>在链表中插入节点非常容易。如下图所示，假设我们想在相邻的两个节点<code>n0</code>，<code>n1</code>之间插入一个新节点<code>P</code>，则只需要改变两个节点引用（指针）即可，时间复杂度为<code>O(1)</code>。</p>
<p>相比之下，在数组中插入元素的时间复杂度为<code>O(n)</code>，在大数据量下的效率较低。</p>
<p><img src="https://www.hello-algo.com/chapter_array_and_linkedlist/linked_list.assets/linkedlist_insert_node.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 在链表的节点 n0 之后插入节点 P */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(ListNode n0, ListNode P)</span> &#123;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">n1</span> <span class="operator">=</span> n0.next;</span><br><span class="line">    P.next = n1;</span><br><span class="line">    n0.next = P;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（3）删除节点</p>
<p>如下图所示，在链表中删除节点也非常方便，只需改变一个节点的引用（指针）即可。</p>
<p>虽然在删除操作完成后节点<code>P</code>仍然指向<code>n1</code>，但实际上遍历此链表已经无法访问到<code>P</code>，这意味着<code>P</code>已经不再属于该链表了。</p>
<p><img src="https://www.hello-algo.com/chapter_array_and_linkedlist/linked_list.assets/linkedlist_remove_node.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 删除链表的节点 n0 之后的首个节点 */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(ListNode n0)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n0.next == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// n0 -&gt; P -&gt; n1</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">P</span> <span class="operator">=</span> n0.next;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">n1</span> <span class="operator">=</span> P.next;</span><br><span class="line">    n0.next = n1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（4）访问节点</p>
<p>链表访问节点的效率较低。可以在<code>O(1)</code>时间下访问数组中的任意元素，链表则不行。程序需要从头节点出发，逐个向后遍历，直至找到目标节点。访问链表的第<code>n</code>个节点需要循环<code>n - 1</code>轮，时间复杂度为<code>O(n)</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 访问链表中索引为 index 的节点 */</span></span><br><span class="line">ListNode <span class="title function_">access</span><span class="params">(ListNode head, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; index; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        head = head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（5）查找节点</p>
<p>遍历链表，查找链表内值为<code>target</code>的节点，输出节点在链表中的索引。此过程也属于线性查找。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 在链表中查找值为 target 的首个节点 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">find</span><span class="params">(ListNode head, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (head != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (head.val == target)</span><br><span class="line">            <span class="keyword">return</span> index;</span><br><span class="line">        head = head.next;</span><br><span class="line">        index++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="数组-VS-链表"><a href="#数组-VS-链表" class="headerlink" title="数组 VS 链表"></a>数组 VS 链表</h4><p>下面是数组和链表的各项特点与操作效率。由于它们采用两种相反的存储策略，因此各种性质和操作效率也呈现对立的特点。</p>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left">数组</th>
<th align="left">链表</th>
</tr>
</thead>
<tbody><tr>
<td align="left">存储方式</td>
<td align="left">连续内存空间</td>
<td align="left">离散内存空间</td>
</tr>
<tr>
<td align="left">缓存局部性</td>
<td align="left">友好</td>
<td align="left">不友好</td>
</tr>
<tr>
<td align="left">容量扩展</td>
<td align="left">长度不可变</td>
<td align="left">可灵活扩展</td>
</tr>
<tr>
<td align="left">内存效率</td>
<td align="left">占用内存少、浪费部分空间</td>
<td align="left">占用内存多</td>
</tr>
<tr>
<td align="left">访问元素</td>
<td align="left"><code>O(1)</code></td>
<td align="left"><code>O(n)</code></td>
</tr>
<tr>
<td align="left">添加元素</td>
<td align="left"><code>O(n)</code></td>
<td align="left"><code>O(1)</code></td>
</tr>
<tr>
<td align="left">删除元素</td>
<td align="left"><code>O(n)</code></td>
<td align="left"><code>O(1)</code></td>
</tr>
</tbody></table>
<h4 id="常见链表类型"><a href="#常见链表类型" class="headerlink" title="常见链表类型"></a>常见链表类型</h4><ul>
<li><strong>单向链表</strong>：即普通链表。单向链表的节点包含值和指向下一节点的引用两项数据。我们将首个节点称为头节点，将最后一个节点成为尾节点，尾节点指向空<code>Node</code>。</li>
<li><strong>环形链表</strong>：如果我们令单向链表的尾节点指向头节点（即首尾相接），则得到一个环形链表。在环形链表中，任意节点都可以视作头节点。</li>
<li><strong>双向链表</strong>：与单向链表相比，双向链表记录了两个方向的引用。双向链表的节点定义同时包含指向后继节点（下一个节点）和前驱节点（上一个节点）的引用（指针）。相较于单向链表，双向链表更具灵活性，可以朝两个方向遍历链表，但相应地也需要占用更多的内存空间。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 双向链表节点类 */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;        <span class="comment">// 节点值</span></span><br><span class="line">    ListNode next;  <span class="comment">// 指向后继节点的引用</span></span><br><span class="line">    ListNode prev;  <span class="comment">// 指向前驱节点的引用</span></span><br><span class="line">    ListNode(<span class="type">int</span> x) &#123; val = x; &#125;  <span class="comment">// 构造函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://www.hello-algo.com/chapter_array_and_linkedlist/linked_list.assets/linkedlist_common_types.png"></p>
<hr>
<h3 id="4-3-列表"><a href="#4-3-列表" class="headerlink" title="4.3 列表"></a>4.3 列表</h3><p>「动态数组 <code>dynamic array</code>」是长度可变的数组，也常被称为「列表 <code>list</code>」。它基于数组实现，继承了数组的优点，并且可以在程序运行过程中动态扩容。可以在列表中自由地添加元素，而无须担心超过容量限制。</p>
<h4 id="列表常用操作"><a href="#列表常用操作" class="headerlink" title="列表常用操作"></a>列表常用操作</h4><p>（1）初始化列表</p>
<p>可以使用“无初始值”和“有初始值”这两种初始化方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 初始化列表 */</span></span><br><span class="line"><span class="comment">// 无初始值</span></span><br><span class="line">List&lt;Integer&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="comment">// 有初始值（注意数组的元素类型需为 int[] 的包装类 Integer[]）</span></span><br><span class="line">Integer[] numbers = <span class="keyword">new</span> <span class="title class_">Integer</span>[] &#123; <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">4</span> &#125;;</span><br><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(numbers));</span><br></pre></td></tr></table></figure>

<p>（2）访问元素</p>
<p>列表本质上是数组，因此可以在<code>O(1)</code>时间内访问和更新元素，效率很高。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 访问元素 */</span></span><br><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> list.get(<span class="number">1</span>);  <span class="comment">// 访问索引 1 处的元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 更新元素 */</span></span><br><span class="line">list.set(<span class="number">1</span>, <span class="number">0</span>);  <span class="comment">// 将索引 1 处的元素更新为 0</span></span><br></pre></td></tr></table></figure>

<p>（3）插入与删除元素</p>
<p>相较于数组，列表可以自由地添加与删除元素。在列表尾部添加元素的时间复杂度为<code>O(1)</code>，但插入和删除元素的效率仍与数组相同，时间复杂度为<code>O(n)</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 清空列表 */</span></span><br><span class="line">list.clear();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 尾部添加元素 */</span></span><br><span class="line">list.add(<span class="number">1</span>);</span><br><span class="line">list.add(<span class="number">3</span>);</span><br><span class="line">list.add(<span class="number">2</span>);</span><br><span class="line">list.add(<span class="number">5</span>);</span><br><span class="line">list.add(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 中间插入元素 */</span></span><br><span class="line">list.add(<span class="number">3</span>, <span class="number">6</span>);  <span class="comment">// 在索引 3 处插入数字 6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 删除元素 */</span></span><br><span class="line">list.remove(<span class="number">3</span>);  <span class="comment">// 删除索引 3 处的元素</span></span><br></pre></td></tr></table></figure>

<p>（4）遍历列表</p>
<p>与数组一样，列表可以根据索引遍历，也可以直接遍历各元素。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 通过索引遍历列表 */</span></span><br><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">    count++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 直接遍历列表元素 */</span></span><br><span class="line">count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> n : list) &#123;</span><br><span class="line">    count++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（5）拼接列表</p>
<p>给定一个新列表<code>list1</code>，我们可以将该列表拼接到原列表的尾部。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 拼接两个列表 */</span></span><br><span class="line">List&lt;Integer&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(<span class="keyword">new</span> <span class="title class_">Integer</span>[] &#123; <span class="number">6</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">10</span>, <span class="number">9</span> &#125;));</span><br><span class="line">list.addAll(list1);  <span class="comment">// 将列表 list1 拼接到 list 之后</span></span><br></pre></td></tr></table></figure>

<p>（6）排序列表</p>
<p>完成列表排序后，便可以使用在数组类算法题中经常考察的“二分查找”和“双指针”算法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 排序列表 */</span></span><br><span class="line">Collections.sort(list);  <span class="comment">// 排序后，列表元素从小到大排列</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="5-栈与队列"><a href="#5-栈与队列" class="headerlink" title="5. 栈与队列"></a>5. 栈与队列</h2><h3 id="5-1-栈"><a href="#5-1-栈" class="headerlink" title="5.1 栈"></a>5.1 栈</h3><p>「栈 <code>stack</code>」是一种遵循先入后出<code>First In，Last Out</code>的逻辑的线性数据结构。我们可以将栈类比为桌面上的一摞盘子，<ins>如果需要拿出底部的盘子，则需要先将上面的盘子依次取出</ins>。</p>
<p><img src="https://www.hello-algo.com/chapter_stack_and_queue/stack.assets/stack_operations.png"></p>
<h4 id="栈常用操作"><a href="#栈常用操作" class="headerlink" title="栈常用操作"></a>栈常用操作</h4><p>栈的常用操作如下表所示，具体的方法名需要根据所使用的编程语言来确定。我们以常见的<code>push()</code>、<code>pop()</code>、<code>peek()</code>命名为例。</p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">描述</th>
<th align="left">时间复杂度</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>push()</code></td>
<td align="left">元素入栈（添加至栈顶）</td>
<td align="left"><code>O(1)</code></td>
</tr>
<tr>
<td align="left"><code>pop()</code></td>
<td align="left">栈顶元素出栈</td>
<td align="left"><code>O(1)</code></td>
</tr>
<tr>
<td align="left"><code>peek()</code></td>
<td align="left">访问栈顶元素</td>
<td align="left"><code>O(1)</code></td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 初始化栈 */</span></span><br><span class="line">Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 元素入栈 */</span></span><br><span class="line">stack.push(<span class="number">1</span>);</span><br><span class="line">stack.push(<span class="number">3</span>);</span><br><span class="line">stack.push(<span class="number">2</span>);</span><br><span class="line">stack.push(<span class="number">5</span>);</span><br><span class="line">stack.push(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 访问栈顶元素 */</span></span><br><span class="line"><span class="type">int</span> <span class="variable">peek</span> <span class="operator">=</span> stack.peek();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 元素出栈 */</span></span><br><span class="line"><span class="type">int</span> <span class="variable">pop</span> <span class="operator">=</span> stack.pop();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取栈的长度 */</span></span><br><span class="line"><span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> stack.size();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 判断是否为空 */</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">isEmpty</span> <span class="operator">=</span> stack.isEmpty();</span><br></pre></td></tr></table></figure>

<h4 id="栈简单实现"><a href="#栈简单实现" class="headerlink" title="栈简单实现"></a>栈简单实现</h4><p>栈遵循先入后出的原则，因此只能在栈顶添加或删除元素。我们可以使用链表来实现栈。将链表的头节点视为栈顶，尾节点视为栈底。对于入栈操作，只需将元素插入链表头部，这种节点插入方法被称为“头插法”。而对于出栈操作，只需将头节点从链表中删除即可。</p>
<div class="tabs" id="placeholder"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#placeholder-1">LinkedListStack</button></li><li class="tab"><button type="button" data-href="#placeholder-2">push()</button></li><li class="tab"><button type="button" data-href="#placeholder-3">pop()</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="placeholder-1"><p><img src="https://www.hello-algo.com/chapter_stack_and_queue/stack.assets/linkedlist_stack.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="placeholder-2"><p><img src="https://www.hello-algo.com/chapter_stack_and_queue/stack.assets/linkedlist_stack_push.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="placeholder-3"><p><img src="https://www.hello-algo.com/chapter_stack_and_queue/stack.assets/linkedlist_stack_pop.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 基于链表实现的栈 */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LinkedListStack</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> ListNode stackPeek; <span class="comment">// 将头节点作为栈顶</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">stkSize</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 栈的长度</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LinkedListStack</span><span class="params">()</span> &#123;</span><br><span class="line">        stackPeek = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取栈的长度 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> stkSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 判断栈是否为空 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> size() == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 入栈 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(num);</span><br><span class="line">        node.next = stackPeek;</span><br><span class="line">        stackPeek = node;</span><br><span class="line">        stkSize++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 出栈 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> peek();</span><br><span class="line">        stackPeek = stackPeek.next;</span><br><span class="line">        stkSize--;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 访问栈顶元素 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">peek</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (size() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>();</span><br><span class="line">        <span class="keyword">return</span> stackPeek.val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 将 List 转化为 Array 并返回 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] toArray() &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">node</span> <span class="operator">=</span> stackPeek;</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[size()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> res.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            res[i] = node.val;</span><br><span class="line">            node = node.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="5-2-队列"><a href="#5-2-队列" class="headerlink" title="5.2 队列"></a>5.2 队列</h3><p>「队列 <code>queue</code>」是一种遵循先入先出<code>First In, First Out</code>规则的线性数据结构。顾名思义，<ins>队列模拟了排队现象，即新来的人不断加入队列的尾部，而位于队列头部的人逐个离开</ins>。</p>
<p><img src="https://www.hello-algo.com/chapter_stack_and_queue/queue.assets/queue_operations.png"></p>
<h4 id="队列常用操作"><a href="#队列常用操作" class="headerlink" title="队列常用操作"></a>队列常用操作</h4><p>队列的常用操作如下表所示，具体的方法名需要根据所使用的编程语言来确定。我们以常见的<code>push()</code>、<code>pop()</code>、<code>peek()</code>命名为例。</p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">描述</th>
<th align="left">时间复杂度</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>push()</code></td>
<td align="left">元素入队，即将元素添加至队尾</td>
<td align="left"><code>O(1)</code></td>
</tr>
<tr>
<td align="left"><code>pop()</code></td>
<td align="left">队首元素出队</td>
<td align="left"><code>O(1)</code></td>
</tr>
<tr>
<td align="left"><code>peek()</code></td>
<td align="left">访问队首元素</td>
<td align="left"><code>O(1)</code></td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 初始化队列 */</span></span><br><span class="line">Queue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 元素入队 */</span></span><br><span class="line">queue.offer(<span class="number">1</span>);</span><br><span class="line">queue.offer(<span class="number">3</span>);</span><br><span class="line">queue.offer(<span class="number">2</span>);</span><br><span class="line">queue.offer(<span class="number">5</span>);</span><br><span class="line">queue.offer(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 访问队首元素 */</span></span><br><span class="line"><span class="type">int</span> <span class="variable">peek</span> <span class="operator">=</span> queue.peek();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 元素出队 */</span></span><br><span class="line"><span class="type">int</span> <span class="variable">pop</span> <span class="operator">=</span> queue.poll();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取队列的长度 */</span></span><br><span class="line"><span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 判断队列是否为空 */</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">isEmpty</span> <span class="operator">=</span> queue.isEmpty();</span><br></pre></td></tr></table></figure>

<h4 id="队列简单实现"><a href="#队列简单实现" class="headerlink" title="队列简单实现"></a>队列简单实现</h4><p>为了实现队列，需要一种数据结构，可以在一端添加元素，并在另一端删除元素。我们可以使用链表来实现队列。将链表的“头节点”和“尾节点”分别视为“队首”和“队尾”，规定队尾仅可添加节点，队首仅可删除节点。</p>
<div class="tabs" id="placeholder"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#placeholder-1">LinkedListQueue</button></li><li class="tab"><button type="button" data-href="#placeholder-2">push()</button></li><li class="tab"><button type="button" data-href="#placeholder-3">pop()</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="placeholder-1"><p><img src="https://www.hello-algo.com/chapter_stack_and_queue/queue.assets/linkedlist_queue.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="placeholder-2"><p><img src="https://www.hello-algo.com/chapter_stack_and_queue/queue.assets/linkedlist_queue_push.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="placeholder-3"><p><img src="https://www.hello-algo.com/chapter_stack_and_queue/queue.assets/linkedlist_queue_pop.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 基于链表实现的队列 */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LinkedListQueue</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> ListNode front, rear; <span class="comment">// 头节点 front ，尾节点 rear</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">queSize</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LinkedListQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        front = <span class="literal">null</span>;</span><br><span class="line">        rear = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取队列的长度 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> queSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 判断队列是否为空 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> size() == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 入队 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="comment">// 尾节点后添加 num</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(num);</span><br><span class="line">        <span class="comment">// 如果队列为空，则令头、尾节点都指向该节点</span></span><br><span class="line">        <span class="keyword">if</span> (front == <span class="literal">null</span>) &#123;</span><br><span class="line">            front = node;</span><br><span class="line">            rear = node;</span><br><span class="line">        <span class="comment">// 如果队列不为空，则将该节点添加到尾节点后</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            rear.next = node;</span><br><span class="line">            rear = node;</span><br><span class="line">        &#125;</span><br><span class="line">        queSize++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 出队 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> peek();</span><br><span class="line">        <span class="comment">// 删除头节点</span></span><br><span class="line">        front = front.next;</span><br><span class="line">        queSize--;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 访问队首元素 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">peek</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (size() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>();</span><br><span class="line">        <span class="keyword">return</span> front.val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 将链表转化为 Array 并返回 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] toArray() &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">node</span> <span class="operator">=</span> front;</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[size()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; res.length; i++) &#123;</span><br><span class="line">            res[i] = node.val;</span><br><span class="line">            node = node.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="5-3-双向队列"><a href="#5-3-双向队列" class="headerlink" title="5.3 双向队列"></a>5.3 双向队列</h3><p>在队列中，我们仅能在头部删除或在尾部添加元素。如下图所示，「双向队列 <code>deque</code>」提供了更高的灵活性，<ins>允许在头部和尾部执行元素的添加或删除操作</ins>。</p>
<p><img src="https://www.hello-algo.com/chapter_stack_and_queue/deque.assets/deque_operations.png"></p>
<h4 id="双向队列常用操作"><a href="#双向队列常用操作" class="headerlink" title="双向队列常用操作"></a>双向队列常用操作</h4><p>双向队列的常用操作如下表所示。</p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">描述</th>
<th align="left">时间复杂度</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>pushFirst()</code></td>
<td align="left">将元素添加至队首</td>
<td align="left"><code>O(1)</code></td>
</tr>
<tr>
<td align="left"><code>pushLast()</code></td>
<td align="left">将元素添加至队尾</td>
<td align="left"><code>O(1)</code></td>
</tr>
<tr>
<td align="left"><code>popFirst()</code></td>
<td align="left">删除队首元素</td>
<td align="left"><code>O(1)</code></td>
</tr>
<tr>
<td align="left"><code>popLast()</code></td>
<td align="left">删除队尾元素</td>
<td align="left"><code>O(1)</code></td>
</tr>
<tr>
<td align="left"><code>peekFirst()</code></td>
<td align="left">访问队首元素</td>
<td align="left"><code>O(1)</code></td>
</tr>
<tr>
<td align="left"><code>peekLast()</code></td>
<td align="left">访问队尾元素</td>
<td align="left"><code>O(1)</code></td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 初始化双向队列 */</span></span><br><span class="line">Deque&lt;Integer&gt; deque = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 元素入队 */</span></span><br><span class="line">deque.offerLast(<span class="number">2</span>);   <span class="comment">// 添加至队尾</span></span><br><span class="line">deque.offerLast(<span class="number">5</span>);</span><br><span class="line">deque.offerLast(<span class="number">4</span>);</span><br><span class="line">deque.offerFirst(<span class="number">3</span>);  <span class="comment">// 添加至队首</span></span><br><span class="line">deque.offerFirst(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 访问元素 */</span></span><br><span class="line"><span class="type">int</span> <span class="variable">peekFirst</span> <span class="operator">=</span> deque.peekFirst();  <span class="comment">// 队首元素</span></span><br><span class="line"><span class="type">int</span> <span class="variable">peekLast</span> <span class="operator">=</span> deque.peekLast();    <span class="comment">// 队尾元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 元素出队 */</span></span><br><span class="line"><span class="type">int</span> <span class="variable">popFirst</span> <span class="operator">=</span> deque.pollFirst();  <span class="comment">// 队首元素出队</span></span><br><span class="line"><span class="type">int</span> <span class="variable">popLast</span> <span class="operator">=</span> deque.pollLast();    <span class="comment">// 队尾元素出队</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取双向队列的长度 */</span></span><br><span class="line"><span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> deque.size();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 判断双向队列是否为空 */</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">isEmpty</span> <span class="operator">=</span> deque.isEmpty();</span><br></pre></td></tr></table></figure>

<h4 id="双向队列简单实现"><a href="#双向队列简单实现" class="headerlink" title="双向队列简单实现"></a>双向队列简单实现</h4><p>对于双向队列而言，头部和尾部都可以执行入队和出队操作。换句话说，双向队列需要实现另一个对称方向的操作。为此，我们采用“双向链表”作为双向队列的底层数据结构。</p>
<div class="tabs" id="placeholder"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#placeholder-1">LinkedListDeque</button></li><li class="tab"><button type="button" data-href="#placeholder-2">pushLast()</button></li><li class="tab"><button type="button" data-href="#placeholder-3">pushFirst()</button></li><li class="tab"><button type="button" data-href="#placeholder-4">popLast()</button></li><li class="tab"><button type="button" data-href="#placeholder-5">popFirst()</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="placeholder-1"><p><img src="https://www.hello-algo.com/chapter_stack_and_queue/deque.assets/linkedlist_deque.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="placeholder-2"><p><img src="https://www.hello-algo.com/chapter_stack_and_queue/deque.assets/linkedlist_deque_push_last.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="placeholder-3"><p><img src="https://www.hello-algo.com/chapter_stack_and_queue/deque.assets/linkedlist_deque_push_first.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="placeholder-4"><p><img src="https://www.hello-algo.com/chapter_stack_and_queue/deque.assets/linkedlist_deque_pop_last.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="placeholder-5"><p><img src="https://www.hello-algo.com/chapter_stack_and_queue/deque.assets/linkedlist_deque_pop_first.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>

<p>由于实现比较复杂，这里暂时不记实现方法。</p>
<hr>
<h2 id="6-哈希表"><a href="#6-哈希表" class="headerlink" title="6. 哈希表"></a>6. 哈希表</h2><h3 id="6-1-哈希表"><a href="#6-1-哈希表" class="headerlink" title="6.1 哈希表"></a>6.1 哈希表</h3><p>「哈希表 <code>hash table</code>」，通过建立键<code>key</code>与值<code>value</code>之间的映射，实现高效的元素查询。简单来说，向哈希表输入一个键<code>key</code>，就可以在<code>O(1)</code>时间内获取对应的值<code>value</code>。</p>
<p>如下图所示，给定<code>n</code>个学生，每个学生都有“姓名”和“学号”两项数据。假如我们希望实现“输入一个学号，返回对应的姓名”的查询功能，则可以采用下图所示的哈希表来实现。</p>
<p><img src="https://www.hello-algo.com/chapter_hashing/hash_map.assets/hash_table_lookup.png"></p>
<p>除哈希表外，数组和链表也可以实现查询功能，它们的效率对比如下表所示。</p>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left">数组</th>
<th align="left">链表</th>
<th align="left">哈希表</th>
</tr>
</thead>
<tbody><tr>
<td align="left">查找元素</td>
<td align="left"><code>O(n)</code></td>
<td align="left"><code>O(n)</code></td>
<td align="left"><code>O(1)</code></td>
</tr>
<tr>
<td align="left">添加元素</td>
<td align="left"><code>O(1)</code></td>
<td align="left"><code>O(1)</code></td>
<td align="left"><code>O(1)</code></td>
</tr>
<tr>
<td align="left">删除元素</td>
<td align="left"><code>O(n)</code></td>
<td align="left"><code>O(n)</code></td>
<td align="left"><code>O(1)</code></td>
</tr>
</tbody></table>
<p>观察发现，在哈希表中进行增删查改的时间复杂度都是<code>O(1)</code>，非常高效。</p>
<h4 id="哈希表常用操作"><a href="#哈希表常用操作" class="headerlink" title="哈希表常用操作"></a>哈希表常用操作</h4><p>哈希表的常见操作包括，初始化、查询操作<code>get(key)</code>、添加键值对<code>put(key, value)</code>和删除键值对<code>remove(key)</code>等。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 初始化哈希表 */</span></span><br><span class="line">Map&lt;Integer, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 添加操作 */</span></span><br><span class="line"><span class="comment">// 在哈希表中添加键值对 (key, value)</span></span><br><span class="line">map.put(<span class="number">12836</span>, <span class="string">&quot;小哈&quot;</span>);</span><br><span class="line">map.put(<span class="number">15937</span>, <span class="string">&quot;小啰&quot;</span>);</span><br><span class="line">map.put(<span class="number">16750</span>, <span class="string">&quot;小算&quot;</span>);</span><br><span class="line">map.put(<span class="number">13276</span>, <span class="string">&quot;小法&quot;</span>);</span><br><span class="line">map.put(<span class="number">10583</span>, <span class="string">&quot;小鸭&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 查询操作 */</span></span><br><span class="line"><span class="comment">// 向哈希表输入键 key ，得到值 value</span></span><br><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> map.get(<span class="number">15937</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 删除操作 */</span></span><br><span class="line"><span class="comment">// 在哈希表中删除键值对 (key, value)</span></span><br><span class="line">map.remove(<span class="number">10583</span>);</span><br></pre></td></tr></table></figure>

<p>哈希表有三种常用遍历方式，遍历键值对、遍历键和遍历值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 遍历哈希表 */</span></span><br><span class="line"><span class="comment">// 遍历键值对 key-&gt;value</span></span><br><span class="line"><span class="keyword">for</span> (Map.Entry &lt;Integer, String&gt; kv: map.entrySet()) &#123;</span><br><span class="line">    System.out.println(kv.getKey() + <span class="string">&quot; -&gt; &quot;</span> + kv.getValue());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 单独遍历键 key</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> key: map.keySet()) &#123;</span><br><span class="line">    System.out.println(key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 单独遍历值 value</span></span><br><span class="line"><span class="keyword">for</span> (String val: map.values()) &#123;</span><br><span class="line">    System.out.println(val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="哈希表简单实现"><a href="#哈希表简单实现" class="headerlink" title="哈希表简单实现"></a>哈希表简单实现</h4><p>我们可以用数组来实现哈希表。在哈希表中，数组中的每个空位称为「桶 <code>bucket</code>」，每个桶可存储一个键值对。因此，查询操作就是找到<code>key</code>对应的桶，并在桶中获取<code>value</code>。</p>
<p>那怎么基于<code>key</code>来定位对应的桶呢？这是通过「哈希函数 <code>hash function</code>」实现的。在哈希表中输入一个<code>key</code>，可以通过哈希函数得到该<code>key</code>对应的键值对在数组中的存储位置。计算过程分为两步。</p>
<ul>
<li>通过某种哈希算法<code>hash()</code>计算得到哈希值。</li>
<li>将哈希值对桶数量（数组长度）<code>capacity</code>取模，从而获取该<code>key</code>对应的数组索引<code>index</code>。</li>
</ul>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">index = hash(key) % capacity</span><br></pre></td></tr></table></figure>

<p>随后，就可以利用<code>index</code>在哈希表中访问对应的桶，从而获取<code>value</code>。</p>
<p>设数组长度<code>capacity = 100</code>、哈希算法<code>hash(key) = key</code>，哈希函数为<code>key % 100</code>。下图以<code>key</code>学号和<code>value</code>姓名为例，展示了哈希函数的工作原理。</p>
<p><img src="https://www.hello-algo.com/chapter_hashing/hash_map.assets/hash_function.png"></p>
<p>下面代码实现了一个简单哈希表。将<code>key</code>和<code>value</code>封装成一个类<code>Pair</code>，以表示键值对。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 键值对 */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Pair</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> key;</span><br><span class="line">    <span class="keyword">public</span> String val;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Pair</span><span class="params">(<span class="type">int</span> key, String val)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.key = key;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 基于数组简易实现的哈希表 */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ArrayHashMap</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Pair&gt; buckets;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArrayHashMap</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 初始化数组，包含 100 个桶</span></span><br><span class="line">        buckets = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            buckets.add(<span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 哈希函数 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">hashFunc</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> key % <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 查询操作 */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">get</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> hashFunc(key);</span><br><span class="line">        <span class="type">Pair</span> <span class="variable">pair</span> <span class="operator">=</span> buckets.get(index);</span><br><span class="line">        <span class="keyword">if</span> (pair == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">return</span> pair.val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 添加操作 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> key, String val)</span> &#123;</span><br><span class="line">        <span class="type">Pair</span> <span class="variable">pair</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Pair</span>(key, val);</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> hashFunc(key);</span><br><span class="line">        buckets.set(index, pair);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 删除操作 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> hashFunc(key);</span><br><span class="line">        <span class="comment">// 置为 null ，代表删除</span></span><br><span class="line">        buckets.set(index, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取所有键值对 */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Pair&gt; <span class="title function_">pairSet</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;Pair&gt; pairSet = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Pair pair : buckets) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pair != <span class="literal">null</span>)</span><br><span class="line">                pairSet.add(pair);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pairSet;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取所有键 */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">keySet</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; keySet = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Pair pair : buckets) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pair != <span class="literal">null</span>)</span><br><span class="line">                keySet.add(pair.key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> keySet;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取所有值 */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">valueSet</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;String&gt; valueSet = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Pair pair : buckets) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pair != <span class="literal">null</span>)</span><br><span class="line">                valueSet.add(pair.val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> valueSet;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 打印哈希表 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Pair kv : pairSet()) &#123;</span><br><span class="line">            System.out.println(kv.key + <span class="string">&quot; -&gt; &quot;</span> + kv.val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="哈希冲突与扩容"><a href="#哈希冲突与扩容" class="headerlink" title="哈希冲突与扩容"></a>哈希冲突与扩容</h4><p>本质上看，哈希函数的作用是将所有<code>key</code>构成的输入空间映射到数组所有索引构成的输出空间，而输入空间往往远大于输出空间。因此，理论上一定存在“多个输入对应相同输出”的情况。</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">12836 % 100 = 36</span><br><span class="line">20336 % 100 = 36</span><br></pre></td></tr></table></figure>

<p>如下图所示，两个学号指向了同一个姓名，这显然是不对的。我们将这种多个输入对应同一输出的情况称为「哈希冲突 <code>hash collision</code>」。</p>
<p><img src="https://www.hello-algo.com/chapter_hashing/hash_map.assets/hash_collision.png"></p>
<p>简单来说，可以通过扩容哈希表来减少哈希冲突。因为哈希表容量<code>n</code>越大，多个<code>key</code>被分配到同一个桶中的概率就越低，冲突就越少。如下图所示，扩容前键值对<code>(136, A)</code>和<code>(236, D)</code>发生冲突，扩容后冲突消失。</p>
<p><img src="https://www.hello-algo.com/chapter_hashing/hash_map.assets/hash_table_reshash.png"></p>
<p>类似于数组扩容，哈希表扩容需将所有键值对从原哈希表迁移至新哈希表，非常耗时。并且由于哈希表容量<code>capacity</code>改变，需要通过哈希函数来重新计算所有键值对的存储位置，这进一步提高了扩容过程的计算开销。</p>
<p>由于<a target="_blank" rel="noopener" href="https://www.hello-algo.com/chapter_hashing/hash_collision/">哈希冲突</a>和<a target="_blank" rel="noopener" href="https://www.hello-algo.com/chapter_hashing/hash_algorithm/">哈希算法</a>比较复杂，这里就不做过多解释，可以自行阅读。</p>
<hr>
<h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><blockquote>
<p>文件还未上传 Github</p>
</blockquote>
</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E7%AE%97%E6%B3%95/">算法</a></div><div class="post_share"></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/cd5cb147.html" title="C# 关键字解析"><img class="cover" src="https://cdn.jsdelivr.net/gh/Hongda-OSU/PicGo/image/克鲁赛德战记2.jpg" onerror="onerror=null;src='https://cdn.jsdelivr.net/gh/Hongda-OSU/PicGo/image/404.GIF'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">C# 关键字解析</div></div></a></div><div class="next-post pull-right"><a href="/posts/e90cdaa3.html" title="算法 Algorithm • 中"><img class="cover" src="https://cdn.jsdelivr.net/gh/Hongda-OSU/PicGo/image/克鲁赛德战记1.jpg" onerror="onerror=null;src='https://cdn.jsdelivr.net/gh/Hongda-OSU/PicGo/image/404.GIF'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">算法 Algorithm • 中</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/3b015f5e.html" title="算法 Algorithm • 下"><img class="cover" src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/imgodr8vukcwco0h34p0ngc84462vs454j.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-09-16</div><div class="title">算法 Algorithm • 下</div></div></a></div><div><a href="/posts/e90cdaa3.html" title="算法 Algorithm • 中"><img class="cover" src="https://cdn.jsdelivr.net/gh/Hongda-OSU/PicGo/image/克鲁赛德战记1.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-09-06</div><div class="title">算法 Algorithm • 中</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://cdn.jsdelivr.net/gh/Hongda-OSU/PicGo/image/德狗子.GIF" onerror="this.onerror=null;this.src='https://cdn.jsdelivr.net/gh/Hongda-OSU/PicGo/image/404.GIF'" alt="avatar"/></div><div class="author-info__name">鴻達</div><div class="author-info__description">活著</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">13</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">7</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Hongda-OSU" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="https://www.linkedin.com/in/hongda-lin" target="_blank" title="Linkedin"><i class="fab fa-linkedin"></i></a><a class="social-icon" href="https://hongdalin.me" target="_blank" title="Portfolio"><i class="iconfont icon-guanfangwangzhan"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">文章右下角小工具进入阅读模式</div></div><div class="xpand" style="height:200px;"><canvas class="illo" width="800" height="800" style="max-width: 200px; max-height: 200px; touch-action: none; width: 640px; height: 640px;"></canvas></div><script src="https://npm.elemecdn.com/ethan4116-blog/lib/js/other/two-people/twopeople1.js"></script><script src="https://npm.elemecdn.com/ethan4116-blog/lib/js/other/two-people/zdog.dist.js"></script><script id="rendered-js" src="https://npm.elemecdn.com/ethan4116-blog/lib/js/other/two-people/twopeople.js"></script><style>.card-widget.card-announcement {
margin: 0;
align-items: center;
justify-content: center;
text-align: center;
}
canvas {
display: block;
margin: 0 auto;
cursor: move;
}</style><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%88%9D%E8%AF%86%E7%AE%97%E6%B3%95"><span class="toc-text">1. 初识算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-text">2. 复杂度</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E8%BF%AD%E4%BB%A3%E4%B8%8E%E9%80%92%E5%BD%92"><span class="toc-text">2.1 迭代与递归</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-text">2.2 时间复杂度</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%B8%90%E8%BF%91%E4%B8%8A%E7%95%8C"><span class="toc-text">函数渐近上界</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A8%E7%AE%97%E6%96%B9%E6%B3%95"><span class="toc-text">推算方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%B1%BB%E5%9E%8B"><span class="toc-text">常见类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E5%B7%AE%E3%80%81%E6%9C%80%E4%BD%B3%E3%80%81%E5%B9%B3%E5%9D%87"><span class="toc-text">最差、最佳、平均</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-text">2.3 空间复杂度</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A8%E7%AE%97%E6%96%B9%E6%B3%95-1"><span class="toc-text">推算方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%B1%BB%E5%9E%8B-1"><span class="toc-text">常见类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%83%E8%A1%A1%E6%97%B6%E9%97%B4%E4%B8%8E%E7%A9%BA%E9%97%B4"><span class="toc-text">权衡时间与空间</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-text">3. 数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%88%86%E7%B1%BB"><span class="toc-text">3.1 数据结构分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text">3.2 基本数据类型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E6%95%B0%E7%BB%84%E4%B8%8E%E9%93%BE%E8%A1%A8"><span class="toc-text">4. 数组与链表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E6%95%B0%E7%BB%84"><span class="toc-text">4.1 数组</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C"><span class="toc-text">数组常用操作</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E9%93%BE%E8%A1%A8"><span class="toc-text">4.2 链表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C"><span class="toc-text">链表常用操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84-VS-%E9%93%BE%E8%A1%A8"><span class="toc-text">数组 VS 链表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E9%93%BE%E8%A1%A8%E7%B1%BB%E5%9E%8B"><span class="toc-text">常见链表类型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-%E5%88%97%E8%A1%A8"><span class="toc-text">4.3 列表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%97%E8%A1%A8%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C"><span class="toc-text">列表常用操作</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97"><span class="toc-text">5. 栈与队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-%E6%A0%88"><span class="toc-text">5.1 栈</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%88%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C"><span class="toc-text">栈常用操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%88%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0"><span class="toc-text">栈简单实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-%E9%98%9F%E5%88%97"><span class="toc-text">5.2 队列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%9F%E5%88%97%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C"><span class="toc-text">队列常用操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%9F%E5%88%97%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0"><span class="toc-text">队列简单实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-%E5%8F%8C%E5%90%91%E9%98%9F%E5%88%97"><span class="toc-text">5.3 双向队列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8C%E5%90%91%E9%98%9F%E5%88%97%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C"><span class="toc-text">双向队列常用操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8C%E5%90%91%E9%98%9F%E5%88%97%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0"><span class="toc-text">双向队列简单实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="toc-text">6. 哈希表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="toc-text">6.1 哈希表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E8%A1%A8%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C"><span class="toc-text">哈希表常用操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E8%A1%A8%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0"><span class="toc-text">哈希表简单实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81%E4%B8%8E%E6%89%A9%E5%AE%B9"><span class="toc-text">哈希冲突与扩容</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%99%84%E5%BD%95"><span class="toc-text">附录</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/b7fb4495.html" title="游戏音乐 👾"><img src="https://cdn.jsdelivr.net/gh/Hongda-OSU/PicGo/image/dfcjswnw17cl1hrwz9tz8n1hgf1m8dv.jpg" onerror="this.onerror=null;this.src='https://cdn.jsdelivr.net/gh/Hongda-OSU/PicGo/image/404.GIF'" alt="游戏音乐 👾"/></a><div class="content"><a class="title" href="/posts/b7fb4495.html" title="游戏音乐 👾">游戏音乐 👾</a><time datetime="2024-06-23T15:15:05.000Z" title="发表于 2024-06-23 10:15:05">2024-06-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/eb0c992c.html" title="CSS 学习笔记"><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img578ut571o3a1a8kj2su9jra6dz7p5ey.jpg" onerror="this.onerror=null;this.src='https://cdn.jsdelivr.net/gh/Hongda-OSU/PicGo/image/404.GIF'" alt="CSS 学习笔记"/></a><div class="content"><a class="title" href="/posts/eb0c992c.html" title="CSS 学习笔记">CSS 学习笔记</a><time datetime="2024-04-26T15:15:05.000Z" title="发表于 2024-04-26 10:15:05">2024-04-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/31e3742d.html" title="考证：AWS DVA-C02"><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img735yqku3pzfqxatav0t55gipvv1zzh2.jpg" onerror="this.onerror=null;this.src='https://cdn.jsdelivr.net/gh/Hongda-OSU/PicGo/image/404.GIF'" alt="考证：AWS DVA-C02"/></a><div class="content"><a class="title" href="/posts/31e3742d.html" title="考证：AWS DVA-C02">考证：AWS DVA-C02</a><time datetime="2024-03-30T17:03:05.000Z" title="发表于 2024-03-30 12:03:05">2024-03-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/fa4ed4d8.html" title="考证：AWS SAA-C03"><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img4gb8ou3p2t5vv347i6lopc13wtm82qw.jpg" onerror="this.onerror=null;this.src='https://cdn.jsdelivr.net/gh/Hongda-OSU/PicGo/image/404.GIF'" alt="考证：AWS SAA-C03"/></a><div class="content"><a class="title" href="/posts/fa4ed4d8.html" title="考证：AWS SAA-C03">考证：AWS SAA-C03</a><time datetime="2024-01-13T18:03:05.000Z" title="发表于 2024-01-13 12:03:05">2024-01-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/ced5b880.html" title="考证：AWS CLF-C02"><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img1l99wbel5ip2y1oivo40zrh051humxd.png" onerror="this.onerror=null;this.src='https://cdn.jsdelivr.net/gh/Hongda-OSU/PicGo/image/404.GIF'" alt="考证：AWS CLF-C02"/></a><div class="content"><a class="title" href="/posts/ced5b880.html" title="考证：AWS CLF-C02">考证：AWS CLF-C02</a><time datetime="2023-12-30T18:03:05.000Z" title="发表于 2023-12-30 12:03:05">2023-12-30</time></div></div></div></div></div></div></main><footer id="footer" style="background: rgba(0, 0, 0, 0.25)"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2024 &nbsp;<i id="heartbeat" class="fa fas fa-heartbeat"></i> &nbsp;鴻達</div><div class="footer_custom_text"><p class="badge"><a style="margin-inline:5px"target="_blank" href="https://hexo.io/"><img src="https://img.shields.io/badge/Frame-Hexo-informational?style=flat&logo=hexo"></a><a style="margin-inline:5px"target="_blank" href="https://domains.google/"><img src="https://img.shields.io/badge/Hosted-Google-ff69b4?style=flat&logo=googledomains"></a><a style="margin-inline:5px"target="_blank" href="https://gulpjs.com/"><img src="https://img.shields.io/badge/Compress-gulp-critical?style=flat&logo=gulp"></a><a style="margin-inline:5px"target="_blank" href="https://www.jsdelivr.com/"><img src="https://img.shields.io/badge/CDN-jsDelivr-orange?style=flat&logo=jsDelivr"></a><a style="margin-inline:5px"target="_blank" href="https://github.com/"><img src="https://img.shields.io/badge/Source-Github-black?style=flat&logo=GitHub"></a><a style="margin-inline:5px"target="_blank"href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&logo=Claris"></a></p></div></div><link rel="stylesheet" href="https://fastly.jsdelivr.net/gh/HCLonely/images@master/others/heartbeat.min.css"></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (true){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><script src="/js/search/local-search.js"></script><div class="js-pjax"></div><script defer src="/js/util.js"></script><script defer src="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()
  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>