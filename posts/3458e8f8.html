<!DOCTYPE html><html lang="zh-CN" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><title>日记 | 鴻鵠誌達</title><meta name="author" content="鴻達"><meta name="copyright" content="鴻達"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#1a1a1a"><meta name="description" content="😃"><meta property="og:type" content="article"><meta property="og:title" content="日记"><meta property="og:url" content="https://hongdalin.blog/posts/3458e8f8.html"><meta property="og:site_name" content="鴻鵠誌達"><meta property="og:description" content="😃"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Hongda-OSU/PicGo/image/od2iyorqbvbnha2g2vybpn8v4tiq4qw.jpg"><meta property="article:published_time" content="2023-01-26T16:15:05.000Z"><meta property="article:modified_time" content="2024-09-17T23:22:47.499Z"><meta property="article:author" content="鴻達"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/Hongda-OSU/PicGo/image/od2iyorqbvbnha2g2vybpn8v4tiq4qw.jpg"><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/Hongda-OSU/PicGo/image/德克萨斯.GIF"><link rel="canonical" href="https://hongdalin.blog/posts/3458e8f8.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:{path:"/search.xml",preload:!0,languages:{hits_empty:"找不到您查询的内容：${query}"}},translate:void 0,noticeOutdate:void 0,highlight:{plugin:"highlighjs",highlightCopy:!0,highlightLang:!0,highlightHeightLimit:200},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"},relativeDate:{homepage:!1,post:!1},runtime:"天",date_suffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:void 0,lightbox:"fancybox",Snackbar:void 0,source:{justifiedGallery:{js:"https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js",css:"https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css"}},isPhotoFigcaption:!0,islazyload:!1,isAnchor:!1,percent:{toc:!0,rightside:!1}}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"日记",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2024-09-17 18:22:47"}</script><noscript><style>#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(e=>{e.saveToLocal={set:function(e,t,n){if(0===n)return;const o=864e5*n,a={value:t,expiry:(new Date).getTime()+o};localStorage.setItem(e,JSON.stringify(a))},get:function(e){const t=localStorage.getItem(e);if(!t)return;const n=JSON.parse(t);if(!((new Date).getTime()>n.expiry))return n.value;localStorage.removeItem(e)}},e.getScript=e=>new Promise(((t,n)=>{const o=document.createElement("script");o.src=e,o.async=!0,o.onerror=n,o.onload=o.onreadystatechange=function(){const e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(o.onload=o.onreadystatechange=null,t())},document.head.appendChild(o)})),e.getCSS=e=>new Promise(((t,n)=>{const o=document.createElement("link");o.rel="stylesheet",o.href=e,o.onload=()=>t(),o.onerror=()=>n(),document.head.appendChild(o)}));/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")})(window)</script><link rel="stylesheet" href="/css/color.css" media="defer" onload='this.media="all"'><link rel="stylesheet" href="/css/font.css" media="defer" onload='this.media="all"'><link rel="stylesheet" href="/css/icon.css" media="defer" onload='this.media="all"'><link rel="stylesheet" href="/css/layout.css" media="defer" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.css" media="defer" onload='this.media="all"'><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://cdn.jsdelivr.net/gh/Hongda-OSU/PicGo/image/德狗子.GIF" onerror='onerror=null,src="https://cdn.jsdelivr.net/gh/Hongda-OSU/PicGo/image/404.GIF"' alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">19</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">12</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i> <span>时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i> <span>标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>分类</span></a></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i> <span>链接</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i> <span>友情链接</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i> <span>关于</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url('https://cdn.jsdelivr.net/gh/Hongda-OSU/PicGo/image/od2iyorqbvbnha2g2vybpn8v4tiq4qw.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="鴻鵠誌達"><span class="site-name">鴻鵠誌達</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i> <span>搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i> <span>时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i> <span>标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>分类</span></a></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i> <span>链接</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i> <span>友情链接</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i> <span>关于</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">日记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-01-26T16:15:05.000Z" title="发表于 2023-01-26 10:15:05">2023-01-26</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-09-17T23:22:47.499Z" title="更新于 2024-09-17 18:22:47">2024-09-17</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">12.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>57分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" data-flag-title="日记"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h3 id="Top-K-元素"><a href="#Top-K-元素" class="headerlink" title="Top K 元素"></a>Top K 元素</h3><blockquote><p>题目: <a target="_blank" rel="noopener" href="https://leetcode.com/problems/kth-largest-element-in-an-array/">Leetcode 215. Kth Largest Element in an Array</a></p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: nums = [3, 2, 1, 5, 6, 4], k = 2</span><br><span class="line">Output: [5, 6]</span><br></pre></td></tr></table></figure><ul><li><p>解法 1: 使用最小堆 (<a target="_blank" rel="noopener" href="https://www.geeksforgeeks.org/heap-queue-or-heapq-in-python/">什么是 heap</a>)</p></li><li><p>使用一个大小为<code>k</code>的最小堆可以更有效地找到前<code>k</code>个最大元素。当遍历数组时，将元素插入堆中，如果堆的大小超过<code>k</code>，就移除堆顶（最小的元素），最终堆中剩下的就是前<code>k</code>个最大的元素</p></li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">top_k_heap</span>(<span class="params">arr, k</span>):</span><br><span class="line">    <span class="keyword">if</span> k == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">    heap = arr[:k]</span><br><span class="line">    heapq.heapify(heap)  <span class="comment"># 建立最小堆</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> arr[k:]:</span><br><span class="line">        <span class="keyword">if</span> num &gt; heap[<span class="number">0</span>]:  <span class="comment"># 只在当前元素大于堆顶时替换</span></span><br><span class="line">            heapq.heapreplace(heap, num)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> heap</span><br></pre></td></tr></table></figure><ul><li><p>解法 2: 使用快速选择 <code>Quick Select</code></p></li><li><p>快速选择算法基于快速排序的思想，通过分治法找到第<code>k</code>大的元素，然后将数组划分为两部分，一部分比第 <code>k</code>大的元素大，一部分比它小。这样，可以直接得到前<code>k</code>个最大的元素。</p></li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">partition</span>(<span class="params">arr, low, high</span>):</span><br><span class="line">    pivot = arr[high]</span><br><span class="line">    i = low - <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(low, high):</span><br><span class="line">        <span class="keyword">if</span> arr[j] &gt; pivot:</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            arr[i], arr[j] = arr[j], arr[i]</span><br><span class="line">    arr[i + <span class="number">1</span>], arr[high] = arr[high], arr[i + <span class="number">1</span>]</span><br><span class="line">    <span class="keyword">return</span> i + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">quickselect</span>(<span class="params">arr, low, high, k</span>):</span><br><span class="line">    <span class="keyword">if</span> low &lt; high:</span><br><span class="line">        pivot_index = partition(arr, low, high)</span><br><span class="line">        <span class="keyword">if</span> pivot_index == k:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">elif</span> pivot_index &gt; k:</span><br><span class="line">            quickselect(arr, low, pivot_index - <span class="number">1</span>, k)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            quickselect(arr, pivot_index + <span class="number">1</span>, high, k)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">top_k_quickselect</span>(<span class="params">arr, k</span>):</span><br><span class="line">    quickselect(arr, <span class="number">0</span>, <span class="built_in">len</span>(arr) - <span class="number">1</span>, k)</span><br><span class="line">    <span class="keyword">return</span> arr[:k]</span><br></pre></td></tr></table></figure><hr><h3 id="Top-K-频率"><a href="#Top-K-频率" class="headerlink" title="Top K 频率"></a>Top K 频率</h3><blockquote><p>题目: <a target="_blank" rel="noopener" href="https://leetcode.com/problems/top-k-frequent-elements/">Leetcode 347. Top K Frequent Elements</a></p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: nums = [1, 1, 1, 2, 2, 3], k = 2</span><br><span class="line">Output: [1, 2]</span><br></pre></td></tr></table></figure><ul><li>解法: 使用最小堆 (简单写法)</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">topKFrequent</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums) == k:</span><br><span class="line">            <span class="keyword">return</span> nums</span><br><span class="line"></span><br><span class="line">        count = Counter(nums)</span><br><span class="line">        <span class="keyword">return</span> heapq.nlargest(k, count.keys(), key=count.get)</span><br></pre></td></tr></table></figure><ul><li><p>解法: 使用最小堆</p></li><li><p>使用大小为<code>k</code>的最小堆，我们可以找到频率最高的前<code>k</code>个元素。每次添加元素时，如果堆超过<code>k</code>，就移除频率最低的。最后，堆中剩下的就是频率最高的<code>k</code>个元素。</p></li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">topKFrequent</span>(<span class="params">nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">    <span class="comment"># 1. 统计每个元素的频率</span></span><br><span class="line">    freq_map = Counter(nums)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 2. 使用最小堆找到前 k 个频率最高的元素</span></span><br><span class="line">    heap = []</span><br><span class="line">    <span class="keyword">for</span> num, freq <span class="keyword">in</span> freq_map.items():</span><br><span class="line">        heapq.heappush(heap, (freq, num))  <span class="comment"># 堆中存储 (频率, 元素)</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(heap) &gt; k:</span><br><span class="line">            heapq.heappop(heap)  <span class="comment"># 维持堆的大小为 k</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 3. 提取堆中的元素</span></span><br><span class="line">    <span class="keyword">return</span> [num <span class="keyword">for</span> freq, num <span class="keyword">in</span> heap]</span><br></pre></td></tr></table></figure><hr><h3 id="LRU-Cache"><a href="#LRU-Cache" class="headerlink" title="LRU Cache"></a>LRU Cache</h3><blockquote><p>题目: <a target="_blank" rel="noopener" href="https://leetcode.com/problems/lru-cache/">Leetcode 146. LRU Cache</a></p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">[&quot;LRUCache&quot;, [2], &quot;put&quot;, [1, 10],  &quot;get&quot;, [1], &quot;put&quot;, [2, 20], &quot;put&quot;, [3, 30], &quot;get&quot;, [2], &quot;get&quot;, [1]]</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">[null, null, 10, null, null, 20, -1]</span><br><span class="line"></span><br><span class="line">Explanation:</span><br><span class="line">LRUCache lRUCache = new LRUCache(2);</span><br><span class="line">lRUCache.put(1, 10);  // cache: &#123;1=10&#125;</span><br><span class="line">lRUCache.get(1);      // return 10</span><br><span class="line">lRUCache.put(2, 20);  // cache: &#123;1=10, 2=20&#125;</span><br><span class="line">lRUCache.put(3, 30);  // cache: &#123;2=20, 3=30&#125;, key=1 was evicted</span><br><span class="line">lRUCache.get(2);      // returns 20</span><br><span class="line">lRUCache.get(1);      // return -1 (not found)</span><br></pre></td></tr></table></figure><ul><li>解法: 使用一个哈希表<code>cache</code>来存储键值对，值为双向链表的节点。使用双向链表来维护数据的访问顺序，链表的左端是最近最少使用的元素，右端是最近使用的元素。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, key, val</span>):</span><br><span class="line">        self.key, self.val = key, val</span><br><span class="line">        self.prev = self.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, capacity: <span class="built_in">int</span></span>):</span><br><span class="line">        self.capacity = capacity</span><br><span class="line">        self.cache = &#123;&#125;</span><br><span class="line">        <span class="comment"># left = LRU, right = most recent</span></span><br><span class="line">        self.left, self.right = Node(<span class="number">0</span>, <span class="number">0</span>), Node(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">        self.left.<span class="built_in">next</span> = self.right</span><br><span class="line">        self.right.prev = self.left</span><br><span class="line"></span><br><span class="line">    <span class="comment"># remove node from list</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">remove</span>(<span class="params">self, node</span>):</span><br><span class="line">        prev, nxt = node.prev, node.<span class="built_in">next</span></span><br><span class="line">        prev.<span class="built_in">next</span> = nxt</span><br><span class="line">        nxt.prev = prev</span><br><span class="line"></span><br><span class="line">    <span class="comment"># insert node at right</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">insert</span>(<span class="params">self, node</span>):</span><br><span class="line">        prev, nxt = self.right.prev, self.right</span><br><span class="line">        prev.<span class="built_in">next</span> = node</span><br><span class="line">        node.prev = prev</span><br><span class="line">        node.<span class="built_in">next</span> = nxt</span><br><span class="line">        nxt.prev = node</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">self, key: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">in</span> self.cache:</span><br><span class="line">            self.remove(self.cache[key])</span><br><span class="line">            self.insert(self.cache[key])</span><br><span class="line">            <span class="keyword">return</span> self.cache[key].val</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">put</span>(<span class="params">self, key: <span class="built_in">int</span>, value: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">in</span> self.cache:</span><br><span class="line">            self.remove(self.cache[key])</span><br><span class="line">        self.cache[key] = Node(key, value)</span><br><span class="line">        self.insert(self.cache[key])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self.cache) &gt; self.capacity:</span><br><span class="line">            lru = self.left.<span class="built_in">next</span></span><br><span class="line">            self.remove(lru)</span><br><span class="line">            <span class="keyword">del</span> self.cache[lru.key]</span><br></pre></td></tr></table></figure><hr><h3 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h3><blockquote><p>题目: <a target="_blank" rel="noopener" href="https://leetcode.com/problems/reverse-linked-list/">Leetcode 206. Reverse Linked List</a><br>题目: <a target="_blank" rel="noopener" href="https://leetcode.com/problems/reverse-linked-list/">Leetcode 92. Reverse Linked List II</a></p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: head = [0,1,2,3]</span><br><span class="line">Output: [3,2,1,0]</span><br></pre></td></tr></table></figure><ul><li><p>解法: 使用<code>Two Pointers</code></p></li><li><p>使用两个指针，逐个调整链表节点的指向，从而将链表反转。<code>prev</code>指向前一个节点，<code>curr</code>指向当前节点，不断更新直到整个链表被反转。最后，返回新的头节点<code>prev</code>。</p></li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">reverseList</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">    prev = <span class="literal">None</span></span><br><span class="line">    curr = head</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> curr:</span><br><span class="line">        tmp = curr.<span class="built_in">next</span> <span class="comment"># get next node tmp</span></span><br><span class="line">        curr.<span class="built_in">next</span> = prev <span class="comment"># curr node point to prev</span></span><br><span class="line">        prev = curr <span class="comment"># move prev to curr</span></span><br><span class="line">        curr = tmp <span class="comment"># move curr to next node tmp</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> prev</span><br></pre></td></tr></table></figure><hr><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: head = [1,2,3,4,5], left = 2, right = 4</span><br><span class="line">Output: [1,4,3,2,5]</span><br></pre></td></tr></table></figure><ul><li>解法: 使用一个虚拟头节点来处理边界问题（如从头开始反转的情况），通过更新指针，将<code>left</code>到<code>right</code>之间的节点逐步插入到子链表的前面，最终实现部分链表的反转。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">reverseBetween</span>(<span class="params"></span></span><br><span class="line"><span class="params">    self, head: <span class="type">Optional</span>[ListNode], left: <span class="built_in">int</span>, right: <span class="built_in">int</span></span></span><br><span class="line"><span class="params"></span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">    dummy = ListNode(<span class="number">0</span>, head)</span><br><span class="line">    prev = dummy</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 1. 先找到 left 的前一个节点（prev），以及 left 的节点（current）</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(left - <span class="number">1</span>):</span><br><span class="line">        prev = prev.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">    curr = prev.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 2. 反转 left 到 right 之间的节点</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(right - left):</span><br><span class="line">        tmp = curr.<span class="built_in">next</span></span><br><span class="line">        curr.<span class="built_in">next</span> = tmp.<span class="built_in">next</span></span><br><span class="line">        tmp.<span class="built_in">next</span> = prev.<span class="built_in">next</span></span><br><span class="line">        prev.<span class="built_in">next</span> = tmp</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><hr><h3 id="合成链表"><a href="#合成链表" class="headerlink" title="合成链表"></a>合成链表</h3><blockquote><p>题目: <a target="_blank" rel="noopener" href="https://leetcode.com/problems/merge-two-sorted-lists/">Leetcode 21. Merge Two Sorted Lists</a></p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: list1 = [1,2,4], list2 = [1,3,5]</span><br><span class="line">Output: [1,1,2,3,4,5]</span><br></pre></td></tr></table></figure><ul><li>解法: 比较<code>list1</code>和<code>list2</code>的节点值，逐个将较小的节点连接到新的链表中。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">mergeTwoLists</span>(<span class="params">self, list1: <span class="type">Optional</span>[ListNode], list2: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">    dummy = ListNode()</span><br><span class="line">    curr = dummy</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> list1 <span class="keyword">and</span> list2:</span><br><span class="line">        <span class="keyword">if</span> list1.val &lt; list2.val:</span><br><span class="line">            curr.<span class="built_in">next</span> = list1</span><br><span class="line">            list1 = list1.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            curr.<span class="built_in">next</span> = list2</span><br><span class="line">            list2 = list2.<span class="built_in">next</span></span><br><span class="line">        curr = curr.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">    curr.<span class="built_in">next</span> = list1 <span class="keyword">or</span> list2</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><hr><h3 id="海岛问题"><a href="#海岛问题" class="headerlink" title="海岛问题"></a>海岛问题</h3><blockquote><p>题目: <a target="_blank" rel="noopener" href="https://leetcode.com/problems/number-of-islands/">Leetcode 200. Number of Islands</a></p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: grid = [</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;]</span><br><span class="line">]</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure><ul><li>解法: <code>BFS</code>，通过<code>visited</code>集合来记录已经访问过的节点。对于每一个没有访问过的陆地，进行<code>BFS</code>以标记整个岛屿，并增加岛屿的计数。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">numIslands</span>(<span class="params">self, grid: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    islands = <span class="number">0</span></span><br><span class="line">    visited = <span class="built_in">set</span>()</span><br><span class="line">    rows, cols = <span class="built_in">len</span>(grid), <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">bfs</span>(<span class="params">r, c</span>):</span><br><span class="line">        q = deque()</span><br><span class="line">        visited.add((r, c))</span><br><span class="line">        q.append((r, c))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            row, col = q.popleft()</span><br><span class="line">            directions = [[<span class="number">1</span>, <span class="number">0</span>], [-<span class="number">1</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">1</span>], [<span class="number">0</span>, -<span class="number">1</span>]]</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> dr, dc <span class="keyword">in</span> directions:</span><br><span class="line">                r, c = row + dr, col + dc</span><br><span class="line">                <span class="keyword">if</span> (</span><br><span class="line">                    <span class="number">0</span> &lt;= r &lt; rows</span><br><span class="line">                    <span class="keyword">and</span> <span class="number">0</span> &lt;= c &lt; cols</span><br><span class="line">                    <span class="keyword">and</span> grid[r][c] == <span class="string">&quot;1&quot;</span></span><br><span class="line">                    <span class="keyword">and</span> (r, c) <span class="keyword">not</span> <span class="keyword">in</span> visited</span><br><span class="line">                ):</span><br><span class="line">                    q.append((r, c))</span><br><span class="line">                    visited.add((r, c))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> r <span class="keyword">in</span> <span class="built_in">range</span>(rows):</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">range</span>(cols):</span><br><span class="line">            <span class="keyword">if</span> grid[r][c] == <span class="string">&quot;1&quot;</span> <span class="keyword">and</span> (r, c) <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">                islands += <span class="number">1</span></span><br><span class="line">                bfs(r, c)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> islands</span><br></pre></td></tr></table></figure><hr><h3 id="雨水问题"><a href="#雨水问题" class="headerlink" title="雨水问题"></a>雨水问题</h3><blockquote><p>题目: <a target="_blank" rel="noopener" href="https://leetcode.com/problems/trapping-rain-water/">Leetcode 42. Trapping Rain Water</a><br>题目: <a target="_blank" rel="noopener" href="https://leetcode.com/problems/container-with-most-water/">Leetcode 11. Container With Most Water</a></p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: height = [0,1,0,2,1,0,1,3,2,1,2,1]</span><br><span class="line">Output: 6</span><br></pre></td></tr></table></figure><ul><li>解法: 通过设置左右两个指针分别从数组两端开始遍历，比较两边的最大高度，确定当前位置可以接的水量。较低的一侧的水量取决于其最大高度与当前位置高度的差值，并移动指针靠近中间，逐步累积接到的雨水量，直到两个指针相遇为止。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">trap</span>(<span class="params">self, height: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> height:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    left, right = <span class="number">0</span>, <span class="built_in">len</span>(height) - <span class="number">1</span></span><br><span class="line">    <span class="comment"># 初始化左右两边的最大高度</span></span><br><span class="line">    left_max, right_max = height[left], height[right]</span><br><span class="line"></span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> left &lt; right:</span><br><span class="line">        <span class="comment"># 如果左边的最大高度小于右边的最大高度</span></span><br><span class="line">        <span class="keyword">if</span> left_max &lt; right_max:</span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 更新左边的最大高度</span></span><br><span class="line">            left_max = <span class="built_in">max</span>(left_max, height[left])</span><br><span class="line">            <span class="comment"># 计算当前左指针位置的接水量（左边的最大高度 - 当前柱子的高度）</span></span><br><span class="line">            res += left_max - height[left]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            right -= <span class="number">1</span></span><br><span class="line">            <span class="comment"># 更新右边的最大高度</span></span><br><span class="line">            right_max = <span class="built_in">max</span>(right_max, height[right])</span><br><span class="line">            <span class="comment"># 计算当前右指针位置的接水量（右边的最大高度 - 当前柱子的高度）</span></span><br><span class="line">            res += right_max - height[right]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><hr><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: height = [1,8,6,2,5,4,8,3,7]</span><br><span class="line">Output: 49</span><br></pre></td></tr></table></figure><ul><li>解法: 使用双指针法解决，初始时指针分别指向数组的两端。每次计算由这两根竖线形成的容器面积，记录最大值。接着移动较短的那一侧的指针，目的是尝试找到更大的容积，因为容积受较短的边限制。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">maxArea</span>(<span class="params">self, height: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    left, right = <span class="number">0</span>, <span class="built_in">len</span>(height) - <span class="number">1</span></span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> left &lt; right:</span><br><span class="line">        <span class="comment"># 计算当前容器的面积</span></span><br><span class="line">        width = right - left</span><br><span class="line">        area = <span class="built_in">min</span>(height[left], height[right]) * width</span><br><span class="line">        <span class="comment"># 更新最大面积</span></span><br><span class="line">        res = <span class="built_in">max</span>(res, area)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 移动较短边对应的指针，尝试找到更大的容器</span></span><br><span class="line">        <span class="keyword">if</span> height[left] &lt; height[right]:</span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            right -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><hr><h3 id="K-个一组翻转链表"><a href="#K-个一组翻转链表" class="headerlink" title="K 个一组翻转链表"></a>K 个一组翻转链表</h3><blockquote><p>题目: <a target="_blank" rel="noopener" href="https://leetcode.com/problems/reverse-nodes-in-k-group/">Leetcode 25. Reverse Nodes in k-Group</a></p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: head = [1,2,3,4,5,6], k = 3</span><br><span class="line">Output: [3,2,1,6,5,4]</span><br></pre></td></tr></table></figure><ul><li>解法: 将链表按照每<code>k</code>个节点为一组进行翻转，若链表的剩余部分长度不足<code>k</code>，则保持原样不翻转。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">reverseKGroup</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode], k: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">    dummy = ListNode(<span class="number">0</span>, head)</span><br><span class="line">    group_prev = dummy</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="comment"># 找到当前组的第 k 个节点</span></span><br><span class="line">        kth = self.getKthNode(group_prev, k)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> kth:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        group_next = kth.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 反转当前组的节点</span></span><br><span class="line">        prev, curr = kth.<span class="built_in">next</span>, group_prev.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">while</span> curr != group_next:</span><br><span class="line">            tmp = curr.<span class="built_in">next</span></span><br><span class="line">            curr.<span class="built_in">next</span> = prev</span><br><span class="line">            prev = curr</span><br><span class="line">            curr = tmp</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 处理连接：将反转后的部分与链表其余部分连接起来</span></span><br><span class="line">        tmp = group_prev.<span class="built_in">next</span></span><br><span class="line">        group_prev.<span class="built_in">next</span> = kth</span><br><span class="line">        group_prev = tmp</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getKthNode</span>(<span class="params">self, curr, k</span>):</span><br><span class="line">    <span class="keyword">while</span> curr <span class="keyword">and</span> k &gt; <span class="number">0</span>:</span><br><span class="line">        curr = curr.<span class="built_in">next</span></span><br><span class="line">        k -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> curr</span><br></pre></td></tr></table></figure><hr><h3 id="两两交换链表中的节点"><a href="#两两交换链表中的节点" class="headerlink" title="两两交换链表中的节点"></a>两两交换链表中的节点</h3><blockquote><p>题目: <a target="_blank" rel="noopener" href="https://leetcode.com/problems/swap-nodes-in-pairs/">Leetcode 24. Swap Nodes in Pairs</a></p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: head = [1,2,3,4]</span><br><span class="line">Output: [2,1,4,3]</span><br></pre></td></tr></table></figure><ul><li>解法: 创建一个虚拟头节点<code>dummy</code>来简化链表的操作，然后遍历链表，每次取出一对相邻节点进行交换，并更新指针确保链表的顺序正确。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">swapPairs</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">    dummy = ListNode(<span class="number">0</span>, head)</span><br><span class="line">    prev = dummy</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> head <span class="keyword">and</span> head.<span class="built_in">next</span>:</span><br><span class="line">        <span class="comment"># Nodes to be swapped</span></span><br><span class="line">        first = head</span><br><span class="line">        second = head.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Swapping</span></span><br><span class="line">        prev.<span class="built_in">next</span> = second</span><br><span class="line">        first.<span class="built_in">next</span> = second.<span class="built_in">next</span></span><br><span class="line">        second.<span class="built_in">next</span> = first</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Re-positioning prev and head for next swap</span></span><br><span class="line">        prev = first</span><br><span class="line">        head = first.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><hr><h3 id="字符串解码"><a href="#字符串解码" class="headerlink" title="字符串解码"></a>字符串解码</h3><blockquote><p>题目: <a target="_blank" rel="noopener" href="https://leetcode.com/problems/decode-string/">Leetcode 394. Decode String</a></p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: s = &quot;3[a]2[bc]&quot;</span><br><span class="line">Output: &quot;aaabcbc&quot;</span><br></pre></td></tr></table></figure><ul><li>解法: 通过栈来处理字符串的嵌套解码。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">decodeString</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">    stack = []</span><br><span class="line">    curr_num = <span class="number">0</span></span><br><span class="line">    curr_str = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">        <span class="keyword">if</span> c.isdigit():</span><br><span class="line">            <span class="comment"># 构建当前数字</span></span><br><span class="line">            curr_num = curr_num * <span class="number">10</span> + <span class="built_in">int</span>(c)</span><br><span class="line">        <span class="keyword">elif</span> c == <span class="string">&quot;[&quot;</span>:</span><br><span class="line">            <span class="comment"># 将当前的数字和字符串入栈</span></span><br><span class="line">            stack.append((curr_str, curr_num))</span><br><span class="line">            curr_str = <span class="string">&quot;&quot;</span></span><br><span class="line">            curr_num = <span class="number">0</span></span><br><span class="line">        <span class="keyword">elif</span> c == <span class="string">&quot;]&quot;</span>:</span><br><span class="line">            <span class="comment"># 出栈，并重复字符串</span></span><br><span class="line">            prev_str, num = stack.pop()</span><br><span class="line">            curr_str = prev_str + num * curr_str</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 追加当前字符到字符串</span></span><br><span class="line">            curr_str += c</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> curr_str</span><br></pre></td></tr></table></figure><hr><h3 id="0-1-背包问题"><a href="#0-1-背包问题" class="headerlink" title="0-1 背包问题"></a>0-1 背包问题</h3><blockquote><p>题目: <a target="_blank" rel="noopener" href="https://leetcode.com/problems/partition-equal-subset-sum/">Leetcode 416. Partition Equal Subset Sum</a><br>题目: <a target="_blank" rel="noopener" href="https://leetcode.com/problems/target-sum/">Leetcode 494. Target Sum</a></p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: nums = [1,5,11,5]</span><br><span class="line">Output: true</span><br><span class="line">Explanation: The array can be partitioned as [1, 5, 5] and [11].</span><br></pre></td></tr></table></figure><ul><li>解法: 是否存在一个子集，它的元素和等于总和的一半。问题变为：给定一个数组<code>nums</code>和一个目标值<code>target</code>，判断是否能从数组中选出若干元素，使它们的和等于<code>target</code>。</li><li>用<code>dp[i]</code>表示是否存在一个子集，使得这个子集的和为<code>i</code>。对于每个数字<code>num</code>，从<code>target</code>向下遍历所有可能的和<code>i</code>，并更新<code>dp[i]</code>。如果存在某个子集的和为<code>i - num</code>，则<code>dp[i]</code>应该为<code>True</code>。</li><li>公式为: <code>dp[i] = dp[i] or dp[i - num]</code>。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">canPartition</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">    total = <span class="built_in">sum</span>(nums)</span><br><span class="line">    <span class="comment"># 如果总和是奇数，无法平分</span></span><br><span class="line">    <span class="keyword">if</span> total % <span class="number">2</span> != <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    target = total // <span class="number">2</span></span><br><span class="line">    dp = [<span class="literal">False</span>] * (target + <span class="number">1</span>)</span><br><span class="line">    dp[<span class="number">0</span>] = [<span class="literal">True</span>]  <span class="comment"># 总和为 0 的情况是可以实现的</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">        <span class="comment"># 遍历背包容量，从大到小更新 dp 数组</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(target, num - <span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            dp[i] = dp[i] <span class="keyword">or</span> dp[i - num]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[target]</span><br></pre></td></tr></table></figure><hr><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: nums = [1,1,1,1,1], target = 3</span><br><span class="line">Output: 5</span><br><span class="line">Explanation: There are 5 ways to assign symbols to make the sum of nums be target 3.</span><br><span class="line">-1 + 1 + 1 + 1 + 1 = 3</span><br><span class="line">+1 - 1 + 1 + 1 + 1 = 3</span><br><span class="line">+1 + 1 - 1 + 1 + 1 = 3</span><br><span class="line">+1 + 1 + 1 - 1 + 1 = 3</span><br><span class="line">+1 + 1 + 1 + 1 - 1 = 3</span><br></pre></td></tr></table></figure><ul><li>解法: 将问题转化为寻找数组的两个部分，分别使用<code>+</code>和<code>-</code>号。<code>P</code>是使用<code>+</code>号的部分，<code>N</code>是使用<code>-</code>号的部分。我们可以推导出：<code>P - N = target</code>，以及<code>P + N = sum(nums)</code>，两个方程联立得到：<code>P = (target + sum(nums)) / 2</code>。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">findTargetSumWays</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    total_sum = <span class="built_in">sum</span>(nums)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (target + total_sum) % <span class="number">2</span> != <span class="number">0</span> <span class="keyword">or</span> total_sum &lt; <span class="built_in">abs</span>(target):</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    subset_sum = (target + total_sum) // <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># dp[i] 表示和为 i 的子集数</span></span><br><span class="line">    dp = [<span class="number">0</span>] * (subset_sum + <span class="number">1</span>)</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">        <span class="comment"># 倒序遍历，确保每个数字只能被使用一次</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(subset_sum, num - <span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            dp[i] += dp[i - num]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[subset_sum]</span><br></pre></td></tr></table></figure><hr><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><ul><li>快速排序是一种基于分治思想的高效排序算法，平均时间复杂度为<code>O(n log n)</code>，最坏情况下时间复杂度为 <code>O(n^2)</code>。它的基本思想是通过一次排序将待排序数组分割成独立的两部分，其中一部分的所有元素都比另一部分的所有元素小，然后对这两部分分别进行递归排序。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">quicksort</span>(<span class="params">arr</span>):</span><br><span class="line">    <span class="comment"># 基本条件：如果数组为空或只有一个元素，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(arr) &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> arr</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 选择基准元素</span></span><br><span class="line">    pivot = arr[<span class="built_in">len</span>(arr) // <span class="number">2</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 将数组分成三个部分：小于基准的部分、等于基准的部分、大于基准的部分</span></span><br><span class="line">    left = [x <span class="keyword">for</span> x <span class="keyword">in</span> arr <span class="keyword">if</span> x &lt; pivot]</span><br><span class="line">    middle = [x <span class="keyword">for</span> x <span class="keyword">in</span> arr <span class="keyword">if</span> x == pivot]</span><br><span class="line">    right = [x <span class="keyword">for</span> x <span class="keyword">in</span> arr <span class="keyword">if</span> x &gt; pivot]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 递归排序左右两部分</span></span><br><span class="line">    <span class="keyword">return</span> quicksort(left) + middle + quicksort(right)</span><br></pre></td></tr></table></figure><hr><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><ul><li>冒泡排序是一种简单的排序算法，它通过重复遍历列表，将相邻的元素进行比较并交换，使得每次遍历后最大（或最小）的元素逐步“冒泡”到列表的末尾。冒泡排序的时间复杂度为<code>O(n²)</code>，适用于小规模数据的排序。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">bubble_sort</span>(<span class="params">arr</span>):</span><br><span class="line">    n = <span class="built_in">len</span>(arr)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 外层循环控制遍历次数</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        swapped = <span class="literal">False</span>  <span class="comment"># 用来标记是否发生交换</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 内层循环进行相邻元素的比较和交换</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, n - i - <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> arr[j] &gt; arr[j + <span class="number">1</span>]:</span><br><span class="line">                <span class="comment"># 交换相邻元素</span></span><br><span class="line">                arr[j], arr[j + <span class="number">1</span>] = arr[j + <span class="number">1</span>], arr[j]</span><br><span class="line">                swapped = <span class="literal">True</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 如果没有发生交换，说明数组已经排序完毕</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> swapped:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> arr</span><br></pre></td></tr></table></figure><hr><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><ul><li>插入排序是一种简单直观的排序算法，适合处理小规模数据。它的工作原理是构建一个有序序列，对于未排序的数据，在已排序的序列中从后向前扫描，找到相应位置并插入。插入排序的时间复杂度为<code>O(n²)</code>，在数组几乎有序的情况下表现很好，接近<code>O(n)</code>。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">insertion_sort</span>(<span class="params">arr</span>):</span><br><span class="line">    <span class="comment"># 从第二个元素开始遍历</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(arr)):</span><br><span class="line">        key = arr[i]  <span class="comment"># 当前待插入的元素</span></span><br><span class="line">        j = i - <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 向前遍历已排序的序列，找到适合的位置插入当前元素</span></span><br><span class="line">        <span class="keyword">while</span> j &gt;= <span class="number">0</span> <span class="keyword">and</span> arr[j] &gt; key:</span><br><span class="line">            arr[j + <span class="number">1</span>] = arr[j]  <span class="comment"># 将大于 key 的元素向后移动</span></span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        arr[j + <span class="number">1</span>] = key  <span class="comment"># 将当前元素插入到正确的位置</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> arr</span><br></pre></td></tr></table></figure><hr><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><ul><li>归并排序是一种经典的分治算法，通过将数组递归地分成两个子数组，分别进行排序，然后合并这两个有序子数组来实现排序。归并排序的时间复杂度为<code>O(n log n)</code>，它具有稳定性且适用于大规模数据的排序。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">merge_sort</span>(<span class="params">arr</span>):</span><br><span class="line">    <span class="comment"># 如果数组长度小于等于1，则直接返回</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(arr) &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> arr</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 分割数组</span></span><br><span class="line">    mid = <span class="built_in">len</span>(arr) // <span class="number">2</span></span><br><span class="line">    left_half = merge_sort(arr[:mid])</span><br><span class="line">    right_half = merge_sort(arr[mid:])</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 合并两个已排序的子数组</span></span><br><span class="line">    <span class="keyword">return</span> merge(left_half, right_half)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">merge</span>(<span class="params">left, right</span>):</span><br><span class="line">    sorted_array = []</span><br><span class="line">    i = j = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 逐步比较两个子数组中的元素，按顺序合并</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(left) <span class="keyword">and</span> j &lt; <span class="built_in">len</span>(right):</span><br><span class="line">        <span class="keyword">if</span> left[i] &lt; right[j]:</span><br><span class="line">            sorted_array.append(left[i])</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            sorted_array.append(right[j])</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 将剩余的元素加入合并结果</span></span><br><span class="line">    sorted_array.extend(left[i:])</span><br><span class="line">    sorted_array.extend(right[j:])</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> sorted_array</span><br></pre></td></tr></table></figure><hr><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><ul><li>堆排序是一种基于二叉堆的数据结构的比较排序算法，时间复杂度为<code>O(n log n)</code>。堆排序分为最大堆和最小堆，通常使用最大堆来进行升序排序。堆排序具有原地排序的特点，不需要额外的存储空间。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">heapify</span>(<span class="params">arr, n, i</span>):</span><br><span class="line">    largest = i  <span class="comment"># 设当前节点 i 为最大</span></span><br><span class="line">    left = <span class="number">2</span> * i + <span class="number">1</span>  <span class="comment"># 左子节点</span></span><br><span class="line">    right = <span class="number">2</span> * i + <span class="number">2</span>  <span class="comment"># 右子节点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 如果左子节点存在，且大于当前最大值</span></span><br><span class="line">    <span class="keyword">if</span> left &lt; n <span class="keyword">and</span> arr[left] &gt; arr[largest]:</span><br><span class="line">        largest = left</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 如果右子节点存在，且大于当前最大值</span></span><br><span class="line">    <span class="keyword">if</span> right &lt; n <span class="keyword">and</span> arr[right] &gt; arr[largest]:</span><br><span class="line">        largest = right</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 如果最大值不是当前节点，进行交换并继续调整堆</span></span><br><span class="line">    <span class="keyword">if</span> largest != i:</span><br><span class="line">        arr[i], arr[largest] = arr[largest], arr[i]</span><br><span class="line">        heapify(arr, n, largest)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">heap_sort</span>(<span class="params">arr</span>):</span><br><span class="line">    n = <span class="built_in">len</span>(arr)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 构建最大堆</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n // <span class="number">2</span> - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">        heapify(arr, n, i)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 交换元素，并重新调整堆结构</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n - <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>):</span><br><span class="line">        arr[i], arr[<span class="number">0</span>] = arr[<span class="number">0</span>], arr[i]  <span class="comment"># 将堆顶元素移到数组末尾</span></span><br><span class="line">        heapify(arr, i, <span class="number">0</span>)  <span class="comment"># 调整剩下的部分为最大堆</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> arr</span><br></pre></td></tr></table></figure><hr><h3 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h3><blockquote><p>题目: <a target="_blank" rel="noopener" href="https://leetcode.com/problems/remove-duplicates-from-sorted-array/">Leetcode 26. Remove Duplicates from Sorted Array</a></p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: nums = [0,0,1,1,1,2,2,3,3,4]</span><br><span class="line">Output: 5, nums = [0,1,2,3,4,_,_,_,_,_]</span><br></pre></td></tr></table></figure><ul><li>解法: 使用双指针法遍历数组，一个指针跟踪去重后的数组位置，另一个指针遍历原数组，遇到新元素时将其移动到去重后的数组中，最终返回去重后的数组长度。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">removeDuplicates</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(nums)):</span><br><span class="line">        <span class="keyword">if</span> nums[j] != nums[i]: <span class="comment"># 如果遇到新的元素</span></span><br><span class="line">            i += <span class="number">1</span> <span class="comment"># 更新i指针</span></span><br><span class="line">            nums[i] = nums[j] <span class="comment"># 将nums[j]移到nums[i+1]的位置</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> i + <span class="number">1</span></span><br></pre></td></tr></table></figure><hr><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">matrix = [</span><br><span class="line">    [1, 2, 3],</span><br><span class="line">    [1, 2, 3],</span><br><span class="line">    [4, 5, 6]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"># 输出: [(1, 2, 3), (4, 5, 6)]</span><br></pre></td></tr></table></figure><ul><li>对于二维数组去重，一种常见的做法是将每一行转化为元组，然后通过<code>set</code>来去重。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">remove_duplicates</span>(<span class="params">matrix</span>):</span><br><span class="line">    unique_rows = <span class="built_in">set</span>(<span class="built_in">tuple</span>(row) <span class="keyword">for</span> row <span class="keyword">in</span> matrix)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>(unique_rows)</span><br></pre></td></tr></table></figure><hr><h3 id="最长无重复子串"><a href="#最长无重复子串" class="headerlink" title="最长无重复子串"></a>最长无重复子串</h3><blockquote><p>题目: <a target="_blank" rel="noopener" href="https://leetcode.com/problems/longest-substring-without-repeating-characters/">Leetcode 3. Longest Substring Without Repeating Characters</a></p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: s = &quot;abcabcbb&quot;</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure><ul><li>解法: 使用滑动窗口法，通过两个指针动态维护一个不含重复字符的窗口，实时更新最长无重复子串的长度。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">lengthOfLongestSubstring</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    left = <span class="number">0</span></span><br><span class="line">    right = <span class="number">0</span></span><br><span class="line">    char_set = <span class="built_in">set</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> right &lt; <span class="built_in">len</span>(s):</span><br><span class="line">        c = s[right]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 如果字符重复，移动左指针直到没有重复字符</span></span><br><span class="line">        <span class="keyword">while</span> c <span class="keyword">in</span> char_set:</span><br><span class="line">            char_set.remove(s[left])</span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        char_set.add(c)</span><br><span class="line">        res = <span class="built_in">max</span>(res, right - left + <span class="number">1</span>)</span><br><span class="line">        right += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><hr><h3 id="二叉树的层序遍历"><a href="#二叉树的层序遍历" class="headerlink" title="二叉树的层序遍历"></a>二叉树的层序遍历</h3><ul><li>二叉树的层序遍历，也叫作广度优先遍历（BFS，Breadth-First Search），其核心思想是按层级顺序从上到下遍历二叉树的节点，先访问当前层的所有节点，再依次访问下一层的节点。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, val=<span class="number">0</span>, left=<span class="literal">None</span>, right=<span class="literal">None</span></span>):</span><br><span class="line">        self.val = val</span><br><span class="line">        self.left = left</span><br><span class="line">        self.right = right</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">levelOrder</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="built_in">list</span>[<span class="built_in">list</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        </span><br><span class="line">        queue = deque([root])  <span class="comment"># 使用 deque 作为队列</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            level_size = <span class="built_in">len</span>(queue)  <span class="comment"># 当前层的节点数</span></span><br><span class="line">            current_level = []</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(level_size):</span><br><span class="line">                node = queue.popleft()  <span class="comment"># 取出当前层的节点</span></span><br><span class="line">                current_level.append(node.val)</span><br><span class="line">                </span><br><span class="line">                <span class="comment"># 将下一层的节点加入队列</span></span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    queue.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    queue.append(node.right)</span><br><span class="line">            </span><br><span class="line">            result.append(current_level)  <span class="comment"># 将当前层的结果加入最终结果</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><hr><h3 id="对折链表"><a href="#对折链表" class="headerlink" title="对折链表"></a>对折链表</h3><blockquote><p>题目: <a target="_blank" rel="noopener" href="https://leetcode.com/problems/reorder-list/">Leetcode 143. Reorder List</a></p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: head = [1,2,3,4,5]</span><br><span class="line">Output: [1,5,2,4,3]</span><br></pre></td></tr></table></figure><ul><li>解法: 通过快慢指针的方式，找到链表的中点。将链表的后半部分反转，形成新链表。将链表的前半部分和反转后的后半部分交替连接，实现重新排序。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reorderList</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify head in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 1. 使用快慢指针找到链表中点</span></span><br><span class="line">        slow = head</span><br><span class="line">        fast = head.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> fast <span class="keyword">and</span> fast.<span class="built_in">next</span>:</span><br><span class="line">            slow = slow.<span class="built_in">next</span></span><br><span class="line">            fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 2. 反转链表的后半部分</span></span><br><span class="line">        second = slow.<span class="built_in">next</span></span><br><span class="line">        prev = <span class="literal">None</span></span><br><span class="line">        slow.<span class="built_in">next</span> = <span class="literal">None</span>  <span class="comment"># 切断前半部分和后半部分链表的连接</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> second:</span><br><span class="line">            tmp = second.<span class="built_in">next</span></span><br><span class="line">            second.<span class="built_in">next</span> = prev</span><br><span class="line">            prev = second</span><br><span class="line">            second = tmp</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 3. 合并链表</span></span><br><span class="line">        first, second = head, prev  <span class="comment"># first 是前半部分的链表头，second 是反转后的后半部分链表头</span></span><br><span class="line">        <span class="keyword">while</span> second:</span><br><span class="line">            tmp1, tmp2 = first.<span class="built_in">next</span>, second.<span class="built_in">next</span></span><br><span class="line">            first.<span class="built_in">next</span> = second</span><br><span class="line">            second.<span class="built_in">next</span> = tmp1</span><br><span class="line">            first, second = tmp1, tmp2</span><br></pre></td></tr></table></figure><hr><h3 id="删除有序链表中的重复元素"><a href="#删除有序链表中的重复元素" class="headerlink" title="删除有序链表中的重复元素"></a>删除有序链表中的重复元素</h3><blockquote><p>题目: <a target="_blank" rel="noopener" href="https://leetcode.com/problems/remove-duplicates-from-sorted-list/">Leetcode 83. Remove Duplicates from Sorted List</a><br>题目: <a target="_blank" rel="noopener" href="https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/">Leetcode 82. Remove Duplicates from Sorted List II</a></p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: head = [1,1,2,3,3]</span><br><span class="line">Output: [1,2,3]</span><br></pre></td></tr></table></figure><ul><li>解法: 遍历链表删除相邻的重复节点，确保每个值只出现一次。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">deleteDuplicates</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">    curr = head</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> curr <span class="keyword">and</span> curr.<span class="built_in">next</span>:</span><br><span class="line">        <span class="keyword">if</span> curr.val == curr.<span class="built_in">next</span>.val:</span><br><span class="line">            curr.<span class="built_in">next</span> = curr.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            curr = curr.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure><hr><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: head = [1,2,3,3,4,4,5]</span><br><span class="line">Output: [1,2,5]</span><br></pre></td></tr></table></figure><ul><li>解法: 使用一个虚拟头节点来处理可能删除头节点的情况，定义两个指针<code>prev</code>和<code>curr</code>分别指向已处理的最后一个不重复节点和当前遍历节点。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">deleteDuplicates</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">    dummy = ListNode(<span class="number">0</span>, head)</span><br><span class="line"></span><br><span class="line">    prev = dummy</span><br><span class="line">    curr = head</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> curr:</span><br><span class="line">        <span class="comment"># 如果当前节点的值与下一个节点的值相同，则找到所有重复的节点</span></span><br><span class="line">        <span class="keyword">if</span> curr.<span class="built_in">next</span> <span class="keyword">and</span> curr.val == curr.<span class="built_in">next</span>.val:</span><br><span class="line">            <span class="comment"># 跳过所有值相同的节点</span></span><br><span class="line">            <span class="keyword">while</span> curr.<span class="built_in">next</span> <span class="keyword">and</span> curr.val == curr.<span class="built_in">next</span>.val:</span><br><span class="line">                curr = curr.<span class="built_in">next</span></span><br><span class="line">            <span class="comment"># prev 的 next 指向下一个不重复的节点</span></span><br><span class="line">            prev.<span class="built_in">next</span> = curr.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            prev = prev.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        curr = curr.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><hr><h3 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h3><ul><li>斐波那契数列的每一个数字都是前两个数字之和。该数列的前几项如下</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...</span><br></pre></td></tr></table></figure><ul><li>递归实现（简单但效率低）</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 递归</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fibonacci</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">elif</span> n == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> fibonacci(n-<span class="number">1</span>) + fibonacci(n-<span class="number">2</span>)</span><br></pre></td></tr></table></figure><ul><li>优化空间的动态规划</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 动态规划</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fibonacci</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">elif</span> n == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    prev2, prev1 = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n + <span class="number">1</span>):</span><br><span class="line">        curr = prev1 + prev2</span><br><span class="line">        prev2 = prev1</span><br><span class="line">        prev1 = curr</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> prev1</span><br></pre></td></tr></table></figure><hr><h3 id="在每个树行中找最大值"><a href="#在每个树行中找最大值" class="headerlink" title="在每个树行中找最大值"></a>在每个树行中找最大值</h3><blockquote><p>题目: <a target="_blank" rel="noopener" href="https://leetcode.com/problems/find-largest-value-in-each-tree-row/">Leetcode 515. Find Largest Value in Each Tree Row</a></p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: root = [1,3,2,5,3,null,9]</span><br><span class="line">Output: [1,3,9]</span><br></pre></td></tr></table></figure><ul><li>解法: 用<code>BFS</code>去找每一行的最大值。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">largestValues</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">    res = []</span><br><span class="line">    queue = deque([root])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> queue:</span><br><span class="line">        level_size = <span class="built_in">len</span>(queue)</span><br><span class="line">        max_val = <span class="built_in">float</span>(<span class="string">&quot;-inf&quot;</span>)  <span class="comment"># 初始化每一层的最大值为负无穷大</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(level_size):</span><br><span class="line">            node = queue.popleft()</span><br><span class="line">            max_val = <span class="built_in">max</span>(max_val, node.val)  <span class="comment"># 更新最大值</span></span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                queue.append(node.left)</span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                queue.append(node.right)</span><br><span class="line">        res.append(max_val)  <span class="comment"># 将每层的最大值添加到结果列表中</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><hr><h3 id="深度优先搜索-DFS-amp-广度优先搜索-BFS"><a href="#深度优先搜索-DFS-amp-广度优先搜索-BFS" class="headerlink" title="深度优先搜索 (DFS) &amp; 广度优先搜索 (BFS)"></a>深度优先搜索 (DFS) &amp; 广度优先搜索 (BFS)</h3><ul><li>深度优先搜索: <code>DFS</code>是一种通过深入每一个节点并尽可能深地搜索其子节点的遍历算法。可以使用递归或显式栈来实现。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">dfs_recursive</span>(<span class="params">graph, node, visited=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="keyword">if</span> visited <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        visited = <span class="built_in">set</span>()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 访问当前节点</span></span><br><span class="line">    <span class="built_in">print</span>(node)</span><br><span class="line">    visited.add(node)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 递归访问相邻节点</span></span><br><span class="line">    <span class="keyword">for</span> neighbor <span class="keyword">in</span> graph[node]:</span><br><span class="line">        <span class="keyword">if</span> neighbor <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">            dfs_recursive(graph, neighbor, visited)</span><br></pre></td></tr></table></figure><ul><li>广度优先搜索: <code>BFS</code>是一种逐层遍历算法，先访问当前节点的所有相邻节点，再继续访问这些相邻节点的相邻节点。<code>BFS</code>通常用队列来实现。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">bfs</span>(<span class="params">graph, start</span>):</span><br><span class="line">    visited = <span class="built_in">set</span>()</span><br><span class="line">    queue = deque([start])  <span class="comment"># 使用双端队列作为队列</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> queue:</span><br><span class="line">        node = queue.popleft()  <span class="comment"># 从队列中取出第一个节点</span></span><br><span class="line">        <span class="keyword">if</span> node <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">            <span class="built_in">print</span>(node)</span><br><span class="line">            visited.add(node)</span><br><span class="line">            <span class="comment"># 将相邻节点加入队列</span></span><br><span class="line">            queue.extend(graph[node])</span><br></pre></td></tr></table></figure><hr><h3 id="验证二叉搜索树"><a href="#验证二叉搜索树" class="headerlink" title="验证二叉搜索树"></a>验证二叉搜索树</h3><blockquote><p>题目: <a target="_blank" rel="noopener" href="https://leetcode.com/problems/validate-binary-search-tree/">Leetcode 98. Validate Binary Search Tree</a></p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: root = [2,1,3]</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><ul><li>解法: 使用递归，通过维护每个节点的上下界（最小值和最大值）来验证二叉树是否是合法的二叉搜索树</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">isValidBST</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">    <span class="comment"># 递归函数，传入当前节点和其值的上下边界</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">validate</span>(<span class="params">node, low, high</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="comment"># 当前节点值必须在(low, high)范围内</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> (low &lt; node.val &lt; high):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="comment"># 递归检查左子树和右子树</span></span><br><span class="line">        <span class="keyword">return</span> validate(node.left, low, node.val) <span class="keyword">and</span> validate(</span><br><span class="line">            node.right, node.val, high</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> validate(root, <span class="built_in">float</span>(<span class="string">&quot;-inf&quot;</span>), <span class="built_in">float</span>(<span class="string">&quot;inf&quot;</span>))</span><br></pre></td></tr></table></figure><hr><h3 id="括号匹配"><a href="#括号匹配" class="headerlink" title="括号匹配"></a>括号匹配</h3><blockquote><p>题目: <a target="_blank" rel="noopener" href="https://leetcode.com/problems/valid-parentheses/">Leetcode 20. Valid Parentheses</a><br>题目: <a target="_blank" rel="noopener" href="https://leetcode.com/problems/generate-parentheses/">Leetcode 22. Generate Parentheses</a></p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: s = &quot;()[]&#123;&#125;&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><ul><li>解法: 通过栈来验证括号是否有效。当遇到左括号时，将其压入栈中；当遇到右括号时，检查栈顶是否为对应的左括号，如果匹配，则弹出栈顶元素。如果不匹配或者栈为空，则返回<code>False</code>。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">isValid</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">    <span class="comment"># 定义右括号到左括号的映射</span></span><br><span class="line">    char_map = &#123;<span class="string">&quot;)&quot;</span>: <span class="string">&quot;(&quot;</span>, <span class="string">&quot;]&quot;</span>: <span class="string">&quot;[&quot;</span>, <span class="string">&quot;&#125;&quot;</span>: <span class="string">&quot;&#123;&quot;</span>&#125;</span><br><span class="line">    stack = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">        <span class="comment"># 如果是左括号，将其压入栈中</span></span><br><span class="line">        <span class="keyword">if</span> c <span class="keyword">not</span> <span class="keyword">in</span> char_map:</span><br><span class="line">            stack.append(c)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 如果栈为空或者栈顶元素不匹配当前右括号，返回 False</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> stack <span class="keyword">or</span> stack[-<span class="number">1</span>] != char_map[c]:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 匹配成功，弹出栈顶元素</span></span><br><span class="line">        stack.pop()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">not</span> stack</span><br></pre></td></tr></table></figure><hr><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: n = 3</span><br><span class="line">Output: [&quot;((()))&quot;,&quot;(()())&quot;,&quot;(())()&quot;,&quot;()(())&quot;,&quot;()()()&quot;]</span><br></pre></td></tr></table></figure><ul><li>解法: 用递归地构建括号组合。每次递归调用时，会尝试添加一个左括号或右括号。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">generateParenthesis</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">str</span>]:</span><br><span class="line">    res = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">s, left, right</span>):</span><br><span class="line">        <span class="comment"># 当字符串长度等于 2 * n 时，说明所有括号已添加完毕</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(s) == <span class="number">2</span> * n:</span><br><span class="line">            res.append(s)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 如果左括号数量小于 n，则可以添加左括号</span></span><br><span class="line">        <span class="keyword">if</span> left &lt; n:</span><br><span class="line">            backtrack(s + <span class="string">&quot;(&quot;</span>, left + <span class="number">1</span>, right)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 如果右括号数量小于左括号，则可以添加右括号</span></span><br><span class="line">        <span class="keyword">if</span> right &lt; left:</span><br><span class="line">            backtrack(s + <span class="string">&quot;)&quot;</span>, left, right + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    backtrack(<span class="string">&quot;&quot;</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><hr><h3 id="二叉树最大差值"><a href="#二叉树最大差值" class="headerlink" title="二叉树最大差值"></a>二叉树最大差值</h3><blockquote><p>题目: <a target="_blank" rel="noopener" href="https://leetcode.com/problems/maximum-difference-between-node-and-ancestor/">Leetcode 1026. Maximum Difference Between Node and Ancestor</a></p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: root = [8,3,10,1,6,null,14,null,null,4,7,13]</span><br><span class="line">Output: 7</span><br></pre></td></tr></table></figure><ul><li>解法: 使用深度优先搜索（DFS）遍历二叉树，同时在递归过程中维护当前路径上的最大值和最小值。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">maxAncestorDiff</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxDiff</span>(<span class="params">node, curr_min, curr_max</span>):</span><br><span class="line">        <span class="comment"># 如果节点为空，返回当前最大值和最小值的差值</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">            <span class="keyword">return</span> curr_max - curr_min</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 更新当前路径中的最小值和最大值</span></span><br><span class="line">        curr_min = <span class="built_in">min</span>(curr_min, node.val)</span><br><span class="line">        curr_max = <span class="built_in">max</span>(curr_max, node.val)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 递归左子树和右子树</span></span><br><span class="line">        left_diff = maxDiff(node.left, curr_min, curr_max)</span><br><span class="line">        right_diff = maxDiff(node.right, curr_min, curr_max)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 返回左子树和右子树中的最大差值</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(left_diff, right_diff)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> maxDiff(root, root.val, root.val)</span><br></pre></td></tr></table></figure><hr><h3 id="整数反转"><a href="#整数反转" class="headerlink" title="整数反转"></a>整数反转</h3><blockquote><p>题目: <a target="_blank" rel="noopener" href="https://leetcode.com/problems/reverse-integer/">Leetcode 7. Reverse Integer</a></p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: x = 123</span><br><span class="line">Output: 321</span><br></pre></td></tr></table></figure><ul><li>解法: 通过取余和整除操作逐位反转整数。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">reverse</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="comment"># 定义 32 位整数的上下限</span></span><br><span class="line">    INT_MIN, INT_MAX = -(<span class="number">2</span>**<span class="number">31</span>), <span class="number">2</span>**<span class="number">31</span> - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    <span class="comment"># 记录 x 的符号，确保处理负数情况</span></span><br><span class="line">    sign = -<span class="number">1</span> <span class="keyword">if</span> x &lt; <span class="number">0</span> <span class="keyword">else</span> <span class="number">1</span></span><br><span class="line">    x = <span class="built_in">abs</span>(x)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> x != <span class="number">0</span>:</span><br><span class="line">        digit = x % <span class="number">10</span></span><br><span class="line">        res = res * <span class="number">10</span> + digit</span><br><span class="line">        x //= <span class="number">10</span></span><br><span class="line"></span><br><span class="line">    res *= sign</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> res &lt; INT_MIN <span class="keyword">or</span> res &gt; INT_MAX:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><hr><h3 id="不同的二叉搜索树"><a href="#不同的二叉搜索树" class="headerlink" title="不同的二叉搜索树"></a>不同的二叉搜索树</h3><blockquote><p>题目: <a target="_blank" rel="noopener" href="https://leetcode.com/problems/unique-binary-search-trees/">Leetcode Unique Binary Search Trees. Reverse Integer</a></p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: n = 3</span><br><span class="line">Output: 5</span><br></pre></td></tr></table></figure><ul><li>解法: 构造长度为<code>n</code>的二叉搜索树的数量遵循卡特兰数公式。我们定义<code>G[i]</code>表示有<code>i</code>个节点的不同二叉搜索树的数量。通过递推公式<code>G[i] = G[j-1] * G[i-j]</code>，即选择<code>j</code>为根时，左子树节点数量为<code>j-1</code>，右子树节点数量为<code>i-j</code>，对所有可能的<code>j</code>进行求和，最终计算出<code>G[n]</code>。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">numTrees</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="comment"># G[i] 表示 i 个节点可以组成的不同二叉搜索树的数量</span></span><br><span class="line">    G = [<span class="number">0</span>] * (n + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 空树和只有一个节点的树都只有一种情况</span></span><br><span class="line">    G[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">    G[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算 G[2] 到 G[n] 的值</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, i + <span class="number">1</span>):</span><br><span class="line">            <span class="comment"># G[i] 是对所有的 G[j-1] * G[i-j] 求和</span></span><br><span class="line">            G[i] += G[j - <span class="number">1</span>] * G[i - j]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> G[n]</span><br></pre></td></tr></table></figure><hr><h3 id="螺旋矩阵"><a href="#螺旋矩阵" class="headerlink" title="螺旋矩阵"></a>螺旋矩阵</h3><blockquote><p>题目: <a target="_blank" rel="noopener" href="https://leetcode.com/problems/spiral-matrix/">Leetcode 54. Spiral Matrix</a></p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: matrix = [[1,2,3],[4,5,6],[7,8,9]]</span><br><span class="line">Output: [1,2,3,6,9,8,7,4,5]</span><br></pre></td></tr></table></figure><ul><li>解法: 从左到右遍历矩阵的最上层，然后从上到下遍历最右边的列，接着从右到左遍历最底层，最后从下到上遍历最左边的列。不断地缩小范围，直到遍历完整个矩阵。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">spiralOrder</span>(<span class="params">self, matrix: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">    top, bottom = <span class="number">0</span>, <span class="built_in">len</span>(matrix) - <span class="number">1</span></span><br><span class="line">    left, right = <span class="number">0</span>, <span class="built_in">len</span>(matrix[<span class="number">0</span>]) - <span class="number">1</span></span><br><span class="line">    res = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> top &lt;= bottom <span class="keyword">and</span> left &lt;= right:</span><br><span class="line">        <span class="comment"># 从左到右遍历最上面一行</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(left, right + <span class="number">1</span>):</span><br><span class="line">            res.append(matrix[top][i])</span><br><span class="line">        top += <span class="number">1</span>  <span class="comment"># 上边界向下移动</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 从上到下遍历最右边一列</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(top, bottom + <span class="number">1</span>):</span><br><span class="line">            res.append(matrix[i][right])</span><br><span class="line">        right -= <span class="number">1</span>  <span class="comment"># 右边界向左移动</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> top &lt;= bottom:</span><br><span class="line">            <span class="comment"># 从右到左遍历最下面一行</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(right, left - <span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                res.append(matrix[bottom][i])</span><br><span class="line">            bottom -= <span class="number">1</span>  <span class="comment"># 下边界向上移动</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> left &lt;= right:</span><br><span class="line">            <span class="comment"># 从下到上遍历最左边一列</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(bottom, top - <span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                res.append(matrix[i][left])</span><br><span class="line">            left += <span class="number">1</span>  <span class="comment"># 左边界向右移动</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><hr><h3 id="数独"><a href="#数独" class="headerlink" title="数独"></a>数独</h3><blockquote><p>题目: <a target="_blank" rel="noopener" href="https://leetcode.com/problems/valid-sudoku/">Leetcode 36. Valid Sudoku</a></p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: board = </span><br><span class="line">[[&quot;5&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;]</span><br><span class="line">,[&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;]</span><br><span class="line">,[&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;]</span><br><span class="line">,[&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;]</span><br><span class="line">,[&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;]</span><br><span class="line">,[&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;]</span><br><span class="line">,[&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;]</span><br><span class="line">,[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;]</span><br><span class="line">,[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]]</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><ul><li>解法: 转换成每一行、每一列和每一个<code>3x3</code>的小方块中不能出现重复的数字。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">isValidSudoku</span>(<span class="params">self, board: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">    <span class="comment"># 创建三个字典来记录每行、每列、每个3x3方块中已出现的数字</span></span><br><span class="line">    rows = collections.defaultdict(<span class="built_in">set</span>)</span><br><span class="line">    cols = collections.defaultdict(<span class="built_in">set</span>)</span><br><span class="line">    squares = collections.defaultdict(<span class="built_in">set</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> r <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">            <span class="keyword">if</span> board[r][c] == <span class="string">&quot;.&quot;</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 检查当前数字是否在同一行、同一列或同一个3x3方块中已经存在</span></span><br><span class="line">            <span class="keyword">if</span> (</span><br><span class="line">                board[r][c] <span class="keyword">in</span> rows[r]</span><br><span class="line">                <span class="keyword">or</span> board[r][c] <span class="keyword">in</span> cols[c]</span><br><span class="line">                <span class="keyword">or</span> board[r][c] <span class="keyword">in</span> squares[(r // <span class="number">3</span>, c // <span class="number">3</span>)]</span><br><span class="line">            ):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 如果当前数字没有在行、列或3x3方块中出现过，将其添加到相应的集合中</span></span><br><span class="line">            cols[c].add(board[r][c])</span><br><span class="line">            rows[r].add(board[r][c])</span><br><span class="line">            squares[(r // <span class="number">3</span>, c // <span class="number">3</span>)].add(board[r][c])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><hr><h3 id="全排列"><a href="#全排列" class="headerlink" title="全排列"></a>全排列</h3><blockquote><p>题目: <a target="_blank" rel="noopener" href="https://leetcode.com/problems/permutations/">Leetcode 46. Permutations</a><br>题目: <a target="_blank" rel="noopener" href="https://leetcode.com/problems/permutations-ii/">Leetcode 47. Permutations II</a></p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: nums = [1,2,3]</span><br><span class="line">Output: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</span><br></pre></td></tr></table></figure><ul><li>解法: 使用回溯算法来生成所有的排列。通过递归构建排列路径，依次选择数组中的每个元素加入当前路径，并标记为已使用。当路径长度等于数组长度时，将当前排列加入结果集。递归返回时，撤销最近的选择并尝试其他未使用的元素，直到生成所有排列。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">permute</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">    res = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">path, used</span>):</span><br><span class="line">        <span class="comment"># 当排列的长度等于原数组的长度时，添加到结果集中</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(path) == <span class="built_in">len</span>(nums):</span><br><span class="line">            res.append(path[:])</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span> used[i]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 做选择</span></span><br><span class="line">            path.append(nums[i])</span><br><span class="line">            used[i] = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 递归生成下一个数字的排列</span></span><br><span class="line">            backtrack(path, used)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 撤销选择</span></span><br><span class="line">            path.pop()</span><br><span class="line">            used[i] = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 初始化回溯的路径和使用状态</span></span><br><span class="line">    backtrack([], [<span class="literal">False</span>] * <span class="built_in">len</span>(nums))</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><hr><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: nums = [1,1,2]</span><br><span class="line">Output:</span><br><span class="line">[[1,1,2],</span><br><span class="line"> [1,2,1],</span><br><span class="line"> [2,1,1]]</span><br></pre></td></tr></table></figure><ul><li>解法: 对<code>nums</code>进行排序，这是为了方便去重。当数字相同时，可以通过检查前一个数字是否被使用过来决定是否跳过当前数字。然后就是和上面题目一模一样的解法。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">permuteUnique</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">    res = []</span><br><span class="line">    nums.sort()  <span class="comment"># 先对数组排序，方便去重</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">path, used</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(path) == <span class="built_in">len</span>(nums):</span><br><span class="line">            res.append(path[:])</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span> used[i]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 如果当前数字和前一个数字相同，并且前一个数字还未被使用，则跳过</span></span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i - <span class="number">1</span>] <span class="keyword">and</span> <span class="keyword">not</span> used[i - <span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            path.append(nums[i])</span><br><span class="line">            used[i] = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">            backtrack(path, used)</span><br><span class="line"></span><br><span class="line">            path.pop()</span><br><span class="line">            used[i] = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    backtrack([], [<span class="literal">False</span>] * (<span class="built_in">len</span>(nums) + <span class="number">1</span>))</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><hr><h3 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h3><blockquote><p>题目: <a target="_blank" rel="noopener" href="https://leetcode.com/problems/balanced-binary-tree/">Leetcode 110. Balanced Binary Tree</a></p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: root = [3,9,20,null,null,15,7]</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><ul><li>解法: 使用深度优先搜索（<code>DFS</code>）来检查二叉树是否平衡。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">isBalanced</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">root</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> [<span class="literal">True</span>, <span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        left, right = dfs(root.left), dfs(root.right)</span><br><span class="line">        balanced = left[<span class="number">0</span>] <span class="keyword">and</span> right[<span class="number">0</span>] <span class="keyword">and</span> <span class="built_in">abs</span>(left[<span class="number">1</span>] - right[<span class="number">1</span>]) &lt;= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> [balanced, <span class="number">1</span> + <span class="built_in">max</span>(left[<span class="number">1</span>], right[<span class="number">1</span>])]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dfs(root)[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><hr><h3 id="BST-第-k-大的节点"><a href="#BST-第-k-大的节点" class="headerlink" title="BST 第 k 大的节点"></a>BST 第 k 大的节点</h3><blockquote><p>题目: <a target="_blank" rel="noopener" href="https://leetcode.com/problems/kth-smallest-element-in-a-bst/">Leetcode 230. Kth Smallest Element in a BST</a></p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: root = [3,1,4,null,2], k = 1</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure><ul><li>解法: 利用中序遍历的特点来找到二叉搜索树（<code>BST</code>）中的第<code>k</code>小节点。因为二叉搜索树的中序遍历结果是递增的有序序列，所以中序遍历过程中，当访问到第<code>k</code>个节点时，它就是第<code>k</code>小的节点。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">kthSmallest</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="comment"># 中序遍历得到的节点值列表</span></span><br><span class="line">    self.count = <span class="number">0</span>  <span class="comment"># 记录当前的节点计数</span></span><br><span class="line">    self.result = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inorder_traversal</span>(<span class="params">node</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 遍历左子树</span></span><br><span class="line">        inorder_traversal(node.left)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 处理当前节点</span></span><br><span class="line">        self.count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> self.count == k:</span><br><span class="line">            self.result = node.val</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 遍历右子树</span></span><br><span class="line">        inorder_traversal(node.right)</span><br><span class="line"></span><br><span class="line">    inorder_traversal(root)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> self.result</span><br></pre></td></tr></table></figure><hr><h3 id="最接近的三数之和"><a href="#最接近的三数之和" class="headerlink" title="最接近的三数之和"></a>最接近的三数之和</h3><blockquote><p>题目: <a target="_blank" rel="noopener" href="https://leetcode.com/problems/3sum-closest/">Leetcode 16. 3Sum Closest</a></p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: nums = [-1,2,1,-4], target = 1</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).</span><br></pre></td></tr></table></figure><ul><li>解法: 通过排序 + 双指针来找到最接近目标的三数之和。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">threeSumClosest</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    nums.sort()</span><br><span class="line">    res = <span class="built_in">float</span>(<span class="string">&quot;inf&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 遍历数组，取每一个元素作为三元组的第一个数</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums) - <span class="number">2</span>):</span><br><span class="line">        left = i + <span class="number">1</span></span><br><span class="line">        right = <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            curr = nums[i] + nums[left] + nums[right]</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 如果当前三数之和比记录的最接近值更接近目标值，则更新</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">abs</span>(curr - target) &lt; <span class="built_in">abs</span>(res - target):</span><br><span class="line">                res = curr</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 根据当前的和与目标的比较，移动左右指针</span></span><br><span class="line">            <span class="keyword">if</span> curr &lt; target:</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> curr &gt; target:</span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> curr</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><hr><h3 id="前序，中序，后序"><a href="#前序，中序，后序" class="headerlink" title="前序，中序，后序"></a>前序，中序，后序</h3><ul><li>前序遍历顺序为：根节点 -&gt; 左子树 -&gt; 右子树</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">preorder</span>(<span class="params">root</span>):</span><br><span class="line">    <span class="keyword">if</span> root:</span><br><span class="line">        <span class="built_in">print</span>(root.val)  <span class="comment"># 先访问根节点</span></span><br><span class="line">        preorder(root.left)  <span class="comment"># 递归访问左子树</span></span><br><span class="line">        preorder(root.right)  <span class="comment"># 递归访问右子树</span></span><br></pre></td></tr></table></figure><ul><li>中序遍历顺序为：左子树 -&gt; 根节点 -&gt; 右子树</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">inorder</span>(<span class="params">root</span>):</span><br><span class="line">    <span class="keyword">if</span> root:</span><br><span class="line">        inorder(root.left)  <span class="comment"># 递归访问左子树</span></span><br><span class="line">        <span class="built_in">print</span>(root.val)  <span class="comment"># 访问根节点</span></span><br><span class="line">        inorder(root.right)  <span class="comment"># 递归访问右子树</span></span><br></pre></td></tr></table></figure><ul><li>后序遍历顺序为：左子树 -&gt; 右子树 -&gt; 根节点</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">postorder</span>(<span class="params">root</span>):</span><br><span class="line">    <span class="keyword">if</span> root:</span><br><span class="line">        postorder(root.left)  <span class="comment"># 递归访问左子树</span></span><br><span class="line">        postorder(root.right)  <span class="comment"># 递归访问右子树</span></span><br><span class="line">        <span class="built_in">print</span>(root.val)  <span class="comment"># 最后访问根节点</span></span><br></pre></td></tr></table></figure><hr><h3 id="36-手写-Promise-all"><a href="#36-手写-Promise-all" class="headerlink" title="36. 手写 Promise.all"></a>36. 手写 Promise.all</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">myPromiseAll</span>(<span class="params">promises</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> results = [];</span><br><span class="line">        <span class="keyword">let</span> completedPromises = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">const</span> totalPromises = promises.<span class="property">length</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果传入的数组是空的，直接返回一个 resolved 的 Promise</span></span><br><span class="line">        <span class="keyword">if</span> (totalPromises === <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="title function_">resolve</span>(results);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历传入的 Promise 数组</span></span><br><span class="line">        promises.<span class="title function_">forEach</span>(<span class="function">(<span class="params">promise, index</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(promise)</span><br><span class="line">                .<span class="title function_">then</span>(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">                    results[index] = result;</span><br><span class="line">                    completedPromises += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 如果所有 Promise 都已经 resolved，resolve 主 Promise</span></span><br><span class="line">                    <span class="keyword">if</span> (completedPromises === totalPromises) &#123;</span><br><span class="line">                        <span class="title function_">resolve</span>(results);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                .<span class="title function_">catch</span>(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">                    <span class="comment">// 如果有一个 Promise 被 rejected，reject 主 Promise</span></span><br><span class="line">                    <span class="title function_">reject</span>(error);</span><br><span class="line">                &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="37-手写-new"><a href="#37-手写-new" class="headerlink" title="37. 手写 new"></a>37. 手写 new</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">_new</span>(<span class="params">obj, ...rest</span>)&#123;</span><br><span class="line">  <span class="comment">// 基于obj的原型创建一个新的对象</span></span><br><span class="line">  <span class="keyword">const</span> newObj = <span class="title class_">Object</span>.<span class="title function_">create</span>(obj.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 添加属性到新创建的newObj上, 并获取obj函数执行的结果.</span></span><br><span class="line">  <span class="keyword">const</span> result = obj.<span class="title function_">apply</span>(newObj, rest);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果执行结果有返回值并且是一个对象, 返回执行的结果, 否则, 返回新创建的对象</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> result === <span class="string">&#x27;object&#x27;</span> ? result : newObj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="38-手写-EventEmitter"><a href="#38-手写-EventEmitter" class="headerlink" title="38. 手写 EventEmitter"></a>38. 手写 EventEmitter</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">EventEmitter</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 用于存储事件及其回调函数的映射</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">events</span> = &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 订阅事件</span></span><br><span class="line">  <span class="title function_">on</span>(<span class="params">event, listener</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果事件不存在，创建一个新数组来存储回调函数</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">events</span>[event]) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">events</span>[event] = [];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将回调函数添加到事件的回调数组中</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">events</span>[event].<span class="title function_">push</span>(listener);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 取消订阅事件</span></span><br><span class="line">  <span class="title function_">off</span>(<span class="params">event, listenerToRemove</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">events</span>[event]) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 过滤掉要移除的回调函数</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">events</span>[event] = <span class="variable language_">this</span>.<span class="property">events</span>[event].<span class="title function_">filter</span>(<span class="function"><span class="params">listener</span> =&gt;</span> listener !== listenerToRemove);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 只订阅一次</span></span><br><span class="line">  <span class="title function_">once</span>(<span class="params">event, listener</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">onceListener</span> = (<span class="params">...args</span>) =&gt; &#123;</span><br><span class="line">      <span class="comment">// 调用回调函数</span></span><br><span class="line">      <span class="title function_">listener</span>(...args);</span><br><span class="line">      <span class="comment">// 调用后取消订阅</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">off</span>(event, onceListener);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 订阅该临时回调</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">on</span>(event, onceListener);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 触发事件</span></span><br><span class="line">  <span class="title function_">emit</span>(<span class="params">event, ...args</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">events</span>[event]) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用所有订阅的回调函数</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">events</span>[event].<span class="title function_">forEach</span>(<span class="function"><span class="params">listener</span> =&gt;</span> <span class="title function_">listener</span>(...args));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用示例</span></span><br><span class="line"><span class="keyword">const</span> emitter = <span class="keyword">new</span> <span class="title class_">EventEmitter</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 订阅事件</span></span><br><span class="line">emitter.<span class="title function_">on</span>(<span class="string">&#x27;sayHello&#x27;</span>, <span class="function"><span class="params">name</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hello, <span class="subst">$&#123;name&#125;</span>!`</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 触发事件</span></span><br><span class="line">emitter.<span class="title function_">emit</span>(<span class="string">&#x27;sayHello&#x27;</span>, <span class="string">&#x27;Alice&#x27;</span>); <span class="comment">// 输出：Hello, Alice!</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 一次性订阅事件</span></span><br><span class="line">emitter.<span class="title function_">once</span>(<span class="string">&#x27;greetOnce&#x27;</span>, <span class="function"><span class="params">name</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Greetings, <span class="subst">$&#123;name&#125;</span>! This will only happen once.`</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 触发事件</span></span><br><span class="line">emitter.<span class="title function_">emit</span>(<span class="string">&#x27;greetOnce&#x27;</span>, <span class="string">&#x27;Bob&#x27;</span>); <span class="comment">// 输出：Greetings, Bob! This will only happen once.</span></span><br><span class="line">emitter.<span class="title function_">emit</span>(<span class="string">&#x27;greetOnce&#x27;</span>, <span class="string">&#x27;Charlie&#x27;</span>); <span class="comment">// 不输出</span></span><br></pre></td></tr></table></figure><hr><h3 id="39-手写防抖"><a href="#39-手写防抖" class="headerlink" title="39. 手写防抖"></a>39. 手写防抖</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">fn, wait = <span class="number">50</span></span>) &#123;</span><br><span class="line">    <span class="comment">// 通过闭包缓存一个定时器 id</span></span><br><span class="line">    <span class="keyword">let</span> timer = <span class="literal">null</span></span><br><span class="line">    <span class="comment">// 将 debounce 处理结果当作函数返回</span></span><br><span class="line">    <span class="comment">// 触发事件回调时执行这个返回函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">        <span class="comment">// this保存给context</span></span><br><span class="line">        <span class="keyword">const</span> context = <span class="variable language_">this</span></span><br><span class="line">      	<span class="comment">// 如果已经设定过定时器就清空上一次的定时器</span></span><br><span class="line">        <span class="keyword">if</span> (timer) <span class="built_in">clearTimeout</span>(timer)</span><br><span class="line">      </span><br><span class="line">      	<span class="comment">// 开始设定一个新的定时器，定时器结束后执行传入的函数 fn</span></span><br><span class="line">        timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            fn.<span class="title function_">apply</span>(context, args)</span><br><span class="line">        &#125;, wait)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DEMO</span></span><br><span class="line"><span class="comment">// 执行 debounce 函数返回新函数</span></span><br><span class="line"><span class="keyword">const</span> betterFn = <span class="title function_">debounce</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;fn 防抖执行了&#x27;</span>), <span class="number">1000</span>)</span><br><span class="line"><span class="comment">// 停止滑动 1 秒后执行函数 () =&gt; console.log(&#x27;fn 防抖执行了&#x27;)</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;scroll&#x27;</span>, betterFn)</span><br></pre></td></tr></table></figure><hr><h3 id="40-手写节流"><a href="#40-手写节流" class="headerlink" title="40. 手写节流"></a>40. 手写节流</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// fn 是需要执行的函数</span></span><br><span class="line"><span class="comment">// wait 是时间间隔</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">throttle</span> = (<span class="params">fn, wait = <span class="number">50</span></span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 上一次执行 fn 的时间</span></span><br><span class="line">  <span class="keyword">let</span> previous = <span class="number">0</span></span><br><span class="line">  <span class="comment">// 将 throttle 处理结果当作函数返回</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">    <span class="comment">// 获取当前时间，转换成时间戳，单位毫秒</span></span><br><span class="line">    <span class="keyword">let</span> now = +<span class="keyword">new</span> <span class="title class_">Date</span>()</span><br><span class="line">    <span class="comment">// 将当前时间和上一次执行函数的时间进行对比</span></span><br><span class="line">    <span class="comment">// 大于等待时间就把 previous 设置为当前时间并执行函数 fn</span></span><br><span class="line">    <span class="keyword">if</span> (now - previous &gt; wait) &#123;</span><br><span class="line">      previous = now</span><br><span class="line">      fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DEMO</span></span><br><span class="line"><span class="comment">// 执行 throttle 函数返回新函数</span></span><br><span class="line"><span class="keyword">const</span> betterFn = <span class="title function_">throttle</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;fn 函数执行了&#x27;</span>), <span class="number">1000</span>)</span><br><span class="line"><span class="comment">// 每 10 毫秒执行一次 betterFn 函数，但是只有时间差大于 1000 时才会执行 fn</span></span><br><span class="line"><span class="built_in">setInterval</span>(betterFn, <span class="number">10</span>)</span><br></pre></td></tr></table></figure><hr><h3 id="41-手写弱拷贝"><a href="#41-手写弱拷贝" class="headerlink" title="41. 手写弱拷贝"></a>41. 手写弱拷贝</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个浅拷贝函数，接收一个目标对象或数组</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">shallowClone</span> = target =&gt; &#123;</span><br><span class="line">  <span class="comment">// 判断 target 是否为对象或数组，并且排除 null</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> target === <span class="string">&#x27;object&#x27;</span> &amp;&amp; target !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果 target 是数组，初始化为空数组；否则，初始化为空对象</span></span><br><span class="line">    <span class="keyword">const</span> cloneTarget = <span class="title class_">Array</span>.<span class="title function_">isArray</span>(target) ? [] : &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 遍历 target 对象的所有属性</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> prop <span class="keyword">in</span> target) &#123;</span><br><span class="line">      <span class="comment">// 检查属性是否为 target 自身的属性，而不是原型链上的属性</span></span><br><span class="line">      <span class="keyword">if</span> (target.<span class="title function_">hasOwnProperty</span>(prop)) &#123;</span><br><span class="line">        <span class="comment">// 将属性值复制给新对象或数组的对应属性</span></span><br><span class="line">        cloneTarget[prop] = target[prop]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回拷贝后的对象或数组</span></span><br><span class="line">    <span class="keyword">return</span> cloneTarget</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 如果 target 是基本类型，直接返回它的值</span></span><br><span class="line">    <span class="keyword">return</span> target</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="42-手写深拷贝"><a href="#42-手写深拷贝" class="headerlink" title="42. 手写深拷贝"></a>42. 手写深拷贝</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">simpleDeepClone</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="comment">// 如果是基本数据类型或 null，直接返回</span></span><br><span class="line">  <span class="keyword">if</span> (obj === <span class="literal">null</span> || <span class="keyword">typeof</span> obj !== <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果是数组，遍历复制每个元素</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(obj)) &#123;</span><br><span class="line">    <span class="keyword">return</span> obj.<span class="title function_">map</span>(<span class="function"><span class="params">item</span> =&gt;</span> <span class="title function_">simpleDeepClone</span>(item));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果是对象，遍历复制每个属性</span></span><br><span class="line">  <span class="keyword">const</span> clonedObj = &#123;&#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="keyword">if</span> (obj.<span class="title function_">hasOwnProperty</span>(key)) &#123;</span><br><span class="line">      clonedObj[key] = <span class="title function_">simpleDeepClone</span>(obj[key]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> clonedObj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="43-手写-reduce"><a href="#43-手写-reduce" class="headerlink" title="43.  手写 reduce"></a>43. 手写 reduce</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">simpleReduce</span> = <span class="keyword">function</span>(<span class="params">callback, initialValue</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> accumulator = initialValue;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="variable language_">this</span>.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    accumulator = <span class="title function_">callback</span>(accumulator, <span class="variable language_">this</span>[i], i, <span class="variable language_">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> accumulator;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">const</span> result = arr.<span class="title function_">simpleReduce</span>(<span class="function">(<span class="params">acc, curr</span>) =&gt;</span> acc + curr, <span class="number">0</span>); <span class="comment">// 输出: 10</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result);</span><br></pre></td></tr></table></figure><hr><h3 id="44-手写数组扁平化"><a href="#44-手写数组扁平化" class="headerlink" title="44. 手写数组扁平化"></a>44. 手写数组扁平化</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">flattenArray</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> result = [];</span><br><span class="line"></span><br><span class="line">  arr.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(item)) &#123;</span><br><span class="line">      <span class="comment">// 如果是数组，递归展开</span></span><br><span class="line">      result = result.<span class="title function_">concat</span>(<span class="title function_">flattenArray</span>(item));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 如果不是数组，直接添加到结果数组中</span></span><br><span class="line">      result.<span class="title function_">push</span>(item);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="keyword">const</span> nestedArray = [<span class="number">1</span>, [<span class="number">2</span>, [<span class="number">3</span>, [<span class="number">4</span>]], <span class="number">5</span>]];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">flattenArray</span>(nestedArray));</span><br></pre></td></tr></table></figure><hr><h3 id="45-手写数组转为树形结构"><a href="#45-手写数组转为树形结构" class="headerlink" title="45. 手写数组转为树形结构"></a>45. 手写数组转为树形结构</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">buildTree</span>(<span class="params">data</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> map = &#123;&#125;;</span><br><span class="line">  <span class="keyword">const</span> result = [];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始化节点的 children 数组</span></span><br><span class="line">  data.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    map[item.<span class="property">id</span>] = &#123; ...item, <span class="attr">children</span>: [] &#125;;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 构造树</span></span><br><span class="line">  data.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> parent = map[item.<span class="property">pid</span>];</span><br><span class="line">    <span class="keyword">if</span> (parent) &#123;</span><br><span class="line">      <span class="comment">// 如果有父节点，放到父节点的 children 中</span></span><br><span class="line">      parent.<span class="property">children</span>.<span class="title function_">push</span>(map[item.<span class="property">id</span>]);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 如果没有父节点（说明是根节点），放到结果中</span></span><br><span class="line">      result.<span class="title function_">push</span>(map[item.<span class="property">id</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> tree = <span class="title function_">buildTree</span>(data);</span><br></pre></td></tr></table></figure><hr><h3 id="46-手写-hook"><a href="#46-手写-hook" class="headerlink" title="46. 手写 hook"></a>46. 手写 hook</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">useFetch</span>(<span class="params">url</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [data, setData] = <span class="title function_">useState</span>(<span class="literal">null</span>); <span class="comment">// 存储数据</span></span><br><span class="line">  <span class="keyword">const</span> [loading, setLoading] = <span class="title function_">useState</span>(<span class="literal">true</span>); <span class="comment">// 存储加载状态</span></span><br><span class="line">  <span class="keyword">const</span> [error, setError] = <span class="title function_">useState</span>(<span class="literal">null</span>); <span class="comment">// 存储错误信息</span></span><br><span class="line"></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 当 URL 改变时，重新发起请求</span></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">fetchData</span> = <span class="keyword">async</span> (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">      <span class="title function_">setLoading</span>(<span class="literal">true</span>); <span class="comment">// 开始加载</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> response = <span class="keyword">await</span> <span class="title function_">fetch</span>(url); <span class="comment">// 发起请求</span></span><br><span class="line">        <span class="keyword">const</span> result = <span class="keyword">await</span> response.<span class="title function_">json</span>(); <span class="comment">// 解析数据</span></span><br><span class="line">        <span class="title function_">setData</span>(result); <span class="comment">// 保存数据</span></span><br><span class="line">      &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">        <span class="title function_">setError</span>(err); <span class="comment">// 捕获并保存错误</span></span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="title function_">setLoading</span>(<span class="literal">false</span>); <span class="comment">// 请求结束，更新加载状态</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">fetchData</span>();</span><br><span class="line">  &#125;, [url]); <span class="comment">// 依赖 URL，当 URL 改变时重新请求数据</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123; data, loading, error &#125;; <span class="comment">// 返回数据、加载状态和错误信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="47-手写-Promise-race"><a href="#47-手写-Promise-race" class="headerlink" title="47. 手写 Promise.race"></a>47. 手写 Promise.race</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">promiseRace</span>(<span class="params">promises</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 遍历传入的 promises</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> promise <span class="keyword">of</span> promises) &#123;</span><br><span class="line">      <span class="comment">// 使用 Promise.resolve 将所有值转化为 Promise</span></span><br><span class="line">      <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(promise)</span><br><span class="line">        .<span class="title function_">then</span>(resolve)  <span class="comment">// 如果当前 promise 首先完成，resolve 外层 promise</span></span><br><span class="line">        .<span class="title function_">catch</span>(reject); <span class="comment">// 如果当前 promise 首先被拒绝，reject 外层 promise</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="48-手写-Pub-x2F-Sub"><a href="#48-手写-Pub-x2F-Sub" class="headerlink" title="48. 手写 Pub&#x2F;Sub"></a>48. 手写 Pub&#x2F;Sub</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PubSub</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">events</span> = &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 订阅</span></span><br><span class="line">  <span class="title function_">subscribe</span>(<span class="params">event, listener</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">events</span>[event]) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">events</span>[event] = [];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">events</span>[event].<span class="title function_">push</span>(listener);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 发布</span></span><br><span class="line">  <span class="title function_">publish</span>(<span class="params">event, data</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">events</span>[event]) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">events</span>[event].<span class="title function_">forEach</span>(<span class="function"><span class="params">listener</span> =&gt;</span> <span class="title function_">listener</span>(data));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 取消订阅</span></span><br><span class="line">  <span class="title function_">unsubscribe</span>(<span class="params">event, listenerToRemove</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">events</span>[event]) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">events</span>[event] = <span class="variable language_">this</span>.<span class="property">events</span>[event].<span class="title function_">filter</span>(<span class="function"><span class="params">listener</span> =&gt;</span> listener !== listenerToRemove);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用示例</span></span><br><span class="line"><span class="keyword">const</span> pubSub = <span class="keyword">new</span> <span class="title class_">PubSub</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 订阅事件</span></span><br><span class="line">pubSub.<span class="title function_">subscribe</span>(<span class="string">&#x27;message&#x27;</span>, <span class="function"><span class="params">data</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Received: <span class="subst">$&#123;data&#125;</span>`</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发布事件</span></span><br><span class="line">pubSub.<span class="title function_">publish</span>(<span class="string">&#x27;message&#x27;</span>, <span class="string">&#x27;Hello, Pub/Sub!&#x27;</span>);</span><br></pre></td></tr></table></figure><hr><h3 id="比较版本号"><a href="#比较版本号" class="headerlink" title="比较版本号"></a>比较版本号</h3><blockquote><p>题目: <a target="_blank" rel="noopener" href="https://leetcode.com/problems/compare-version-numbers/">Leetcode 165. Compare Version Numbers</a></p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: version1 = &quot;1.2&quot;, version2 = &quot;1.10&quot;</span><br><span class="line">Output: -1</span><br></pre></td></tr></table></figure><ul><li>解法: 解法是将两个版本号通过点号分割成多个子版本号，然后逐个比较它们的大小。如果版本号长度不同，较短的版本号用<code>0</code>补齐。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">compareVersion</span>(<span class="params">self, version1: <span class="built_in">str</span>, version2: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="comment"># 将版本号分割为子部分（用点号分割）</span></span><br><span class="line">    v1_parts = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, version1.split(<span class="string">&quot;.&quot;</span>)))</span><br><span class="line">    v2_parts = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, version2.split(<span class="string">&quot;.&quot;</span>)))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 取较长的版本部分长度</span></span><br><span class="line">    max_len = <span class="built_in">max</span>(<span class="built_in">len</span>(v1_parts), <span class="built_in">len</span>(v2_parts))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 用 0 补齐较短的版本号部分 (eg. &#x27;1.0&#x27; 比 &#x27;1.0.0.0&#x27;)</span></span><br><span class="line">    v1_parts += [<span class="number">0</span>] * (max_len - <span class="built_in">len</span>(v1_parts))</span><br><span class="line">    v2_parts += [<span class="number">0</span>] * (max_len - <span class="built_in">len</span>(v2_parts))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(max_len):</span><br><span class="line">        <span class="keyword">if</span> v1_parts[i] &gt; v2_parts[i]:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> v1_parts[i] &lt; v2_parts[i]:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><hr><h3 id="二叉树展开为链表"><a href="#二叉树展开为链表" class="headerlink" title="二叉树展开为链表"></a>二叉树展开为链表</h3><blockquote><p>题目: <a target="_blank" rel="noopener" href="https://leetcode.com/problems/flatten-binary-tree-to-linked-list/">Leetcode 114. Flatten Binary Tree to Linked List</a></p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: root = [1,2,5,3,4,null,6]</span><br><span class="line">Output: [1,null,2,null,3,null,4,null,5,null,6]</span><br></pre></td></tr></table></figure><ul><li>解法: 通过递归遍历每个节点，先将左右子树分别“扁平化”。然后将左子树移到右子树的位置，并将左子树置为空。接着找到原左子树的最右节点，并将之前保存的右子树连接到这个最右节点。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">flatten</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Do not return anything, modify root in-place instead.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Flatten the left and right subtrees</span></span><br><span class="line">    self.flatten(root.left)</span><br><span class="line">    self.flatten(root.right)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Save the right subtree</span></span><br><span class="line">    right_subtree = root.right</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Move the left subtree to the right</span></span><br><span class="line">    root.right = root.left</span><br><span class="line">    root.left = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Find the rightmost node of the flattened left subtree</span></span><br><span class="line">    curr = root</span><br><span class="line">    <span class="keyword">while</span> curr.right:</span><br><span class="line">        curr = curr.right</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Attach the saved right subtree to the rightmost node</span></span><br><span class="line">    curr.right = right_subtree</span><br></pre></td></tr></table></figure><hr><h3 id="轮转数组"><a href="#轮转数组" class="headerlink" title="轮转数组"></a>轮转数组</h3><blockquote><p>题目: <a target="_blank" rel="noopener" href="https://leetcode.com/problems/rotate-array/">Leetcode 189. Rotate Array</a></p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: nums = [1,2,3,4,5,6,7], k = 3</span><br><span class="line">Output: [5,6,7,1,2,3,4]</span><br></pre></td></tr></table></figure><ul><li>解法: 首先将整个数组翻转，然后分别翻转前<code>k</code>个元素和剩余的元素。通过三次翻转，数组会实现向右旋转<code>k</code>位的位置变化。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">rotate</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    n = <span class="built_in">len</span>(nums)</span><br><span class="line">    k = k % n  <span class="comment"># 处理k大于数组长度的情况</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 定义翻转数组的函数</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverse</span>(<span class="params">start, end</span>):</span><br><span class="line">        <span class="keyword">while</span> start &lt; end:</span><br><span class="line">            nums[start], nums[end] = nums[end], nums[start]</span><br><span class="line">            start += <span class="number">1</span></span><br><span class="line">            end -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 1. 翻转整个数组</span></span><br><span class="line">    reverse(<span class="number">0</span>, n - <span class="number">1</span>)</span><br><span class="line">    <span class="comment"># 2. 翻转前 k 个元素</span></span><br><span class="line">    reverse(<span class="number">0</span>, k - <span class="number">1</span>)</span><br><span class="line">    <span class="comment"># 3. 翻转剩下的元素</span></span><br><span class="line">    reverse(k, n - <span class="number">1</span>)</span><br></pre></td></tr></table></figure><hr><h3 id="自定义一个-set-类"><a href="#自定义一个-set-类" class="headerlink" title="自定义一个 set 类"></a>自定义一个 set 类</h3><blockquote><p>题目: <a target="_blank" rel="noopener" href="https://leetcode.com/problems/insert-delete-getrandom-o1/">Leetcode 380. Insert Delete GetRandom O(1)</a></p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input</span><br><span class="line">[&quot;RandomizedSet&quot;, &quot;insert&quot;, &quot;remove&quot;, &quot;insert&quot;, &quot;getRandom&quot;, &quot;remove&quot;, &quot;insert&quot;, &quot;getRandom&quot;]</span><br><span class="line">[[], [1], [2], [2], [], [1], [2], []]</span><br><span class="line">Output</span><br><span class="line">[null, true, false, true, 2, true, false, 2]</span><br></pre></td></tr></table></figure><ul><li>解法: 数组用于存储元素，方便随机获取；哈希表用于记录每个元素在数组中的索引，以便<code>O(1)</code>时间进行查找和删除。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RandomizedSet</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.<span class="built_in">dict</span> = &#123;&#125;</span><br><span class="line">        self.<span class="built_in">list</span> = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">insert</span>(<span class="params">self, val: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">if</span> val <span class="keyword">in</span> self.<span class="built_in">dict</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        self.<span class="built_in">dict</span>[val] = <span class="built_in">len</span>(self.<span class="built_in">list</span>)</span><br><span class="line">        self.<span class="built_in">list</span>.append(val)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">remove</span>(<span class="params">self, val: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">if</span> val <span class="keyword">not</span> <span class="keyword">in</span> self.<span class="built_in">dict</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="comment"># 找到要删除的元素位置</span></span><br><span class="line">        index = self.<span class="built_in">dict</span>[val]</span><br><span class="line">        <span class="comment"># 将要删除的元素与最后一个元素交换</span></span><br><span class="line">        last_element = self.<span class="built_in">list</span>[-<span class="number">1</span>]</span><br><span class="line">        self.<span class="built_in">list</span>[index] = last_element</span><br><span class="line">        self.<span class="built_in">dict</span>[last_element] = index</span><br><span class="line">        <span class="comment"># 移除最后一个元素</span></span><br><span class="line">        self.<span class="built_in">list</span>.pop()</span><br><span class="line">        <span class="keyword">del</span> self.<span class="built_in">dict</span>[val]</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getRandom</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">return</span> random.choice(self.<span class="built_in">list</span>)</span><br></pre></td></tr></table></figure><hr><h3 id="数组转树"><a href="#数组转树" class="headerlink" title="数组转树"></a>数组转树</h3><blockquote><p>题目: <a target="_blank" rel="noopener" href="https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/">Leetcode 108. Convert Sorted Array to Binary Search Tree</a><br>题目: <a target="_blank" rel="noopener" href="https://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/">Leetcode 109. Convert Sorted List to Binary Search Tree</a></p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: nums = [-10,-3,0,5,9]</span><br><span class="line">Output: [0,-3,9,-10,null,5]</span><br></pre></td></tr></table></figure><ul><li>解法: 使用递归的方式，每次选取数组的中间元素作为根节点，左侧子数组构建左子树，右侧子数组构建右子树，最终递归地完成整棵树的构建。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">sortedArrayToBST</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">    <span class="comment"># 递归终止条件：如果数组为空，返回 None</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 选择中间元素作为根节点</span></span><br><span class="line">    mid = <span class="built_in">len</span>(nums) // <span class="number">2</span></span><br><span class="line">    root = TreeNode(nums[mid])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 递归构建左子树和右子树</span></span><br><span class="line">    root.left = self.sortedArrayToBST(nums[:mid])</span><br><span class="line">    root.right = self.sortedArrayToBST(nums[mid + <span class="number">1</span> :])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><hr><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: head = [-10,-3,0,5,9]</span><br><span class="line">Output: [0,-3,9,-10,null,5]</span><br></pre></td></tr></table></figure><ul><li>解法: 通过分治法来解决，结合快慢指针找到链表的中间节点来作为当前树的根节点，递归处理左右子链表来构建左右子树。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">sortedListToBST</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">    <span class="comment"># 辅助函数：找到链表的中间节点</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">find_middle</span>(<span class="params">start, end</span>):</span><br><span class="line">        slow = fast = start</span><br><span class="line">        <span class="keyword">while</span> fast != end <span class="keyword">and</span> fast.<span class="built_in">next</span> != end:</span><br><span class="line">            slow = slow.<span class="built_in">next</span></span><br><span class="line">            fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> slow</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 主函数：递归构建二叉搜索树</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">build_bst</span>(<span class="params">start, end</span>):</span><br><span class="line">        <span class="keyword">if</span> start == end:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        mid = find_middle(start, end)</span><br><span class="line">        root = TreeNode(mid.val)</span><br><span class="line"></span><br><span class="line">        root.left = build_bst(start, mid)</span><br><span class="line">        root.right = build_bst(mid.<span class="built_in">next</span>, end)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> build_bst(head, <span class="literal">None</span>)</span><br></pre></td></tr></table></figure><hr><h3 id="k-个有序数组合并"><a href="#k-个有序数组合并" class="headerlink" title="k 个有序数组合并"></a>k 个有序数组合并</h3><blockquote><p>题目: <a target="_blank" rel="noopener" href="https://leetcode.com/problems/merge-sorted-array/">Leetcode 88. Merge Sorted Array</a><br>题目: <a target="_blank" rel="noopener" href="https://leetcode.com/problems/merge-k-sorted-lists/">Leetcode 23. Merge k Sorted Lists</a></p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3</span><br><span class="line">Output: [1,2,2,3,5,6]</span><br></pre></td></tr></table></figure><ul><li>解法: 使用双指针从后往前遍历。由于<code>nums1</code>有足够的空间存放<code>nums2</code>的元素，我们从<code>nums1</code>和 <code>nums2</code>的末尾开始比较，每次将较大的元素放入<code>nums1</code>的最后位置，逐步向前移动指针。如果<code>nums2</code>还有剩余元素，直接填入<code>nums1</code>中。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">merge</span>(<span class="params">self, nums1: <span class="type">List</span>[<span class="built_in">int</span>], m: <span class="built_in">int</span>, nums2: <span class="type">List</span>[<span class="built_in">int</span>], n: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Do not return anything, modify nums1 in-place instead.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 设置三个指针：i 指向 nums1 的有效元素部分的末尾，j 指向 nums2 的末尾，k 指向 nums1 的末尾</span></span><br><span class="line">    i, j, k = m - <span class="number">1</span>, n - <span class="number">1</span>, m + n - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 从后往前合并</span></span><br><span class="line">    <span class="keyword">while</span> i &gt;= <span class="number">0</span> <span class="keyword">and</span> j &gt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">if</span> nums1[i] &gt; nums2[j]:</span><br><span class="line">            nums1[k] = nums1[i]</span><br><span class="line">            i -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            nums1[k] = nums2[j]</span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">        k -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 如果 nums2 还有剩余的元素，直接填入 nums1</span></span><br><span class="line">    <span class="keyword">while</span> j &gt;= <span class="number">0</span>:</span><br><span class="line">        nums1[k] = nums2[j]</span><br><span class="line">        j -= <span class="number">1</span></span><br><span class="line">        k -= <span class="number">1</span></span><br></pre></td></tr></table></figure><hr><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: lists = [[1,4,5],[1,3,4],[2,6]]</span><br><span class="line">Output: [1,1,2,3,4,4,5,6]</span><br></pre></td></tr></table></figure><ul><li>解法: 使用最小堆（优先队列）来合并<code>K</code>个有序链表。将每个链表的头节点放入最小堆中，然后每次从堆中取出最小值节点，将其加入结果链表，并将该节点的下一个节点继续放入堆中，重复这一过程直到所有链表节点都被处理完毕。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">mergeKLists</span>(<span class="params">self, lists: <span class="type">List</span>[<span class="type">Optional</span>[ListNode]]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">    min_heap = []</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 将每个链表的头节点放入堆中</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(lists)):</span><br><span class="line">        <span class="keyword">if</span> lists[i]:</span><br><span class="line">            heapq.heappush(min_heap, (lists[i].val, i, lists[i]))</span><br><span class="line"></span><br><span class="line">    dummy = ListNode(<span class="number">0</span>)</span><br><span class="line">    curr = dummy</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 不断从堆中取出最小节点，并将其后续节点继续放入堆中</span></span><br><span class="line">    <span class="keyword">while</span> min_heap:</span><br><span class="line">        val, idx, node = heapq.heappop(min_heap)</span><br><span class="line">        curr.<span class="built_in">next</span> = node</span><br><span class="line">        curr = curr.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">if</span> node.<span class="built_in">next</span>:</span><br><span class="line">            heapq.heappush(min_heap, (node.<span class="built_in">next</span>.val, idx, node.<span class="built_in">next</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><hr><h3 id="跳跃游戏"><a href="#跳跃游戏" class="headerlink" title="跳跃游戏"></a>跳跃游戏</h3><blockquote><p>题目: <a target="_blank" rel="noopener" href="https://leetcode.com/problems/jump-game/">Leetcode 55. Jump Game</a><br>题目: <a target="_blank" rel="noopener" href="https://leetcode.com/problems/jump-game-ii/">Leetcode 45. Jump Game II</a></p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: nums = [2,3,1,1,4]</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><ul><li>解法: 通过一个变量<code>maxReach</code>来记录当前能够到达的最远位置，遍历数组时，如果当前位置超过了最远可达位置，则说明无法跳到该位置，返回<code>False</code>。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">canJump</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">    <span class="comment"># 初始化能够到达的最远位置</span></span><br><span class="line">    maxReach = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">        <span class="comment"># 如果当前索引 i 超过了能到达的最远位置，返回 False，表示无法跳到该位置</span></span><br><span class="line">        <span class="keyword">if</span> i &gt; maxReach:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="comment"># 更新能够到达的最远位置</span></span><br><span class="line">        maxReach = <span class="built_in">max</span>(maxReach, i + nums[i])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><hr><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: nums = [2,3,1,1,4]</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure><ul><li>解法: 使用贪心算法，维护当前跳跃的范围和能跳到的最远位置，在每次达到跳跃边界时更新跳跃次数和最远跳跃距离。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">jump</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="comment"># 初始化跳跃次数 jumps，当前跳跃的边界 current_end，和当前能跳到的最远位置 farthest</span></span><br><span class="line">    jumps = <span class="number">0</span></span><br><span class="line">    current_end = <span class="number">0</span></span><br><span class="line">    farthest = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 最后一个元素不需要遍历</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums) - <span class="number">1</span>):</span><br><span class="line">        farthest = <span class="built_in">max</span>(farthest, i + nums[i])</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 当到达当前跳跃的边界时</span></span><br><span class="line">        <span class="keyword">if</span> i == current_end:</span><br><span class="line">            jumps += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 更新跳跃边界为当前能跳到的最远位置</span></span><br><span class="line">            current_end = farthest</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> jumps</span><br></pre></td></tr></table></figure><hr><h3 id="股票问题"><a href="#股票问题" class="headerlink" title="股票问题"></a>股票问题</h3><blockquote><p>题目: <a target="_blank" rel="noopener" href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock/">Leetcode 121. Best Time to Buy and Sell Stock</a><br>题目: <a target="_blank" rel="noopener" href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/">Leetcode 122. Best Time to Buy and Sell Stock II</a></p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: prices = [7,1,5,3,6,4]</span><br><span class="line">Output: 5</span><br></pre></td></tr></table></figure><ul><li>解法: 在遍历每个价格时，如果当前价格小于之前记录的最小买入价格，则更新最小买入价格。如果当前价格减去最小买入价格的差值大于之前记录的最大利润，则更新最大利润。最终返回最大利润。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">maxProfit</span>(<span class="params">self, prices: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    min_price = <span class="built_in">float</span>(<span class="string">&quot;inf&quot;</span>)</span><br><span class="line">    max_profit = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> price <span class="keyword">in</span> prices:</span><br><span class="line">        <span class="comment"># 更新最小买入价格</span></span><br><span class="line">        <span class="keyword">if</span> price &lt; min_price:</span><br><span class="line">            min_price = price</span><br><span class="line">        <span class="comment"># 计算当前利润，并更新最大利润</span></span><br><span class="line">        <span class="keyword">elif</span> price - min_price &gt; max_profit:</span><br><span class="line">            max_profit = price - min_price</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> max_profit</span><br></pre></td></tr></table></figure><hr><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: prices = [7,1,5,3,6,4]</span><br><span class="line">Output: 7</span><br></pre></td></tr></table></figure><ul><li>解法: 因为可以进行多次买卖操作，因此只要当天的价格比前一天高，我们就可以通过当天卖出股票获得利润。通过累加每次上涨的差值，最终可以得到最大利润。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">maxProfit</span>(<span class="params">self, prices: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    max_profit = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 遍历价格列表，寻找每个连续上涨的机会</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(prices)):</span><br><span class="line">        <span class="keyword">if</span> prices[i] &gt; prices[i - <span class="number">1</span>]:</span><br><span class="line">            <span class="comment"># 如果今天的价格比前一天高，就把差值计入利润</span></span><br><span class="line">            max_profit += prices[i] - prices[i - <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> max_profit</span><br></pre></td></tr></table></figure><hr><h3 id="最大岛屿问题"><a href="#最大岛屿问题" class="headerlink" title="最大岛屿问题"></a>最大岛屿问题</h3><blockquote><p>题目: <a target="_blank" rel="noopener" href="https://leetcode.com/problems/max-area-of-island/">Leetcode 695. Max Area of Island</a></p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: grid = [[0,0,1,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,1,1,0,1,0,0,0,0,0,0,0,0],[0,1,0,0,1,1,0,0,1,0,1,0,0],[0,1,0,0,1,1,0,0,1,1,1,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,0,0,0,0,0,0,1,1,0,0,0,0]]</span><br><span class="line">Output: 6</span><br></pre></td></tr></table></figure><ul><li>解法: 使用 深度优先搜索（<code>DFS</code>）来遍历整个网格。对于每个值为<code>1</code>的格子，启动 <code>DFS</code>，遍历与其相连的所有陆地，计算岛屿的面积，同时将遍历过的格子标记为 <code>0</code>（已访问）。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">maxAreaOfIsland</span>(<span class="params">self, grid: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="comment"># 定义 DFS 函数，遍历岛屿</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">i, j</span>):</span><br><span class="line">        <span class="comment"># 如果超出边界或当前位置不是岛屿，返回 0</span></span><br><span class="line">        <span class="keyword">if</span> i &lt; <span class="number">0</span> <span class="keyword">or</span> i &gt;= <span class="built_in">len</span>(grid) <span class="keyword">or</span> j &lt; <span class="number">0</span> <span class="keyword">or</span> j &gt;= <span class="built_in">len</span>(grid[<span class="number">0</span>]) <span class="keyword">or</span> grid[i][j] == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        grid[i][j] = <span class="number">0</span>  <span class="comment"># 标记为访问过的岛屿</span></span><br><span class="line">        <span class="comment"># 递归地访问上下左右</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + dfs(i + <span class="number">1</span>, j) + dfs(i - <span class="number">1</span>, j) + dfs(i, j + <span class="number">1</span>) + dfs(i, j - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    max_area = <span class="number">0</span>  <span class="comment"># 记录最大岛屿面积</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(grid)):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(grid[<span class="number">0</span>])):</span><br><span class="line">            <span class="keyword">if</span> grid[i][j] == <span class="number">1</span>:  <span class="comment"># 如果找到岛屿，启动 DFS</span></span><br><span class="line">                max_area = <span class="built_in">max</span>(max_area, dfs(i, j))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> max_area</span><br></pre></td></tr></table></figure><hr></article><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/posts/c7d67744.html" title="笔记"><img class="cover" src="https://cdn.jsdelivr.net/gh/Hongda-OSU/PicGo/image/gknx188yxuapxelxaeyjso308qyhne0.jpg" onerror='onerror=null,src="https://cdn.jsdelivr.net/gh/Hongda-OSU/PicGo/image/404.GIF"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">笔记</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://cdn.jsdelivr.net/gh/Hongda-OSU/PicGo/image/德狗子.GIF" onerror='this.onerror=null,this.src="https://cdn.jsdelivr.net/gh/Hongda-OSU/PicGo/image/404.GIF"' alt="avatar"></div><div class="author-info__name">鴻達</div><div class="author-info__description">记录 生活</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">19</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">12</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Hongda-OSU" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="https://www.linkedin.com/in/hongda-lin" target="_blank" title="Linkedin"><i class="fab fa-linkedin"></i></a><a class="social-icon" href="https://hongdalin.me" target="_blank" title="Portfolio"><i class="iconfont icon-guanfangwangzhan"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">文章右下角小工具进入阅读模式</div></div><div class="xpand" style="height:200px"><canvas class="illo" width="800" height="800" style="max-width:200px;max-height:200px;touch-action:none;width:640px;height:640px"></canvas></div><script src="https://npm.elemecdn.com/ethan4116-blog/lib/js/other/two-people/twopeople1.js"></script><script src="https://npm.elemecdn.com/ethan4116-blog/lib/js/other/two-people/zdog.dist.js"></script><script id="rendered-js" src="https://npm.elemecdn.com/ethan4116-blog/lib/js/other/two-people/twopeople.js"></script><style>.card-widget.card-announcement{margin:0;align-items:center;justify-content:center;text-align:center}canvas{display:block;margin:0 auto;cursor:move}</style><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#Top-K-%E5%85%83%E7%B4%A0"><span class="toc-text">Top K 元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Top-K-%E9%A2%91%E7%8E%87"><span class="toc-text">Top K 频率</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LRU-Cache"><span class="toc-text">LRU Cache</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8"><span class="toc-text">反转链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%88%E6%88%90%E9%93%BE%E8%A1%A8"><span class="toc-text">合成链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%B7%E5%B2%9B%E9%97%AE%E9%A2%98"><span class="toc-text">海岛问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%A8%E6%B0%B4%E9%97%AE%E9%A2%98"><span class="toc-text">雨水问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#K-%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8"><span class="toc-text">K 个一组翻转链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9"><span class="toc-text">两两交换链表中的节点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A7%A3%E7%A0%81"><span class="toc-text">字符串解码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0-1-%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98"><span class="toc-text">0-1 背包问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="toc-text">快速排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F"><span class="toc-text">冒泡排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="toc-text">插入排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="toc-text">归并排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A0%86%E6%8E%92%E5%BA%8F"><span class="toc-text">堆排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D"><span class="toc-text">数组去重</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E9%95%BF%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%90%E4%B8%B2"><span class="toc-text">最长无重复子串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-text">二叉树的层序遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E6%8A%98%E9%93%BE%E8%A1%A8"><span class="toc-text">对折链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0"><span class="toc-text">删除有序链表中的重复元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97"><span class="toc-text">斐波那契数列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8%E6%AF%8F%E4%B8%AA%E6%A0%91%E8%A1%8C%E4%B8%AD%E6%89%BE%E6%9C%80%E5%A4%A7%E5%80%BC"><span class="toc-text">在每个树行中找最大值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2-DFS-amp-%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2-BFS"><span class="toc-text">深度优先搜索 (DFS) &amp; 广度优先搜索 (BFS)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-text">验证二叉搜索树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%AC%E5%8F%B7%E5%8C%B9%E9%85%8D"><span class="toc-text">括号匹配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E6%9C%80%E5%A4%A7%E5%B7%AE%E5%80%BC"><span class="toc-text">二叉树最大差值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC"><span class="toc-text">整数反转</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-text">不同的二叉搜索树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5"><span class="toc-text">螺旋矩阵</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%8B%AC"><span class="toc-text">数独</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A8%E6%8E%92%E5%88%97"><span class="toc-text">全排列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">平衡二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BST-%E7%AC%AC-k-%E5%A4%A7%E7%9A%84%E8%8A%82%E7%82%B9"><span class="toc-text">BST 第 k 大的节点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9A%84%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="toc-text">最接近的三数之和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E5%BA%8F%EF%BC%8C%E4%B8%AD%E5%BA%8F%EF%BC%8C%E5%90%8E%E5%BA%8F"><span class="toc-text">前序，中序，后序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#36-%E6%89%8B%E5%86%99-Promise-all"><span class="toc-text">36. 手写 Promise.all</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#37-%E6%89%8B%E5%86%99-new"><span class="toc-text">37. 手写 new</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#38-%E6%89%8B%E5%86%99-EventEmitter"><span class="toc-text">38. 手写 EventEmitter</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#39-%E6%89%8B%E5%86%99%E9%98%B2%E6%8A%96"><span class="toc-text">39. 手写防抖</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#40-%E6%89%8B%E5%86%99%E8%8A%82%E6%B5%81"><span class="toc-text">40. 手写节流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#41-%E6%89%8B%E5%86%99%E5%BC%B1%E6%8B%B7%E8%B4%9D"><span class="toc-text">41. 手写弱拷贝</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#42-%E6%89%8B%E5%86%99%E6%B7%B1%E6%8B%B7%E8%B4%9D"><span class="toc-text">42. 手写深拷贝</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#43-%E6%89%8B%E5%86%99-reduce"><span class="toc-text">43. 手写 reduce</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#44-%E6%89%8B%E5%86%99%E6%95%B0%E7%BB%84%E6%89%81%E5%B9%B3%E5%8C%96"><span class="toc-text">44. 手写数组扁平化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#45-%E6%89%8B%E5%86%99%E6%95%B0%E7%BB%84%E8%BD%AC%E4%B8%BA%E6%A0%91%E5%BD%A2%E7%BB%93%E6%9E%84"><span class="toc-text">45. 手写数组转为树形结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#46-%E6%89%8B%E5%86%99-hook"><span class="toc-text">46. 手写 hook</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#47-%E6%89%8B%E5%86%99-Promise-race"><span class="toc-text">47. 手写 Promise.race</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#48-%E6%89%8B%E5%86%99-Pub-x2F-Sub"><span class="toc-text">48. 手写 Pub&#x2F;Sub</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AF%94%E8%BE%83%E7%89%88%E6%9C%AC%E5%8F%B7"><span class="toc-text">比较版本号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%95%E5%BC%80%E4%B8%BA%E9%93%BE%E8%A1%A8"><span class="toc-text">二叉树展开为链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AE%E8%BD%AC%E6%95%B0%E7%BB%84"><span class="toc-text">轮转数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA-set-%E7%B1%BB"><span class="toc-text">自定义一个 set 类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E8%BD%AC%E6%A0%91"><span class="toc-text">数组转树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#k-%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E5%90%88%E5%B9%B6"><span class="toc-text">k 个有序数组合并</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F"><span class="toc-text">跳跃游戏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%82%A1%E7%A5%A8%E9%97%AE%E9%A2%98"><span class="toc-text">股票问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E5%A4%A7%E5%B2%9B%E5%B1%BF%E9%97%AE%E9%A2%98"><span class="toc-text">最大岛屿问题</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/29dadae9.html" title="PostgreSQL 学习笔记"><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/imgied0v0dgsgyqeoh7804b0ca54buj0qd.jpg" onerror='this.onerror=null,this.src="https://cdn.jsdelivr.net/gh/Hongda-OSU/PicGo/image/404.GIF"' alt="PostgreSQL 学习笔记"></a><div class="content"><a class="title" href="/posts/29dadae9.html" title="PostgreSQL 学习笔记">PostgreSQL 学习笔记</a><time datetime="2024-08-02T15:15:06.000Z" title="发表于 2024-08-02 10:15:06">2024-08-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/69cd31bf.html" title="GraphQL 学习笔记"><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/imge39twvhffwemdsipqncbwko5vayrxgd.jpg" onerror='this.onerror=null,this.src="https://cdn.jsdelivr.net/gh/Hongda-OSU/PicGo/image/404.GIF"' alt="GraphQL 学习笔记"></a><div class="content"><a class="title" href="/posts/69cd31bf.html" title="GraphQL 学习笔记">GraphQL 学习笔记</a><time datetime="2024-08-02T15:15:05.000Z" title="发表于 2024-08-02 10:15:05">2024-08-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/88b435e5.html" title="考证：GCP Cloud Digital Leader"><img src="https://cdn.jsdelivr.net/gh/Hongda-OSU/PicGo/image/4lm5yuyw4y3lbznbatf6j8o8kcvefg8.jpg" onerror='this.onerror=null,this.src="https://cdn.jsdelivr.net/gh/Hongda-OSU/PicGo/image/404.GIF"' alt="考证：GCP Cloud Digital Leader"></a><div class="content"><a class="title" href="/posts/88b435e5.html" title="考证：GCP Cloud Digital Leader">考证：GCP Cloud Digital Leader</a><time datetime="2024-07-19T17:03:05.000Z" title="发表于 2024-07-19 12:03:05">2024-07-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/4c411076.html" title="考证：Exam AZ-900"><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img1u6qw3ad64bz8nsedrd2wddgrax5wew.jpg" onerror='this.onerror=null,this.src="https://cdn.jsdelivr.net/gh/Hongda-OSU/PicGo/image/404.GIF"' alt="考证：Exam AZ-900"></a><div class="content"><a class="title" href="/posts/4c411076.html" title="考证：Exam AZ-900">考证：Exam AZ-900</a><time datetime="2024-07-07T17:03:05.000Z" title="发表于 2024-07-07 12:03:05">2024-07-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/b7fb4495.html" title="游戏音乐 👾"><img src="https://cdn.jsdelivr.net/gh/Hongda-OSU/PicGo/image/dfcjswnw17cl1hrwz9tz8n1hgf1m8dv.jpg" onerror='this.onerror=null,this.src="https://cdn.jsdelivr.net/gh/Hongda-OSU/PicGo/image/404.GIF"' alt="游戏音乐 👾"></a><div class="content"><a class="title" href="/posts/b7fb4495.html" title="游戏音乐 👾">游戏音乐 👾</a><time datetime="2024-06-23T15:15:05.000Z" title="发表于 2024-06-23 10:15:05">2024-06-23</time></div></div></div></div></div></div></main><footer id="footer" style="background:rgba(0,0,0,.25)"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2024 &nbsp;<i id="heartbeat" class="fa fas fa-heartbeat"></i> &nbsp;鴻達</div><div class="footer_custom_text"><p class="badge"><a style="margin-inline:5px" target="_blank" href="https://hexo.io/"><img src="https://img.shields.io/badge/Frame-Hexo-informational?style=flat&logo=hexo"></a><a style="margin-inline:5px" target="_blank" href="https://domains.google/"><img src="https://img.shields.io/badge/Hosted-Google-ff69b4?style=flat&logo=googledomains"></a><a style="margin-inline:5px" target="_blank" href="https://gulpjs.com/"><img src="https://img.shields.io/badge/Compress-gulp-critical?style=flat&logo=gulp"></a><a style="margin-inline:5px" target="_blank" href="https://www.jsdelivr.com/"><img src="https://img.shields.io/badge/CDN-jsDelivr-orange?style=flat&logo=jsDelivr"></a><a style="margin-inline:5px" target="_blank" href="https://github.com/"><img src="https://img.shields.io/badge/Source-Github-black?style=flat&logo=GitHub"></a><a style="margin-inline:5px" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&logo=Claris"></a></p></div></div><link rel="stylesheet" href="https://fastly.jsdelivr.net/gh/HCLonely/images@master/others/heartbeat.min.css"></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i> <span>数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script>function panguFn(){"object"==typeof pangu?pangu.autoSpacingPage():getScript("https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js").then((()=>{pangu.autoSpacingPage()}))}function panguInit(){GLOBAL_CONFIG_SITE.isPost&&panguFn()}document.addEventListener("DOMContentLoaded",panguInit)</script><script src="/js/search/local-search.js"></script><div class="js-pjax"></div><script defer src="/js/util.js"></script><script defer src="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js"></script><script disable-devtool-auto src="https://cdn.jsdelivr.net/npm/disable-devtool"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors=["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"];var pjax=new Pjax({elements:'a:not([target="_blank"])',selectors:pjaxSelectors,cacheBust:!1,analytics:!1,scrollRestoration:!1});document.addEventListener("pjax:send",(function(){if(window.tocScrollFn&&window.removeEventListener("scroll",window.tocScrollFn),window.scrollCollect&&window.removeEventListener("scroll",scrollCollect),document.getElementById("rightside").style.cssText="opacity: ''; transform: ''",window.aplayers)for(let e=0;e<window.aplayers.length;e++)window.aplayers[e].options.fixed||window.aplayers[e].destroy();"object"==typeof typed&&typed.destroy();const e=document.body.classList;e.contains("read-mode")&&e.remove("read-mode"),"object"==typeof disqusjs&&disqusjs.destroy()})),document.addEventListener("pjax:complete",(function(){window.refreshFn(),document.querySelectorAll("script[data-pjax]").forEach((e=>{const t=document.createElement("script"),o=e.text||e.textContent||e.innerHTML||"";Array.from(e.attributes).forEach((e=>t.setAttribute(e.name,e.value))),t.appendChild(document.createTextNode(o)),e.parentNode.replaceChild(t,e)})),GLOBAL_CONFIG.islazyload&&window.lazyLoadInstance.update(),"function"==typeof chatBtnFn&&chatBtnFn(),"function"==typeof panguInit&&panguInit(),"function"==typeof gtag&&gtag("config","",{page_path:window.location.pathname}),"object"==typeof _hmt&&_hmt.push(["_trackPageview",window.location.pathname]),"function"==typeof loadMeting&&document.getElementsByClassName("aplayer").length&&loadMeting(),"object"==typeof Prism&&Prism.highlightAll()})),document.addEventListener("pjax:error",(e=>{404===e.request.status&&pjax.loadUrl("/404.html")}))</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>