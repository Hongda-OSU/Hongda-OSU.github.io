<!DOCTYPE html><html lang="zh-CN" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><title>算法笔记 | 鴻鵠誌達</title><meta name="author" content="鴻達"><meta name="copyright" content="鴻達"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#1a1a1a"><meta name="description" content="😃"><meta property="og:type" content="article"><meta property="og:title" content="算法笔记"><meta property="og:url" content="https://hongdalin.blog/posts/3458e8f8.html"><meta property="og:site_name" content="鴻鵠誌達"><meta property="og:description" content="😃"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Hongda-OSU/PicGo/image/od2iyorqbvbnha2g2vybpn8v4tiq4qw.jpg"><meta property="article:published_time" content="2023-01-26T16:15:05.000Z"><meta property="article:modified_time" content="2025-01-04T02:14:09.647Z"><meta property="article:author" content="鴻達"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/Hongda-OSU/PicGo/image/od2iyorqbvbnha2g2vybpn8v4tiq4qw.jpg"><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/Hongda-OSU/PicGo/image/德克萨斯.GIF"><link rel="canonical" href="https://hongdalin.blog/posts/3458e8f8.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:{path:"/search.xml",preload:!0,languages:{hits_empty:"找不到您查询的内容：${query}"}},translate:void 0,noticeOutdate:void 0,highlight:{plugin:"highlighjs",highlightCopy:!0,highlightLang:!0,highlightHeightLimit:!1},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"},relativeDate:{homepage:!1,post:!1},runtime:"天",date_suffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:void 0,lightbox:"fancybox",Snackbar:void 0,source:{justifiedGallery:{js:"https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js",css:"https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css"}},isPhotoFigcaption:!0,islazyload:!1,isAnchor:!1,percent:{toc:!0,rightside:!1}}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"算法笔记",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2025-01-03 20:14:09"}</script><noscript><style>#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(e=>{e.saveToLocal={set:function(e,t,n){if(0===n)return;const o=864e5*n,a={value:t,expiry:(new Date).getTime()+o};localStorage.setItem(e,JSON.stringify(a))},get:function(e){const t=localStorage.getItem(e);if(!t)return;const n=JSON.parse(t);if(!((new Date).getTime()>n.expiry))return n.value;localStorage.removeItem(e)}},e.getScript=e=>new Promise(((t,n)=>{const o=document.createElement("script");o.src=e,o.async=!0,o.onerror=n,o.onload=o.onreadystatechange=function(){const e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(o.onload=o.onreadystatechange=null,t())},document.head.appendChild(o)})),e.getCSS=e=>new Promise(((t,n)=>{const o=document.createElement("link");o.rel="stylesheet",o.href=e,o.onload=()=>t(),o.onerror=()=>n(),document.head.appendChild(o)}));/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")})(window)</script><link rel="stylesheet" href="/css/color.css" media="defer" onload='this.media="all"'><link rel="stylesheet" href="/css/font.css" media="defer" onload='this.media="all"'><link rel="stylesheet" href="/css/icon.css" media="defer" onload='this.media="all"'><link rel="stylesheet" href="/css/layout.css" media="defer" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.css" media="defer" onload='this.media="all"'><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://cdn.jsdelivr.net/gh/Hongda-OSU/PicGo/image/德狗子.GIF" onerror='onerror=null,src="https://cdn.jsdelivr.net/gh/Hongda-OSU/PicGo/image/404.GIF"' alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">23</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">13</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i> <span>时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i> <span>标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>分类</span></a></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i> <span>链接</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i> <span>友情链接</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i> <span>关于</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url('https://cdn.jsdelivr.net/gh/Hongda-OSU/PicGo/image/od2iyorqbvbnha2g2vybpn8v4tiq4qw.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="鴻鵠誌達"><span class="site-name">鴻鵠誌達</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i> <span>搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i> <span>时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i> <span>标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>分类</span></a></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i> <span>链接</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i> <span>友情链接</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i> <span>关于</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">算法笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-01-26T16:15:05.000Z" title="发表于 2023-01-26 10:15:05">2023-01-26</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-01-04T02:14:09.647Z" title="更新于 2025-01-03 20:14:09">2025-01-03</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">27.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>121分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" data-flag-title="算法笔记"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h3 id="PriorityQueue-优先队列"><a href="#PriorityQueue-优先队列" class="headerlink" title="PriorityQueue 优先队列"></a><code>PriorityQueue</code> 优先队列</h3><h4 id="第k大的元素"><a href="#第k大的元素" class="headerlink" title="第k大的元素"></a>第<code>k</code>大的元素</h4><blockquote><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/kth-largest-element-in-an-array/">Leetcode 215. Kth Largest Element in an Array</a></p></blockquote><ul><li>题目: 给定一个数组<code>nums</code>和一个整数<code>k</code>，输出数组中第<code>k</code>大的元素</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: nums = [3, 2, 1, 5, 6, 4], k = 2</span><br><span class="line">Output: 5</span><br></pre></td></tr></table></figure><ul><li>解法<code>1</code>: 最小堆 <a target="_blank" rel="noopener" href="https://www.geeksforgeeks.org/heap-queue-or-heapq-in-python/">什么是 heap</a></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 初始化一个大小为 k 的最小堆，将前 k 个元素加入堆中</span><br><span class="line">2. 遍历剩余的元素，如果当前元素大于堆顶元素，则替换堆顶</span><br><span class="line">3. 遍历结束后，堆顶即为第 k 大的元素</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findKthLargest</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> k == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">        heap = nums[:k]</span><br><span class="line">        heapq.heapify(heap)  <span class="comment"># 建立最小堆</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums[k:]:</span><br><span class="line">            <span class="keyword">if</span> num &gt; heap[<span class="number">0</span>]:  <span class="comment"># 只在当前元素大于堆顶时替换</span></span><br><span class="line">                heapq.heapreplace(heap, num)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> heap[<span class="number">0</span>] <span class="comment"># 如果是 heap, 那就是返回数组前 k 大的元素</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">findKthLargest</span>(<span class="params">nums, k</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> minPQ = <span class="keyword">new</span> <span class="title class_">MinPriorityQueue</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.<span class="property">length</span>; i++) &#123;</span><br><span class="line">            minPQ.<span class="title function_">enqueue</span>(nums[i]);</span><br><span class="line">            <span class="keyword">if</span> (minPQ.<span class="title function_">size</span>() &gt; k)</span><br><span class="line">                minPQ.<span class="title function_">dequeue</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> minPQ.<span class="title function_">front</span>().<span class="property">element</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><ul><li>解法<code>2</code>: 快速选择 <code>Quick Select</code></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 通过「分区」方法将数组分为两部分，左边比 pivot 大，右边比 pivot 小</span><br><span class="line">2. 如果 pivot 的位置刚好是 k，则 pivot 即为第 k 大的元素</span><br><span class="line">3. 如果 pivot 的位置大于 k，递归左边部分</span><br><span class="line">4. 如果 pivot 的位置小于 k，递归右边部分</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">partition</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], low: <span class="built_in">int</span>, high: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        pivot = nums[high]</span><br><span class="line">        i = low - <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(low, high):</span><br><span class="line">            <span class="keyword">if</span> nums[j] &gt; pivot:  <span class="comment"># 按降序排列</span></span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">                nums[i], nums[j] = nums[j], nums[i]</span><br><span class="line">        nums[i + <span class="number">1</span>], nums[high] = nums[high], nums[i + <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> i + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">quickSelect</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], low: <span class="built_in">int</span>, high: <span class="built_in">int</span>, k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> low &lt;= high:</span><br><span class="line">            pivot_index = self.partition(nums, low, high)</span><br><span class="line">            <span class="keyword">if</span> pivot_index == k:</span><br><span class="line">                <span class="keyword">return</span> nums[k]</span><br><span class="line">            <span class="keyword">elif</span> pivot_index &gt; k:</span><br><span class="line">                <span class="keyword">return</span> self.quickSelect(nums, low, pivot_index - <span class="number">1</span>, k)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> self.quickSelect(nums, pivot_index + <span class="number">1</span>, high, k)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findKthLargest</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">return</span> self.quickSelect(nums, <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span>, k - <span class="number">1</span>)</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">partition</span>(<span class="params">nums, left, right</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> pivot = nums[right]; <span class="comment">// 选择最右边的元素作为 pivot</span></span><br><span class="line">        <span class="keyword">let</span> i = left - <span class="number">1</span>; <span class="comment">// 指针 i 表示小于 pivot 的区域的最后位置</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = left; j &lt; right; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[j] &gt; pivot) &#123; <span class="comment">// 降序排列：将较大的元素放在左边</span></span><br><span class="line">                i++;</span><br><span class="line">                [nums[i], nums[j]] = [nums[j], nums[i]]; <span class="comment">// 交换元素</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将 pivot 放到正确位置</span></span><br><span class="line">        [nums[i + <span class="number">1</span>], nums[right]] = [nums[right], nums[i + <span class="number">1</span>]];</span><br><span class="line">        <span class="keyword">return</span> i + <span class="number">1</span>; <span class="comment">// 返回 pivot 的索引</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">quickSelect</span>(<span class="params">nums, left, right, k</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">const</span> pivotIndex = <span class="variable language_">this</span>.<span class="title function_">partition</span>(nums, left, right);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (pivotIndex === k)</span><br><span class="line">                <span class="keyword">return</span> nums[k];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (pivotIndex &gt; k)</span><br><span class="line">                <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">quickSelect</span>(nums, left, pivotIndex - <span class="number">1</span>, k);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">quickSelect</span>(nums, pivotIndex + <span class="number">1</span>, right, k);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">findKthLargest</span>(<span class="params">nums, k</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">quickSelect</span>(nums, <span class="number">0</span>, nums.<span class="property">length</span> - <span class="number">1</span>, k - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h4 id="前k个元素的频率"><a href="#前k个元素的频率" class="headerlink" title="前k个元素的频率"></a>前<code>k</code>个元素的频率</h4><blockquote><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/top-k-frequent-elements/">Leetcode 347. Top K Frequent Elements</a></p></blockquote><ul><li>题目: 给定一个数组<code>nums</code>和一个整数<code>k</code>，返回数组中出现频率最高的前<code>k</code>个元素</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: nums = [1, 1, 1, 2, 2, 3], k = 2</span><br><span class="line">Output: [1, 2]</span><br></pre></td></tr></table></figure><ul><li>解法<code>1</code>: <code>heapq.nlargest</code> (<code>Python</code>)</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 使用 `Counter` 统计元素出现频率</span><br><span class="line">2. 调用 `heapq.nlargest`，在 O(n + k log n) 时间内找到前 k 大的频率</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">topKFrequent</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums) == k:</span><br><span class="line">            <span class="keyword">return</span> nums</span><br><span class="line"></span><br><span class="line">        count = Counter(nums)</span><br><span class="line">        <span class="keyword">return</span> heapq.nlargest(k, count.keys(), key=count.get)</span><br></pre></td></tr></table></figure><ul><li>解法<code>2</code>: 最小堆</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 统计元素频率，使用堆存储前 k 个高频元素</span><br><span class="line">2. 每次比较当前元素与堆顶的频率，维护堆的大小为 k</span><br><span class="line">3. 最后堆中的元素即为结果</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">topKFrequent</span>(<span class="params">nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="comment"># 1. 统计每个元素的频率</span></span><br><span class="line">        freq_map = Counter(nums)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 2. 使用最小堆找到前 k 个频率最高的元素</span></span><br><span class="line">        heap = []</span><br><span class="line">        <span class="keyword">for</span> num, freq <span class="keyword">in</span> freq_map.items():</span><br><span class="line">            heapq.heappush(heap, (freq, num))  <span class="comment"># 堆中存储 (频率, 元素)</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(heap) &gt; k:</span><br><span class="line">                heapq.heappop(heap)  <span class="comment"># 维持堆的大小为 k</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 3. 提取堆中的元素</span></span><br><span class="line">        <span class="keyword">return</span> [num <span class="keyword">for</span> freq, num <span class="keyword">in</span> heap]</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">topKFrequent</span>(<span class="params">nums, k</span>) &#123;</span><br><span class="line">        <span class="comment">// 1. 统计频率</span></span><br><span class="line">        <span class="keyword">const</span> freqMap = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> num <span class="keyword">of</span> nums)</span><br><span class="line">            freqMap.<span class="title function_">set</span>(num, (freqMap.<span class="title function_">get</span>(num) || <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 使用最小堆</span></span><br><span class="line">        <span class="keyword">const</span> minPQ = <span class="keyword">new</span> <span class="title class_">MinPriorityQueue</span>(&#123; <span class="attr">priority</span>: <span class="function"><span class="params">x</span> =&gt;</span> x[<span class="number">0</span>] &#125;);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> [num, freq] <span class="keyword">of</span> freqMap) &#123;</span><br><span class="line">            minPQ.<span class="title function_">enqueue</span>([freq, num]);</span><br><span class="line">            <span class="keyword">if</span> (minPQ.<span class="title function_">size</span>() &gt; k)</span><br><span class="line">                minPQ.<span class="title function_">dequeue</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 提取堆中的元素</span></span><br><span class="line">        <span class="keyword">return</span> minPQ.<span class="title function_">toArray</span>().<span class="title function_">map</span>(<span class="function"><span class="params">item</span> =&gt;</span> item.<span class="property">element</span>[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><ul><li>解法<code>3</code>: 桶排序</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 统计频率，并将元素按频率存储在“桶”中</span><br><span class="line">2. 桶的索引表示频率，从高到低提取前 k 个元素</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">topKFrequent</span>(<span class="params">nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="comment"># 1. 统计频率</span></span><br><span class="line">        freq_map = Counter(nums)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 2. 桶排序</span></span><br><span class="line">        bucket = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums) + <span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> num, freq <span class="keyword">in</span> freq_map.items():</span><br><span class="line">            bucket[freq].append(num) <span class="comment"># 将元素按频率存储在对应桶中</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 3. 从高频到低频提取前 k 个元素</span></span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(bucket) - <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> num <span class="keyword">in</span> bucket[i]:</span><br><span class="line">                result.append(num)</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">len</span>(result) == k:</span><br><span class="line">                    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">topKFrequent</span>(<span class="params">nums, k</span>) &#123;</span><br><span class="line">        <span class="comment">// 1. 统计频率</span></span><br><span class="line">        <span class="keyword">const</span> freqMap = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> num <span class="keyword">of</span> nums)</span><br><span class="line">            freqMap.<span class="title function_">set</span>(num, (freqMap.<span class="title function_">get</span>(num) || <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 桶排序</span></span><br><span class="line">        <span class="keyword">const</span> bucket = <span class="title class_">Array</span>(nums.<span class="property">length</span> + <span class="number">1</span>).<span class="title function_">fill</span>(<span class="literal">null</span>).<span class="title function_">map</span>(<span class="function">() =&gt;</span> []);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> [num, freq] <span class="keyword">of</span> freqMap)</span><br><span class="line">            bucket[freq].<span class="title function_">push</span>(num);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 从高频到低频提取前 k 个元素</span></span><br><span class="line">        <span class="keyword">const</span> result = [];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = bucket.<span class="property">length</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; result.<span class="property">length</span> &lt; k; i--)</span><br><span class="line">            result.<span class="title function_">push</span>(...bucket[i]);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><blockquote><p><code>最小堆</code>: 更灵活，可以适应动态输入数据，适合<code>k</code>较小的情况<br><code>桶排序</code>: 更高效，尤其是当<code>k</code>较大或频率分布较均匀时</p></blockquote><hr><h3 id="Design"><a href="#Design" class="headerlink" title="Design"></a><code>Design</code></h3><h4 id="LRU-缓存"><a href="#LRU-缓存" class="headerlink" title="LRU 缓存"></a><code>LRU</code> 缓存</h4><blockquote><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/lru-cache/">Leetcode 146. LRU Cache</a></p></blockquote><ul><li><p>题目: 实现一个数据结构<code>LRU Cache (Least Recently Used Cache)</code>，它能够在固定容量下缓存键值对，同时满足以下两种操作</p><ul><li><code>get(key)</code>: 如果键存在，返回其值，并将该键标记为最近使用。如果不存在，返回<code>-1</code></li><li><code>put(key, value)</code>: 插入新键值对。如果缓存已满，移除最久未使用的键值对</li></ul></li><li><p>解法<code>1</code>: <code>OrderedDict</code> (<code>Python</code>)</p><ul><li><code>Python</code>中的<code>OrderedDict</code>可以非常直观地实现<code>LRU Cache</code></li><li><code>OrderedDict</code>自动维护插入顺序，最久未使用的元素总在最前面</li><li>提供了<code>move_to_end(key)</code>方法，可以将某个键移动到末尾，表示最近使用</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">get 方法</span><br><span class="line">    如果键存在，将其移到末尾，表示最近使用，并返回对应值</span><br><span class="line">    如果键不存在，返回 -1</span><br><span class="line"></span><br><span class="line">put 方法</span><br><span class="line">    如果键存在，更新值并移到末尾</span><br><span class="line">    如果键不存在，直接添加</span><br><span class="line">    如果缓存超出容量，删除最前面的键（popitem(last=False)）</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> OrderedDict</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, capacity: <span class="built_in">int</span></span>):</span><br><span class="line">        self.cache = OrderedDict() <span class="comment"># 创建一个有序字典</span></span><br><span class="line">        self.capacity = capacity</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">self, key: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">in</span> self.cache:</span><br><span class="line">            <span class="comment"># 将访问的键移到末尾</span></span><br><span class="line">            self.cache.move_to_end(key)</span><br><span class="line">            <span class="keyword">return</span> self.cache[key]</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">put</span>(<span class="params">self, key: <span class="built_in">int</span>, value: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">in</span> self.cache:</span><br><span class="line">            <span class="comment"># 如果键已经存在，更新值，并移到末尾</span></span><br><span class="line">            self.cache.move_to_end(key)</span><br><span class="line">        self.cache[key] = value</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self.cache) &gt; self.capacity:</span><br><span class="line">            <span class="comment"># 超过容量时，删除第一个键（最久未使用）</span></span><br><span class="line">            self.cache.popitem(last=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><ul><li>解法<code>2</code>: <code>Map</code> (<code>Javascript</code>)<ul><li><code>JS</code>的<code>Map</code>数据结构，它按插入顺序存储键值对</li><li>使用<code>set(key, value)</code>方法更新键时，会将该键移到末尾，表示最近使用</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">get 方法</span><br><span class="line">    如果键存在，先删除它，再重新插入到末尾</span><br><span class="line">    如果键不存在，返回 -1</span><br><span class="line"></span><br><span class="line">put 方法</span><br><span class="line">    如果键已存在，先删除它，再插入新值</span><br><span class="line">    如果超过容量，删除最老的键（Map.keys().next().value 返回第一个键）</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">capacity</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">capacity</span> = capacity;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">cache</span> = <span class="keyword">new</span> <span class="title class_">Map</span>(); <span class="comment">// Map 是有序的，按插入顺序维护键值对</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">get</span>(<span class="params">key</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">cache</span>.<span class="title function_">has</span>(key)) <span class="keyword">return</span> -<span class="number">1</span>; </span><br><span class="line">        <span class="keyword">const</span> value = <span class="variable language_">this</span>.<span class="property">cache</span>.<span class="title function_">get</span>(key);</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">cache</span>.<span class="title function_">delete</span>(key); <span class="comment">// 删除旧位置的键</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">cache</span>.<span class="title function_">set</span>(key, value); <span class="comment">// 将键移到末尾（最新使用）</span></span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">put</span>(<span class="params">key, value</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">cache</span>.<span class="title function_">has</span>(key))</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">cache</span>.<span class="title function_">delete</span>(key); <span class="comment">// 如果键已存在，先删除它</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">cache</span>.<span class="title function_">set</span>(key, value); <span class="comment">// 插入新键值对</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">cache</span>.<span class="property">size</span> &gt; <span class="variable language_">this</span>.<span class="property">capacity</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> oldestKey = <span class="variable language_">this</span>.<span class="property">cache</span>.<span class="property">keys</span>.<span class="title function_">next</span>().<span class="property">value</span>; <span class="comment">// 获取最老的键</span></span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">cache</span>.<span class="title function_">delete</span>(oldestKey);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>JS</code> 的写法要比 <code>Python</code> 简单</p></blockquote><hr><h4 id="实现随机集合"><a href="#实现随机集合" class="headerlink" title="实现随机集合"></a>实现随机集合</h4><blockquote><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/insert-delete-getrandom-o1/">Leetcode 380. Insert Delete GetRandom O(1)</a></p></blockquote><ul><li>题目: 设计一个支持以下操作的集合，在平均时间复杂度为<code>O(1)</code>下实现插入、删除和随机获取操作<ul><li><code>insert(val)</code>: 如果集合中没有该值，则插入</li><li><code>remove(val)</code>: 如果集合中存在该值</li><li><code>getRandom()</code>: 随机返回集合中的一个元素，每个元素被返回的概率相等</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input</span><br><span class="line">[&quot;RandomizedSet&quot;, &quot;insert&quot;, &quot;remove&quot;, &quot;insert&quot;, &quot;getRandom&quot;, &quot;remove&quot;, &quot;insert&quot;, &quot;getRandom&quot;]</span><br><span class="line">[[], [1], [2], [2], [], [1], [2], []]</span><br><span class="line">Output</span><br><span class="line">[null, true, false, true, 2, true, false, 2]</span><br></pre></td></tr></table></figure><ul><li>解法: 数组 + 哈希表</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 数组存储集合的元素，用于随机访问</span><br><span class="line">2. 哈希表记录每个值在数组中的索引，方便 O(1) 时间查找和删除</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RandomizedSet</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.<span class="built_in">dict</span> = &#123;&#125;</span><br><span class="line">        self.<span class="built_in">list</span> = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">insert</span>(<span class="params">self, val: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">if</span> val <span class="keyword">in</span> self.<span class="built_in">dict</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        self.<span class="built_in">dict</span>[val] = <span class="built_in">len</span>(self.<span class="built_in">list</span>) <span class="comment"># 记录值的索引</span></span><br><span class="line">        self.<span class="built_in">list</span>.append(val) <span class="comment"># 将值添加到列表</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">remove</span>(<span class="params">self, val: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">if</span> val <span class="keyword">not</span> <span class="keyword">in</span> self.<span class="built_in">dict</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        index = self.<span class="built_in">dict</span>[val] <span class="comment"># 获取值的索引</span></span><br><span class="line">        last_element = self.<span class="built_in">list</span>[-<span class="number">1</span>] <span class="comment"># 获取列表中的最后一个元素</span></span><br><span class="line">        self.<span class="built_in">list</span>[index] = last_element <span class="comment"># 将最后一个元素移到被移除的位置</span></span><br><span class="line">        self.<span class="built_in">dict</span>[last_element] = index <span class="comment"># 更新最后一个元素的索引</span></span><br><span class="line">        self.<span class="built_in">list</span>.pop() <span class="comment"># 删除最后一个元素</span></span><br><span class="line">        <span class="keyword">del</span> self.<span class="built_in">dict</span>[val] <span class="comment"># 从字典中删除该值</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getRandom</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">return</span> random.choice(self.<span class="built_in">list</span>) <span class="comment"># 随机选择一个列表中的值</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">map</span> = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">list</span> = [];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">insert</span>(<span class="params">val</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">map</span>.<span class="title function_">has</span>(val)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">map</span>.<span class="title function_">set</span>(val, <span class="variable language_">this</span>.<span class="property">list</span>.<span class="property">length</span>); <span class="comment">// 存储值和索引</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">list</span>.<span class="title function_">push</span>(val); <span class="comment">// 将值添加到数组</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">remove</span>(<span class="params">val</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">map</span>.<span class="title function_">has</span>(val)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">const</span> index = <span class="variable language_">this</span>.<span class="property">map</span>.<span class="title function_">get</span>(val); <span class="comment">// 获取值的索引</span></span><br><span class="line">        <span class="keyword">const</span> lastElement = <span class="variable language_">this</span>.<span class="property">list</span>[<span class="variable language_">this</span>.<span class="property">list</span>.<span class="property">length</span> - <span class="number">1</span>]; <span class="comment">// 获取最后一个值</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">list</span>[index] = lastElement; <span class="comment">// 将最后一个值移到被删除的位置</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">map</span>.<span class="title function_">set</span>(lastElement, index); <span class="comment">// 更新最后一个值的索引</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">list</span>.<span class="title function_">pop</span>(); <span class="comment">// 删除最后一个值</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">map</span>.<span class="title function_">delete</span>(val); <span class="comment">// 从映射中删除该值</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">getRandom</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> randomIndex = <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="variable language_">this</span>.<span class="property">list</span>.<span class="property">length</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">list</span>[randomIndex];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h3 id="LinkedList-链表"><a href="#LinkedList-链表" class="headerlink" title="LinkedList 链表"></a><code>LinkedList</code> 链表</h3><h4 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h4><blockquote><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/reverse-linked-list/">Leetcode 206. Reverse Linked List</a></p></blockquote><ul><li>题目: 给定一个单链表的头节点<code>head</code>，将其完全反转，并返回新的头节点</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: head = [0,1,2,3]</span><br><span class="line">Output: [3,2,1,0]</span><br></pre></td></tr></table></figure><ul><li>解法: <code>Two Pointers</code> 双指针</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 初始化两个指针：prev 表示前一个节点，curr 表示当前节点</span><br><span class="line">2. 遍历链表，逐个调整当前节点的指向，使其指向前一个节点</span><br><span class="line">3. 移动指针，直到链表尾部</span><br><span class="line">4. 返回 prev 作为新的头节点</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseList</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        prev = <span class="literal">None</span></span><br><span class="line">        curr = head</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> curr:</span><br><span class="line">            tmp = curr.<span class="built_in">next</span> <span class="comment"># 暂存下一个节点</span></span><br><span class="line">            curr.<span class="built_in">next</span> = prev <span class="comment"># 当前节点指向前一个节点</span></span><br><span class="line">            prev = curr <span class="comment"># prev 向前移动到当前节点</span></span><br><span class="line">            curr = tmp <span class="comment"># curr 向前移动到下一个节点</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> prev   </span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">reverseList</span>(<span class="params">head</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> prev = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">let</span> curr = head;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (curr) &#123;</span><br><span class="line">            <span class="keyword">let</span> tmp = curr.<span class="property">next</span>; <span class="comment">// 暂存下一个节点</span></span><br><span class="line">            curr.<span class="property">next</span> = prev; <span class="comment">// 当前节点指向前一个节点</span></span><br><span class="line">            prev = curr; <span class="comment">// prev 向前移动到当前节点</span></span><br><span class="line">            curr = tmp; <span class="comment">// curr 向前移动到下一个节点</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h4 id="反转链表中间部分"><a href="#反转链表中间部分" class="headerlink" title="反转链表中间部分"></a>反转链表中间部分</h4><blockquote><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/reverse-linked-list-ii/">Leetcode 92. Reverse Linked List II</a></p></blockquote><ul><li>题目: 给定一个单链表的头节点<code>head</code>，以及两个整数<code>left</code>和<code>right</code>，反转链表中从位置<code>left</code>到位置<code>right</code>的部分，并返回链表的头节点</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: head = [1,2,3,4,5], left = 2, right = 4</span><br><span class="line">Output: [1,4,3,2,5]</span><br></pre></td></tr></table></figure><ul><li>解法: 虚拟头节点法</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 添加虚拟头节点：用于处理从链表头部开始反转的特殊情况</span><br><span class="line">2. 找到 left 的前驱节点 prev 和要反转的第一个节点 curr</span><br><span class="line">3. 遍历从 left 到 right 的链表部分，逐个将当前节点插入到子链表的头部</span><br><span class="line">4. 返回链表的新头节点</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseBetween</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode], left: <span class="built_in">int</span>, right: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        dummy = ListNode(<span class="number">0</span>, head)</span><br><span class="line">        prev = dummy</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 1. 找到 left 的前驱节点（prev）和 left 节点（curr）</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(left - <span class="number">1</span>):</span><br><span class="line">            prev = prev.<span class="built_in">next</span></span><br><span class="line">        curr = prev.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 2. 反转 [left, right] 之间的节点</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(right - left):</span><br><span class="line">            tmp = curr.<span class="built_in">next</span> <span class="comment"># 暂存当前节点的 next</span></span><br><span class="line">            curr.<span class="built_in">next</span> = tmp.<span class="built_in">next</span> <span class="comment"># 当前节点指向 next 的 next</span></span><br><span class="line">            tmp.<span class="built_in">next</span> = prev.<span class="built_in">next</span> <span class="comment"># 插入到子链表头部</span></span><br><span class="line">            prev.<span class="built_in">next</span> = tmp <span class="comment"># 更新 prev 的 next</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">reverseBetween</span>(<span class="params">head, left, right</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> dummy = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        dummy.<span class="property">next</span> = head;</span><br><span class="line">        <span class="keyword">let</span> prev = dummy;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 找到 left 的前驱节点（prev）和 left 节点（curr）</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; left; i++)</span><br><span class="line">            prev = prev.<span class="property">next</span>;</span><br><span class="line">        curr = prev.<span class="property">next</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 反转 [left, right] 之间的节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; right - left; i++) &#123;</span><br><span class="line">            <span class="keyword">let</span> tmp = curr.<span class="property">next</span>;</span><br><span class="line">            curr.<span class="property">next</span> = tmp.<span class="property">next</span>;</span><br><span class="line">            tmp.<span class="property">next</span> = prev.<span class="property">next</span>;</span><br><span class="line">            prev.<span class="property">next</span> = tmp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h4 id="合成链表"><a href="#合成链表" class="headerlink" title="合成链表"></a>合成链表</h4><blockquote><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/merge-two-sorted-lists/">Leetcode 21. Merge Two Sorted Lists</a></p></blockquote><ul><li>题目: 给定两个单链表<code>list1</code>和<code>list2</code>，它们的元素按升序排列。将它们合并为一个新的链表，要求新链表也按照升序排列，并返回新链表的头节点</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: list1 = [1,2,4], list2 = [1,3,5]</span><br><span class="line">Output: [1,1,2,3,4,5]</span><br></pre></td></tr></table></figure><ul><li>解法: 虚拟头节点法</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 使用一个虚拟头节点 dummy 来简化链表连接逻辑</span><br><span class="line">2. 遍历 list1 和 list2，逐步比较它们的节点值，将较小的节点连接到结果链表中</span><br><span class="line">3. 当一个链表遍历完成后，将另一个链表剩余的节点直接连接到结果链表</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">mergeTwoLists</span>(<span class="params">self, list1: <span class="type">Optional</span>[ListNode], list2: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        dummy = ListNode()</span><br><span class="line">        curr = dummy</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 遍历两个链表，比较节点值</span></span><br><span class="line">        <span class="keyword">while</span> list1 <span class="keyword">and</span> list2:</span><br><span class="line">            <span class="keyword">if</span> list1.val &lt; list2.val:</span><br><span class="line">                curr.<span class="built_in">next</span> = list1</span><br><span class="line">                list1 = list1.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                curr.<span class="built_in">next</span> = list2</span><br><span class="line">                list2 = list2.<span class="built_in">next</span></span><br><span class="line">            curr = curr.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 连接剩余的节点</span></span><br><span class="line">        curr.<span class="built_in">next</span> = list1 <span class="keyword">or</span> list2</span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">mergeTwoLists</span>(<span class="params">list1, list2</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> dummy = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">let</span> curr = dummt;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历两个链表，比较节点值</span></span><br><span class="line">        <span class="keyword">while</span> (list1 !== <span class="literal">null</span> &amp;&amp; list2 !== <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (list1.<span class="property">val</span> &lt; list2.<span class="property">val</span>) &#123;</span><br><span class="line">                curr.<span class="property">next</span> = list1;</span><br><span class="line">                list1 = list1.<span class="property">next</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                curr.<span class="property">next</span> = list2;</span><br><span class="line">                list2 = list2.<span class="property">next</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            curr = curr.<span class="property">next</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 连接剩余的节点</span></span><br><span class="line">        curr.<span class="property">next</span> = list1 !== <span class="literal">null</span> ? list1 : list2;</span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h4 id="k个一组翻转链表"><a href="#k个一组翻转链表" class="headerlink" title="k个一组翻转链表"></a><code>k</code>个一组翻转链表</h4><blockquote><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/reverse-nodes-in-k-group/">Leetcode 25. Reverse Nodes in k-Group</a></p></blockquote><ul><li>题目: 给定一个单链表的头节点<code>head</code>和一个整数<code>k</code>，将链表按照每<code>k</code>个节点为一组进行翻转。如果剩余节点不足 <code>k</code>个，则保持原样。要求返回翻转后的链表</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: head = [1,2,3,4,5,6], k = 3</span><br><span class="line">Output: [3,2,1,6,5,4]</span><br></pre></td></tr></table></figure><ul><li>解法: 按组翻转 + 双指针</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 遍历链表并按 k 个节点为一组分割</span><br><span class="line">2. 对每组节点执行翻转操作</span><br><span class="line">3. 翻转后的部分与链表的其他部分正确连接</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseKGroup</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode], k: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        dummy = ListNode(<span class="number">0</span>, head)</span><br><span class="line">        group_prev = dummy</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="comment"># 找到当前组的第 k 个节点</span></span><br><span class="line">            kth = self.getKthNode(group_prev, k)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> kth:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            group_next = kth.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 反转当前组的节点</span></span><br><span class="line">            prev, curr = group_next, group_prev.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">while</span> curr != group_next:</span><br><span class="line">                tmp = curr.<span class="built_in">next</span></span><br><span class="line">                curr.<span class="built_in">next</span> = prev</span><br><span class="line">                prev = curr</span><br><span class="line">                curr = tmp</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 处理连接：将反转后的部分与链表其余部分连接起来</span></span><br><span class="line">            tmp = group_prev.<span class="built_in">next</span></span><br><span class="line">            group_prev.<span class="built_in">next</span> = kth</span><br><span class="line">            group_prev = tmp</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getKthNode</span>(<span class="params">self, curr, k</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        <span class="keyword">while</span> curr <span class="keyword">and</span> k &gt; <span class="number">0</span>:</span><br><span class="line">            curr = curr.<span class="built_in">next</span></span><br><span class="line">            k -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> curr</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">reverseKGroup</span>(<span class="params">head, k</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> dummy = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        dummy.<span class="property">next</span> = head;</span><br><span class="line">        <span class="keyword">let</span> groupPrev = dummy;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 找到当前组的第 k 个节点</span></span><br><span class="line">            <span class="keyword">const</span> kth = <span class="variable language_">this</span>.<span class="title function_">getKthNode</span>(groupPrev, k);</span><br><span class="line">            <span class="keyword">if</span> (!kth) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">const</span> groupNext = kth.<span class="property">next</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 反转当前组的节点</span></span><br><span class="line">            <span class="keyword">let</span> prev = groupNext;</span><br><span class="line">            <span class="keyword">let</span> curr = groupPrev.<span class="property">next</span>;</span><br><span class="line">            <span class="keyword">while</span> (curr !== groupNext) &#123;</span><br><span class="line">                <span class="keyword">const</span> tmp = curr.<span class="property">next</span>;</span><br><span class="line">                curr.<span class="property">next</span> = prev;</span><br><span class="line">                prev = curr;</span><br><span class="line">                curr = tmp;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 处理连接</span></span><br><span class="line">            <span class="keyword">const</span> tmp = groupPrev.<span class="property">next</span>;</span><br><span class="line">            groupPrev.<span class="property">next</span> = kth;</span><br><span class="line">            groupPrev = tmp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">getKthNode</span>(<span class="params">curr, k</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (curr &amp;&amp; k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            curr = curr.<span class="property">next</span>;</span><br><span class="line">            k--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> curr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h4 id="成对反转链表节点"><a href="#成对反转链表节点" class="headerlink" title="成对反转链表节点"></a>成对反转链表节点</h4><blockquote><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/swap-nodes-in-pairs/">Leetcode 24. Swap Nodes in Pairs</a></p></blockquote><ul><li>题目: 给定一个单链表的头节点<code>head</code>，将链表中的节点两两交换，并返回交换后的链表。如果链表节点数是奇数，最后一个节点保持不变</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: head = [1,2,3,4]</span><br><span class="line">Output: [2,1,4,3]</span><br></pre></td></tr></table></figure><ul><li>解法: 虚拟头节点法</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 使用一个虚拟头节点 dummy，便于操作头节点及其后的节点</span><br><span class="line">2. 每次取出两个相邻节点，将它们交换</span><br><span class="line">3. 正确调整指针以保持链表的顺序</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">swapPairs</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        dummy = ListNode(<span class="number">0</span>, head)</span><br><span class="line">        prev = dummy</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> head <span class="keyword">and</span> head.<span class="built_in">next</span>:</span><br><span class="line">            <span class="comment"># 要交换的两个节点</span></span><br><span class="line">            first = head</span><br><span class="line">            second = head.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 交换节点</span></span><br><span class="line">            prev.<span class="built_in">next</span> = second</span><br><span class="line">            first.<span class="built_in">next</span> = second.<span class="built_in">next</span></span><br><span class="line">            second.<span class="built_in">next</span> = first</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 移动指针准备下一组交换</span></span><br><span class="line">            prev = first</span><br><span class="line">            head = first.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">swapPairs</span>(<span class="params">head</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> dummy = <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        dummy.<span class="property">next</span> = head;</span><br><span class="line">        <span class="keyword">let</span> prev = dummy;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (head &amp;&amp; head.<span class="property">next</span>) &#123;</span><br><span class="line">            <span class="comment">// 要交换的两个节点</span></span><br><span class="line">            <span class="keyword">const</span> first = head;</span><br><span class="line">            <span class="keyword">const</span> second = head.<span class="property">next</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 交换节点</span></span><br><span class="line">            prev.<span class="property">next</span> = second;</span><br><span class="line">            first.<span class="property">next</span> = second.<span class="property">next</span>;</span><br><span class="line">            second.<span class="property">next</span> = first;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 移动指针准备下一组交换</span></span><br><span class="line">            prev = first;</span><br><span class="line">            head = first.<span class="property">next</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h4 id="对折链表"><a href="#对折链表" class="headerlink" title="对折链表"></a>对折链表</h4><blockquote><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/reorder-list/">Leetcode 143. Reorder List</a></p></blockquote><ul><li>题目: 给定一个单链表<code>head</code>，要求在原地修改链表，不使用额外的空间, 将其重新排序为<ul><li>原链表的第一个节点 -&gt; 最后一个节点 -&gt; 第二个节点 -&gt; 倒数第二个节点 -&gt;</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: head = [1,2,3,4,5]</span><br><span class="line">Output: [1,5,2,4,3]</span><br></pre></td></tr></table></figure><ul><li>解法: 快慢指针 + 反转链表 + 合并链表</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 找到链表中点</span><br><span class="line">   - 使用快慢指针，快指针每次移动两步，慢指针每次移动一步，当快指针到达末尾时，慢指针指向中点</span><br><span class="line">2. 反转链表后半部分</span><br><span class="line">   - 将链表从中点分成两部分，反转后半部分链表</span><br><span class="line">3. 合并链表</span><br><span class="line">   - 按顺序交替连接前半部分和反转后的后半部分链表</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reorderList</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify head in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 1. 使用快慢指针找到链表中点</span></span><br><span class="line">        slow = head</span><br><span class="line">        fast = head.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> fast <span class="keyword">and</span> fast.<span class="built_in">next</span>:</span><br><span class="line">            slow = slow.<span class="built_in">next</span></span><br><span class="line">            fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 2. 反转链表的后半部分</span></span><br><span class="line">        second = slow.<span class="built_in">next</span></span><br><span class="line">        prev = <span class="literal">None</span></span><br><span class="line">        slow.<span class="built_in">next</span> = <span class="literal">None</span> <span class="comment"># 切断前半部分和后半部分链表的连接</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> second:</span><br><span class="line">            tmp = second.<span class="built_in">next</span></span><br><span class="line">            second.<span class="built_in">next</span> = prev</span><br><span class="line">            prev = second</span><br><span class="line">            second = tmp</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 3. 合并链表</span></span><br><span class="line">        first, second = head, prev <span class="comment"># first 是前半部分的链表头，second 是反转后的后半部分链表头</span></span><br><span class="line">        <span class="keyword">while</span> second:</span><br><span class="line">            tmp1, tmp2 = first.<span class="built_in">next</span>, second.<span class="built_in">next</span></span><br><span class="line">            first.<span class="built_in">next</span> = second</span><br><span class="line">            second.<span class="built_in">next</span> = tmp1</span><br><span class="line">            first, second = tmp1, tmp2</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">reorderList</span>(<span class="params">head</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!head || !head.<span class="property">next</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 使用快慢指针找到链表中点</span></span><br><span class="line">        <span class="keyword">let</span> slow = head, fast = head.<span class="property">next</span>;</span><br><span class="line">        <span class="keyword">while</span> (fast &amp;&amp; fast.<span class="property">next</span>) &#123;</span><br><span class="line">            slow = slow.<span class="property">next</span>;</span><br><span class="line">            fast = fast.<span class="property">next</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 反转链表的后半部分</span></span><br><span class="line">        <span class="keyword">let</span> second = slow.<span class="property">next</span>;</span><br><span class="line">        slow.<span class="property">next</span> = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">let</span> prev = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (second) &#123;</span><br><span class="line">            <span class="keyword">let</span> tmp = second.<span class="property">next</span>;</span><br><span class="line">            second.<span class="property">next</span> = prev;</span><br><span class="line">            prev = second;</span><br><span class="line">            second = tmp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 合并链表</span></span><br><span class="line">        <span class="keyword">let</span> first = head;</span><br><span class="line">        second = prev;</span><br><span class="line">        <span class="keyword">while</span> (second) &#123;</span><br><span class="line">            <span class="keyword">let</span> tmp1 = first.<span class="property">next</span>, tmp2 = second.<span class="property">next</span>;</span><br><span class="line">            first.<span class="property">next</span> = second;</span><br><span class="line">            second.<span class="property">next</span> = tmp1;</span><br><span class="line">            first = tmp1;</span><br><span class="line">            second = tmp2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h4 id="删除有序链表重复元素"><a href="#删除有序链表重复元素" class="headerlink" title="删除有序链表重复元素"></a>删除有序链表重复元素</h4><blockquote><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/remove-duplicates-from-sorted-list/">Leetcode 83. Remove Duplicates from Sorted List</a></p></blockquote><ul><li>题目: 从一个升序排列的链表中，删除所有重复的节点，确保每个值只出现一次</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: head = [1,1,2,3,3]</span><br><span class="line">Output: [1,2,3]</span><br></pre></td></tr></table></figure><ul><li>解法: 遍历链表</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 从链表头开始，依次检查当前节点和下一个节点的值</span><br><span class="line">2. 如果当前节点值和下一个节点值相同，则跳过下一个节点</span><br><span class="line">3. 如果值不同，则移动指针到下一个节点</span><br><span class="line">4. 重复上述过程，直到遍历完整个链表</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">deleteDuplicates</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        curr = head</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> curr <span class="keyword">and</span> curr.<span class="built_in">next</span>:</span><br><span class="line">            <span class="keyword">if</span> curr.val == curr.<span class="built_in">next</span>.val: <span class="comment"># 如果当前值等于下一个值</span></span><br><span class="line">                curr.<span class="built_in">next</span> = curr.<span class="built_in">next</span>.<span class="built_in">next</span> <span class="comment"># 跳过下一个节点</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                curr = curr.<span class="built_in">next</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">deleteDuplicates</span>(<span class="params">head</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> curr = head;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (curr &amp;&amp; curr.<span class="property">next</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (curr.<span class="property">val</span> === curr.<span class="property">next</span>.<span class="property">val</span>)</span><br><span class="line">                curr.<span class="property">next</span> = curr.<span class="property">next</span>.<span class="property">next</span>; <span class="comment">// 跳过下一个节点</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                curr = curr.<span class="property">next</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h4 id="删除有序链表所有重复元素"><a href="#删除有序链表所有重复元素" class="headerlink" title="删除有序链表所有重复元素"></a>删除有序链表所有重复元素</h4><blockquote><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/">Leetcode 82. Remove Duplicates from Sorted List II</a></p></blockquote><ul><li>题目: 从一个升序排列的链表中，删除所有出现次数超过<code>1</code>次的节点，仅保留没有重复的节点</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: head = [1,2,3,3,4,4,5]</span><br><span class="line">Output: [1,2,5]</span><br></pre></td></tr></table></figure><ul><li>解法: 双指针 + 虚拟头节点</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 创建虚拟头节点 dummy，以处理可能需要删除头节点的情况</span><br><span class="line">2. 定义两个指针：</span><br><span class="line">    - prev：指向最后一个不重复的节点</span><br><span class="line">    - curr：用于遍历链表</span><br><span class="line">3. 遍历链表：</span><br><span class="line">    - 如果 curr 和 curr.next 的值相同，跳过所有重复的节点</span><br><span class="line">    - 如果没有重复，移动 prev 指针到当前节点</span><br><span class="line">4. 返回虚拟头节点的下一个节点</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">deleteDuplicates</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        dummy = ListNode(<span class="number">0</span>, head)</span><br><span class="line">        prev = dummy</span><br><span class="line">        curr = head</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> curr:</span><br><span class="line">            <span class="comment"># 如果当前节点的值与下一个节点的值相同</span></span><br><span class="line">            <span class="keyword">if</span> curr.<span class="built_in">next</span> <span class="keyword">and</span> curr.val == curr.<span class="built_in">next</span>.val:</span><br><span class="line">                <span class="comment"># 跳过所有值相同的节点</span></span><br><span class="line">                <span class="keyword">while</span> curr.<span class="built_in">next</span> <span class="keyword">and</span> curr.val == curr.<span class="built_in">next</span>.val:</span><br><span class="line">                    curr = curr.<span class="built_in">next</span></span><br><span class="line">                <span class="comment"># 将 prev 的 next 指向下一个不重复的节点</span></span><br><span class="line">                prev.<span class="built_in">next</span> = curr.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 如果没有重复，移动 prev 指针</span></span><br><span class="line">                prev = prev.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 移动 curr 指针</span></span><br><span class="line">            curr = curr.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">deleteDuplicates</span>(<span class="params">head</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> dummy = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>, head);</span><br><span class="line">        <span class="keyword">let</span> prev = dummy;</span><br><span class="line">        <span class="keyword">let</span> curr = head;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (curr) &#123;</span><br><span class="line">            <span class="comment">// 如果当前节点的值与下一个节点的值相同</span></span><br><span class="line">            <span class="keyword">if</span> (curr.<span class="property">next</span> &amp;&amp; curr.<span class="property">val</span> === curr.<span class="property">next</span>.<span class="property">val</span>) &#123;</span><br><span class="line">                <span class="comment">// 跳过所有值相同的节点</span></span><br><span class="line">                <span class="keyword">while</span> (curr.<span class="property">next</span> &amp;&amp; curr.<span class="property">val</span> === curr.<span class="property">next</span>.<span class="property">val</span>)</span><br><span class="line">                    curr = curr.<span class="property">next</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将 prev 的 next 指向下一个不重复的节点</span></span><br><span class="line">            prev.<span class="property">next</span> = curr.<span class="property">next</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果没有重复，移动 prev 指针</span></span><br><span class="line">            prev = prev.<span class="property">next</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 移动 curr 指针</span></span><br><span class="line">        curr = curr.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dummy.<span class="property">next</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h4 id="链表转树"><a href="#链表转树" class="headerlink" title="链表转树"></a>链表转树</h4><blockquote><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/">Leetcode 109. Convert Sorted List to Binary Search Tree</a></p></blockquote><ul><li>题目: 将一个有序链表转换为高度平衡的二叉搜索树（<code>BST</code>）。高度平衡指的是树中每个节点的两个子树的高度差不超过<code>1</code></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: head = [-10,-3,0,5,9]</span><br><span class="line">Output: [0,-3,9,-10,null,5]</span><br></pre></td></tr></table></figure><ul><li>解法: 分治法 + 快慢指针</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 使用快慢指针找到链表的中间节点，将其作为当前树的根节点</span><br><span class="line">2. 对中间节点之前的链表递归构建左子树</span><br><span class="line">3. 对中间节点之后的链表递归构建右子树</span><br><span class="line">4. 当链表为空时，返回 None</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sortedListToBST</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">        <span class="comment"># 辅助函数：找到链表的中间节点</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">find_middle</span>(<span class="params">start, end</span>):</span><br><span class="line">            slow = fast = start</span><br><span class="line">            <span class="keyword">while</span> fast != end <span class="keyword">and</span> fast.<span class="built_in">next</span> != end:</span><br><span class="line">                slow = slow.<span class="built_in">next</span></span><br><span class="line">                fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">return</span> slow</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 主函数：递归构建二叉搜索树</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">build_bst</span>(<span class="params">start, end</span>):</span><br><span class="line">            <span class="keyword">if</span> start == end:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            </span><br><span class="line">            mid = find_middle(start, end)</span><br><span class="line">            root = TreeNode(mid.val)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 构建左右子树</span></span><br><span class="line">            root.left = build_bst(start, mid)</span><br><span class="line">            root.right = build_bst(mid.<span class="built_in">next</span>, end)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> build_bst(head, <span class="literal">None</span>)</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">sortedListToBST</span>(<span class="params">head</span>) &#123;</span><br><span class="line">        <span class="comment">// 辅助函数：找到链表的中间节点</span></span><br><span class="line">        <span class="keyword">function</span> <span class="title function_">findMiddle</span>(<span class="params">start, end</span>) &#123;</span><br><span class="line">            <span class="keyword">let</span> slow = start;</span><br><span class="line">            <span class="keyword">let</span> fast = start;</span><br><span class="line">            <span class="keyword">while</span> (fast !== end &amp;&amp; fast.<span class="property">next</span> !== end) &#123;</span><br><span class="line">                slow = slow.<span class="property">next</span>;</span><br><span class="line">                fast = fast.<span class="property">next</span>.<span class="property">next</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> slow;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 主函数：递归构建二叉搜索树</span></span><br><span class="line">        <span class="keyword">function</span> <span class="title function_">buildBST</span>(<span class="params">start, end</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (start === end) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> mid = <span class="title function_">findMiddle</span>(start, end);</span><br><span class="line">            <span class="keyword">const</span> root = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(mid.<span class="property">val</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 构建左右子树</span></span><br><span class="line">            root.<span class="property">left</span> = <span class="title function_">buildBST</span>(start, mid);</span><br><span class="line">            root.<span class="property">right</span> = <span class="title function_">buildBST</span>(mid.<span class="property">next</span>, end);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">buildBST</span>(head, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h4 id="合并k个有序链表"><a href="#合并k个有序链表" class="headerlink" title="合并k个有序链表"></a>合并<code>k</code>个有序链表</h4><blockquote><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/merge-k-sorted-lists/">Leetcode 23. Merge k Sorted Lists</a></p></blockquote><ul><li>题目: 给定<code>k</code>个有序链表，将它们合并成一个有序链表并返</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: lists = [[1,4,5],[1,3,4],[2,6]]</span><br><span class="line">Output: [1,1,2,3,4,4,5,6]</span><br></pre></td></tr></table></figure><ul><li>解法: 最小堆（优先队列）</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 将每个链表的头节点加入最小堆</span><br><span class="line">2. 每次从堆中取出最小值节点，将其加入结果链表</span><br><span class="line">3. 如果该节点有下一个节点，将下一个节点加入堆中</span><br><span class="line">4. 重复以上过程直到堆为空</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">mergeKLists</span>(<span class="params">self, lists: <span class="type">List</span>[<span class="type">Optional</span>[ListNode]]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        min_heap = []</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 将每个链表的头节点放入堆中</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(lists)):</span><br><span class="line">            <span class="keyword">if</span> lists[i]:</span><br><span class="line">                heapq.heappush(min_heap, (lists[i].val, i, lists[i]))</span><br><span class="line"></span><br><span class="line">        dummy = ListNode(<span class="number">0</span>)</span><br><span class="line">        curr = dummy</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 不断从堆中取出最小节点，并将其后续节点继续放入堆中</span></span><br><span class="line">        <span class="keyword">while</span> min_heap:</span><br><span class="line">            val, idx, node = heapq.heappop(min_heap)</span><br><span class="line">            curr.<span class="built_in">next</span> = node</span><br><span class="line">            curr = curr.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">if</span> node.<span class="built_in">next</span>:</span><br><span class="line">                heapq.heappush(min_heap, (node.<span class="built_in">next</span>.val, idx, node.<span class="built_in">next</span>))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">mergeKLists</span>(<span class="params">lists</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> minHeap = <span class="keyword">new</span> <span class="title class_">MinPriorityQueue</span>(&#123; <span class="attr">priority</span>: <span class="function">(<span class="params">node</span>) =&gt;</span> node.<span class="property">val</span> &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将每个链表的头节点加入堆中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; lists.<span class="property">length</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (lists[i])</span><br><span class="line">                minHeap.<span class="title function_">enqueue</span>(lists[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> dummy = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">let</span> curr = dummy;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从堆中取出最小节点，构建合并链表</span></span><br><span class="line">        <span class="keyword">while</span> (!minHeap.<span class="title function_">isEmpty</span>()) &#123;</span><br><span class="line">            <span class="keyword">const</span> smallestNode = minHeap.<span class="title function_">dequeue</span>().<span class="property">element</span>; <span class="comment">// 取出最小值节点</span></span><br><span class="line">            curr.<span class="property">next</span> = smallestNode;</span><br><span class="line">            curr = curr.<span class="property">next</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (smallestNode.<span class="property">next</span>)</span><br><span class="line">                minHeap.<span class="title function_">enqueue</span>(smallestNode.<span class="property">next</span>); <span class="comment">// 将下一个节点加入堆</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h3 id="BFS-amp-DFS"><a href="#BFS-amp-DFS" class="headerlink" title="BFS &amp; DFS"></a><code>BFS</code> &amp; <code>DFS</code></h3><h4 id="海岛问题"><a href="#海岛问题" class="headerlink" title="海岛问题"></a>海岛问题</h4><blockquote><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/number-of-islands/">Leetcode 200. Number of Islands</a></p></blockquote><ul><li>题目: 给定一个由<code>&#39;1&#39;</code>和<code>&#39;0&#39;</code>组成的网格，<code>&#39;1&#39;</code>表示陆地，<code>&#39;0&#39;</code>表示水域，计算网格中岛屿的数量。岛屿被水域包围，由相邻的陆地（水平或垂直方向）连接而成</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: grid = [</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;]</span><br><span class="line">]</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure><ul><li>解法<code>1</code>: 广度优先搜索 (<code>BFS</code>)</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 遍历网格中的每个位置，找到未访问的陆地节点作为起点</span><br><span class="line">2. 从起点开始，使用 BFS 遍历整个岛屿，将所有相连的陆地标记为已访问</span><br><span class="line">3. 每发现一个新岛屿时，岛屿计数器加一</span><br><span class="line">4. 返回最终的岛屿数量</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">numIslands</span>(<span class="params">self, grid: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        island = <span class="number">0</span></span><br><span class="line">        visited = <span class="built_in">set</span>() <span class="comment"># 记录已访问节点</span></span><br><span class="line">        rows, cols = <span class="built_in">len</span>(grid), <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">bfs</span>(<span class="params">r, c</span>):</span><br><span class="line">            q = deque()</span><br><span class="line">            q.append((r, c))</span><br><span class="line">            visited.add((r, c))</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> q:</span><br><span class="line">                row, col = q.popleft()</span><br><span class="line">                <span class="keyword">for</span> dr, dc <span class="keyword">in</span> [[<span class="number">1</span>, <span class="number">0</span>], [-<span class="number">1</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">1</span>], [<span class="number">0</span>, -<span class="number">1</span>]]:</span><br><span class="line">                    nr, nc = dr + row, dc + col</span><br><span class="line">                    <span class="keyword">if</span> (</span><br><span class="line">                        <span class="number">0</span> &lt;= nr &lt; rows <span class="keyword">and</span></span><br><span class="line">                        <span class="number">0</span> &lt;= nc &lt; cols <span class="keyword">and</span></span><br><span class="line">                        grid[nr][nc] == <span class="string">&quot;1&quot;</span> <span class="keyword">and</span></span><br><span class="line">                        (nr, nc) <span class="keyword">not</span> <span class="keyword">in</span> visited</span><br><span class="line">                    ):</span><br><span class="line">                        q.append((nr, nc))</span><br><span class="line">                        visited.add((nr, nc))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> r <span class="keyword">in</span> <span class="built_in">range</span>(rows):</span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">range</span>(cols):</span><br><span class="line">                <span class="keyword">if</span> grid[r][c] == <span class="string">&quot;1&quot;</span> <span class="keyword">and</span> (r, c) <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">                    island += <span class="number">1</span></span><br><span class="line">                    bfs(r, c)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> island</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">numIslands</span>(<span class="params">grid</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> rows = grid.<span class="property">length</span>;</span><br><span class="line">        <span class="keyword">const</span> cols = grid[<span class="number">0</span>].<span class="property">length</span>;</span><br><span class="line">        <span class="keyword">const</span> visited = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line">        <span class="keyword">let</span> island = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> <span class="title function_">bfs</span> = (<span class="params">r, c</span>) =&gt; &#123;</span><br><span class="line">            <span class="keyword">const</span> queue = [];</span><br><span class="line">            queue.<span class="title function_">push</span>([r, c]);</span><br><span class="line">            visited.<span class="title function_">add</span>(<span class="string">`<span class="subst">$&#123;r&#125;</span>,<span class="subst">$&#123;c&#125;</span>`</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (queue.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">const</span> [row, col] = queue.<span class="title function_">shift</span>();</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">const</span> [dr, dc] <span class="keyword">of</span> [[<span class="number">1</span>, <span class="number">0</span>], [-<span class="number">1</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">1</span>], [<span class="number">0</span>, -<span class="number">1</span>]]) &#123;</span><br><span class="line">                    <span class="keyword">const</span> nr = dr + row;</span><br><span class="line">                    <span class="keyword">const</span> nc = dc + col;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (nr &gt;= <span class="number">0</span> &amp;&amp;</span><br><span class="line">                        nc &gt;= <span class="number">0</span> &amp;&amp;</span><br><span class="line">                        nr &lt; rows &amp;&amp;</span><br><span class="line">                        nc &lt; cols &amp;&amp;</span><br><span class="line">                        grid[nr][nc] === <span class="string">&quot;1&quot;</span> &amp;&amp;</span><br><span class="line">                        !visited.<span class="title function_">has</span>(<span class="string">`<span class="subst">$&#123;nr&#125;</span>,<span class="subst">$&#123;nc&#125;</span>`</span>)</span><br><span class="line">                    ) &#123;</span><br><span class="line">                        queue.<span class="title function_">push</span>([nr, nc]);</span><br><span class="line">                        visited.<span class="title function_">add</span>(<span class="string">`<span class="subst">$&#123;nr&#125;</span>,<span class="subst">$&#123;nc&#125;</span>`</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> r = <span class="number">0</span>; r &lt; rows; r++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> c = <span class="number">0</span>; c &lt; cols; c++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[r][c] === <span class="string">&quot;1&quot;</span> &amp;&amp; !visited.<span class="title function_">has</span>(<span class="string">`<span class="subst">$&#123;r&#125;</span>,<span class="subst">$&#123;c&#125;</span>`</span>)) &#123;</span><br><span class="line">                    island += <span class="number">1</span>;</span><br><span class="line">                    <span class="title function_">bfs</span>(r, c);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> island;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><ul><li>解法<code>2</code>: 深度优先搜索 (<code>DFS</code>)</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 使用递归替代 BFS 的队列逻辑</span><br><span class="line">2. 遍历网格，遇到未访问的陆地时，启动 DFS 遍历整个岛屿</span><br><span class="line">3. 每发现一个新岛屿时，岛屿计数器加一</span><br><span class="line">4. 返回岛屿数量</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">numIslands</span>(<span class="params">self, grid: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        island = <span class="number">0</span></span><br><span class="line">        rows, cols = <span class="built_in">len</span>(grid), <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">r, c</span>):</span><br><span class="line">            <span class="keyword">if</span> r &lt; <span class="number">0</span> <span class="keyword">or</span> c &lt; <span class="number">0</span> <span class="keyword">or</span> r &gt;= rows <span class="keyword">or</span> c &gt;= cols <span class="keyword">or</span> grid[r][c] == <span class="string">&quot;0&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            grid[r][c] = <span class="string">&quot;0&quot;</span> <span class="comment"># 标记为已访问</span></span><br><span class="line">            <span class="comment"># 遍历四个方向</span></span><br><span class="line">            <span class="keyword">for</span> dr, dc <span class="keyword">in</span> [[<span class="number">1</span>, <span class="number">0</span>], [-<span class="number">1</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">1</span>], [<span class="number">0</span>, -<span class="number">1</span>]]:</span><br><span class="line">                dfs(r + dr, c + dc)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> r <span class="keyword">in</span> <span class="built_in">range</span>(rows):</span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">range</span>(cols):</span><br><span class="line">                <span class="keyword">if</span> grid[r][c] == <span class="string">&quot;1&quot;</span>:</span><br><span class="line">                    island += <span class="number">1</span></span><br><span class="line">                    dfs(r, c)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> island</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">numIslands</span>(<span class="params">grid</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> rows = grid.<span class="property">length</span>;</span><br><span class="line">        <span class="keyword">const</span> cols = grid[<span class="number">0</span>].<span class="property">length</span>;</span><br><span class="line">        <span class="keyword">let</span> island = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> <span class="title function_">dfs</span> = (<span class="params">r, c</span>) =&gt; &#123;</span><br><span class="line">            <span class="comment">// 如果超出边界或遇到水域，则停止递归</span></span><br><span class="line">            <span class="keyword">if</span> (r &lt; <span class="number">0</span> || c &lt; <span class="number">0</span> || r &gt;= rows || c &gt;= cols || grid[r][c] === <span class="string">&quot;0&quot;</span>)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">            grid[r][c] = <span class="number">0</span>; <span class="comment">// 标记为已访问</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">const</span> [dr, dc] <span class="keyword">of</span> [[<span class="number">1</span>, <span class="number">0</span>], [-<span class="number">1</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">1</span>], [<span class="number">0</span>, -<span class="number">1</span>]])</span><br><span class="line">                <span class="title function_">dfs</span>(r + dr, c + dc);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> r = <span class="number">0</span>; r &lt; rows; r++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> c = <span class="number">0</span>; c &lt; cols; c++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[r][c] === <span class="string">&quot;1&quot;</span>) &#123;</span><br><span class="line">                    island += <span class="number">1</span>;</span><br><span class="line">                    <span class="title function_">dfs</span>(r, c);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> island;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h3 id="Two-Pointers-双指针"><a href="#Two-Pointers-双指针" class="headerlink" title="Two Pointers 双指针"></a><code>Two Pointers</code> 双指针</h3><h4 id="雨水问题"><a href="#雨水问题" class="headerlink" title="雨水问题"></a>雨水问题</h4><blockquote><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/trapping-rain-water/">Leetcode 42. Trapping Rain Water</a></p></blockquote><ul><li>题目: 给定一个非负整数数组<code>height</code>，表示每个柱子的高度。假设下雨后水只会停留在柱子之间，请计算可以接住的总雨水量</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: height = [0,1,0,2,1,0,1,3,2,1,2,1]</span><br><span class="line">Output: 6</span><br></pre></td></tr></table></figure><ul><li>解法: 双指针</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 使用两个指针分别从数组的左右两端向中间靠拢</span><br><span class="line">2. 在遍历过程中，记录左右两侧的最大高度</span><br><span class="line">3. 计算当前柱子上方的雨水量：</span><br><span class="line">    - 雨水量 = 较低一侧的最大高度 - 当前柱子高度</span><br><span class="line">4. 移动较低一侧的指针，同时更新对应的最大高度</span><br><span class="line">5. 遍历结束时，累加所有雨水量并返回结果</span><br><span class="line"></span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">trap</span>(<span class="params">self, height: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> height:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        left, right = <span class="number">0</span>, <span class="built_in">len</span>(height) - <span class="number">1</span></span><br><span class="line">        <span class="comment"># 初始化左右两边的最大高度</span></span><br><span class="line">        left_max, right_max = height[left], height[right]</span><br><span class="line">        result = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            <span class="comment"># 如果左边的最大高度小于右边的最大高度</span></span><br><span class="line">            <span class="keyword">if</span> left_max &lt; right_max:</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">                <span class="comment"># 更新左边的最大高度</span></span><br><span class="line">                left_max = <span class="built_in">max</span>(left_max, height[left])</span><br><span class="line">                <span class="comment"># 计算当前左指针位置的接水量（左边的最大高度 - 当前柱子的高度）</span></span><br><span class="line">                result += left_max - height[left]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line">                <span class="comment"># 更新右边的最大高度</span></span><br><span class="line">                right_max = <span class="built_in">max</span>(right_max, height[right])</span><br><span class="line">                <span class="comment"># 计算当前右指针位置的接水量（右边的最大高度 - 当前柱子的高度）</span></span><br><span class="line">                result += right_max - height[right]</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">trap</span>(<span class="params">height</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> left = <span class="number">0</span>, right = height.<span class="property">length</span> - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">let</span> leftMax = height[left], rightMax = height[right];</span><br><span class="line">        <span class="keyword">let</span> result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">if</span> (leftMax &lt; rightMax) &#123;</span><br><span class="line">                left++;</span><br><span class="line">                leftMax = <span class="title class_">Math</span>.<span class="title function_">max</span>(leftMax, height[left]); <span class="comment">// 更新左边最大高度</span></span><br><span class="line">                result += leftMax - height[left]; <span class="comment">// 计算左侧接水量</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right--;</span><br><span class="line">                rightMax = <span class="title class_">Math</span>.<span class="title function_">max</span>(rightMax, height[right]); <span class="comment">// 更新右边最大高度</span></span><br><span class="line">                result += rightMax - height[right]; <span class="comment">// 计算右侧接水量</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h4 id="盛水问题"><a href="#盛水问题" class="headerlink" title="盛水问题"></a>盛水问题</h4><blockquote><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/container-with-most-water/">Leetcode 11. Container With Most Water</a></p></blockquote><ul><li>题目: 给定一个数组<code>height</code>，其中每个元素表示一个竖线的高度，竖线在横轴上的间隔为<code>1</code>。找到两根竖线之间形成的容器能够盛水的最大面积</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: height = [1,8,6,2,5,4,8,3,7]</span><br><span class="line">Output: 49</span><br></pre></td></tr></table></figure><ul><li>解法: 双指针</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 初始化左右指针，分别指向数组的两端</span><br><span class="line">2. 每次计算由左右指针对应的竖线形成的容器面积，更新最大面积</span><br><span class="line">3. 移动较短竖线的一侧指针，尝试找到更大的容器</span><br><span class="line">4. 重复上述步骤，直到左右指针相遇</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxArea</span>(<span class="params">self, height: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        left, right = <span class="number">0</span>, <span class="built_in">len</span>(height) - <span class="number">1</span></span><br><span class="line">        result = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            <span class="comment"># 计算当前容器的面积</span></span><br><span class="line">            width = right - left</span><br><span class="line">            area = <span class="built_in">min</span>(height[left], height[right]) * width</span><br><span class="line">            <span class="comment"># 更新最大面积</span></span><br><span class="line">            result = <span class="built_in">max</span>(result, area)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 移动较短边对应的指针，尝试找到更大的容器</span></span><br><span class="line">            <span class="keyword">if</span> height[left] &lt; height[right]:</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">maxArea</span>(<span class="params">height</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> left = <span class="number">0</span>, right = height.<span class="property">length</span> - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">let</span> maxArea = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="comment">// 计算当前容器的面积</span></span><br><span class="line">            <span class="keyword">const</span> width = right - left;</span><br><span class="line">            <span class="keyword">const</span> area = <span class="title class_">Math</span>.<span class="title function_">min</span>(height[left], height[right]) * width;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 更新最大面积</span></span><br><span class="line">            maxArea = <span class="title class_">Math</span>.<span class="title function_">max</span>(maxArea, area);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 移动较短边对应的指针</span></span><br><span class="line">            <span class="keyword">if</span> (height[left] &lt; height[right])</span><br><span class="line">                left++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                right--;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> maxArea;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h4 id="一维数组去重"><a href="#一维数组去重" class="headerlink" title="一维数组去重"></a>一维数组去重</h4><blockquote><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/remove-duplicates-from-sorted-array/">Leetcode 26. Remove Duplicates from Sorted Array</a></p></blockquote><ul><li>题目: 有序数组<code>nums</code>，需要原地移除重复项，使每个元素最多出现一次</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: nums = [0,0,1,1,1,2,2,3,3,4]</span><br><span class="line">Output: 5, nums = [0,1,2,3,4,_,_,_,_,_]</span><br></pre></td></tr></table></figure><ul><li>解法: 双指针</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 定义 i 指针跟踪去重后数组的最后一个位置</span><br><span class="line">2. 使用 j 指针遍历数组，寻找不重复的元素</span><br><span class="line">3. 遇到新元素时，将其放在 i+1 位置，并更新 i</span><br><span class="line">4. 返回去重后数组的长度 i+1</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeDuplicates</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        i = <span class="number">0</span> <span class="comment"># 跟踪去重后数组的最后一个位置</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[j] != nums[i]: <span class="comment"># 如果发现新的元素</span></span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">                nums[i] = nums[j] <span class="comment"># 将 nums[j] 移动到去重后的数组中</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> i + <span class="number">1</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">removeDuplicates</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="property">length</span> === <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>; j &lt; nums.<span class="property">length</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[j] !== nums[i]) &#123; <span class="comment">// 遇到新元素</span></span><br><span class="line">                i++;</span><br><span class="line">                nums[i] = nums[j]; <span class="comment">// 更新数组</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h4 id="最接近的三数之和"><a href="#最接近的三数之和" class="headerlink" title="最接近的三数之和"></a>最接近的三数之和</h4><blockquote><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/3sum-closest/">Leetcode 16. 3Sum Closest</a></p></blockquote><ul><li>题目: 给定一个长度为<code>n</code>的整数数组<code>nums</code>和一个目标值<code>target</code>，找到数组中三个数的和，使其最接近目标值。返回这个和</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: nums = [-1,2,1,-4], target = 1</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: The sum that is closest to the target is 2. (-1 + 2 + 1 = 2)</span><br></pre></td></tr></table></figure><ul><li>解法: 排序 + 双指针</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 首先对数组进行排序</span><br><span class="line">2. 遍历数组，固定一个数 nums[i]，用双指针从 i+1 和数组末尾出发寻找最接近的三数之和</span><br><span class="line">3. 如果当前三数之和比记录的更接近目标值，更新结果</span><br><span class="line">4. 根据当前和与目标值的大小关系移动左右指针</span><br><span class="line">5. 返回最接近的三数之和</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">threeSumClosest</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        nums.sort() <span class="comment"># 排序</span></span><br><span class="line">        result = <span class="built_in">float</span>(<span class="string">&quot;inf&quot;</span>) <span class="comment"># 初始化最接近的结果</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums) - <span class="number">2</span>):</span><br><span class="line">            left, right = i + <span class="number">1</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> left &lt; right:</span><br><span class="line">                curr_sum = nums[i] + nums[left] + nums[right]</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 更新最接近的结果</span></span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">abs</span>(curr_sum - target) &lt; <span class="built_in">abs</span>(result - target):</span><br><span class="line">                    result = curr_sum</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 根据当前和与目标值的关系调整指针</span></span><br><span class="line">                <span class="keyword">if</span> curr_sum &lt; target:</span><br><span class="line">                    left += <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> curr_sum &gt; target:</span><br><span class="line">                    right -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> curr_sum <span class="comment"># 当前和等于目标值时直接返回</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">threeSumClosest</span>(<span class="params">nums, target</span>) &#123;</span><br><span class="line">        nums.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b); <span class="comment">// 排序</span></span><br><span class="line">        <span class="keyword">let</span> result = <span class="title class_">Infinity</span>; <span class="comment">// 初始化最接近的结果</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.<span class="property">length</span> - <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">let</span> left = i + <span class="number">1</span>, right = nums.<span class="property">length</span> - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">                <span class="keyword">let</span> currSum = nums[i] + nums[left] + nums[right];</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 更新最接近的结果</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="title class_">Math</span>.<span class="title function_">abs</span>(currSum - target) &lt; <span class="title class_">Math</span>.<span class="title function_">abs</span>(result - target))</span><br><span class="line">                    result = currSum;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 根据当前和与目标值的关系调整指针</span></span><br><span class="line">                <span class="keyword">if</span> (currSum &lt; target)</span><br><span class="line">                    left++;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (currSum &gt; target)</span><br><span class="line">                    right--;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">return</span> currSum; <span class="comment">// 当前和等于目标值时直接返回</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h4 id="三数之和"><a href="#三数之和" class="headerlink" title="三数之和"></a>三数之和</h4><blockquote><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/3sum/">Leetcode 15. 3Sum</a></p></blockquote><ul><li>题目: 给定一个包含整数的数组<code>nums</code>，返回所有不重复的三元组<code>[nums[i], nums[j], nums[k]]</code>，使得<code>nums[i] + nums[j] + nums[k] == 0</code>。答案中不能包含重复的三元组</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: nums = [-1, 0, 1, 2, -1, -4]</span><br><span class="line">Output: [[-1, -1, 2], [-1, 0, 1]]</span><br><span class="line">Explanation: </span><br><span class="line">nums[0] + nums[1] + nums[3] = -1 + -1 + 2 = 0</span><br><span class="line">nums[0] + nums[2] + nums[4] = -1 + 0 + 1 = 0</span><br></pre></td></tr></table></figure><ul><li>解法: 排序 + 双指针</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 对数组进行排序，便于去重和使用双指针</span><br><span class="line">2. 遍历数组，固定一个数 nums[i]，然后用双指针从 i+1 和数组末尾出发，寻找和为 -nums[i] 的另外两个数</span><br><span class="line">3. 如果找到和为 0 的三元组，将其加入结果集中，同时移动指针跳过重复值</span><br><span class="line">4. 如果当前和小于 0，左指针右移；如果当前和大于 0，右指针左移</span><br><span class="line">5. 遍历结束返回结果</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">threeSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        nums.sort() <span class="comment"># 对数组进行排序，方便后续去重和双指针处理</span></span><br><span class="line">        result = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums) - <span class="number">2</span>):</span><br><span class="line">            <span class="comment"># 如果当前数和前一个数相同，跳过，避免重复三元组</span></span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i - <span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            left, right = i + <span class="number">1</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> left &lt; right:</span><br><span class="line">                total = nums[i] + nums[left] + nums[right] <span class="comment"># 计算当前三数之和</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> total == <span class="number">0</span>:</span><br><span class="line">                    result.append([nums[i], nums[left], nums[right]])</span><br><span class="line"></span><br><span class="line">                    <span class="comment"># 跳过重复的左指针和右指针值</span></span><br><span class="line">                    <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> nums[left] == nums[left + <span class="number">1</span>]:</span><br><span class="line">                        left += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> nums[right] == nums[right - <span class="number">1</span>]:</span><br><span class="line">                        right -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment"># 移动指针</span></span><br><span class="line">                    left += <span class="number">1</span></span><br><span class="line">                    right -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> total &lt; <span class="number">0</span>: <span class="comment"># 如果当前和小于 0，增加左指针</span></span><br><span class="line">                    left += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>: <span class="comment"># 如果当前和大于 0，减少右指针</span></span><br><span class="line">                    right -= <span class="number">1</span> </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">threeSum</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">        nums.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b); <span class="comment">// 对数组进行排序</span></span><br><span class="line">        <span class="keyword">const</span> result = [];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.<span class="property">length</span> - <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 如果当前数和前一个数相同，跳过，避免重复三元组</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] === nums[i - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">let</span> left = i + <span class="number">1</span>, right = nums.<span class="property">length</span> - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">                <span class="keyword">const</span> total = nums[i] + nums[left] + nums[right];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (total === <span class="number">0</span>) &#123;</span><br><span class="line">                    result.<span class="title function_">push</span>([nums[i], nums[left], nums[right]]);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 跳过重复的左指针和右指针值</span></span><br><span class="line">                    <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[left] === nums[left + <span class="number">1</span>]) left++;</span><br><span class="line">                    <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[right] === nums[right - <span class="number">1</span>]) right--;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 移动指针</span></span><br><span class="line">                    left++;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (total &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    left++; <span class="comment">// 如果当前和小于 0，增加左指针</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    right--;  如果当前和大于 <span class="number">0</span>，减少右指针</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h4 id="四数之和"><a href="#四数之和" class="headerlink" title="四数之和"></a>四数之和</h4><blockquote><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/4sum/">Leetcode 18. 4Sum</a></p></blockquote><ul><li>题目: 给定一个由整数数组<code>nums</code>和一个目标值<code>target</code>，找出所有不重复的四元组<code>[nums[a], nums[b], nums[c], nums[d]]</code>，使得<code>nums[a] + nums[b] + nums[c] + nums[d] == target</code></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: nums = [1,0,-1,0,-2,2], target = 0</span><br><span class="line">Output: [[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]</span><br><span class="line">Explanation: The solution sets are unique and order does not matter</span><br></pre></td></tr></table></figure><ul><li>解法: 排序 + 双指针 + 多层遍历</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 对数组进行排序，以便后续去重和使用双指针</span><br><span class="line">2. 先固定两个数 nums[i] 和 nums[j]，然后使用双指针寻找剩下两个数，使得四数之和等于 target</span><br><span class="line">3. 遍历过程中跳过重复的数值，避免结果中出现重复的四元组</span><br><span class="line">4. 返回所有符合条件的四元组</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fourSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        nums.sort() <span class="comment"># 排序</span></span><br><span class="line">        result = []</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums) - <span class="number">3</span>):</span><br><span class="line">            <span class="comment"># 跳过重复的第一个数</span></span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i - <span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i + <span class="number">1</span>, <span class="built_in">len</span>(nums) - <span class="number">2</span>):</span><br><span class="line">                <span class="comment"># 跳过重复的第二个数</span></span><br><span class="line">                <span class="keyword">if</span> j &gt; i + <span class="number">1</span> <span class="keyword">and</span> nums[j] == nums[j - <span class="number">1</span>]:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                </span><br><span class="line">                left, right = j + <span class="number">1</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> left &lt; right:</span><br><span class="line">                    total = nums[i] + nums[j] + nums[left] + nums[right]</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> total == target:</span><br><span class="line">                        result.append([nums[i], nums[j], nums[left], nums[right]])</span><br><span class="line"></span><br><span class="line">                        <span class="comment"># 跳过重复的左指针和右指针值</span></span><br><span class="line">                        <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> nums[left] == nums[left + <span class="number">1</span>]:</span><br><span class="line">                            left += <span class="number">1</span></span><br><span class="line">                        <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> nums[right] == nums[right - <span class="number">1</span>]:</span><br><span class="line">                            right -= <span class="number">1</span></span><br><span class="line">                        </span><br><span class="line">                        <span class="comment"># 移动指针</span></span><br><span class="line">                        left += <span class="number">1</span></span><br><span class="line">                        right -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">elif</span> total &lt; target:</span><br><span class="line">                        left += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        right -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">fourSum</span>(<span class="params">nums, target</span>) &#123;</span><br><span class="line">        nums.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b); <span class="comment">// 排序</span></span><br><span class="line">        <span class="keyword">const</span> result = [];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.<span class="property">length</span> - <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 跳过重复的第一个数</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] === nums[i - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; nums.<span class="property">length</span> - <span class="number">2</span>; j++) &#123;</span><br><span class="line">                <span class="comment">// 跳过重复的第二个数</span></span><br><span class="line">                <span class="keyword">if</span> (j &gt; i + <span class="number">1</span> &amp;&amp; nums[j] === nums[j - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">let</span> left = j + <span class="number">1</span>, right = nums.<span class="property">length</span> - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">                    <span class="keyword">const</span> total = nums[i] + nums[j] + nums[left] + nums[right];</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (total === target) &#123;</span><br><span class="line">                        result.<span class="title function_">push</span>([nums[i], nums[j], nums[left], nums[right]]);</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 跳过重复的左指针和右指针值</span></span><br><span class="line">                        <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[left] === nums[left + <span class="number">1</span>]) left++;</span><br><span class="line">                        <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[right] === nums[right - <span class="number">1</span>]) right--;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 移动指针</span></span><br><span class="line">                        left++;</span><br><span class="line">                        right--;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (total &lt; target) &#123;</span><br><span class="line">                        left++;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        right--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h4 id="找出数组中的重复数字"><a href="#找出数组中的重复数字" class="headerlink" title="找出数组中的重复数字"></a>找出数组中的重复数字</h4><blockquote><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/find-the-duplicate-number/">Leetcode 287. Find the Duplicate Number</a></p></blockquote><ul><li>题目: 给定一个包含<code>n + 1</code>个整数的数组 nums，其中每个整数都在范围 [1, n] 内，且只有一个重复的数字。找出该重复的数字。注意：不能修改数组内容，并且仅使用常数级别的额外空间</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: nums = [3,1,3,4,2]</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure><ul><li>解法: 快慢指针（<code>Floyd</code>判圈算法）</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 将数组看作链表，nums[i] 指向下一个节点</span><br><span class="line">2. 使用快慢指针找到环的位置：慢指针一次走一步，快指针一次走两步</span><br><span class="line">3. 在环中找到入口，也就是重复的数字</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findDuplicate</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 使用快慢指针</span></span><br><span class="line">        slow, fast = nums[<span class="number">0</span>], nums[nums[<span class="number">0</span>]]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 阶段 1：找到快慢指针相遇点</span></span><br><span class="line">        <span class="keyword">while</span> slow != fast:</span><br><span class="line">            slow = nums[slow]</span><br><span class="line">            fast = nums[nums[fast]]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 阶段 2：找到环的入口，即重复的数字</span></span><br><span class="line">        slow = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> slow != fast:</span><br><span class="line">            slow = nums[slow]</span><br><span class="line">            fast = nums[fast]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> slow</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">findDuplicate</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> slow = nums[<span class="number">0</span>], fast = nums[nums[<span class="number">0</span>]];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 阶段 1：找到快慢指针相遇点</span></span><br><span class="line">        <span class="keyword">while</span> (slow !== fast) &#123;</span><br><span class="line">            slow = nums[slow];</span><br><span class="line">            fast = nums[nums[fast]];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 阶段 2：找到环的入口，即重复的数字</span></span><br><span class="line">        slow = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (slow !== fast) &#123;</span><br><span class="line">            slow = nums[slow];</span><br><span class="line">            fast = nums[fast];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h3 id="Binary-Search"><a href="#Binary-Search" class="headerlink" title="Binary Search"></a><code>Binary Search</code></h3><h4 id="最长递增子序列"><a href="#最长递增子序列" class="headerlink" title="最长递增子序列"></a>最长递增子序列</h4><blockquote><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/longest-increasing-subsequence/">Leetcode 300. Longest Increasing Subsequence</a></p></blockquote><ul><li>题目: 给定一个整数数组<code>nums</code>，找到其中最长严格递增子序列的长度</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: nums = [10,9,2,5,3,7,101,18]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4</span><br></pre></td></tr></table></figure><ul><li>解法: 动态规划 + 二分法优化</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 动态规划：</span><br><span class="line">   定义 dp[i] 表示以 nums[i] 为结尾的最长递增子序列的长度</span><br><span class="line">   状态转移方程：dp[i] = max(dp[i], dp[j] + 1) for all j &lt; i and nums[j] &lt; nums[i]</span><br><span class="line">   时间复杂度为 O(n^2)</span><br><span class="line"></span><br><span class="line">2. 二分法优化：</span><br><span class="line">   维护一个数组 tails，其中 tails[i] 表示长度为 i+1 的递增子序列的末尾最小值</span><br><span class="line">   对每个 nums 中的元素使用二分法更新 tails</span><br><span class="line">   时间复杂度为 O(n log n)</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lengthOfLIS</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 用于存储不同长度递增子序列的最小末尾值</span></span><br><span class="line">        tails = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="comment"># 二分查找，寻找第一个大于等于 num 的位置</span></span><br><span class="line">            left, right = <span class="number">0</span>, <span class="built_in">len</span>(tails)</span><br><span class="line">            <span class="keyword">while</span> left &lt; right:</span><br><span class="line">                mid = (left + right) // <span class="number">2</span></span><br><span class="line">                <span class="keyword">if</span> tails[mid] &lt; num:</span><br><span class="line">                    left = mid + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    right = mid</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 如果 left 等于 tails 长度，说明 num 是一个新的最大值</span></span><br><span class="line">            <span class="keyword">if</span> left == <span class="built_in">len</span>(tails):</span><br><span class="line">                tails.append(num)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                tails[left] = num</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(tails)</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">lengthOfLIS</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> tails = [];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> num <span class="keyword">of</span> nums) &#123;</span><br><span class="line">            <span class="comment">// 找到第一个大于等于 num 的位置</span></span><br><span class="line">            <span class="keyword">let</span> left = <span class="number">0</span>, right = tails.<span class="property">length</span>;</span><br><span class="line">            <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">                <span class="keyword">const</span> mid = <span class="title class_">Math</span>.<span class="title function_">floor</span>((left + right) / <span class="number">2</span>);</span><br><span class="line">                <span class="keyword">if</span> (tails[mid] &lt; num)</span><br><span class="line">                    left = mid + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    right = mid;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (left === tails.<span class="property">length</span>)</span><br><span class="line">                <span class="comment">// 如果 num 比 tails 中的所有值都大，直接添加到末尾</span></span><br><span class="line">                tails.<span class="title function_">push</span>(num);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="comment">// 否则替换位置 left 的值，保持更小的末尾</span></span><br><span class="line">                tails[left] = num;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> tails.<span class="property">length</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h3 id="Tree-树与二叉树"><a href="#Tree-树与二叉树" class="headerlink" title="Tree 树与二叉树"></a><code>Tree</code> 树与二叉树</h3><h4 id="二叉树层序遍历"><a href="#二叉树层序遍历" class="headerlink" title="二叉树层序遍历"></a>二叉树层序遍历</h4><ul><li>实现二叉树的层序遍历（广度优先遍历，<code>BFS</code>）</li><li>从二叉树的根节点开始，按层级顺序逐层访问节点，每层从左到右</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    3  </span><br><span class="line">   / \</span><br><span class="line">  9   20</span><br><span class="line">     /  \</span><br><span class="line">    15   7</span><br><span class="line"></span><br><span class="line">输出: </span><br><span class="line">[</span><br><span class="line">    [3],</span><br><span class="line">    [9, 20],</span><br><span class="line">    [15, 7]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><ul><li>解法: 队列实现<code>BFS</code></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 使用 deque 实现队列，初始包含根节点</span><br><span class="line">2. 遍历每一层：</span><br><span class="line">    - 记录当前层的节点数量（level_size）</span><br><span class="line">    - 弹出队首节点，存储值到当前层结果</span><br><span class="line">    - 将左右子节点加入队列</span><br><span class="line">3. 每层遍历结束后，将当前层结果加入最终结果</span><br><span class="line">4. 队列为空时，遍历完成</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, val=<span class="number">0</span>, left=<span class="literal">None</span>, right=<span class="literal">None</span></span>):</span><br><span class="line">        self.val = val</span><br><span class="line">        self.left = left</span><br><span class="line">        self.right = right</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">levelOrder</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="built_in">list</span>[<span class="built_in">list</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">        queue = deque([root]) <span class="comment"># 初始化队列，包含根节点</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            level_size = <span class="built_in">len</span>(queue) <span class="comment"># 当前层的节点数</span></span><br><span class="line">            current_level = [] <span class="comment"># 用于存储当前层的节点值</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(level_size):</span><br><span class="line">                node = queue.popleft() <span class="comment"># 弹出队首节点</span></span><br><span class="line">                current_level.append(node.val) <span class="comment"># 添加节点值到当前层</span></span><br><span class="line"></span><br><span class="line">                <span class="comment"># 将左右子节点加入队列</span></span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    queue.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    queue.append(node.right)</span><br><span class="line"></span><br><span class="line">            result.append(current_level) <span class="comment"># 将当前层加入结果</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result       </span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">val = <span class="number">0</span>, left = <span class="literal">null</span>, right = <span class="literal">null</span></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">val</span> = val;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">left</span> = left;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">right</span> = right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">levelOrder</span>(<span class="params">root</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> result = [];</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> queue = [root]; <span class="comment">// 初始化队列，包含根节点</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (queue.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> levelSize = queue.<span class="property">length</span>; <span class="comment">// 当前层的节点数</span></span><br><span class="line">            <span class="keyword">const</span> currentLevel = []; <span class="comment">// 用于存储当前层的节点值</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; levelSize; i++) &#123;</span><br><span class="line">                <span class="keyword">const</span> node = queue.<span class="title function_">shift</span>(); <span class="comment">// 弹出队首节点</span></span><br><span class="line">                currentLevel.<span class="title function_">push</span>(node.<span class="property">val</span>); <span class="comment">// 添加节点值到当前层</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 将左右子节点加入队列</span></span><br><span class="line">                <span class="keyword">if</span> (node.<span class="property">left</span>) queue.<span class="title function_">push</span>(node.<span class="property">left</span>);</span><br><span class="line">                <span class="keyword">if</span> (node.<span class="property">right</span>) queue.<span class="title function_">push</span>(node.<span class="property">right</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            result.<span class="title function_">push</span>(currentLevel);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h4 id="树每层的最大值"><a href="#树每层的最大值" class="headerlink" title="树每层的最大值"></a>树每层的最大值</h4><blockquote><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/find-largest-value-in-each-tree-row/">Leetcode 515. Find Largest Value in Each Tree Row</a></p></blockquote><ul><li>题目: 给定一个二叉树，按层遍历树，返回每一行中的最大值</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">      1</span><br><span class="line">     / \</span><br><span class="line">    3   2</span><br><span class="line">   / \    \</span><br><span class="line">  5   3    9</span><br><span class="line"></span><br><span class="line">Output: [1,3,9]</span><br></pre></td></tr></table></figure><ul><li>解法: 广度优先搜索<code>BFS</code></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 使用队列（deque）进行层序遍历（BFS）</span><br><span class="line">2. 遍历每一层时，找出该层节点值的最大值</span><br><span class="line">3. 将每层的最大值添加到结果列表中</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">largestValues</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        </span><br><span class="line">        result = []</span><br><span class="line">        queue = deque([root])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            level_size = <span class="built_in">len</span>(queue)</span><br><span class="line">            max_val = <span class="built_in">float</span>(<span class="string">&quot;-inf&quot;</span>) <span class="comment"># 初始化每层最大值</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(level_size):</span><br><span class="line">                node = queue.popleft() <span class="comment"># 弹出当前层的节点</span></span><br><span class="line">                max_val = <span class="built_in">max</span>(max_val, node.val) <span class="comment"># 更新最大值</span></span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    queue.append(node.left) <span class="comment"># 加入左子节点</span></span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    queue.append(node.right) <span class="comment"># 加入右子节点</span></span><br><span class="line">            </span><br><span class="line">            result.append(max_val) <span class="comment"># 保存每层最大值</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">largestValues</span>(<span class="params">root</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> [];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> result = [];</span><br><span class="line">        <span class="keyword">const</span> queue = [root];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (queue.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> levelSize = queue.<span class="property">length</span>;</span><br><span class="line">            <span class="keyword">let</span> maxVal = -<span class="title class_">Infinity</span>; <span class="comment">// 初始化每层最大值</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; levelSize; i++) &#123;</span><br><span class="line">                <span class="keyword">const</span> node = queue.<span class="title function_">shift</span>(); <span class="comment">// 弹出当前层的节点</span></span><br><span class="line">                maxVal = <span class="title class_">Math</span>.<span class="title function_">max</span>(maxVal, node.<span class="property">val</span>); <span class="comment">// 更新最大值</span></span><br><span class="line">                <span class="keyword">if</span> (node.<span class="property">left</span>) queue.<span class="title function_">push</span>(node.<span class="property">left</span>); <span class="comment">// 加入左子节点</span></span><br><span class="line">                <span class="keyword">if</span> (node.<span class="property">right</span>) queue.<span class="title function_">push</span>(node.<span class="property">right</span>); <span class="comment">// 加入右子节点</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            result.<span class="title function_">push</span>(maxVal); <span class="comment">// 保存每层最大值</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h4 id="验证二叉搜索树"><a href="#验证二叉搜索树" class="headerlink" title="验证二叉搜索树"></a>验证二叉搜索树</h4><blockquote><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/validate-binary-search-tree/">Leetcode 98. Validate Binary Search Tree</a></p></blockquote><ul><li>题目: 验证一棵二叉树是否为二叉搜索树（<code>BST</code>）</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">二叉搜索树的性质:</span><br><span class="line">1. 节点的左子树只包含比当前节点值小的节点</span><br><span class="line">2. 节点的右子树只包含比当前节点值大的节点</span><br><span class="line">3. 左右子树也必须是二叉搜索树</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: root = [2,1,3]</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><ul><li>解法: 递归验证上下界</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 使用递归检查每个节点的值是否满足二叉搜索树的性质:</span><br><span class="line">   节点的值应在一个范围内 `(low, high)`</span><br><span class="line">2. 初始范围是 `(-inf, inf)`</span><br><span class="line">3. 左子树的值范围: `(low, node.val)`</span><br><span class="line">   右子树的值范围: `(node.val, high)`</span><br><span class="line">4. 递归检查子树是否满足条件</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isValidBST</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="comment"># 递归函数，检查节点是否在 (low, high) 范围内</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">validate</span>(<span class="params">node, low, high</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node: <span class="comment"># 空节点是合法的</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="comment"># 当前节点值必须在范围内</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> (low &lt; node.val &lt; high):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">return</span> validate(node.left, low, node.val) <span class="keyword">and</span> validate(node.right, node.val, high)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 初始范围为 (-inf, inf)</span></span><br><span class="line">        <span class="keyword">return</span> validate(root, <span class="built_in">float</span>(<span class="string">&quot;-inf&quot;</span>), <span class="built_in">float</span>(<span class="string">&quot;inf&quot;</span>))</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">isValidBST</span>(<span class="params">root</span>) &#123;</span><br><span class="line">        <span class="keyword">function</span> <span class="title function_">validate</span>(<span class="params">node, low, high</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!node) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 空节点合法</span></span><br><span class="line">            <span class="keyword">if</span> (node.<span class="property">val</span> &lt;= low || node.<span class="property">val</span> &gt;= high) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 不在范围内</span></span><br><span class="line">            <span class="comment">// 检查左右子树</span></span><br><span class="line">            <span class="keyword">return</span> <span class="title function_">validate</span>(node.<span class="property">left</span>, low, node.<span class="property">val</span>) &amp;&amp; <span class="title function_">validate</span>(node.<span class="property">right</span>, node.<span class="property">val</span>, high);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始范围 (-Infinity, Infinity)</span></span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">validate</span>(root, -<span class="title class_">Infinity</span>, <span class="title class_">Infinity</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h4 id="二叉树最大差值"><a href="#二叉树最大差值" class="headerlink" title="二叉树最大差值"></a>二叉树最大差值</h4><blockquote><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/maximum-difference-between-node-and-ancestor/">Leetcode 1026. Maximum Difference Between Node and Ancestor</a></p></blockquote><ul><li>题目: 找到二叉树中任意节点与其祖先节点值之间的最大差值<ul><li>祖先节点: 从根节点到当前节点路径上的任意节点</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: root = [8,3,10,1,6,null,14,null,null,4,7,13]</span><br><span class="line">Output: 7</span><br><span class="line"></span><br><span class="line">差值最大的一对节点是: 8 和 1，差值为 7</span><br></pre></td></tr></table></figure><ul><li>解法: 深度优先搜索（<code>DFS</code>）</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 使用递归（DFS）遍历二叉树</span><br><span class="line">2. 在递归过程中维护当前路径上的最小值和最大值</span><br><span class="line">3. 每到一个节点</span><br><span class="line">    - 更新路径的最小值和最大值</span><br><span class="line">    - 计算当前节点值与路径最小值或最大值的差值</span><br><span class="line">4. 遍历整棵树，返回最大差值</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxAncestorDiff</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">maxDiff</span>(<span class="params">node, curr_min, curr_max</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node: <span class="comment"># 如果节点为空，返回当前差值</span></span><br><span class="line">                <span class="keyword">return</span> curr_max - curr_min</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 更新当前路径的最小值和最大值</span></span><br><span class="line">            curr_min = <span class="built_in">min</span>(curr_min, node.val)</span><br><span class="line">            curr_max = <span class="built_in">max</span>(curr_max, node.val)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 递归左子树和右子树，计算最大差值</span></span><br><span class="line">            left_diff = maxDiff(node.left, curr_min, curr_max)</span><br><span class="line">            right_diff = maxDiff(node.right, curr_min, curr_max)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 返回左右子树中差值的最大值</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">max</span>(left_diff, right_diff)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 从根节点开始，初始最小值和最大值为根节点的值</span></span><br><span class="line">        <span class="keyword">return</span> maxDiff(root, root.val, root.val)</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">maxAncestorDiff</span>(<span class="params">root</span>) &#123;</span><br><span class="line">        <span class="keyword">function</span> <span class="title function_">maxDiff</span>(<span class="params">node, currMin, currMax</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!node) <span class="keyword">return</span> currMax - currMin; <span class="comment">// 返回当前差值</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 更新路径中的最小值和最大值</span></span><br><span class="line">            currMin = <span class="title class_">Math</span>.<span class="title function_">min</span>(currMin, node.<span class="property">val</span>);</span><br><span class="line">            currMax = <span class="title class_">Math</span>.<span class="title function_">max</span>(currMax, node.<span class="property">val</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 递归左右子树，计算最大差值</span></span><br><span class="line">            <span class="keyword">const</span> leftDiff = <span class="title function_">maxDiff</span>(node.<span class="property">left</span>, currMin, currMax);</span><br><span class="line">            <span class="keyword">const</span> rightDiff = <span class="title function_">maxDiff</span>(node.<span class="property">right</span>, currMin, currMax);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 返回左右子树中差值的最大值</span></span><br><span class="line">            <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">max</span>(leftDiff, rightDiff);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始最小值和最大值为根节点的值</span></span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">maxDiff</span>(root, root.<span class="property">val</span>, root.<span class="property">val</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h4 id="不同二叉搜索树的数量"><a href="#不同二叉搜索树的数量" class="headerlink" title="不同二叉搜索树的数量"></a>不同二叉搜索树的数量</h4><blockquote><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/unique-binary-search-trees/">Leetcode 96. Unique Binary Search Trees</a></p></blockquote><ul><li>题目: 给定一个整数<code>n</code>，表示从<code>1</code>到<code>n</code>的节点，计算可以形成的不同二叉搜索树（<code>BST</code>）的数量</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: n = 3</span><br><span class="line">Output: 5</span><br><span class="line"></span><br><span class="line">   1         3     3      2      1</span><br><span class="line">    \       /     /      / \      \</span><br><span class="line">     3     2     1      1   3      2</span><br><span class="line">    /     /       \                 \</span><br><span class="line">   2     1         2                 3</span><br></pre></td></tr></table></figure><ul><li>解法: 动态规划 (卡特兰数公式)</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 定义 G[i] 表示由 i 个节点可以构成的不同二叉搜索树的数量</span><br><span class="line">2. 初始条件</span><br><span class="line">    - G[0] = 1（空树有 1 种情况）</span><br><span class="line">    - G[1] = 1（只有一个节点也只有 1 种情况）</span><br><span class="line">3. 递推公式</span><br><span class="line">    - G[i] = Σ G[j-1] * G[i-j]</span><br><span class="line">    - 即选择第 j 个节点为根时</span><br><span class="line">        - 左子树有 j-1 个节点，数量为 G[j-1]</span><br><span class="line">        - 右子树有 i-j 个节点，数量为 G[i-j]</span><br><span class="line">    - 对所有可能的根节点 j 求和</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">numTrees</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># G[i] 表示 i 个节点的不同二叉搜索树数量</span></span><br><span class="line">        G = [<span class="number">0</span>] * (n + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 初始条件</span></span><br><span class="line">        G[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        G[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 动态规划计算 G[2] 到 G[n]</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, i + <span class="number">1</span>):</span><br><span class="line">                G[i] += G[j - <span class="number">1</span>] * G[i - j]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> G[n]</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">numTrees</span>(<span class="params">n</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> G = <span class="keyword">new</span> <span class="title class_">Array</span>(n + <span class="number">1</span>).<span class="title function_">fill</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始条件</span></span><br><span class="line">        G[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        G[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 动态规划计算 G[2] 到 G[n]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>; j &lt;= i; j++) &#123;</span><br><span class="line">                G[i] += G[j - <span class="number">1</span>] * G[i - j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> G[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h4 id="检查二叉树是否平衡"><a href="#检查二叉树是否平衡" class="headerlink" title="检查二叉树是否平衡"></a>检查二叉树是否平衡</h4><blockquote><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/balanced-binary-tree/">Leetcode 110. Balanced Binary Tree</a></p></blockquote><ul><li>题目: 给定一个二叉树，判断它是否是高度平衡的<ul><li>平衡二叉树的定义是: 二叉树的任意节点的左右子树高度差不超过<code>1</code></li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: root = [3,9,20,null,null,15,7]</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><ul><li>解法: 深度优先搜索 (<code>DFS</code>)</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 使用递归函数 dfs(node)</span><br><span class="line">   - 如果节点为空，返回平衡状态 True 和高度 0</span><br><span class="line">   - 递归检查左右子树，计算它们的平衡状态和高度</span><br><span class="line">2. 当前节点是否平衡</span><br><span class="line">   - 左右子树都平衡</span><br><span class="line">   - 左右子树高度差不超过 1</span><br><span class="line">3. 返回当前节点的平衡状态和高度</span><br><span class="line">4. 检查根节点的平衡状态</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isBalanced</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">node</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span>, <span class="number">0</span> <span class="comment"># [是否平衡, 高度]</span></span><br><span class="line">            </span><br><span class="line">            left_balanced, left_height = dfs(node.left)</span><br><span class="line">            right_balanced, right_height = dfs(node.right)</span><br><span class="line"></span><br><span class="line">            balanced = left_balanced <span class="keyword">and</span> right_balanced <span class="keyword">and</span> <span class="built_in">abs</span>(left_height - right_height) &lt;= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            height = <span class="built_in">max</span>(left_height, right_height) + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> balanced, height</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dfs(root)[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">isBalanced</span>(<span class="params">root</span>) &#123;</span><br><span class="line">        <span class="keyword">function</span> <span class="title function_">dfs</span>(<span class="params">node</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!node) <span class="keyword">return</span> [<span class="literal">true</span>, <span class="number">0</span>]; <span class="comment">// [是否平衡, 高度]</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">const</span> [leftBalanced, leftHeight] = <span class="title function_">dfs</span>(node.<span class="property">left</span>);</span><br><span class="line">            <span class="keyword">const</span> [rightBalanced, rightHeight] = <span class="title function_">dfs</span>(node.<span class="property">right</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> balanced = leftBalanced &amp;&amp; rightBalanced &amp;&amp; <span class="title class_">Math</span>.<span class="title function_">abs</span>(leftHeight - rightHeight) &lt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> height = <span class="title class_">Math</span>.<span class="title function_">max</span>(leftHeight, rightHeight) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> [balanced, height];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">dfs</span>(root)[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h4 id="二叉搜索树第k小的节点"><a href="#二叉搜索树第k小的节点" class="headerlink" title="二叉搜索树第k小的节点"></a>二叉搜索树第<code>k</code>小的节点</h4><blockquote><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/kth-smallest-element-in-a-bst/">Leetcode 230. Kth Smallest Element in a BST</a></p></blockquote><ul><li>题目: 给定一棵二叉搜索树的根节点<code>root</code>，以及一个整数<code>k</code>，请返回该二叉搜索树中第<code>k</code>小的节点值</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: root = [3,1,4,null,2], k = 1</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure><ul><li>解法: 中序遍历 (<code>In-order Traversal</code>)</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 中序遍历二叉搜索树，按升序访问节点值</span><br><span class="line">2. 计数每访问一个节点，当计数等于 k 时，返回该节点值</span><br><span class="line">3. 使用递归实现中序遍历</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">kthSmallest</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        count = <span class="number">0</span> <span class="comment"># 计数器</span></span><br><span class="line">        result = <span class="literal">None</span> <span class="comment"># 结果存储</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">inorder</span>(<span class="params">node</span>):</span><br><span class="line">            <span class="keyword">nonlocal</span> count, result</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 遍历左子树</span></span><br><span class="line">            inorder(node.left)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 处理当前节点</span></span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> count == k:</span><br><span class="line">                result = node.val</span><br><span class="line">                <span class="keyword">return</span> </span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 遍历右子树</span></span><br><span class="line">            inorder(node.right)</span><br><span class="line"></span><br><span class="line">        inorder(root)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">kthSmallest</span>(<span class="params">root, k</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> count = <span class="number">0</span>; <span class="comment">// 计数器</span></span><br><span class="line">        <span class="keyword">let</span> result = <span class="literal">null</span>; <span class="comment">// 结果存储</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">function</span> <span class="title function_">inorder</span>(<span class="params">node</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!node) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 遍历左子树</span></span><br><span class="line">            <span class="title function_">inorder</span>(node.<span class="property">left</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 处理当前节点</span></span><br><span class="line">            count += <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (count === k) &#123;</span><br><span class="line">                result = node.<span class="property">val</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 遍历右子树</span></span><br><span class="line">            <span class="title function_">inorder</span>(node.<span class="property">right</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="title function_">inorder</span>(root);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h4 id="二叉树展开为链表"><a href="#二叉树展开为链表" class="headerlink" title="二叉树展开为链表"></a>二叉树展开为链表</h4><blockquote><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/flatten-binary-tree-to-linked-list/">Leetcode 114. Flatten Binary Tree to Linked List</a></p></blockquote><ul><li>题目: 将二叉树展开为链表，要求“就地”修改树的结构，使其变为一个单链表形式，顺序与前序遍历一致</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: root = [1,2,5,3,4,null,6]</span><br><span class="line">Output: [1,null,2,null,3,null,4,null,5,null,6]</span><br></pre></td></tr></table></figure><ul><li>解法: 递归</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 递归处理左子树和右子树，将它们分别扁平化</span><br><span class="line">2. 保存右子树，并将左子树移到右子树的位置，将左子树置为 None</span><br><span class="line">3. 找到左子树的最右节点，将保存的右子树接到这个节点上</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">flatten</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 递归处理左子树和右子树</span></span><br><span class="line">        self.flatten(root.left)</span><br><span class="line">        self.flatten(root.right)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 保存右子树</span></span><br><span class="line">        right_subtree = root.right</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 将左子树移动到右子树的位置</span></span><br><span class="line">        root.right = root.left</span><br><span class="line">        root.left = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 找到左子树的最右节点</span></span><br><span class="line">        curr = root</span><br><span class="line">        <span class="keyword">while</span> curr.right:</span><br><span class="line">            curr = curr.right</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 将保存的右子树接到最右节点</span></span><br><span class="line">        curr.right = right_subtree</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">flatten</span>(<span class="params">root</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 递归处理左子树和右子树</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">flatten</span>(root.<span class="property">left</span>);</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">flatten</span>(root.<span class="property">right</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 保存右子树</span></span><br><span class="line">        <span class="keyword">const</span> rightSubtree = root.<span class="property">right</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将左子树移动到右子树的位置</span></span><br><span class="line">        root.<span class="property">right</span> = root.<span class="property">left</span>;</span><br><span class="line">        root.<span class="property">left</span> = <span class="literal">null</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 找到左子树的最右节点</span></span><br><span class="line">        <span class="keyword">let</span> curr = root;</span><br><span class="line">        <span class="keyword">while</span> (curr.<span class="property">right</span>)</span><br><span class="line">            curr = curr.<span class="property">right</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将保存的右子树接到最右节点</span></span><br><span class="line">        curr.<span class="property">right</span> = rightSubtree;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h4 id="二叉搜索树的最近公共祖先"><a href="#二叉搜索树的最近公共祖先" class="headerlink" title="二叉搜索树的最近公共祖先"></a>二叉搜索树的最近公共祖先</h4><blockquote><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/">Leetcode 235. Lowest Common Ancestor of a Binary Search Tree</a></p></blockquote><ul><li>题目: 在一个二叉搜索树（<code>BST</code>）中，给定两个节点<code>p</code>和<code>q</code>，找到它们的最近公共祖先（<code>LCA</code>）</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: root = [5,3,8,1,4,7,9,null,2], p = 3, q = 8</span><br><span class="line">Output: 5</span><br><span class="line">Explanation: 节点 5 是节点 3 和 8 的最近公共祖先</span><br></pre></td></tr></table></figure><ul><li>解法: 利用二叉搜索树的性质</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 从根节点开始遍历</span><br><span class="line">2. 如果 p 和 q 的值都小于当前节点值，则往左子树继续查找</span><br><span class="line">3. 如果 p 和 q 的值都大于当前节点值，则往右子树继续查找</span><br><span class="line">4. 如果 p 和 q 的值分别位于当前节点的两侧，或者当前节点值等于其中一个节点值，则当前节点为最近公共祖先</span><br></pre></td></tr></table></figure><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">Python</button></li><li class="tab"><button type="button" data-href="#test-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lowestCommonAncestor</span>(<span class="params">self, root: <span class="string">&#x27;TreeNode&#x27;</span>, p: <span class="string">&#x27;TreeNode&#x27;</span>, q: <span class="string">&#x27;TreeNode&#x27;</span></span>) -&gt; <span class="string">&#x27;TreeNode&#x27;</span>:</span><br><span class="line">        <span class="keyword">while</span> root:</span><br><span class="line">            <span class="keyword">if</span> root.val &gt; p.val <span class="keyword">and</span> root.val &gt; q.val:</span><br><span class="line">                root = root.left <span class="comment"># p 和 q 都在左子树</span></span><br><span class="line">            <span class="keyword">elif</span> root.val &lt; p.val <span class="keyword">and</span> root.val &lt; q.val:</span><br><span class="line">                root = root.right <span class="comment"># p 和 q 都在右子树</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> root <span class="comment"># 当前节点是最近公共祖先</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">lowestCommonAncestor</span>(<span class="params">root, p, q</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (root) &#123;</span><br><span class="line">            <span class="keyword">if</span> (root.<span class="property">val</span> &gt; p.<span class="property">val</span> &amp;&amp; root.<span class="property">val</span> &gt; q.<span class="property">val</span>)</span><br><span class="line">                root = root.<span class="property">left</span>; <span class="comment">// p 和 q 都在左子树</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (root.<span class="property">val</span> &lt; p.<span class="property">val</span> &amp;&amp; root.<span class="property">val</span> &lt; q.<span class="property">val</span>)</span><br><span class="line">                root = root.<span class="property">right</span>; <span class="comment">// p 和 q 都在右子树</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> root; <span class="comment">// 当前节点是最近公共祖先</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h4 id="对称二叉树"><a href="#对称二叉树" class="headerlink" title="对称二叉树"></a>对称二叉树</h4><blockquote><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/symmetric-tree/">Leetcode 101. Symmetric Tree</a></p></blockquote><ul><li>题目: 判断给定的二叉树是否是对称的。如果一棵树的左子树和右子树是镜像对称的，则这棵树是对称</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: root = [1,2,2,3,4,4,3]</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><ul><li>解法: 递归</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 如果树为空，返回 True</span><br><span class="line">2. 定义一个辅助函数 isMirror，判断两个节点是否对称</span><br><span class="line">   - 如果两个节点都为空，返回 True</span><br><span class="line">   - 如果只有一个节点为空，返回 False</span><br><span class="line">   - 判断两个节点的值是否相等，并递归判断它们的左右子节点是否对称</span><br><span class="line">3. 调用 isMirror(root.left, root.right)</span><br></pre></td></tr></table></figure><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">Python</button></li><li class="tab"><button type="button" data-href="#test-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isSymmetric</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">isMirror</span>(<span class="params">t1, t2</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> t1 <span class="keyword">and</span> <span class="keyword">not</span> t2:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> t1 <span class="keyword">or</span> <span class="keyword">not</span> t2:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">return</span> t1.val == t2.val <span class="keyword">and</span> isMirror(t1.right, t2.left) <span class="keyword">and</span> isMirror(t1.left, t2.right)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> isMirror(root, root)</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">isSymmetric</span>(<span class="params">root</span>) &#123;</span><br><span class="line">        <span class="keyword">function</span> <span class="title function_">isMirror</span>(<span class="params">t1, t2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!t1 &amp;&amp; !t2) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (!t1 || !t2) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> t1.<span class="property">val</span> === t2.<span class="property">val</span> &amp;&amp; <span class="title function_">isMirror</span>(t1.<span class="property">right</span>, t2.<span class="property">left</span>) &amp;&amp; <span class="title function_">isMirror</span>(t1.<span class="property">left</span>, t2.<span class="property">right</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">isMirror</span>(root, root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h4 id="存在路径总和"><a href="#存在路径总和" class="headerlink" title="存在路径总和"></a>存在路径总和</h4><blockquote><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/path-sum/">Leetcode 112. Path Sum</a></p></blockquote><ul><li>题目: 给定一个二叉树和一个目标和，判断树中是否存在从根节点到叶子节点的路径，使得路径上的所有节点值相加等于目标和</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22</span><br><span class="line">Output: true</span><br><span class="line">Explanation: The path 5 → 4 → 11 → 2 has a sum of 22</span><br></pre></td></tr></table></figure><ul><li>解法: 深度优先搜索</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 从根节点出发，递归地检查左右子树</span><br><span class="line">2. 在每次递归中，将目标值减去当前节点的值</span><br><span class="line">3. 当到达叶子节点时，检查剩余目标值是否为 0</span><br><span class="line">4. 如果找到一条路径符合条件，则返回 True；否则继续搜索</span><br></pre></td></tr></table></figure><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">Python</button></li><li class="tab"><button type="button" data-href="#test-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hasPathSum</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], targetSum: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 减去当前节点值</span></span><br><span class="line">        targetSum -= root.val</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 检查是否是叶子节点并且目标值为</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right:</span><br><span class="line">            <span class="keyword">return</span> targetSum == <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 递归检查左右子树</span></span><br><span class="line">        <span class="keyword">return</span> self.hasPathSum(root.left, targetSum) <span class="keyword">or</span> self.hasPathSum(root.right, targetSum)</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">hasPathSum</span>(<span class="params">root, targetSum</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 减去当前节点值</span></span><br><span class="line">        targetSum -= root.<span class="property">val</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查是否是叶子节点并且目标值为0</span></span><br><span class="line">        <span class="keyword">if</span> (!root.<span class="property">left</span> &amp;&amp; !root.<span class="property">right</span>)</span><br><span class="line">            <span class="keyword">return</span> targetSum === <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 递归检查左右子树</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">hasPathSum</span>(root.<span class="property">left</span>, targetSum) || <span class="variable language_">this</span>.<span class="title function_">hasPathSum</span>(root.<span class="property">right</span>, targetSum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h4 id="所有路径总和"><a href="#所有路径总和" class="headerlink" title="所有路径总和"></a>所有路径总和</h4><blockquote><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/path-sum-ii/">Leetcode 113. Path Sum II</a></p></blockquote><ul><li>题目: 给定一个二叉树和一个目标和，返回所有从根节点到叶子节点的路径，使得路径上的节点值之和等于目标和</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22</span><br><span class="line">Output: [[5,4,11,2],[5,8,4,5]]</span><br><span class="line">Explanation: The paths are:</span><br><span class="line">5 → 4 → 11 → 2</span><br><span class="line">5 → 8 → 4 → 5</span><br></pre></td></tr></table></figure><ul><li>解法: 深度优先搜索 + 回溯</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 使用递归深度优先搜索（DFS）遍历二叉树</span><br><span class="line">2. 在路径上记录当前节点值，减去当前节点值更新目标和</span><br><span class="line">3. 当到达叶子节点且目标和为 0 时，将当前路径加入结果</span><br><span class="line">4. 回溯时移除当前节点值，返回上一层递归继续搜索</span><br></pre></td></tr></table></figure><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">Python</button></li><li class="tab"><button type="button" data-href="#test-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pathSum</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], targetSum: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        result = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">node, current_path, remaining_sum</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 添加当前节点值到路径</span></span><br><span class="line">            current_path.append(node.val)</span><br><span class="line">            remaining_sum -= node.val</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 如果是叶子节点且目标和为0，保存路径</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node.left <span class="keyword">and</span> <span class="keyword">not</span> node.right <span class="keyword">and</span> remaining_sum == <span class="number">0</span>:</span><br><span class="line">                result.append(<span class="built_in">list</span>(current_path))</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 递归遍历左右子树</span></span><br><span class="line">            dfs(node.left, current_path, remaining_sum)</span><br><span class="line">            dfs(node.right, current_path, remaining_sum)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 回溯</span></span><br><span class="line">            current_path.pop()</span><br><span class="line">        </span><br><span class="line">        dfs(root, [], targetSum)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">pathSum</span>(<span class="params">root, targetSum</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> result = [];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">function</span> <span class="title function_">dfs</span>(<span class="params">node, currentPath, remainingSum</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!node) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 添加当前节点值到路径</span></span><br><span class="line">            currentPath.<span class="title function_">push</span>(node.<span class="property">val</span>);</span><br><span class="line">            remainingSum -= node.<span class="property">val</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果是叶子节点且目标和为0，保存路径</span></span><br><span class="line">            <span class="keyword">if</span> (!node.<span class="property">left</span> &amp;&amp; !node.<span class="property">right</span> &amp;&amp; remainingSum === <span class="number">0</span>)</span><br><span class="line">                result.<span class="title function_">push</span>([...currentPath]);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 递归遍历左右子树</span></span><br><span class="line">            <span class="title function_">dfs</span>(node.<span class="property">left</span>, currentPath, remainingSum);</span><br><span class="line">            <span class="title function_">dfs</span>(node.<span class="property">right</span>, currentPath, remainingSum);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 回溯</span></span><br><span class="line">            currentPath.<span class="title function_">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="title function_">dfs</span>(root, [], targetSum);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h3 id="Matrix-矩阵"><a href="#Matrix-矩阵" class="headerlink" title="Matrix 矩阵"></a><code>Matrix</code> 矩阵</h3><h4 id="螺旋矩阵"><a href="#螺旋矩阵" class="headerlink" title="螺旋矩阵"></a>螺旋矩阵</h4><blockquote><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/spiral-matrix/">Leetcode 54. Spiral Matrix</a></p></blockquote><ul><li>题目: 按照螺旋顺序输出矩阵中的所有元素</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: matrix = [[1,2,3],[4,5,6],[7,8,9]]</span><br><span class="line">Output: [1,2,3,6,9,8,7,4,5]</span><br></pre></td></tr></table></figure><ul><li>解法: 逐层遍历</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 初始化矩阵的边界</span><br><span class="line">    - 上边界 top，初始为 0</span><br><span class="line">    - 下边界 bottom，初始为矩阵的行数 - 1</span><br><span class="line">    - 左边界 left，初始为 0</span><br><span class="line">    - 右边界 right，初始为矩阵的列数 - 1</span><br><span class="line">2. 按照螺旋顺序</span><br><span class="line">    - 从左到右遍历最上面一行</span><br><span class="line">    - 从上到下遍历最右边一列</span><br><span class="line">    - 从右到左遍历最下面一行（如果还有剩余行）</span><br><span class="line">    - 从下到上遍历最左边一列（如果还有剩余列）</span><br><span class="line">3. 每遍历一层后缩小边界，直到遍历完整个矩阵</span><br></pre></td></tr></table></figure><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">Python</button></li><li class="tab"><button type="button" data-href="#test-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">spiralOrder</span>(<span class="params">self, matrix: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        top, bottom = <span class="number">0</span>, <span class="built_in">len</span>(matrix) - <span class="number">1</span></span><br><span class="line">        left, right = <span class="number">0</span>, <span class="built_in">len</span>(matrix[<span class="number">0</span>]) - <span class="number">1</span></span><br><span class="line">        result = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> top &lt;= bottom <span class="keyword">and</span> left &lt;= right:</span><br><span class="line">            <span class="comment"># 从左到右遍历最上面一行</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(left, right + <span class="number">1</span>):</span><br><span class="line">                result.append(matrix[top][i])</span><br><span class="line">            top += <span class="number">1</span>  <span class="comment"># 上边界向下移动</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 从上到下遍历最右边一列</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(top, bottom + <span class="number">1</span>):</span><br><span class="line">                result.append(matrix[i][right])</span><br><span class="line">            right -= <span class="number">1</span>  <span class="comment"># 右边界向左移动</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> top &lt;= bottom:</span><br><span class="line">                <span class="comment"># 从右到左遍历最下面一行</span></span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(right, left - <span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                    result.append(matrix[bottom][i])</span><br><span class="line">                bottom -= <span class="number">1</span>  <span class="comment"># 下边界向上移动</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> left &lt;= right:</span><br><span class="line">                <span class="comment"># 从下到上遍历最左边一列</span></span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(bottom, top - <span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                    result.append(matrix[i][left])</span><br><span class="line">                left += <span class="number">1</span>  <span class="comment"># 左边界向右移动</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">spiralOrder</span>(<span class="params">matrix</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> top = <span class="number">0</span>, bottom = matrix.<span class="property">length</span> - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">let</span> left = <span class="number">0</span>, right = matrix[<span class="number">0</span>].<span class="property">length</span> - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">let</span> result = [];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> ((top &lt;= bottom) &amp;&amp; (left &lt;= right)) &#123;</span><br><span class="line">            <span class="comment">// 从左到右遍历最上面一行</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = left; i &lt; right + <span class="number">1</span>; i++)</span><br><span class="line">                result.<span class="title function_">push</span>(matrix[top][i]);</span><br><span class="line">            top += <span class="number">1</span>; <span class="comment">// 上边界向下移动</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 从上到下遍历最右边一列</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> j = top; j &lt; bottom + <span class="number">1</span>; j++)</span><br><span class="line">                result.<span class="title function_">push</span>(matrix[j][right]);</span><br><span class="line">            right -= <span class="number">1</span>; <span class="comment">// 右边界向左移动</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (top &lt;= bottom) &#123;</span><br><span class="line">                <span class="comment">// 从右到左遍历最下面一行</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">let</span> i = right; i &gt; left - <span class="number">1</span>; i--)</span><br><span class="line">                    result.<span class="title function_">push</span>(matrix[bottom][i]);</span><br><span class="line">                bottom -= <span class="number">1</span>; <span class="comment">// 下边界向上移动</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (left &lt;= right) &#123;</span><br><span class="line">                <span class="comment">// 从下到上遍历最左边一列</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">let</span> j = bottom; j &gt; top - <span class="number">1</span>; j--)</span><br><span class="line">                    result.<span class="title function_">push</span>(matrix[j][left]);</span><br><span class="line">                left += <span class="number">1</span>; <span class="comment">// 左边界向右移动</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h4 id="有效数独"><a href="#有效数独" class="headerlink" title="有效数独"></a>有效数独</h4><blockquote><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/valid-sudoku/">Leetcode 36. Valid Sudoku</a></p></blockquote><ul><li>题目: 给定一个<code>9x9</code>的数独棋盘，验证该棋盘是否有效<ul><li>每行数字不能重复</li><li>每列数字不能重复</li><li>每个<code>3x3</code>方块中的数字不能重复</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: board = </span><br><span class="line">[[&quot;5&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;]</span><br><span class="line">,[&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;]</span><br><span class="line">,[&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;]</span><br><span class="line">,[&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;]</span><br><span class="line">,[&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;]</span><br><span class="line">,[&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;]</span><br><span class="line">,[&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;]</span><br><span class="line">,[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;]</span><br><span class="line">,[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]]</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><ul><li>解法: 哈希表</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 使用三个哈希表分别记录</span><br><span class="line">    - 每行中已出现的数字</span><br><span class="line">    - 每列中已出现的数字</span><br><span class="line">    - 每个 3x3 方块中已出现的数字</span><br><span class="line">2. 遍历整个棋盘</span><br><span class="line">    - 如果遇到 .，跳过</span><br><span class="line">    - 检查数字是否已存在于当前行、列或对应的 3x3 方块中</span><br><span class="line">    - 如果存在，返回 False</span><br><span class="line">    - 如果不存在，添加到相应的哈希表中</span><br><span class="line">3. 遍历结束后，若未发现冲突，返回 True</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isValidSudoku</span>(<span class="params">board: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="comment"># 哈希表记录每行、每列和每个 3x3 方块的数字</span></span><br><span class="line">        rows = collections.defaultdict(<span class="built_in">set</span>)</span><br><span class="line">        cols = collections.defaultdict(<span class="built_in">set</span>)</span><br><span class="line">        squares = collections.defaultdict(<span class="built_in">set</span>) <span class="comment"># 键为 (r//3, c//3)</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> r <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">                num = board[r][c]</span><br><span class="line">                <span class="keyword">if</span> num == <span class="string">&quot;.&quot;</span>:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">                <span class="comment"># 检查当前数字是否已存在</span></span><br><span class="line">                <span class="keyword">if</span> num <span class="keyword">in</span> rows[r] <span class="keyword">or</span> num <span class="keyword">in</span> cols[c] <span class="keyword">or</span> num <span class="keyword">in</span> squares[(r // <span class="number">3</span>, c // <span class="number">3</span>)]:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">                <span class="comment"># 添加数字到对应哈希表</span></span><br><span class="line">                rows[r].add(num)</span><br><span class="line">                cols[c].add(num)</span><br><span class="line">                squares[((r // <span class="number">3</span>, c // <span class="number">3</span>))].add(num)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">isValidSudoku</span>(<span class="params">board</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> rows = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">9</span>).<span class="title function_">fill</span>(<span class="number">0</span>).<span class="title function_">map</span>(<span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="title class_">Set</span>());</span><br><span class="line">        <span class="keyword">const</span> cols = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">9</span>).<span class="title function_">fill</span>(<span class="number">0</span>).<span class="title function_">map</span>(<span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="title class_">Set</span>());</span><br><span class="line">        <span class="keyword">const</span> squares = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">9</span>).<span class="title function_">fill</span>(<span class="number">0</span>).<span class="title function_">map</span>(<span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="title class_">Set</span>());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> r = <span class="number">0</span>; r &lt; <span class="number">9</span>; r++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> c = <span class="number">0</span>; c &lt; <span class="number">9</span>; c++) &#123;</span><br><span class="line">                <span class="keyword">const</span> num = board[r][c];</span><br><span class="line">                <span class="keyword">if</span> (num === <span class="string">&quot;.&quot;</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">const</span> squareIndex = <span class="title class_">Math</span>.<span class="title function_">floor</span>(r / <span class="number">3</span>) * <span class="number">3</span> + <span class="title class_">Math</span>.<span class="title function_">floor</span>(c / <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (rows[r].<span class="title function_">has</span>(num) || cols[c].<span class="title function_">has</span>(num) || squares[squareIndex].<span class="title function_">has</span>(num))</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">                rows[r].<span class="title function_">add</span>(num);</span><br><span class="line">                cols[c].<span class="title function_">add</span>(num);</span><br><span class="line">                squares[squareIndex].<span class="title function_">add</span>(num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h4 id="最大岛屿面积"><a href="#最大岛屿面积" class="headerlink" title="最大岛屿面积"></a>最大岛屿面积</h4><blockquote><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/max-area-of-island/">Leetcode 695. Max Area of Island</a></p></blockquote><ul><li>题目: 给定一个二维网格<code>grid</code>，其中<code>0</code>表示水域，<code>1</code>表示陆地，计算网格中最大的岛屿面积。岛屿由上下左右四个方向相连的陆地组成</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: grid = [[0,0,1,0,0,0,0,1,0,0,0,0,0],</span><br><span class="line">               [0,0,0,0,0,0,0,1,1,1,0,0,0],</span><br><span class="line">               [0,1,1,0,1,0,0,0,0,0,0,0,0],</span><br><span class="line">               [0,1,0,0,1,1,0,0,1,0,1,0,0],</span><br><span class="line">               [0,1,0,0,1,1,0,0,1,1,1,0,0],</span><br><span class="line">               [0,0,0,0,0,0,0,0,0,0,1,0,0],</span><br><span class="line">               [0,0,0,0,0,0,0,1,1,1,0,0,0],</span><br><span class="line">               [0,0,0,0,0,0,0,1,1,0,0,0,0]]</span><br><span class="line">Output: 6</span><br></pre></td></tr></table></figure><ul><li>解法: 深度优先搜索（<code>DFS</code>）</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 遍历整个网格</span><br><span class="line">2. 遇到 1 时，启动 DFS 计算连通岛屿的面积</span><br><span class="line">3. 将访问过的格子标记为 0，防止重复访问</span><br><span class="line">4. 更新最大岛屿面积</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxAreaOfIsland</span>(<span class="params">self, grid: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 定义 DFS 函数，遍历岛屿</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">i, j</span>):</span><br><span class="line">            <span class="comment"># 如果超出边界或当前位置不是岛屿，返回 0</span></span><br><span class="line">            <span class="keyword">if</span> i &lt; <span class="number">0</span> <span class="keyword">or</span> i &gt;= <span class="built_in">len</span>(grid) <span class="keyword">or</span> j &lt; <span class="number">0</span> <span class="keyword">or</span> j &gt;= <span class="built_in">len</span>(grid[<span class="number">0</span>]) <span class="keyword">or</span> grid[i][j] == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">            grid[i][j] = <span class="number">0</span> <span class="comment"># 标记为已访问</span></span><br><span class="line">            <span class="comment"># 递归地访问上下左右</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> + dfs(i + <span class="number">1</span>, j) + dfs(i - <span class="number">1</span>, j) + dfs(i, j + <span class="number">1</span>) + dfs(i, j - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        max_area = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(grid)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(grid[<span class="number">0</span>])):</span><br><span class="line">                <span class="keyword">if</span> grid[i][j] == <span class="number">1</span>:</span><br><span class="line">                    max_area = <span class="built_in">max</span>(max_area, dfs(i, j)) <span class="comment"># 如果找到岛屿，启动 DFS</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> max_area</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">maxAreaOfIsland</span>(<span class="params">grid</span>) &#123;</span><br><span class="line">        <span class="keyword">function</span> <span class="title function_">dfs</span>(<span class="params">i, j</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果超出边界或当前位置不是岛屿，返回 0</span></span><br><span class="line">            <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= grid.<span class="property">lenght</span> || j &lt; <span class="number">0</span> || j &gt;= grid[<span class="number">0</span>].<span class="property">length</span> || grid[i][j] === <span class="number">0</span>) </span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            grid[i][j] = <span class="number">0</span>; <span class="comment">// 标记为已访问</span></span><br><span class="line">            <span class="comment">// 递归地访问上下左右</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> + <span class="title function_">dfs</span>(i + <span class="number">1</span>, j) + <span class="title function_">dfs</span>(i - <span class="number">1</span>, j) + <span class="title function_">dfs</span>(i, j + <span class="number">1</span>) + <span class="title function_">dfs</span>(i, j - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> maxArea = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; grid.<span class="property">length</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].<span class="property">length</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] === <span class="number">1</span>)</span><br><span class="line">                    maxArea = <span class="title class_">Math</span>.<span class="title function_">max</span>(maxArea, <span class="title function_">dfs</span>(i, j));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxArea;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h3 id="Array-数组"><a href="#Array-数组" class="headerlink" title="Array 数组"></a><code>Array</code> 数组</h3><h4 id="轮转数组"><a href="#轮转数组" class="headerlink" title="轮转数组"></a>轮转数组</h4><blockquote><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/rotate-array/">Leetcode 189. Rotate Array</a></p></blockquote><ul><li>题目: 给定一个数组，将其元素向右轮转<code>k</code>位，其中<code>k</code>是非负数</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: nums = [1,2,3,4,5,6,7], k = 3</span><br><span class="line">Output: [5,6,7,1,2,3,4]</span><br></pre></td></tr></table></figure><ul><li>解法: 翻转法</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 翻转整个数组</span><br><span class="line">2. 翻转前 k 个元素</span><br><span class="line">3. 翻转剩余的元素</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">rotate</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        k %= n <span class="comment"># 处理 k 大于数组长度的情况</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 翻转数组的辅助函数</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">reverse</span>(<span class="params">start, end</span>):</span><br><span class="line">            <span class="keyword">while</span> start &lt; end:</span><br><span class="line">                nums[start], nums[end] = nums[end], nums[start]</span><br><span class="line">                start += <span class="number">1</span></span><br><span class="line">                end -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 1. 翻转整个数组</span></span><br><span class="line">        reverse(<span class="number">0</span>, n - <span class="number">1</span>)</span><br><span class="line">        <span class="comment"># 2. 翻转前 k 个元素</span></span><br><span class="line">        reverse(<span class="number">0</span>, k - <span class="number">1</span>)</span><br><span class="line">        <span class="comment"># 3. 翻转剩下的元素</span></span><br><span class="line">        reverse(k, n - <span class="number">1</span>)</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">rotate</span>(<span class="params">nums, k</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> n = nums.<span class="property">length</span>;</span><br><span class="line">        k %= n; <span class="comment">// 处理 k 大于数组长度的情况</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">function</span> <span class="title function_">reverse</span>(<span class="params">start, end</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">                [nums[start], nums[end]] = [nums[end], nums[start]];</span><br><span class="line">                start++;</span><br><span class="line">                end--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 翻转整个数组</span></span><br><span class="line">        <span class="title function_">reverse</span>(<span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 2. 翻转前 k 个元素</span></span><br><span class="line">        <span class="title function_">reverse</span>(<span class="number">0</span>, k - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 3. 翻转剩下的元素</span></span><br><span class="line">        <span class="title function_">reverse</span>(k, n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h4 id="数组转树"><a href="#数组转树" class="headerlink" title="数组转树"></a>数组转树</h4><blockquote><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/">Leetcode 108. Convert Sorted Array to Binary Search Tree</a></p></blockquote><ul><li>题目: 将一个有序数组转换为一棵高度平衡的二叉搜索树（<code>BST</code>）。高度平衡指的是树中每个节点的两个子树的高度差不超过<code>1</code></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: nums = [-10,-3,0,5,9]</span><br><span class="line">Output: [0,-3,9,-10,null,5]</span><br></pre></td></tr></table></figure><ul><li>解法: 递归构建</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 选择数组的中间元素作为当前子树的根节点。</span><br><span class="line">2. 左侧子数组递归构建左子树。</span><br><span class="line">3. 右侧子数组递归构建右子树。</span><br><span class="line">4. 当数组为空时，返回 None。</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sortedArrayToBST</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">        <span class="comment"># 如果数组为空，返回 None</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 找到中间元素并创建当前根节点</span></span><br><span class="line">        mid = <span class="built_in">len</span>(nums) // <span class="number">2</span></span><br><span class="line">        root = TreeNode(nums[mid])</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 构建左子树和右子树</span></span><br><span class="line">        root.left = self.sortedArrayToBST(nums[:mid])</span><br><span class="line">        root.right = self.sortedArrayToBST(nums[mid + <span class="number">1</span>:])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">sortedArrayToBST</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果数组为空，返回 null</span></span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="property">length</span> === <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找到中间元素并创建当前根节点</span></span><br><span class="line">        <span class="keyword">const</span> mid = <span class="title class_">Math</span>.<span class="title function_">floor</span>(nums.<span class="property">length</span> / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">const</span> root = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(nums[mid]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构建左子树和右子树</span></span><br><span class="line">        root.<span class="property">left</span> = <span class="variable language_">this</span>.<span class="title function_">sortedArrayToBST</span>(nums.<span class="title function_">slice</span>(<span class="number">0</span>, mid));</span><br><span class="line">        root.<span class="property">right</span> = <span class="variable language_">this</span>.<span class="title function_">sortedArrayToBST</span>(nums.<span class="title function_">slice</span>(mid + <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h4 id="合并两个有序数组"><a href="#合并两个有序数组" class="headerlink" title="合并两个有序数组"></a>合并两个有序数组</h4><blockquote><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/merge-sorted-array/">Leetcode 88. Merge Sorted Array</a></p></blockquote><ul><li>题目: 将两个有序数组<code>nums1</code>和<code>nums2</code>合并为一个有序数组，其中<code>nums1</code>有足够的空间存放<code>nums2</code>的元素</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3</span><br><span class="line">Output: [1,2,2,3,5,6]</span><br></pre></td></tr></table></figure><ul><li>解法: 双指针从后往前合并</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 设置三个指针</span><br><span class="line">   - i 指向 nums1 的有效元素部分的末尾</span><br><span class="line">   - j 指向 nums2 的末尾</span><br><span class="line">   - k 指向 nums1 的末尾</span><br><span class="line">2. 比较 nums1 和 nums2 中的元素，将较大的元素填入 nums1 的末尾，指针向前移动</span><br><span class="line">3. 如果 nums2 还有剩余的元素，直接填入 nums1</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">merge</span>(<span class="params">self, nums1: <span class="type">List</span>[<span class="built_in">int</span>], m: <span class="built_in">int</span>, nums2: <span class="type">List</span>[<span class="built_in">int</span>], n: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="comment"># 指针 i 指向 nums1 的有效部分末尾，j 指向 nums2 末尾，k 指向 nums1 的总末尾</span></span><br><span class="line">        i, j, k = m - <span class="number">1</span>, n - <span class="number">1</span>, m + n - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 从后往前合并</span></span><br><span class="line">        <span class="keyword">while</span> i &gt;= <span class="number">0</span> <span class="keyword">and</span> j &gt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> nums1[i] &gt; nums2[j]:</span><br><span class="line">                nums1[k] = nums1[i]</span><br><span class="line">                i -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                nums1[k] = nums2[j]</span><br><span class="line">                j -= <span class="number">1</span></span><br><span class="line">            k -= <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 如果 nums2 还有剩余元素，填入 nums1</span></span><br><span class="line">        <span class="keyword">while</span> j &gt;= <span class="number">0</span>:</span><br><span class="line">            nums1[k] = nums2[j]</span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">            k -= <span class="number">1</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">merge</span>(<span class="params">nums1, m, nums2, n</span>) &#123;</span><br><span class="line">        <span class="comment">// 指针 i 指向 nums1 的有效部分末尾，j 指向 nums2 末尾，k 指向 nums1 的总末尾</span></span><br><span class="line">        <span class="keyword">let</span> i = m - <span class="number">1</span>, j = n - <span class="number">1</span>, k = m + n - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从后往前合并</span></span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums1[i] &gt; nums2[j]) &#123;</span><br><span class="line">                nums1[k] = nums1[i];</span><br><span class="line">                i--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                nums1[k] = nums2[j];</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            k--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果 nums2 还有剩余元素，填入 nums1</span></span><br><span class="line">        <span class="keyword">while</span> (j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            nums1[k] = nums2[j];</span><br><span class="line">            j--;</span><br><span class="line">            k--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h4 id="每日温度"><a href="#每日温度" class="headerlink" title="每日温度"></a>每日温度</h4><blockquote><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/daily-temperatures/">Leetcode 739. Daily Temperatures</a></p></blockquote><ul><li>题目: 给定一个整数数组<code>temperatures</code>，表示每天的温度，返回一个数组<code>answer</code>，其中<code>answer[i]</code>是需要等待的天数，直到<code>temperatures[i]</code>之后出现更高的温度。如果没有更高的温度，<code>answer[i] = 0</code></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: temperatures = [73,74,75,71,69,72,76,73]</span><br><span class="line">Output: [1,1,4,2,1,1,0,0]</span><br></pre></td></tr></table></figure><ul><li>解法: 单调栈</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 使用栈存储温度的索引</span><br><span class="line">2. 遍历 temperatures：</span><br><span class="line">   - 如果当前温度高于栈顶索引对应的温度，弹出栈顶索引并计算等待天数</span><br><span class="line">   - 否则，将当前索引压入栈</span><br><span class="line">3. 最后栈中未处理的索引对应的等待天数为 0</span><br><span class="line">4. 时间复杂度 O(n)</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dailyTemperatures</span>(<span class="params">self, temperatures: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="comment"># 初始化结果数组和栈</span></span><br><span class="line">        result = [<span class="number">0</span>] * <span class="built_in">len</span>(temperatures)</span><br><span class="line">        stack = []</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 遍历温度数组</span></span><br><span class="line">        <span class="keyword">for</span> i, temp <span class="keyword">in</span> <span class="built_in">enumerate</span>(temperatures):</span><br><span class="line">            <span class="comment"># 如果当前温度比栈顶的温度高</span></span><br><span class="line">            <span class="keyword">while</span> stack <span class="keyword">and</span> temp &gt; temperatures[stack[-<span class="number">1</span>]]:</span><br><span class="line">                prev_index = stack.pop()</span><br><span class="line">                result[prev_index] = i - prev_index</span><br><span class="line">            <span class="comment"># 将当前索引压入栈</span></span><br><span class="line">            stack.append(i)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">dailyTemperatures</span>(<span class="params">temperatures</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> result = <span class="keyword">new</span> <span class="title class_">Array</span>(temperatures.<span class="property">length</span>).<span class="title function_">fill</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">const</span> stack = [];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历温度数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; temperatures.<span class="property">length</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 如果当前温度比栈顶的温度高</span></span><br><span class="line">            <span class="keyword">while</span> (stack.<span class="property">length</span> &amp;&amp; temperatures[i] &gt; temperatures[stack[stack.<span class="property">length</span> - <span class="number">1</span>]]) &#123;</span><br><span class="line">                <span class="keyword">const</span> prevIndex = stack.<span class="title function_">pop</span>();</span><br><span class="line">                result[prevIndex] = i - prevIndex;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将当前索引压入栈</span></span><br><span class="line">            stack.<span class="title function_">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h3 id="String-字符串"><a href="#String-字符串" class="headerlink" title="String 字符串"></a><code>String</code> 字符串</h3><h4 id="字符串解码"><a href="#字符串解码" class="headerlink" title="字符串解码"></a>字符串解码</h4><blockquote><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/decode-string/">Leetcode 394. Decode String</a></p></blockquote><ul><li>题目: 给定一个编码过的字符串<code>s</code>，其中包含嵌套的数字和括号结构，例如<code>3[a2[c]]</code>，其解码规则为<ul><li>数字表示括号内字符串的重复次数</li><li>解码后输出完整的字符串</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: s = &quot;3[a]2[bc]&quot;</span><br><span class="line">Output: &quot;aaabcbc&quot;</span><br></pre></td></tr></table></figure><ul><li>解法: 栈</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 使用栈保存当前的字符串和重复次数</span><br><span class="line">2. 遇到 [ 将当前字符串和次数入栈，清空当前的数字和字符串</span><br><span class="line">3. 遇到 ] 将栈中的字符串与当前字符串组合，并重复指定次数</span><br><span class="line">4. 遇到数字时，累积数字值</span><br><span class="line">5. 遇到普通字符时，将其追加到当前字符串</span><br><span class="line">6. 最后，栈中保存的即为解码后的结果</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">decodeString</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        stack = [] <span class="comment"># 栈，用于保存 (当前字符串, 当前数字)</span></span><br><span class="line">        curr_num = <span class="number">0</span> <span class="comment"># 当前的重复次数</span></span><br><span class="line">        curr_str = <span class="string">&quot;&quot;</span> <span class="comment"># 当前正在构建的字符串</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> c.isdigit():</span><br><span class="line">                <span class="comment"># 构建数字</span></span><br><span class="line">                curr_num = curr_num * <span class="number">10</span> + <span class="built_in">int</span>(c)</span><br><span class="line">            <span class="keyword">elif</span> c == <span class="string">&quot;[&quot;</span>:</span><br><span class="line">                <span class="comment"># 遇到左括号，将当前字符串和数字入栈</span></span><br><span class="line">                stack.append((curr_str, curr_num))</span><br><span class="line">                curr_str = <span class="string">&quot;&quot;</span></span><br><span class="line">                curr_num = <span class="number">0</span></span><br><span class="line">            <span class="keyword">elif</span> c == <span class="string">&quot;]&quot;</span>:</span><br><span class="line">                <span class="comment"># 遇到右括号，出栈并构造新字符串</span></span><br><span class="line">                prev_str, num = stack.pop()</span><br><span class="line">                curr_str = prev_str + num * curr_str</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 字母追加到当前字符串</span></span><br><span class="line">                curr_str += c</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> curr_str</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">decodeString</span>(<span class="params">s</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> stack = [];</span><br><span class="line">        <span class="keyword">let</span> currNum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">let</span> currStr = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> c <span class="keyword">of</span> s) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">isNaN</span>(c)) &#123;</span><br><span class="line">                <span class="comment">// 构建数字</span></span><br><span class="line">                currNum = currNum * <span class="number">10</span> + <span class="built_in">parseInt</span>(c);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c === <span class="string">&quot;[&quot;</span>) &#123;</span><br><span class="line">                <span class="comment">// 遇到左括号，将当前字符串和数字入栈</span></span><br><span class="line">                stack.<span class="title function_">push</span>([currStr, currNum]);</span><br><span class="line">                currStr = <span class="string">&quot;&quot;</span>;</span><br><span class="line">                currNum = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c === <span class="string">&quot;]&quot;</span>) &#123;</span><br><span class="line">                <span class="comment">// 遇到右括号，出栈并构造新字符串</span></span><br><span class="line">                <span class="keyword">const</span> [prevStr, num] = stack.<span class="title function_">pop</span>();</span><br><span class="line">                currStr = prevStr + currStr.<span class="title function_">repeat</span>(num);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 字母追加到当前字符串</span></span><br><span class="line">                currStr += c;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> currStr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h4 id="最长无重复子串"><a href="#最长无重复子串" class="headerlink" title="最长无重复子串"></a>最长无重复子串</h4><blockquote><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/longest-substring-without-repeating-characters/">Leetcode 3. Longest Substring Without Repeating Characters</a></p></blockquote><ul><li>题目: 给定一个字符串<code>s</code>，找出其中不含重复字符的最长子串的长度</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: s = &quot;abcabcbb&quot;</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure><ul><li>解法: 滑动窗口</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 使用两个指针 `left` 和 `right` 维护一个滑动窗口，窗口内的字符不重复</span><br><span class="line">2. 用一个 `set` 存储当前窗口内的字符</span><br><span class="line">3. 每次移动右指针，将字符尝试加入窗口：</span><br><span class="line">   - 如果字符已存在，移动左指针，直到窗口中无重复字符</span><br><span class="line">4. 更新当前窗口的最大长度</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lengthOfLongestSubstring</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        result = <span class="number">0</span></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        char_set = <span class="built_in">set</span>()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> right <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">            <span class="comment"># 如果字符重复，移动左指针直到窗口无重复字符</span></span><br><span class="line">            <span class="keyword">while</span> s[right] <span class="keyword">in</span> char_set:</span><br><span class="line">                char_set.remove(s[left])</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 将当前字符加入窗口</span></span><br><span class="line">            char_set.add(s[right])</span><br><span class="line">            <span class="comment"># 更新最大长度</span></span><br><span class="line">            result = <span class="built_in">max</span>(result, right - left + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">lengthOfLongestSubstring</span>(<span class="params">s</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">let</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">let</span> charSet = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> right = <span class="number">0</span>; right &lt; s.<span class="property">length</span>; right++) &#123;</span><br><span class="line">            <span class="comment">// 如果字符重复，移动左指针直到窗口无重复字符</span></span><br><span class="line">            <span class="keyword">while</span> (charSet.<span class="title function_">has</span>(s[right])) &#123;</span><br><span class="line">                charSet.<span class="title function_">delete</span>(s[left]);</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将当前字符加入窗口</span></span><br><span class="line">            charSet.<span class="title function_">add</span>(s[right]);</span><br><span class="line">            <span class="comment">// 更新最大长度</span></span><br><span class="line">            result = <span class="title class_">Math</span>.<span class="title function_">max</span>(result, right - left + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h4 id="括号匹配"><a href="#括号匹配" class="headerlink" title="括号匹配"></a>括号匹配</h4><blockquote><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/valid-parentheses/">Leetcode 20. Valid Parentheses</a></p></blockquote><ul><li>题目: 验证一个只包含括号的字符串是否有效<ul><li>所有的左括号必须有对应的右括号</li><li>左括号必须以正确的顺序闭合</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: s = &quot;()[]&#123;&#125;&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><ul><li>解法: 栈</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 用一个栈来保存左括号</span><br><span class="line">2. 遍历字符串</span><br><span class="line">    - 遇到左括号，就压入栈</span><br><span class="line">    - 遇到右括号，检查栈顶是否是对应的左括号</span><br><span class="line">        - 如果匹配，弹出栈顶</span><br><span class="line">        - 如果不匹配或栈为空，返回 False</span><br><span class="line">3. 遍历结束后，如果栈为空，说明括号有效</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isValid</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="comment"># 定义右括号到左括号的映射</span></span><br><span class="line">        char_map = &#123;<span class="string">&quot;)&quot;</span>: <span class="string">&quot;(&quot;</span>, <span class="string">&quot;]&quot;</span>: <span class="string">&quot;[&quot;</span>, <span class="string">&quot;&#125;&quot;</span>: <span class="string">&quot;&#123;&quot;</span>&#125;</span><br><span class="line">        stack = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">            <span class="comment"># 如果是左括号，压入栈中</span></span><br><span class="line">            <span class="keyword">if</span> c <span class="keyword">not</span> <span class="keyword">in</span> char_map:</span><br><span class="line">                stack.append(c)</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 如果栈为空或者栈顶元素不匹配，返回 False</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> stack <span class="keyword">or</span> stack[-<span class="number">1</span>] != char_map[c]:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 匹配成功，弹出栈顶</span></span><br><span class="line">            stack.pop()</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> stack</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">isValid</span>(<span class="params">s</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> charMap = &#123; <span class="string">&quot;)&quot;</span>: <span class="string">&quot;(&quot;</span>, <span class="string">&quot;]&quot;</span>: <span class="string">&quot;[&quot;</span>, <span class="string">&quot;&#125;&quot;</span>: <span class="string">&quot;&#123;&quot;</span> &#125;;</span><br><span class="line">        <span class="keyword">const</span> stack = [];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> c <span class="keyword">of</span> s) &#123;</span><br><span class="line">            <span class="comment">// 如果是左括号，压入栈中</span></span><br><span class="line">            <span class="keyword">if</span> (!(c <span class="keyword">in</span> charMap)) &#123;</span><br><span class="line">                stack.<span class="title function_">push</span>(c);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果栈为空或者栈顶元素不匹配，返回 false</span></span><br><span class="line">            <span class="keyword">if</span> (!stack.<span class="property">length</span> || stack[stack.<span class="property">length</span> - <span class="number">1</span>] !== charMap[c])</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 匹配成功，弹出栈顶</span></span><br><span class="line">            stack.<span class="title function_">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> stack.<span class="property">length</span> === <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h4 id="生成括号"><a href="#生成括号" class="headerlink" title="生成括号"></a>生成括号</h4><blockquote><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/generate-parentheses/">Leetcode 22. Generate Parentheses</a></p></blockquote><ul><li>题目: 给定一个数字<code>n</code>，生成所有可能的有效括号组合<ul><li>左括号数量等于右括号数量，并且任意位置右括号的数量不超过左括号</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: n = 3</span><br><span class="line">Output: [&quot;((()))&quot;,&quot;(()())&quot;,&quot;(())()&quot;,&quot;()(())&quot;,&quot;()()()&quot;]</span><br></pre></td></tr></table></figure><ul><li>解法: 回溯法</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 使用递归来生成括号组合</span><br><span class="line">2. 每次递归时，维护当前括号字符串 s 和左右括号的数量</span><br><span class="line">    - 如果左括号的数量小于 n，可以添加左括号</span><br><span class="line">    - 如果右括号的数量小于左括号，添加右括号</span><br><span class="line">3. 当字符串长度等于 2 * n 时，添加到结果中</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">generateParenthesis</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">str</span>]:</span><br><span class="line">        result = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">s, left, right</span>):</span><br><span class="line">            <span class="comment"># 如果长度达到 2 * n，记录结果</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(s) == <span class="number">2</span> * n:</span><br><span class="line">                result.append(s)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 添加左括号</span></span><br><span class="line">            <span class="keyword">if</span> left &lt; n:</span><br><span class="line">                backtrack(s + <span class="string">&quot;(&quot;</span>, left + <span class="number">1</span>, right)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 添加右括号</span></span><br><span class="line">            <span class="keyword">if</span> right &lt; left:</span><br><span class="line">                backtrack(s + <span class="string">&quot;)&quot;</span>, left, right + <span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        backtrack(<span class="string">&quot;&quot;</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">generateParenthesis</span>(<span class="params">n</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> result = [];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">function</span> <span class="title function_">backtrack</span>(<span class="params">s, left, right</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果长度达到 2 * n，记录结果</span></span><br><span class="line">            <span class="keyword">if</span> (s.<span class="property">length</span> === <span class="number">2</span> * n) &#123;</span><br><span class="line">                result.<span class="title function_">push</span>(s);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 添加左括号</span></span><br><span class="line">            <span class="keyword">if</span> (left &lt; n) <span class="title function_">backtrack</span>(s + <span class="string">&quot;(&quot;</span>, left + <span class="number">1</span>, right);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 添加右括号</span></span><br><span class="line">            <span class="keyword">if</span> (right &lt; left) <span class="title function_">backtrack</span>(s + <span class="string">&quot;)&quot;</span>, left, right + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="title function_">backtrack</span>(<span class="string">&quot;&quot;</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h4 id="比较版本号"><a href="#比较版本号" class="headerlink" title="比较版本号"></a>比较版本号</h4><blockquote><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/compare-version-numbers/">Leetcode 165. Compare Version Numbers</a></p></blockquote><ul><li>题目: 给定两个版本号<code>version1</code>和<code>version2</code>，比较它们的大小<ul><li>如果<code>version1 &gt; version2</code>返回<code>1</code></li><li>如果<code>version1 &lt; version2</code>返回<code>-1</code></li><li>如果它们相等，返回<code>0</code></li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: version1 = &quot;1.2&quot;, version2 = &quot;1.10&quot;</span><br><span class="line">Output: -1</span><br></pre></td></tr></table></figure><ul><li>解法: 分割和补齐</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 使用点号分割版本号，将其转换为整数列表</span><br><span class="line">2. 找到两个版本号的最大长度，将较短的版本号用 0 补齐</span><br><span class="line">3. 从左到右逐个比较对应的版本号部分，返回结果</span><br><span class="line">4. 如果遍历结束后仍然没有结果，则两个版本号相等</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">compareVersion</span>(<span class="params">self, version1: <span class="built_in">str</span>, version2: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 将版本号分割为整数列表</span></span><br><span class="line">        v1_parts = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, version1.split(<span class="string">&quot;.&quot;</span>)))</span><br><span class="line">        v2_parts = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, version2.split(<span class="string">&quot;.&quot;</span>)))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 用 0 补齐较短的版本号部分</span></span><br><span class="line">        max_len = <span class="built_in">max</span>(<span class="built_in">len</span>(v1_parts), <span class="built_in">len</span>(v2_parts))</span><br><span class="line">        v1_parts += [<span class="number">0</span>] * (max_len - <span class="built_in">len</span>(v1_parts))</span><br><span class="line">        v2_parts += [<span class="number">0</span>] * (max_len - <span class="built_in">len</span>(v2_parts))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 比较每一部分</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(max_len):</span><br><span class="line">            <span class="keyword">if</span> v1_parts[i] &gt; v2_parts[i]:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> v1_parts[i] &lt; v2_parts[<span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 如果遍历结束仍未分出大小，则版本号相等</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">compareVersion</span>(<span class="params">version1, version2</span>) &#123;</span><br><span class="line">        <span class="comment">// 将版本号分割为整数数组</span></span><br><span class="line">        <span class="keyword">const</span> v1Parts = version1.<span class="title function_">split</span>(<span class="string">&quot;.&quot;</span>).<span class="title function_">map</span>(<span class="title class_">Number</span>);</span><br><span class="line">        <span class="keyword">const</span> v2Parts = version2.<span class="title function_">split</span>(<span class="string">&quot;.&quot;</span>).<span class="title function_">map</span>(<span class="title class_">Number</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用 0 补齐较短的版本号部分</span></span><br><span class="line">        <span class="keyword">const</span> maxLen = <span class="title class_">Math</span>.<span class="title function_">max</span>(v1Parts.<span class="property">length</span>, v2Parts.<span class="property">length</span>);</span><br><span class="line">        <span class="keyword">while</span> (v1Parts.<span class="property">length</span> &lt; maxLen) v1Parts.<span class="title function_">push</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">while</span> (v2Parts.<span class="property">length</span> &lt; maxLen) v2Parts.<span class="title function_">push</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 比较每一部分</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; maxLen; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (v1Parts[i] &gt; v2Parts[i]) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (v1Parts[i] &lt; v2Parts[i]) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果遍历结束仍未分出大小，则版本号相等</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h4 id="经典计算器-无乘除"><a href="#经典计算器-无乘除" class="headerlink" title="经典计算器 (无乘除)"></a>经典计算器 (无乘除)</h4><blockquote><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/basic-calculator/">Leetcode 224. Basic Calculator</a></p></blockquote><ul><li>题目: 实现一个基本的计算器来计算由正整数、<code>+</code>、<code>-</code>和括号组成的数学表达式的值。表达式中可能包含空格，确保输入合法且结果不会溢出</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: s = &quot;(1+(4+5+2)-3)+(6+8)&quot;</span><br><span class="line">Output: 23</span><br></pre></td></tr></table></figure><ul><li>解法: 栈 + 模拟</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 定义一个栈，用于存储运算结果和符号</span><br><span class="line">2. 遍历字符串:</span><br><span class="line">   - 如果是数字，累加当前数字</span><br><span class="line">   - 如果是 `+` 或 `-`，更新当前的符号，并将累加的数字加到结果中</span><br><span class="line">   - 如果是 `(`，将当前结果和符号压栈，并重置结果和符号</span><br><span class="line">   - 如果是 `)`，将栈顶的结果和符号弹出，并与当前结果相加</span><br><span class="line">3. 返回最终计算结果</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">calculate</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        stack = []</span><br><span class="line">        num = <span class="number">0</span></span><br><span class="line">        result = <span class="number">0</span></span><br><span class="line">        sign = <span class="number">1</span> <span class="comment"># 初始符号为正号</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> char <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> char.isdigit():</span><br><span class="line">                <span class="comment"># 如果是数字，更新当前数字</span></span><br><span class="line">                num = num * <span class="number">10</span> + <span class="built_in">int</span>(char)</span><br><span class="line">            <span class="keyword">elif</span> char <span class="keyword">in</span> <span class="string">&quot;+-&quot;</span>:</span><br><span class="line">                <span class="comment"># 如果是加号或减号，先更新当前结果</span></span><br><span class="line">                result += sign * num</span><br><span class="line">                num = <span class="number">0</span></span><br><span class="line">                sign = <span class="number">1</span> <span class="keyword">if</span> char == <span class="string">&quot;+&quot;</span> <span class="keyword">else</span> -<span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> char == <span class="string">&quot;(&quot;</span>:</span><br><span class="line">                <span class="comment"># 如果是左括号，保存当前结果和符号到栈中</span></span><br><span class="line">                stack.append(result)</span><br><span class="line">                stack.append(sign)</span><br><span class="line">                result = <span class="number">0</span></span><br><span class="line">                sign = <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> char == <span class="string">&quot;)&quot;</span>:</span><br><span class="line">                <span class="comment"># 如果是右括号，计算括号内的结果</span></span><br><span class="line">                result += sign * num</span><br><span class="line">                num = <span class="number">0</span></span><br><span class="line">                result *= stack.pop() <span class="comment"># 弹出符号并应用</span></span><br><span class="line">                result += stack.pop() <span class="comment"># 加上之前的结果</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> result + sign * num</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">calculate</span>(<span class="params">s</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> stack = [];</span><br><span class="line">        <span class="keyword">let</span> num = <span class="number">0</span>, result = <span class="number">0</span>, sign = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> char <span class="keyword">of</span> s) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">isNaN</span>(char) &amp;&amp; char !== <span class="string">&quot; &quot;</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果是数字，更新当前数字</span></span><br><span class="line">                num = num * <span class="number">10</span> + <span class="built_in">parseInt</span>(char);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (char === <span class="string">&quot;+&quot;</span> || char === <span class="string">&quot;-&quot;</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果是加号或减号，先更新当前结果</span></span><br><span class="line">                result += sign * num;</span><br><span class="line">                num = <span class="number">0</span>;</span><br><span class="line">                sign = char === <span class="string">&quot;+&quot;</span> ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (char === <span class="string">&quot;(&quot;</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果是左括号，保存当前结果和符号到栈中</span></span><br><span class="line">                stack.<span class="title function_">push</span>(result);</span><br><span class="line">                stack.<span class="title function_">push</span>(sign);</span><br><span class="line">                result = <span class="number">0</span>;</span><br><span class="line">                sign = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (char === <span class="string">&quot;)&quot;</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果是右括号，计算括号内的结果</span></span><br><span class="line">                result += sign * num;</span><br><span class="line">                num = <span class="number">0</span>;</span><br><span class="line">                result *= stack.<span class="title function_">pop</span>(); <span class="comment">// 弹出符号并应用</span></span><br><span class="line">                result += stack.<span class="title function_">pop</span>(); <span class="comment">// 加上之前的结果</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result + sign * num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h4 id="经典计算器-有乘除"><a href="#经典计算器-有乘除" class="headerlink" title="经典计算器 (有乘除)"></a>经典计算器 (有乘除)</h4><blockquote><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/basic-calculator-ii/">Leetcode 227. Basic Calculator II</a></p></blockquote><ul><li>题目: 实现一个基本的计算器来计算一个字符串表达式的值。表达式仅包含非负整数、<code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>运算符以及空格</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: s = &quot;3+2*2&quot;</span><br><span class="line">Output: 7</span><br><span class="line">Explanation: 3 + (2 * 2) = 7</span><br></pre></td></tr></table></figure><ul><li>解法: 栈 + 模拟</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 使用栈来保存当前的计算结果</span><br><span class="line">2. 遍历字符串，处理数字、操作符和空格</span><br><span class="line">   - 如果是数字，累加构成完整数字</span><br><span class="line">   - 如果是操作符或到达字符串末尾，根据前一个操作符执行计算</span><br><span class="line">     - `+`：将当前数字压入栈</span><br><span class="line">     - `-`：将当前数字取反后压入栈</span><br><span class="line">     - `*`：弹出栈顶数字，与当前数字相乘后压入栈</span><br><span class="line">     - `/`：弹出栈顶数字，执行整数除法后压入栈</span><br><span class="line">3. 遍历结束后，栈中的所有元素求和即为最终结果</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">calculate</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        stack = []</span><br><span class="line">        num = <span class="number">0</span></span><br><span class="line">        op = <span class="string">&#x27;+&#x27;</span> <span class="comment"># 初始操作符为 &#x27;+&#x27;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i, c <span class="keyword">in</span> <span class="built_in">enumerate</span>(s):</span><br><span class="line">            <span class="keyword">if</span> c.isdigit():</span><br><span class="line">                num = num * <span class="number">10</span> + <span class="built_in">int</span>(c) <span class="comment"># 累加数字</span></span><br><span class="line">            <span class="keyword">if</span> c <span class="keyword">in</span> <span class="string">&quot;+-*/&quot;</span> <span class="keyword">or</span> i == <span class="built_in">len</span>(s) - <span class="number">1</span>: <span class="comment"># 遇到操作符或字符串末尾</span></span><br><span class="line">                <span class="keyword">if</span> op == <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">                    stack.append(num)</span><br><span class="line">                <span class="keyword">elif</span> op == <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">                    stack.append(-num)</span><br><span class="line">                <span class="keyword">elif</span> op == <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">                    stack.append(stack.pop() * num)</span><br><span class="line">                <span class="keyword">elif</span> op == <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">                    stack.append(<span class="built_in">int</span>(stack.pop() / num))</span><br><span class="line">                op = c <span class="comment"># 更新操作符</span></span><br><span class="line">                num = <span class="number">0</span> <span class="comment"># 重置当前数字</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span>(stack)</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">calculate</span>(<span class="params">s</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> stack = [];</span><br><span class="line">        <span class="keyword">let</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">let</span> op = <span class="string">&#x27;+&#x27;</span>; <span class="comment">// 初始操作符为 &#x27;+&#x27;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; s.<span class="property">length</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">const</span> c = s[i];</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">isNaN</span>(c) &amp;&amp; c !== <span class="string">&#x27; &#x27;</span>) num = num * <span class="number">10</span> + <span class="built_in">parseInt</span>(c); <span class="comment">// 累加数字</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;+-*/&quot;</span>.<span class="title function_">includes</span>(c) || i === s.<span class="property">length</span> - <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (op === <span class="string">&#x27;+&#x27;</span>) stack.<span class="title function_">push</span>(num);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (op === <span class="string">&#x27;-&#x27;</span>) stack.<span class="title function_">push</span>(-num);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (op === <span class="string">&#x27;*&#x27;</span>) stack.<span class="title function_">push</span>(stack.<span class="title function_">pop</span>() * num);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (op === <span class="string">&#x27;/&#x27;</span>) stack.<span class="title function_">push</span>(<span class="title class_">Math</span>.<span class="title function_">trunc</span>(stack.<span class="title function_">pop</span>() / num));</span><br><span class="line"></span><br><span class="line">                op = c; <span class="comment">// 更新操作符</span></span><br><span class="line">                num = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> stack.<span class="title function_">reduce</span>(<span class="function">(<span class="params">acc, num</span>) =&gt;</span> acc + num, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h4 id="回文子串个数"><a href="#回文子串个数" class="headerlink" title="回文子串个数"></a>回文子串个数</h4><blockquote><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/palindromic-substrings/">Leetcode 647. Palindromic Substrings</a></p></blockquote><ul><li>题目: 给定一个字符串<code>s</code>，计算其中包含多少个回文子串</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: s = &quot;abc&quot;</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: Three palindromic substrings are &quot;a&quot;, &quot;b&quot;, and &quot;c&quot;</span><br><span class="line"></span><br><span class="line">Input: s = &quot;aaa&quot;</span><br><span class="line">Output: 6</span><br><span class="line">Explanation: Six palindromic substrings are &quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;aa&quot;, &quot;aa&quot;, and &quot;aaa&quot;</span><br></pre></td></tr></table></figure><ul><li>解法: 中心扩展法</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 中心扩展法</span><br><span class="line">   - 每个字符可以作为奇数长度回文的中心</span><br><span class="line">   - 每对相邻字符可以作为偶数长度回文的中心</span><br><span class="line">   - 从中心向两边扩展，判断两边字符是否相等，同时统计回文子串的数量</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">countSubstrings</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(s)</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">expand_around_center</span>(<span class="params">left, right</span>):</span><br><span class="line">            <span class="keyword">nonlocal</span> count</span><br><span class="line">            <span class="keyword">while</span> left &gt;= <span class="number">0</span> <span class="keyword">and</span> right &lt; n <span class="keyword">and</span> s[left] == s[right]:</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">                left -= <span class="number">1</span></span><br><span class="line">                right += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="comment"># 奇数长度的回文</span></span><br><span class="line">            expand_around_center(i, i)</span><br><span class="line">            <span class="comment"># 偶数长度的回文</span></span><br><span class="line">            expand_around_center(i, i + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">countSubstrings</span>(<span class="params">s</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> n = s.<span class="property">length</span>;</span><br><span class="line">        <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">function</span> <span class="title function_">expandAroundCenter</span>(<span class="params">left, right</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (left &gt;= <span class="number">0</span> &amp;&amp; right &lt; n &amp;&amp; s[left] === s[right]) &#123;</span><br><span class="line">                count++;</span><br><span class="line">                left--;</span><br><span class="line">                right++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">// 奇数长度的回文</span></span><br><span class="line">            <span class="title function_">expandAroundCenter</span>(i, i);</span><br><span class="line">            <span class="comment">// 偶数长度的回文</span></span><br><span class="line">            <span class="title function_">expandAroundCenter</span>(i, i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h4 id="最长回文子串"><a href="#最长回文子串" class="headerlink" title="最长回文子串"></a>最长回文子串</h4><blockquote><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/longest-palindromic-substring/">Leetcode 5. Longest Palindromic Substring</a></p></blockquote><ul><li>题目: 给定一个字符串<code>s</code>，找到其中最长的回文子串</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: s = &quot;babad&quot;</span><br><span class="line">Output: &quot;bab&quot;</span><br><span class="line">Explanation: &quot;aba&quot; is also a valid answer</span><br></pre></td></tr></table></figure><ul><li>解法: 中心扩展法</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 回文的中心可以是一个字符，也可以是两个字符之间的间隔</span><br><span class="line">2. 遍历字符串，每个字符和每两个字符之间都作为回文中心进行扩展</span><br><span class="line">3. 在扩展过程中，更新最长的回文子串的起始位置和长度</span><br><span class="line">4. 时间复杂度 O(n^2)</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">longestPalindrome</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">expand_around_center</span>(<span class="params">left, right</span>):</span><br><span class="line">            <span class="comment"># 从中心扩展，寻找最长回文</span></span><br><span class="line">            <span class="keyword">while</span> left &gt;= <span class="number">0</span> <span class="keyword">and</span> right &lt; <span class="built_in">len</span>(s) <span class="keyword">and</span> s[left] == s[right]:</span><br><span class="line">                left -= <span class="number">1</span></span><br><span class="line">                right += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> s[left + <span class="number">1</span>:right]</span><br><span class="line"></span><br><span class="line">        longest = <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">            <span class="comment"># 奇数长度回文</span></span><br><span class="line">            odd_palindrome = expand_around_center(i, i)</span><br><span class="line">            <span class="comment"># 偶数长度回文</span></span><br><span class="line">            even_palindrome = expand_around_center(i, i + <span class="number">1</span>)</span><br><span class="line">            <span class="comment"># 更新最长回文子串</span></span><br><span class="line">            longest = <span class="built_in">max</span>(longest, odd_palindrome, even_palindrome, key=<span class="built_in">len</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> longest</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">longestPalindrome</span>(<span class="params">s</span>) &#123;</span><br><span class="line">        <span class="keyword">function</span> <span class="title function_">expandAroundCenter</span>(<span class="params">left, right</span>) &#123;</span><br><span class="line">            <span class="comment">// 从中心扩展，寻找最长回文</span></span><br><span class="line">            <span class="keyword">while</span> (left &gt;= <span class="number">0</span> &amp;&amp; right &lt; s.<span class="property">length</span> &amp;&amp; s[left] === s[right]) &#123;</span><br><span class="line">                left--;</span><br><span class="line">                right++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> s.<span class="title function_">substring</span>(left + <span class="number">1</span>, right);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> longest = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; s.<span class="property">length</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 奇数长度回文</span></span><br><span class="line">            <span class="keyword">const</span> oddPalindrome = <span class="title function_">expandAroundCenter</span>(i, i);</span><br><span class="line">            <span class="comment">// 偶数长度回文</span></span><br><span class="line">            <span class="keyword">const</span> evenPalindrome = <span class="title function_">expandAroundCenter</span>(i, i + <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 更新最长回文子串</span></span><br><span class="line">            <span class="keyword">if</span> (oddPalindrome.<span class="property">length</span> &gt; longest.<span class="property">length</span>) longest = oddPalindrome;</span><br><span class="line">            <span class="keyword">if</span> (evenPalindrome.<span class="property">length</span> &gt; longest.<span class="property">length</span>) longest = evenPalindrome;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> longest;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h4 id="大数相加"><a href="#大数相加" class="headerlink" title="大数相加"></a>大数相加</h4><blockquote><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/add-strings/">Leetcode 415. Add Strings</a></p></blockquote><ul><li>题目: 给定两个非负整数<code>num1</code>和<code>num2</code>，以字符串的形式表示，返回它们的和，结果也用字符串表示。不能直接使用大整数库或将输入直接转换为整数</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: num1 = &quot;11&quot;, num2 = &quot;123&quot;</span><br><span class="line">Output: &quot;134&quot;</span><br></pre></td></tr></table></figure><ul><li>解法: 模拟逐位相加</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 从字符串末尾开始，逐位相加，记录进位</span><br><span class="line">2. 如果一个字符串较短，用零补齐</span><br><span class="line">3. 将每位的计算结果插入到最终结果的前面</span><br><span class="line">4. 如果最终还有进位，追加到结果</span><br><span class="line">5. 返回拼接的结果字符串</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">addStrings</span>(<span class="params">self, num1: <span class="built_in">str</span>, num2: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="comment"># 初始化指针和变量</span></span><br><span class="line">        i, j = <span class="built_in">len</span>(num1) - <span class="number">1</span>, <span class="built_in">len</span>(num2) - <span class="number">1</span></span><br><span class="line">        carry = <span class="number">0</span></span><br><span class="line">        result = []</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 从右向左逐位相加</span></span><br><span class="line">        <span class="keyword">while</span> i &gt;= <span class="number">0</span> <span class="keyword">or</span> j &gt;= <span class="number">0</span> <span class="keyword">or</span> carry:</span><br><span class="line">            n1 = <span class="built_in">int</span>(num1[i]) <span class="keyword">if</span> i &gt;= <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            n2 = <span class="built_in">int</span>(num2[j]) <span class="keyword">if</span> j &gt;= <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            total = n1 + n2 + carry</span><br><span class="line"></span><br><span class="line">            carry  = total // <span class="number">10</span> <span class="comment"># 计算进位</span></span><br><span class="line">            result.append(<span class="built_in">str</span>(total % <span class="number">10</span>))</span><br><span class="line"></span><br><span class="line">            i -= <span class="number">1</span></span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(result[::-<span class="number">1</span>]) <span class="comment"># 翻转并拼接结果</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">addStrings</span>(<span class="params">num1, num2</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> i = num1.<span class="property">length</span> - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">let</span> j = num2.<span class="property">length</span> - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">let</span> carry = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">let</span> result = [];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从右向左逐位相加</span></span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span> || carry) &#123;</span><br><span class="line">            <span class="keyword">const</span> n1 = i &gt;= <span class="number">0</span> ? <span class="built_in">parseInt</span>(num1[i]) : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">const</span> n2 = j &gt;= <span class="number">0</span> ? <span class="built_in">parseInt</span>(num2[j]) : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">const</span> total = n1 + n2 + carry;</span><br><span class="line"></span><br><span class="line">            carry = <span class="title class_">Math</span>.<span class="title function_">floor</span>(total / <span class="number">10</span>); <span class="comment">// 计算进位</span></span><br><span class="line">            result.<span class="title function_">push</span>(total % <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">            i--;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result.<span class="title function_">reverse</span>().<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>); <span class="comment">// 翻转并拼接结果</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h3 id="Backtrack-回溯"><a href="#Backtrack-回溯" class="headerlink" title="Backtrack 回溯"></a><code>Backtrack</code> 回溯</h3><h4 id="全排列（无重复元素）"><a href="#全排列（无重复元素）" class="headerlink" title="全排列（无重复元素）"></a>全排列（无重复元素）</h4><blockquote><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/permutations/">Leetcode 46. Permutations</a></p></blockquote><ul><li>题目: 给定一个不包含重复的数组<code>nums</code>，返回数组的所有可能的排列，不包含重复</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: nums = [1,2,3]</span><br><span class="line">Output: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</span><br></pre></td></tr></table></figure><ul><li>解法: 回溯算法</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 初始化一个空路径 path 和一个 used 数组用于标记是否使用过某元素</span><br><span class="line">2. 遍历数组，对未使用的元素进行选择，加入路径</span><br><span class="line">3. 如果路径长度等于数组长度，将当前路径加入结果</span><br><span class="line">4. 撤销选择，尝试其他未使用的元素</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">permute</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        result = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">path, used</span>):</span><br><span class="line">            <span class="comment"># 如果路径长度等于数组长度，加入结果</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(path) == <span class="built_in">len</span>(nums):</span><br><span class="line">                result.append(path[:]) <span class="comment"># 深拷贝当前路径</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">                <span class="keyword">if</span> used[i]:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">                <span class="comment"># 做选择</span></span><br><span class="line">                path.append(nums[i])</span><br><span class="line">                used[i] = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">                <span class="comment"># 递归</span></span><br><span class="line">                backtrack(path, used)</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 撤销选择</span></span><br><span class="line">                path.pop()</span><br><span class="line">                used[i] = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        backtrack([], [<span class="literal">False</span>] * <span class="built_in">len</span>(nums))</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">permute</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> result = [];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">function</span> <span class="title function_">backtrack</span>(<span class="params">path, used</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果路径长度等于数组长度，加入结果</span></span><br><span class="line">            <span class="keyword">if</span> (path.<span class="property">length</span> === nums.<span class="property">length</span>) &#123;</span><br><span class="line">                result.<span class="title function_">push</span>([...path]); <span class="comment">// 深拷贝当前路径</span></span><br><span class="line">                <span class="keyword">return</span>; </span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.<span class="property">length</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (used[i]) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 做选择</span></span><br><span class="line">                path.<span class="title function_">push</span>(nums[i]);</span><br><span class="line">                used[i] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 递归</span></span><br><span class="line">                <span class="title function_">backtrack</span>(path, used);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 撤销选择</span></span><br><span class="line">                path.<span class="title function_">pop</span>();</span><br><span class="line">                used[i] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="title function_">backtrack</span>([], <span class="title class_">Array</span>(nums.<span class="property">length</span>).<span class="title function_">fill</span>(<span class="literal">false</span>));</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h4 id="全排列（有重复元素）"><a href="#全排列（有重复元素）" class="headerlink" title="全排列（有重复元素）"></a>全排列（有重复元素）</h4><blockquote><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/permutations-ii/">Leetcode 47. Permutations II</a></p></blockquote><ul><li>题目: 给定一个可能包含重复数字的数组<code>nums</code>，返回数组的所有不重复的排列</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: nums = [1,1,2]</span><br><span class="line">Output:</span><br><span class="line">[[1,1,2],</span><br><span class="line"> [1,2,1],</span><br><span class="line"> [2,1,1]]</span><br></pre></td></tr></table></figure><ul><li>解法: 回溯算法 + 去重</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 对 nums 排序，使得相同的数字相邻，方便去重</span><br><span class="line">2. 在回溯过程中，跳过当前数字与前一个数字相同且前一个数字未被使用的情况</span><br><span class="line">3. 构建排列路径，记录已使用数字</span><br><span class="line">4. 撤销选择，尝试其他未使用的数字</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">permuteUnique</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        result = []</span><br><span class="line">        nums.sort() <span class="comment"># 排序以便去重</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">path, used</span>):</span><br><span class="line">            <span class="comment"># 如果路径长度等于数组长度，加入结果</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(path) == <span class="built_in">len</span>(nums):</span><br><span class="line">                result.append(path[:])</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">                <span class="comment"># 如果数字已使用，跳过</span></span><br><span class="line">                <span class="keyword">if</span> used[i]:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">                <span class="comment"># 去重：当前数字与前一个数字相同，且前一个数字未被使用</span></span><br><span class="line">                <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i - <span class="number">1</span>] <span class="keyword">and</span> <span class="keyword">not</span> used[i - <span class="number">1</span>]:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">                <span class="comment"># 做选择</span></span><br><span class="line">                path.append(nums[i])</span><br><span class="line">                used[i] = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">                <span class="comment"># 递归</span></span><br><span class="line">                backtrack(path, used)</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 撤销选择</span></span><br><span class="line">                path.pop()</span><br><span class="line">                used[i] = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        backtrack([], [<span class="literal">False</span>] * <span class="built_in">len</span>(nums))</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">permuteUnique</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> result = [];</span><br><span class="line">        nums.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b); <span class="comment">// 排序以便去重</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">function</span> <span class="title function_">backtrack</span>(<span class="params">path, used</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果路径长度等于数组长度，加入结果</span></span><br><span class="line">            <span class="keyword">if</span> (path.<span class="property">length</span> === nums.<span class="property">length</span>) &#123;</span><br><span class="line">                result.<span class="title function_">push</span>([...path]); <span class="comment">// 深拷贝路径</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.<span class="property">length</span>; i++) &#123;</span><br><span class="line">                <span class="comment">// 如果数字已使用，跳过</span></span><br><span class="line">                <span class="keyword">if</span> (used[i]) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 去重：当前数字与前一个数字相同，且前一个数字未被使用</span></span><br><span class="line">                <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] === nums[i - <span class="number">1</span>] &amp;&amp; !used[i - <span class="number">1</span>])</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 做选择</span></span><br><span class="line">                path.<span class="title function_">push</span>(nums[i]);</span><br><span class="line">                used[i] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 递归</span></span><br><span class="line">                <span class="title function_">backtrack</span>(path, used);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 撤销选择</span></span><br><span class="line">                path.<span class="title function_">pop</span>();</span><br><span class="line">                used[i] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="title function_">backtrack</span>([], <span class="title class_">Array</span>(nums.<span class="property">length</span>).<span class="title function_">fill</span>(<span class="literal">false</span>));</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h3 id="Dynamic-Programming"><a href="#Dynamic-Programming" class="headerlink" title="Dynamic Programming"></a><code>Dynamic Programming</code></h3><h4 id="分割等和子集"><a href="#分割等和子集" class="headerlink" title="分割等和子集"></a>分割等和子集</h4><blockquote><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/partition-equal-subset-sum/">Leetcode 416. Partition Equal Subset Sum</a></p></blockquote><ul><li>题目: 给定一个非空正整数数组<code>nums</code>，判断是否可以将这个数组分割为两个子集，使得两个子集的元素和相等</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: nums = [1,5,11,5]</span><br><span class="line">Output: true</span><br><span class="line">Explanation: The array can be partitioned as [1, 5, 5] and [11]</span><br></pre></td></tr></table></figure><ul><li>解法: 动态规划（背包问题）</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 目标是找到一个子集，使其和等于总和的一半</span><br><span class="line">2. 如果数组总和为奇数，直接返回 False</span><br><span class="line">3. 定义 dp[i] 表示是否存在一个子集，使得这个子集的和为 i</span><br><span class="line">4. 初始化 dp[0] = True（空集的和为 0 总是成立）</span><br><span class="line">5. 遍历数组中的每个数，从 target（总和的一半）开始向下更新 dp 数组</span><br><span class="line">6. 对于每个数 num 和当前的和 i，如果 dp[i - num] 为 True，则 dp[i] 也为 True</span><br><span class="line">7. 最终检查 dp[target] 是否为 True</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">canPartition</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        total_sum = <span class="built_in">sum</span>(nums)</span><br><span class="line">        <span class="keyword">if</span> total_sum % <span class="number">2</span> != <span class="number">0</span>: <span class="comment"># 如果总和是奇数，无法平分</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        target = total_sum // <span class="number">2</span></span><br><span class="line">        dp = [<span class="literal">False</span>] * (target + <span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="literal">True</span> <span class="comment"># 和为 0 的子集总是存在</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(target, num - <span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                dp[i] = dp[i] <span class="keyword">or</span> dp[i - num]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[target]</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">canPartition</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> totalSum = nums.<span class="title function_">reduce</span>(<span class="function">(<span class="params">acc, num</span>) =&gt;</span> acc + num, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (totalSum % <span class="number">2</span> !== <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 如果总和是奇数，无法平分</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> target = totalSum / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">const</span> dp = <span class="title class_">Array</span>(target + <span class="number">1</span>).<span class="title function_">fill</span>(<span class="literal">false</span>);</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="literal">true</span>; <span class="comment">// 和为 0 的子集总是存在</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> num <span class="keyword">of</span> nums) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = target; i &gt;= num; i--) &#123;</span><br><span class="line">                dp[i] = dp[i] || dp[i - num];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h4 id="组成目标和"><a href="#组成目标和" class="headerlink" title="组成目标和"></a>组成目标和</h4><blockquote><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/target-sum/">Leetcode 494. Target Sum</a></p></blockquote><ul><li>题目: 给定一个数组<code>nums</code>，可以为每个元素加上<code>+</code>或<code>-</code>符号，问有多少种不同的方式使得总和等于目标值<code>target</code></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: nums = [1,1,1,1,1], target = 3</span><br><span class="line">Output: 5</span><br><span class="line">Explanation: There are 5 ways to assign symbols to make the sum of nums be target 3</span><br><span class="line">-1 + 1 + 1 + 1 + 1 = 3</span><br><span class="line">+1 - 1 + 1 + 1 + 1 = 3</span><br><span class="line">+1 + 1 - 1 + 1 + 1 = 3</span><br><span class="line">+1 + 1 + 1 - 1 + 1 = 3</span><br><span class="line">+1 + 1 + 1 + 1 - 1 = 3</span><br></pre></td></tr></table></figure><ul><li>解法: 动态规划</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 将问题转换为子集问题，设 P 是正号部分，N 是负号部分</span><br><span class="line">2. 方程联立：P - N = target 和 P + N = sum(nums) 得到 P = (target + sum(nums)) / 2</span><br><span class="line">3. 如果 (target + sum(nums)) 不是偶数或 target 超过 sum(nums)，返回 0</span><br><span class="line">4. 定义 dp[i] 表示和为 i 的子集数，初始化 dp[0] = 1</span><br><span class="line">5. 遍历数组中的每个数，倒序更新 dp 数组</span><br><span class="line">6. dp[subset_sum] 即为结果</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findTargetSumWays</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        total_sum = <span class="built_in">sum</span>(nums)</span><br><span class="line">        <span class="comment"># 如果目标值无法分割为两部分，返回 </span></span><br><span class="line">        <span class="keyword">if</span> (target + total_sum) % <span class="number">2</span> != <span class="number">0</span> <span class="keyword">or</span> total_sum &lt; <span class="built_in">abs</span>(target):</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 转换为子集和问题</span></span><br><span class="line">        subset_sum = (target + total_sum) // <span class="number">2</span></span><br><span class="line">        <span class="comment"># dp[i] 表示和为 i 的子集数</span></span><br><span class="line">        dp = [<span class="number">0</span>] * (subset_sum + <span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span> <span class="comment"># 和为 0 的子集数为 1（空集）</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="comment"># 从后向前更新 dp 数组</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(subset_sum, num - <span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                dp[i] += dp[i - num]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[subset_sum]</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">findTargetSumWays</span>(<span class="params">nums, target</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> totalSum = nums.<span class="title function_">reduce</span>(<span class="function">(<span class="params">acc, num</span>) =&gt;</span> acc + num, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 如果目标值无法分割为两部分，返回 0</span></span><br><span class="line">        <span class="keyword">if</span> ((target + totalSum) % <span class="number">2</span> !== <span class="number">0</span> || totalSum &lt; <span class="title class_">Math</span>.<span class="title function_">abs</span>(target))</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 转换为子集和问题</span></span><br><span class="line">        <span class="keyword">const</span> subsetSum = (target + totalSum) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">const</span> dp = <span class="keyword">new</span> <span class="title class_">Array</span>(subsetSum + <span class="number">1</span>).<span class="title function_">fill</span>(<span class="number">0</span>);</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>; <span class="comment">// 和为 0 的子集数为 1（空集）</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> num <span class="keyword">of</span> nums) &#123;</span><br><span class="line">            <span class="comment">// 从后向前更新 dp 数组</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = subsetSum; i &gt;= num; i--) &#123;</span><br><span class="line">                dp[i] += dp[i - num];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[subsetSum];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h4 id="跳跃游戏"><a href="#跳跃游戏" class="headerlink" title="跳跃游戏"></a>跳跃游戏</h4><blockquote><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/jump-game/">Leetcode 55. Jump Game</a></p></blockquote><ul><li>题目: 给定一个非负整数数组<code>nums</code>，每个元素表示在该位置上最多可以跳跃的步数。判断是否能够从数组的第一个位置跳到最后一个位置</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: nums = [2,3,1,1,4]</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><ul><li>解法: 贪心算法</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 初始化变量 maxReach 记录当前能到达的最远位置</span><br><span class="line">2. 遍历数组</span><br><span class="line">    - 如果当前位置 i 超过 maxReach，返回 False，表示无法跳到该位置</span><br><span class="line">    - 更新 maxReach 为 max(maxReach, i + nums[i])</span><br><span class="line">3. 遍历结束后，如果未返回 False，说明可以到达终点</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">canJump</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        max_reach = <span class="number">0</span> <span class="comment"># 初始化能够到达的最远位置</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="comment"># 如果当前位置超过了最远可达位置，返回 False</span></span><br><span class="line">            <span class="keyword">if</span> i &gt; max_reach:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 更新最远可达位置</span></span><br><span class="line">            max_reach = <span class="built_in">max</span>(max_reach, i + nums[i])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">canJump</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> maxReach = <span class="number">0</span>; <span class="comment">// 初始化能够到达的最远位置</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.<span class="property">length</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 如果当前位置超过了最远可达位置，返回 false</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; maxReach) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 更新最远可达位置</span></span><br><span class="line">            maxReach = <span class="title class_">Math</span>.<span class="title function_">max</span>(maxReach, i + nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h4 id="最小跳跃次数"><a href="#最小跳跃次数" class="headerlink" title="最小跳跃次数"></a>最小跳跃次数</h4><blockquote><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/jump-game-ii/">Leetcode 45. Jump Game II</a></p></blockquote><ul><li>题目: 给定一个非负整数数组<code>nums</code>，每个元素表示在该位置上最多可以跳跃的步数。求从数组的第一个位置跳到最后一个位置所需的最小跳跃次数</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: nums = [2,3,1,1,4]</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure><ul><li>解法: 贪心算法</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 初始化 jumps（跳跃次数），current_end（当前跳跃的边界），farthest（能跳到的最远位置）</span><br><span class="line">2. 遍历数组，更新 farthest 为 max(farthest, i + nums[i])</span><br><span class="line">3. 当到达 current_end 时，增加跳跃次数，并更新 current_end 为 farthest</span><br><span class="line">4. 遍历结束返回 jumps</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">jump</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        jumps = <span class="number">0</span> <span class="comment"># 跳跃次数</span></span><br><span class="line">        current_end = <span class="number">0</span> <span class="comment"># 当前跳跃的边界</span></span><br><span class="line">        farthest = <span class="number">0</span> <span class="comment"># 当前能跳到的最远位置</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums) - <span class="number">1</span>): <span class="comment"># 最后一个元素不需要遍历</span></span><br><span class="line">            farthest = <span class="built_in">max</span>(farthest, i + nums[i])</span><br><span class="line">            <span class="keyword">if</span> i == current_end: <span class="comment"># 到达当前跳跃的边界</span></span><br><span class="line">                jumps += <span class="number">1</span></span><br><span class="line">                current_end = farthest</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> jumps</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">jump</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> jumps = <span class="number">0</span>; <span class="comment">// 跳跃次数</span></span><br><span class="line">        <span class="keyword">let</span> currentEnd = <span class="number">0</span>; <span class="comment">// 当前跳跃的边界</span></span><br><span class="line">        <span class="keyword">let</span> farthest = <span class="number">0</span>; <span class="comment">// 当前能跳到的最远位置</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.<span class="property">length</span> - <span class="number">1</span>; i++) &#123; <span class="comment">// 最后一个元素不需要遍历</span></span><br><span class="line">            farthest = <span class="title class_">Math</span>.<span class="title function_">max</span>(farthest, i + nums[i]);</span><br><span class="line">            <span class="keyword">if</span> (i === currentEnd) &#123;</span><br><span class="line">                jumps++;</span><br><span class="line">                currentEnd = farthest;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> jumps;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h4 id="买卖股票的最佳时机"><a href="#买卖股票的最佳时机" class="headerlink" title="买卖股票的最佳时机"></a>买卖股票的最佳时机</h4><blockquote><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock/">Leetcode 121. Best Time to Buy and Sell Stock</a></p></blockquote><ul><li>题目: 给定一个整数数组<code>prices</code>，其中<code>prices[i]</code>表示某天的股票价格。只允许完成一笔交易（买入和卖出），求最大利润。如果无法获得利润，返回<code>0</code></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: prices = [7,1,5,3,6,4]</span><br><span class="line">Output: 5</span><br><span class="line">Explanation: 在价格为1时买入，价格为6时卖出，利润为6-1=5</span><br></pre></td></tr></table></figure><ul><li>解法: 贪心算法</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 初始化最小买入价格为无穷大，最大利润为 0</span><br><span class="line">2. 遍历价格数组</span><br><span class="line">    - 如果当前价格小于最小买入价格，更新最小买入价格</span><br><span class="line">    - 如果当前价格减去最小买入价格的利润大于最大利润，更新最大利润</span><br><span class="line">3. 返回最大利润</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxProfit</span>(<span class="params">self, prices: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        min_price = <span class="built_in">float</span>(<span class="string">&quot;inf&quot;</span>) <span class="comment"># 最小买入价格</span></span><br><span class="line">        max_profit = <span class="number">0</span> <span class="comment"># 最大利润</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> price <span class="keyword">in</span> prices:</span><br><span class="line">            <span class="comment"># 更新最小买入价格</span></span><br><span class="line">            <span class="keyword">if</span> price &lt; min_price:</span><br><span class="line">                min_price = price</span><br><span class="line">            <span class="comment"># 计算当前利润，并更新最大利润</span></span><br><span class="line">            <span class="keyword">elif</span> price - min_price &gt; max_profit:</span><br><span class="line">                max_profit = price - min_price</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> max_profit</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">maxProfit</span>(<span class="params">prices</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> minPrice = <span class="title class_">Infinity</span>; <span class="comment">// 最小买入价格</span></span><br><span class="line">        <span class="keyword">let</span> maxProfit = <span class="number">0</span>; <span class="comment">// 最大利润</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> price <span class="keyword">of</span> prices) &#123;</span><br><span class="line">            <span class="comment">// 更新最小买入价格</span></span><br><span class="line">            <span class="keyword">if</span> (price &lt; minPrice) </span><br><span class="line">                minPrice = price;</span><br><span class="line">            <span class="comment">// 计算当前利润，并更新最大利润</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (price - minPrice &gt; maxProfit)</span><br><span class="line">                maxProfit = price - minPrice;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> maxProfit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h4 id="股票买卖的最大收益"><a href="#股票买卖的最大收益" class="headerlink" title="股票买卖的最大收益"></a>股票买卖的最大收益</h4><blockquote><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/">Leetcode 122. Best Time to Buy and Sell Stock II</a></p></blockquote><ul><li>题目: 给定一个数组，<code>prices[i]</code>表示第<code>i</code>天的股票价格。可以进行多次买卖操作（但必须先卖掉之前的股票后才能再次购买），求能获得的最大利润</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: prices = [7,1,5,3,6,4]</span><br><span class="line">Output: 7</span><br><span class="line">Explanation: 在第2天买入（价格=1），第3天卖出（价格=5），收益=5-1=4；然后在第4天买入（价格=3），第5天卖出（价格=6），收益=6-3=3，总收益为7</span><br></pre></td></tr></table></figure><ul><li>解法: 贪心算法</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 遍历价格数组，检查是否存在连续上涨的价格差</span><br><span class="line">2. 如果今天的价格高于昨天的价格，将差值累加到最大利润中</span><br><span class="line">3. 遍历完成后，返回最大利润</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxProfit</span>(<span class="params">self, prices: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        max_profit = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(prices)):</span><br><span class="line">            <span class="comment"># 如果今天的价格比昨天高，累加差值到利润中</span></span><br><span class="line">            <span class="keyword">if</span> prices[i] &gt; prices[i - <span class="number">1</span>]:</span><br><span class="line">                max_profit += prices[i] - prices[i - <span class="number">1</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> max_profit</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">maxProfit</span>(<span class="params">prices</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> maxProfit = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; prices.<span class="property">length</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 如果今天的价格比昨天高，累加差值到利润中</span></span><br><span class="line">            <span class="keyword">if</span> (prices[i] &gt; prices[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                maxProfit += prices[i] - prices[i - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> maxProfit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h4 id="不同路径的数目"><a href="#不同路径的数目" class="headerlink" title="不同路径的数目"></a>不同路径的数目</h4><blockquote><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/unique-paths/">Leetcode 62. Unique Paths</a></p></blockquote><ul><li>题目: 一个机器人位于一个<code>m x n</code>网格的左上角 (起点在<code>(0, 0)</code>)。机器人每次只能向下或向右移动一步。网格的右下角在<code>(m-1, n-1)</code>。问有多少条不同的路径可以到达终点</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: m = 3, n = 7</span><br><span class="line">Output: 28</span><br></pre></td></tr></table></figure><ul><li>解法: 动态规划</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 定义 dp 数组，dp[i][j] 表示到达网格 (i, j) 的路径数量</span><br><span class="line">2. 初始状态: dp[0][j] 和 dp[i][0] 都为 1（第一行和第一列的路径数量都为 1）</span><br><span class="line">3. 状态转移方程: dp[i][j] = dp[i-1][j] + dp[i][j-1]</span><br><span class="line">4. 返回 dp[m-1][n-1]</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">uniquePaths</span>(<span class="params">self, m: <span class="built_in">int</span>, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 初始化 dp 数组，所有值为 1</span></span><br><span class="line">        dp = [[<span class="number">1</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m)]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 填充 dp 表格</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>]</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">uniquePaths</span>(<span class="params">m, n</span>) &#123;</span><br><span class="line">        <span class="comment">// 初始化 dp 数组，所有值为 1</span></span><br><span class="line">        <span class="keyword">const</span> dp = <span class="title class_">Array</span>.<span class="title function_">from</span>(&#123;<span class="attr">length</span>: m&#125;, <span class="function">() =&gt;</span> <span class="title class_">Array</span>(n).<span class="title function_">fill</span>(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 填充 dp 表格</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h4 id="最大连续和"><a href="#最大连续和" class="headerlink" title="最大连续和"></a>最大连续和</h4><blockquote><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/maximum-subarray/">Leetcode 53. Maximum Subarray</a></p></blockquote><ul><li>题目: 给定一个整数数组<code>nums</code>，找到具有最大和的连续子数组（至少包含一个元素），返回其最大和</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: nums = [-2,1,-3,4,-1,2,1,-5,4]</span><br><span class="line">Output: 6</span><br><span class="line">Explanation: [4,-1,2,1] has the largest sum = 6</span><br></pre></td></tr></table></figure><ul><li>解法: 动态规划</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 定义 dp[i] 表示以 nums[i] 结尾的最大子数组和</span><br><span class="line">2. 状态转移方程:</span><br><span class="line">   dp[i] = max(nums[i], dp[i-1] + nums[i])</span><br><span class="line">   即当前位置的最大和，要么是当前数字本身，要么是当前数字加上前面的最大和</span><br><span class="line">3. 初始化: dp[0] = nums[0]</span><br><span class="line">4. 遍历数组，计算每个位置的 dp 值，并记录最大值</span><br><span class="line">5. 时间复杂度 O(n)，空间复杂度 O(1)（通过优化只保留当前值）</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxSubArray</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 初始化当前最大和和全局最大和</span></span><br><span class="line">        current_sum = max_sum = nums[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums[<span class="number">1</span>:]:</span><br><span class="line">            <span class="comment"># 当前和为当前数字或当前数字加之前的和</span></span><br><span class="line">            current_sum = <span class="built_in">max</span>(num, current_sum + num)</span><br><span class="line">            <span class="comment"># 更新全局最大和</span></span><br><span class="line">            max_sum = <span class="built_in">max</span>(max_sum, current_sum)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> max_sum</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">maxSubArray</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">        <span class="comment">// 初始化当前最大和和全局最大和</span></span><br><span class="line">        <span class="keyword">let</span> currentSum = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">let</span> maxSum = nums[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; nums.<span class="property">length</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 当前和为当前数字或当前数字加之前的和</span></span><br><span class="line">            currentSum = <span class="title class_">Math</span>.<span class="title function_">max</span>(nums[i], currentSum + nums[i]);</span><br><span class="line">            <span class="comment">// 更新全局最大和</span></span><br><span class="line">            maxSum = <span class="title class_">Math</span>.<span class="title function_">max</span>(maxSum, currentSum);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> maxSum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h4 id="最长公共子串"><a href="#最长公共子串" class="headerlink" title="最长公共子串"></a>最长公共子串</h4><blockquote><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/longest-common-subsequence/">Leetcode 1143. Longest Common Subsequence</a></p></blockquote><ul><li>题目: 给定两个字符串<code>text1</code>和<code>text2</code>，返回它们最长公共子序列的长度。如果不存在公共子序列，则返回<code>0</code></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: text1 = &quot;abcde&quot;, text2 = &quot;ace&quot;</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: The longest common subsequence is &quot;ace&quot; and its length is 3</span><br></pre></td></tr></table></figure><ul><li>解法: 动态规划</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 定义 dp[i][j]:</span><br><span class="line">   - dp[i][j] 表示 text1 前 i 个字符和 text2 前 j 个字符的最长公共子序列长度</span><br><span class="line">2. 转移方程:</span><br><span class="line">   - 如果 text1[i-1] == text2[j-1]，则 dp[i][j] = dp[i-1][j-1] + 1</span><br><span class="line">   - 否则，dp[i][j] = max(dp[i-1][j], dp[i][j-1])</span><br><span class="line">3. 初始化:</span><br><span class="line">   - dp[0][j] = 0 和 dp[i][0] = 0，因为空字符串与任何字符串的公共子序列长度为 0</span><br><span class="line">4. 遍历:</span><br><span class="line">   - 填充整个 dp 表，并返回 dp[m][n]，其中 m 和 n 是 text1 和 text2 的长度</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">longestCommonSubsequence</span>(<span class="params">self, text1: <span class="built_in">str</span>, text2: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        m, n = <span class="built_in">len</span>(text1), <span class="built_in">len</span>(text2)</span><br><span class="line">        <span class="comment"># 创建 dp 数组并初始化</span></span><br><span class="line">        dp = [[<span class="number">0</span>] * (n + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m + <span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 遍历两个字符串的所有前缀组合</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> text1[i - <span class="number">1</span>] == text2[j - <span class="number">1</span>]:</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[m][n]</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">longestCommonSubsequence</span>(<span class="params">text1, text2</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> m = text1.<span class="property">length</span>, n = text2.<span class="property">length</span>;</span><br><span class="line">        <span class="comment">// 创建 dp 数组并初始化</span></span><br><span class="line">        <span class="keyword">const</span> dp = <span class="title class_">Array</span>.<span class="title function_">from</span>(&#123;<span class="attr">length</span>: m + <span class="number">1</span>&#125;, <span class="function">() =&gt;</span> <span class="title class_">Array</span>(n + <span class="number">1</span>).<span class="title function_">fill</span>(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历两个字符串的所有前缀组合</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (text1[i - <span class="number">1</span>] === text2[j - <span class="number">1</span>])</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp[i][j] = <span class="title class_">Math</span>.<span class="title function_">max</span>(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h3 id="Other-其他"><a href="#Other-其他" class="headerlink" title="Other 其他"></a><code>Other</code> 其他</h3><h4 id="二维数组去重"><a href="#二维数组去重" class="headerlink" title="二维数组去重"></a>二维数组去重</h4><ul><li>题目: 给定一个二维数组，可能包含重复的行，实现一个方法去重，返回去重后的二维数组</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">matrix = [</span><br><span class="line">    [1, 2, 3],</span><br><span class="line">    [1, 2, 3],</span><br><span class="line">    [4, 5, 6]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"># 输出: [(1, 2, 3), (4, 5, 6)]</span><br></pre></td></tr></table></figure><ul><li>解法<code>1</code>: 不保留顺序</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">将每一行转化为不可变类型</span><br><span class="line">    在 Python 中使用 tuple</span><br><span class="line">    在 JavaScript 中使用 JSON.stringify</span><br><span class="line">利用 Set 的特性去重</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">remove_duplicates</span>(<span class="params">matrix</span>):</span><br><span class="line">        <span class="comment"># 将每一行转化为元组并用 set 去重</span></span><br><span class="line">        unique_rows = <span class="built_in">set</span>(<span class="built_in">tuple</span>(row) <span class="keyword">for</span> row <span class="keyword">in</span> matrix)</span><br><span class="line">        <span class="comment"># 将去重后的结果转回列表形式</span></span><br><span class="line">        <span class="keyword">return</span> [<span class="built_in">list</span>(row) <span class="keyword">for</span> row <span class="keyword">in</span> unique_rows]</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">removeDuplicates</span>(<span class="params">matrix</span>) &#123;</span><br><span class="line">        <span class="comment">// 使用 Set 去重，将每一行转换为字符串</span></span><br><span class="line">        <span class="keyword">const</span> uniqueRows = <span class="keyword">new</span> <span class="title class_">Set</span>(matrix.<span class="title function_">map</span>(<span class="function"><span class="params">row</span> =&gt;</span> <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(rows)));</span><br><span class="line">        <span class="comment">// 将字符串还原为数组</span></span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Array</span>.<span class="title function_">from</span>(uniqueRows, <span class="function"><span class="params">row</span> =&gt;</span> <span class="title class_">JSON</span>.<span class="title function_">parse</span>(row));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><ul><li>解法<code>2</code>: 保留顺序</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">使用 Set 跟踪已经处理的行</span><br><span class="line">遍历二维数组，检查每一行是否已在 Set 中</span><br><span class="line">    如果未出现过，则添加到结果数组中，并将其标记为已处理</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">remove_duplicates_with_order</span>(<span class="params">matrix</span>):</span><br><span class="line">        seen = <span class="built_in">set</span>()</span><br><span class="line">        unique_rows = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> matrix:</span><br><span class="line">            row_tuple = <span class="built_in">tuple</span>(row)</span><br><span class="line">            <span class="keyword">if</span> row_tuple <span class="keyword">not</span> <span class="keyword">in</span> seen: <span class="comment"># 如果该行尚未处理</span></span><br><span class="line">                seen.add(row_tuple) <span class="comment"># 标记为已处理</span></span><br><span class="line">                unique_rows.append(row) <span class="comment"># 添加到结果中</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> unique_rows</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">removeDuplicatesWithOrder</span>(<span class="params">matrix</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> seen = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line">        <span class="keyword">const</span> uniqueRows = [];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> row <span class="keyword">of</span> matrix) &#123;</span><br><span class="line">            <span class="keyword">const</span> rowString = <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(row); <span class="comment">// 将行转化为字符串</span></span><br><span class="line">            <span class="keyword">if</span> (!seen.<span class="title function_">has</span>(rowString)) &#123;</span><br><span class="line">                seen.<span class="title function_">add</span>(rowString);</span><br><span class="line">                uniqueRows.<span class="title function_">push</span>(row);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> uniqueRows;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h4 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">斐波那契数列的定义是</span><br><span class="line">    F(0) = 0</span><br><span class="line">    F(1) = 1</span><br><span class="line">    对于 n &gt;= 2，F(n) = F(n-1) + F(n-2)</span><br><span class="line"></span><br><span class="line">数列前几项为</span><br><span class="line">    0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...</span><br></pre></td></tr></table></figure><ul><li>解法<code>1</code>: 递归</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">按照定义，递归计算每个斐波那契数</span><br><span class="line">优点：实现简单，代码清晰</span><br><span class="line">缺点：存在大量重复计算，效率较低</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fibonacci</span>(<span class="params">n</span>):</span><br><span class="line">        <span class="keyword">if</span> n &lt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">elif</span> n == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> fibonacci(n - <span class="number">1</span>) + fibonacci(n - <span class="number">2</span>)</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">fibonacci</span>(<span class="params">n</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (n === <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">fibonacci</span>(n - <span class="number">1</span>) + <span class="title function_">fibonacci</span>(n - <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><ul><li>解法<code>2</code>: 动态规划</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">使用两个变量存储前两个数值，避免重复计算</span><br><span class="line">从 F(2) 开始循环计算，最终返回 F(n)</span><br><span class="line">优点：时间复杂度 O(n)，空间复杂度 O(1)</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fibonacci</span>(<span class="params">n</span>):</span><br><span class="line">        <span class="keyword">if</span> n &lt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">elif</span> n == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        prev2, prev1 = <span class="number">0</span>, <span class="number">1</span> <span class="comment"># 初始值</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n + <span class="number">1</span>):</span><br><span class="line">            curr = prev1 + prev2 </span><br><span class="line">            prev2 = prev1  <span class="comment"># 更新前两个数</span></span><br><span class="line">            prev1 = curr</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> prev1</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">fibonacci</span>(<span class="params">n</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (n === <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> prev2 = <span class="number">0</span>, prev1 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">const</span> curr = prev1 + prev2;</span><br><span class="line">            prev2 = prev1;</span><br><span class="line">            prev1 = curr;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> prev1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><table><thead><tr><th>方法</th><th>时间复杂度</th><th>空间复杂度</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>递归</td><td><code>O(2^n)</code></td><td><code>O(n)</code></td><td>简单易理解，适合小问题</td><td>性能差，大量重复计算</td></tr><tr><td>动态规划优化空间</td><td><code>O(n)</code></td><td><code>O(1)</code></td><td>高效，占用空间少</td><td>不保存所有中间结果</td></tr><tr><td>通用迭代</td><td><code>O(n)</code></td><td><code>O(n)</code></td><td>清晰直观，适合扩展</td><td>占用更多空间</td></tr></tbody></table><hr><h4 id="整数反转"><a href="#整数反转" class="headerlink" title="整数反转"></a>整数反转</h4><blockquote><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/reverse-integer/">Leetcode 7. Reverse Integer</a></p></blockquote><ul><li>题目: 给定一个<code>32</code>位有符号整数<code>x</code>，将其数字部分反转<ul><li>如果反转后整数溢出（不在<code>[-2^31, 2^31 - 1]</code>范围内），返回<code>0</code></li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: x = 123</span><br><span class="line">Output: 321</span><br></pre></td></tr></table></figure><ul><li>解法: 逐位反转</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 记录整数的符号（正或负），然后将整数取绝对值，方便处理</span><br><span class="line">2. 通过 取余操作 获取最后一位数字，将其添加到结果中</span><br><span class="line">    - 每次更新结果为 res = res * 10 + digit</span><br><span class="line">    - 再通过整除去掉最后一位数字</span><br><span class="line">3. 反转后乘以原始符号恢复符号</span><br><span class="line">4. 检查是否超出 32 位整数范围，如果超出返回 0</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverse</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 定义 32 位整数范围</span></span><br><span class="line">        INT_MIN, INT_MAX = -(<span class="number">2</span>**<span class="number">31</span>), <span class="number">2</span>**<span class="number">31</span> - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        result = <span class="number">0</span></span><br><span class="line">        sign = -<span class="number">1</span> <span class="keyword">if</span> x &lt; <span class="number">0</span> <span class="keyword">else</span> <span class="number">1</span> <span class="comment"># 记录符号</span></span><br><span class="line">        x = <span class="built_in">abs</span>(x)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> x != <span class="number">0</span>:</span><br><span class="line">            digit = x % <span class="number">10</span> <span class="comment"># 取出最后一位数字</span></span><br><span class="line">            result = result * <span class="number">10</span> + digit <span class="comment"># 更新结果</span></span><br><span class="line">            x //= <span class="number">10</span> <span class="comment"># 去掉最后一位</span></span><br><span class="line"></span><br><span class="line">        result *= sign <span class="comment"># 恢复符号</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> result &lt; INT_MIN <span class="keyword">or</span> result &gt; INT_MAX:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">reverse</span>(<span class="params">x</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="variable constant_">INT_MIN</span> = -(<span class="number">2</span> ** <span class="number">31</span>);</span><br><span class="line">        <span class="keyword">const</span> <span class="variable constant_">INT_MAX</span> = <span class="number">2</span> ** <span class="number">31</span> - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">const</span> sign = x &lt; <span class="number">0</span> ? -<span class="number">1</span> : <span class="number">1</span>;</span><br><span class="line">        x = <span class="title class_">Math</span>.<span class="title function_">abs</span>(x);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (x !== <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> digit = x % <span class="number">10</span>; <span class="comment">// 取出最后一位数字</span></span><br><span class="line">            result = result * <span class="number">10</span> + digit; <span class="comment">// 更新结果</span></span><br><span class="line">            x = <span class="title class_">Math</span>.<span class="title function_">floor</span>(x / <span class="number">10</span>); <span class="comment">// 去掉最后一位</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        result *= sign;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (result &lt; <span class="variable constant_">INT_MIN</span> || result &gt; <span class="variable constant_">INT_MAX</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h4 id="位1的个数"><a href="#位1的个数" class="headerlink" title="位1的个数"></a>位<code>1</code>的个数</h4><blockquote><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/number-of-1-bits/">Leetcode 191. Number of 1 Bits</a></p></blockquote><ul><li>题目: 给定一个无符号整数，返回其二进制表示中<code>1</code>的个数（也称为汉明权重）</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: n = 11 (二进制表示为 00000000000000000000000000001011)</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: 11 的二进制表示有三个 1</span><br></pre></td></tr></table></figure><ul><li>解法: 位操作</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 使用按位与 (n &amp; (n - 1)) 消除最低位的 1，直到 n 为 0，统计次数</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hammingWeight</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> n:</span><br><span class="line">            n &amp;= n - <span class="number">1</span> <span class="comment"># 每次消除最低位的 1</span></span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">hammingWeight</span>(<span class="params">n</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n !== <span class="number">0</span>) &#123;</span><br><span class="line">            n &amp;= n - <span class="number">1</span>; <span class="comment">// 每次消除最低位的 1</span></span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><ul><li>快速排序是一种基于分治思想的高效排序算法，平均时间复杂度为<code>O(n log n)</code>，最坏情况下时间复杂度为 <code>O(n^2)</code>。它的基本思想是通过一次排序将待排序数组分割成独立的两部分，其中一部分的所有元素都比另一部分的所有元素小，然后对这两部分分别进行递归排序。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">quicksort</span>(<span class="params">arr</span>):</span><br><span class="line">    <span class="comment"># 基本条件：如果数组为空或只有一个元素，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(arr) &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> arr</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 选择基准元素</span></span><br><span class="line">    pivot = arr[<span class="built_in">len</span>(arr) // <span class="number">2</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 将数组分成三个部分：小于基准的部分、等于基准的部分、大于基准的部分</span></span><br><span class="line">    left = [x <span class="keyword">for</span> x <span class="keyword">in</span> arr <span class="keyword">if</span> x &lt; pivot]</span><br><span class="line">    middle = [x <span class="keyword">for</span> x <span class="keyword">in</span> arr <span class="keyword">if</span> x == pivot]</span><br><span class="line">    right = [x <span class="keyword">for</span> x <span class="keyword">in</span> arr <span class="keyword">if</span> x &gt; pivot]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 递归排序左右两部分</span></span><br><span class="line">    <span class="keyword">return</span> quicksort(left) + middle + quicksort(right)</span><br></pre></td></tr></table></figure><hr><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><ul><li>冒泡排序是一种简单的排序算法，它通过重复遍历列表，将相邻的元素进行比较并交换，使得每次遍历后最大（或最小）的元素逐步“冒泡”到列表的末尾。冒泡排序的时间复杂度为<code>O(n²)</code>，适用于小规模数据的排序。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">bubble_sort</span>(<span class="params">arr</span>):</span><br><span class="line">    n = <span class="built_in">len</span>(arr)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 外层循环控制遍历次数</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        swapped = <span class="literal">False</span>  <span class="comment"># 用来标记是否发生交换</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 内层循环进行相邻元素的比较和交换</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, n - i - <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> arr[j] &gt; arr[j + <span class="number">1</span>]:</span><br><span class="line">                <span class="comment"># 交换相邻元素</span></span><br><span class="line">                arr[j], arr[j + <span class="number">1</span>] = arr[j + <span class="number">1</span>], arr[j]</span><br><span class="line">                swapped = <span class="literal">True</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 如果没有发生交换，说明数组已经排序完毕</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> swapped:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> arr</span><br></pre></td></tr></table></figure><hr><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><ul><li>插入排序是一种简单直观的排序算法，适合处理小规模数据。它的工作原理是构建一个有序序列，对于未排序的数据，在已排序的序列中从后向前扫描，找到相应位置并插入。插入排序的时间复杂度为<code>O(n²)</code>，在数组几乎有序的情况下表现很好，接近<code>O(n)</code>。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">insertion_sort</span>(<span class="params">arr</span>):</span><br><span class="line">    <span class="comment"># 从第二个元素开始遍历</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(arr)):</span><br><span class="line">        key = arr[i]  <span class="comment"># 当前待插入的元素</span></span><br><span class="line">        j = i - <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 向前遍历已排序的序列，找到适合的位置插入当前元素</span></span><br><span class="line">        <span class="keyword">while</span> j &gt;= <span class="number">0</span> <span class="keyword">and</span> arr[j] &gt; key:</span><br><span class="line">            arr[j + <span class="number">1</span>] = arr[j]  <span class="comment"># 将大于 key 的元素向后移动</span></span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        arr[j + <span class="number">1</span>] = key  <span class="comment"># 将当前元素插入到正确的位置</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> arr</span><br></pre></td></tr></table></figure><hr><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><ul><li>归并排序是一种经典的分治算法，通过将数组递归地分成两个子数组，分别进行排序，然后合并这两个有序子数组来实现排序。归并排序的时间复杂度为<code>O(n log n)</code>，它具有稳定性且适用于大规模数据的排序。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">merge_sort</span>(<span class="params">arr</span>):</span><br><span class="line">    <span class="comment"># 如果数组长度小于等于1，则直接返回</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(arr) &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> arr</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 分割数组</span></span><br><span class="line">    mid = <span class="built_in">len</span>(arr) // <span class="number">2</span></span><br><span class="line">    left_half = merge_sort(arr[:mid])</span><br><span class="line">    right_half = merge_sort(arr[mid:])</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 合并两个已排序的子数组</span></span><br><span class="line">    <span class="keyword">return</span> merge(left_half, right_half)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">merge</span>(<span class="params">left, right</span>):</span><br><span class="line">    sorted_array = []</span><br><span class="line">    i = j = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 逐步比较两个子数组中的元素，按顺序合并</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(left) <span class="keyword">and</span> j &lt; <span class="built_in">len</span>(right):</span><br><span class="line">        <span class="keyword">if</span> left[i] &lt; right[j]:</span><br><span class="line">            sorted_array.append(left[i])</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            sorted_array.append(right[j])</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 将剩余的元素加入合并结果</span></span><br><span class="line">    sorted_array.extend(left[i:])</span><br><span class="line">    sorted_array.extend(right[j:])</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> sorted_array</span><br></pre></td></tr></table></figure><hr><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><ul><li>堆排序是一种基于二叉堆的数据结构的比较排序算法，时间复杂度为<code>O(n log n)</code>。堆排序分为最大堆和最小堆，通常使用最大堆来进行升序排序。堆排序具有原地排序的特点，不需要额外的存储空间。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">heapify</span>(<span class="params">arr, n, i</span>):</span><br><span class="line">    largest = i  <span class="comment"># 设当前节点 i 为最大</span></span><br><span class="line">    left = <span class="number">2</span> * i + <span class="number">1</span>  <span class="comment"># 左子节点</span></span><br><span class="line">    right = <span class="number">2</span> * i + <span class="number">2</span>  <span class="comment"># 右子节点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 如果左子节点存在，且大于当前最大值</span></span><br><span class="line">    <span class="keyword">if</span> left &lt; n <span class="keyword">and</span> arr[left] &gt; arr[largest]:</span><br><span class="line">        largest = left</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 如果右子节点存在，且大于当前最大值</span></span><br><span class="line">    <span class="keyword">if</span> right &lt; n <span class="keyword">and</span> arr[right] &gt; arr[largest]:</span><br><span class="line">        largest = right</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 如果最大值不是当前节点，进行交换并继续调整堆</span></span><br><span class="line">    <span class="keyword">if</span> largest != i:</span><br><span class="line">        arr[i], arr[largest] = arr[largest], arr[i]</span><br><span class="line">        heapify(arr, n, largest)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">heap_sort</span>(<span class="params">arr</span>):</span><br><span class="line">    n = <span class="built_in">len</span>(arr)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 构建最大堆</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n // <span class="number">2</span> - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">        heapify(arr, n, i)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 交换元素，并重新调整堆结构</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n - <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>):</span><br><span class="line">        arr[i], arr[<span class="number">0</span>] = arr[<span class="number">0</span>], arr[i]  <span class="comment"># 将堆顶元素移到数组末尾</span></span><br><span class="line">        heapify(arr, i, <span class="number">0</span>)  <span class="comment"># 调整剩下的部分为最大堆</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> arr</span><br></pre></td></tr></table></figure><hr><h3 id="深度优先搜索-DFS-amp-广度优先搜索-BFS"><a href="#深度优先搜索-DFS-amp-广度优先搜索-BFS" class="headerlink" title="深度优先搜索 (DFS) &amp; 广度优先搜索 (BFS)"></a>深度优先搜索 (DFS) &amp; 广度优先搜索 (BFS)</h3><ul><li>深度优先搜索: <code>DFS</code>是一种通过深入每一个节点并尽可能深地搜索其子节点的遍历算法。可以使用递归或显式栈来实现。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">dfs_recursive</span>(<span class="params">graph, node, visited=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="keyword">if</span> visited <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        visited = <span class="built_in">set</span>()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 访问当前节点</span></span><br><span class="line">    <span class="built_in">print</span>(node)</span><br><span class="line">    visited.add(node)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 递归访问相邻节点</span></span><br><span class="line">    <span class="keyword">for</span> neighbor <span class="keyword">in</span> graph[node]:</span><br><span class="line">        <span class="keyword">if</span> neighbor <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">            dfs_recursive(graph, neighbor, visited)</span><br></pre></td></tr></table></figure><ul><li>广度优先搜索: <code>BFS</code>是一种逐层遍历算法，先访问当前节点的所有相邻节点，再继续访问这些相邻节点的相邻节点。<code>BFS</code>通常用队列来实现。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">bfs</span>(<span class="params">graph, start</span>):</span><br><span class="line">    visited = <span class="built_in">set</span>()</span><br><span class="line">    queue = deque([start])  <span class="comment"># 使用双端队列作为队列</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> queue:</span><br><span class="line">        node = queue.popleft()  <span class="comment"># 从队列中取出第一个节点</span></span><br><span class="line">        <span class="keyword">if</span> node <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">            <span class="built_in">print</span>(node)</span><br><span class="line">            visited.add(node)</span><br><span class="line">            <span class="comment"># 将相邻节点加入队列</span></span><br><span class="line">            queue.extend(graph[node])</span><br></pre></td></tr></table></figure><hr><h3 id="前序，中序，后序"><a href="#前序，中序，后序" class="headerlink" title="前序，中序，后序"></a>前序，中序，后序</h3><ul><li>前序遍历顺序为：根节点 -&gt; 左子树 -&gt; 右子树</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">preorder</span>(<span class="params">root</span>):</span><br><span class="line">    <span class="keyword">if</span> root:</span><br><span class="line">        <span class="built_in">print</span>(root.val)  <span class="comment"># 先访问根节点</span></span><br><span class="line">        preorder(root.left)  <span class="comment"># 递归访问左子树</span></span><br><span class="line">        preorder(root.right)  <span class="comment"># 递归访问右子树</span></span><br></pre></td></tr></table></figure><ul><li>中序遍历顺序为：左子树 -&gt; 根节点 -&gt; 右子树</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">inorder</span>(<span class="params">root</span>):</span><br><span class="line">    <span class="keyword">if</span> root:</span><br><span class="line">        inorder(root.left)  <span class="comment"># 递归访问左子树</span></span><br><span class="line">        <span class="built_in">print</span>(root.val)  <span class="comment"># 访问根节点</span></span><br><span class="line">        inorder(root.right)  <span class="comment"># 递归访问右子树</span></span><br></pre></td></tr></table></figure><ul><li>后序遍历顺序为：左子树 -&gt; 右子树 -&gt; 根节点</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">postorder</span>(<span class="params">root</span>):</span><br><span class="line">    <span class="keyword">if</span> root:</span><br><span class="line">        postorder(root.left)  <span class="comment"># 递归访问左子树</span></span><br><span class="line">        postorder(root.right)  <span class="comment"># 递归访问右子树</span></span><br><span class="line">        <span class="built_in">print</span>(root.val)  <span class="comment"># 最后访问根节点</span></span><br></pre></td></tr></table></figure><hr></article><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/posts/c7d67744.html" title="前端面试笔记"><img class="cover" src="https://cdn.jsdelivr.net/gh/Hongda-OSU/PicGo/image/gknx188yxuapxelxaeyjso308qyhne0.jpg" onerror='onerror=null,src="https://cdn.jsdelivr.net/gh/Hongda-OSU/PicGo/image/404.GIF"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">前端面试笔记</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://cdn.jsdelivr.net/gh/Hongda-OSU/PicGo/image/德狗子.GIF" onerror='this.onerror=null,this.src="https://cdn.jsdelivr.net/gh/Hongda-OSU/PicGo/image/404.GIF"' alt="avatar"></div><div class="author-info__name">鴻達</div><div class="author-info__description">记录 我的 生活</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">23</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">13</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Hongda-OSU" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="https://www.linkedin.com/in/hongda-lin" target="_blank" title="Linkedin"><i class="fab fa-linkedin"></i></a><a class="social-icon" href="https://hongdalin.me" target="_blank" title="Portfolio"><i class="iconfont icon-guanfangwangzhan"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">文章右下角小工具进入阅读模式</div></div><div class="xpand" style="height:200px"><canvas class="illo" width="800" height="800" style="max-width:200px;max-height:200px;touch-action:none;width:640px;height:640px"></canvas></div><script src="https://npm.elemecdn.com/ethan4116-blog/lib/js/other/two-people/twopeople1.js"></script><script src="https://npm.elemecdn.com/ethan4116-blog/lib/js/other/two-people/zdog.dist.js"></script><script id="rendered-js" src="https://npm.elemecdn.com/ethan4116-blog/lib/js/other/two-people/twopeople.js"></script><style>.card-widget.card-announcement{margin:0;align-items:center;justify-content:center;text-align:center}canvas{display:block;margin:0 auto;cursor:move}</style><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#PriorityQueue-%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97"><span class="toc-text">PriorityQueue 优先队列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%ACk%E5%A4%A7%E7%9A%84%E5%85%83%E7%B4%A0"><span class="toc-text">第k大的元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%89%8Dk%E4%B8%AA%E5%85%83%E7%B4%A0%E7%9A%84%E9%A2%91%E7%8E%87"><span class="toc-text">前k个元素的频率</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Design"><span class="toc-text">Design</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#LRU-%E7%BC%93%E5%AD%98"><span class="toc-text">LRU 缓存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E9%9A%8F%E6%9C%BA%E9%9B%86%E5%90%88"><span class="toc-text">实现随机集合</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LinkedList-%E9%93%BE%E8%A1%A8"><span class="toc-text">LinkedList 链表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8"><span class="toc-text">反转链表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8%E4%B8%AD%E9%97%B4%E9%83%A8%E5%88%86"><span class="toc-text">反转链表中间部分</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%88%E6%88%90%E9%93%BE%E8%A1%A8"><span class="toc-text">合成链表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#k%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8"><span class="toc-text">k个一组翻转链表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%88%90%E5%AF%B9%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8%E8%8A%82%E7%82%B9"><span class="toc-text">成对反转链表节点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E6%8A%98%E9%93%BE%E8%A1%A8"><span class="toc-text">对折链表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0"><span class="toc-text">删除有序链表重复元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E6%89%80%E6%9C%89%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0"><span class="toc-text">删除有序链表所有重复元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8%E8%BD%AC%E6%A0%91"><span class="toc-text">链表转树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%88%E5%B9%B6k%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8"><span class="toc-text">合并k个有序链表</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BFS-amp-DFS"><span class="toc-text">BFS &amp; DFS</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%B7%E5%B2%9B%E9%97%AE%E9%A2%98"><span class="toc-text">海岛问题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Two-Pointers-%E5%8F%8C%E6%8C%87%E9%92%88"><span class="toc-text">Two Pointers 双指针</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9B%A8%E6%B0%B4%E9%97%AE%E9%A2%98"><span class="toc-text">雨水问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%9B%E6%B0%B4%E9%97%AE%E9%A2%98"><span class="toc-text">盛水问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D"><span class="toc-text">一维数组去重</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9A%84%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="toc-text">最接近的三数之和</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="toc-text">三数之和</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="toc-text">四数之和</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%BE%E5%87%BA%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E6%95%B0%E5%AD%97"><span class="toc-text">找出数组中的重复数字</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Binary-Search"><span class="toc-text">Binary Search</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-text">最长递增子序列</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Tree-%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">Tree 树与二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-text">二叉树层序遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%91%E6%AF%8F%E5%B1%82%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC"><span class="toc-text">树每层的最大值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-text">验证二叉搜索树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E6%9C%80%E5%A4%A7%E5%B7%AE%E5%80%BC"><span class="toc-text">二叉树最大差值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8D%E5%90%8C%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%95%B0%E9%87%8F"><span class="toc-text">不同二叉搜索树的数量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A3%80%E6%9F%A5%E4%BA%8C%E5%8F%89%E6%A0%91%E6%98%AF%E5%90%A6%E5%B9%B3%E8%A1%A1"><span class="toc-text">检查二叉树是否平衡</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%AC%ACk%E5%B0%8F%E7%9A%84%E8%8A%82%E7%82%B9"><span class="toc-text">二叉搜索树第k小的节点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%95%E5%BC%80%E4%B8%BA%E9%93%BE%E8%A1%A8"><span class="toc-text">二叉树展开为链表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88"><span class="toc-text">二叉搜索树的最近公共祖先</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">对称二叉树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%98%E5%9C%A8%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C"><span class="toc-text">存在路径总和</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C"><span class="toc-text">所有路径总和</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Matrix-%E7%9F%A9%E9%98%B5"><span class="toc-text">Matrix 矩阵</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5"><span class="toc-text">螺旋矩阵</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%89%E6%95%88%E6%95%B0%E7%8B%AC"><span class="toc-text">有效数独</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E5%A4%A7%E5%B2%9B%E5%B1%BF%E9%9D%A2%E7%A7%AF"><span class="toc-text">最大岛屿面积</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Array-%E6%95%B0%E7%BB%84"><span class="toc-text">Array 数组</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AE%E8%BD%AC%E6%95%B0%E7%BB%84"><span class="toc-text">轮转数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E8%BD%AC%E6%A0%91"><span class="toc-text">数组转树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84"><span class="toc-text">合并两个有序数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6"><span class="toc-text">每日温度</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#String-%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">String 字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A7%A3%E7%A0%81"><span class="toc-text">字符串解码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E9%95%BF%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%90%E4%B8%B2"><span class="toc-text">最长无重复子串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8B%AC%E5%8F%B7%E5%8C%B9%E9%85%8D"><span class="toc-text">括号匹配</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%9F%E6%88%90%E6%8B%AC%E5%8F%B7"><span class="toc-text">生成括号</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AF%94%E8%BE%83%E7%89%88%E6%9C%AC%E5%8F%B7"><span class="toc-text">比较版本号</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%8F%E5%85%B8%E8%AE%A1%E7%AE%97%E5%99%A8-%E6%97%A0%E4%B9%98%E9%99%A4"><span class="toc-text">经典计算器 (无乘除)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%8F%E5%85%B8%E8%AE%A1%E7%AE%97%E5%99%A8-%E6%9C%89%E4%B9%98%E9%99%A4"><span class="toc-text">经典计算器 (有乘除)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2%E4%B8%AA%E6%95%B0"><span class="toc-text">回文子串个数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2"><span class="toc-text">最长回文子串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%A7%E6%95%B0%E7%9B%B8%E5%8A%A0"><span class="toc-text">大数相加</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Backtrack-%E5%9B%9E%E6%BA%AF"><span class="toc-text">Backtrack 回溯</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%A8%E6%8E%92%E5%88%97%EF%BC%88%E6%97%A0%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0%EF%BC%89"><span class="toc-text">全排列（无重复元素）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%A8%E6%8E%92%E5%88%97%EF%BC%88%E6%9C%89%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0%EF%BC%89"><span class="toc-text">全排列（有重复元素）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Dynamic-Programming"><span class="toc-text">Dynamic Programming</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86"><span class="toc-text">分割等和子集</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%84%E6%88%90%E7%9B%AE%E6%A0%87%E5%92%8C"><span class="toc-text">组成目标和</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F"><span class="toc-text">跳跃游戏</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E8%B7%B3%E8%B7%83%E6%AC%A1%E6%95%B0"><span class="toc-text">最小跳跃次数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA"><span class="toc-text">买卖股票的最佳时机</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%82%A1%E7%A5%A8%E4%B9%B0%E5%8D%96%E7%9A%84%E6%9C%80%E5%A4%A7%E6%94%B6%E7%9B%8A"><span class="toc-text">股票买卖的最大收益</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84%E7%9A%84%E6%95%B0%E7%9B%AE"><span class="toc-text">不同路径的数目</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD%E5%92%8C"><span class="toc-text">最大连续和</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E4%B8%B2"><span class="toc-text">最长公共子串</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Other-%E5%85%B6%E4%BB%96"><span class="toc-text">Other 其他</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D"><span class="toc-text">二维数组去重</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97"><span class="toc-text">斐波那契数列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC"><span class="toc-text">整数反转</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%8D1%E7%9A%84%E4%B8%AA%E6%95%B0"><span class="toc-text">位1的个数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="toc-text">快速排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F"><span class="toc-text">冒泡排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="toc-text">插入排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="toc-text">归并排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A0%86%E6%8E%92%E5%BA%8F"><span class="toc-text">堆排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2-DFS-amp-%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2-BFS"><span class="toc-text">深度优先搜索 (DFS) &amp; 广度优先搜索 (BFS)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E5%BA%8F%EF%BC%8C%E4%B8%AD%E5%BA%8F%EF%BC%8C%E5%90%8E%E5%BA%8F"><span class="toc-text">前序，中序，后序</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/7c522c36.html" title="切图仔 2"><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/imgbmcrg53uzso0a5lk4rcm76njiw0mw0m.jpg" onerror='this.onerror=null,this.src="https://cdn.jsdelivr.net/gh/Hongda-OSU/PicGo/image/404.GIF"' alt="切图仔 2"></a><div class="content"><a class="title" href="/posts/7c522c36.html" title="切图仔 2">切图仔 2</a><time datetime="2024-12-23T18:03:05.000Z" title="发表于 2024-12-23 12:03:05">2024-12-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/d58818f0.html" title="WebGL 学习笔记"><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/imgdip29s0ui3xcpinvtb8pelnc00xb05s.jpg" onerror='this.onerror=null,this.src="https://cdn.jsdelivr.net/gh/Hongda-OSU/PicGo/image/404.GIF"' alt="WebGL 学习笔记"></a><div class="content"><a class="title" href="/posts/d58818f0.html" title="WebGL 学习笔记">WebGL 学习笔记</a><time datetime="2024-12-08T16:15:05.000Z" title="发表于 2024-12-08 10:15:05">2024-12-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/558bc4fb.html" title="GO 学习笔记"><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/imgbqwt4ir73bffcbd68bcq4c0turzstua.jpg" onerror='this.onerror=null,this.src="https://cdn.jsdelivr.net/gh/Hongda-OSU/PicGo/image/404.GIF"' alt="GO 学习笔记"></a><div class="content"><a class="title" href="/posts/558bc4fb.html" title="GO 学习笔记">GO 学习笔记</a><time datetime="2024-11-23T16:15:05.000Z" title="发表于 2024-11-23 10:15:05">2024-11-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/13fe9182.html" title="原型链解析"><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/imgl5zrba8rs677k0siqvc37eh5l0hdzqu.jpg" onerror='this.onerror=null,this.src="https://cdn.jsdelivr.net/gh/Hongda-OSU/PicGo/image/404.GIF"' alt="原型链解析"></a><div class="content"><a class="title" href="/posts/13fe9182.html" title="原型链解析">原型链解析</a><time datetime="2024-11-14T16:15:05.000Z" title="发表于 2024-11-14 10:15:05">2024-11-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/29dadae9.html" title="PostgreSQL 学习笔记"><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/imgied0v0dgsgyqeoh7804b0ca54buj0qd.jpg" onerror='this.onerror=null,this.src="https://cdn.jsdelivr.net/gh/Hongda-OSU/PicGo/image/404.GIF"' alt="PostgreSQL 学习笔记"></a><div class="content"><a class="title" href="/posts/29dadae9.html" title="PostgreSQL 学习笔记">PostgreSQL 学习笔记</a><time datetime="2024-08-02T15:15:06.000Z" title="发表于 2024-08-02 10:15:06">2024-08-02</time></div></div></div></div></div></div></main><footer id="footer" style="background:rgba(0,0,0,.25)"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2025 &nbsp;<i id="heartbeat" class="fa fas fa-heartbeat"></i> &nbsp;鴻達</div><div class="footer_custom_text"><p class="badge"><a style="margin-inline:5px" target="_blank" href="https://hexo.io/"><img src="https://img.shields.io/badge/Frame-Hexo-informational?style=flat&logo=hexo"></a><a style="margin-inline:5px" target="_blank" href="https://domains.google/"><img src="https://img.shields.io/badge/Hosted-Google-ff69b4?style=flat&logo=googledomains"></a><a style="margin-inline:5px" target="_blank" href="https://gulpjs.com/"><img src="https://img.shields.io/badge/Compress-gulp-critical?style=flat&logo=gulp"></a><a style="margin-inline:5px" target="_blank" href="https://www.jsdelivr.com/"><img src="https://img.shields.io/badge/CDN-jsDelivr-orange?style=flat&logo=jsDelivr"></a><a style="margin-inline:5px" target="_blank" href="https://github.com/"><img src="https://img.shields.io/badge/Source-Github-black?style=flat&logo=GitHub"></a><a style="margin-inline:5px" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&logo=Claris"></a></p></div></div><link rel="stylesheet" href="https://fastly.jsdelivr.net/gh/HCLonely/images@master/others/heartbeat.min.css"></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i> <span>数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script>function panguFn(){"object"==typeof pangu?pangu.autoSpacingPage():getScript("https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js").then((()=>{pangu.autoSpacingPage()}))}function panguInit(){GLOBAL_CONFIG_SITE.isPost&&panguFn()}document.addEventListener("DOMContentLoaded",panguInit)</script><script src="/js/search/local-search.js"></script><div class="js-pjax"></div><script defer src="/js/util.js"></script><script defer src="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js"></script><script disable-devtool-auto src="https://cdn.jsdelivr.net/npm/disable-devtool"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors=["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"];var pjax=new Pjax({elements:'a:not([target="_blank"])',selectors:pjaxSelectors,cacheBust:!1,analytics:!1,scrollRestoration:!1});document.addEventListener("pjax:send",(function(){if(window.tocScrollFn&&window.removeEventListener("scroll",window.tocScrollFn),window.scrollCollect&&window.removeEventListener("scroll",scrollCollect),document.getElementById("rightside").style.cssText="opacity: ''; transform: ''",window.aplayers)for(let e=0;e<window.aplayers.length;e++)window.aplayers[e].options.fixed||window.aplayers[e].destroy();"object"==typeof typed&&typed.destroy();const e=document.body.classList;e.contains("read-mode")&&e.remove("read-mode"),"object"==typeof disqusjs&&disqusjs.destroy()})),document.addEventListener("pjax:complete",(function(){window.refreshFn(),document.querySelectorAll("script[data-pjax]").forEach((e=>{const t=document.createElement("script"),o=e.text||e.textContent||e.innerHTML||"";Array.from(e.attributes).forEach((e=>t.setAttribute(e.name,e.value))),t.appendChild(document.createTextNode(o)),e.parentNode.replaceChild(t,e)})),GLOBAL_CONFIG.islazyload&&window.lazyLoadInstance.update(),"function"==typeof chatBtnFn&&chatBtnFn(),"function"==typeof panguInit&&panguInit(),"function"==typeof gtag&&gtag("config","",{page_path:window.location.pathname}),"object"==typeof _hmt&&_hmt.push(["_trackPageview",window.location.pathname]),"function"==typeof loadMeting&&document.getElementsByClassName("aplayer").length&&loadMeting(),"object"==typeof Prism&&Prism.highlightAll()})),document.addEventListener("pjax:error",(e=>{404===e.request.status&&pjax.loadUrl("/404.html")}))</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>