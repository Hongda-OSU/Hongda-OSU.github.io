<!DOCTYPE html><html lang="zh-CN" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><title>GO 学习笔记 | 鴻鵠誌達</title><meta name="author" content="鴻達"><meta name="copyright" content="鴻達"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#1a1a1a"><meta name="description" content="GO 学习笔记"><meta property="og:type" content="article"><meta property="og:title" content="GO 学习笔记"><meta property="og:url" content="https://hongdalin.blog/posts/558bc4fb.html"><meta property="og:site_name" content="鴻鵠誌達"><meta property="og:description" content="GO 学习笔记"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img700px-Dot_scenario_s1_ep2.png"><meta property="article:published_time" content="2024-11-23T16:15:05.000Z"><meta property="article:modified_time" content="2025-11-28T02:06:07.945Z"><meta property="article:author" content="鴻達"><meta property="article:tag" content="GO"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img700px-Dot_scenario_s1_ep2.png"><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/Hongda-OSU/PicGo/image/德克萨斯.GIF"><link rel="canonical" href="https://hongdalin.blog/posts/558bc4fb.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:{path:"/search.xml",preload:!0,languages:{hits_empty:"找不到您查询的内容：${query}"}},translate:void 0,noticeOutdate:void 0,highlight:{plugin:"highlighjs",highlightCopy:!0,highlightLang:!0,highlightHeightLimit:!1},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"},relativeDate:{homepage:!1,post:!1},runtime:"天",date_suffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:void 0,lightbox:"fancybox",Snackbar:void 0,source:{justifiedGallery:{js:"https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js",css:"https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css"}},isPhotoFigcaption:!0,islazyload:!1,isAnchor:!1,percent:{toc:!0,rightside:!1}}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"GO 学习笔记",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2025-11-27 20:06:07"}</script><noscript><style>#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(e=>{e.saveToLocal={set:function(e,t,n){if(0===n)return;const o=864e5*n,a={value:t,expiry:(new Date).getTime()+o};localStorage.setItem(e,JSON.stringify(a))},get:function(e){const t=localStorage.getItem(e);if(!t)return;const n=JSON.parse(t);if(!((new Date).getTime()>n.expiry))return n.value;localStorage.removeItem(e)}},e.getScript=e=>new Promise(((t,n)=>{const o=document.createElement("script");o.src=e,o.async=!0,o.onerror=n,o.onload=o.onreadystatechange=function(){const e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(o.onload=o.onreadystatechange=null,t())},document.head.appendChild(o)})),e.getCSS=e=>new Promise(((t,n)=>{const o=document.createElement("link");o.rel="stylesheet",o.href=e,o.onload=()=>t(),o.onerror=()=>n(),document.head.appendChild(o)}));/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")})(window)</script><link rel="stylesheet" href="/css/color.css" media="defer" onload='this.media="all"'><link rel="stylesheet" href="/css/font.css" media="defer" onload='this.media="all"'><link rel="stylesheet" href="/css/icon.css" media="defer" onload='this.media="all"'><link rel="stylesheet" href="/css/layout.css" media="defer" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.css" media="defer" onload='this.media="all"'><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://cdn.jsdelivr.net/gh/Hongda-OSU/PicGo/image/德狗子.GIF" onerror='onerror=null,src="https://cdn.jsdelivr.net/gh/Hongda-OSU/PicGo/image/404.GIF"' alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">31</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">16</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i> <span>时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i> <span>标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>分类</span></a></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i> <span>链接</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i> <span>友情链接</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i> <span>关于</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url('https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img700px-Dot_scenario_s1_ep2.png')"><nav id="nav"><span id="blog-info"><a href="/" title="鴻鵠誌達"><span class="site-name">鴻鵠誌達</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i> <span>搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i> <span>时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i> <span>标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>分类</span></a></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i> <span>链接</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i> <span>友情链接</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i> <span>关于</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">GO 学习笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-11-23T16:15:05.000Z" title="发表于 2024-11-23 10:15:05">2024-11-23</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-11-28T02:06:07.945Z" title="更新于 2025-11-27 20:06:07">2025-11-27</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">5.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>26分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" data-flag-title="GO 学习笔记"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h3 id="1-什么是Go语言"><a href="#1-什么是Go语言" class="headerlink" title="1. 什么是Go语言"></a>1. 什么是<code>Go</code>语言</h3><ul><li><code>Go</code>是由<code>Google</code>开发的一种开源编程语言，设计初衷是让开发者可以快速构建高效的现代应用。<code>Go</code>结合了静态语言的性能和动态语言的开发效率，<ins>特别适合开发高并发的后端服务</ins></li></ul><hr><h3 id="2-包的概念"><a href="#2-包的概念" class="headerlink" title="2. 包的概念"></a>2. 包的概念</h3><ul><li><p><code>Go</code> 用包 (<code>package</code>) 来组织代码，和 <code>Python</code> 的模块差不多。把相关功能的代码放一个目录，就是一个包。包可以被其他包引用，方便复用。</p></li><li><p>有一个特殊的包叫 <code>main</code>，它是程序的入口。每个可执行程序必须有且只有一个 <code>main</code> 包，里面必须有一个 <code>main()</code> 函数。</p></li></ul><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main  <span class="comment">// 声明这是 main 包</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span>  <span class="comment">// 引入 fmt 包，用于打印输出</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;hello go&quot;</span>)</span><br><span class="line">    fmt.Println(<span class="string">&quot;hello haha&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>几个注意点:</p><ul><li>每个 <code>.go</code> 文件开头必须声明属于哪个包</li><li>左花括号 <code>&#123;</code> 必须和函数名同一行，不能换行 (<code>Go</code> 的强制风格)</li><li>语句结尾不用加分号</li><li>注释用 <code>//</code> 或 <code>/* */</code></li></ul><hr><h3 id="3-变量声明"><a href="#3-变量声明" class="headerlink" title="3. 变量声明"></a>3. 变量声明</h3><p><code>Go</code> 声明变量有三种写法:</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name <span class="type">string</span> = <span class="string">&quot;Hongda&quot;</span>   <span class="comment">// 完整写法: var + 名字 + 类型 + 值</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;Hongda&quot;</span>          <span class="comment">// 省略类型，编译器自动推断</span></span><br><span class="line">name := <span class="string">&quot;Hongda&quot;</span>             <span class="comment">// 短声明，最常用</span></span><br></pre></td></tr></table></figure><p>短声明 <code>:=</code> 写起来最简洁，日常用得最多。但它只能在函数内部用，包级别的变量必须用 <code>var</code>。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> globalVar = <span class="string">&quot;我是全局变量&quot;</span>  <span class="comment">// 包级别，必须用 var</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    localVar := <span class="string">&quot;我是局部变量&quot;</span>  <span class="comment">// 函数内，短声明 OK</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>零值</strong>: 变量声明了但没赋值，<code>Go</code> 会给默认值，叫”零值”。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> count <span class="type">int</span>     <span class="comment">// 0</span></span><br><span class="line"><span class="keyword">var</span> text <span class="type">string</span>   <span class="comment">// &quot;&quot;（空字符串）</span></span><br><span class="line"><span class="keyword">var</span> flag <span class="type">bool</span>     <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p><strong>批量声明</strong>: 多个变量可以放一起声明。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 同类型</span></span><br><span class="line"><span class="keyword">var</span> i, j, k <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不同类型，自动推断</span></span><br><span class="line"><span class="keyword">var</span> a, b, c = <span class="number">1</span>, <span class="string">&quot;hello&quot;</span>, <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用括号组织，适合包级别变量</span></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    host = <span class="string">&quot;localhost&quot;</span></span><br><span class="line">    port = <span class="number">5432</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><strong>多变量赋值</strong>: <code>Go</code> 支持一行给多个变量赋值，交换变量值特别方便。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">x, y := <span class="number">10</span>, <span class="number">20</span>    <span class="comment">// 声明并赋值</span></span><br><span class="line">x, y = y, x       <span class="comment">// 交换，不需要临时变量</span></span><br></pre></td></tr></table></figure><p>注意 <code>:=</code> 是声明+赋值，<code>=</code> 是纯赋值。已经声明过的变量再用 <code>:=</code> 会报错。</p><hr><h3 id="4-赋值"><a href="#4-赋值" class="headerlink" title="4. 赋值"></a>4. 赋值</h3><p><code>Go</code> 的赋值操作很直接:</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">x = <span class="number">1</span>              <span class="comment">// 基本赋值</span></span><br><span class="line">*p = <span class="literal">true</span>          <span class="comment">// 指针解引用赋值</span></span><br><span class="line">person.name = <span class="string">&quot;bob&quot;</span> <span class="comment">// 结构体字段赋值</span></span><br></pre></td></tr></table></figure><p><strong>复合赋值</strong>: 简化 <code>x = x + 5</code> 这种写法。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">count[x] *= scale  <span class="comment">// 等价于 count[x] = count[x] * scale</span></span><br><span class="line">x += <span class="number">5</span>             <span class="comment">// 等价于 x = x + 5</span></span><br></pre></td></tr></table></figure><p><strong>自增自减</strong>: 注意 <code>Go</code> 里 <code>v++</code> 是语句不是表达式，不能写 <code>x = i++</code>。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">v := <span class="number">1</span></span><br><span class="line">v++  <span class="comment">// v 变为 2</span></span><br><span class="line">v--  <span class="comment">// v 变为 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// x = i++  // 错误! Go 不允许这样写</span></span><br></pre></td></tr></table></figure><h4 id="元组赋值"><a href="#元组赋值" class="headerlink" title="元组赋值"></a>元组赋值</h4><p>可以一行给多个变量赋值，右边表达式先全部求值，再赋给左边。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 交换变量，不需要临时变量</span></span><br><span class="line">x, y = y, x</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最大公约数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcd</span><span class="params">(x, y <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> y != <span class="number">0</span> &#123;</span><br><span class="line">        x, y = y, x%y</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 斐波那契</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fib</span><span class="params">(n <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    x, y := <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        x, y = y, x+y</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>函数多返回值</strong>: <code>Go</code> 函数可以返回多个值，常见的模式是返回结果和错误。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">f, err := os.Open(<span class="string">&quot;foo.txt&quot;</span>)</span><br></pre></td></tr></table></figure><p><strong><code>ok</code> 模式</strong>: <code>map</code> 查找、类型断言、<code>channel</code> 接收都可以返回第二个 <code>bool</code> 值表示是否成功。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">v, ok := m[key]    <span class="comment">// map 查找</span></span><br><span class="line">v, ok := x.(T)     <span class="comment">// 类型断言</span></span><br><span class="line">v, ok := &lt;-ch      <span class="comment">// channel 接收</span></span><br></pre></td></tr></table></figure><p><strong>丢弃不需要的值</strong>: 用 <code>_</code> 占位。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">_, err := io.Copy(dst, src)  <span class="comment">// 只关心 err，不关心拷贝了多少字节</span></span><br></pre></td></tr></table></figure><h4 id="可赋值性"><a href="#可赋值性" class="headerlink" title="可赋值性"></a>可赋值性</h4><p>赋值分显式和隐式两种:</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 显式赋值</span></span><br><span class="line">x = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 隐式赋值 - 函数调用时参数传递</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(a, b <span class="type">int</span>)</span></span> &#123;&#125;  <span class="comment">// 调用时实参赋给 a, b</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 隐式赋值 - 字面量初始化</span></span><br><span class="line">medals := []<span class="type">string</span>&#123;<span class="string">&quot;gold&quot;</span>, <span class="string">&quot;silver&quot;</span>, <span class="string">&quot;bronze&quot;</span>&#125;</span><br></pre></td></tr></table></figure><p>赋值规则: 类型必须匹配。<code>nil</code> 可以赋给指针、<code>slice</code>、<code>map</code>、<code>channel</code>、<code>interface</code> 等引用类型。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p *<span class="type">int</span> = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">var</span> m <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span> = <span class="literal">nil</span></span><br></pre></td></tr></table></figure><hr><h3 id="5-函数基础"><a href="#5-函数基础" class="headerlink" title="5. 函数基础"></a>5. 函数基础</h3><p>用 <code>func</code> 关键字声明函数。函数名首字母小写是包内私有，大写是公开可导出。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sayHello</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Hello&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><p>参数格式是 <code>变量名 类型</code>，多个参数用逗号分隔。<code>Go</code> 不支持默认参数。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">greet</span><span class="params">(name <span class="type">string</span>, age <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%s is %d years old\n&quot;</span>, name, age)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 相同类型可以简写</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>不定参数</strong>: 用 <code>...</code> 表示，必须放在最后。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(nums ...<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    total := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        total += v</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> total</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sum()           <span class="comment">// 0 个参数</span></span><br><span class="line">sum(<span class="number">1</span>)          <span class="comment">// 1 个参数</span></span><br><span class="line">sum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)    <span class="comment">// 3 个参数</span></span><br></pre></td></tr></table></figure><h4 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h4><p>单个返回值不用括号，多个要括号。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 单个返回值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">double</span><span class="params">(x <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x * <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多个返回值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap</span><span class="params">(x, y <span class="type">string</span>)</span></span> (<span class="type">string</span>, <span class="type">string</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> y, x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 命名返回值，可以直接 return</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">split</span><span class="params">(sum <span class="type">int</span>)</span></span> (x, y <span class="type">int</span>) &#123;</span><br><span class="line">    x = sum * <span class="number">4</span> / <span class="number">9</span></span><br><span class="line">    y = sum - x</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>丢弃不需要的返回值</strong>: 用 <code>_</code> 占位。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">max, _ := MaxAndMin(<span class="number">10</span>, <span class="number">20</span>)  <span class="comment">// 只要 max，不要 min</span></span><br></pre></td></tr></table></figure><h4 id="函数调用流程"><a href="#函数调用流程" class="headerlink" title="函数调用流程"></a>函数调用流程</h4><p>函数调用是栈结构，后进先出 (LIFO)。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">funcc</span><span class="params">(c <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;c =&quot;</span>, c)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">funcb</span><span class="params">(b <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    funcc(b - <span class="number">1</span>)</span><br><span class="line">    fmt.Println(<span class="string">&quot;b =&quot;</span>, b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">funca</span><span class="params">(a <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    funcb(a - <span class="number">1</span>)</span><br><span class="line">    fmt.Println(<span class="string">&quot;a =&quot;</span>, a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    funca(<span class="number">3</span>)</span><br><span class="line">    fmt.Println(<span class="string">&quot;main&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行流程:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">main() → funca(3) → funcb(2) → funcc(1)</span><br><span class="line">                                打印 &quot;c = 1&quot;</span><br><span class="line">                    打印 &quot;b = 2&quot;</span><br><span class="line">         打印 &quot;a = 3&quot;</span><br><span class="line">打印 &quot;main&quot;</span><br></pre></td></tr></table></figure><p>输出: <code>c = 1</code> → <code>b = 2</code> → <code>a = 3</code> → <code>main</code></p><h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><p>函数调用自身，必须有退出条件。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 累加: 1 + 2 + ... + n</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(n <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n + sum(n<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sum(<span class="number">100</span>)  <span class="comment">// 5050</span></span><br></pre></td></tr></table></figure><p>执行流程:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sum(100) = 100 + sum(99)</span><br><span class="line">         = 100 + 99 + sum(98)</span><br><span class="line">         = ...</span><br><span class="line">         = 100 + 99 + ... + 1</span><br><span class="line">         = 5050</span><br></pre></td></tr></table></figure><hr><h3 id="6-函数进阶"><a href="#6-函数进阶" class="headerlink" title="6. 函数进阶"></a>6. 函数进阶</h3><h4 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h4><p>函数在 <code>Go</code> 里是一等公民，可以赋值给变量、作为参数传递。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Add</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Minus</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a - b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义函数类型</span></span><br><span class="line"><span class="keyword">type</span> CalcFunc <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span> <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> f CalcFunc</span><br><span class="line">    </span><br><span class="line">    f = Add</span><br><span class="line">    fmt.Println(f(<span class="number">10</span>, <span class="number">5</span>))  <span class="comment">// 15</span></span><br><span class="line">    </span><br><span class="line">    f = Minus</span><br><span class="line">    fmt.Println(f(<span class="number">10</span>, <span class="number">5</span>))  <span class="comment">// 5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>函数作为参数 (回调函数)</strong>: 实现多态，同一个函数传入不同的函数参数，实现不同功能。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> CalcFunc <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span> <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Calc</span><span class="params">(a, b <span class="type">int</span>, f CalcFunc)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> f(a, b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Calc(<span class="number">3</span>, <span class="number">3</span>, Add)    <span class="comment">// 6，加法</span></span><br><span class="line">    Calc(<span class="number">3</span>, <span class="number">3</span>, Minus)  <span class="comment">// 0，减法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h4><p>没有名字的函数，可以赋值给变量，也可以定义后立即调用。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 赋值给变量</span></span><br><span class="line">f := <span class="function"><span class="keyword">func</span><span class="params">(x, y <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line">f(<span class="number">1</span>, <span class="number">2</span>)  <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义并立即调用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(x, y <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    fmt.Println(x + y)</span><br><span class="line">&#125;(<span class="number">1</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure><h4 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h4><p>闭包是引用了外部变量的匿名函数。关键点: 变量以引用方式捕获，会保留状态。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 普通函数: 每次调用 a 都重新初始化</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test01</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> a <span class="type">int</span>  <span class="comment">// 每次都是 0</span></span><br><span class="line">    a++</span><br><span class="line">    <span class="keyword">return</span> a * a</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用 5 次输出: 1 1 1 1 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 闭包: a 只初始化一次，状态保留</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test02</span><span class="params">()</span></span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> a <span class="type">int</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">        a++</span><br><span class="line">        <span class="keyword">return</span> a * a</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    f := test02()</span><br><span class="line">    fmt.Println(f())  <span class="comment">// 1</span></span><br><span class="line">    fmt.Println(f())  <span class="comment">// 4</span></span><br><span class="line">    fmt.Println(f())  <span class="comment">// 9</span></span><br><span class="line">    fmt.Println(f())  <span class="comment">// 16</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h4><p><code>defer</code> 延迟执行，函数返回前才执行。常用于资源清理: 关闭文件、释放连接等。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> fmt.Println(<span class="string">&quot;最后执行&quot;</span>)</span><br><span class="line">    fmt.Println(<span class="string">&quot;先执行&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出:</span></span><br><span class="line"><span class="comment">// 先执行</span></span><br><span class="line"><span class="comment">// 最后执行</span></span><br></pre></td></tr></table></figure><p><strong>典型用法</strong>:</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">readFile</span><span class="params">()</span></span> &#123;</span><br><span class="line">    f, err := os.Open(<span class="string">&quot;file.txt&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> f.Close()  <span class="comment">// 确保文件关闭</span></span><br><span class="line">    <span class="comment">// 处理文件...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>多个 <code>defer</code></strong>: 后进先出 (LIFO)，先定义的后执行。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> fmt.Println(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">    <span class="keyword">defer</span> fmt.Println(<span class="string">&quot;2&quot;</span>)</span><br><span class="line">    <span class="keyword">defer</span> fmt.Println(<span class="string">&quot;3&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出: 3 2 1</span></span><br></pre></td></tr></table></figure><p><strong><code>defer</code> 与闭包</strong>: 注意捕获变量的时机。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := <span class="number">10</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 无参数: 捕获变量，使用最终值</span></span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Println(a)  <span class="comment">// 100</span></span><br><span class="line">    &#125;()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 有参数: 定义时传值，使用当时的值</span></span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">(x <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">        fmt.Println(x)  <span class="comment">// 10</span></span><br><span class="line">    &#125;(a)</span><br><span class="line">    </span><br><span class="line">    a = <span class="number">100</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出:</span></span><br><span class="line"><span class="comment">// 10</span></span><br><span class="line"><span class="comment">// 100</span></span><br></pre></td></tr></table></figure><p>总结: 想要 <code>defer</code> 时的值，就传参数; 想要最终值，就用闭包捕获。</p><hr><h3 id="7-指针"><a href="#7-指针" class="headerlink" title="7. 指针"></a>7. 指针</h3><p>指针存的是内存地址。<code>&amp;</code> 取地址，<code>*</code> 取值。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="type">int</span> = <span class="number">10</span></span><br><span class="line"></span><br><span class="line">fmt.Println(a)   <span class="comment">// 10，变量的值</span></span><br><span class="line">fmt.Println(&amp;a)  <span class="comment">// 0xc0000..，变量的地址</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p *<span class="type">int</span> = &amp;a  <span class="comment">// p 是指针，存的是 a 的地址</span></span><br><span class="line">fmt.Println(p)   <span class="comment">// 0xc0000..，和 &amp;a 一样</span></span><br><span class="line">fmt.Println(*p)  <span class="comment">// 10，指针指向的值</span></span><br><span class="line"></span><br><span class="line">*p = <span class="number">20</span>          <span class="comment">// 通过指针修改值</span></span><br><span class="line">fmt.Println(a)   <span class="comment">// 20，a 被改了</span></span><br></pre></td></tr></table></figure><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><p><strong>不要操作未初始化的指针</strong>: 指针默认值是 <code>nil</code>，解引用会崩。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p *<span class="type">int</span>       <span class="comment">// nil</span></span><br><span class="line"><span class="comment">// *p = 666      // panic!</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a <span class="type">int</span></span><br><span class="line">p = &amp;a           <span class="comment">// 先指向一个变量</span></span><br><span class="line">*p = <span class="number">666</span>         <span class="comment">// OK</span></span><br></pre></td></tr></table></figure><p><strong>不能取常量或字面量的地址</strong>:</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> i = <span class="number">5</span></span><br><span class="line"><span class="comment">// &amp;i   // 错误</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// &amp;10  // 错误</span></span><br></pre></td></tr></table></figure><p><strong>不支持指针运算</strong>: 和 <code>C</code> 不一样，<code>Go</code> 不能 <code>p++</code> 或 <code>p + 2</code>。</p><h4 id="值传递-vs-指针传递"><a href="#值传递-vs-指针传递" class="headerlink" title="值传递 vs 指针传递"></a>值传递 vs 指针传递</h4><p>值传递复制一份，改不了原变量; 指针传递传地址，能改原变量。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 值传递: 交换失败</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swapByValue</span><span class="params">(a, b <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    a, b = b, a  <span class="comment">// 只改了副本</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指针传递: 交换成功</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swapByPointer</span><span class="params">(a, b *<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    *a, *b = *b, *a</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x, y := <span class="number">10</span>, <span class="number">20</span></span><br><span class="line">    </span><br><span class="line">    swapByValue(x, y)</span><br><span class="line">    fmt.Println(x, y)  <span class="comment">// 10 20，没变</span></span><br><span class="line">    </span><br><span class="line">    swapByPointer(&amp;x, &amp;y)</span><br><span class="line">    fmt.Println(x, y)  <span class="comment">// 20 10，交换了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="8-数组"><a href="#8-数组" class="headerlink" title="8. 数组"></a>8. 数组</h3><p>数组是固定长度、同一类型的数据集合。长度必须是常量，定义后不能改。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr [<span class="number">5</span>]<span class="type">int</span>              <span class="comment">// 5 个 int，默认都是 0</span></span><br><span class="line">fmt.Println(arr)            <span class="comment">// [0 0 0 0 0]</span></span><br><span class="line">fmt.Println(<span class="built_in">len</span>(arr))       <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line">arr[<span class="number">0</span>] = <span class="number">10</span>                 <span class="comment">// 下标从 0 开始</span></span><br><span class="line">fmt.Println(arr[<span class="number">0</span>])         <span class="comment">// 10</span></span><br></pre></td></tr></table></figure><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 全部初始化</span></span><br><span class="line">a := [<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 部分初始化，剩下的是零值</span></span><br><span class="line">b := [<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;        <span class="comment">// [1 2 3 0 0]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定下标初始化</span></span><br><span class="line">c := [<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">2</span>: <span class="number">10</span>, <span class="number">4</span>: <span class="number">20</span>&#125;   <span class="comment">// [0 0 10 0 20]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 让编译器数长度</span></span><br><span class="line">d := [...]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;      <span class="comment">// 长度是 3</span></span><br></pre></td></tr></table></figure><h4 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">arr := [<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// for 循环</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(arr); i++ &#123;</span><br><span class="line">    fmt.Println(arr[i])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// range，更简洁</span></span><br><span class="line"><span class="keyword">for</span> i, v := <span class="keyword">range</span> arr &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;arr[%d] = %d\n&quot;</span>, i, v)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只要值，不要下标</span></span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> arr &#123;</span><br><span class="line">    fmt.Println(v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="9-切片"><a href="#9-切片" class="headerlink" title="9. 切片"></a>9. 切片</h3><p>数组长度固定，切片长度可变。切片是引用类型。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数组: 长度固定，类型是 [5]int</span></span><br><span class="line"><span class="keyword">var</span> arr [<span class="number">5</span>]<span class="type">int</span> = [<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 切片: 长度可变，类型是 []int</span></span><br><span class="line"><span class="keyword">var</span> s []<span class="type">int</span> = []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br></pre></td></tr></table></figure><h4 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 直接初始化</span></span><br><span class="line">s := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// make(类型, 长度, 容量)</span></span><br><span class="line">s1 := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">5</span>, <span class="number">10</span>)  <span class="comment">// 长度 5，容量 10</span></span><br><span class="line">s2 := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">5</span>)      <span class="comment">// 长度和容量都是 5</span></span><br></pre></td></tr></table></figure><p><code>len()</code> 是当前元素个数，<code>cap()</code> 是底层数组能容纳的最大个数。</p><h4 id="切片截取"><a href="#切片截取" class="headerlink" title="切片截取"></a>切片截取</h4><p>切片可以从数组或另一个切片截取，语法是 <code>s[low:high]</code>，包含 <code>low</code> 不包含 <code>high</code>。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s := []<span class="type">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;</span><br><span class="line"></span><br><span class="line">s[<span class="number">2</span>]      <span class="comment">// 2，单个元素</span></span><br><span class="line">s[:]      <span class="comment">// [0 1 2 3 4 5 6 7 8 9]，全部</span></span><br><span class="line">s[<span class="number">3</span>:]     <span class="comment">// [3 4 5 6 7 8 9]，从下标 3 到末尾</span></span><br><span class="line">s[:<span class="number">5</span>]     <span class="comment">// [0 1 2 3 4]，从开头到下标 4</span></span><br><span class="line">s[<span class="number">2</span>:<span class="number">7</span>]    <span class="comment">// [2 3 4 5 6]，下标 2 到 6</span></span><br></pre></td></tr></table></figure><p>还可以用第三个参数限制容量: <code>s[low:high:max]</code>，容量是 <code>max - low</code>。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s[<span class="number">2</span>:<span class="number">5</span>:<span class="number">8</span>]  <span class="comment">// [2 3 4]，长度 3，容量 6</span></span><br></pre></td></tr></table></figure><hr><h3 id="10-Map"><a href="#10-Map" class="headerlink" title="10. Map"></a>10. Map</h3><p><code>map</code> 是键值对的集合，无序。<code>key</code> 必须是可比较的类型 (支持 <code>==</code>)。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明</span></span><br><span class="line"><span class="keyword">var</span> m1 <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>          <span class="comment">// nil map，不能直接用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// make 创建</span></span><br><span class="line">m2 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)     <span class="comment">// 空 map，可以用</span></span><br><span class="line">m3 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>, <span class="number">10</span>) <span class="comment">// 指定初始容量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接初始化</span></span><br><span class="line">m4 := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;</span><br><span class="line">    <span class="string">&quot;alice&quot;</span>: <span class="number">18</span>,</span><br><span class="line">    <span class="string">&quot;bob&quot;</span>:   <span class="number">20</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="增删改查"><a href="#增删改查" class="headerlink" title="增删改查"></a>增删改查</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">m := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;<span class="string">&quot;alice&quot;</span>: <span class="number">18</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加/修改</span></span><br><span class="line">m[<span class="string">&quot;bob&quot;</span>] = <span class="number">20</span>     <span class="comment">// 添加</span></span><br><span class="line">m[<span class="string">&quot;alice&quot;</span>] = <span class="number">19</span>   <span class="comment">// 修改</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询</span></span><br><span class="line">age := m[<span class="string">&quot;alice&quot;</span>]           <span class="comment">// 19</span></span><br><span class="line">age, ok := m[<span class="string">&quot;charlie&quot;</span>]     <span class="comment">// 0, false (不存在)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断 key 是否存在</span></span><br><span class="line"><span class="keyword">if</span> val, ok := m[<span class="string">&quot;bob&quot;</span>]; ok &#123;</span><br><span class="line">    fmt.Println(val)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除</span></span><br><span class="line"><span class="built_in">delete</span>(m, <span class="string">&quot;alice&quot;</span>)</span><br></pre></td></tr></table></figure><h4 id="遍历-1"><a href="#遍历-1" class="headerlink" title="遍历"></a>遍历</h4><p><code>map</code> 遍历顺序是随机的。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">m := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;<span class="string">&quot;a&quot;</span>: <span class="number">1</span>, <span class="string">&quot;b&quot;</span>: <span class="number">2</span>, <span class="string">&quot;c&quot;</span>: <span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> m &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%s: %d\n&quot;</span>, k, v)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只要 key</span></span><br><span class="line"><span class="keyword">for</span> k := <span class="keyword">range</span> m &#123;</span><br><span class="line">    fmt.Println(k)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h4><p><code>map</code> 是引用类型，传参时不会复制，函数内修改会影响原 <code>map</code>。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addKey</span><span class="params">(m <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    m[<span class="string">&quot;new&quot;</span>] = <span class="number">100</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    m := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;<span class="string">&quot;a&quot;</span>: <span class="number">1</span>&#125;</span><br><span class="line">    addKey(m)</span><br><span class="line">    fmt.Println(m)  <span class="comment">// map[a:1 new:100]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="11-结构体"><a href="#11-结构体" class="headerlink" title="11. 结构体"></a>11. 结构体</h3><p>结构体是不同类型数据的集合。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">    ID   <span class="type">int</span></span><br><span class="line">    Name <span class="type">string</span></span><br><span class="line">    Age  <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="初始化-2"><a href="#初始化-2" class="headerlink" title="初始化"></a>初始化</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 顺序初始化，必须全部字段</span></span><br><span class="line">s1 := Student&#123;<span class="number">1</span>, <span class="string">&quot;mike&quot;</span>, <span class="number">18</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定字段，未指定的是零值</span></span><br><span class="line">s2 := Student&#123;Name: <span class="string">&quot;bob&quot;</span>, Age: <span class="number">20</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 先声明后赋值</span></span><br><span class="line"><span class="keyword">var</span> s3 Student</span><br><span class="line">s3.ID = <span class="number">1</span></span><br><span class="line">s3.Name = <span class="string">&quot;alice&quot;</span></span><br></pre></td></tr></table></figure><h4 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 取地址</span></span><br><span class="line">p1 := &amp;Student&#123;<span class="number">1</span>, <span class="string">&quot;mike&quot;</span>, <span class="number">18</span>&#125;</span><br><span class="line">p2 := &amp;Student&#123;Name: <span class="string">&quot;bob&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// new 创建</span></span><br><span class="line">p3 := <span class="built_in">new</span>(Student)</span><br><span class="line">p3.ID = <span class="number">1</span></span><br><span class="line">p3.Name = <span class="string">&quot;alice&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 指针访问成员，p.Name 和 (*p).Name 等价</span></span><br><span class="line">fmt.Println(p1.Name)</span><br></pre></td></tr></table></figure><h4 id="比较和赋值"><a href="#比较和赋值" class="headerlink" title="比较和赋值"></a>比较和赋值</h4><p>同类型结构体可以用 <code>==</code> 比较，也可以直接赋值。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s1 := Student&#123;<span class="number">1</span>, <span class="string">&quot;mike&quot;</span>, <span class="number">18</span>&#125;</span><br><span class="line">s2 := Student&#123;<span class="number">1</span>, <span class="string">&quot;mike&quot;</span>, <span class="number">18</span>&#125;</span><br><span class="line">s3 := Student&#123;<span class="number">2</span>, <span class="string">&quot;bob&quot;</span>, <span class="number">20</span>&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(s1 == s2)  <span class="comment">// true</span></span><br><span class="line">fmt.Println(s1 == s3)  <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">s4 := s1  <span class="comment">// 复制一份</span></span><br></pre></td></tr></table></figure><h4 id="值传递-vs-指针传递-1"><a href="#值传递-vs-指针传递-1" class="headerlink" title="值传递 vs 指针传递"></a>值传递 vs 指针传递</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 值传递: 改不了原变量</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">updateByValue</span><span class="params">(s Student)</span></span> &#123;</span><br><span class="line">    s.Age = <span class="number">100</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指针传递: 能改原变量</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">updateByPointer</span><span class="params">(s *Student)</span></span> &#123;</span><br><span class="line">    s.Age = <span class="number">100</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s := Student&#123;<span class="number">1</span>, <span class="string">&quot;mike&quot;</span>, <span class="number">18</span>&#125;</span><br><span class="line">    </span><br><span class="line">    updateByValue(s)</span><br><span class="line">    fmt.Println(s.Age)  <span class="comment">// 18，没变</span></span><br><span class="line">    </span><br><span class="line">    updateByPointer(&amp;s)</span><br><span class="line">    fmt.Println(s.Age)  <span class="comment">// 100，改了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h4><p>首字母大写是公开的 (<code>public</code>)，小写是私有的 (<code>private</code>，仅包内可见)。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">    ID   <span class="type">int</span>     <span class="comment">// 公开</span></span><br><span class="line">    Name <span class="type">string</span>  <span class="comment">// 公开</span></span><br><span class="line">    age  <span class="type">int</span>     <span class="comment">// 私有，其他包访问不了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="12-匿名组合"><a href="#12-匿名组合" class="headerlink" title="12. 匿名组合"></a>12. 匿名组合</h3><p><code>Go</code> 没有传统的继承，但可以通过匿名字段实现类似效果。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="type">string</span></span><br><span class="line">    Age  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">    Person       <span class="comment">// 匿名字段，继承 Person 的所有字段</span></span><br><span class="line">    ID   <span class="type">int</span></span><br><span class="line">    Addr <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="初始化-3"><a href="#初始化-3" class="headerlink" title="初始化"></a>初始化</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 顺序初始化</span></span><br><span class="line">s1 := Student&#123;Person&#123;<span class="string">&quot;mike&quot;</span>, <span class="number">18</span>&#125;, <span class="number">1</span>, <span class="string">&quot;beijing&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定字段</span></span><br><span class="line">s2 := Student&#123;</span><br><span class="line">    Person: Person&#123;Name: <span class="string">&quot;bob&quot;</span>&#125;,</span><br><span class="line">    ID:     <span class="number">2</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="访问成员"><a href="#访问成员" class="headerlink" title="访问成员"></a>访问成员</h4><p>匿名字段的成员可以直接访问，不用写完整路径。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s := Student&#123;Person&#123;<span class="string">&quot;mike&quot;</span>, <span class="number">18</span>&#125;, <span class="number">1</span>, <span class="string">&quot;beijing&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接访问</span></span><br><span class="line">fmt.Println(s.Name)  <span class="comment">// mike</span></span><br><span class="line">fmt.Println(s.Age)   <span class="comment">// 18</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以写完整路径</span></span><br><span class="line">fmt.Println(s.Person.Name)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改</span></span><br><span class="line">s.Name = <span class="string">&quot;bob&quot;</span></span><br><span class="line">s.Person = Person&#123;<span class="string">&quot;alice&quot;</span>, <span class="number">20</span>&#125;</span><br></pre></td></tr></table></figure><h4 id="同名字段"><a href="#同名字段" class="headerlink" title="同名字段"></a>同名字段</h4><p>如果外层和匿名字段有同名成员，就近原则。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">    Person</span><br><span class="line">    Name <span class="type">string</span>  <span class="comment">// 和 Person.Name 重名</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> s Student</span><br><span class="line">    s.Name = <span class="string">&quot;student&quot;</span>        <span class="comment">// Student.Name</span></span><br><span class="line">    s.Person.Name = <span class="string">&quot;person&quot;</span>  <span class="comment">// Person.Name</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="指针类型匿名字段"><a href="#指针类型匿名字段" class="headerlink" title="指针类型匿名字段"></a>指针类型匿名字段</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">    *Person  <span class="comment">// 指针类型</span></span><br><span class="line">    ID <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s1 := Student&#123;&amp;Person&#123;<span class="string">&quot;mike&quot;</span>, <span class="number">18</span>&#125;, <span class="number">1</span>&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 或者用 new</span></span><br><span class="line">    <span class="keyword">var</span> s2 Student</span><br><span class="line">    s2.Person = <span class="built_in">new</span>(Person)</span><br><span class="line">    s2.Name = <span class="string">&quot;bob&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="13-方法"><a href="#13-方法" class="headerlink" title="13. 方法"></a>13. 方法</h3><p>方法是带接收者的函数，语法: <code>func (receiver Type) methodName(params) returns</code></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="type">string</span></span><br><span class="line">    Age  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 值接收者</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span></span> PrintInfo() &#123;</span><br><span class="line">    fmt.Println(p.Name, p.Age)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指针接收者</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Person)</span></span> SetAge(age <span class="type">int</span>) &#123;</span><br><span class="line">    p.Age = age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    p := Person&#123;<span class="string">&quot;mike&quot;</span>, <span class="number">18</span>&#125;</span><br><span class="line">    p.PrintInfo()   <span class="comment">// mike 18</span></span><br><span class="line">    p.SetAge(<span class="number">20</span>)</span><br><span class="line">    fmt.Println(p.Age)  <span class="comment">// 20</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="值接收者-vs-指针接收者"><a href="#值接收者-vs-指针接收者" class="headerlink" title="值接收者 vs 指针接收者"></a>值接收者 vs 指针接收者</h4><p>值接收者是拷贝，改不了原变量; 指针接收者是引用，能改原变量。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span></span> SetByValue(name <span class="type">string</span>) &#123;</span><br><span class="line">    p.Name = name  <span class="comment">// 改的是副本</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Person)</span></span> SetByPointer(name <span class="type">string</span>) &#123;</span><br><span class="line">    p.Name = name  <span class="comment">// 改的是原变量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    p := Person&#123;<span class="string">&quot;mike&quot;</span>, <span class="number">18</span>&#125;</span><br><span class="line">    </span><br><span class="line">    p.SetByValue(<span class="string">&quot;bob&quot;</span>)</span><br><span class="line">    fmt.Println(p.Name)  <span class="comment">// mike，没变</span></span><br><span class="line">    </span><br><span class="line">    p.SetByPointer(<span class="string">&quot;bob&quot;</span>)</span><br><span class="line">    fmt.Println(p.Name)  <span class="comment">// bob，变了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方法继承"><a href="#方法继承" class="headerlink" title="方法继承"></a>方法继承</h4><p>匿名字段的方法会被继承。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span></span> Say() &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;I&#x27;m&quot;</span>, p.Name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">    Person</span><br><span class="line">    ID <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s := Student&#123;Person&#123;<span class="string">&quot;mike&quot;</span>&#125;, <span class="number">1</span>&#125;</span><br><span class="line">    s.Say()  <span class="comment">// I&#x27;m mike</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方法重写"><a href="#方法重写" class="headerlink" title="方法重写"></a>方法重写</h4><p>子类型可以定义同名方法覆盖父类型，就近原则。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Student)</span></span> Say() &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Student:&quot;</span>, s.Name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s := Student&#123;Person&#123;<span class="string">&quot;mike&quot;</span>&#125;, <span class="number">1</span>&#125;</span><br><span class="line">    s.Say()         <span class="comment">// Student: mike</span></span><br><span class="line">    s.Person.Say()  <span class="comment">// I&#x27;m mike，显式调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="14-接口"><a href="#14-接口" class="headerlink" title="14. 接口"></a>14. 接口</h3><p>接口是方法签名的集合，定义行为不定义实现。实现了接口所有方法的类型就实现了该接口，不需要显式声明。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Humaner <span class="keyword">interface</span> &#123;</span><br><span class="line">    SayHi()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="实现接口"><a href="#实现接口" class="headerlink" title="实现接口"></a>实现接口</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Student)</span></span> SayHi() &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Student:&quot;</span>, s.Name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Teacher <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Teacher)</span></span> SayHi() &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Teacher:&quot;</span>, t.Name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> h Humaner</span><br><span class="line">    </span><br><span class="line">    h = &amp;Student&#123;<span class="string">&quot;mike&quot;</span>&#125;</span><br><span class="line">    h.SayHi()  <span class="comment">// Student: mike</span></span><br><span class="line">    </span><br><span class="line">    h = &amp;Teacher&#123;<span class="string">&quot;bob&quot;</span>&#125;</span><br><span class="line">    h.SayHi()  <span class="comment">// Teacher: bob</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h4><p>同一个接口，不同类型有不同表现。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WhoSayHi</span><span class="params">(h Humaner)</span></span> &#123;</span><br><span class="line">    h.SayHi()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s := &amp;Student&#123;<span class="string">&quot;mike&quot;</span>&#125;</span><br><span class="line">    t := &amp;Teacher&#123;<span class="string">&quot;bob&quot;</span>&#125;</span><br><span class="line">    </span><br><span class="line">    WhoSayHi(s)  <span class="comment">// Student: mike</span></span><br><span class="line">    WhoSayHi(t)  <span class="comment">// Teacher: bob</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 切片存不同类型</span></span><br><span class="line">    people := []Humaner&#123;s, t&#125;</span><br><span class="line">    <span class="keyword">for</span> _, p := <span class="keyword">range</span> people &#123;</span><br><span class="line">        p.SayHi()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="接口继承"><a href="#接口继承" class="headerlink" title="接口继承"></a>接口继承</h4><p>接口可以嵌入其他接口。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Humaner <span class="keyword">interface</span> &#123;</span><br><span class="line">    SayHi()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Personer <span class="keyword">interface</span> &#123;</span><br><span class="line">    Humaner           <span class="comment">// 继承 Humaner</span></span><br><span class="line">    Sing(lrc <span class="type">string</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现 <code>Personer</code> 必须同时实现 <code>SayHi()</code> 和 <code>Sing()</code>。</p><h4 id="空接口"><a href="#空接口" class="headerlink" title="空接口"></a>空接口</h4><p><code>interface&#123;&#125;</code> 可以存任意类型。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> i <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">i = <span class="number">1</span></span><br><span class="line">i = <span class="string">&quot;hello&quot;</span></span><br><span class="line">i = &amp;Student&#123;<span class="string">&quot;mike&quot;</span>&#125;</span><br></pre></td></tr></table></figure><h4 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h4><p>从空接口取出具体类型。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> i <span class="keyword">interface</span>&#123;&#125; = <span class="string">&quot;hello&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// if 判断</span></span><br><span class="line"><span class="keyword">if</span> s, ok := i.(<span class="type">string</span>); ok &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;是 string:&quot;</span>, s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// switch 判断</span></span><br><span class="line"><span class="keyword">switch</span> v := i.(<span class="keyword">type</span>) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="type">int</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;int:&quot;</span>, v)</span><br><span class="line"><span class="keyword">case</span> <span class="type">string</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;string:&quot;</span>, v)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;其他类型&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="15-Error-接口"><a href="#15-Error-接口" class="headerlink" title="15. Error 接口"></a>15. Error 接口</h3><p><code>error</code> 是 <code>Go</code> 内建的接口，用于错误处理。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="type">error</span> <span class="keyword">interface</span> &#123;</span><br><span class="line">    Error() <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="创建-error"><a href="#创建-error" class="headerlink" title="创建 error"></a>创建 error</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;errors&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// errors.New</span></span><br><span class="line">err1 := errors.New(<span class="string">&quot;something went wrong&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// fmt.Errorf，支持格式化</span></span><br><span class="line">err2 := fmt.Errorf(<span class="string">&quot;user %d not found&quot;</span>, <span class="number">123</span>)</span><br></pre></td></tr></table></figure><h4 id="错误处理模式"><a href="#错误处理模式" class="headerlink" title="错误处理模式"></a>错误处理模式</h4><p><code>Go</code> 的惯例是函数返回值最后一个是 <code>error</code>，调用后检查是否为 <code>nil</code>。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Divide</span><span class="params">(a, b <span class="type">int</span>)</span></span> (<span class="type">int</span>, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> b == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>, errors.New(<span class="string">&quot;division by zero&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a / b, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    result, err := Divide(<span class="number">10</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;错误:&quot;</span>, err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;结果:&quot;</span>, result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>标准模式:</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">result, err := someFunction()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="comment">// 处理错误</span></span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 继续用 result</span></span><br></pre></td></tr></table></figure><hr><h3 id="16-Panic"><a href="#16-Panic" class="headerlink" title="16. Panic"></a>16. Panic</h3><p><code>panic</code> 是严重错误，触发后程序崩溃。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;开始&quot;</span>)</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;出错了&quot;</span>)</span><br><span class="line">    fmt.Println(<span class="string">&quot;不会执行&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出:</span></span><br><span class="line"><span class="comment">// 开始</span></span><br><span class="line"><span class="comment">// panic: 出错了</span></span><br></pre></td></tr></table></figure><h4 id="触发方式"><a href="#触发方式" class="headerlink" title="触发方式"></a>触发方式</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 手动触发</span></span><br><span class="line"><span class="built_in">panic</span>(<span class="string">&quot;something went wrong&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行时错误自动触发</span></span><br><span class="line"><span class="keyword">var</span> a [<span class="number">10</span>]<span class="type">int</span></span><br><span class="line">a[<span class="number">20</span>] = <span class="number">1</span>  <span class="comment">// 数组越界 -&gt; panic</span></span><br></pre></td></tr></table></figure><h4 id="panic-与-defer"><a href="#panic-与-defer" class="headerlink" title="panic 与 defer"></a>panic 与 defer</h4><p><code>panic</code> 之前注册的 <code>defer</code> 会执行，常用于清理资源。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> fmt.Println(<span class="string">&quot;清理工作&quot;</span>)</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;出错&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出:</span></span><br><span class="line"><span class="comment">// 清理工作</span></span><br><span class="line"><span class="comment">// panic: 出错</span></span><br></pre></td></tr></table></figure><hr><h3 id="17-Recover"><a href="#17-Recover" class="headerlink" title="17. Recover"></a>17. Recover</h3><p><code>recover</code> 捕获 <code>panic</code>，防止程序崩溃。必须在 <code>defer</code> 中使用。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> err := <span class="built_in">recover</span>(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">&quot;捕获到:&quot;</span>, err)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;出错了&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    test()</span><br><span class="line">    fmt.Println(<span class="string">&quot;程序继续运行&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出:</span></span><br><span class="line"><span class="comment">// 捕获到: 出错了</span></span><br><span class="line"><span class="comment">// 程序继续运行</span></span><br></pre></td></tr></table></figure><p>不用 <code>recover</code>，<code>panic</code> 会让整个程序崩溃; 用了 <code>recover</code>，程序可以继续执行。</p><hr><h3 id="18-Goroutine"><a href="#18-Goroutine" class="headerlink" title="18. Goroutine"></a>18. Goroutine</h3><p><code>go</code> 关键字创建协程，非常轻量，可以轻松创建成千上万个。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">task</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;任务执行&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> task()  <span class="comment">// 创建协程，异步执行</span></span><br><span class="line">    time.Sleep(time.Second)  <span class="comment">// 等一下，否则 main 退出子协程也没了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主协程退出，所有子协程也会退出。</p><h4 id="WaitGroup"><a href="#WaitGroup" class="headerlink" title="WaitGroup"></a>WaitGroup</h4><p>用 <code>sync.WaitGroup</code> 等待所有协程完成。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">task</span><span class="params">(id <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> wg.Done()</span><br><span class="line">    fmt.Println(<span class="string">&quot;任务&quot;</span>, id)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">go</span> task(i)</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Wait()  <span class="comment">// 等待全部完成</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">runtime.Gosched()       <span class="comment">// 让出 CPU，让其他协程先跑</span></span><br><span class="line">runtime.Goexit()        <span class="comment">// 退出当前协程</span></span><br><span class="line">runtime.GOMAXPROCS(n)   <span class="comment">// 设置使用的 CPU 核数</span></span><br></pre></td></tr></table></figure><hr><h3 id="19-Channel"><a href="#19-Channel" class="headerlink" title="19. Channel"></a>19. Channel</h3><p><code>channel</code> 用于 <code>goroutine</code> 之间通信，类似管道，一端发一端收，并发安全。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)      <span class="comment">// 无缓冲</span></span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">10</span>)  <span class="comment">// 有缓冲，容量 10</span></span><br><span class="line"></span><br><span class="line">ch &lt;- <span class="number">10</span>    <span class="comment">// 发送</span></span><br><span class="line">x := &lt;-ch   <span class="comment">// 接收</span></span><br></pre></td></tr></table></figure><h4 id="无缓冲-channel"><a href="#无缓冲-channel" class="headerlink" title="无缓冲 channel"></a>无缓冲 channel</h4><p>发送方会阻塞，直到有接收方准备好。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch &lt;- <span class="number">10</span>  <span class="comment">// 阻塞，直到有人接收</span></span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">x := &lt;-ch  <span class="comment">// 接收</span></span><br></pre></td></tr></table></figure><h4 id="有缓冲-channel"><a href="#有缓冲-channel" class="headerlink" title="有缓冲 channel"></a>有缓冲 channel</h4><p>缓冲区没满就不阻塞，满了才阻塞。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">ch &lt;- <span class="number">1</span>  <span class="comment">// 不阻塞</span></span><br><span class="line">ch &lt;- <span class="number">2</span>  <span class="comment">// 不阻塞</span></span><br><span class="line">ch &lt;- <span class="number">3</span>  <span class="comment">// 不阻塞</span></span><br><span class="line">ch &lt;- <span class="number">4</span>  <span class="comment">// 阻塞，满了</span></span><br><span class="line"></span><br><span class="line">&lt;-ch     <span class="comment">// 取走一个，腾出位置</span></span><br></pre></td></tr></table></figure><h4 id="关闭和遍历"><a href="#关闭和遍历" class="headerlink" title="关闭和遍历"></a>关闭和遍历</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">        ch &lt;- i</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(ch)  <span class="comment">// 发完了，关闭</span></span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> v := <span class="keyword">range</span> ch &#123;  <span class="comment">// 自动遍历直到关闭</span></span><br><span class="line">    fmt.Println(v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关闭后不能再发送，但可以继续接收剩余数据。</p><h4 id="单向-channel"><a href="#单向-channel" class="headerlink" title="单向 channel"></a>单向 channel</h4><p>限制只能发或只能收，用于函数参数约束。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">send</span><span class="params">(ch <span class="keyword">chan</span>&lt;- <span class="type">int</span>)</span></span> &#123;  <span class="comment">// 只能发</span></span><br><span class="line">    ch &lt;- <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">receive</span><span class="params">(ch &lt;-<span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;  <span class="comment">// 只能收</span></span><br><span class="line">    x := &lt;-ch</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Timer: 一次性</span></span><br><span class="line">timer := time.NewTimer(<span class="number">2</span> * time.Second)</span><br><span class="line">&lt;-timer.C</span><br><span class="line">fmt.Println(<span class="string">&quot;时间到&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Ticker: 周期性</span></span><br><span class="line">ticker := time.NewTicker(time.Second)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">    &lt;-ticker.C</span><br><span class="line">    fmt.Println(<span class="string">&quot;tick&quot;</span>, i)</span><br><span class="line">&#125;</span><br><span class="line">ticker.Stop()</span><br></pre></td></tr></table></figure><hr><h3 id="20-Select"><a href="#20-Select" class="headerlink" title="20. Select"></a>20. Select</h3><p><code>select</code> 同时监听多个 <code>channel</code>，哪个准备好就执行哪个。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> x := &lt;-ch1:</span><br><span class="line">    fmt.Println(<span class="string">&quot;从 ch1 收到&quot;</span>, x)</span><br><span class="line"><span class="keyword">case</span> ch2 &lt;- y:</span><br><span class="line">    fmt.Println(<span class="string">&quot;发送到 ch2&quot;</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;都没准备好&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ch1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">ch2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    time.Sleep(time.Second)</span><br><span class="line">    ch1 &lt;- <span class="number">1</span></span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">    ch2 &lt;- <span class="number">2</span></span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> x := &lt;-ch1:</span><br><span class="line">    fmt.Println(<span class="string">&quot;ch1:&quot;</span>, x)  <span class="comment">// 先到，执行这个</span></span><br><span class="line"><span class="keyword">case</span> x := &lt;-ch2:</span><br><span class="line">    fmt.Println(<span class="string">&quot;ch2:&quot;</span>, x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="超时处理"><a href="#超时处理" class="headerlink" title="超时处理"></a>超时处理</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> x := &lt;-ch:</span><br><span class="line">    fmt.Println(<span class="string">&quot;收到:&quot;</span>, x)</span><br><span class="line"><span class="keyword">case</span> &lt;-time.After(<span class="number">3</span> * time.Second):</span><br><span class="line">    fmt.Println(<span class="string">&quot;超时&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="斐波那契示例"><a href="#斐波那契示例" class="headerlink" title="斐波那契示例"></a>斐波那契示例</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fibonacci</span><span class="params">(ch <span class="keyword">chan</span>&lt;- <span class="type">int</span>, quit &lt;-<span class="keyword">chan</span> <span class="type">bool</span>)</span></span> &#123;</span><br><span class="line">    x, y := <span class="number">1</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> ch &lt;- x:</span><br><span class="line">            x, y = y, x+y</span><br><span class="line">        <span class="keyword">case</span> &lt;-quit:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">    quit := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">8</span>; i++ &#123;</span><br><span class="line">            fmt.Println(&lt;-ch)</span><br><span class="line">        &#125;</span><br><span class="line">        quit &lt;- <span class="literal">true</span></span><br><span class="line">    &#125;()</span><br><span class="line">    </span><br><span class="line">    fibonacci(ch, quit)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h4><ul><li>多个 <code>case</code> 同时准备好时随机选一个</li><li><code>default</code> 在所有 <code>case</code> 阻塞时执行</li><li>常用于超时控制和多路复用</li></ul><hr><h3 id="21-锁-sync"><a href="#21-锁-sync" class="headerlink" title="21. 锁 (sync)"></a>21. 锁 (sync)</h3><p>多个 <code>goroutine</code> 同时访问共享资源会有竞态问题，需要锁来保证安全。</p><h4 id="互斥锁-sync-Mutex"><a href="#互斥锁-sync-Mutex" class="headerlink" title="互斥锁 sync.Mutex"></a>互斥锁 sync.Mutex</h4><p>同一时刻只有一个 <code>goroutine</code> 能访问。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"><span class="keyword">var</span> lock sync.Mutex</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> wg.Done()</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++ &#123;</span><br><span class="line">        lock.Lock()</span><br><span class="line">        x = x + <span class="number">1</span></span><br><span class="line">        lock.Unlock()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    wg.Add(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">go</span> add()</span><br><span class="line">    <span class="keyword">go</span> add()</span><br><span class="line">    wg.Wait()</span><br><span class="line">    fmt.Println(x)  <span class="comment">// 10000</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="读写锁-sync-RWMutex"><a href="#读写锁-sync-RWMutex" class="headerlink" title="读写锁 sync.RWMutex"></a>读写锁 sync.RWMutex</h4><p>读多写少的场景用这个。多个读可以同时进行，写独占。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> rwlock sync.RWMutex</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">write</span><span class="params">()</span></span> &#123;</span><br><span class="line">    rwlock.Lock()      <span class="comment">// 写锁</span></span><br><span class="line">    x = x + <span class="number">1</span></span><br><span class="line">    rwlock.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">read</span><span class="params">()</span></span> &#123;</span><br><span class="line">    rwlock.RLock()     <span class="comment">// 读锁</span></span><br><span class="line">    fmt.Println(x)</span><br><span class="line">    rwlock.RUnlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="sync-Once"><a href="#sync-Once" class="headerlink" title="sync.Once"></a>sync.Once</h4><p>确保某操作只执行一次，常用于单例初始化。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> once sync.Once</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    once.Do(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;只执行一次&quot;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="sync-Map"><a href="#sync-Map" class="headerlink" title="sync.Map"></a>sync.Map</h4><p>并发安全的 <code>map</code>，不需要额外加锁。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> m sync.Map</span><br><span class="line"></span><br><span class="line">m.Store(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;value&quot;</span>)        <span class="comment">// 存</span></span><br><span class="line">value, ok := m.Load(<span class="string">&quot;key&quot;</span>)     <span class="comment">// 取</span></span><br><span class="line">m.Delete(<span class="string">&quot;key&quot;</span>)                <span class="comment">// 删</span></span><br></pre></td></tr></table></figure></article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/GO/">GO</a></div><div class="post_share"></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/13fe9182.html" title="JS 原型链"><img class="cover" src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img700px-Dot_scenario_s1_ep3.png" onerror='onerror=null,src="https://cdn.jsdelivr.net/gh/Hongda-OSU/PicGo/image/404.GIF"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">JS 原型链</div></div></a></div><div class="next-post pull-right"><a href="/posts/d58818f0.html" title="WebGL 学习笔记"><img class="cover" src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img20gl0lfaktxca5b80bf9c5qkfujbla7.png" onerror='onerror=null,src="https://cdn.jsdelivr.net/gh/Hongda-OSU/PicGo/image/404.GIF"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">WebGL 学习笔记</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://cdn.jsdelivr.net/gh/Hongda-OSU/PicGo/image/德狗子.GIF" onerror='this.onerror=null,this.src="https://cdn.jsdelivr.net/gh/Hongda-OSU/PicGo/image/404.GIF"' alt="avatar"></div><div class="author-info__name">鴻達</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">31</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">16</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Hongda-OSU" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="https://www.linkedin.com/in/hongda-lin" target="_blank" title="Linkedin"><i class="fab fa-linkedin"></i></a><a class="social-icon" href="https://hongdalin.me" target="_blank" title="Portfolio"><i class="iconfont icon-guanfangwangzhan"></i></a></div></div><script src="https://npm.elemecdn.com/ethan4116-blog/lib/js/other/two-people/twopeople1.js"></script><script src="https://npm.elemecdn.com/ethan4116-blog/lib/js/other/two-people/zdog.dist.js"></script><script id="rendered-js" src="https://npm.elemecdn.com/ethan4116-blog/lib/js/other/two-people/twopeople.js"></script><style>.card-widget.card-announcement{margin:0;align-items:center;justify-content:center;text-align:center}canvas{display:block;margin:0 auto;cursor:move}</style><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AFGo%E8%AF%AD%E8%A8%80"><span class="toc-text">1. 什么是Go语言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%8C%85%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-text">2. 包的概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E"><span class="toc-text">3. 变量声明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E8%B5%8B%E5%80%BC"><span class="toc-text">4. 赋值</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%83%E7%BB%84%E8%B5%8B%E5%80%BC"><span class="toc-text">元组赋值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E8%B5%8B%E5%80%BC%E6%80%A7"><span class="toc-text">可赋值性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%87%BD%E6%95%B0%E5%9F%BA%E7%A1%80"><span class="toc-text">5. 函数基础</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E6%95%B0"><span class="toc-text">参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-text">返回值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B"><span class="toc-text">函数调用流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%92%E5%BD%92"><span class="toc-text">递归</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E5%87%BD%E6%95%B0%E8%BF%9B%E9%98%B6"><span class="toc-text">6. 函数进阶</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E7%B1%BB%E5%9E%8B"><span class="toc-text">函数类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0"><span class="toc-text">匿名函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%AD%E5%8C%85"><span class="toc-text">闭包</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#defer"><span class="toc-text">defer</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E6%8C%87%E9%92%88"><span class="toc-text">7. 指针</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-text">注意事项</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%80%BC%E4%BC%A0%E9%80%92-vs-%E6%8C%87%E9%92%88%E4%BC%A0%E9%80%92"><span class="toc-text">值传递 vs 指针传递</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E6%95%B0%E7%BB%84"><span class="toc-text">8. 数组</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%81%8D%E5%8E%86"><span class="toc-text">遍历</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E5%88%87%E7%89%87"><span class="toc-text">9. 切片</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96-1"><span class="toc-text">初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%87%E7%89%87%E6%88%AA%E5%8F%96"><span class="toc-text">切片截取</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-Map"><span class="toc-text">10. Map</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5"><span class="toc-text">增删改查</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%81%8D%E5%8E%86-1"><span class="toc-text">遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B"><span class="toc-text">引用类型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-text">11. 结构体</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96-2"><span class="toc-text">初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E9%92%88"><span class="toc-text">指针</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AF%94%E8%BE%83%E5%92%8C%E8%B5%8B%E5%80%BC"><span class="toc-text">比较和赋值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%80%BC%E4%BC%A0%E9%80%92-vs-%E6%8C%87%E9%92%88%E4%BC%A0%E9%80%92-1"><span class="toc-text">值传递 vs 指针传递</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E8%A7%81%E6%80%A7"><span class="toc-text">可见性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-%E5%8C%BF%E5%90%8D%E7%BB%84%E5%90%88"><span class="toc-text">12. 匿名组合</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96-3"><span class="toc-text">初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E6%88%90%E5%91%98"><span class="toc-text">访问成员</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8C%E5%90%8D%E5%AD%97%E6%AE%B5"><span class="toc-text">同名字段</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E7%B1%BB%E5%9E%8B%E5%8C%BF%E5%90%8D%E5%AD%97%E6%AE%B5"><span class="toc-text">指针类型匿名字段</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-%E6%96%B9%E6%B3%95"><span class="toc-text">13. 方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%80%BC%E6%8E%A5%E6%94%B6%E8%80%85-vs-%E6%8C%87%E9%92%88%E6%8E%A5%E6%94%B6%E8%80%85"><span class="toc-text">值接收者 vs 指针接收者</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E7%BB%A7%E6%89%BF"><span class="toc-text">方法继承</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E9%87%8D%E5%86%99"><span class="toc-text">方法重写</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-%E6%8E%A5%E5%8F%A3"><span class="toc-text">14. 接口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3"><span class="toc-text">实现接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E6%80%81"><span class="toc-text">多态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E7%BB%A7%E6%89%BF"><span class="toc-text">接口继承</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A9%BA%E6%8E%A5%E5%8F%A3"><span class="toc-text">空接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80"><span class="toc-text">类型断言</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-Error-%E6%8E%A5%E5%8F%A3"><span class="toc-text">15. Error 接口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA-error"><span class="toc-text">创建 error</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E6%A8%A1%E5%BC%8F"><span class="toc-text">错误处理模式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-Panic"><span class="toc-text">16. Panic</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A6%E5%8F%91%E6%96%B9%E5%BC%8F"><span class="toc-text">触发方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#panic-%E4%B8%8E-defer"><span class="toc-text">panic 与 defer</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-Recover"><span class="toc-text">17. Recover</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-Goroutine"><span class="toc-text">18. Goroutine</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#WaitGroup"><span class="toc-text">WaitGroup</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0"><span class="toc-text">常用函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19-Channel"><span class="toc-text">19. Channel</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A0%E7%BC%93%E5%86%B2-channel"><span class="toc-text">无缓冲 channel</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%89%E7%BC%93%E5%86%B2-channel"><span class="toc-text">有缓冲 channel</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E9%97%AD%E5%92%8C%E9%81%8D%E5%8E%86"><span class="toc-text">关闭和遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E5%90%91-channel"><span class="toc-text">单向 channel</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E6%97%B6%E5%99%A8"><span class="toc-text">定时器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20-Select"><span class="toc-text">20. Select</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95"><span class="toc-text">基本用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B6%85%E6%97%B6%E5%A4%84%E7%90%86"><span class="toc-text">超时处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E7%A4%BA%E4%BE%8B"><span class="toc-text">斐波那契示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A6%81%E7%82%B9"><span class="toc-text">要点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#21-%E9%94%81-sync"><span class="toc-text">21. 锁 (sync)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%92%E6%96%A5%E9%94%81-sync-Mutex"><span class="toc-text">互斥锁 sync.Mutex</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%BB%E5%86%99%E9%94%81-sync-RWMutex"><span class="toc-text">读写锁 sync.RWMutex</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sync-Once"><span class="toc-text">sync.Once</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sync-Map"><span class="toc-text">sync.Map</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/c888933a.html" title="Web 拦截"><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/image/1100px-Event_top_01.png" onerror='this.onerror=null,this.src="https://cdn.jsdelivr.net/gh/Hongda-OSU/PicGo/image/404.GIF"' alt="Web 拦截"></a><div class="content"><a class="title" href="/posts/c888933a.html" title="Web 拦截">Web 拦截</a><time datetime="2025-06-15T17:03:05.000Z" title="发表于 2025-06-15 12:03:05">2025-06-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/50096d59.html" title="AWS MLA-C01"><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/image/700px-卡冈图雅-像素.png" onerror='this.onerror=null,this.src="https://cdn.jsdelivr.net/gh/Hongda-OSU/PicGo/image/404.GIF"' alt="AWS MLA-C01"></a><div class="content"><a class="title" href="/posts/50096d59.html" title="AWS MLA-C01">AWS MLA-C01</a><time datetime="2025-06-14T17:03:05.000Z" title="发表于 2025-06-14 12:03:05">2025-06-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/998b6089.html" title="JS &amp; Python 小技巧"><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/image/700px-荷赛拉大战-机械淘淘宣传图.png" onerror='this.onerror=null,this.src="https://cdn.jsdelivr.net/gh/Hongda-OSU/PicGo/image/404.GIF"' alt="JS &amp; Python 小技巧"></a><div class="content"><a class="title" href="/posts/998b6089.html" title="JS &amp; Python 小技巧">JS &amp; Python 小技巧</a><time datetime="2025-06-14T17:03:05.000Z" title="发表于 2025-06-14 12:03:05">2025-06-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/3f28c94.html" title="GCP 实操练习"><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/imgf46582az111imog7tayrkhdegi73sg9.png" onerror='this.onerror=null,this.src="https://cdn.jsdelivr.net/gh/Hongda-OSU/PicGo/image/404.GIF"' alt="GCP 实操练习"></a><div class="content"><a class="title" href="/posts/3f28c94.html" title="GCP 实操练习">GCP 实操练习</a><time datetime="2025-06-13T17:03:05.000Z" title="发表于 2025-06-13 12:03:05">2025-06-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/733301f0.html" title="System Design 101"><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img5r931hxtc55u09sm6oxjl3b0bp0v1z6.png" onerror='this.onerror=null,this.src="https://cdn.jsdelivr.net/gh/Hongda-OSU/PicGo/image/404.GIF"' alt="System Design 101"></a><div class="content"><a class="title" href="/posts/733301f0.html" title="System Design 101">System Design 101</a><time datetime="2025-06-13T17:03:05.000Z" title="发表于 2025-06-13 12:03:05">2025-06-13</time></div></div></div></div></div></div></main><footer id="footer" style="background:rgba(0,0,0,.25)"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2025 &nbsp;<i id="heartbeat" class="fa fas fa-heartbeat"></i> &nbsp;鴻達</div><div class="footer_custom_text"><p class="badge"><a style="margin-inline:5px" target="_blank" href="https://hexo.io/"><img src="https://img.shields.io/badge/Frame-Hexo-informational?style=flat&logo=hexo"></a><a style="margin-inline:5px" target="_blank" href="https://domains.google/"><img src="https://img.shields.io/badge/Hosted-Google-ff69b4?style=flat&logo=googledomains"></a><a style="margin-inline:5px" target="_blank" href="https://gulpjs.com/"><img src="https://img.shields.io/badge/Compress-gulp-critical?style=flat&logo=gulp"></a><a style="margin-inline:5px" target="_blank" href="https://www.jsdelivr.com/"><img src="https://img.shields.io/badge/CDN-jsDelivr-orange?style=flat&logo=jsDelivr"></a><a style="margin-inline:5px" target="_blank" href="https://github.com/"><img src="https://img.shields.io/badge/Source-Github-black?style=flat&logo=GitHub"></a><a style="margin-inline:5px" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&logo=Claris"></a></p></div></div><link rel="stylesheet" href="https://fastly.jsdelivr.net/gh/HCLonely/images@master/others/heartbeat.min.css"></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i> <span>数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script>function panguFn(){"object"==typeof pangu?pangu.autoSpacingPage():getScript("https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js").then((()=>{pangu.autoSpacingPage()}))}function panguInit(){GLOBAL_CONFIG_SITE.isPost&&panguFn()}document.addEventListener("DOMContentLoaded",panguInit)</script><script src="/js/search/local-search.js"></script><div class="js-pjax"></div><script defer src="/js/util.js"></script><script defer src="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js"></script><script disable-devtool-auto src="https://cdn.jsdelivr.net/npm/disable-devtool"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors=["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"];var pjax=new Pjax({elements:'a:not([target="_blank"])',selectors:pjaxSelectors,cacheBust:!1,analytics:!1,scrollRestoration:!1});document.addEventListener("pjax:send",(function(){if(window.tocScrollFn&&window.removeEventListener("scroll",window.tocScrollFn),window.scrollCollect&&window.removeEventListener("scroll",scrollCollect),document.getElementById("rightside").style.cssText="opacity: ''; transform: ''",window.aplayers)for(let e=0;e<window.aplayers.length;e++)window.aplayers[e].options.fixed||window.aplayers[e].destroy();"object"==typeof typed&&typed.destroy();const e=document.body.classList;e.contains("read-mode")&&e.remove("read-mode"),"object"==typeof disqusjs&&disqusjs.destroy()})),document.addEventListener("pjax:complete",(function(){window.refreshFn(),document.querySelectorAll("script[data-pjax]").forEach((e=>{const t=document.createElement("script"),o=e.text||e.textContent||e.innerHTML||"";Array.from(e.attributes).forEach((e=>t.setAttribute(e.name,e.value))),t.appendChild(document.createTextNode(o)),e.parentNode.replaceChild(t,e)})),GLOBAL_CONFIG.islazyload&&window.lazyLoadInstance.update(),"function"==typeof chatBtnFn&&chatBtnFn(),"function"==typeof panguInit&&panguInit(),"function"==typeof gtag&&gtag("config","",{page_path:window.location.pathname}),"object"==typeof _hmt&&_hmt.push(["_trackPageview",window.location.pathname]),"function"==typeof loadMeting&&document.getElementsByClassName("aplayer").length&&loadMeting(),"object"==typeof Prism&&Prism.highlightAll()})),document.addEventListener("pjax:error",(e=>{404===e.request.status&&pjax.loadUrl("/404.html")}))</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>