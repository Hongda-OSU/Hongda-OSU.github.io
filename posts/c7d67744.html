<!DOCTYPE html><html lang="zh-CN" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><title>前端面试笔记 | 鴻鵠誌達</title><meta name="author" content="鴻達"><meta name="copyright" content="鴻達"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#1a1a1a"><meta name="description" content="😃"><meta property="og:type" content="article"><meta property="og:title" content="前端面试笔记"><meta property="og:url" content="https://hongdalin.blog/posts/c7d67744.html"><meta property="og:site_name" content="鴻鵠誌達"><meta property="og:description" content="😃"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Hongda-OSU/PicGo/image/gknx188yxuapxelxaeyjso308qyhne0.jpg"><meta property="article:published_time" content="2023-01-26T16:15:05.000Z"><meta property="article:modified_time" content="2025-01-04T02:14:09.645Z"><meta property="article:author" content="鴻達"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/Hongda-OSU/PicGo/image/gknx188yxuapxelxaeyjso308qyhne0.jpg"><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/Hongda-OSU/PicGo/image/德克萨斯.GIF"><link rel="canonical" href="https://hongdalin.blog/posts/c7d67744.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:{path:"/search.xml",preload:!0,languages:{hits_empty:"找不到您查询的内容：${query}"}},translate:void 0,noticeOutdate:void 0,highlight:{plugin:"highlighjs",highlightCopy:!0,highlightLang:!0,highlightHeightLimit:!1},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"},relativeDate:{homepage:!1,post:!1},runtime:"天",date_suffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:void 0,lightbox:"fancybox",Snackbar:void 0,source:{justifiedGallery:{js:"https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js",css:"https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css"}},isPhotoFigcaption:!0,islazyload:!1,isAnchor:!1,percent:{toc:!0,rightside:!1}}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"前端面试笔记",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2025-01-03 20:14:09"}</script><noscript><style>#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(e=>{e.saveToLocal={set:function(e,t,n){if(0===n)return;const o=864e5*n,a={value:t,expiry:(new Date).getTime()+o};localStorage.setItem(e,JSON.stringify(a))},get:function(e){const t=localStorage.getItem(e);if(!t)return;const n=JSON.parse(t);if(!((new Date).getTime()>n.expiry))return n.value;localStorage.removeItem(e)}},e.getScript=e=>new Promise(((t,n)=>{const o=document.createElement("script");o.src=e,o.async=!0,o.onerror=n,o.onload=o.onreadystatechange=function(){const e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(o.onload=o.onreadystatechange=null,t())},document.head.appendChild(o)})),e.getCSS=e=>new Promise(((t,n)=>{const o=document.createElement("link");o.rel="stylesheet",o.href=e,o.onload=()=>t(),o.onerror=()=>n(),document.head.appendChild(o)}));/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")})(window)</script><link rel="stylesheet" href="/css/color.css" media="defer" onload='this.media="all"'><link rel="stylesheet" href="/css/font.css" media="defer" onload='this.media="all"'><link rel="stylesheet" href="/css/icon.css" media="defer" onload='this.media="all"'><link rel="stylesheet" href="/css/layout.css" media="defer" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.css" media="defer" onload='this.media="all"'><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://cdn.jsdelivr.net/gh/Hongda-OSU/PicGo/image/德狗子.GIF" onerror='onerror=null,src="https://cdn.jsdelivr.net/gh/Hongda-OSU/PicGo/image/404.GIF"' alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">23</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">13</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i> <span>时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i> <span>标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>分类</span></a></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i> <span>链接</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i> <span>友情链接</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i> <span>关于</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url('https://cdn.jsdelivr.net/gh/Hongda-OSU/PicGo/image/gknx188yxuapxelxaeyjso308qyhne0.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="鴻鵠誌達"><span class="site-name">鴻鵠誌達</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i> <span>搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i> <span>时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i> <span>标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>分类</span></a></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i> <span>链接</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i> <span>友情链接</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i> <span>关于</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">前端面试笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-01-26T16:15:05.000Z" title="发表于 2023-01-26 10:15:05">2023-01-26</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-01-04T02:14:09.645Z" title="更新于 2025-01-03 20:14:09">2025-01-03</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">8.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>30分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" data-flag-title="前端面试笔记"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h3 id="1-CSS-题目"><a href="#1-CSS-题目" class="headerlink" title="1. CSS 题目"></a>1. CSS 题目</h3><h4 id="1-1-画等腰直角三角形"><a href="#1-1-画等腰直角三角形" class="headerlink" title="1.1 画等腰直角三角形"></a>1.1 画等腰直角三角形</h4><ul><li><p>这题是美团前端面试一面题: <a target="_blank" rel="noopener" href="https://juejin.cn/post/6950081305560219679?searchId=202410130111434E030964573D8F88A42E">参考链接</a></p></li><li><p>第一种方法: 使用<code>boarder</code></p></li></ul><iframe width="100%" height="300" src="//jsfiddle.net/HDL52/mojg3tqL/13/embedded/html,css,result/dark/" frameborder="0" loading="lazy" allowtransparency="true" allowfullscreen></iframe><ul><li>第二种方法: 使用<code>linear-gradient</code></li></ul><iframe width="100%" height="300" src="//jsfiddle.net/HDL52/uwykmf1a/4/embedded/html,css,result/dark/" frameborder="0" loading="lazy" allowtransparency="true" allowfullscreen></iframe><ul><li>第三种方法: 使用<code>clip-path</code></li></ul><iframe width="100%" height="300" src="//jsfiddle.net/HDL52/7eowjy52/15/embedded/html,css,result/dark/" frameborder="0" loading="lazy" allowtransparency="true" allowfullscreen></iframe><hr><h4 id="1-2-不定宽高水平垂直居中"><a href="#1-2-不定宽高水平垂直居中" class="headerlink" title="1.2 不定宽高水平垂直居中"></a>1.2 不定宽高水平垂直居中</h4><ul><li>第一种方法: 使用<code>Flexbox</code> (也可以父元素是<code>flex</code>然后子元素<code>margin:auto</code>)</li></ul><iframe width="100%" height="300" src="//jsfiddle.net/HDL52/9fa0m5rg/14/embedded/html,css,result/dark/" frameborder="0" loading="lazy" allowtransparency="true" allowfullscreen></iframe><ul><li>第二种方法: 使用<code>Grid</code></li></ul><iframe width="100%" height="300" src="//jsfiddle.net/HDL52/0b2oduje/4/embedded/html,css,result/dark/" frameborder="0" loading="lazy" allowtransparency="true" allowfullscreen></iframe><ul><li>第三种方法: 绝对定位 + <code>transform</code></li></ul><iframe width="100%" height="300" src="//jsfiddle.net/HDL52/u1e7a2mv/5/embedded/html,css,result/dark/" frameborder="0" loading="lazy" allowtransparency="true" allowfullscreen></iframe><hr><h4 id="1-3-正方形子元素"><a href="#1-3-正方形子元素" class="headerlink" title="1.3 正方形子元素"></a>1.3 正方形子元素</h4><ul><li>这题是字节跳动一面题: 父元素的宽高不固定，并且可以随窗口变形，而子元素必须保持正方形 (只能使用<code>CSS</code>)<ul><li>解决方案: 子元素使用百分比宽度并使用<code>aspect-ratio</code>属性来保持子元素的正方形比例</li></ul></li></ul><iframe width="100%" height="300" src="//jsfiddle.net/HDL52/qy79su82/27/embedded/html,css,result/dark/" frameborder="0" loading="lazy" allowtransparency="true" allowfullscreen></iframe><hr><h4 id="1-4-position-定位"><a href="#1-4-position-定位" class="headerlink" title="1.4 position 定位"></a>1.4 position 定位</h4><ul><li><p><code>position: static</code>（默认定位）: 所有元素的默认定位方式。元素按照正常的文档流排列，不会受<code>top</code>、<code>right</code>、<code>bottom</code>或<code>left</code>等属性的影响</p></li><li><p><code>position: relative</code>（相对定位）: 相对于元素自身的原始位置进行定位，但可以通过<code>top</code>、<code>right</code>、<code>bottom</code>、<code>left</code>等属性调整元素的相对位置</p></li></ul><iframe width="100%" height="300" src="//jsfiddle.net/HDL52/5qb29Lzg/2/embedded/html,css,result/dark/" frameborder="0" loading="lazy" allowtransparency="true" allowfullscreen></iframe><ul><li><code>position: absolute</code>（绝对定位）: 相对于最近的非<code>static</code>定位的父元素进行定位。如果没有非<code>static</code>的父元素，则相对于文档的根元素（通常是<code>&lt;html&gt;</code>或<code>&lt;body&gt;</code>）进行定位</li></ul><iframe width="100%" height="300" src="//jsfiddle.net/HDL52/3jmu7q8a/7/embedded/html,css,result/dark/" frameborder="0" loading="lazy" allowtransparency="true" allowfullscreen></iframe><ul><li><p><code>position: fixed</code>（固定定位）: 相对于浏览器窗口进行定位，无论页面如何滚动，元素始终保持在浏览器窗口中的固定位置</p></li><li><p><code>position: sticky</code>（粘性定位）: 结合了<code>relative</code>和<code>fixed</code>的特性。元素一开始是相对于文档流定位的（<code>relative</code>），当页面滚动到某个阈值时，元素会变为固定定位（<code>fixed</code>）</p><ul><li>父元素不能<code>overflow:hidden</code>或者<code>overflow:auto</code>属性</li><li>必须指定<code>top</code>、<code>bottom</code>、<code>left</code>、<code>right</code>四个值之一，否则只会处于相对定位</li></ul></li></ul><iframe width="100%" height="300" src="//jsfiddle.net/HDL52/ybk3o9Lu/23/embedded/html,css,result/dark/" frameborder="0" loading="lazy" allowtransparency="true" allowfullscreen></iframe><hr><h4 id="1-5-盒模型"><a href="#1-5-盒模型" class="headerlink" title="1.5 盒模型"></a>1.5 盒模型</h4><p>盒模型分为<code>IE</code>盒模型和<code>W3C</code>标准盒模型</p><ul><li>在标准盒模型下，一个块的总宽度 &#x3D; <code>width + margin(左右) + padding(左右) + border(左右)</code></li><li>在<code>IE</code>盒模型下，一个块的总宽度 &#x3D; <code>width + margin(左右)</code>（即<code>width</code>已经包含了<code>padding</code>和<code>border</code>值）</li></ul><blockquote><p>当设置<code>box-sizing:content-box</code>时，采用标准盒模型计算，也是默认模式<br>当设置<code>box-sizing:border-box</code>时，采用<code>IE</code>盒模型计算</p></blockquote><ul><li><code>JS</code>如何获取盒模型对应的宽和高<ul><li><code>window.getComputedStyle(dom).width/height</code>: 取到的是最终渲染后的宽和高</li><li><code>dom.getBoundingClientRect().width/height</code>: 得到渲染后的宽和高，还可以取到相对于视窗的上下左右的距离</li><li><code>dom.offsetWidth/offsetHeight</code>: 包括高度（宽度）、内边距和边框，不包括外边距 (兼容性最好)</li></ul></li></ul><hr><h4 id="1-6-CSS-实现扇形"><a href="#1-6-CSS-实现扇形" class="headerlink" title="1.6 CSS 实现扇形"></a>1.6 CSS 实现扇形</h4><hr><h4 id="1-7-BFC"><a href="#1-7-BFC" class="headerlink" title="1.7 BFC"></a>1.7 BFC</h4><ul><li><code>BFC</code>是<code>CSS</code>布局的一个概念，是一块独立的渲染区域，是一个环境，里面的元素不会影响到外部的元素</li></ul><hr><h3 id="2-JS-题目"><a href="#2-JS-题目" class="headerlink" title="2. JS 题目"></a>2. JS 题目</h3><h4 id="2-1-var-与循环"><a href="#2-1-var-与循环" class="headerlink" title="2.1 var 与循环"></a>2.1 var 与循环</h4><ul><li>字节跳动一面的题目</li><li>下面循环的最终结果是什么，<code>i</code>的最终值是什么，<code>i</code>在循环结束后的值是什么</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>这个循环将会输出<code>0 1 2 3 4</code>，<code>i</code>的最终值为<code>5</code></p></li><li><p>由于<code>var</code>声明的变量在整个函数（或全局范围内）都是共享的，它不受块作用域的限制。因此，<code>i</code>在整个函数或脚本范围内是可见的。换句话说，<code>i</code>仍然在循环结束后存在并且可以访问</p></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(i), <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>这个循环将会输出<code>5 5 5 5 5</code>，<code>i</code>的最终值为<code>5</code></li><li>由于<code>var</code>是函数级作用域，所有的<code>setTimeout</code>回调函数在执行时访问的都是同一个<code>i</code>，即循环结束时的<code>i</code>值<code>5</code>。因为<code>setTimeout</code>是异步的，它会在<code>1</code>秒后执行，此时循环早已结束，<code>i</code>已经被更新为<code>5</code></li><li>解决方案: 使用<code>let</code>或闭包可以解决这个问题，确保每次迭代时<code>i</code>的值是独立的</li></ul><hr><h4 id="2-2-手写倒计时"><a href="#2-2-手写倒计时" class="headerlink" title="2.2 手写倒计时"></a>2.2 手写倒计时</h4><ul><li><p>美团一面的题目</p></li><li><p>手写一个倒计时函数，要求输出<code>5 4 3 2 1</code>，每隔一分钟输出一个值</p></li><li><p>方法一: 使用<code>setInterval</code></p><ul><li><code>setInterval</code>会在指定的时间间隔内反复执行一个函数，直到手动清除这个定时器</li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">countdown</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">const</span> intervalId = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(count);</span><br><span class="line">        count--;</span><br><span class="line">        <span class="keyword">if</span> (count === <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">clearInterval</span>(intervalId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="number">60000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">countdown</span>();</span><br></pre></td></tr></table></figure><ul><li>方法二: 使用<code>Generator</code>函数<ul><li>使用<code>Generator</code>函数可以通过<code>yield</code>暂停和恢复函数的执行，结合<code>setTimeout</code>来实现倒计时</li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">countdownGenerator</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">while</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">yield</span> count;</span><br><span class="line">        count--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">countdown</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> generator = <span class="title function_">countdownGenerator</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">nextCountdown</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; value, done &#125; = generator.<span class="title function_">next</span>();</span><br><span class="line">        <span class="keyword">if</span> (!done) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">            <span class="built_in">setTimeout</span>(nextCountdown, <span class="number">60000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">nextCountdown</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">countdown</span>();</span><br></pre></td></tr></table></figure><hr><h4 id="2-3-防抖和节流"><a href="#2-3-防抖和节流" class="headerlink" title="2.3 防抖和节流"></a>2.3 防抖和节流</h4><ul><li><p>可以使用类似<code>loadash</code>这种库来实现</p></li><li><p>防抖 <code>Debounce</code></p><ul><li>防抖是指在事件被触发<code>n</code>秒后在执行回调，如果在这<code>n</code>秒内时间又被触发，则重新计时</li><li>可以使用在一些点击请求的事件上，避免因为用户的多次点击向后端发送多次请求</li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">fn, delay = <span class="number">500</span></span>) &#123;</span><br><span class="line">    <span class="comment">// 通过闭包缓存一个定时器 id</span></span><br><span class="line">    <span class="keyword">let</span> timer = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果已经设定过定时器就清空上一次的定时器</span></span><br><span class="line">        <span class="keyword">if</span> (timer) <span class="built_in">clearTimeout</span>(timer)</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 开始设定一个新的定时器，定时器结束后执行传入的函数 fn</span></span><br><span class="line">        <span class="comment">// 这里必须是箭头函数，不然 this 指向 window，要让 this 就指向 fn 的调用者</span></span><br><span class="line">        timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123; </span><br><span class="line">            fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args)</span><br><span class="line">        &#125;, delay)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行 debounce 函数返回新函数</span></span><br><span class="line"><span class="keyword">const</span> betterFn = <span class="title function_">debounce</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;fn 防抖执行了&#x27;</span>), <span class="number">1000</span>)</span><br><span class="line"><span class="comment">// 停止滑动 1 秒后执行函数 () =&gt; console.log(&#x27;fn 防抖执行了&#x27;)</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;scroll&#x27;</span>, betterFn)</span><br></pre></td></tr></table></figure><blockquote><p>防抖函数分为非立即执行版和立即执行版，需要根据不同的场景来决定需要使用哪一个版本的防抖函数</p></blockquote><ul><li>节流 <code>Throttle</code><ul><li>节流就是一定时间内执行一次事件，即使重复触发，也只有一次生效</li><li>可以使用在监听滚动<code>scroll</code>事件上，通过事件节流来降低事件调用的频率</li></ul></li></ul><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">时间戳版本</button></li><li class="tab"><button type="button" data-href="#test-2">定时器版本</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">throttle</span> = (<span class="params">fn, delay = <span class="number">500</span></span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 上一次执行 fn 的时间</span></span><br><span class="line">  <span class="keyword">let</span> prev = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">    <span class="comment">// 获取当前时间，转换成时间戳，单位毫秒</span></span><br><span class="line">    <span class="keyword">let</span> now = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line">    <span class="comment">// 如果差值大于等于设置的等待时间就执行函数</span></span><br><span class="line">    <span class="keyword">if</span> (now - prev &gt;= delay) &#123;</span><br><span class="line">      fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args);</span><br><span class="line">      prev = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行 throttle 函数返回新函数</span></span><br><span class="line"><span class="keyword">const</span> betterFn = <span class="title function_">throttle</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;fn 函数执行了&#x27;</span>), <span class="number">1000</span>)</span><br><span class="line"><span class="comment">// 每 10 毫秒执行一次 betterFn 函数，但是只有时间差大于 1s 时才会执行 fn</span></span><br><span class="line"><span class="built_in">setInterval</span>(betterFn, <span class="number">10</span>)</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">throttle</span> = (<span class="params">fn, delay = <span class="number">500</span></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> timer = <span class="literal">null</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (timer) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args);</span><br><span class="line">      <span class="comment">// 执行完后，需重置定时器，不然 timer 一直有值，无法开启下一个定时器</span></span><br><span class="line">      timer = <span class="literal">null</span>;	</span><br><span class="line">    &#125;, delay)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><blockquote><p>对于节流，一般有两种方式可以实现，分别是时间戳版和定时器版。时间戳版的函数触发是在时间段内开始的时候，而定时器版的函数触发是在时间段内结束的时候</p></blockquote><hr><h4 id="2-4-undefined-与-null-的区别"><a href="#2-4-undefined-与-null-的区别" class="headerlink" title="2.4 undefined 与 null 的区别"></a>2.4 undefined 与 null 的区别</h4><ul><li><code>undefined</code>表示”缺少值”，就是此处应该有一个值，但是还没有定义</li><li><code>null</code>表示”没有对象”，即该处不应该有值</li></ul><hr><h4 id="2-5-浅拷贝和深拷贝"><a href="#2-5-浅拷贝和深拷贝" class="headerlink" title="2.5 浅拷贝和深拷贝"></a>2.5 浅拷贝和深拷贝</h4><ul><li>浅拷贝<ul><li>浅拷贝是创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝</li><li>如果属性是基本类型，拷贝的就是基本类型的值，如果属性是引用类型，拷贝的就是内存地址，所以如果其中一个对象改变了这个地址，就会影响到另一个对象</li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">shallowCopy</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="comment">// 只拷贝对象，基本类型或 null 直接返回</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="string">&#x27;object&#x27;</span> || object === <span class="literal">null</span>)</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断是新建一个数组还是对象</span></span><br><span class="line">  <span class="keyword">let</span> newObj = <span class="title class_">Array</span>.<span class="title function_">isArray</span>(obj) ? [] : &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="comment">// hasOwnProperty 判断是否是对象自身属性，会忽略从原型链上继承的属性</span></span><br><span class="line">    <span class="keyword">if</span> (obj.<span class="title function_">hasOwnProperty</span>(key))</span><br><span class="line">      newObj[key] = obj[key]; <span class="comment">// 只拷贝对象本身的属性</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> newObj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试</span></span><br><span class="line"><span class="keyword">var</span> obj =&#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&#x27;张三&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>:<span class="number">8</span>,</span><br><span class="line">    <span class="attr">pal</span>:[<span class="string">&#x27;王五&#x27;</span>,<span class="string">&#x27;王六&#x27;</span>,<span class="string">&#x27;王七&#x27;</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj2 = <span class="title function_">shallowCopy</span>(obj);</span><br><span class="line">obj2.<span class="property">name</span> = <span class="string">&#x27;李四&#x27;</span></span><br><span class="line">obj2.<span class="property">pal</span>[<span class="number">0</span>] = <span class="string">&#x27;王麻子&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj); <span class="comment">//&#123;age: 8, name: &quot;张三&quot;, pal: [&#x27;王麻子&#x27;, &#x27;王六&#x27;, &#x27;王七&#x27;]&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj2); <span class="comment">//&#123;age: 8, name: &quot;李四&quot;, pal: [&#x27;王麻子&#x27;, &#x27;王六&#x27;, &#x27;王七&#x27;]&#125;</span></span><br></pre></td></tr></table></figure><ul><li>深拷贝<ul><li>深拷贝是将一个对象从内存中完整的拷贝一份出来，从堆内存中开辟一个新的区域存放新对象，且修改新对象不会影响原对象</li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">deepCopy</span>(<span class="params">obj, map = <span class="keyword">new</span> <span class="built_in">WeakMap</span>()</span>) &#123;</span><br><span class="line">  <span class="comment">// 基本类型或 null 直接返回</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="string">&#x27;object&#x27;</span> || obj === <span class="literal">null</span>)</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断是新建一个数组还是对象</span></span><br><span class="line">  <span class="keyword">let</span> newObj = <span class="title class_">Array</span>.<span class="title function_">isArray</span>(obj) ? [] : &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 利用 map 解决循环引用</span></span><br><span class="line">  <span class="keyword">if</span> (map.<span class="title function_">has</span>(obj))</span><br><span class="line">    <span class="keyword">return</span> map.<span class="title function_">get</span>(obj);</span><br><span class="line"></span><br><span class="line">  map.<span class="title function_">set</span>(obj, newObj); <span class="comment">// 将当前对象作为 key，克隆对象作为 value</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> obj) &#123;</span><br><span class="line">    <span class="keyword">if</span> (obj.<span class="title function_">hasOwnProperty</span>(key))</span><br><span class="line">      newObj[key] = <span class="title function_">deepCopy</span>(object[key], map); <span class="comment">// 递归</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> newObj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="keyword">let</span> obj1 = &#123;</span><br><span class="line">    name : <span class="string">&#x27;AK、哒哒哒&#x27;</span>,</span><br><span class="line">    arr : [<span class="number">1</span>,[<span class="number">2</span>,<span class="number">3</span>],<span class="number">4</span>],</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> obj2=<span class="title function_">deepCopy</span>(obj1)</span><br><span class="line">obj2.<span class="property">name</span> = <span class="string">&quot;哒哒哒&quot;</span>;</span><br><span class="line">obj2.<span class="property">arr</span>[<span class="number">1</span>] = [<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>] ; <span class="comment">// 新对象跟原对象不共享内存</span></span><br><span class="line"> </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;obj1&#x27;</span>,obj1) <span class="comment">// obj1 &#123; name: &#x27;AK、哒哒哒&#x27;, arr: [ 1, [ 2, 3 ], 4 ] &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;obj2&#x27;</span>,obj2) <span class="comment">// obj2 &#123; name: &#x27;哒哒哒&#x27;, arr: [ 1, [ 5, 6, 7 ], 4 ] &#125;</span></span><br></pre></td></tr></table></figure><hr><h4 id="2-6-函数柯里化"><a href="#2-6-函数柯里化" class="headerlink" title="2.6 函数柯里化"></a>2.6 函数柯里化</h4><ul><li>在数学和计算机科学中，柯里化是一种将使用多个参数的一个函数转换成一系列使用一个参数的函数的技术</li></ul><blockquote><p>柯里化实际是把简单的问题复杂化，但是复杂化的同时，在使用函数时拥有了更加多的自由度。而对于函数参数的自由处理，正是柯里化的核心所在。柯里化本质上是降低通用性，提高适用性</p></blockquote><ul><li>参数定长的柯里化<ul><li>假设存在一个原函数<code>fn</code>，<code>fn</code>接受三个参数<code>a, b, c</code>，那么函数<code>fn</code>最多被柯里化三次</li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">curry</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">  <span class="comment">// 获取原函数的参数长度</span></span><br><span class="line">  <span class="keyword">const</span> argLen = fn.<span class="property">length</span>;</span><br><span class="line">  <span class="comment">// 保存预置参数</span></span><br><span class="line">  <span class="keyword">const</span> presetArgs = [].<span class="property">slice</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>, <span class="number">1</span>)</span><br><span class="line">  <span class="comment">// 返回一个新函数</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 新函数调用时会继续传参</span></span><br><span class="line">    <span class="keyword">const</span> restArgs = [].<span class="property">slice</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>)</span><br><span class="line">    <span class="keyword">const</span> allArgs = [...presetArgs, ...restArgs]</span><br><span class="line">    <span class="keyword">if</span> (allArgs.<span class="property">length</span> &gt;= argLen) &#123;</span><br><span class="line">      <span class="comment">// 如果参数够了，就执行原函数</span></span><br><span class="line">      <span class="keyword">return</span> fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, allArgs)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 否则继续柯里化</span></span><br><span class="line">      <span class="keyword">return</span> curry.<span class="title function_">call</span>(<span class="literal">null</span>, fn, ...allArgs)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">a, b, c</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b + c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> curried = <span class="title function_">curry</span>(sum);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">curried</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)); <span class="comment">//6</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">curried</span>(<span class="number">1</span>, <span class="number">2</span>)(<span class="number">3</span>)); <span class="comment">//6</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">curried</span>(<span class="number">1</span>)(<span class="number">2</span>, <span class="number">3</span>)); <span class="comment">//6</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">curried</span>(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)); <span class="comment">//6</span></span><br></pre></td></tr></table></figure><ul><li>参数不定长的柯里化<ul><li>如果要支持参数不定长的场景，已经柯里化的函数在执行完毕时不能返回一个值，只能返回一个函数。同时要让<code>JS</code>引擎在解析得到的这个结果时，能求出预期的值</li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">curry</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">  <span class="comment">// 保存预置参数</span></span><br><span class="line">  <span class="keyword">const</span> presetArgs = [].<span class="property">slice</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>, <span class="number">1</span>)</span><br><span class="line">  <span class="comment">// 返回一个新函数</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">curried</span> () &#123;</span><br><span class="line">    <span class="comment">// 新函数调用时会继续传参</span></span><br><span class="line">    <span class="keyword">const</span> restArgs = [].<span class="property">slice</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>)</span><br><span class="line">    <span class="keyword">const</span> allArgs = [...presetArgs, ...restArgs]</span><br><span class="line">    <span class="keyword">return</span> curry.<span class="title function_">call</span>(<span class="literal">null</span>, fn, ...allArgs)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 重写toString</span></span><br><span class="line">  curried.<span class="property">toString</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> fn.<span class="title function_">apply</span>(<span class="literal">null</span>, presetArgs)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> curried;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">dynamicAdd</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> [...<span class="variable language_">arguments</span>].<span class="title function_">reduce</span>(<span class="function">(<span class="params">prev, curr</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> prev + curr</span><br><span class="line">  &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> add = <span class="title function_">curry</span>(dynamicAdd);</span><br><span class="line"><span class="title function_">add</span>(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)(<span class="number">4</span>) <span class="comment">// 10</span></span><br><span class="line"><span class="title function_">add</span>(<span class="number">1</span>, <span class="number">2</span>)(<span class="number">3</span>, <span class="number">4</span>)(<span class="number">5</span>, <span class="number">6</span>) <span class="comment">// 21</span></span><br></pre></td></tr></table></figure><hr><h4 id="2-7-数组扁平化"><a href="#2-7-数组扁平化" class="headerlink" title="2.7 数组扁平化"></a>2.7 数组扁平化</h4><blockquote><p>实现扁平化的方法，封装<code>flatten</code><br>已有多级嵌套数组<code>[1, [2, [3, [4, 5]]], 6]</code> 将其扁平化处理，输出<code>[1,2,3,4,5,6]</code></p></blockquote><ul><li><code>ES6 flat</code><ul><li><code>flat(depth)</code>方法会按照一个可指定的深度递归遍历数组，并将所有元素与遍历到的子数组中的元素合并为一个新数组返回。使用<code>Infinity</code>，可展开任意深度的嵌套数组</li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, [<span class="number">2</span>, [<span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>]]], <span class="number">6</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">flatten</span>(<span class="params">params</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> params.<span class="title function_">flat</span>(<span class="title class_">Infinity</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">flatten</span>(arr));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出: [1,2,3,4,5,6]</span></span><br></pre></td></tr></table></figure><blockquote><p>⭐ 直接使用自带的方法可以很快的实现, 但是面试官当然不希望就看到这些呀</p></blockquote><ul><li>循环递归<ul><li>循环判断数组的每一项是否是数组<code>Array.isArray(arr[i])</code></li><li>是数组就递归调用扁平化代码<code>result = result.concat(flatten(arr[i]));</code></li><li>不是数组,直接通过<code>push</code>添加到返回值数组</li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">flatten</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> result = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(arr[i])) &#123;</span><br><span class="line">      result = result.<span class="title function_">concat</span>(<span class="title function_">flatten</span>(arr[i]));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      result.<span class="title function_">push</span>(arr[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">flatten</span>(arr));</span><br></pre></td></tr></table></figure><blockquote><p>⭐⭐⭐ 使用递归写出数组扁平化, 但是缺少控制层级关系</p></blockquote><ul><li>增加参数控制扁平化深度<ul><li>可以理解为手写<code>flat()</code>方法</li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// forEach 遍历数组会自动跳过空元素</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">eachFlat</span> = (<span class="params">arr = [], depth = <span class="number">1</span></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> result = []; <span class="comment">// 缓存递归结果</span></span><br><span class="line">  <span class="comment">// 开始递归</span></span><br><span class="line">  (<span class="keyword">function</span> <span class="title function_">flat</span>(<span class="params">arr, depth</span>) &#123;</span><br><span class="line">    <span class="comment">// forEach 会自动去除数组空位</span></span><br><span class="line">    arr.<span class="title function_">forEach</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 控制递归深度</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(item) &amp;&amp; depth &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 递归数组</span></span><br><span class="line">        <span class="title function_">flat</span>(item, depth - <span class="number">1</span>)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 缓存元素</span></span><br><span class="line">        result.<span class="title function_">push</span>(item)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)(arr, depth)</span><br><span class="line">  <span class="comment">// 返回递归结果</span></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>⭐⭐⭐⭐ 使用递归写出数组扁平化, 可以通过参数控制层级关系</p></blockquote><ul><li><code>while</code>循环+<code>some</code>方法<ul><li>通过<code>some</code>来判断数组中是否用数组, 通过<code>while</code>不断循环执行判断, 如果是数组的话可以使用拓展运算符<code>...</code>, <code>...</code>每次只能展开最外层的数组, 加上<code>contact</code>来减少嵌套层数</li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">flatten</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="keyword">while</span> (arr.<span class="title function_">some</span>(<span class="function"><span class="params">item</span>=&gt;</span> <span class="title class_">Array</span>.<span class="title function_">isArray</span>(item))) &#123;</span><br><span class="line">    arr = [].<span class="title function_">concat</span>(...arr)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">flatten</span>(arr));</span><br></pre></td></tr></table></figure><blockquote><p>⭐⭐⭐⭐ 使用<code>while</code>循环取消递归操作, 巧用<code>some</code>操作进行判断</p></blockquote><hr><h4 id="2-8-typeof-判断"><a href="#2-8-typeof-判断" class="headerlink" title="2.8 typeof 判断"></a>2.8 typeof 判断</h4><ul><li><code>typeof null</code> 是 <code>“object”</code>: 历史遗留问题</li><li><code>typeof NaN</code> 是 <code>“number”</code>: <code>NaN</code> 实际存储是一种特殊的数值类型</li><li><code>typeof Function.prototype</code> 是 <code>function</code></li></ul><table><thead><tr><th align="center">类型</th><th align="center">结果</th></tr></thead><tbody><tr><td align="center">Undefined</td><td align="center"><code>&quot;undefined&quot;</code></td></tr><tr><td align="center">Null</td><td align="center"><code>&quot;object&quot;</code></td></tr><tr><td align="center">Boolean</td><td align="center"><code>&quot;boolean&quot;</code></td></tr><tr><td align="center">Number</td><td align="center"><code>&quot;number&quot;</code></td></tr><tr><td align="center">BigInt</td><td align="center"><code>&quot;bigint&quot;</code></td></tr><tr><td align="center">String</td><td align="center"><code>&quot;string&quot;</code></td></tr><tr><td align="center">Symbol</td><td align="center"><code>&quot;symbol&quot;</code></td></tr><tr><td align="center">Function (class)</td><td align="center"><code>&quot;function&quot;</code></td></tr><tr><td align="center">其他任何对象</td><td align="center"><code>&quot;object&quot;</code></td></tr></tbody></table><hr><h4 id="2-9-事件委托优化"><a href="#2-9-事件委托优化" class="headerlink" title="2.9 事件委托优化"></a>2.9 事件委托优化</h4><ul><li>字节一面题</li></ul><blockquote><p>举个例子，比如我们需要去做<code>Event Tracking System</code>，需要去记录用户在网站内做了什么，点击了什么按钮。如果有很多个按钮，每个都绑一个点击事件性能很差，如何优化？</p></blockquote><ul><li>绑定事件到父元素<ul><li>而不是为每个子节点单独绑定事件处理程序，事件委托可以将事件处理程序绑定到公共的父元素上，然后通过事件的<code>target</code>来确定实际触发事件的子节点。</li></ul></li><li>检查目标元素<ul><li>使用事件对象的<code>event.target</code>属性来判断哪个子节点触发了事件，并根据需要处理相应的逻辑</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;ul id=&quot;parent&quot;&gt;</span><br><span class="line">  &lt;li class=&quot;child&quot;&gt;子节点 1&lt;/li&gt;</span><br><span class="line">  &lt;li class=&quot;child&quot;&gt;子节点 2&lt;/li&gt;</span><br><span class="line">  &lt;li class=&quot;child&quot;&gt;子节点 3&lt;/li&gt;</span><br><span class="line">  &lt;li class=&quot;child&quot;&gt;子节点 4&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line"></span><br><span class="line">// 使用事件委托，将点击事件绑定到父元素</span><br><span class="line">const parent = document.getElementById(&#x27;parent&#x27;);</span><br><span class="line"></span><br><span class="line">// 事件处理器绑定在父元素上</span><br><span class="line">parent.addEventListener(&#x27;click&#x27;, function (event) &#123;</span><br><span class="line">  // 通过 event.target 来判断点击的是否是目标子节点</span><br><span class="line">  if (event.target &amp;&amp; event.target.classList.contains(&#x27;child&#x27;)) &#123;</span><br><span class="line">    console.log(&#x27;点击了子节点：&#x27;, event.target.innerText);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><blockquote><p>事件委托特别适用于存在大量类似元素的场景，如列表、表格中的行、动态生成的元素等</p></blockquote><hr><h3 id="3-网络安全"><a href="#3-网络安全" class="headerlink" title="3. 网络安全"></a>3. 网络安全</h3><h4 id="3-1-跨站脚本攻击-XSS"><a href="#3-1-跨站脚本攻击-XSS" class="headerlink" title="3.1 跨站脚本攻击 XSS"></a>3.1 跨站脚本攻击 XSS</h4><ul><li><code>XSS</code>（跨站脚本攻击，<code>Cross-Site Scripting</code>）是一种安全漏洞，攻击者通过向网页注入恶意脚本，使得当用户访问受感染的页面时，恶意脚本会在用户的浏览器中执行<ul><li>防止 <code>XSS</code>攻击的关键是严格处理用户输入和输出</li><li>对用户输入进行严格验证和过滤<strong>，</strong>使用安全的框架和库</li></ul></li></ul><hr><h4 id="3-2-跨站请求伪造-CSRF"><a href="#3-2-跨站请求伪造-CSRF" class="headerlink" title="3.2 跨站请求伪造 CSRF"></a>3.2 跨站请求伪造 CSRF</h4><ul><li>跨站点请求伪造 (<code>CSRF</code>) 是一种前端安全攻击，通过伪造的形式来执行你原本不希望执行的操作<ul><li>防止<code>CSRF</code>攻击需要确保请求是合法的，并且是用户有意发起的</li><li>防止<code>CSRF</code>攻击的最简单方法之一是使用从服务器生成的<code>CSRF</code>令牌。如果客户端无法提供准确的令牌，服务器可以拒绝请求的操作</li></ul></li></ul><hr><h3 id="4-网络协议"><a href="#4-网络协议" class="headerlink" title="4. 网络协议"></a>4. 网络协议</h3><h4 id="4-1-网络七层模型与四层模型区别"><a href="#4-1-网络七层模型与四层模型区别" class="headerlink" title="4.1 网络七层模型与四层模型区别"></a>4.1 网络七层模型与四层模型区别</h4><ul><li>参考: <a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903492763533319?searchId=20241013095821BCBAFA2F17F7FC9E99C5">链接</a></li><li>网络七层模型 <code>OSI</code>（<code>Open Systems Interconnection Model</code>）是一个标准，而非实现</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/imgCapture1234.PNG"></p><ul><li><code>OSI</code>模型是从上往下的，越底层越接近硬件，越往上越接近软件，这七层模型分别是<strong>物理层、数据链路层、网络层、传输层、会话层、表示层、应用层</strong>。</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; 物理层：底层数据传输，如网线；网卡标准。</span><br><span class="line">&gt; 数据链路层：定义数据的基本格式，如何传输，如何标识；如网卡MAC地址。</span><br><span class="line">&gt; 网络层：定义IP编址，定义路由功能；如不同设备的数据转发。</span><br><span class="line">&gt; 传输层：端到端传输数据的基本功能；如 TCP、UDP。</span><br><span class="line">&gt; 会话层：控制应用程序之间会话能力；如不同软件数据分发给不同软件。</span><br><span class="line">&gt; 标识层：数据格式标识，基本压缩加密功能。</span><br><span class="line">&gt; 应用层：各种应用软件，包括 Web 应用。</span><br></pre></td></tr></table></figure><ul><li>网络四层模型是一个实现的应用模型，由七层模型简化合并而来</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/imgCapture4321.PNG"></p><ul><li><code>TCP/IP</code>模型将<code>OSI</code>模型由七层简化为四层，传输层和网络层被完整保留，因此网络中最核心的技术就是传输层和网络层技术</li></ul><hr><h4 id="4-2-http-和-https-基本概念"><a href="#4-2-http-和-https-基本概念" class="headerlink" title="4.2 http 和 https 基本概念"></a>4.2 http 和 https 基本概念</h4><ul><li><code>HTTP</code>: 是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准<code>TCP</code>，用于从<code>WWW</code>服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少</li><li><code>HTTPS</code>: 是以安全为目标的<code>HTTP</code>通道，简单讲是<code>HTTP</code>的安全版，即<code>HTTP</code>下加入<code>SSL</code>层，<code>HTTPS</code>的安全基础是<code>SSL</code>，因此加密的详细内容就需要<code>SSL</code></li><li><code>HTTPS</code>协议的主要作用可以分为两种：一种是建立一个信息安全通道，来保证数据传输的安全。另一种就是确认网站的真实性</li></ul><hr><h4 id="4-3-http-和-https-区别"><a href="#4-3-http-和-https-区别" class="headerlink" title="4.3 http 和 https 区别"></a>4.3 http 和 https 区别</h4><p><code>HTTP</code>协议传输的数据都是未加密的，也就是明文的，因此使用<code>HTTP</code>协议传输隐私信息非常不安全，为了保证 这些隐私数据能加密传输，于是网景公司设计了<code>SSL</code>(<code>Secure Sockets Layer</code>)协议用于对<code>HTTP</code>协议传输的数据进行加密，从而就诞生了<code>HTTPS</code>。简单来说，<code>HTTPS</code>协议是由<code>SSL+HTTP</code>协议构建的可进行加密传输、身份认证的网络协议，要比<code>HTTP</code>协议安全</p><ul><li><code>https</code>协议需要到<code>ca</code>申请证书，一般免费证书较少，因而需要一定费用</li><li><code>http</code>是超文本传输协议，信息是明文传输，<code>https</code>则是具有安全性的<code>ssl</code>加密传输协议</li><li><code>http</code>和<code>https</code>使用的是完全不同的连接方式，用的端口也不一样，前者是<code>80</code>，后者是<code>443</code></li><li><code>http</code>的连接很简单，是无状态的。<code>https</code>协议是由<code>SSL+HTTP</code>协议构建的可进行加密传输、身份认证的网络协议，比<code>http</code>协议安全</li></ul><blockquote><p>注意: <code>HTTPS = HTTP + SSL/TLS</code>，如今<code>SSL</code>已废弃，所以现在只关注<code>HTTP + TLS</code></p></blockquote><hr><h4 id="4-4-http1-x-和-http2-x-区别"><a href="#4-4-http1-x-和-http2-x-区别" class="headerlink" title="4.4 http1.x 和 http2.x 区别"></a>4.4 http1.x 和 http2.x 区别</h4><p><code>http1.x</code>和<code>http2.x</code>主要有以下<code>4</code>个区别</p><ul><li><p><code>HTTP2</code>使用的是二进制传送，<code>HTTP1.X</code>是文本(字符串)传送</p><ul><li>二进制传送的单位是帧和流。帧组成了流，同时流还有流<code>ID</code>标示</li><li>优势: 传输速度更快 (二进制数据体积较小), 处理更高效 (不需要进行文本解析), 适用于复杂数据类型 (图像、音频、视频), 安全性更高 (二进制数据不易被直接阅读)</li></ul></li><li><p><code>HTTP2</code>支持多路复用</p><ul><li>因为有流<code>ID</code>，所以通过同一个<code>http</code>请求实现多个<code>http</code>请求传输变成了可能，可以通过流<code>ID</code>来标示究竟是哪个流从而定位到是哪个<code>http</code>请求</li></ul></li><li><p><code>HTTP2</code>头部压缩</p><ul><li><code>HTTP2</code>通过<code>gzip</code>和<code>compress</code>压缩头部然后再发送，同时客户端和服务器端同时维护一张头信息表，所有字段都记录在这张表中，这样后面每次传输只需要传输表里面的索引<code>ID</code>就行，通过索引<code>ID</code>查询表头的值</li></ul></li><li><p><code>HTTP2</code>支持服务器推送</p><ul><li><code>HTTP2</code>支持在未经客户端许可的情况下，主动向客户端推送内容</li></ul></li></ul><hr><h4 id="4-5-http-请求方式"><a href="#4-5-http-请求方式" class="headerlink" title="4.5 http 请求方式"></a>4.5 http 请求方式</h4><p><code>http</code>请求方式有以下<code>8</code>种，其中<code>GET</code>和<code>POST</code>是最常用的</p><ul><li><code>GET</code>: 向特定的资源发出请求。<code>GET</code>方法不应当被用于产生“副作用”的操作中</li><li><code>POST</code>: 向指定资源提交数据进行处理请求, 例如提交表单或者上传文件。数据被包含在请求体中。<code>POST</code>请求可能会导致新的资源的建立和&#x2F;或已有资源的修改</li><li><code>PUT</code>: 向指定资源位置上传其最新内容</li><li><code>DELETE</code>: 请求服务器删除<code>Request-URL</code>所标识的资源</li><li><code>HEAD</code>: 向服务器索与<code>GET</code>请求相一致的响应，只不过响应体将不会被返回。这一方法可以再不必传输整个响应内容的情况下，就可以获取包含在响应小消息头中的元信息</li><li><code>OPTIONS</code>: 返回服务器针对特定资源所支持的<code>HTTP</code>请求方法，也可以利用向<code>web</code>服务器发送<code>‘*’</code>的请求来测试服务器的功能性</li><li><code>TRACE</code>: 回显服务器收到的请求，主要用于测试或诊断</li><li><code>CONNECT</code>: <code>HTTP/1.1</code>协议中预留给能够将连接改为管道方式的代理服务器</li></ul><hr><h4 id="4-6-TCP-三次握手"><a href="#4-6-TCP-三次握手" class="headerlink" title="4.6 TCP 三次握手"></a>4.6 TCP 三次握手</h4><hr><h3 id="5-React-题目"><a href="#5-React-题目" class="headerlink" title="5. React 题目"></a>5. React 题目</h3><hr><h3 id="6-缓存"><a href="#6-缓存" class="headerlink" title="6. 缓存"></a>6. 缓存</h3><h4 id="6-1-强缓存与协商缓存"><a href="#6-1-强缓存与协商缓存" class="headerlink" title="6.1 强缓存与协商缓存"></a>6.1 强缓存与协商缓存</h4><ul><li><p>参考: <a target="_blank" rel="noopener" href="https://juejin.cn/post/7259298281578889273?searchId=20241013235036EC2DA00FC6CFFB00CC87">链接</a></p></li><li><p>为了减少资源请求次数，加快资源访问速度，浏览器会对资源文件如图片、<code>css</code>文件、<code>js</code>文件等进行缓存，而浏览器缓存策略又分为强缓存和协商缓存</p></li><li><p>强缓存 <code>Strong Cache</code></p><ul><li>所谓强缓存，可以理解为强制缓存的意思，即浏览器在访问某个资源时会判断是否使用本地缓存里已经存在的资源文件，使用本地缓存的话则不会发送请求到服务器，从而达到减轻服务器访问压力的作用，且由于直接从本地缓存读取资源文件，大大提高了加载速度</li><li>浏览器第一次请求远程服务器的某个资源时，如果服务器希望浏览器得到该资源后一段时间内不要再发送请求过来，直接从浏览器里的缓存里取，则服务器可以通过在响应头里设置<code>Cache-Control: max-age=31536000</code>，<code>max-age</code>代表缓存时间，单位为秒，这里的数据换算过来就是一年，意味着在一年内浏览器不会再向服务器发送请求。</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/imgCapture4567.PNG"></p><ul><li>使用缓存的话，状态码<code>200</code>后面会标明情况。浏览器缓存资源的地方有两个: 磁盘缓存（<code>disk cache</code>）和内存缓存（<code>memory cache</code>）</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/imgCapture7654.PNG"></p><ul><li>当缓存时间到期后再次访问时，状态码<code>200</code>后面便没有括号内的内容了</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/imgCapture12345.PNG"></p><blockquote><p>一般来说，浏览器会将较大的资源缓存到<code>disk cache</code>，而较小的资源则被缓存到<code>memory cache</code>里。内存缓存与磁盘缓存相比，访问速度要更快一些</p></blockquote><ul><li>强缓存除了使用<code>Cache-Control</code>实现之外，还可以使用<code>Expires</code>字段，<code>Expires</code>是<code>Http1.0</code>规范，<code>Cache-Control</code>是<code>Http1.1</code>规范，<code>Expires</code>返回一个具体的时间值，代表缓存的有效期，在该日期内浏览器不会向服务器发起请求，而是直接从缓存里获取资源</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/imgCapture5431.PNG"></p><ul><li>因为<code>Expires</code>参照的是本地客户端的时间，而客户端的时间是可以被修改的，所以会有误差产生的情况，这也是<code>Expires</code>的一个缺点，所以有了后来<code>Http1.1</code>规范的<code>Cache-control</code></li></ul><blockquote><p><code>Cache-control</code>的优先级要高于<code>Expires</code>，如果两者同时设置，会优先使用<code>Cache-control</code>而忽略掉<code>Expires</code></p></blockquote><ul><li>协商缓存 <code>Negotiation Cache</code><ul><li>在强缓存里，是否使用缓存是由浏览器来确定的，而协商缓存则是由服务器来告诉浏览器是否使用缓存资源，也就是浏览器每一次都要发送请求到服务器询问是否使用缓存</li><li>浏览器初次请求资源，服务器返回资源，同时生成一个<code>Etag</code>值携带在响应头里返回给浏览器，当浏览器再次请求资源时会在请求头里携带<code>If-None-Match</code>，值是之前服务器返回的<code>Etag</code>的值，服务器收到之后拿该值与资源文件最新的<code>Etag</code>值做对比</li></ul></li></ul><blockquote><p>如果没有变化则返回<code>304</code>，告诉浏览器继续使用缓存（不返回资源文件）<br>如果发生变化，则返回<code>200</code>和最新的资源文件给浏览器使用</p></blockquote><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/imgCapture2567.PNG"></p><ul><li>除了<code>Etag</code>外，还有一个<code>Last-Modified</code>的属性，它是<code>Http1.0</code>规范的，服务器返回<code>Last-Modified</code>，浏览器请求头对应携带的是<code>If-Modified-since</code>，与<code>Etag</code>不同的是，<code>Last-Modified</code>的值是一个时间值，代表文件的修改时间，服务器通过对比文件的修改时间是否发生改变来判断是否使用缓存</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/imgCapture7890.PNG"></p><ul><li>相比<code>Last-Modified</code>，<code>Etag</code>优先级更高，使用上也更精确一些，因为有时候会存在文件内容并没有改变，但文件的修改时间变更了，<code>Last-Modified</code>不一致所以服务器会重新返回资源文件，实际上还是可以继续使用缓存的</li></ul><blockquote><p>强缓存优先级大于协商缓存，即两者同时存在时，如果强缓存开启且在有效期内，则不会走协商缓存</p></blockquote><hr><h3 id="7-算法"><a href="#7-算法" class="headerlink" title="7. 算法"></a>7. 算法</h3><h4 id="7-1-LRU-Cache"><a href="#7-1-LRU-Cache" class="headerlink" title="7.1 LRU Cache"></a>7.1 LRU Cache</h4><ul><li>字节一面算法题</li><li>使用<code>JS</code>实现一个魔改版的<code>LRU Cache</code>，并且满足以下要求</li></ul><blockquote><p>维护一个容量为<code>n</code>的缓存<br>每个缓存项如果在<code>X</code>秒后没有被使用，则自动删除</p></blockquote><ul><li>可以使用<code>Map</code>来维护缓存的顺序和容量，利用<code>setTimeout</code>来实现自动删除的功能</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">capacity, expireTime</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">capacity</span> = capacity; <span class="comment">// 缓存容量</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">expireTime</span> = expireTime; <span class="comment">// 缓存项的有效时间（秒）</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">cache</span> = <span class="keyword">new</span> <span class="title class_">Map</span>(); <span class="comment">// 用 Map 来存储缓存数据</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">timers</span> = <span class="keyword">new</span> <span class="title class_">Map</span>(); <span class="comment">// 用来存储每个缓存项的定时器</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取缓存</span></span><br><span class="line">  <span class="title function_">get</span>(<span class="params">key</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">cache</span>.<span class="title function_">has</span>(key)) <span class="keyword">return</span> -<span class="number">1</span>; <span class="comment">// 如果缓存中没有这个key，返回-1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果缓存命中，需要刷新缓存的顺序（将这个key移到最新的位置）</span></span><br><span class="line">    <span class="keyword">const</span> value = <span class="variable language_">this</span>.<span class="property">cache</span>.<span class="title function_">get</span>(key);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">cache</span>.<span class="title function_">delete</span>(key); <span class="comment">// 先删除老的位置</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">cache</span>.<span class="title function_">set</span>(key, value); <span class="comment">// 重新插入，保证最新访问的在末尾</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重置定时器，延长过期时间</span></span><br><span class="line">    <span class="built_in">clearTimeout</span>(<span class="variable language_">this</span>.<span class="property">timers</span>.<span class="title function_">get</span>(key)); <span class="comment">// 清除老的定时器</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">timers</span>.<span class="title function_">set</span>(key, <span class="variable language_">this</span>.<span class="title function_">setExpiration</span>(key)); <span class="comment">// 重新设置定时器</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 添加缓存</span></span><br><span class="line">  <span class="title function_">put</span>(<span class="params">key, value</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">cache</span>.<span class="title function_">has</span>(key)) &#123;</span><br><span class="line">      <span class="comment">// 如果已经存在，删除旧的缓存</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">cache</span>.<span class="title function_">delete</span>(key);</span><br><span class="line">      <span class="built_in">clearTimeout</span>(<span class="variable language_">this</span>.<span class="property">timers</span>.<span class="title function_">get</span>(key));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果缓存已满，删除最老的缓存</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">cache</span>.<span class="property">size</span> &gt;= <span class="variable language_">this</span>.<span class="property">capacity</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> oldestKey = <span class="variable language_">this</span>.<span class="property">cache</span>.<span class="title function_">keys</span>().<span class="title function_">next</span>().<span class="property">value</span>; <span class="comment">// 获取 Map 中第一个（最旧）的key</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">cache</span>.<span class="title function_">delete</span>(oldestKey); <span class="comment">// 删除最旧的缓存项</span></span><br><span class="line">      <span class="built_in">clearTimeout</span>(<span class="variable language_">this</span>.<span class="property">timers</span>.<span class="title function_">get</span>(oldestKey)); <span class="comment">// 清除相应的定时器</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">timers</span>.<span class="title function_">delete</span>(oldestKey); <span class="comment">// 删除定时器记录</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入新的缓存项</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">cache</span>.<span class="title function_">set</span>(key, value);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">timers</span>.<span class="title function_">set</span>(key, <span class="variable language_">this</span>.<span class="title function_">setExpiration</span>(key)); <span class="comment">// 设置定时器</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置缓存项的自动删除定时器</span></span><br><span class="line">  <span class="title function_">setExpiration</span>(<span class="params">key</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">cache</span>.<span class="title function_">delete</span>(key); <span class="comment">// 删除缓存项</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">timers</span>.<span class="title function_">delete</span>(key); <span class="comment">// 删除定时器记录</span></span><br><span class="line">    &#125;, <span class="variable language_">this</span>.<span class="property">expireTime</span> * <span class="number">1000</span>); <span class="comment">// 转换为毫秒</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> lru = <span class="keyword">new</span> <span class="title class_">LRUCache</span>(<span class="number">3</span>, <span class="number">5</span>); <span class="comment">// 创建容量为3，缓存项5秒后失效的LRU Cache</span></span><br><span class="line">lru.<span class="title function_">put</span>(<span class="number">1</span>, <span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">lru.<span class="title function_">put</span>(<span class="number">2</span>, <span class="string">&#x27;B&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(lru.<span class="title function_">get</span>(<span class="number">1</span>)); <span class="comment">// 输出 &#x27;A&#x27;</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(lru.<span class="title function_">get</span>(<span class="number">2</span>)); <span class="comment">// 在5秒内访问，输出 &#x27;B&#x27;</span></span><br><span class="line">&#125;, <span class="number">4000</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(lru.<span class="title function_">get</span>(<span class="number">1</span>)); <span class="comment">// 超过5秒未访问，输出 -1（已过期）</span></span><br><span class="line">&#125;, <span class="number">6000</span>);</span><br></pre></td></tr></table></figure><hr><h4 id="7-2-格式化数字"><a href="#7-2-格式化数字" class="headerlink" title="7.2 格式化数字"></a>7.2 格式化数字</h4><ul><li><p>字节一面算法题</p></li><li><p>给一个数字比如<code>1000000</code>，把它转化成<code>1,000,000</code>。或者是<code>1000000.12</code>，把它转化成<code>1,000,000.12</code>。只能使用<code>JS</code>实现</p></li><li><p>解决方案一: 使用<code>toLocaleString()</code></p></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">formatNumberWithCommas</span>(<span class="params">number</span>) &#123;</span><br><span class="line">  <span class="comment">// 分离整数和小数部分，默认小数部分为空字符串</span></span><br><span class="line">  <span class="keyword">let</span> [integer, decimal = <span class="string">&#x27;&#x27;</span>] = (number + <span class="string">&#x27;&#x27;</span>).<span class="title function_">split</span>(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 通过 toLocaleString 格式化整数部分，自动加上千分位逗号</span></span><br><span class="line">  integer = (+integer).<span class="title function_">toLocaleString</span>();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 如果没有小数部分，直接返回格式化后的整数部分</span></span><br><span class="line">  <span class="keyword">if</span> (decimal === <span class="string">&#x27;&#x27;</span>) <span class="keyword">return</span> integer;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 小数部分无需反转或使用 toLocaleString，直接返回原来的小数部分即可</span></span><br><span class="line">  <span class="keyword">return</span> integer + <span class="string">&#x27;.&#x27;</span> + decimal;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">formatNumberWithCommas</span>(<span class="number">1000000</span>)); <span class="comment">// 输出 &quot;1,000,000&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">formatNumberWithCommas</span>(<span class="number">1000000.12</span>)); <span class="comment">// 输出 &quot;1,000,000.12&quot;</span></span><br></pre></td></tr></table></figure><ul><li>解决方案二: 正则表达式</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">formateNumberWithCommas</span>(<span class="params">number</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> number.<span class="title function_">toString</span>().<span class="title function_">replace</span>(<span class="regexp">/\B(?=(\d&#123;3&#125;)+(?!\d))/g</span>, <span class="string">&quot;,&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">formateNumberWithCommas</span>(<span class="number">1000000</span>)); <span class="comment">// 输出 &quot;1,000,000&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">formateNumberWithCommas</span>(<span class="number">1000000.12</span>)); <span class="comment">// 输出 &quot;1,000,000.12&quot;</span></span><br></pre></td></tr></table></figure><ul><li>解决方案三: 手动实现格式化</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">formatNumberWithCommas</span>(<span class="params">number</span>) &#123;</span><br><span class="line">  <span class="comment">// 类型检测</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> number !== <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 先转成字符串</span></span><br><span class="line">  number = number.<span class="title function_">toString</span>();</span><br><span class="line">  <span class="comment">// 支持小数,按小数点分成两部分 使用了es6解构</span></span><br><span class="line">  <span class="keyword">let</span> [integer, decimal] = number.<span class="title function_">split</span>(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 封装了 doSplit 方法 第二个参数 isInteger 来表示是整数部分还是小数部分</span></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">doSplit</span> = (<span class="params">num, isInteger = <span class="literal">true</span></span>) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 如果为空，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (!num) <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="comment">// 如果是整数部分 先按位切割再反转</span></span><br><span class="line">    <span class="comment">// 整数部分数字从右往左数，每3位插入一个逗号</span></span><br><span class="line">    <span class="comment">// 小数部分从左往右数</span></span><br><span class="line">    <span class="comment">// 两次反转，它的逗号顺序是一样的。</span></span><br><span class="line">    <span class="keyword">if</span> (isInteger) num = num.<span class="title function_">split</span>(<span class="string">&#x27;&#x27;</span>).<span class="title function_">reverse</span>();</span><br><span class="line">    <span class="keyword">let</span> str = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; num.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (i !== <span class="number">0</span> &amp;&amp; i % <span class="number">3</span> === <span class="number">0</span>) str.<span class="title function_">push</span>(<span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">      str.<span class="title function_">push</span>(num[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isInteger) <span class="keyword">return</span> str.<span class="title function_">reverse</span>().<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> str.<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 处理整数部分</span></span><br><span class="line">  integer = <span class="title function_">doSplit</span>(integer);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 处理小数部分，确保 undefined 小数不会导致问题</span></span><br><span class="line">  decimal = decimal ? <span class="title function_">doSplit</span>(decimal, <span class="literal">false</span>) : <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> integer + (decimal === <span class="string">&#x27;&#x27;</span> ? <span class="string">&#x27;&#x27;</span> : <span class="string">&#x27;.&#x27;</span> + decimal);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">formatNumberWithCommas</span>(<span class="number">1000000</span>)); <span class="comment">// 输出 &quot;1,000,000&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">formatNumberWithCommas</span>(<span class="number">1000000.12</span>)); <span class="comment">// 输出 &quot;1,000,000.12&quot;</span></span><br></pre></td></tr></table></figure><hr><h4 id="7-3-手写数组转树"><a href="#7-3-手写数组转树" class="headerlink" title="7.3 手写数组转树"></a>7.3 手写数组转树</h4><ul><li>做到类似下面的转换</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> input = [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">val</span>: <span class="string">&#x27;学校&#x27;</span>, <span class="attr">parentId</span>: <span class="literal">null</span></span><br><span class="line">    &#125;, &#123;</span><br><span class="line">        <span class="attr">id</span>: <span class="number">2</span>, <span class="attr">val</span>: <span class="string">&#x27;班级1&#x27;</span>, <span class="attr">parentId</span>: <span class="number">1</span></span><br><span class="line">    &#125;, &#123;</span><br><span class="line">        <span class="attr">id</span>: <span class="number">3</span>, <span class="attr">val</span>: <span class="string">&#x27;班级2&#x27;</span>, <span class="attr">parentId</span>: <span class="number">1</span></span><br><span class="line">    &#125;, &#123;</span><br><span class="line">        <span class="attr">id</span>: <span class="number">4</span>, <span class="attr">val</span>: <span class="string">&#x27;学生1&#x27;</span>, <span class="attr">parentId</span>: <span class="number">2</span></span><br><span class="line">    &#125;, &#123;</span><br><span class="line">        <span class="attr">id</span>: <span class="number">5</span>, <span class="attr">val</span>: <span class="string">&#x27;学生2&#x27;</span>, <span class="attr">parentId</span>: <span class="number">2</span></span><br><span class="line">    &#125;, &#123;</span><br><span class="line">        <span class="attr">id</span>: <span class="number">6</span>, <span class="attr">val</span>: <span class="string">&#x27;学生3&#x27;</span>, <span class="attr">parentId</span>: <span class="number">3</span></span><br><span class="line">    &#125;,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> output = &#123;</span><br><span class="line">    <span class="attr">id</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">val</span>: <span class="string">&#x27;学校&#x27;</span>,</span><br><span class="line">    <span class="attr">children</span>: [&#123;</span><br><span class="line">        <span class="attr">id</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="attr">val</span>: <span class="string">&#x27;班级1&#x27;</span>,</span><br><span class="line">        <span class="attr">children</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">id</span>: <span class="number">4</span>,</span><br><span class="line">                <span class="attr">val</span>: <span class="string">&#x27;学生1&#x27;</span>,</span><br><span class="line">                <span class="attr">children</span>: []</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">id</span>: <span class="number">5</span>,</span><br><span class="line">                <span class="attr">val</span>: <span class="string">&#x27;学生2&#x27;</span>,</span><br><span class="line">                <span class="attr">children</span>: []</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;, &#123;</span><br><span class="line">        <span class="attr">id</span>: <span class="number">3</span>,</span><br><span class="line">        <span class="attr">val</span>: <span class="string">&#x27;班级2&#x27;</span>,</span><br><span class="line">        <span class="attr">children</span>: [&#123;</span><br><span class="line">            <span class="attr">id</span>: <span class="number">6</span>,</span><br><span class="line">            <span class="attr">val</span>: <span class="string">&#x27;学生3&#x27;</span>,</span><br><span class="line">            <span class="attr">children</span>: []</span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">arrayToTree</span>(<span class="params">array</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> root = array[<span class="number">0</span>];</span><br><span class="line">  array.<span class="title function_">shift</span>();</span><br><span class="line">  <span class="keyword">let</span> tree = &#123;</span><br><span class="line">    <span class="attr">id</span>: root.<span class="property">id</span>,</span><br><span class="line">    <span class="attr">val</span>: root.<span class="property">val</span>,</span><br><span class="line">    <span class="attr">children</span>: array.<span class="property">length</span> &gt; <span class="number">0</span> ? <span class="title function_">toTree</span>(root.<span class="property">id</span>, array) : []</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> tree;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">toTree</span>(<span class="params">parentId, array</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> children = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; array.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> node = array[i];</span><br><span class="line">    <span class="keyword">if</span> (node.<span class="property">parentId</span> === parentId) &#123;</span><br><span class="line">      children.<span class="title function_">push</span>(&#123;</span><br><span class="line">        <span class="attr">id</span>: node.<span class="property">id</span>,</span><br><span class="line">        <span class="attr">val</span>: node.<span class="property">val</span>,</span><br><span class="line">        <span class="attr">children</span>: <span class="title function_">toTree</span>(node.<span class="property">id</span>, array)</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> children;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">arrayToTree</span>(input));</span><br></pre></td></tr></table></figure><hr><h4 id="7-4-数组去重"><a href="#7-4-数组去重" class="headerlink" title="7.4 数组去重"></a>7.4 数组去重</h4><ul><li><p>将<code>[1,1,2,2,3,3,4,4,5,5]</code>去重, 结果应该是<code>[1,2,3,4,5]</code></p></li><li><p>方法一: <code>ES6</code>的<code>Set</code>去重</p></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>];</span><br><span class="line"><span class="keyword">const</span> setData = <span class="title class_">Array</span>.<span class="title function_">from</span>(<span class="keyword">new</span> <span class="title class_">Set</span>(arr));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(setData);</span><br></pre></td></tr></table></figure><blockquote><p><code>Set</code>去重有一个弊端，无法去重引用类型的数据。比如对象数组<code>[&#123;a:1&#125;, &#123;a:1&#125;]</code></p></blockquote><ul><li>方法二: 双重<code>for</code>循环去重</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">handleRemoveRepeat</span> = (<span class="params">arr</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, len = arr.<span class="property">length</span>; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; len; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (arr[i] === arr[j]) &#123;</span><br><span class="line">        arr.<span class="title function_">splice</span>(j, <span class="number">1</span>);</span><br><span class="line">        j--;</span><br><span class="line">        len--;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>使用<code>len = arr.length</code>的原因: 假设这个循环需要循环<code>10000</code>次，<code>length</code>就会被执行<code>10000</code>次</p></blockquote><hr><h3 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h3><blockquote><p>文件还未上传 Github</p></blockquote></article><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/3458e8f8.html" title="算法笔记"><img class="cover" src="https://cdn.jsdelivr.net/gh/Hongda-OSU/PicGo/image/od2iyorqbvbnha2g2vybpn8v4tiq4qw.jpg" onerror='onerror=null,src="https://cdn.jsdelivr.net/gh/Hongda-OSU/PicGo/image/404.GIF"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">算法笔记</div></div></a></div><div class="next-post pull-right"><a href="/posts/fbe58254.html" title="ES6学习笔记 • 上"><img class="cover" src="https://cdn.jsdelivr.net/gh/Hongda-OSU/PicGo/image/8shhfm8bsq648izivnrc32jq9e0d62e.jpg" onerror='onerror=null,src="https://cdn.jsdelivr.net/gh/Hongda-OSU/PicGo/image/404.GIF"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">ES6学习笔记 • 上</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://cdn.jsdelivr.net/gh/Hongda-OSU/PicGo/image/德狗子.GIF" onerror='this.onerror=null,this.src="https://cdn.jsdelivr.net/gh/Hongda-OSU/PicGo/image/404.GIF"' alt="avatar"></div><div class="author-info__name">鴻達</div><div class="author-info__description">记录 我的 生活</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">23</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">13</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Hongda-OSU" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="https://www.linkedin.com/in/hongda-lin" target="_blank" title="Linkedin"><i class="fab fa-linkedin"></i></a><a class="social-icon" href="https://hongdalin.me" target="_blank" title="Portfolio"><i class="iconfont icon-guanfangwangzhan"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">文章右下角小工具进入阅读模式</div></div><div class="xpand" style="height:200px"><canvas class="illo" width="800" height="800" style="max-width:200px;max-height:200px;touch-action:none;width:640px;height:640px"></canvas></div><script src="https://npm.elemecdn.com/ethan4116-blog/lib/js/other/two-people/twopeople1.js"></script><script src="https://npm.elemecdn.com/ethan4116-blog/lib/js/other/two-people/zdog.dist.js"></script><script id="rendered-js" src="https://npm.elemecdn.com/ethan4116-blog/lib/js/other/two-people/twopeople.js"></script><style>.card-widget.card-announcement{margin:0;align-items:center;justify-content:center;text-align:center}canvas{display:block;margin:0 auto;cursor:move}</style><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-CSS-%E9%A2%98%E7%9B%AE"><span class="toc-text">1. CSS 题目</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-%E7%94%BB%E7%AD%89%E8%85%B0%E7%9B%B4%E8%A7%92%E4%B8%89%E8%A7%92%E5%BD%A2"><span class="toc-text">1.1 画等腰直角三角形</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-%E4%B8%8D%E5%AE%9A%E5%AE%BD%E9%AB%98%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD"><span class="toc-text">1.2 不定宽高水平垂直居中</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-%E6%AD%A3%E6%96%B9%E5%BD%A2%E5%AD%90%E5%85%83%E7%B4%A0"><span class="toc-text">1.3 正方形子元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-position-%E5%AE%9A%E4%BD%8D"><span class="toc-text">1.4 position 定位</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-5-%E7%9B%92%E6%A8%A1%E5%9E%8B"><span class="toc-text">1.5 盒模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-6-CSS-%E5%AE%9E%E7%8E%B0%E6%89%87%E5%BD%A2"><span class="toc-text">1.6 CSS 实现扇形</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-7-BFC"><span class="toc-text">1.7 BFC</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-JS-%E9%A2%98%E7%9B%AE"><span class="toc-text">2. JS 题目</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-var-%E4%B8%8E%E5%BE%AA%E7%8E%AF"><span class="toc-text">2.1 var 与循环</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-%E6%89%8B%E5%86%99%E5%80%92%E8%AE%A1%E6%97%B6"><span class="toc-text">2.2 手写倒计时</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81"><span class="toc-text">2.3 防抖和节流</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-undefined-%E4%B8%8E-null-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">2.4 undefined 与 null 的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D"><span class="toc-text">2.5 浅拷贝和深拷贝</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-6-%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96"><span class="toc-text">2.6 函数柯里化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-7-%E6%95%B0%E7%BB%84%E6%89%81%E5%B9%B3%E5%8C%96"><span class="toc-text">2.7 数组扁平化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-8-typeof-%E5%88%A4%E6%96%AD"><span class="toc-text">2.8 typeof 判断</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-9-%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98%E4%BC%98%E5%8C%96"><span class="toc-text">2.9 事件委托优化</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8"><span class="toc-text">3. 网络安全</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%AC%E6%94%BB%E5%87%BB-XSS"><span class="toc-text">3.1 跨站脚本攻击 XSS</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0-CSRF"><span class="toc-text">3.2 跨站请求伪造 CSRF</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE"><span class="toc-text">4. 网络协议</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-%E7%BD%91%E7%BB%9C%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%9B%9B%E5%B1%82%E6%A8%A1%E5%9E%8B%E5%8C%BA%E5%88%AB"><span class="toc-text">4.1 网络七层模型与四层模型区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-http-%E5%92%8C-https-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-text">4.2 http 和 https 基本概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-http-%E5%92%8C-https-%E5%8C%BA%E5%88%AB"><span class="toc-text">4.3 http 和 https 区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-http1-x-%E5%92%8C-http2-x-%E5%8C%BA%E5%88%AB"><span class="toc-text">4.4 http1.x 和 http2.x 区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-5-http-%E8%AF%B7%E6%B1%82%E6%96%B9%E5%BC%8F"><span class="toc-text">4.5 http 请求方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-6-TCP-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="toc-text">4.6 TCP 三次握手</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-React-%E9%A2%98%E7%9B%AE"><span class="toc-text">5. React 题目</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E7%BC%93%E5%AD%98"><span class="toc-text">6. 缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1-%E5%BC%BA%E7%BC%93%E5%AD%98%E4%B8%8E%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98"><span class="toc-text">6.1 强缓存与协商缓存</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E7%AE%97%E6%B3%95"><span class="toc-text">7. 算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-1-LRU-Cache"><span class="toc-text">7.1 LRU Cache</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2-%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%95%B0%E5%AD%97"><span class="toc-text">7.2 格式化数字</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-3-%E6%89%8B%E5%86%99%E6%95%B0%E7%BB%84%E8%BD%AC%E6%A0%91"><span class="toc-text">7.3 手写数组转树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-4-%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D"><span class="toc-text">7.4 数组去重</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%99%84%E5%BD%95"><span class="toc-text">附录</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/7c522c36.html" title="切图仔 2"><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/imgbmcrg53uzso0a5lk4rcm76njiw0mw0m.jpg" onerror='this.onerror=null,this.src="https://cdn.jsdelivr.net/gh/Hongda-OSU/PicGo/image/404.GIF"' alt="切图仔 2"></a><div class="content"><a class="title" href="/posts/7c522c36.html" title="切图仔 2">切图仔 2</a><time datetime="2024-12-23T18:03:05.000Z" title="发表于 2024-12-23 12:03:05">2024-12-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/d58818f0.html" title="WebGL 学习笔记"><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/imgdip29s0ui3xcpinvtb8pelnc00xb05s.jpg" onerror='this.onerror=null,this.src="https://cdn.jsdelivr.net/gh/Hongda-OSU/PicGo/image/404.GIF"' alt="WebGL 学习笔记"></a><div class="content"><a class="title" href="/posts/d58818f0.html" title="WebGL 学习笔记">WebGL 学习笔记</a><time datetime="2024-12-08T16:15:05.000Z" title="发表于 2024-12-08 10:15:05">2024-12-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/558bc4fb.html" title="GO 学习笔记"><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/imgbqwt4ir73bffcbd68bcq4c0turzstua.jpg" onerror='this.onerror=null,this.src="https://cdn.jsdelivr.net/gh/Hongda-OSU/PicGo/image/404.GIF"' alt="GO 学习笔记"></a><div class="content"><a class="title" href="/posts/558bc4fb.html" title="GO 学习笔记">GO 学习笔记</a><time datetime="2024-11-23T16:15:05.000Z" title="发表于 2024-11-23 10:15:05">2024-11-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/13fe9182.html" title="原型链解析"><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/imgl5zrba8rs677k0siqvc37eh5l0hdzqu.jpg" onerror='this.onerror=null,this.src="https://cdn.jsdelivr.net/gh/Hongda-OSU/PicGo/image/404.GIF"' alt="原型链解析"></a><div class="content"><a class="title" href="/posts/13fe9182.html" title="原型链解析">原型链解析</a><time datetime="2024-11-14T16:15:05.000Z" title="发表于 2024-11-14 10:15:05">2024-11-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/29dadae9.html" title="PostgreSQL 学习笔记"><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/imgied0v0dgsgyqeoh7804b0ca54buj0qd.jpg" onerror='this.onerror=null,this.src="https://cdn.jsdelivr.net/gh/Hongda-OSU/PicGo/image/404.GIF"' alt="PostgreSQL 学习笔记"></a><div class="content"><a class="title" href="/posts/29dadae9.html" title="PostgreSQL 学习笔记">PostgreSQL 学习笔记</a><time datetime="2024-08-02T15:15:06.000Z" title="发表于 2024-08-02 10:15:06">2024-08-02</time></div></div></div></div></div></div></main><footer id="footer" style="background:rgba(0,0,0,.25)"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2025 &nbsp;<i id="heartbeat" class="fa fas fa-heartbeat"></i> &nbsp;鴻達</div><div class="footer_custom_text"><p class="badge"><a style="margin-inline:5px" target="_blank" href="https://hexo.io/"><img src="https://img.shields.io/badge/Frame-Hexo-informational?style=flat&logo=hexo"></a><a style="margin-inline:5px" target="_blank" href="https://domains.google/"><img src="https://img.shields.io/badge/Hosted-Google-ff69b4?style=flat&logo=googledomains"></a><a style="margin-inline:5px" target="_blank" href="https://gulpjs.com/"><img src="https://img.shields.io/badge/Compress-gulp-critical?style=flat&logo=gulp"></a><a style="margin-inline:5px" target="_blank" href="https://www.jsdelivr.com/"><img src="https://img.shields.io/badge/CDN-jsDelivr-orange?style=flat&logo=jsDelivr"></a><a style="margin-inline:5px" target="_blank" href="https://github.com/"><img src="https://img.shields.io/badge/Source-Github-black?style=flat&logo=GitHub"></a><a style="margin-inline:5px" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&logo=Claris"></a></p></div></div><link rel="stylesheet" href="https://fastly.jsdelivr.net/gh/HCLonely/images@master/others/heartbeat.min.css"></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i> <span>数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script>function panguFn(){"object"==typeof pangu?pangu.autoSpacingPage():getScript("https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js").then((()=>{pangu.autoSpacingPage()}))}function panguInit(){GLOBAL_CONFIG_SITE.isPost&&panguFn()}document.addEventListener("DOMContentLoaded",panguInit)</script><script src="/js/search/local-search.js"></script><div class="js-pjax"></div><script defer src="/js/util.js"></script><script defer src="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js"></script><script disable-devtool-auto src="https://cdn.jsdelivr.net/npm/disable-devtool"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors=["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"];var pjax=new Pjax({elements:'a:not([target="_blank"])',selectors:pjaxSelectors,cacheBust:!1,analytics:!1,scrollRestoration:!1});document.addEventListener("pjax:send",(function(){if(window.tocScrollFn&&window.removeEventListener("scroll",window.tocScrollFn),window.scrollCollect&&window.removeEventListener("scroll",scrollCollect),document.getElementById("rightside").style.cssText="opacity: ''; transform: ''",window.aplayers)for(let e=0;e<window.aplayers.length;e++)window.aplayers[e].options.fixed||window.aplayers[e].destroy();"object"==typeof typed&&typed.destroy();const e=document.body.classList;e.contains("read-mode")&&e.remove("read-mode"),"object"==typeof disqusjs&&disqusjs.destroy()})),document.addEventListener("pjax:complete",(function(){window.refreshFn(),document.querySelectorAll("script[data-pjax]").forEach((e=>{const t=document.createElement("script"),o=e.text||e.textContent||e.innerHTML||"";Array.from(e.attributes).forEach((e=>t.setAttribute(e.name,e.value))),t.appendChild(document.createTextNode(o)),e.parentNode.replaceChild(t,e)})),GLOBAL_CONFIG.islazyload&&window.lazyLoadInstance.update(),"function"==typeof chatBtnFn&&chatBtnFn(),"function"==typeof panguInit&&panguInit(),"function"==typeof gtag&&gtag("config","",{page_path:window.location.pathname}),"object"==typeof _hmt&&_hmt.push(["_trackPageview",window.location.pathname]),"function"==typeof loadMeting&&document.getElementsByClassName("aplayer").length&&loadMeting(),"object"==typeof Prism&&Prism.highlightAll()})),document.addEventListener("pjax:error",(e=>{404===e.request.status&&pjax.loadUrl("/404.html")}))</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>