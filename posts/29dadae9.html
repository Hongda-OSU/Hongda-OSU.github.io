<!DOCTYPE html><html lang="zh-CN" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><title>PostgreSQL 学习笔记 | 鴻鵠誌達</title><meta name="author" content="鴻達"><meta name="copyright" content="鴻達"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#1a1a1a"><meta name="description" content="PostgreSQL 学习笔记"><meta property="og:type" content="article"><meta property="og:title" content="PostgreSQL 学习笔记"><meta property="og:url" content="https://hongdalin.blog/posts/29dadae9.html"><meta property="og:site_name" content="鴻鵠誌達"><meta property="og:description" content="PostgreSQL 学习笔记"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img700px-Dot_scenario_s1_ep4.png"><meta property="article:published_time" content="2024-08-02T15:15:06.000Z"><meta property="article:modified_time" content="2025-11-23T04:32:04.727Z"><meta property="article:author" content="鴻達"><meta property="article:tag" content="PostgreSQL"><meta property="article:tag" content="SQL"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img700px-Dot_scenario_s1_ep4.png"><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/Hongda-OSU/PicGo/image/德克萨斯.GIF"><link rel="canonical" href="https://hongdalin.blog/posts/29dadae9.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:{path:"/search.xml",preload:!0,languages:{hits_empty:"找不到您查询的内容：${query}"}},translate:void 0,noticeOutdate:void 0,highlight:{plugin:"highlighjs",highlightCopy:!0,highlightLang:!0,highlightHeightLimit:!1},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"},relativeDate:{homepage:!1,post:!1},runtime:"天",date_suffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:void 0,lightbox:"fancybox",Snackbar:void 0,source:{justifiedGallery:{js:"https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js",css:"https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css"}},isPhotoFigcaption:!0,islazyload:!1,isAnchor:!1,percent:{toc:!0,rightside:!1}}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"PostgreSQL 学习笔记",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2025-11-22 22:32:04"}</script><noscript><style>#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(e=>{e.saveToLocal={set:function(e,t,n){if(0===n)return;const o=864e5*n,a={value:t,expiry:(new Date).getTime()+o};localStorage.setItem(e,JSON.stringify(a))},get:function(e){const t=localStorage.getItem(e);if(!t)return;const n=JSON.parse(t);if(!((new Date).getTime()>n.expiry))return n.value;localStorage.removeItem(e)}},e.getScript=e=>new Promise(((t,n)=>{const o=document.createElement("script");o.src=e,o.async=!0,o.onerror=n,o.onload=o.onreadystatechange=function(){const e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(o.onload=o.onreadystatechange=null,t())},document.head.appendChild(o)})),e.getCSS=e=>new Promise(((t,n)=>{const o=document.createElement("link");o.rel="stylesheet",o.href=e,o.onload=()=>t(),o.onerror=()=>n(),document.head.appendChild(o)}));/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")})(window)</script><link rel="stylesheet" href="/css/color.css" media="defer" onload='this.media="all"'><link rel="stylesheet" href="/css/font.css" media="defer" onload='this.media="all"'><link rel="stylesheet" href="/css/icon.css" media="defer" onload='this.media="all"'><link rel="stylesheet" href="/css/layout.css" media="defer" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.css" media="defer" onload='this.media="all"'><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://cdn.jsdelivr.net/gh/Hongda-OSU/PicGo/image/德狗子.GIF" onerror='onerror=null,src="https://cdn.jsdelivr.net/gh/Hongda-OSU/PicGo/image/404.GIF"' alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">31</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">15</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i> <span>时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i> <span>标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>分类</span></a></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i> <span>链接</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i> <span>友情链接</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i> <span>关于</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url('https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img700px-Dot_scenario_s1_ep4.png')"><nav id="nav"><span id="blog-info"><a href="/" title="鴻鵠誌達"><span class="site-name">鴻鵠誌達</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i> <span>搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i> <span>时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i> <span>标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>分类</span></a></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i> <span>链接</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i> <span>友情链接</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i> <span>关于</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">PostgreSQL 学习笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-08-02T15:15:06.000Z" title="发表于 2024-08-02 10:15:06">2024-08-02</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-11-23T04:32:04.727Z" title="更新于 2025-11-22 22:32:04">2025-11-22</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">23.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>100分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" data-flag-title="PostgreSQL 学习笔记"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h2><h3 id="1-简单查询-SELECT"><a href="#1-简单查询-SELECT" class="headerlink" title="1. 简单查询 SELECT"></a>1. 简单查询 SELECT</h3><ul><li><code>SELECT</code>是读取与组合数据的核心，按顺序写子句，按需省略未用部分。</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> [<span class="keyword">DISTINCT</span>] expr_list</span><br><span class="line"><span class="keyword">FROM</span> table_or_subquery t</span><br><span class="line">  [<span class="keyword">JOIN</span> other <span class="keyword">ON</span> <span class="keyword">condition</span>]</span><br><span class="line">[<span class="keyword">WHERE</span> row_predicate]</span><br><span class="line">[<span class="keyword">GROUP</span> <span class="keyword">BY</span> grouping_exprs]</span><br><span class="line">[<span class="keyword">HAVING</span> group_predicate]</span><br><span class="line">[<span class="keyword">UNION</span> <span class="operator">|</span> <span class="keyword">INTERSECT</span> <span class="operator">|</span> <span class="keyword">EXCEPT</span> <span class="keyword">SELECT</span> ...]</span><br><span class="line">[<span class="keyword">ORDER</span> <span class="keyword">BY</span> sort_exprs]</span><br><span class="line">[LIMIT n [<span class="keyword">OFFSET</span> m] <span class="operator">|</span> <span class="keyword">FETCH</span> <span class="keyword">FIRST</span> n <span class="keyword">ROWS</span> <span class="keyword">ONLY</span>]</span><br></pre></td></tr></table></figure><ul><li><p>子句作用速记</p><ul><li><code>DISTINCT</code>: 结果去重。</li><li><code>JOIN</code>: 组合多表行。</li><li><code>WHERE</code>: 分组前行级过滤。</li><li><code>GROUP BY</code>: 按键聚合。未分组列必须聚合。</li><li><code>HAVING</code>: 对聚合结果再过滤。</li><li>集合运算: <code>UNION</code>&#x2F;<code>INTERSECT</code>&#x2F;<code>EXCEPT</code>整集合操作。</li><li>排序 &amp; 限制: <code>ORDER BY</code> + <code>LIMIT/OFFSET</code> 或 <code>FETCH</code> 分页。</li><li>聚合函数: <code>COUNT/SUM/AVG/MAX/MIN</code> 在分组或全表上聚合。</li></ul></li><li><p>常见顺序影响</p><ul><li>执行逻辑（简化）: FROM → JOIN → WHERE → GROUP BY → HAVING → SELECT → UNION 等 → ORDER BY → LIMIT。</li><li>早过滤（WHERE）减少后续分组与排序成本。</li><li>只在需要展示顺序时才加 <code>ORDER BY</code>。分页必须与确定顺序绑定。</li></ul></li></ul><hr><h3 id="2-列别名"><a href="#2-列别名" class="headerlink" title="2. 列别名"></a>2. 列别名</h3><p>列别名用于给输出列临时命名（不改表结构），提升可读性与复用。</p><ul><li>适用: 原始列、表达式、函数、聚合、<code>CASE</code></li><li>引用: 可<code>ORDER BY</code>、外层查询中使用别名，不能在同一层<code>WHERE</code>里引用它</li><li>省略<code>AS</code>等价：<code>col alias</code></li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 基本用法</span></span><br><span class="line"><span class="keyword">SELECT</span> column_name <span class="keyword">AS</span> alias_name <span class="keyword">FROM</span> table_name;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 表达式别名</span></span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">  price <span class="operator">*</span> quantity <span class="keyword">AS</span> total,</span><br><span class="line">  <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> cnt</span><br><span class="line"><span class="keyword">FROM</span> orders</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> total <span class="keyword">DESC</span>;  <span class="comment">-- ORDER BY 可用别名</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- CASE 别名</span></span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">  <span class="keyword">CASE</span></span><br><span class="line">    <span class="keyword">WHEN</span> status <span class="operator">=</span> <span class="string">&#x27;paid&#x27;</span> <span class="keyword">THEN</span> <span class="string">&#x27;P&#x27;</span></span><br><span class="line">    <span class="keyword">ELSE</span> <span class="string">&#x27;U&#x27;</span></span><br><span class="line">  <span class="keyword">END</span> <span class="keyword">AS</span> pay_flag</span><br><span class="line"><span class="keyword">FROM</span> invoices;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- WHERE 不能用别名（错误示例）</span></span><br><span class="line"><span class="keyword">SELECT</span> price <span class="operator">*</span> quantity <span class="keyword">AS</span> total</span><br><span class="line"><span class="keyword">FROM</span> orders</span><br><span class="line"><span class="keyword">WHERE</span> total <span class="operator">&gt;</span> <span class="number">100</span>;  <span class="comment">-- ❌ 错误</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 正确做法：重复表达式或用子查询</span></span><br><span class="line"><span class="keyword">WHERE</span> price <span class="operator">*</span> quantity <span class="operator">&gt;</span> <span class="number">100</span>;  <span class="comment">-- ✅</span></span><br></pre></td></tr></table></figure><hr><h3 id="3-排序-ORDER-BY"><a href="#3-排序-ORDER-BY" class="headerlink" title="3. 排序 ORDER BY"></a>3. 排序 ORDER BY</h3><ul><li><code>ORDER BY</code>按指定列或表达式排序。多列时先按第一列排，相同再按第二列排。默认升序<code>ASC</code>，降序用<code>DESC</code>。可排别名、表达式、函数。可控制空值位置：<code>NULLS FIRST</code>&#x2F;<code>NULLS LAST</code>。不推荐用序号排序（如<code>ORDER BY 1</code>）。</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 单列排序</span></span><br><span class="line"><span class="keyword">SELECT</span> id, created_at <span class="keyword">FROM</span> posts</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> created_at <span class="keyword">DESC</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 控制NULL值位置</span></span><br><span class="line"><span class="keyword">SELECT</span> id, name <span class="keyword">FROM</span> users</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> name <span class="keyword">ASC</span> NULLS <span class="keyword">LAST</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 多列排序（先按total降序，相同则按id升序）</span></span><br><span class="line"><span class="keyword">SELECT</span> price <span class="operator">*</span> quantity <span class="keyword">AS</span> total, id</span><br><span class="line"><span class="keyword">FROM</span> orders</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> total <span class="keyword">DESC</span>, id <span class="keyword">ASC</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 表达式排序</span></span><br><span class="line"><span class="keyword">SELECT</span> name, age <span class="keyword">FROM</span> users</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> age <span class="operator">*</span> <span class="number">12</span> <span class="keyword">DESC</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 函数排序</span></span><br><span class="line"><span class="keyword">SELECT</span> email <span class="keyword">FROM</span> users</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="built_in">LOWER</span>(email);</span><br></pre></td></tr></table></figure><hr><h3 id="4-去重查询-DISTINCT"><a href="#4-去重查询-DISTINCT" class="headerlink" title="4. 去重查询 DISTINCT"></a>4. 去重查询 DISTINCT</h3><ul><li><code>SELECT DISTINCT</code>是<code>SQL</code>中的一种用法，用于从查询结果中去除重复的记录，仅返回唯一的结果行。它适用于希望从数据库表中获取不重复的值或组合的场景。</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查询所有不重复的城市</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> city <span class="keyword">FROM</span> customers;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询不重复的城市和州的组合</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> city, state <span class="keyword">FROM</span> customers;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 统计有多少个不同的城市</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> city) <span class="keyword">FROM</span> customers;</span><br></pre></td></tr></table></figure><ul><li><strong>性能考虑</strong>: <code>SELECT DISTINCT</code>需要对结果进行去重处理，这在大数据集上可能会影响查询性能。使用时应注意查询效率，特别是在处理大表时。</li><li><strong>多列去重</strong>: 当使用多列时，<code>DISTINCT</code>是对所有列的组合进行去重，而不是单独对每一列去重。</li></ul><hr><h3 id="5-分页查询"><a href="#5-分页查询" class="headerlink" title="5. 分页查询"></a>5. 分页查询</h3><ul><li>分页查询是数据库查询的一种技术，用于将查询结果分割成更小的部分（页），以方便数据的显示和管理，特别是在结果集非常大的情况下。分页能够提高应用的性能和用户体验，因为它可以减少一次性加载的数据量，并提供更快的响应时间。</li></ul><h4 id="OFFSET-x2F-LIMIT-分页"><a href="#OFFSET-x2F-LIMIT-分页" class="headerlink" title="OFFSET&#x2F;LIMIT 分页"></a>OFFSET&#x2F;LIMIT 分页</h4><ul><li>最常见的分页方式，适合小数据集。</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 基本语法</span></span><br><span class="line"><span class="keyword">SELECT</span> column1, column2, ...</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> column_name</span><br><span class="line">LIMIT page_size <span class="keyword">OFFSET</span> (page_number <span class="operator">-</span> <span class="number">1</span>) <span class="operator">*</span> page_size;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 示例：每页10条记录 (page_size = 10)</span></span><br><span class="line"><span class="comment">-- 第一页 (page_number = 1)</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees <span class="keyword">ORDER</span> <span class="keyword">BY</span> id LIMIT <span class="number">10</span> <span class="keyword">OFFSET</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 第二页 (page_number = 2)</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees <span class="keyword">ORDER</span> <span class="keyword">BY</span> id LIMIT <span class="number">10</span> <span class="keyword">OFFSET</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 第三页 (page_number = 3)</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees <span class="keyword">ORDER</span> <span class="keyword">BY</span> id LIMIT <span class="number">10</span> <span class="keyword">OFFSET</span> <span class="number">20</span>;</span><br></pre></td></tr></table></figure><ul><li><strong>计算公式</strong>: <code>OFFSET = (page_number - 1) * page_size</code></li><li><strong>优点</strong>: 实现简单，可以跳转到任意页</li><li><strong>缺点</strong>: OFFSET很大时性能差，数据库需要扫描所有跳过的记录 (一个简单的比喻就是你每次翻书都要从第一页翻到你之前看到的页数)</li></ul><h4 id="基于ID的分页"><a href="#基于ID的分页" class="headerlink" title="基于ID的分页"></a>基于ID的分页</h4><ul><li>基于上一页最后一条记录的ID继续查询，性能好。（得从 batch 中拿到下一次开始的 id）</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 第一页</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees </span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> id </span><br><span class="line">LIMIT <span class="number">10</span>;</span><br><span class="line"><span class="comment">-- 应用层记录 last_id = 最后一条记录的id</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 第二页（使用上一页的 last_id）</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees </span><br><span class="line"><span class="keyword">WHERE</span> id <span class="operator">&gt;</span> last_id </span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> id </span><br><span class="line">LIMIT <span class="number">10</span>;</span><br><span class="line"><span class="comment">-- 应用层更新 last_id</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 第三页（使用更新后的 last_id）</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees </span><br><span class="line"><span class="keyword">WHERE</span> id <span class="operator">&gt;</span> last_id </span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> id </span><br><span class="line">LIMIT <span class="number">10</span>;</span><br></pre></td></tr></table></figure><ul><li><strong>优点</strong>: 性能稳定，不受数据量影响</li><li><strong>缺点</strong>: 不能跳转到指定页，只能顺序翻页</li></ul><h4 id="Cursor-游标-分页"><a href="#Cursor-游标-分页" class="headerlink" title="Cursor (游标) 分页"></a>Cursor (游标) 分页</h4><ul><li>数据库提供的游标机制，常用于存储过程中。</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- PostgreSQL 示例</span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">DECLARE</span> my_cursor <span class="keyword">CURSOR</span> <span class="keyword">FOR</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees <span class="keyword">ORDER</span> <span class="keyword">BY</span> id;</span><br><span class="line"><span class="keyword">FETCH</span> <span class="number">10</span> <span class="keyword">FROM</span> my_cursor;  <span class="comment">-- 获取10条</span></span><br><span class="line"><span class="keyword">FETCH</span> <span class="number">10</span> <span class="keyword">FROM</span> my_cursor;  <span class="comment">-- 再获取10条</span></span><br><span class="line"><span class="keyword">CLOSE</span> my_cursor;</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure><ul><li><strong>优点</strong>: 数据库原生支持，可以暂停和恢复</li><li><strong>缺点</strong>: 需要保持连接，不适合无状态的Web应用</li></ul><p>注意事项</p><ul><li><strong>性能考虑</strong>: OFFSET&#x2F;LIMIT在大数据集上性能较差，推荐使用基于ID的分页。</li><li><strong>ORDER BY的重要性</strong>: 必须使用ORDER BY确保结果顺序一致，否则分页结果可能重复或遗漏。</li><li><strong>选择合适的方案</strong>:<ul><li>需要跳页功能 → OFFSET&#x2F;LIMIT</li><li>无限滚动&#x2F;顺序浏览 → 基于ID的分页</li><li>存储过程&#x2F;批处理 → Cursor游标</li></ul></li></ul><hr><h2 id="过滤数据"><a href="#过滤数据" class="headerlink" title="过滤数据"></a>过滤数据</h2><h3 id="6-WHERE"><a href="#6-WHERE" class="headerlink" title="6. WHERE"></a>6. WHERE</h3><ul><li><code>WHERE</code>子句是<code>SQL</code>中用于指定筛选条件的部分。它用于从数据库表中筛选出符合特定条件的行。<code>WHERE</code>子句可以用在<code>SELECT</code>、<code>UPDATE</code>、<code>DELETE</code>等<code>SQL</code>语句中，限制这些操作只应用于符合条件的行。</li><li>常见运算符<ul><li><strong>比较运算符</strong>: <code>=</code>, <code>&lt;&gt;</code> (不等于), <code>!=</code>, <code>&gt;</code>, <code>&lt;</code>, <code>&gt;=</code>, <code>&lt;=</code></li><li><strong>逻辑运算符</strong>: <code>AND</code>, <code>OR</code>, <code>NOT</code></li><li><strong>范围运算符</strong>: <code>BETWEEN ... AND ...</code></li><li><strong>集合运算符</strong>: <code>IN (value1, value2, ...)</code></li><li><strong>模糊匹配</strong>: <code>LIKE</code></li><li><strong>空值判断</strong>: <code>IS NULL</code>, <code>IS NOT NULL</code></li></ul></li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 比较运算符</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> salary <span class="operator">&gt;</span> <span class="number">50000</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> department <span class="operator">=</span> <span class="string">&#x27;IT&#x27;</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> age <span class="operator">&lt;&gt;</span> <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 逻辑运算符</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> salary <span class="operator">&gt;</span> <span class="number">50000</span> <span class="keyword">AND</span> department <span class="operator">=</span> <span class="string">&#x27;IT&#x27;</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> department <span class="operator">=</span> <span class="string">&#x27;IT&#x27;</span> <span class="keyword">OR</span> department <span class="operator">=</span> <span class="string">&#x27;HR&#x27;</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> <span class="keyword">NOT</span> department <span class="operator">=</span> <span class="string">&#x27;IT&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- BETWEEN</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> salary <span class="keyword">BETWEEN</span> <span class="number">40000</span> <span class="keyword">AND</span> <span class="number">60000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- IN</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> department <span class="keyword">IN</span> (<span class="string">&#x27;IT&#x27;</span>, <span class="string">&#x27;HR&#x27;</span>, <span class="string">&#x27;Finance&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- LIKE (模糊匹配)</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> name <span class="keyword">LIKE</span> <span class="string">&#x27;John%&#x27;</span>;  <span class="comment">-- 以John开头</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> name <span class="keyword">LIKE</span> <span class="string">&#x27;%son&#x27;</span>;   <span class="comment">-- 以son结尾</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> name <span class="keyword">LIKE</span> <span class="string">&#x27;%oh%&#x27;</span>;   <span class="comment">-- 包含oh</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- IS NULL</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> phone <span class="keyword">IS</span> <span class="keyword">NULL</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> phone <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>;</span><br></pre></td></tr></table></figure><ul><li><code>NULL</code>值不能用<code>=</code>或<code>&lt;&gt;</code>比较，必须使用<code>IS NULL</code>或<code>IS NOT NULL</code></li><li><code>LIKE</code>中<code>%</code>表示任意字符，<code>_</code>表示单个字符</li><li>多个条件组合时注意使用括号明确优先级</li></ul><hr><h3 id="7-LIMIT"><a href="#7-LIMIT" class="headerlink" title="7. LIMIT"></a>7. LIMIT</h3><ul><li><code>LIMIT</code>子句是<code>SQL</code>中的一部分，用于限制查询结果中返回的行数。它通常与<code>SELECT</code>语句一起使用，以控制从数据库中提取的行数。<code>LIMIT</code>子句对于分页、性能优化和控制数据输出量非常有用。</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 基本语法</span></span><br><span class="line"><span class="keyword">SELECT</span> column1, column2, ...</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> column_name</span><br><span class="line">LIMIT number_of_rows;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查询前5条记录</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees LIMIT <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询工资最高的前3名员工</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> salary <span class="keyword">DESC</span></span><br><span class="line">LIMIT <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 结合OFFSET实现分页</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> id</span><br><span class="line">LIMIT <span class="number">10</span> <span class="keyword">OFFSET</span> <span class="number">20</span>;  <span class="comment">-- 跳过前20条，返回第21-30条</span></span><br></pre></td></tr></table></figure><ul><li><code>LIMIT</code>通常与<code>ORDER BY</code>一起使用，确保结果顺序一致</li><li>不同数据库语法略有差异：<ul><li>MySQL&#x2F;PostgreSQL: <code>LIMIT n OFFSET m</code></li><li>SQL Server: <code>TOP n</code> 或 <code>OFFSET m ROWS FETCH NEXT n ROWS ONLY</code></li><li>Oracle: <code>ROWNUM</code> 或 <code>FETCH FIRST n ROWS ONLY</code></li></ul></li></ul><hr><h3 id="8-OFFSET-x2F-FETCH"><a href="#8-OFFSET-x2F-FETCH" class="headerlink" title="8. OFFSET&#x2F;FETCH"></a>8. OFFSET&#x2F;FETCH</h3><ul><li><code>FETCH</code>子句是<code>SQL</code>中的一部分，用于从查询结果中返回特定数量的行。它通常与<code>OFFSET</code>子句一起使用，以实现更加灵活和清晰的分页操作。在不同的数据库系统中，<code>FETCH</code>子句的支持和语法可能略有不同。</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 基本语法</span></span><br><span class="line"><span class="keyword">SELECT</span> column1, column2, ...</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> column_name</span><br><span class="line"><span class="keyword">OFFSET</span> number_of_rows <span class="keyword">ROWS</span></span><br><span class="line"><span class="keyword">FETCH</span> &#123;<span class="keyword">FIRST</span> <span class="operator">|</span> NEXT&#125; number_of_rows &#123;<span class="type">ROW</span> <span class="operator">|</span> <span class="keyword">ROWS</span>&#125; <span class="keyword">ONLY</span>;</span><br></pre></td></tr></table></figure><ul><li><code>FIRST</code>: 表示从结果集的开头返回行数</li><li><code>NEXT</code>: 表示从当前偏移量位置继续返回行数</li><li><code>ROW / ROWS</code>: 用于指定返回行的单数或复数形式，两者在功能上没有差别</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 获取前10条记录</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> id</span><br><span class="line"><span class="keyword">FETCH</span> <span class="keyword">FIRST</span> <span class="number">10</span> <span class="keyword">ROWS</span> <span class="keyword">ONLY</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 跳过前20条，获取接下来的10条</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> id</span><br><span class="line"><span class="keyword">OFFSET</span> <span class="number">20</span> <span class="keyword">ROWS</span></span><br><span class="line"><span class="keyword">FETCH</span> NEXT <span class="number">10</span> <span class="keyword">ROWS</span> <span class="keyword">ONLY</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 获取工资最高的前5名员工</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> salary <span class="keyword">DESC</span></span><br><span class="line"><span class="keyword">FETCH</span> <span class="keyword">FIRST</span> <span class="number">5</span> <span class="keyword">ROWS</span> <span class="keyword">ONLY</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 分页示例：第3页，每页10条</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> id</span><br><span class="line"><span class="keyword">OFFSET</span> <span class="number">20</span> <span class="keyword">ROWS</span></span><br><span class="line"><span class="keyword">FETCH</span> NEXT <span class="number">10</span> <span class="keyword">ROWS</span> <span class="keyword">ONLY</span>;</span><br></pre></td></tr></table></figure><ul><li>使用<code>FETCH</code>时必须有<code>ORDER BY</code>子句</li><li><code>OFFSET</code>和<code>FETCH</code>提供了更清晰的语义表达</li><li>不同数据库支持情况：<ul><li>PostgreSQL: 支持<code>FETCH</code>和<code>LIMIT</code></li><li>SQL Server: 仅支持<code>FETCH</code></li><li>MySQL: 仅支持<code>LIMIT</code></li></ul></li></ul><hr><h3 id="9-IN"><a href="#9-IN" class="headerlink" title="9. IN"></a>9. IN</h3><ul><li><code>IN</code>运算符是<code>SQL</code>中用于指定多个可能值的一种条件操作符。它通常用于<code>WHERE</code>子句中，用来过滤那些列值在指定集合中的行。<code>IN</code>运算符允许你简洁地测试某个列的值是否匹配一组值中的任何一个，而无需使用多个<code>OR</code>条件。</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 基本语法</span></span><br><span class="line"><span class="keyword">SELECT</span> column1, column2, ...</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> column_name <span class="keyword">IN</span> (value1, value2, ...);</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查询特定部门的员工</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> department <span class="keyword">IN</span> (<span class="string">&#x27;IT&#x27;</span>, <span class="string">&#x27;HR&#x27;</span>, <span class="string">&#x27;Finance&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 等价于使用多个OR</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> department <span class="operator">=</span> <span class="string">&#x27;IT&#x27;</span> <span class="keyword">OR</span> department <span class="operator">=</span> <span class="string">&#x27;HR&#x27;</span> <span class="keyword">OR</span> department <span class="operator">=</span> <span class="string">&#x27;Finance&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询特定ID的员工</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> id <span class="keyword">IN</span> (<span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- NOT IN: 排除特定部门</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> department <span class="keyword">NOT</span> <span class="keyword">IN</span> (<span class="string">&#x27;HR&#x27;</span>, <span class="string">&#x27;Engineering&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 子查询配合IN</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> department_id <span class="keyword">IN</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> id <span class="keyword">FROM</span> departments <span class="keyword">WHERE</span> location <span class="operator">=</span> <span class="string">&#x27;New York&#x27;</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><ul><li><code>IN</code>比多个<code>OR</code>条件更简洁易读</li><li><code>NOT IN</code>在遇到<code>NULL</code>值时要小心，可能得到意外结果</li><li><code>IN</code>可以配合子查询使用</li><li>列表值过多时可能影响性能，考虑使用<code>JOIN</code>或临时表</li></ul><hr><h3 id="10-BETWEEN"><a href="#10-BETWEEN" class="headerlink" title="10. BETWEEN"></a>10. BETWEEN</h3><ul><li><code>BETWEEN</code>运算符是<code>SQL</code>中用于筛选范围内的值的一种条件操作符。它通常用于<code>WHERE</code>子句中，以测试某个列的值是否在指定的上下限之间。<code>BETWEEN</code>运算符包括指定的边界值（即包含上下限），它可以用于数字、日期、时间等类型的数据。</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 基本语法</span></span><br><span class="line"><span class="keyword">SELECT</span> column1, column2, ...</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> column_name <span class="keyword">BETWEEN</span> value1 <span class="keyword">AND</span> value2;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 数值范围</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> salary <span class="keyword">BETWEEN</span> <span class="number">30000</span> <span class="keyword">AND</span> <span class="number">60000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 等价于</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> salary <span class="operator">&gt;=</span> <span class="number">30000</span> <span class="keyword">AND</span> salary <span class="operator">&lt;=</span> <span class="number">60000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 日期范围</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> orders</span><br><span class="line"><span class="keyword">WHERE</span> order_date <span class="keyword">BETWEEN</span> <span class="string">&#x27;2023-01-01&#x27;</span> <span class="keyword">AND</span> <span class="string">&#x27;2023-12-31&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 字母范围</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> name <span class="keyword">BETWEEN</span> <span class="string">&#x27;A&#x27;</span> <span class="keyword">AND</span> <span class="string">&#x27;M&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- NOT BETWEEN</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> salary <span class="keyword">NOT</span> <span class="keyword">BETWEEN</span> <span class="number">30000</span> <span class="keyword">AND</span> <span class="number">60000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 等价于</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> salary <span class="operator">&lt;</span> <span class="number">30000</span> <span class="keyword">OR</span> salary <span class="operator">&gt;</span> <span class="number">60000</span>;</span><br></pre></td></tr></table></figure><ul><li><code>BETWEEN</code>是<strong>包含边界值</strong>的（闭区间）</li><li><code>BETWEEN value1 AND value2</code>等价于<code>&gt;= value1 AND &lt;= value2</code></li><li><code>value1</code>必须小于或等于<code>value2</code>，否则结果为空</li><li>日期范围查询时注意时间部分，可能需要使用<code>&lt;</code>而不是<code>BETWEEN</code>来避免边界问题</li><li>可以使用<code>NOT BETWEEN</code>排除范围内的值</li></ul><hr><h3 id="11-LIKE"><a href="#11-LIKE" class="headerlink" title="11. LIKE"></a>11. LIKE</h3><ul><li><code>LIKE</code>运算符是<code>SQL</code>中用于进行模式匹配的运算符。它通常用于<code>WHERE</code>子句中，以根据指定的模式筛选出符合条件的行。<code>LIKE</code>运算符可以匹配字符串中的部分内容，因此特别适合用于查找类似的字符串数据。</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 基本语法</span></span><br><span class="line"><span class="keyword">SELECT</span> column1, column2, ...</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> column_name <span class="keyword">LIKE</span> <span class="keyword">pattern</span>;</span><br></pre></td></tr></table></figure><ul><li><strong>百分号 <code>%</code></strong>: 匹配任意数量的字符，包括零个字符</li><li><strong>下划线 <code>_</code></strong>: 匹配单个字符</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查询名字以&quot;A&quot;开头的员工</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> name <span class="keyword">LIKE</span> <span class="string">&#x27;A%&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询名字以&quot;son&quot;结尾的员工</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> name <span class="keyword">LIKE</span> <span class="string">&#x27;%son&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询名字中包含&quot;li&quot;的员工</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> name <span class="keyword">LIKE</span> <span class="string">&#x27;%li%&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询名字第二个字母是&quot;a&quot;的员工</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> name <span class="keyword">LIKE</span> <span class="string">&#x27;_a%&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询名字正好是4个字符的员工</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> name <span class="keyword">LIKE</span> <span class="string">&#x27;____&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- NOT LIKE: 排除匹配</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> name <span class="keyword">NOT</span> <span class="keyword">LIKE</span> <span class="string">&#x27;A%&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 转义特殊字符</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> name <span class="keyword">LIKE</span> <span class="string">&#x27;%\_%&#x27;</span> <span class="keyword">ESCAPE</span> <span class="string">&#x27;\&#x27;</span>;  <span class="comment">-- 查找包含下划线的产品名</span></span><br></pre></td></tr></table></figure><ul><li><code>LIKE</code>是<strong>区分大小写</strong>的（取决于数据库和字符集设置）</li><li>使用<code>%</code>在开头会导致无法使用索引，影响性能</li><li>如果需要匹配<code>%</code>或<code>_</code>字符本身，需要使用转义符</li><li>对于复杂的模式匹配，可以考虑使用正则表达式（如PostgreSQL的<code>~</code>运算符）</li><li><code>ILIKE</code>（PostgreSQL）可以实现不区分大小写的匹配</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- ILIKE: 不区分大小写的匹配（PostgreSQL特有）</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> name ILIKE <span class="string">&#x27;john%&#x27;</span>;  <span class="comment">-- 可以匹配 &#x27;John&#x27;, &#x27;JOHN&#x27;, &#x27;john&#x27;, &#x27;JoHn&#x27; 等</span></span><br></pre></td></tr></table></figure><hr><h3 id="12-NULL-和-IS-NULL"><a href="#12-NULL-和-IS-NULL" class="headerlink" title="12. NULL 和 IS NULL"></a>12. NULL 和 IS NULL</h3><ul><li><p><code>NULL</code>是<code>SQL</code>中用于表示数据的缺失或未知值的特殊标识符。它不同于零、空字符串或任何其他值，因为它表示没有数据或数据不可用。由于<code>NULL</code>代表未知值，因此它在逻辑运算和比较中有特殊的处理方式。</p></li><li><p><strong>没有特定类型</strong>: <code>NULL</code>可以出现在任何数据类型的列中</p></li><li><p><strong>不可比较</strong>: <code>NULL</code>不等于任何值，包括它自己。因此，<code>NULL = NULL</code>的表达式结果为<code>FALSE</code>。正确的做法是使用<code>IS NULL</code>来检查<code>NULL</code>值</p></li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 检查NULL值</span></span><br><span class="line"><span class="keyword">SELECT</span> column1, column2, ...</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> column_name <span class="keyword">IS</span> <span class="keyword">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 检查非NULL值</span></span><br><span class="line"><span class="keyword">SELECT</span> column1, column2, ...</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> column_name <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查询没有电话号码的员工</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> phone <span class="keyword">IS</span> <span class="keyword">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询有电话号码的员工</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> phone <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 错误写法（永远不会返回结果）</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> phone <span class="operator">=</span> <span class="keyword">NULL</span>;  <span class="comment">-- ❌ 错误</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 正确写法</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> phone <span class="keyword">IS</span> <span class="keyword">NULL</span>;  <span class="comment">-- ✅ 正确</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- NULL在计算中的表现</span></span><br><span class="line"><span class="keyword">SELECT</span> salary <span class="operator">+</span> bonus <span class="keyword">FROM</span> employees;  <span class="comment">-- 如果bonus是NULL，结果也是NULL</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 使用COALESCE处理NULL</span></span><br><span class="line"><span class="keyword">SELECT</span> name, <span class="built_in">COALESCE</span>(phone, <span class="string">&#x27;No Phone&#x27;</span>) <span class="keyword">FROM</span> employees;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 使用IFNULL/ISNULL处理NULL（不同数据库语法不同）</span></span><br><span class="line"><span class="keyword">SELECT</span> name, IFNULL(phone, <span class="string">&#x27;No Phone&#x27;</span>) <span class="keyword">FROM</span> employees;  <span class="comment">-- MySQL</span></span><br><span class="line"><span class="keyword">SELECT</span> name, ISNULL(phone, <span class="string">&#x27;No Phone&#x27;</span>) <span class="keyword">FROM</span> employees;  <span class="comment">-- SQL Server</span></span><br></pre></td></tr></table></figure><ul><li><strong>不能使用 <code>=</code> 或 <code>!=</code> 比较NULL</strong>, 必须使用<code>IS NULL</code>或<code>IS NOT NULL</code></li><li><strong>NULL在逻辑运算中</strong><ul><li><code>NULL AND TRUE = NULL</code></li><li><code>NULL OR FALSE = NULL</code></li><li><code>NOT NULL = NULL</code></li></ul></li><li><strong>NULL在聚合函数中</strong>: 大多数聚合函数（如<code>COUNT</code>, <code>SUM</code>, <code>AVG</code>）会忽略<code>NULL</code>值</li><li><strong>NULL在排序中</strong>: <code>ORDER BY</code>时，<code>NULL</code>值通常排在最前面或最后面（取决于数据库）</li></ul><hr><h2 id="连接多个表"><a href="#连接多个表" class="headerlink" title="连接多个表"></a>连接多个表</h2><h3 id="13-表别名"><a href="#13-表别名" class="headerlink" title="13. 表别名"></a>13. 表别名</h3><ul><li>表别名<code>Table Alias</code>是<code>SQL</code>中用于为表指定临时名称的功能。表别名通常用于简化查询语句，特别是在多表联接<code>JOIN</code>或子查询中，使得查询更加简洁和易读。表别名仅在查询的上下文中有效，不会影响数据库中表的实际名称。</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 基本语法</span></span><br><span class="line"><span class="keyword">SELECT</span> column1, column2, ...</span><br><span class="line"><span class="keyword">FROM</span> table_name <span class="keyword">AS</span> alias_name</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">condition</span>;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 使用AS关键字</span></span><br><span class="line"><span class="keyword">SELECT</span> e.name, e.salary</span><br><span class="line"><span class="keyword">FROM</span> employees <span class="keyword">AS</span> e</span><br><span class="line"><span class="keyword">WHERE</span> e.salary <span class="operator">&gt;</span> <span class="number">50000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 省略AS关键字</span></span><br><span class="line"><span class="keyword">SELECT</span> e.name, e.salary</span><br><span class="line"><span class="keyword">FROM</span> employees e</span><br><span class="line"><span class="keyword">WHERE</span> e.salary <span class="operator">&gt;</span> <span class="number">50000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 多表联接中使用别名</span></span><br><span class="line"><span class="keyword">SELECT</span> e.name, d.department_name</span><br><span class="line"><span class="keyword">FROM</span> employees <span class="keyword">AS</span> e</span><br><span class="line"><span class="keyword">JOIN</span> departments <span class="keyword">AS</span> d <span class="keyword">ON</span> e.department_id <span class="operator">=</span> d.id;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 自联接中使用别名（必须使用）</span></span><br><span class="line"><span class="keyword">SELECT</span> e1.name <span class="keyword">AS</span> employee, e2.name <span class="keyword">AS</span> manager</span><br><span class="line"><span class="keyword">FROM</span> employees e1</span><br><span class="line"><span class="keyword">JOIN</span> employees e2 <span class="keyword">ON</span> e1.manager_id <span class="operator">=</span> e2.id;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 子查询中使用别名</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> name, salary <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> salary <span class="operator">&gt;</span> <span class="number">50000</span></span><br><span class="line">) <span class="keyword">AS</span> high_earners;</span><br></pre></td></tr></table></figure><ul><li>表别名在<code>SELECT</code>、<code>WHERE</code>、<code>JOIN</code>等子句中都可以使用</li><li>自联接（同一张表联接自己）时<strong>必须</strong>使用别名</li><li>使用别名可以提高查询可读性，特别是在复杂查询中</li><li>别名只在当前查询中有效，不会改变数据库中的表名</li><li>推荐使用有意义的别名，如<code>e</code>代表<code>employees</code>，<code>d</code>代表<code>departments</code></li></ul><hr><h3 id="14-INNER-JOIN"><a href="#14-INNER-JOIN" class="headerlink" title="14. INNER JOIN"></a>14. INNER JOIN</h3><ul><li><code>INNER JOIN</code>内连接是<code>SQL</code>中的一种联接操作，用于从多个表中查询相关联的数据。<code>INNER JOIN</code>只返回两个表中满足联接条件的行，也就是说，它只返回在两个表中都有匹配关系的记录。如果其中一个表没有匹配的记录，结果中不会包含该行。</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 基本语法</span></span><br><span class="line"><span class="keyword">SELECT</span> column1, column2, ...</span><br><span class="line"><span class="keyword">FROM</span> table1</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> table2</span><br><span class="line"><span class="keyword">ON</span> table1.common_column <span class="operator">=</span> table2.common_column;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- employees</span></span><br><span class="line"><span class="comment">-- | id | name    | department_id |</span></span><br><span class="line"><span class="comment">-- |----|---------|---------------|</span></span><br><span class="line"><span class="comment">-- | 1  | Alice   | 1             |</span></span><br><span class="line"><span class="comment">-- | 2  | Bob     | 2             |</span></span><br><span class="line"><span class="comment">-- | 3  | Charlie | NULL          |</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- departments</span></span><br><span class="line"><span class="comment">-- | id | department_name |</span></span><br><span class="line"><span class="comment">-- |----|-----------------| </span></span><br><span class="line"><span class="comment">-- | 1  | HR              |</span></span><br><span class="line"><span class="comment">-- | 2  | Engineering     |</span></span><br><span class="line"><span class="comment">-- | 3  | Marketing       |</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> e.name, d.department_name</span><br><span class="line"><span class="keyword">FROM</span> employees e</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> departments d <span class="keyword">ON</span> e.department_id <span class="operator">=</span> d.id;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询结果</span></span><br><span class="line"><span class="comment">-- | name  | department_name |</span></span><br><span class="line"><span class="comment">-- |-------|-----------------|</span></span><br><span class="line"><span class="comment">-- | Alice | HR              |</span></span><br><span class="line"><span class="comment">-- | Bob   | Engineering     |</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>注意</strong>: Charlie 没有出现在结果中，因为他的 <code>department_id</code> 是 <code>NULL</code>，在 <code>departments</code> 表中没有匹配的记录。同样，Marketing 部门也没有出现，因为没有员工属于该部门。</p></blockquote><ul><li><code>INNER JOIN</code> 可以简写为 <code>JOIN</code>（效果相同）</li><li>只返回两个表中都有匹配的记录</li><li><code>NULL</code> 值不会被匹配</li><li>使用表别名可以简化查询</li><li>可以连接多个表，使用多个 <code>INNER JOIN</code></li></ul><hr><h3 id="15-LEFT-JOIN"><a href="#15-LEFT-JOIN" class="headerlink" title="15. LEFT JOIN"></a>15. LEFT JOIN</h3><ul><li><code>LEFT JOIN</code>左连接是<code>SQL</code>中的一种联接操作，用于从两个表中查询相关的数据。与<code>INNER JOIN</code>不同，<code>LEFT JOIN</code>会返回左表中的所有记录，即使右表中没有匹配的记录。对于那些在右表中没有匹配的记录，结果集中相应右表的字段会显示为<code>NULL</code>。</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 基本语法</span></span><br><span class="line"><span class="keyword">SELECT</span> column1, column2, ...</span><br><span class="line"><span class="keyword">FROM</span> table1</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> table2</span><br><span class="line"><span class="keyword">ON</span> table1.common_column <span class="operator">=</span> table2.common_column;</span><br></pre></td></tr></table></figure><ul><li><strong>所有左表的行</strong>: 即使左表中的某一行在右表中没有匹配记录，该行也会包含在结果集中</li><li><strong>右表的匹配行</strong>: 如果有匹配的右表记录，这些记录会出现在结果集中</li><li><strong>NULL值</strong>: 对于在右表中没有匹配的左表记录，结果集中右表的列会显示为<code>NULL</code></li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- employees</span></span><br><span class="line"><span class="comment">-- | id | name    | department_id |</span></span><br><span class="line"><span class="comment">-- |----|---------|---------------|</span></span><br><span class="line"><span class="comment">-- | 1  | Alice   | 1             |</span></span><br><span class="line"><span class="comment">-- | 2  | Bob     | 2             |</span></span><br><span class="line"><span class="comment">-- | 3  | Charlie | NULL          |</span></span><br><span class="line"><span class="comment">-- | 4  | David   | 3             |</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- departments</span></span><br><span class="line"><span class="comment">-- | id | department_name |</span></span><br><span class="line"><span class="comment">-- |----|-----------------| </span></span><br><span class="line"><span class="comment">-- | 1  | HR              |</span></span><br><span class="line"><span class="comment">-- | 2  | Engineering     |</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> e.name, d.department_name</span><br><span class="line"><span class="keyword">FROM</span> employees e</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> departments d <span class="keyword">ON</span> e.department_id <span class="operator">=</span> d.id;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询结果</span></span><br><span class="line"><span class="comment">-- | name    | department_name |</span></span><br><span class="line"><span class="comment">-- |---------|-----------------|</span></span><br><span class="line"><span class="comment">-- | Alice   | HR              |</span></span><br><span class="line"><span class="comment">-- | Bob     | Engineering     |</span></span><br><span class="line"><span class="comment">-- | Charlie | NULL            |</span></span><br><span class="line"><span class="comment">-- | David   | NULL            |</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>注意</strong>: 所有员工都出现在结果中。Charlie 的 <code>department_id</code> 是 <code>NULL</code>，David 的 <code>department_id</code> 是 3 但在 <code>departments</code> 表中不存在，所以他们的 <code>department_name</code> 都显示为 <code>NULL</code>。</p></blockquote><ul><li><code>LEFT JOIN</code> 也可以写作 <code>LEFT OUTER JOIN</code>（效果相同）</li><li>返回左表的所有记录，右表没有匹配时显示 <code>NULL</code></li><li>常用于查找”孤立”记录（例如：没有部门的员工）</li><li>可以通过 <code>WHERE right_table.column IS NULL</code> 来筛选只在左表存在的记录</li></ul><hr><h3 id="16-SELF-JOIN"><a href="#16-SELF-JOIN" class="headerlink" title="16. SELF JOIN"></a>16. SELF JOIN</h3><ul><li><p>自连接<code>Self Join</code>是<code>SQL</code>中的一种联接操作，其中一个表与自身进行联接。自连接用于将表中的一行与同一表中的另一行进行比较或关联。这在处理表中行与行之间的关系时非常有用，例如层次结构（如员工与经理的关系）或相邻行之间的比较。</p></li><li><p><strong>同一张表</strong>: 自连接涉及的表实际上是同一张表，只是在查询中使用了不同的别名，使得它们在逻辑上看起来像是两个不同的表</p></li><li><p><strong>表别名</strong>: 为了区分表的不同实例，通常使用表别名。这样可以在同一个查询中引用表中的不同行</p></li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 基本语法</span></span><br><span class="line"><span class="keyword">SELECT</span> a.column1, b.column2, ...</span><br><span class="line"><span class="keyword">FROM</span> table_name a</span><br><span class="line"><span class="keyword">JOIN</span> table_name b</span><br><span class="line"><span class="keyword">ON</span> a.common_column <span class="operator">=</span> b.common_column;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- employees</span></span><br><span class="line"><span class="comment">-- | id | name    | manager_id |</span></span><br><span class="line"><span class="comment">-- |----|---------|------------|</span></span><br><span class="line"><span class="comment">-- | 1  | Alice   | NULL       |</span></span><br><span class="line"><span class="comment">-- | 2  | Bob     | 1          |</span></span><br><span class="line"><span class="comment">-- | 3  | Charlie | 1          |</span></span><br><span class="line"><span class="comment">-- | 4  | David   | 2          |</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> e.name <span class="keyword">AS</span> employee_name, m.name <span class="keyword">AS</span> manager_name</span><br><span class="line"><span class="keyword">FROM</span> employees e</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> employees m <span class="keyword">ON</span> e.manager_id <span class="operator">=</span> m.id;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询结果</span></span><br><span class="line"><span class="comment">-- | employee_name | manager_name |</span></span><br><span class="line"><span class="comment">-- |---------------|--------------|</span></span><br><span class="line"><span class="comment">-- | Alice         | NULL         |</span></span><br><span class="line"><span class="comment">-- | Bob           | Alice        |</span></span><br><span class="line"><span class="comment">-- | Charlie       | Alice        |</span></span><br><span class="line"><span class="comment">-- | David         | Bob          |</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>注意</strong>: Alice 是最高层级的员工，没有经理，所以 <code>manager_name</code> 显示为 <code>NULL</code>。其他员工都能找到对应的经理。</p></blockquote><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查找同一部门的员工对</span></span><br><span class="line"><span class="keyword">SELECT</span> e1.name <span class="keyword">AS</span> employee1, e2.name <span class="keyword">AS</span> employee2</span><br><span class="line"><span class="keyword">FROM</span> employees e1</span><br><span class="line"><span class="keyword">JOIN</span> employees e2 <span class="keyword">ON</span> e1.department_id <span class="operator">=</span> e2.department_id</span><br><span class="line"><span class="keyword">WHERE</span> e1.id <span class="operator">&lt;</span> e2.id;  <span class="comment">-- 避免重复和自己匹配自己</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查找没有下属的员工</span></span><br><span class="line"><span class="keyword">SELECT</span> e.name</span><br><span class="line"><span class="keyword">FROM</span> employees e</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> employees m <span class="keyword">ON</span> e.id <span class="operator">=</span> m.manager_id</span><br><span class="line"><span class="keyword">WHERE</span> m.id <span class="keyword">IS</span> <span class="keyword">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查找工资比某个特定员工高的所有员工</span></span><br><span class="line"><span class="keyword">SELECT</span> e2.name, e2.salary</span><br><span class="line"><span class="keyword">FROM</span> employees e1</span><br><span class="line"><span class="keyword">JOIN</span> employees e2 <span class="keyword">ON</span> e2.salary <span class="operator">&gt;</span> e1.salary</span><br><span class="line"><span class="keyword">WHERE</span> e1.name <span class="operator">=</span> <span class="string">&#x27;Alice&#x27;</span>;</span><br></pre></td></tr></table></figure><ul><li>自连接<strong>必须</strong>使用表别名来区分同一表的不同实例</li><li>通常使用 <code>LEFT JOIN</code> 来包含没有匹配的行（如没有经理的员工）</li><li>注意避免笛卡尔积，确保有正确的 <code>ON</code> 条件</li><li>自连接可能影响性能，大表需要注意优化</li></ul><hr><h3 id="17-FULL-OUTER-JOIN"><a href="#17-FULL-OUTER-JOIN" class="headerlink" title="17. FULL OUTER JOIN"></a>17. FULL OUTER JOIN</h3><ul><li><code>FULL OUTER JOIN</code>全外连接是<code>SQL</code>中的一种联接操作，它返回两个表中所有符合联接条件的记录，以及不符合联接条件的记录。与<code>INNER JOIN</code>只返回两个表中有匹配记录的行不同</li><li><code>FULL OUTER JOIN</code>会返回两个表中的所有记录，如果在某一表中没有匹配的记录，则该表的列会返回<code>NULL</code></li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 基本语法</span></span><br><span class="line"><span class="keyword">SELECT</span> column1, column2, ...</span><br><span class="line"><span class="keyword">FROM</span> table1</span><br><span class="line"><span class="keyword">FULL</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> table2</span><br><span class="line"><span class="keyword">ON</span> table1.common_column <span class="operator">=</span> table2.common_column;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- employees</span></span><br><span class="line"><span class="comment">-- | id | name    | department_id |</span></span><br><span class="line"><span class="comment">-- |----|---------|---------------|</span></span><br><span class="line"><span class="comment">-- | 1  | Alice   | 1             |</span></span><br><span class="line"><span class="comment">-- | 2  | Bob     | 2             |</span></span><br><span class="line"><span class="comment">-- | 3  | Charlie | NULL          |</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- departments</span></span><br><span class="line"><span class="comment">-- | id | department_name |</span></span><br><span class="line"><span class="comment">-- |----|-----------------| </span></span><br><span class="line"><span class="comment">-- | 1  | HR              |</span></span><br><span class="line"><span class="comment">-- | 2  | Engineering     |</span></span><br><span class="line"><span class="comment">-- | 3  | Marketing       |</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> e.name, d.department_name</span><br><span class="line"><span class="keyword">FROM</span> employees e</span><br><span class="line"><span class="keyword">FULL</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> departments d <span class="keyword">ON</span> e.department_id <span class="operator">=</span> d.id;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询结果</span></span><br><span class="line"><span class="comment">-- | name    | department_name |</span></span><br><span class="line"><span class="comment">-- |---------|-----------------|</span></span><br><span class="line"><span class="comment">-- | Alice   | HR              |</span></span><br><span class="line"><span class="comment">-- | Bob     | Engineering     |</span></span><br><span class="line"><span class="comment">-- | Charlie | NULL            |</span></span><br><span class="line"><span class="comment">-- | NULL    | Marketing       |</span></span><br></pre></td></tr></table></figure><blockquote><p>Charlie 出现在结果中，但 <code>department_name</code> 为 <code>NULL</code>，因为他没有分配部门<br>Marketing 部门也出现在结果中，但 <code>name</code> 为 <code>NULL</code>，因为该部门没有员工<br><code>FULL OUTER JOIN</code> 结合了 <code>LEFT JOIN</code> 和 <code>RIGHT JOIN</code> 的效果</p></blockquote><ul><li><code>FULL OUTER JOIN</code> 也可以简写为 <code>FULL JOIN</code>（效果相同）</li><li>返回两个表中的所有记录，无匹配时显示 <code>NULL</code></li><li>MySQL <strong>不支持</strong> <code>FULL OUTER JOIN</code>，需要用 <code>UNION</code> 组合 <code>LEFT JOIN</code> 和 <code>RIGHT JOIN</code> 实现</li><li>PostgreSQL、SQL Server、Oracle 支持 <code>FULL OUTER JOIN</code></li><li>常用于查找两个表中不匹配的记录</li></ul><hr><h3 id="18-CROSS-JOIN"><a href="#18-CROSS-JOIN" class="headerlink" title="18. CROSS JOIN"></a>18. CROSS JOIN</h3><ul><li><code>CROSS JOIN</code>交叉连接是<code>SQL</code>中的一种联接操作，它返回两个表中所有可能的行组合，生成笛卡尔积<code>Cartesian Product</code>。<code>CROSS JOIN</code>不使用任何联接条件，因此会将左表的每一行与右表的每一行组合在一起。</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 基本语法</span></span><br><span class="line"><span class="keyword">SELECT</span> column1, column2, ...</span><br><span class="line"><span class="keyword">FROM</span> table1</span><br><span class="line"><span class="keyword">CROSS</span> <span class="keyword">JOIN</span> table2;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- products</span></span><br><span class="line"><span class="comment">-- | id | product_name |</span></span><br><span class="line"><span class="comment">-- |----|--------------|</span></span><br><span class="line"><span class="comment">-- | 1  | Shirt        |</span></span><br><span class="line"><span class="comment">-- | 2  | Pants        |</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- colors</span></span><br><span class="line"><span class="comment">-- | id | color_name |</span></span><br><span class="line"><span class="comment">-- |----|------------| </span></span><br><span class="line"><span class="comment">-- | 1  | Red        |</span></span><br><span class="line"><span class="comment">-- | 2  | Blue       |</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> p.product_name, c.color_name</span><br><span class="line"><span class="keyword">FROM</span> products p</span><br><span class="line"><span class="keyword">CROSS</span> <span class="keyword">JOIN</span> colors c;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询结果</span></span><br><span class="line"><span class="comment">-- | product_name | color_name |</span></span><br><span class="line"><span class="comment">-- |--------------|------------|</span></span><br><span class="line"><span class="comment">-- | Shirt        | Red        |</span></span><br><span class="line"><span class="comment">-- | Shirt        | Blue       |</span></span><br><span class="line"><span class="comment">-- | Pants        | Red        |</span></span><br><span class="line"><span class="comment">-- | Pants        | Blue       |</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>注意</strong>: 结果集的行数 &#x3D; 左表行数 × 右表行数。在这个例子中，2 × 2 &#x3D; 4 行。</p></blockquote><h4 id="替代写法"><a href="#替代写法" class="headerlink" title="替代写法"></a>替代写法</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 使用逗号（隐式CROSS JOIN）</span></span><br><span class="line"><span class="keyword">SELECT</span> p.product_name, c.color_name</span><br><span class="line"><span class="keyword">FROM</span> products p, colors c;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 等价于</span></span><br><span class="line"><span class="keyword">SELECT</span> p.product_name, c.color_name</span><br><span class="line"><span class="keyword">FROM</span> products p</span><br><span class="line"><span class="keyword">CROSS</span> <span class="keyword">JOIN</span> colors c;</span><br></pre></td></tr></table></figure><h4 id="常见应用场景"><a href="#常见应用场景" class="headerlink" title="常见应用场景"></a>常见应用场景</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 生成所有尺寸和颜色的组合</span></span><br><span class="line"><span class="keyword">SELECT</span> s.size, c.color</span><br><span class="line"><span class="keyword">FROM</span> sizes s</span><br><span class="line"><span class="keyword">CROSS</span> <span class="keyword">JOIN</span> colors c;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 生成日期和员工的所有组合（用于考勤表）</span></span><br><span class="line"><span class="keyword">SELECT</span> e.name, d.date</span><br><span class="line"><span class="keyword">FROM</span> employees e</span><br><span class="line"><span class="keyword">CROSS</span> <span class="keyword">JOIN</span> dates d;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 生成测试数据</span></span><br><span class="line"><span class="keyword">SELECT</span> n1.num <span class="operator">*</span> <span class="number">10</span> <span class="operator">+</span> n2.num <span class="keyword">AS</span> number</span><br><span class="line"><span class="keyword">FROM</span> (<span class="keyword">SELECT</span> <span class="number">0</span> <span class="keyword">AS</span> num <span class="keyword">UNION</span> <span class="keyword">SELECT</span> <span class="number">1</span> <span class="keyword">UNION</span> <span class="keyword">SELECT</span> <span class="number">2</span>) n1</span><br><span class="line"><span class="keyword">CROSS</span> <span class="keyword">JOIN</span> (<span class="keyword">SELECT</span> <span class="number">0</span> <span class="keyword">AS</span> num <span class="keyword">UNION</span> <span class="keyword">SELECT</span> <span class="number">1</span> <span class="keyword">UNION</span> <span class="keyword">SELECT</span> <span class="number">2</span>) n2;</span><br></pre></td></tr></table></figure><ul><li><code>CROSS JOIN</code> 生成笛卡尔积，结果集可能非常大</li><li>没有 <code>ON</code> 条件，返回所有可能的组合</li><li>通常用于生成组合数据或测试数据</li><li>大表使用 <code>CROSS JOIN</code> 会严重影响性能</li><li>如果意外忘记写 <code>JOIN</code> 条件，会变成 <code>CROSS JOIN</code>，导致性能问题</li></ul><hr><h3 id="19-NATURAL-JOIN"><a href="#19-NATURAL-JOIN" class="headerlink" title="19. NATURAL JOIN"></a>19. NATURAL JOIN</h3><ul><li><code>NATURAL JOIN</code>自然连接是<code>SQL</code>中的一种联接操作，它根据两个表中同名的列自动进行联接。自然连接会自动比较两个表中所有同名的列，并返回这些列值相等的行。与<code>INNER JOIN</code>不同，<code>NATURAL JOIN</code>不需要显式指定联接条件，因为它会自动查找并使用同名列进行联接。</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 基本语法</span></span><br><span class="line"><span class="keyword">SELECT</span> column1, column2, ...</span><br><span class="line"><span class="keyword">FROM</span> table1</span><br><span class="line"><span class="keyword">NATURAL</span> <span class="keyword">JOIN</span> table2;</span><br></pre></td></tr></table></figure><ul><li><strong>自动联接</strong>: <code>NATURAL JOIN</code>自动查找并使用两个表中所有同名的列来进行联接</li><li><strong>同名列值相等</strong>: 只有当两个表中同名列的值相等时，才会在结果集中返回这些行</li><li><strong>不返回重复列</strong>: 结果集中不会包含重复的同名列，只会返回一次</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- employees</span></span><br><span class="line"><span class="comment">-- | id | name    | department_id |</span></span><br><span class="line"><span class="comment">-- |----|---------|---------------|</span></span><br><span class="line"><span class="comment">-- | 1  | Alice   | 1             |</span></span><br><span class="line"><span class="comment">-- | 2  | Bob     | 2             |</span></span><br><span class="line"><span class="comment">-- | 3  | Charlie | 3             |</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- departments</span></span><br><span class="line"><span class="comment">-- | id | department_name |</span></span><br><span class="line"><span class="comment">-- |----|-----------------| </span></span><br><span class="line"><span class="comment">-- | 1  | HR              |</span></span><br><span class="line"><span class="comment">-- | 2  | Engineering     |</span></span><br><span class="line"><span class="comment">-- | 4  | Marketing       |</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">NATURAL</span> <span class="keyword">JOIN</span> departments;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询结果（自动匹配 id 列）</span></span><br><span class="line"><span class="comment">-- | id | name  | department_id | department_name |</span></span><br><span class="line"><span class="comment">-- |----|-------|---------------|-----------------|</span></span><br><span class="line"><span class="comment">-- | 1  | Alice | 1             | HR              |</span></span><br><span class="line"><span class="comment">-- | 2  | Bob   | 2             | Engineering     |</span></span><br></pre></td></tr></table></figure><blockquote><p><code>NATURAL JOIN</code> 自动使用两个表中的同名列 <code>id</code> 进行匹配<br>Charlie (id&#x3D;3) 没有出现，因为 <code>departments</code> 表中没有 <code>id=3</code> 的记录<br>Marketing (id&#x3D;4) 没有出现，因为 <code>employees</code> 表中没有 <code>id=4</code> 的记录<br>结果中 <code>id</code> 列只出现一次，不会重复</p></blockquote><h4 id="代替写法"><a href="#代替写法" class="headerlink" title="代替写法"></a>代替写法</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- NATURAL JOIN</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">NATURAL</span> <span class="keyword">JOIN</span> departments;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 等价于</span></span><br><span class="line"><span class="keyword">SELECT</span> e.id, e.name, e.department_id, d.department_name</span><br><span class="line"><span class="keyword">FROM</span> employees e</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> departments d <span class="keyword">ON</span> e.id <span class="operator">=</span> d.id;</span><br></pre></td></tr></table></figure><ul><li><strong>不推荐使用</strong>: <code>NATURAL JOIN</code> 在实际开发中很少使用，因为它依赖列名，容易出错</li><li><strong>隐式条件</strong>: 联接条件不明确，代码可读性差</li><li><strong>列名变化风险</strong>: 如果表结构发生变化（添加或重命名同名列），查询结果可能意外改变</li><li><strong>多个同名列</strong>: 如果有多个同名列，会同时用于联接条件</li><li><strong>推荐替代方案</strong>: 使用显式的 <code>INNER JOIN</code> 或 <code>LEFT JOIN</code> 并明确指定 <code>ON</code> 条件</li></ul><h4 id="为什么不推荐使用"><a href="#为什么不推荐使用" class="headerlink" title="为什么不推荐使用"></a>为什么不推荐使用</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 假设后来给 departments 表添加了 department_id 列</span></span><br><span class="line"><span class="comment">-- NATURAL JOIN 会同时匹配 id 和 department_id</span></span><br><span class="line"><span class="comment">-- 导致意外的查询结果</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">NATURAL</span> <span class="keyword">JOIN</span> departments;  <span class="comment">-- 结果可能为空或不符合预期</span></span><br></pre></td></tr></table></figure><hr><h3 id="20-LATERAL-JOIN"><a href="#20-LATERAL-JOIN" class="headerlink" title="20. LATERAL JOIN"></a>20. LATERAL JOIN</h3><ul><li><code>LATERAL JOIN</code>横向连接是<code>SQL</code>中的一种高级联接操作，它允许联接的子查询可以引用来自连接左侧表的列。<code>LATERAL</code>子句使得每一行都可以独立地进行子查询，基于当前行的值进行计算或过滤。这使得<code>LATERAL JOIN</code>特别适用于那些需要处理依赖于当前行的复杂子查询的场景。</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 基本语法</span></span><br><span class="line"><span class="keyword">SELECT</span> column1, column2, ...</span><br><span class="line"><span class="keyword">FROM</span> table1</span><br><span class="line"><span class="keyword">JOIN</span> <span class="keyword">LATERAL</span> (</span><br><span class="line">  <span class="keyword">SELECT</span> ...</span><br><span class="line">  <span class="keyword">FROM</span> table2</span><br><span class="line">  <span class="keyword">WHERE</span> table2.column <span class="operator">=</span> table1.column</span><br><span class="line">) alias <span class="keyword">ON</span> <span class="keyword">condition</span>;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- employees</span></span><br><span class="line"><span class="comment">-- | id | name  |</span></span><br><span class="line"><span class="comment">-- |----|-------|</span></span><br><span class="line"><span class="comment">-- | 1  | Alice |</span></span><br><span class="line"><span class="comment">-- | 2  | Bob   |</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- projects</span></span><br><span class="line"><span class="comment">-- | employee_id | project_name | start_date |</span></span><br><span class="line"><span class="comment">-- |-------------|--------------|------------|</span></span><br><span class="line"><span class="comment">-- | 1           | Project X    | 2023-01-01 |</span></span><br><span class="line"><span class="comment">-- | 1           | Project Y    | 2023-06-01 |</span></span><br><span class="line"><span class="comment">-- | 2           | Project Z    | 2022-09-01 |</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询每个员工最新的项目</span></span><br><span class="line"><span class="keyword">SELECT</span> e.name, p.project_name, p.start_date</span><br><span class="line"><span class="keyword">FROM</span> employees e</span><br><span class="line"><span class="keyword">JOIN</span> <span class="keyword">LATERAL</span> (</span><br><span class="line">  <span class="keyword">SELECT</span> project_name, start_date</span><br><span class="line">  <span class="keyword">FROM</span> projects pr</span><br><span class="line">  <span class="keyword">WHERE</span> pr.employee_id <span class="operator">=</span> e.id</span><br><span class="line">  <span class="keyword">ORDER</span> <span class="keyword">BY</span> start_date <span class="keyword">DESC</span></span><br><span class="line">  LIMIT <span class="number">1</span></span><br><span class="line">) p <span class="keyword">ON</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询结果</span></span><br><span class="line"><span class="comment">-- | name  | project_name | start_date |</span></span><br><span class="line"><span class="comment">-- |-------|--------------|------------|</span></span><br><span class="line"><span class="comment">-- | Alice | Project Y    | 2023-06-01 |</span></span><br><span class="line"><span class="comment">-- | Bob   | Project Z    | 2022-09-01 |</span></span><br></pre></td></tr></table></figure><blockquote><p>子查询可以引用外部表 <code>e.id</code><br>对每个员工独立执行子查询<br><code>ON true</code> 表示无额外联接条件<br>Alice 的最新项目是 Project Y，Bob 的是 Project Z</p></blockquote><h4 id="常见应用场景-1"><a href="#常见应用场景-1" class="headerlink" title="常见应用场景"></a>常见应用场景</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 获取每个部门工资最高的3名员工</span></span><br><span class="line"><span class="keyword">SELECT</span> d.department_name, e.name, e.salary</span><br><span class="line"><span class="keyword">FROM</span> departments d</span><br><span class="line"><span class="keyword">JOIN</span> <span class="keyword">LATERAL</span> (</span><br><span class="line">  <span class="keyword">SELECT</span> name, salary</span><br><span class="line">  <span class="keyword">FROM</span> employees</span><br><span class="line">  <span class="keyword">WHERE</span> department_id <span class="operator">=</span> d.id</span><br><span class="line">  <span class="keyword">ORDER</span> <span class="keyword">BY</span> salary <span class="keyword">DESC</span></span><br><span class="line">  LIMIT <span class="number">3</span></span><br><span class="line">) e <span class="keyword">ON</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 计算每个客户的最近5次订单总额</span></span><br><span class="line"><span class="keyword">SELECT</span> c.name, orders.total</span><br><span class="line"><span class="keyword">FROM</span> customers c</span><br><span class="line"><span class="keyword">JOIN</span> <span class="keyword">LATERAL</span> (</span><br><span class="line">  <span class="keyword">SELECT</span> <span class="built_in">SUM</span>(amount) <span class="keyword">as</span> total</span><br><span class="line">  <span class="keyword">FROM</span> orders</span><br><span class="line">  <span class="keyword">WHERE</span> customer_id <span class="operator">=</span> c.id</span><br><span class="line">  <span class="keyword">ORDER</span> <span class="keyword">BY</span> order_date <span class="keyword">DESC</span></span><br><span class="line">  LIMIT <span class="number">5</span></span><br><span class="line">) orders <span class="keyword">ON</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 使用 LEFT JOIN LATERAL 包含没有项目的员工</span></span><br><span class="line"><span class="keyword">SELECT</span> e.name, <span class="built_in">COALESCE</span>(p.project_name, <span class="string">&#x27;No Projects&#x27;</span>) <span class="keyword">as</span> project</span><br><span class="line"><span class="keyword">FROM</span> employees e</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> <span class="keyword">LATERAL</span> (</span><br><span class="line">  <span class="keyword">SELECT</span> project_name</span><br><span class="line">  <span class="keyword">FROM</span> projects pr</span><br><span class="line">  <span class="keyword">WHERE</span> pr.employee_id <span class="operator">=</span> e.id</span><br><span class="line">  <span class="keyword">ORDER</span> <span class="keyword">BY</span> start_date <span class="keyword">DESC</span></span><br><span class="line">  LIMIT <span class="number">1</span></span><br><span class="line">) p <span class="keyword">ON</span> <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><ul><li><strong>数据库支持</strong>: PostgreSQL 9.3+, MySQL 8.0+ (使用 <code>LATERAL</code> 关键字)</li><li><strong>性能</strong>: 对左表的每一行都执行子查询，大表时需注意性能</li><li><strong>LEFT JOIN LATERAL</strong>: 允许子查询返回空结果，类似于 <code>LEFT JOIN</code></li><li><strong>ON true</strong>: 当子查询已经包含所有过滤条件时，使用 <code>ON true</code></li><li><strong>替代方案</strong>: 某些场景可以用窗口函数或普通 <code>JOIN</code> 替代</li></ul><h4 id="数据库兼容性"><a href="#数据库兼容性" class="headerlink" title="数据库兼容性"></a>数据库兼容性</h4><ul><li><strong>PostgreSQL</strong>: 完全支持 <code>LATERAL</code></li><li><strong>MySQL 8.0+</strong>: 支持 <code>LATERAL</code>（之前版本不支持）</li><li><strong>SQL Server</strong>: 使用 <code>CROSS APPLY</code> 和 <code>OUTER APPLY</code> 代替</li><li><strong>Oracle</strong>: 使用 <code>CROSS APPLY</code> 和 <code>OUTER APPLY</code> 代替</li></ul><hr><h2 id="数据分组"><a href="#数据分组" class="headerlink" title="数据分组"></a>数据分组</h2><h3 id="21-GROUP-BY-分组"><a href="#21-GROUP-BY-分组" class="headerlink" title="21. GROUP BY 分组"></a>21. GROUP BY 分组</h3><ul><li><code>GROUP BY</code>是<code>SQL</code>中的一个子句，用于将查询结果按一个或多个列进行分组。分组操作通常与聚合函数（如<code>COUNT</code>、<code>SUM</code>、<code>AVG</code>、<code>MAX</code>、<code>MIN</code>等）结合使用，以便对每个分组进行汇总计算。<code>GROUP BY</code>允许你将数据按特定的维度进行聚合，进而对这些聚合后的数据进行分析。</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 基本语法</span></span><br><span class="line"><span class="keyword">SELECT</span> column1, column2, ..., aggregate_function(<span class="keyword">column</span>)</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">condition</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> column1, column2, ...;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- sales</span></span><br><span class="line"><span class="comment">-- | id | product_id | quantity | price |</span></span><br><span class="line"><span class="comment">-- |----|------------|----------|-------|</span></span><br><span class="line"><span class="comment">-- | 1  | 101        | 5        | 10.00 |</span></span><br><span class="line"><span class="comment">-- | 2  | 102        | 3        | 15.00 |</span></span><br><span class="line"><span class="comment">-- | 3  | 101        | 2        | 10.00 |</span></span><br><span class="line"><span class="comment">-- | 4  | 101        | 4        | 10.00 |</span></span><br><span class="line"><span class="comment">-- | 5  | 102        | 1        | 15.00 |</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 按产品ID汇总销售数量</span></span><br><span class="line"><span class="keyword">SELECT</span> product_id, <span class="built_in">SUM</span>(quantity) <span class="keyword">AS</span> total_quantity</span><br><span class="line"><span class="keyword">FROM</span> sales</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> product_id;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询结果</span></span><br><span class="line"><span class="comment">-- | product_id | total_quantity |</span></span><br><span class="line"><span class="comment">-- |------------|----------------|</span></span><br><span class="line"><span class="comment">-- | 101        | 11             |</span></span><br><span class="line"><span class="comment">-- | 102        | 4              |</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 统计每个产品的销售次数和总金额</span></span><br><span class="line"><span class="keyword">SELECT</span> product_id, </span><br><span class="line">       <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> sale_count,</span><br><span class="line">       <span class="built_in">SUM</span>(quantity <span class="operator">*</span> price) <span class="keyword">AS</span> total_revenue</span><br><span class="line"><span class="keyword">FROM</span> sales</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> product_id;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 按多个列分组</span></span><br><span class="line"><span class="keyword">SELECT</span> product_id, price, <span class="built_in">SUM</span>(quantity) <span class="keyword">AS</span> total_quantity</span><br><span class="line"><span class="keyword">FROM</span> sales</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> product_id, price;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 结合WHERE过滤</span></span><br><span class="line"><span class="keyword">SELECT</span> product_id, <span class="built_in">SUM</span>(quantity) <span class="keyword">AS</span> total_quantity</span><br><span class="line"><span class="keyword">FROM</span> sales</span><br><span class="line"><span class="keyword">WHERE</span> price <span class="operator">&gt;</span> <span class="number">10</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> product_id;</span><br></pre></td></tr></table></figure><h4 id="常用聚合函数"><a href="#常用聚合函数" class="headerlink" title="常用聚合函数"></a>常用聚合函数</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- COUNT: 计数</span></span><br><span class="line"><span class="keyword">SELECT</span> department_id, <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> employee_count</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- SUM: 求和</span></span><br><span class="line"><span class="keyword">SELECT</span> department_id, <span class="built_in">SUM</span>(salary) <span class="keyword">AS</span> total_salary</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- AVG: 平均值</span></span><br><span class="line"><span class="keyword">SELECT</span> department_id, <span class="built_in">AVG</span>(salary) <span class="keyword">AS</span> avg_salary</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- MAX/MIN: 最大值/最小值</span></span><br><span class="line"><span class="keyword">SELECT</span> department_id, <span class="built_in">MAX</span>(salary) <span class="keyword">AS</span> max_salary, <span class="built_in">MIN</span>(salary) <span class="keyword">AS</span> min_salary</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 多个聚合函数组合</span></span><br><span class="line"><span class="keyword">SELECT</span> department_id,</span><br><span class="line">       <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> employee_count,</span><br><span class="line">       <span class="built_in">AVG</span>(salary) <span class="keyword">AS</span> avg_salary,</span><br><span class="line">       <span class="built_in">MAX</span>(salary) <span class="keyword">AS</span> max_salary</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id;</span><br></pre></td></tr></table></figure><ul><li><strong>SELECT中的列</strong>: <code>SELECT</code>子句中出现的非聚合列必须在<code>GROUP BY</code>中列出</li><li><strong>执行顺序</strong>: <code>WHERE</code> → <code>GROUP BY</code> → 聚合函数 → <code>HAVING</code> → <code>SELECT</code></li><li><strong>NULL值处理</strong>: <code>NULL</code>值会被分为一组</li><li><strong>性能</strong>: 在分组列上建立索引可以提高性能</li></ul><h4 id="错误示例"><a href="#错误示例" class="headerlink" title="错误示例"></a>错误示例</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- ❌ 错误: name 不在 GROUP BY 中，也不是聚合函数</span></span><br><span class="line"><span class="keyword">SELECT</span> department_id, name, <span class="built_in">COUNT</span>(<span class="operator">*</span>)</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- ✅ 正确: 所有非聚合列都在 GROUP BY 中</span></span><br><span class="line"><span class="keyword">SELECT</span> department_id, name, <span class="built_in">COUNT</span>(<span class="operator">*</span>)</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id, name;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- ✅ 正确: 只选择分组列和聚合结果</span></span><br><span class="line"><span class="keyword">SELECT</span> department_id, <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> employee_count</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id;</span><br></pre></td></tr></table></figure><hr><h3 id="22-HAVING"><a href="#22-HAVING" class="headerlink" title="22. HAVING"></a>22. HAVING</h3><ul><li><code>HAVING</code>子句是<code>SQL</code>中的一部分，主要用于在分组后的结果集上进行过滤。它通常与<code>GROUP BY</code>子句一起使用，以便对聚合后的数据进行进一步的筛选。与<code>WHERE</code>子句不同，<code>HAVING</code>子句用于过滤基于聚合函数的结果，而<code>WHERE</code>子句是在数据分组之前对行进行过滤。</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 基本语法</span></span><br><span class="line"><span class="keyword">SELECT</span> column1, column2, aggregate_function(column3)</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">condition</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> column1, column2</span><br><span class="line"><span class="keyword">HAVING</span> aggregate_condition;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- sales</span></span><br><span class="line"><span class="comment">-- | id | product_id | quantity | price |</span></span><br><span class="line"><span class="comment">-- |----|------------|----------|-------|</span></span><br><span class="line"><span class="comment">-- | 1  | 101        | 50       | 10.00 |</span></span><br><span class="line"><span class="comment">-- | 2  | 102        | 30       | 15.00 |</span></span><br><span class="line"><span class="comment">-- | 3  | 101        | 60       | 10.00 |</span></span><br><span class="line"><span class="comment">-- | 4  | 103        | 20       | 20.00 |</span></span><br><span class="line"><span class="comment">-- | 5  | 102        | 10       | 15.00 |</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询销售总量大于100的产品</span></span><br><span class="line"><span class="keyword">SELECT</span> product_id, <span class="built_in">SUM</span>(quantity) <span class="keyword">AS</span> total_quantity</span><br><span class="line"><span class="keyword">FROM</span> sales</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> product_id</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">SUM</span>(quantity) <span class="operator">&gt;</span> <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询结果</span></span><br><span class="line"><span class="comment">-- | product_id | total_quantity |</span></span><br><span class="line"><span class="comment">-- |------------|----------------|</span></span><br><span class="line"><span class="comment">-- | 101        | 110            |</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询平均价格大于12且销售次数超过2次的产品</span></span><br><span class="line"><span class="keyword">SELECT</span> product_id, </span><br><span class="line">       <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> sale_count,</span><br><span class="line">       <span class="built_in">AVG</span>(price) <span class="keyword">AS</span> avg_price</span><br><span class="line"><span class="keyword">FROM</span> sales</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> product_id</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="operator">&gt;</span> <span class="number">2</span> <span class="keyword">AND</span> <span class="built_in">AVG</span>(price) <span class="operator">&gt;</span> <span class="number">12</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询部门员工数超过5人的部门</span></span><br><span class="line"><span class="keyword">SELECT</span> department_id, <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> employee_count</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="operator">&gt;</span> <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 结合WHERE和HAVING</span></span><br><span class="line"><span class="keyword">SELECT</span> product_id, <span class="built_in">SUM</span>(quantity) <span class="keyword">AS</span> total_quantity</span><br><span class="line"><span class="keyword">FROM</span> sales</span><br><span class="line"><span class="keyword">WHERE</span> price <span class="operator">&gt;</span> <span class="number">10</span>  <span class="comment">-- 分组前过滤：只统计价格大于10的销售</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> product_id</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">SUM</span>(quantity) <span class="operator">&gt;</span> <span class="number">50</span>;  <span class="comment">-- 分组后过滤：只显示总量大于50的产品</span></span><br></pre></td></tr></table></figure><h4 id="WHERE-vs-HAVING"><a href="#WHERE-vs-HAVING" class="headerlink" title="WHERE vs HAVING"></a>WHERE vs HAVING</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- WHERE: 在分组前过滤行</span></span><br><span class="line"><span class="keyword">SELECT</span> department_id, <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> employee_count</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> salary <span class="operator">&gt;</span> <span class="number">50000</span>  <span class="comment">-- 过滤掉工资≤50000的员工</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- HAVING: 在分组后过滤组</span></span><br><span class="line"><span class="keyword">SELECT</span> department_id, <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> employee_count</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="operator">&gt;</span> <span class="number">10</span>;  <span class="comment">-- 过滤掉员工数≤10的部门</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 同时使用WHERE和HAVING</span></span><br><span class="line"><span class="keyword">SELECT</span> department_id, <span class="built_in">AVG</span>(salary) <span class="keyword">AS</span> avg_salary</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> hire_date <span class="operator">&gt;</span> <span class="string">&#x27;2020-01-01&#x27;</span>  <span class="comment">-- 先过滤：只看2020年后入职的员工</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">AVG</span>(salary) <span class="operator">&gt;</span> <span class="number">60000</span>;  <span class="comment">-- 再过滤：只看平均工资&gt;60000的部门</span></span><br></pre></td></tr></table></figure><h4 id="执行顺序"><a href="#执行顺序" class="headerlink" title="执行顺序"></a>执行顺序</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> department_id, <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> employee_count</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> salary <span class="operator">&gt;</span> <span class="number">50000</span>        <span class="comment">-- 1. 先执行WHERE过滤行</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id      <span class="comment">-- 2. 对过滤后的行分组</span></span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="operator">&gt;</span> <span class="number">5</span>         <span class="comment">-- 3. 对分组结果过滤</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> employee_count <span class="keyword">DESC</span> <span class="comment">-- 4. 最后排序</span></span><br><span class="line">LIMIT <span class="number">10</span>;                   <span class="comment">-- 5. 限制结果数量</span></span><br></pre></td></tr></table></figure><ul><li><strong>使用场景</strong>: <code>HAVING</code>用于过滤聚合结果，<code>WHERE</code>用于过滤原始行</li><li><strong>性能</strong>: 优先使用<code>WHERE</code>过滤，减少需要分组的数据量</li><li><strong>聚合函数</strong>: <code>HAVING</code>中可以使用聚合函数，<code>WHERE</code>中不能</li><li><strong>列引用</strong>: <code>HAVING</code>可以引用<code>SELECT</code>中的别名（部分数据库支持）</li><li><strong>执行顺序</strong>: <code>WHERE</code> → <code>GROUP BY</code> → <code>HAVING</code> → <code>SELECT</code> → <code>ORDER BY</code></li></ul><h4 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- ❌ 错误: WHERE中不能使用聚合函数</span></span><br><span class="line"><span class="keyword">SELECT</span> department_id, <span class="built_in">AVG</span>(salary)</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> <span class="built_in">AVG</span>(salary) <span class="operator">&gt;</span> <span class="number">60000</span>  <span class="comment">-- 错误！</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- ✅ 正确: 在HAVING中使用聚合函数</span></span><br><span class="line"><span class="keyword">SELECT</span> department_id, <span class="built_in">AVG</span>(salary)</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">AVG</span>(salary) <span class="operator">&gt;</span> <span class="number">60000</span>;</span><br></pre></td></tr></table></figure><hr><h3 id="23-PARTITION-BY-分区"><a href="#23-PARTITION-BY-分区" class="headerlink" title="23. PARTITION BY 分区"></a>23. PARTITION BY 分区</h3><ul><li><code>PARTITION BY</code>是<code>SQL</code>中的一个子句，通常与窗口函数一起使用，用于将查询结果集划分为多个分区，然后在每个分区内执行特定的计算。它类似于<code>GROUP BY</code>，但<code>PARTITION BY</code>不会将数据聚合到单一行，而是保留所有行，并在每个分区内执行计算。</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 基本语法</span></span><br><span class="line"><span class="keyword">SELECT</span> column1, </span><br><span class="line">       column2, </span><br><span class="line">       window_function() <span class="keyword">OVER</span> (</span><br><span class="line">           <span class="keyword">PARTITION</span> <span class="keyword">BY</span> column_name </span><br><span class="line">           <span class="keyword">ORDER</span> <span class="keyword">BY</span> column_name</span><br><span class="line">       ) <span class="keyword">AS</span> alias_name</span><br><span class="line"><span class="keyword">FROM</span> table_name;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- sales</span></span><br><span class="line"><span class="comment">-- | id | employee_id | sale_amount | sale_date  |</span></span><br><span class="line"><span class="comment">-- |----|-------------|-------------|------------|</span></span><br><span class="line"><span class="comment">-- | 1  | 101         | 500         | 2023-08-01 |</span></span><br><span class="line"><span class="comment">-- | 2  | 101         | 700         | 2023-08-02 |</span></span><br><span class="line"><span class="comment">-- | 3  | 102         | 300         | 2023-08-01 |</span></span><br><span class="line"><span class="comment">-- | 4  | 101         | 400         | 2023-08-03 |</span></span><br><span class="line"><span class="comment">-- | 5  | 102         | 800         | 2023-08-02 |</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 按员工分区，对每个员工的销售额排名</span></span><br><span class="line"><span class="keyword">SELECT</span> employee_id, </span><br><span class="line">       sale_date, </span><br><span class="line">       sale_amount,</span><br><span class="line">       <span class="built_in">RANK</span>() <span class="keyword">OVER</span> (</span><br><span class="line">           <span class="keyword">PARTITION</span> <span class="keyword">BY</span> employee_id </span><br><span class="line">           <span class="keyword">ORDER</span> <span class="keyword">BY</span> sale_amount <span class="keyword">DESC</span></span><br><span class="line">       ) <span class="keyword">AS</span> sales_rank</span><br><span class="line"><span class="keyword">FROM</span> sales;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询结果</span></span><br><span class="line"><span class="comment">-- | employee_id | sale_date  | sale_amount | sales_rank |</span></span><br><span class="line"><span class="comment">-- |-------------|------------|-------------|------------|</span></span><br><span class="line"><span class="comment">-- | 101         | 2023-08-02 | 700         | 1          |</span></span><br><span class="line"><span class="comment">-- | 101         | 2023-08-01 | 500         | 2          |</span></span><br><span class="line"><span class="comment">-- | 101         | 2023-08-03 | 400         | 3          |</span></span><br><span class="line"><span class="comment">-- | 102         | 2023-08-02 | 800         | 1          |</span></span><br><span class="line"><span class="comment">-- | 102         | 2023-08-01 | 300         | 2          |</span></span><br></pre></td></tr></table></figure><blockquote><p>每个员工的销售记录都保留了，同时在各自的分区内进行了排名。</p></blockquote><h4 id="常见窗口函数示例"><a href="#常见窗口函数示例" class="headerlink" title="常见窗口函数示例"></a>常见窗口函数示例</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- ROW_NUMBER: 为每个分区内的行分配唯一序号</span></span><br><span class="line"><span class="keyword">SELECT</span> employee_id, </span><br><span class="line">       sale_date, </span><br><span class="line">       sale_amount,</span><br><span class="line">       <span class="built_in">ROW_NUMBER</span>() <span class="keyword">OVER</span> (</span><br><span class="line">           <span class="keyword">PARTITION</span> <span class="keyword">BY</span> employee_id </span><br><span class="line">           <span class="keyword">ORDER</span> <span class="keyword">BY</span> sale_date</span><br><span class="line">       ) <span class="keyword">AS</span> row_num</span><br><span class="line"><span class="keyword">FROM</span> sales;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- SUM: 计算每个分区的累计总和</span></span><br><span class="line"><span class="keyword">SELECT</span> employee_id, </span><br><span class="line">       sale_date, </span><br><span class="line">       sale_amount,</span><br><span class="line">       <span class="built_in">SUM</span>(sale_amount) <span class="keyword">OVER</span> (</span><br><span class="line">           <span class="keyword">PARTITION</span> <span class="keyword">BY</span> employee_id </span><br><span class="line">           <span class="keyword">ORDER</span> <span class="keyword">BY</span> sale_date</span><br><span class="line">       ) <span class="keyword">AS</span> running_total</span><br><span class="line"><span class="keyword">FROM</span> sales;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- AVG: 计算每个分区的平均值</span></span><br><span class="line"><span class="keyword">SELECT</span> employee_id, </span><br><span class="line">       sale_date, </span><br><span class="line">       sale_amount,</span><br><span class="line">       <span class="built_in">AVG</span>(sale_amount) <span class="keyword">OVER</span> (</span><br><span class="line">           <span class="keyword">PARTITION</span> <span class="keyword">BY</span> employee_id</span><br><span class="line">       ) <span class="keyword">AS</span> avg_sale</span><br><span class="line"><span class="keyword">FROM</span> sales;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- DENSE_RANK: 排名，相同值排名相同，无间隔</span></span><br><span class="line"><span class="keyword">SELECT</span> employee_id, </span><br><span class="line">       sale_date, </span><br><span class="line">       sale_amount,</span><br><span class="line">       <span class="built_in">DENSE_RANK</span>() <span class="keyword">OVER</span> (</span><br><span class="line">           <span class="keyword">PARTITION</span> <span class="keyword">BY</span> employee_id </span><br><span class="line">           <span class="keyword">ORDER</span> <span class="keyword">BY</span> sale_amount <span class="keyword">DESC</span></span><br><span class="line">       ) <span class="keyword">AS</span> dense_rank</span><br><span class="line"><span class="keyword">FROM</span> sales;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- LAG/LEAD: 访问前一行或后一行的数据</span></span><br><span class="line"><span class="keyword">SELECT</span> employee_id, </span><br><span class="line">       sale_date, </span><br><span class="line">       sale_amount,</span><br><span class="line">       <span class="built_in">LAG</span>(sale_amount) <span class="keyword">OVER</span> (</span><br><span class="line">           <span class="keyword">PARTITION</span> <span class="keyword">BY</span> employee_id </span><br><span class="line">           <span class="keyword">ORDER</span> <span class="keyword">BY</span> sale_date</span><br><span class="line">       ) <span class="keyword">AS</span> prev_sale,</span><br><span class="line">       <span class="built_in">LEAD</span>(sale_amount) <span class="keyword">OVER</span> (</span><br><span class="line">           <span class="keyword">PARTITION</span> <span class="keyword">BY</span> employee_id </span><br><span class="line">           <span class="keyword">ORDER</span> <span class="keyword">BY</span> sale_date</span><br><span class="line">       ) <span class="keyword">AS</span> next_sale</span><br><span class="line"><span class="keyword">FROM</span> sales;</span><br></pre></td></tr></table></figure><ul><li><strong>保留所有行</strong>: <code>PARTITION BY</code>不会减少行数，而是为每行添加计算结果</li><li><strong>窗口函数</strong>: 必须与窗口函数（如<code>ROW_NUMBER</code>、<code>RANK</code>、<code>SUM</code>等）一起使用</li><li><strong>ORDER BY</strong>: 窗口函数内的<code>ORDER BY</code>定义分区内的排序，与查询的<code>ORDER BY</code>不同</li><li><strong>性能</strong>: 窗口函数可能比较耗费资源，大数据集需要注意性能</li><li><strong>数据库支持</strong>: 大多数现代数据库支持窗口函数（PostgreSQL、MySQL 8.0+、SQL Server、Oracle）</li></ul><hr><h2 id="集合运算"><a href="#集合运算" class="headerlink" title="集合运算"></a>集合运算</h2><h3 id="24-UNION-组合"><a href="#24-UNION-组合" class="headerlink" title="24. UNION 组合"></a>24. UNION 组合</h3><ul><li><code>UNION</code>是<code>SQL</code>中的一个运算符，用于将两个或多个<code>SELECT</code>语句的结果组合成一个结果集。<code>UNION</code>运算符将多个查询的结果合并为一个，且默认情况下会去除重复的行。如果你希望保留重复行，可以使用<code>UNION ALL</code>。</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 基本语法</span></span><br><span class="line"><span class="keyword">SELECT</span> column1, column2, ...</span><br><span class="line"><span class="keyword">FROM</span> table1</span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> column1, column2, ...</span><br><span class="line"><span class="keyword">FROM</span> table2;</span><br></pre></td></tr></table></figure><ul><li><strong>列数和数据类型必须一致</strong>: 参与<code>UNION</code>的每个<code>SELECT</code>语句中，列数必须相同，且对应列的数据类型应该兼容或相同</li><li><strong>列的顺序和名称</strong>: 在合并的结果集中，列的顺序以第一个<code>SELECT</code>语句中的列为准，列名也是根据第一个<code>SELECT</code>语句的列名</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- employees_2023</span></span><br><span class="line"><span class="comment">-- | id | name    | department |</span></span><br><span class="line"><span class="comment">-- |----|---------|------------|</span></span><br><span class="line"><span class="comment">-- | 1  | Alice   | HR         |</span></span><br><span class="line"><span class="comment">-- | 2  | Bob     | IT         |</span></span><br><span class="line"><span class="comment">-- | 3  | Charlie | Finance    |</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- employees_2024</span></span><br><span class="line"><span class="comment">-- | id | name  | department |</span></span><br><span class="line"><span class="comment">-- |----|-------|------------|</span></span><br><span class="line"><span class="comment">-- | 2  | Bob   | IT         |</span></span><br><span class="line"><span class="comment">-- | 4  | David | Marketing  |</span></span><br><span class="line"><span class="comment">-- | 5  | Eve   | HR         |</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- UNION: 去除重复行</span></span><br><span class="line"><span class="keyword">SELECT</span> id, name, department</span><br><span class="line"><span class="keyword">FROM</span> employees_2023</span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> id, name, department</span><br><span class="line"><span class="keyword">FROM</span> employees_2024;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询结果（Bob只出现一次）</span></span><br><span class="line"><span class="comment">-- | id | name    | department |</span></span><br><span class="line"><span class="comment">-- |----|---------|------------|</span></span><br><span class="line"><span class="comment">-- | 1  | Alice   | HR         |</span></span><br><span class="line"><span class="comment">-- | 2  | Bob     | IT         |</span></span><br><span class="line"><span class="comment">-- | 3  | Charlie | Finance    |</span></span><br><span class="line"><span class="comment">-- | 4  | David   | Marketing  |</span></span><br><span class="line"><span class="comment">-- | 5  | Eve     | HR         |</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- UNION ALL: 保留重复行</span></span><br><span class="line"><span class="keyword">SELECT</span> id, name, department</span><br><span class="line"><span class="keyword">FROM</span> employees_2023</span><br><span class="line"><span class="keyword">UNION</span> <span class="keyword">ALL</span></span><br><span class="line"><span class="keyword">SELECT</span> id, name, department</span><br><span class="line"><span class="keyword">FROM</span> employees_2024;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询结果（Bob出现两次）</span></span><br><span class="line"><span class="comment">-- | id | name    | department |</span></span><br><span class="line"><span class="comment">-- |----|---------|------------|</span></span><br><span class="line"><span class="comment">-- | 1  | Alice   | HR         |</span></span><br><span class="line"><span class="comment">-- | 2  | Bob     | IT         |</span></span><br><span class="line"><span class="comment">-- | 3  | Charlie | Finance    |</span></span><br><span class="line"><span class="comment">-- | 2  | Bob     | IT         |</span></span><br><span class="line"><span class="comment">-- | 4  | David   | Marketing  |</span></span><br><span class="line"><span class="comment">-- | 5  | Eve     | HR         |</span></span><br></pre></td></tr></table></figure><blockquote><p>UNION: 自动去重，性能较慢<br>UNION ALL: 保留所有行，性能更快</p></blockquote><h4 id="常见应用场景-2"><a href="#常见应用场景-2" class="headerlink" title="常见应用场景"></a>常见应用场景</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 合并历史数据和当前数据</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> orders_archive</span><br><span class="line"><span class="keyword">UNION</span> <span class="keyword">ALL</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> orders_current;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 合并不同条件的查询结果</span></span><br><span class="line"><span class="keyword">SELECT</span> id, name <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> department <span class="operator">=</span> <span class="string">&#x27;IT&#x27;</span></span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> id, name <span class="keyword">FROM</span> contractors <span class="keyword">WHERE</span> status <span class="operator">=</span> <span class="string">&#x27;active&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 生成报表数据</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="string">&#x27;Total Sales&#x27;</span> <span class="keyword">AS</span> metric, <span class="built_in">SUM</span>(amount) <span class="keyword">AS</span> <span class="keyword">value</span> <span class="keyword">FROM</span> sales</span><br><span class="line"><span class="keyword">UNION</span> <span class="keyword">ALL</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="string">&#x27;Average Sale&#x27;</span>, <span class="built_in">AVG</span>(amount) <span class="keyword">FROM</span> sales</span><br><span class="line"><span class="keyword">UNION</span> <span class="keyword">ALL</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="string">&#x27;Max Sale&#x27;</span>, <span class="built_in">MAX</span>(amount) <span class="keyword">FROM</span> sales;</span><br></pre></td></tr></table></figure><ul><li><strong>列数必须相同</strong>: 所有<code>SELECT</code>语句必须返回相同数量的列</li><li><strong>数据类型兼容</strong>: 对应列的数据类型必须兼容</li><li><strong>列名</strong>: 结果集使用第一个<code>SELECT</code>的列名</li><li><strong>性能</strong>: <code>UNION</code>需要去重，比<code>UNION ALL</code>慢。如果确定没有重复或不需要去重，使用<code>UNION ALL</code></li><li><strong>ORDER BY</strong>: 只能在最后一个查询后使用，对整个结果集排序</li><li><strong>NULL值</strong>: <code>NULL</code>被视为相等，会被<code>UNION</code>去重</li></ul><hr><h3 id="25-INTERSECT-交集"><a href="#25-INTERSECT-交集" class="headerlink" title="25. INTERSECT 交集"></a>25. INTERSECT 交集</h3><ul><li><code>INTERSECT</code>是<code>SQL</code>中的一个运算符，用于返回两个或多个<code>SELECT</code>语句结果集的交集。换句话说，它返回的是在所有参与查询的结果集中都存在的行。</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 基本语法</span></span><br><span class="line"><span class="keyword">SELECT</span> column1, column2, ...</span><br><span class="line"><span class="keyword">FROM</span> table1</span><br><span class="line"><span class="keyword">INTERSECT</span></span><br><span class="line"><span class="keyword">SELECT</span> column1, column2, ...</span><br><span class="line"><span class="keyword">FROM</span> table2;</span><br></pre></td></tr></table></figure><ul><li><strong>返回共有行</strong>: 只返回在所有<code>SELECT</code>语句结果集中都存在的行</li><li><strong>自动去重</strong>: 会自动去除结果中的重复行</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- employees_2023</span></span><br><span class="line"><span class="comment">-- | id | name    | department |</span></span><br><span class="line"><span class="comment">-- |----|---------|------------|</span></span><br><span class="line"><span class="comment">-- | 1  | Alice   | HR         |</span></span><br><span class="line"><span class="comment">-- | 2  | Bob     | IT         |</span></span><br><span class="line"><span class="comment">-- | 3  | Charlie | Finance    |</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- employees_2024</span></span><br><span class="line"><span class="comment">-- | id | name  | department |</span></span><br><span class="line"><span class="comment">-- |----|-------|------------|</span></span><br><span class="line"><span class="comment">-- | 2  | Bob   | IT         |</span></span><br><span class="line"><span class="comment">-- | 3  | Charlie | Finance  |</span></span><br><span class="line"><span class="comment">-- | 4  | David | Marketing  |</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询在2023年和2024年都存在的员工</span></span><br><span class="line"><span class="keyword">SELECT</span> id, name, department</span><br><span class="line"><span class="keyword">FROM</span> employees_2023</span><br><span class="line"><span class="keyword">INTERSECT</span></span><br><span class="line"><span class="keyword">SELECT</span> id, name, department</span><br><span class="line"><span class="keyword">FROM</span> employees_2024;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询结果</span></span><br><span class="line"><span class="comment">-- | id | name    | department |</span></span><br><span class="line"><span class="comment">-- |----|---------|------------|</span></span><br><span class="line"><span class="comment">-- | 2  | Bob     | IT         |</span></span><br><span class="line"><span class="comment">-- | 3  | Charlie | Finance    |</span></span><br></pre></td></tr></table></figure><ul><li>列数和数据类型必须一致</li><li>自动去除重复行</li><li>MySQL <strong>不支持</strong> <code>INTERSECT</code>，需要用 <code>INNER JOIN</code> 或 <code>WHERE EXISTS</code> 实现</li><li>PostgreSQL、SQL Server、Oracle 支持 <code>INTERSECT</code></li></ul><hr><h3 id="26-EXCEPT-差集"><a href="#26-EXCEPT-差集" class="headerlink" title="26. EXCEPT 差集"></a>26. EXCEPT 差集</h3><ul><li><code>EXCEPT</code>是<code>SQL</code>中的一个运算符，用于返回两个<code>SELECT</code>语句结果集的差集，即返回第一个查询的结果集中有但第二个查询的结果集中没有的行。</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 基本语法</span></span><br><span class="line"><span class="keyword">SELECT</span> column1, column2, ...</span><br><span class="line"><span class="keyword">FROM</span> table1</span><br><span class="line"><span class="keyword">EXCEPT</span></span><br><span class="line"><span class="keyword">SELECT</span> column1, column2, ...</span><br><span class="line"><span class="keyword">FROM</span> table2;</span><br></pre></td></tr></table></figure><ul><li><strong>返回差集</strong>: 返回第一个查询结果集中有，但第二个查询结果集中没有的行</li><li><strong>自动去重</strong>: 会自动去除结果中的重复行</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- employees_2023</span></span><br><span class="line"><span class="comment">-- | id | name    | department |</span></span><br><span class="line"><span class="comment">-- |----|---------|------------|</span></span><br><span class="line"><span class="comment">-- | 1  | Alice   | HR         |</span></span><br><span class="line"><span class="comment">-- | 2  | Bob     | IT         |</span></span><br><span class="line"><span class="comment">-- | 3  | Charlie | Finance    |</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- employees_2024</span></span><br><span class="line"><span class="comment">-- | id | name    | department |</span></span><br><span class="line"><span class="comment">-- |----|---------|------------|</span></span><br><span class="line"><span class="comment">-- | 2  | Bob     | IT         |</span></span><br><span class="line"><span class="comment">-- | 4  | David   | Marketing  |</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询在2023年存在但在2024年不存在的员工</span></span><br><span class="line"><span class="keyword">SELECT</span> id, name, department</span><br><span class="line"><span class="keyword">FROM</span> employees_2023</span><br><span class="line"><span class="keyword">EXCEPT</span></span><br><span class="line"><span class="keyword">SELECT</span> id, name, department</span><br><span class="line"><span class="keyword">FROM</span> employees_2024;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询结果</span></span><br><span class="line"><span class="comment">-- | id | name    | department |</span></span><br><span class="line"><span class="comment">-- |----|---------|------------|</span></span><br><span class="line"><span class="comment">-- | 1  | Alice   | HR         |</span></span><br><span class="line"><span class="comment">-- | 3  | Charlie | Finance    |</span></span><br></pre></td></tr></table></figure><ul><li>列数和数据类型必须一致</li><li>自动去除重复行</li><li>顺序很重要: <code>A EXCEPT B</code> ≠ <code>B EXCEPT A</code></li><li>MySQL 使用 <code>EXCEPT</code> 或 <code>MINUS</code>（MySQL 8.0.31+支持<code>EXCEPT</code>）</li><li>Oracle 使用 <code>MINUS</code> 代替 <code>EXCEPT</code></li><li>PostgreSQL、SQL Server 支持 <code>EXCEPT</code></li></ul><hr><h2 id="分组集"><a href="#分组集" class="headerlink" title="分组集"></a>分组集</h2><h3 id="27-GROUPING-SETS"><a href="#27-GROUPING-SETS" class="headerlink" title="27. GROUPING SETS"></a>27. GROUPING SETS</h3><ul><li><code>GROUPING SETS</code>是<code>SQL</code>中的一种高级分组功能，用于在单个查询中实现多种分组方式。它允许你在一次查询中指定多个分组标准，并返回每个分组标准的聚合结果。</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 基本语法</span></span><br><span class="line"><span class="keyword">SELECT</span> column1, column2, ..., aggregate_function(<span class="keyword">column</span>)</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">GROUPING</span> SETS ( (column1), (column2), ...);</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- sales</span></span><br><span class="line"><span class="comment">-- | id | employee_id | product_id | sale_amount |</span></span><br><span class="line"><span class="comment">-- |----|-------------|------------|-------------|</span></span><br><span class="line"><span class="comment">-- | 1  | 101         | 1          | 100         |</span></span><br><span class="line"><span class="comment">-- | 2  | 102         | 1          | 200         |</span></span><br><span class="line"><span class="comment">-- | 3  | 101         | 2          | 150         |</span></span><br><span class="line"><span class="comment">-- | 4  | 103         | 2          | 250         |</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 按员工、按产品、总计三种方式分组</span></span><br><span class="line"><span class="keyword">SELECT</span> employee_id, </span><br><span class="line">       product_id, </span><br><span class="line">       <span class="built_in">SUM</span>(sale_amount) <span class="keyword">AS</span> total_sales</span><br><span class="line"><span class="keyword">FROM</span> sales</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">GROUPING</span> SETS (</span><br><span class="line">    (employee_id),</span><br><span class="line">    (product_id),</span><br><span class="line">    ()</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询结果</span></span><br><span class="line"><span class="comment">-- | employee_id | product_id | total_sales |</span></span><br><span class="line"><span class="comment">-- |-------------|------------|-------------|</span></span><br><span class="line"><span class="comment">-- | 101         | NULL       | 250         |</span></span><br><span class="line"><span class="comment">-- | 102         | NULL       | 200         |</span></span><br><span class="line"><span class="comment">-- | 103         | NULL       | 250         |</span></span><br><span class="line"><span class="comment">-- | NULL        | 1          | 300         |</span></span><br><span class="line"><span class="comment">-- | NULL        | 2          | 400         |</span></span><br><span class="line"><span class="comment">-- | NULL        | NULL       | 700         |</span></span><br></pre></td></tr></table></figure><blockquote><p><code>NULL</code>表示该维度未参与分组。例如第一组是按<code>employee_id</code>分组，所以<code>product_id</code>显示为<code>NULL</code>。</p></blockquote><ul><li><code>NULL</code>表示该列未参与分组</li><li>比多个<code>UNION ALL</code>查询更高效</li><li>PostgreSQL、SQL Server、Oracle 支持</li><li>MySQL <strong>不支持</strong> <code>GROUPING SETS</code>，需要用<code>UNION ALL</code>实现</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 对比普通 GROUP BY</span></span><br><span class="line"><span class="keyword">SELECT</span> employee_id, product_id, <span class="built_in">SUM</span>(sale_amount) <span class="keyword">AS</span> total_sales</span><br><span class="line"><span class="keyword">FROM</span> sales</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> employee_id, product_id;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询结果：只有细粒度的组合</span></span><br><span class="line"><span class="comment">-- | employee_id | product_id | total_sales |</span></span><br><span class="line"><span class="comment">-- |-------------|------------|-------------|</span></span><br><span class="line"><span class="comment">-- | 101         | 1          | 100         |</span></span><br><span class="line"><span class="comment">-- | 101         | 2          | 150         |</span></span><br><span class="line"><span class="comment">-- | 102         | 1          | 200         |</span></span><br><span class="line"><span class="comment">-- | 103         | 2          | 250         |</span></span><br></pre></td></tr></table></figure><hr><h3 id="28-CUBE-分组"><a href="#28-CUBE-分组" class="headerlink" title="28. CUBE 分组"></a>28. CUBE 分组</h3><ul><li><code>CUBE</code>是<code>SQL</code>中的一个扩展分组功能，用于在单个查询中生成所有可能组合的分组和聚合结果。<code>CUBE</code>是<code>GROUP BY</code>子句的一部分，提供了一种多维分析的方式，特别适合在需要对数据进行多维度汇总的场景中使用。</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 基本语法</span></span><br><span class="line"><span class="keyword">SELECT</span> column1, column2, ..., aggregate_function(<span class="keyword">column</span>)</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">CUBE</span> (column1, column2, ...);</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- sales</span></span><br><span class="line"><span class="comment">-- | region | product | sale_amount |</span></span><br><span class="line"><span class="comment">-- |--------|---------|-------------|</span></span><br><span class="line"><span class="comment">-- | North  | A       | 100         |</span></span><br><span class="line"><span class="comment">-- | North  | B       | 150         |</span></span><br><span class="line"><span class="comment">-- | South  | A       | 200         |</span></span><br><span class="line"><span class="comment">-- | South  | B       | 250         |</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 生成所有可能的分组组合</span></span><br><span class="line"><span class="keyword">SELECT</span> region, </span><br><span class="line">       product, </span><br><span class="line">       <span class="built_in">SUM</span>(sale_amount) <span class="keyword">AS</span> total_sales</span><br><span class="line"><span class="keyword">FROM</span> sales</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">CUBE</span> (region, product);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询结果</span></span><br><span class="line"><span class="comment">-- | region | product | total_sales |</span></span><br><span class="line"><span class="comment">-- |--------|---------|-------------|</span></span><br><span class="line"><span class="comment">-- | North  | A       | 100         | ← (region, product)</span></span><br><span class="line"><span class="comment">-- | North  | B       | 150         | ← (region, product)</span></span><br><span class="line"><span class="comment">-- | North  | NULL    | 250         | ← (region)</span></span><br><span class="line"><span class="comment">-- | South  | A       | 200         | ← (region, product)</span></span><br><span class="line"><span class="comment">-- | South  | B       | 250         | ← (region, product)</span></span><br><span class="line"><span class="comment">-- | South  | NULL    | 450         | ← (region)</span></span><br><span class="line"><span class="comment">-- | NULL   | A       | 300         | ← (product)</span></span><br><span class="line"><span class="comment">-- | NULL   | B       | 400         | ← (product)</span></span><br><span class="line"><span class="comment">-- | NULL   | NULL    | 700         | ← ()</span></span><br></pre></td></tr></table></figure><h4 id="生成的分组组合"><a href="#生成的分组组合" class="headerlink" title="生成的分组组合"></a>生成的分组组合</h4><p>对于<code>CUBE(A, B)</code>，生成 2^2 &#x3D; 4 种组合</p><ul><li><code>(A, B)</code> - 按两列分组</li><li><code>(A)</code> - 只按A分组</li><li><code>(B)</code> - 只按B分组</li><li><code>()</code> - 不分组（总计）</li></ul><p>对于<code>CUBE(A, B, C)</code>，生成 2^3 &#x3D; 8 种组合。</p><ul><li><code>CUBE(n列)</code>生成 2^n 种分组组合，列数多时结果集会很大</li><li>PostgreSQL、SQL Server、Oracle 支持</li><li>MySQL <strong>不支持</strong> <code>CUBE</code>，需要用<code>GROUPING SETS</code>或<code>UNION ALL</code>实现</li><li>适合多维分析和数据透视表场景</li></ul><hr><h3 id="29-ROLLUP-分组"><a href="#29-ROLLUP-分组" class="headerlink" title="29. ROLLUP 分组"></a>29. ROLLUP 分组</h3><ul><li><code>ROLLUP</code>是<code>SQL</code>中的一个扩展分组功能，用于生成基于层次结构的分组和聚合结果。它是<code>GROUP BY</code>子句的扩展，用于在一个查询中生成从详细到汇总的多个级别的聚合结果。<code>ROLLUP</code>常用于需要对数据进行层次分析的场景，例如销售数据按区域和时间进行汇总时。</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 基本语法</span></span><br><span class="line"><span class="keyword">SELECT</span> column1, column2, ..., aggregate_function(<span class="keyword">column</span>)</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">ROLLUP</span> (column1, column2, ...);</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- sales</span></span><br><span class="line"><span class="comment">-- | region | product | sale_amount |</span></span><br><span class="line"><span class="comment">-- |--------|---------|-------------|</span></span><br><span class="line"><span class="comment">-- | North  | A       | 100         |</span></span><br><span class="line"><span class="comment">-- | North  | B       | 150         |</span></span><br><span class="line"><span class="comment">-- | South  | A       | 200         |</span></span><br><span class="line"><span class="comment">-- | South  | B       | 250         |</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 按区域和产品生成层次汇总</span></span><br><span class="line"><span class="keyword">SELECT</span> region, </span><br><span class="line">       product, </span><br><span class="line">       <span class="built_in">SUM</span>(sale_amount) <span class="keyword">AS</span> total_sales</span><br><span class="line"><span class="keyword">FROM</span> sales</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">ROLLUP</span> (region, product);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询结果</span></span><br><span class="line"><span class="comment">-- | region | product | total_sales |</span></span><br><span class="line"><span class="comment">-- |--------|---------|-------------|</span></span><br><span class="line"><span class="comment">-- | North  | A       | 100         | ← (region, product)</span></span><br><span class="line"><span class="comment">-- | North  | B       | 150         | ← (region, product)</span></span><br><span class="line"><span class="comment">-- | North  | NULL    | 250         | ← (region) 小计</span></span><br><span class="line"><span class="comment">-- | South  | A       | 200         | ← (region, product)</span></span><br><span class="line"><span class="comment">-- | South  | B       | 250         | ← (region, product)</span></span><br><span class="line"><span class="comment">-- | South  | NULL    | 450         | ← (region) 小计</span></span><br><span class="line"><span class="comment">-- | NULL   | NULL    | 700         | ← () 总计</span></span><br></pre></td></tr></table></figure><h4 id="生成的分组组合-1"><a href="#生成的分组组合-1" class="headerlink" title="生成的分组组合"></a>生成的分组组合</h4><p>对于<code>ROLLUP(A, B, C)</code>，生成<strong>层次化</strong>的组合</p><ul><li><code>(A, B, C)</code> - 最详细</li><li><code>(A, B)</code> - 去掉最右边的C</li><li><code>(A)</code> - 再去掉B</li><li><code>()</code> - 总计</li></ul><p><strong>注意</strong>: <code>ROLLUP</code>是<strong>有顺序的</strong>，从左到右逐层汇总。</p><h4 id="ROLLUP-vs-CUBE"><a href="#ROLLUP-vs-CUBE" class="headerlink" title="ROLLUP vs CUBE"></a>ROLLUP vs CUBE</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- ROLLUP: 层次汇总，生成 n+1 种组合</span></span><br><span class="line"><span class="keyword">SELECT</span> region, product, <span class="built_in">SUM</span>(sale_amount)</span><br><span class="line"><span class="keyword">FROM</span> sales</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">ROLLUP</span> (region, product);</span><br><span class="line"><span class="comment">-- 生成: (region, product), (region), ()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- CUBE: 所有组合，生成 2^n 种组合</span></span><br><span class="line"><span class="keyword">SELECT</span> region, product, <span class="built_in">SUM</span>(sale_amount)</span><br><span class="line"><span class="keyword">FROM</span> sales</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">CUBE</span> (region, product);</span><br><span class="line"><span class="comment">-- 生成: (region, product), (region), (product), ()</span></span><br></pre></td></tr></table></figure><p><strong>关键区别</strong>: <code>ROLLUP</code>不会生成<code>(product)</code>这种跳过<code>region</code>的组合。</p><ul><li><code>ROLLUP(n列)</code>生成 n+1 种分组（比<code>CUBE</code>少）</li><li>顺序很重要：<code>ROLLUP(A, B)</code> ≠ <code>ROLLUP(B, A)</code></li><li>适合层次化数据（如：年→月→日，国家→省→市）</li><li>PostgreSQL、SQL Server、Oracle 支持</li><li>MySQL 8.0+ 支持</li></ul><hr><h2 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h2><h3 id="30-PostgreSQL-子查询"><a href="#30-PostgreSQL-子查询" class="headerlink" title="30. PostgreSQL 子查询"></a>30. PostgreSQL 子查询</h3><ul><li>子查询是嵌套在另一个查询中的<code>SELECT</code>语句。子查询可以出现在<code>SELECT</code>、<code>FROM</code>、<code>WHERE</code>、<code>HAVING</code>等子句中，用于提供动态的过滤条件、计算值或临时表。</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 基本语法</span></span><br><span class="line"><span class="comment">-- WHERE子句中的子查询</span></span><br><span class="line"><span class="keyword">SELECT</span> column1, column2</span><br><span class="line"><span class="keyword">FROM</span> table1</span><br><span class="line"><span class="keyword">WHERE</span> column1 <span class="keyword">IN</span> (<span class="keyword">SELECT</span> column1 <span class="keyword">FROM</span> table2);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- FROM子句中的子查询</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> (<span class="keyword">SELECT</span> column1, column2 <span class="keyword">FROM</span> table1) <span class="keyword">AS</span> subquery;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- SELECT子句中的子查询</span></span><br><span class="line"><span class="keyword">SELECT</span> column1, (<span class="keyword">SELECT</span> <span class="built_in">MAX</span>(column2) <span class="keyword">FROM</span> table2) <span class="keyword">AS</span> max_value</span><br><span class="line"><span class="keyword">FROM</span> table1;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- employees</span></span><br><span class="line"><span class="comment">-- | id | name    | salary | department_id |</span></span><br><span class="line"><span class="comment">-- |----|---------|--------|---------------|</span></span><br><span class="line"><span class="comment">-- | 1  | Alice   | 60000  | 1             |</span></span><br><span class="line"><span class="comment">-- | 2  | Bob     | 55000  | 2             |</span></span><br><span class="line"><span class="comment">-- | 3  | Charlie | 70000  | 1             |</span></span><br><span class="line"><span class="comment">-- | 4  | David   | 50000  | 2             |</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- departments</span></span><br><span class="line"><span class="comment">-- | id | name       |</span></span><br><span class="line"><span class="comment">-- |----|------------|</span></span><br><span class="line"><span class="comment">-- | 1  | IT         |</span></span><br><span class="line"><span class="comment">-- | 2  | HR         |</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- WHERE子句：查询工资高于平均工资的员工</span></span><br><span class="line"><span class="keyword">SELECT</span> name, salary</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> salary <span class="operator">&gt;</span> (<span class="keyword">SELECT</span> <span class="built_in">AVG</span>(salary) <span class="keyword">FROM</span> employees);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询结果</span></span><br><span class="line"><span class="comment">-- | name    | salary |</span></span><br><span class="line"><span class="comment">-- |---------|--------|</span></span><br><span class="line"><span class="comment">-- | Alice   | 60000  |</span></span><br><span class="line"><span class="comment">-- | Charlie | 70000  |</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- FROM子句：查询每个部门的平均工资</span></span><br><span class="line"><span class="keyword">SELECT</span> d.name, avg_salary</span><br><span class="line"><span class="keyword">FROM</span> departments d</span><br><span class="line"><span class="keyword">JOIN</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> department_id, <span class="built_in">AVG</span>(salary) <span class="keyword">AS</span> avg_salary</span><br><span class="line">    <span class="keyword">FROM</span> employees</span><br><span class="line">    <span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id</span><br><span class="line">) dept_avg <span class="keyword">ON</span> d.id <span class="operator">=</span> dept_avg.department_id;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- SELECT子句：显示每个员工及其部门的平均工资</span></span><br><span class="line"><span class="keyword">SELECT</span> name, </span><br><span class="line">       salary,</span><br><span class="line">       (<span class="keyword">SELECT</span> <span class="built_in">AVG</span>(salary) </span><br><span class="line">        <span class="keyword">FROM</span> employees e2 </span><br><span class="line">        <span class="keyword">WHERE</span> e2.department_id <span class="operator">=</span> e1.department_id) <span class="keyword">AS</span> dept_avg</span><br><span class="line"><span class="keyword">FROM</span> employees e1;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- IN子句：查询IT部门的员工</span></span><br><span class="line"><span class="keyword">SELECT</span> name, salary</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> department_id <span class="keyword">IN</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> id <span class="keyword">FROM</span> departments <span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">&#x27;IT&#x27;</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- EXISTS子句：查询有员工的部门</span></span><br><span class="line"><span class="keyword">SELECT</span> name</span><br><span class="line"><span class="keyword">FROM</span> departments d</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">EXISTS</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="number">1</span> <span class="keyword">FROM</span> employees e <span class="keyword">WHERE</span> e.department_id <span class="operator">=</span> d.id</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h4 id="ANY-x2F-ALL-操作符"><a href="#ANY-x2F-ALL-操作符" class="headerlink" title="ANY&#x2F;ALL 操作符"></a>ANY&#x2F;ALL 操作符</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- ANY：满足任意一个条件</span></span><br><span class="line"><span class="keyword">SELECT</span> name, salary</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> salary <span class="operator">&gt;</span> <span class="keyword">ANY</span> (<span class="keyword">SELECT</span> salary <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> department_id <span class="operator">=</span> <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- ALL：满足所有条件</span></span><br><span class="line"><span class="keyword">SELECT</span> name, salary</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> salary <span class="operator">&gt;</span> <span class="keyword">ALL</span> (<span class="keyword">SELECT</span> salary <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> department_id <span class="operator">=</span> <span class="number">2</span>);</span><br></pre></td></tr></table></figure><ul><li>子查询必须用括号包裹</li><li><code>SELECT</code>子句中的子查询必须返回单个值</li><li><code>FROM</code>子句中的子查询必须有别名</li><li>相关子查询会对外部查询的每一行执行一次，性能较差</li><li>能用<code>JOIN</code>的地方优先用<code>JOIN</code>，通常性能更好</li></ul><hr><h3 id="31-ANY"><a href="#31-ANY" class="headerlink" title="31. ANY"></a>31. ANY</h3><ul><li><code>ANY</code>运算符用于将一个值与子查询返回的一组值进行比较。如果子查询的任何值满足条件，则返回<code>true</code>。</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 基本形式</span></span><br><span class="line"><span class="keyword">SELECT</span> title</span><br><span class="line"><span class="keyword">FROM</span> film</span><br><span class="line"><span class="keyword">WHERE</span> length <span class="operator">&gt;</span> <span class="keyword">ANY</span>(</span><br><span class="line">    <span class="keyword">SELECT</span> length <span class="keyword">FROM</span> film <span class="keyword">WHERE</span> category_id <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查找每个类别的最大电影时长</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">MAX</span>(length)</span><br><span class="line"><span class="keyword">FROM</span> film</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> film_category <span class="keyword">USING</span>(film_id)</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> category_id;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查找长度大于等于任何类别最大长度的电影</span></span><br><span class="line"><span class="keyword">SELECT</span> title</span><br><span class="line"><span class="keyword">FROM</span> film</span><br><span class="line"><span class="keyword">WHERE</span> length <span class="operator">&gt;=</span> <span class="keyword">ANY</span>(</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="built_in">MAX</span>(length)</span><br><span class="line">    <span class="keyword">FROM</span> film</span><br><span class="line">    <span class="keyword">INNER</span> <span class="keyword">JOIN</span> film_category <span class="keyword">USING</span>(film_id)</span><br><span class="line">    <span class="keyword">GROUP</span> <span class="keyword">BY</span> category_id</span><br><span class="line">);</span><br></pre></td></tr></table></figure><ul><li>子查询必须返回单列</li><li>如果子查询返回空结果集，整个查询返回空结果集</li><li><code>= ANY</code>等价于<code>IN</code></li><li><code>&lt;&gt; ANY</code><strong>不等价于</strong><code>NOT IN</code><ul><li><code>x &lt;&gt; ANY(a, b, c)</code>等价于<code>x &lt;&gt; a OR x &lt;&gt; b OR x &lt;&gt; c</code></li></ul></li></ul><hr><h3 id="32-ALL"><a href="#32-ALL" class="headerlink" title="32. ALL"></a>32. ALL</h3><ul><li><code>ALL</code>运算符用于将一个值与子查询返回的所有值进行比较。只有当值满足与子查询返回的所有值的比较条件时，才返回<code>true</code>。</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 基本形式</span></span><br><span class="line"><span class="keyword">SELECT</span> title</span><br><span class="line"><span class="keyword">FROM</span> film</span><br><span class="line"><span class="keyword">WHERE</span> length <span class="operator">&gt;</span> <span class="keyword">ALL</span>(</span><br><span class="line">    <span class="keyword">SELECT</span> length <span class="keyword">FROM</span> film <span class="keyword">WHERE</span> category_id <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><ul><li>ALL 运算符前面必须有比较运算符：<code>=</code>、<code>!=</code>、<code>&gt;</code>、<code>&gt;=</code>、<code>&lt;</code>、<code>&lt;=</code></li><li>ALL 运算符后面必须跟一个子查询，子查询也必须用括号括起来</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查询按电影评级分组的平均长度</span></span><br><span class="line"><span class="keyword">SELECT</span> ROUND(<span class="built_in">AVG</span>(length), <span class="number">2</span>) <span class="keyword">AS</span> avg_length</span><br><span class="line"><span class="keyword">FROM</span> film</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> rating</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> avg_length <span class="keyword">DESC</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查找长度大于所有平均长度的电影</span></span><br><span class="line"><span class="keyword">SELECT</span> film_id, </span><br><span class="line">       title, </span><br><span class="line">       length</span><br><span class="line"><span class="keyword">FROM</span> film</span><br><span class="line"><span class="keyword">WHERE</span> length <span class="operator">&gt;</span> <span class="keyword">ALL</span>(</span><br><span class="line">    <span class="keyword">SELECT</span> ROUND(<span class="built_in">AVG</span>(length), <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">FROM</span> film</span><br><span class="line">    <span class="keyword">GROUP</span> <span class="keyword">BY</span> rating</span><br><span class="line">)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> length;</span><br></pre></td></tr></table></figure><ul><li>子查询必须返回单列</li><li>如果子查询返回空结果集，ALL 运算符始终返回 true</li><li><code>&gt; ALL</code> 等价于”大于最大值”</li><li><code>&lt; ALL</code> 等价于”小于最小值”</li><li><code>!= ALL</code> 等价于 <code>NOT IN</code></li></ul><hr><h3 id="33-EXISTS"><a href="#33-EXISTS" class="headerlink" title="33. EXISTS"></a>33. EXISTS</h3><ul><li><code>EXISTS</code>运算符是一个布尔运算符，用于测试子查询中是否存在行。</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 基本形式</span></span><br><span class="line"><span class="keyword">SELECT</span> column1</span><br><span class="line"><span class="keyword">FROM</span> table_1</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">EXISTS</span>(</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">FROM</span> table_2</span><br><span class="line">    <span class="keyword">WHERE</span> column_2 <span class="operator">=</span> table_1.column_1</span><br><span class="line">);</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查找至少有一笔付款金额大于11的客户</span></span><br><span class="line"><span class="keyword">SELECT</span> first_name, last_name</span><br><span class="line"><span class="keyword">FROM</span> customer c</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">EXISTS</span>(</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">FROM</span> payment p</span><br><span class="line">    <span class="keyword">WHERE</span> p.customer_id <span class="operator">=</span> c.customer_id</span><br><span class="line">    <span class="keyword">AND</span> amount <span class="operator">&gt;</span> <span class="number">11</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> first_name, last_name;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- NOT EXISTS: 查找没有支付过金额大于11的客户</span></span><br><span class="line"><span class="keyword">SELECT</span> first_name, last_name</span><br><span class="line"><span class="keyword">FROM</span> customer c</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>(</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">FROM</span> payment p</span><br><span class="line">    <span class="keyword">WHERE</span> p.customer_id <span class="operator">=</span> c.customer_id</span><br><span class="line">    <span class="keyword">AND</span> amount <span class="operator">&gt;</span> <span class="number">11</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> first_name, last_name;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- EXISTS 和 NULL</span></span><br><span class="line"><span class="keyword">SELECT</span> first_name, last_name</span><br><span class="line"><span class="keyword">FROM</span> customer</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">EXISTS</span>(<span class="keyword">SELECT</span> <span class="keyword">NULL</span>)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> first_name, last_name;</span><br></pre></td></tr></table></figure><blockquote><p>子查询返回<code>NULL</code>时，<code>EXISTS</code>返回 true，因此查询返回<code>customer</code>表中的所有行。</p></blockquote><ul><li><code>EXISTS</code>只关心是否有行返回，不关心行的内容</li><li><code>NOT EXISTS</code>与<code>EXISTS</code>相反</li><li>如果子查询返回<code>NULL</code>，<code>EXISTS</code>返回 true</li><li><code>EXISTS</code>通常比<code>IN</code>性能更好，特别是子查询返回大量数据时</li></ul><hr><h2 id="公共表表达式"><a href="#公共表表达式" class="headerlink" title="公共表表达式"></a>公共表表达式</h2><h3 id="34-WITH-查询-CTE"><a href="#34-WITH-查询-CTE" class="headerlink" title="34. WITH 查询 (CTE)"></a>34. WITH 查询 (CTE)</h3><ul><li>公共表表达式（CTE，Common Table Expression）是一个临时结果集，您可以在另一个 SQL 语句中引用它。CTE 仅在查询执行期间存在。</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 基本形式</span></span><br><span class="line"><span class="keyword">WITH</span> cte_film <span class="keyword">AS</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> film_id, </span><br><span class="line">           title,</span><br><span class="line">           <span class="keyword">CASE</span> </span><br><span class="line">               <span class="keyword">WHEN</span> length <span class="operator">&lt;</span> <span class="number">30</span> <span class="keyword">THEN</span> <span class="string">&#x27;Short&#x27;</span></span><br><span class="line">               <span class="keyword">WHEN</span> length <span class="operator">&lt;</span> <span class="number">90</span> <span class="keyword">THEN</span> <span class="string">&#x27;Medium&#x27;</span></span><br><span class="line">               <span class="keyword">ELSE</span> <span class="string">&#x27;Long&#x27;</span></span><br><span class="line">           <span class="keyword">END</span> <span class="keyword">AS</span> length    </span><br><span class="line">    <span class="keyword">FROM</span> film</span><br><span class="line">)</span><br><span class="line"><span class="keyword">SELECT</span> film_id, title, length</span><br><span class="line"><span class="keyword">FROM</span> cte_film</span><br><span class="line"><span class="keyword">WHERE</span> length <span class="operator">=</span> <span class="string">&#x27;Long&#x27;</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> title;</span><br></pre></td></tr></table></figure><ul><li>首先，指定 CTE 的名称，后跟可选的列列表</li><li>其次，在<code>WITH</code>子句主体内，指定返回结果集的查询</li><li>第三，在<code>SELECT</code>、<code>INSERT</code>、<code>UPDATE</code>或<code>DELETE</code>等语句中，将 CTE 用作表或视图</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 将 CTE 与表连接</span></span><br><span class="line"><span class="keyword">WITH</span> cte_rental <span class="keyword">AS</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> staff_id,</span><br><span class="line">           <span class="built_in">COUNT</span>(rental_id) <span class="keyword">AS</span> rental_count</span><br><span class="line">    <span class="keyword">FROM</span> rental</span><br><span class="line">    <span class="keyword">GROUP</span> <span class="keyword">BY</span> staff_id</span><br><span class="line">)</span><br><span class="line"><span class="keyword">SELECT</span> s.staff_id,</span><br><span class="line">       first_name,</span><br><span class="line">       last_name,</span><br><span class="line">       rental_count</span><br><span class="line"><span class="keyword">FROM</span> staff s</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> cte_rental <span class="keyword">USING</span> (staff_id);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 将 CTE 与窗口函数结合使用</span></span><br><span class="line"><span class="keyword">WITH</span> cte_film <span class="keyword">AS</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> film_id,</span><br><span class="line">           title,</span><br><span class="line">           rating,</span><br><span class="line">           length,</span><br><span class="line">           <span class="built_in">RANK</span>() <span class="keyword">OVER</span> (</span><br><span class="line">               <span class="keyword">PARTITION</span> <span class="keyword">BY</span> rating</span><br><span class="line">               <span class="keyword">ORDER</span> <span class="keyword">BY</span> length <span class="keyword">DESC</span></span><br><span class="line">           ) <span class="keyword">AS</span> length_rank</span><br><span class="line">    <span class="keyword">FROM</span> film</span><br><span class="line">)</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> cte_film</span><br><span class="line"><span class="keyword">WHERE</span> length_rank <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 多个 CTE</span></span><br><span class="line"><span class="keyword">WITH</span> cte1 <span class="keyword">AS</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> table1 <span class="keyword">WHERE</span> condition1</span><br><span class="line">),</span><br><span class="line">cte2 <span class="keyword">AS</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> table2 <span class="keyword">WHERE</span> condition2</span><br><span class="line">)</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> cte1</span><br><span class="line"><span class="keyword">JOIN</span> cte2 <span class="keyword">ON</span> cte1.id <span class="operator">=</span> cte2.id;</span><br></pre></td></tr></table></figure><ul><li>CTE 是临时的，仅在查询执行期间存在</li><li>CTE 可以引用自身（递归 CTE）</li><li>可以在一个查询中定义多个 CTE</li><li>CTE 通常用于简化复杂连接和子查询</li></ul><hr><h2 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h2><h3 id="35-INSERT"><a href="#35-INSERT" class="headerlink" title="35. INSERT"></a>35. INSERT</h3><ul><li>PostgreSQL 的<code>INSERT</code>语句允许您将新行插入表中</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 基本形式</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> table_name(column1, column2, …)</span><br><span class="line"><span class="keyword">VALUES</span> (value1, value2, …);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 带 RETURNING 子句</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> table_name(column1, column2, …)</span><br><span class="line"><span class="keyword">VALUES</span> (value1, value2, …)</span><br><span class="line">RETURNING <span class="operator">*</span>;</span><br></pre></td></tr></table></figure><ul><li>首先，在<code>INSERT INTO</code>关键字后，指定要插入数据的表名和列列表</li><li>其次，在<code>VALUES</code>关键字后提供逗号分隔的值列表</li><li>列和值列表中的列和值必须具有相同的顺序</li><li><code>RETURNING</code>子句用于返回插入行的信息</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建示例表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> links (</span><br><span class="line">    id SERIAL <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    url <span class="type">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    description <span class="type">VARCHAR</span>(<span class="number">255</span>),</span><br><span class="line">    last_update <span class="type">DATE</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 将单行插入表中</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> links (url, name)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="string">&#x27;https://www.rockdata.net/tutorial/&#x27;</span>, <span class="string">&#x27;PostgreSQL Tutorial&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 插入包含单引号的字符串</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> links (url, name)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="string">&#x27;http://www.oreilly.com&#x27;</span>, <span class="string">&#x27;O&#x27;&#x27;Reilly Media&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 插入日期值</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> links (url, name, last_update)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="string">&#x27;https://www.google.com&#x27;</span>, <span class="string">&#x27;Google&#x27;</span>, <span class="string">&#x27;2013-06-01&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 获取最后插入的ID</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> links (url, name)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="string">&#x27;http://www.postgresql.org&#x27;</span>, <span class="string">&#x27;PostgreSQL&#x27;</span>) </span><br><span class="line">RETURNING id;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 返回整个插入行</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> links (url, name)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="string">&#x27;http://www.example.com&#x27;</span>, <span class="string">&#x27;Example&#x27;</span>)</span><br><span class="line">RETURNING <span class="operator">*</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 返回特定列</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> links (url, name, description)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="string">&#x27;http://www.test.com&#x27;</span>, <span class="string">&#x27;Test&#x27;</span>, <span class="string">&#x27;Test Description&#x27;</span>)</span><br><span class="line">RETURNING id, name;</span><br></pre></td></tr></table></figure><h4 id="获取最后插入ID"><a href="#获取最后插入ID" class="headerlink" title="获取最后插入ID"></a>获取最后插入ID</h4><ul><li>PostgreSQL<ul><li>RETURNING id - 直接返回插入的ID</li><li>currval(‘sequence_name’) - 获取序列当前值</li><li>lastval() - 获取最后使用的序列值</li></ul></li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 使用 RETURNING (推荐)</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> table_name (column1) <span class="keyword">VALUES</span> (value1) RETURNING id;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 使用序列函数</span></span><br><span class="line"><span class="keyword">SELECT</span> currval(<span class="string">&#x27;table_name_id_seq&#x27;</span>);</span><br><span class="line"><span class="keyword">SELECT</span> lastval();</span><br></pre></td></tr></table></figure><ul><li>SQL Server<ul><li>SCOPE_IDENTITY() - 当前作用域最后插入的标识值（最常用）</li><li>@@IDENTITY - 当前会话最后插入的标识值</li><li>IDENT_CURRENT(‘table’) - 指定表的最后标识值</li></ul></li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 使用 OUTPUT</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> table_name (column1) OUTPUT INSERTED.id <span class="keyword">VALUES</span> (value1);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 使用标识函数</span></span><br><span class="line"><span class="keyword">SELECT</span> SCOPE_IDENTITY();  <span class="comment">-- 当前作用域 (推荐)</span></span><br><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@IDENTITY</span>;        <span class="comment">-- 当前会话</span></span><br><span class="line"><span class="keyword">SELECT</span> IDENT_CURRENT(<span class="string">&#x27;table_name&#x27;</span>);  <span class="comment">-- 指定表</span></span><br></pre></td></tr></table></figure><hr><h3 id="36-INSERT-插入多行"><a href="#36-INSERT-插入多行" class="headerlink" title="36. INSERT 插入多行"></a>36. INSERT 插入多行</h3><ul><li>要使用单个<code>INSERT</code>语句将多行插入表中，可以在<code>VALUES</code>子句中提供多个值列表</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 基本形式</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> table_name (column_list)</span><br><span class="line"><span class="keyword">VALUES</span></span><br><span class="line">    (value_list_1),</span><br><span class="line">    (value_list_2),</span><br><span class="line">    ...</span><br><span class="line">    (value_list_n);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 带 RETURNING 子句</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> table_name (column_list)</span><br><span class="line"><span class="keyword">VALUES</span></span><br><span class="line">    (value_list_1),</span><br><span class="line">    (value_list_2),</span><br><span class="line">    ...</span><br><span class="line">    (value_list_n)</span><br><span class="line">RETURNING <span class="operator">*</span> <span class="operator">|</span> output_expression;</span><br></pre></td></tr></table></figure><ul><li>首先，在<code>INSERT INTO</code>关键字后指定要插入数据的表名</li><li>其次，在表名称后面的括号中列出表中所需的列</li><li>第三，在<code>VALUES</code>关键字后面提供以逗号分隔的行列表</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- employees</span></span><br><span class="line"><span class="comment">-- | employee_id | name    | department | salary |</span></span><br><span class="line"><span class="comment">-- |-------------|---------|------------|--------|</span></span><br><span class="line"><span class="comment">-- | 1           | Alice   | IT         | 60000  |</span></span><br><span class="line"><span class="comment">-- | 2           | Bob     | Sales      | 55000  |</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 插入多行</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employees (name, department, salary)</span><br><span class="line"><span class="keyword">VALUES</span></span><br><span class="line">    (<span class="string">&#x27;Charlie&#x27;</span>, <span class="string">&#x27;IT&#x27;</span>, <span class="number">65000</span>),</span><br><span class="line">    (<span class="string">&#x27;David&#x27;</span>, <span class="string">&#x27;HR&#x27;</span>, <span class="number">50000</span>),</span><br><span class="line">    (<span class="string">&#x27;Eve&#x27;</span>, <span class="string">&#x27;Sales&#x27;</span>, <span class="number">58000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 插入多行并返回所有列</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employees (name, department, salary)</span><br><span class="line"><span class="keyword">VALUES</span></span><br><span class="line">    (<span class="string">&#x27;Frank&#x27;</span>, <span class="string">&#x27;IT&#x27;</span>, <span class="number">62000</span>),</span><br><span class="line">    (<span class="string">&#x27;Grace&#x27;</span>, <span class="string">&#x27;Marketing&#x27;</span>, <span class="number">56000</span>)</span><br><span class="line">RETURNING <span class="operator">*</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 插入多行并只返回 ID</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employees (name, department, salary)</span><br><span class="line"><span class="keyword">VALUES</span></span><br><span class="line">    (<span class="string">&#x27;Henry&#x27;</span>, <span class="string">&#x27;Finance&#x27;</span>, <span class="number">70000</span>),</span><br><span class="line">    (<span class="string">&#x27;Ivy&#x27;</span>, <span class="string">&#x27;HR&#x27;</span>, <span class="number">52000</span>)</span><br><span class="line">RETURNING employee_id;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 插入多行并返回特定列</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employees (name, department, salary)</span><br><span class="line"><span class="keyword">VALUES</span></span><br><span class="line">    (<span class="string">&#x27;Jack&#x27;</span>, <span class="string">&#x27;Sales&#x27;</span>, <span class="number">59000</span>),</span><br><span class="line">    (<span class="string">&#x27;Kate&#x27;</span>, <span class="string">&#x27;IT&#x27;</span>, <span class="number">67000</span>)</span><br><span class="line">RETURNING employee_id, name, department;</span><br></pre></td></tr></table></figure><ul><li>使用单个<code>INSERT</code>语句插入多行比多个单行<code>INSERT</code>语句性能更好</li><li>每个值列表必须包含相同数量的值，且顺序与列列表匹配</li><li>可以使用<code>RETURNING</code>子句返回插入的行或特定列</li><li>PostgreSQL返回格式为<code>INSERT 0 n</code>，其中<code>n</code>是插入的行数</li></ul><hr><h3 id="37-UNNEST-批量插入"><a href="#37-UNNEST-批量插入" class="headerlink" title="37. UNNEST 批量插入"></a>37. UNNEST 批量插入</h3><ul><li><code>UNNEST</code>是PostgreSQL中用于将数组展开成行的函数，常用于批量插入数据 (Bulk Upsert&#x2F;Insert)</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 基本形式</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> table_name (column1, column2, ...)</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="built_in">UNNEST</span>(</span><br><span class="line">    <span class="keyword">ARRAY</span>[value1_1, value1_2, ...],</span><br><span class="line">    <span class="keyword">ARRAY</span>[value2_1, value2_2, ...]</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 带 RETURNING 子句</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> table_name (column1, column2, ...)</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="built_in">UNNEST</span>(</span><br><span class="line">    <span class="keyword">ARRAY</span>[value1_1, value1_2, ...],</span><br><span class="line">    <span class="keyword">ARRAY</span>[value2_1, value2_2, ...]</span><br><span class="line">)</span><br><span class="line">RETURNING <span class="operator">*</span>;</span><br></pre></td></tr></table></figure><ul><li><code>UNNEST</code>将多个数组并行展开成行</li><li>每个数组对应一列</li><li>所有数组必须具有相同的长度</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建示例表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> products (</span><br><span class="line">    id SERIAL <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    price <span class="type">DECIMAL</span>(<span class="number">10</span>, <span class="number">2</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    category <span class="type">VARCHAR</span>(<span class="number">100</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 使用 UNNEST 批量插入</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> products (name, price, category)</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="built_in">UNNEST</span>(</span><br><span class="line">    <span class="keyword">ARRAY</span>[<span class="string">&#x27;Laptop&#x27;</span>, <span class="string">&#x27;Mouse&#x27;</span>, <span class="string">&#x27;Keyboard&#x27;</span>],</span><br><span class="line">    <span class="keyword">ARRAY</span>[<span class="number">999.99</span>, <span class="number">29.99</span>, <span class="number">79.99</span>],</span><br><span class="line">    <span class="keyword">ARRAY</span>[<span class="string">&#x27;Electronics&#x27;</span>, <span class="string">&#x27;Electronics&#x27;</span>, <span class="string">&#x27;Electronics&#x27;</span>]</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 使用 UNNEST 并返回插入的行</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> products (name, price, category)</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="built_in">UNNEST</span>(</span><br><span class="line">    <span class="keyword">ARRAY</span>[<span class="string">&#x27;Monitor&#x27;</span>, <span class="string">&#x27;Webcam&#x27;</span>],</span><br><span class="line">    <span class="keyword">ARRAY</span>[<span class="number">299.99</span>, <span class="number">89.99</span>],</span><br><span class="line">    <span class="keyword">ARRAY</span>[<span class="string">&#x27;Electronics&#x27;</span>, <span class="string">&#x27;Electronics&#x27;</span>]</span><br><span class="line">)</span><br><span class="line">RETURNING <span class="operator">*</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 使用 UNNEST 只返回 ID</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> products (name, price, category)</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="built_in">UNNEST</span>(</span><br><span class="line">    <span class="keyword">ARRAY</span>[<span class="string">&#x27;Headphones&#x27;</span>, <span class="string">&#x27;Speaker&#x27;</span>],</span><br><span class="line">    <span class="keyword">ARRAY</span>[<span class="number">149.99</span>, <span class="number">199.99</span>],</span><br><span class="line">    <span class="keyword">ARRAY</span>[<span class="string">&#x27;Electronics&#x27;</span>, <span class="string">&#x27;Electronics&#x27;</span>]</span><br><span class="line">)</span><br><span class="line">RETURNING id;</span><br></pre></td></tr></table></figure><h4 id="UNNEST-vs-VALUES"><a href="#UNNEST-vs-VALUES" class="headerlink" title="UNNEST vs VALUES"></a>UNNEST vs VALUES</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 方式1: 传统 VALUES</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> products (name, price)</span><br><span class="line"><span class="keyword">VALUES</span></span><br><span class="line">    (<span class="string">&#x27;Laptop&#x27;</span>, <span class="number">999.99</span>),</span><br><span class="line">    (<span class="string">&#x27;Mouse&#x27;</span>, <span class="number">29.99</span>),</span><br><span class="line">    (<span class="string">&#x27;Keyboard&#x27;</span>, <span class="number">79.99</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 方式2: UNNEST (等价)</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> products (name, price)</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="built_in">UNNEST</span>(</span><br><span class="line">    <span class="keyword">ARRAY</span>[<span class="string">&#x27;Laptop&#x27;</span>, <span class="string">&#x27;Mouse&#x27;</span>, <span class="string">&#x27;Keyboard&#x27;</span>],</span><br><span class="line">    <span class="keyword">ARRAY</span>[<span class="number">999.99</span>, <span class="number">29.99</span>, <span class="number">79.99</span>]</span><br><span class="line">);</span><br></pre></td></tr></table></figure><ul><li>所有数组必须具有相同的长度，否则会报错</li><li><code>UNNEST</code>适合从程序传入数组参数的场景</li><li>对于大批量插入，<code>UNNEST</code>可能比多个<code>VALUES</code>性能更好</li><li>数组元素类型需要与目标列类型匹配</li><li>可以使用类型转换，如<code>ARRAY[...]::type[]</code></li></ul><hr><h3 id="38-UPDATE"><a href="#38-UPDATE" class="headerlink" title="38. UPDATE"></a>38. UPDATE</h3><ul><li>PostgreSQL 的<code>UPDATE</code>语句允许修改表中的现有数据</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 基本形式</span></span><br><span class="line"><span class="keyword">UPDATE</span> table_name</span><br><span class="line"><span class="keyword">SET</span> column1 <span class="operator">=</span> value1,</span><br><span class="line">    column2 <span class="operator">=</span> value2,</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">condition</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 带 RETURNING 子句</span></span><br><span class="line"><span class="keyword">UPDATE</span> table_name</span><br><span class="line"><span class="keyword">SET</span> column1 <span class="operator">=</span> value1,</span><br><span class="line">    column2 <span class="operator">=</span> value2,</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">condition</span></span><br><span class="line">RETURNING <span class="operator">*</span> <span class="operator">|</span> output_expression;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- employees</span></span><br><span class="line"><span class="comment">-- | employee_id | name    | salary | department |</span></span><br><span class="line"><span class="comment">-- |-------------|---------|--------|------------|</span></span><br><span class="line"><span class="comment">-- | 1           | Alice   | 60000  | IT         |</span></span><br><span class="line"><span class="comment">-- | 2           | Bob     | 55000  | Sales      |</span></span><br><span class="line"><span class="comment">-- | 3           | Charlie | 50000  | Sales      |</span></span><br><span class="line"><span class="comment">-- | 4           | David   | 65000  | IT         |</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 更新单行</span></span><br><span class="line"><span class="keyword">UPDATE</span> employees</span><br><span class="line"><span class="keyword">SET</span> salary <span class="operator">=</span> <span class="number">70000</span></span><br><span class="line"><span class="keyword">WHERE</span> employee_id <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 更新多列</span></span><br><span class="line"><span class="keyword">UPDATE</span> employees</span><br><span class="line"><span class="keyword">SET</span> salary <span class="operator">=</span> <span class="number">72000</span>,</span><br><span class="line">    department <span class="operator">=</span> <span class="string">&#x27;IT&#x27;</span></span><br><span class="line"><span class="keyword">WHERE</span> employee_id <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 更新并返回更新后的行</span></span><br><span class="line"><span class="keyword">UPDATE</span> employees</span><br><span class="line"><span class="keyword">SET</span> salary <span class="operator">=</span> salary <span class="operator">*</span> <span class="number">1.1</span></span><br><span class="line"><span class="keyword">WHERE</span> department <span class="operator">=</span> <span class="string">&#x27;Sales&#x27;</span></span><br><span class="line">RETURNING <span class="operator">*</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 只返回特定列</span></span><br><span class="line"><span class="keyword">UPDATE</span> employees</span><br><span class="line"><span class="keyword">SET</span> department <span class="operator">=</span> <span class="string">&#x27;Marketing&#x27;</span></span><br><span class="line"><span class="keyword">WHERE</span> employee_id <span class="operator">=</span> <span class="number">2</span></span><br><span class="line">RETURNING employee_id, name, department;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 使用表达式更新</span></span><br><span class="line"><span class="keyword">UPDATE</span> employees</span><br><span class="line"><span class="keyword">SET</span> salary <span class="operator">=</span> salary <span class="operator">+</span> <span class="number">5000</span></span><br><span class="line"><span class="keyword">WHERE</span> salary <span class="operator">&lt;</span> <span class="number">60000</span>;</span><br></pre></td></tr></table></figure><ul><li><code>WHERE</code>子句是可选的，但省略时会更新所有行，需谨慎使用</li><li><code>UPDATE</code>语句返回<code>UPDATE count</code>，其中<code>count</code>是更新的行数</li><li><code>SET</code>子句中未出现的列保留其原始值</li><li>可以使用<code>RETURNING</code>子句返回更新后的行</li><li>可以在<code>SET</code>子句中使用表达式或其他列的值</li></ul><hr><h3 id="39-UPDATE-JOIN"><a href="#39-UPDATE-JOIN" class="headerlink" title="39. UPDATE JOIN"></a>39. UPDATE JOIN</h3><ul><li>有时，需要根据另一个表中的值更新表中的数据。在这种情况下，可以使用 PostgreSQL 的 UPDATE 连接语法。</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 基本形式</span></span><br><span class="line"><span class="keyword">UPDATE</span> t1</span><br><span class="line"><span class="keyword">SET</span> t1.c1 <span class="operator">=</span> new_value</span><br><span class="line"><span class="keyword">FROM</span> t2</span><br><span class="line"><span class="keyword">WHERE</span> t1.c2 <span class="operator">=</span> t2.c2;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 使用表别名</span></span><br><span class="line"><span class="keyword">UPDATE</span> t1</span><br><span class="line"><span class="keyword">SET</span> c1 <span class="operator">=</span> new_value</span><br><span class="line"><span class="keyword">FROM</span> t2</span><br><span class="line"><span class="keyword">WHERE</span> t1.c2 <span class="operator">=</span> t2.c2;</span><br></pre></td></tr></table></figure><ul><li>在<code>FROM</code>子句中指定要连接的表</li><li>在<code>WHERE</code>子句中提供连接条件</li><li><code>FROM</code>子句必须紧接在<code>SET</code>子句之后出现</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建 product_segment 表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> product_segment (</span><br><span class="line">    id SERIAL <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    segment <span class="type">VARCHAR</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    discount <span class="type">NUMERIC</span>(<span class="number">4</span>, <span class="number">2</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> product_segment (segment, discount)</span><br><span class="line"><span class="keyword">VALUES</span></span><br><span class="line">    (<span class="string">&#x27;Grand Luxury&#x27;</span>, <span class="number">0.05</span>),</span><br><span class="line">    (<span class="string">&#x27;Luxury&#x27;</span>, <span class="number">0.06</span>),</span><br><span class="line">    (<span class="string">&#x27;Mass&#x27;</span>, <span class="number">0.10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建 product 表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> product(</span><br><span class="line">    id SERIAL <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    name <span class="type">VARCHAR</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    price <span class="type">NUMERIC</span>(<span class="number">10</span>, <span class="number">2</span>),</span><br><span class="line">    net_price <span class="type">NUMERIC</span>(<span class="number">10</span>, <span class="number">2</span>),</span><br><span class="line">    segment_id <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    <span class="keyword">FOREIGN</span> KEY(segment_id) <span class="keyword">REFERENCES</span> product_segment(id)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> product (name, price, segment_id) </span><br><span class="line"><span class="keyword">VALUES</span> </span><br><span class="line">    (<span class="string">&#x27;diam&#x27;</span>, <span class="number">804.89</span>, <span class="number">1</span>),</span><br><span class="line">    (<span class="string">&#x27;vestibulum aliquet&#x27;</span>, <span class="number">228.55</span>, <span class="number">3</span>),</span><br><span class="line">    (<span class="string">&#x27;lacinia erat&#x27;</span>, <span class="number">366.45</span>, <span class="number">2</span>),</span><br><span class="line">    (<span class="string">&#x27;scelerisque quam turpis&#x27;</span>, <span class="number">145.33</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 根据产品细分的折扣计算净价</span></span><br><span class="line"><span class="keyword">UPDATE</span> product</span><br><span class="line"><span class="keyword">SET</span> net_price <span class="operator">=</span> price <span class="operator">-</span> price <span class="operator">*</span> discount</span><br><span class="line"><span class="keyword">FROM</span> product_segment</span><br><span class="line"><span class="keyword">WHERE</span> product.segment_id <span class="operator">=</span> product_segment.id;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 使用表别名简化查询</span></span><br><span class="line"><span class="keyword">UPDATE</span> product p</span><br><span class="line"><span class="keyword">SET</span> net_price <span class="operator">=</span> price <span class="operator">-</span> price <span class="operator">*</span> discount</span><br><span class="line"><span class="keyword">FROM</span> product_segment s</span><br><span class="line"><span class="keyword">WHERE</span> p.segment_id <span class="operator">=</span> s.id;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 更新并返回结果</span></span><br><span class="line"><span class="keyword">UPDATE</span> product p</span><br><span class="line"><span class="keyword">SET</span> net_price <span class="operator">=</span> price <span class="operator">-</span> price <span class="operator">*</span> discount</span><br><span class="line"><span class="keyword">FROM</span> product_segment s</span><br><span class="line"><span class="keyword">WHERE</span> p.segment_id <span class="operator">=</span> s.id</span><br><span class="line">RETURNING p.id, p.name, p.price, p.net_price;</span><br></pre></td></tr></table></figure><ul><li><code>FROM</code>子句允许在<code>UPDATE</code>中引用其他表</li><li>可以使用任何类型的连接（INNER JOIN、LEFT JOIN等）</li><li>使用表别名可以简化查询</li><li>可以结合<code>RETURNING</code>子句返回更新后的行</li><li>如果连接产生多个匹配行，可能会导致意外的更新结果</li></ul><hr><h3 id="40-DELETE"><a href="#40-DELETE" class="headerlink" title="40. DELETE"></a>40. DELETE</h3><ul><li>PostgreSQL 的<code>DELETE</code>语句允许从表中删除一行或多行</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 基本形式</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">condition</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 带 RETURNING 子句</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">condition</span></span><br><span class="line">RETURNING <span class="operator">*</span> <span class="operator">|</span> select_list;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- employees</span></span><br><span class="line"><span class="comment">-- | id | name    | department | salary |</span></span><br><span class="line"><span class="comment">-- |----|---------|------------|--------|</span></span><br><span class="line"><span class="comment">-- | 1  | Alice   | IT         | 60000  |</span></span><br><span class="line"><span class="comment">-- | 2  | Bob     | HR         | 55000  |</span></span><br><span class="line"><span class="comment">-- | 3  | Charlie | IT         | 70000  |</span></span><br><span class="line"><span class="comment">-- | 4  | David   | Sales      | 50000  |</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除一行</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除并返回删除的行</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">3</span></span><br><span class="line">RETURNING <span class="operator">*</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除多行</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> department <span class="operator">=</span> <span class="string">&#x27;IT&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 只返回特定列</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">2</span></span><br><span class="line">RETURNING id, name;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除所有行</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> employees;</span><br></pre></td></tr></table></figure><ul><li><code>WHERE</code>子句是可选的，但省略时会删除所有行，需谨慎使用</li><li><code>DELETE</code>语句返回删除的行数，如果未删除任何行则返回 0</li><li>可以使用<code>RETURNING</code>子句返回已删除的行</li><li><code>DELETE</code>语句仅删除数据，不修改表结构</li><li>如果要修改表结构（如删除列），应使用<code>ALTER TABLE</code>语句</li><li>删除大量数据时，考虑使用<code>TRUNCATE</code>以获得更好的性能</li></ul><hr><h3 id="41-TRUNCATE"><a href="#41-TRUNCATE" class="headerlink" title="41. TRUNCATE"></a>41. TRUNCATE</h3><ul><li><code>TRUNCATE</code>语句用于快速删除表中的所有数据。与<code>DELETE</code>相比，<code>TRUNCATE</code>性能更高，但功能更受限</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 基本形式</span></span><br><span class="line"><span class="keyword">TRUNCATE</span> <span class="keyword">TABLE</span> table_name;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 多个表</span></span><br><span class="line"><span class="keyword">TRUNCATE</span> <span class="keyword">TABLE</span> table_name1, table_name2, ...;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 重置自增序列</span></span><br><span class="line"><span class="keyword">TRUNCATE</span> <span class="keyword">TABLE</span> table_name RESTART <span class="keyword">IDENTITY</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 级联删除</span></span><br><span class="line"><span class="keyword">TRUNCATE</span> <span class="keyword">TABLE</span> table_name CASCADE;</span><br></pre></td></tr></table></figure><ul><li><code>TRUNCATE</code>比<code>DELETE</code>快得多</li><li><code>TRUNCATE</code>不能使用<code>WHERE</code>子句</li><li><code>TRUNCATE</code>会重置自增序列（使用<code>RESTART IDENTITY</code>）</li><li><code>TRUNCATE</code>不触发<code>DELETE</code>触发器</li><li><code>TRUNCATE</code>需要表的所有者权限或<code>TRUNCATE</code>权限</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- orders</span></span><br><span class="line"><span class="comment">-- | order_id | customer_id | amount | order_date |</span></span><br><span class="line"><span class="comment">-- |----------|-------------|--------|------------|</span></span><br><span class="line"><span class="comment">-- | 1        | 101         | 250.00 | 2024-01-15 |</span></span><br><span class="line"><span class="comment">-- | 2        | 102         | 180.00 | 2024-01-16 |</span></span><br><span class="line"><span class="comment">-- | 3        | 101         | 320.00 | 2024-01-17 |</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除所有数据</span></span><br><span class="line"><span class="keyword">TRUNCATE</span> <span class="keyword">TABLE</span> orders;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除数据并重置自增ID</span></span><br><span class="line"><span class="keyword">TRUNCATE</span> <span class="keyword">TABLE</span> orders RESTART <span class="keyword">IDENTITY</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 同时清空多个表</span></span><br><span class="line"><span class="keyword">TRUNCATE</span> <span class="keyword">TABLE</span> orders, order_items;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 级联删除（如果有外键引用）</span></span><br><span class="line"><span class="keyword">TRUNCATE</span> <span class="keyword">TABLE</span> orders CASCADE;</span><br></pre></td></tr></table></figure><ul><li><code>TRUNCATE</code>不能在有外键约束的表上使用，除非使用<code>CASCADE</code></li><li><code>TRUNCATE</code>操作不能回滚（在某些事务配置下）</li><li><code>TRUNCATE</code>不记录单独的行删除日志</li><li>使用<code>RESTART IDENTITY</code>重置序列从1开始</li><li>使用<code>CONTINUE IDENTITY</code>保持序列当前值（默认）</li></ul><hr><h3 id="42-UPSERT"><a href="#42-UPSERT" class="headerlink" title="42. UPSERT"></a>42. UPSERT</h3><ul><li>在关系数据库中，upsert（更新或插入的组合）指的是当您向表中插入新行时，如果该行已存在，PostgreSQL 将更新该行，否则，它将插入新行</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> table_name(column_list) </span><br><span class="line"><span class="keyword">VALUES</span>(value_list)</span><br><span class="line"><span class="keyword">ON</span> CONFLICT target action;</span><br></pre></td></tr></table></figure><p><strong>target 可以是</strong></p><ul><li><code>(column_name)</code> - 列名称</li><li><code>ON CONSTRAINT constraint_name</code> - UNIQUE 约束的名称</li><li><code>WHERE predicate</code> - 带有谓词的 WHERE 子句</li></ul><p><strong>action 可以是</strong></p><ul><li><code>DO NOTHING</code> - 如果该行已存在，则不执行任何操作</li><li><code>DO UPDATE SET column_1 = value_1, ... WHERE condition</code> - 更新表中的字段</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建示例表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> customers (</span><br><span class="line">    customer_id SERIAL <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    name <span class="type">VARCHAR</span> <span class="keyword">UNIQUE</span>,</span><br><span class="line">    email <span class="type">VARCHAR</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    active BOOL <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="literal">TRUE</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> customers (name, email)</span><br><span class="line"><span class="keyword">VALUES</span> </span><br><span class="line">    (<span class="string">&#x27;IBM&#x27;</span>, <span class="string">&#x27;contact@ibm.com&#x27;</span>),</span><br><span class="line">    (<span class="string">&#x27;Microsoft&#x27;</span>, <span class="string">&#x27;contact@microsoft.com&#x27;</span>),</span><br><span class="line">    (<span class="string">&#x27;Intel&#x27;</span>, <span class="string">&#x27;contact@intel.com&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- customers</span></span><br><span class="line"><span class="comment">-- | customer_id | name      | email                  | active |</span></span><br><span class="line"><span class="comment">-- |-------------|-----------|------------------------|--------|</span></span><br><span class="line"><span class="comment">-- | 1           | IBM       | contact@ibm.com        | true   |</span></span><br><span class="line"><span class="comment">-- | 2           | Microsoft | contact@microsoft.com  | true   |</span></span><br><span class="line"><span class="comment">-- | 3           | Intel     | contact@intel.com      | true   |</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- DO NOTHING: 如果冲突则忽略</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> customers (name, email)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="string">&#x27;Microsoft&#x27;</span>, <span class="string">&#x27;hotline@microsoft.com&#x27;</span>) </span><br><span class="line"><span class="keyword">ON</span> CONFLICT (name) </span><br><span class="line">DO NOTHING;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 使用约束名称</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> customers (name, email)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="string">&#x27;Microsoft&#x27;</span>, <span class="string">&#x27;hotline@microsoft.com&#x27;</span>) </span><br><span class="line"><span class="keyword">ON</span> CONFLICT <span class="keyword">ON</span> <span class="keyword">CONSTRAINT</span> customers_name_key </span><br><span class="line">DO NOTHING;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- DO UPDATE: 如果冲突则更新</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> customers (name, email)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="string">&#x27;Microsoft&#x27;</span>, <span class="string">&#x27;hotline@microsoft.com&#x27;</span>) </span><br><span class="line"><span class="keyword">ON</span> CONFLICT (name) </span><br><span class="line">DO <span class="keyword">UPDATE</span> <span class="keyword">SET</span> email <span class="operator">=</span> EXCLUDED.email;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 拼接新旧值</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> customers (name, email)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="string">&#x27;Microsoft&#x27;</span>, <span class="string">&#x27;hotline@microsoft.com&#x27;</span>) </span><br><span class="line"><span class="keyword">ON</span> CONFLICT (name) </span><br><span class="line">DO <span class="keyword">UPDATE</span> <span class="keyword">SET</span> email <span class="operator">=</span> EXCLUDED.email <span class="operator">||</span> <span class="string">&#x27;;&#x27;</span> <span class="operator">||</span> customers.email;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 更新多个列</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> customers (name, email, active)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="string">&#x27;IBM&#x27;</span>, <span class="string">&#x27;newemail@ibm.com&#x27;</span>, <span class="literal">false</span>) </span><br><span class="line"><span class="keyword">ON</span> CONFLICT (name) </span><br><span class="line">DO <span class="keyword">UPDATE</span> <span class="keyword">SET</span> </span><br><span class="line">    email <span class="operator">=</span> EXCLUDED.email,</span><br><span class="line">    active <span class="operator">=</span> EXCLUDED.active;</span><br></pre></td></tr></table></figure><h4 id="EXCLUDED-关键字"><a href="#EXCLUDED-关键字" class="headerlink" title="EXCLUDED 关键字"></a>EXCLUDED 关键字</h4><ul><li><code>EXCLUDED</code>是一个特殊的表引用，代表要插入的行的值。</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- EXCLUDED.column_name 表示要插入的新值</span></span><br><span class="line"><span class="comment">-- table_name.column_name 表示表中已存在的旧值</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> customers (name, email)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="string">&#x27;Microsoft&#x27;</span>, <span class="string">&#x27;new@microsoft.com&#x27;</span>) </span><br><span class="line"><span class="keyword">ON</span> CONFLICT (name) </span><br><span class="line">DO <span class="keyword">UPDATE</span> <span class="keyword">SET</span> </span><br><span class="line">    email <span class="operator">=</span> EXCLUDED.email;  <span class="comment">-- 使用新值</span></span><br></pre></td></tr></table></figure><ul><li><code>ON CONFLICT</code>子句仅在 PostgreSQL 9.5+ 可用</li><li>必须有 UNIQUE 约束或 PRIMARY KEY 才能使用 ON CONFLICT</li><li><code>DO NOTHING</code>不返回任何内容</li><li><code>DO UPDATE</code>可以使用<code>WHERE</code>子句来限制更新条件</li><li><code>EXCLUDED</code>引用要插入的行的值</li><li>类似 MySQL 的<code>INSERT ON DUPLICATE KEY UPDATE</code></li></ul><hr><h3 id="43-MERGE"><a href="#43-MERGE" class="headerlink" title="43. MERGE"></a>43. MERGE</h3><ul><li>PostgreSQL 15 引入了<code>MERGE</code>语句，可将<code>INSERT</code>、<code>UPDATE</code>和<code>DELETE</code>操作合并到一个语句中，来简化数据操作。<code>MERGE</code>语句通常被称为 UPSERT 语句</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">MERGE</span> <span class="keyword">INTO</span> target_table</span><br><span class="line"><span class="keyword">USING</span> source_query</span><br><span class="line"><span class="keyword">ON</span> merge_condition</span><br><span class="line"><span class="keyword">WHEN</span> MATCHED [<span class="keyword">AND</span> <span class="keyword">condition</span>] <span class="keyword">THEN</span> &#123;merge_update <span class="operator">|</span> merge_delete <span class="operator">|</span> DO NOTHING&#125;</span><br><span class="line"><span class="keyword">WHEN</span> <span class="keyword">NOT</span> MATCHED [<span class="keyword">AND</span> <span class="keyword">condition</span>] <span class="keyword">THEN</span> &#123;merge_insert <span class="operator">|</span> DO NOTHING&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建示例表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> leads(</span><br><span class="line">    lead_id SERIAL <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    email <span class="type">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">UNIQUE</span>,</span><br><span class="line">    active BOOL <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="literal">TRUE</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> customers(</span><br><span class="line">    customer_id SERIAL <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    email <span class="type">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">UNIQUE</span>,</span><br><span class="line">    active BOOL <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="literal">TRUE</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 插入数据到 leads</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> leads(name, email)</span><br><span class="line"><span class="keyword">VALUES</span></span><br><span class="line">   (<span class="string">&#x27;John Doe&#x27;</span>, <span class="string">&#x27;john.doe@gmail.com&#x27;</span>),</span><br><span class="line">   (<span class="string">&#x27;Jane Doe&#x27;</span>, <span class="string">&#x27;jane.doe@yahoo.com&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 示例1: 插入不匹配的行</span></span><br><span class="line"><span class="keyword">MERGE</span> <span class="keyword">INTO</span> customers c</span><br><span class="line"><span class="keyword">USING</span> leads l <span class="keyword">ON</span> c.email <span class="operator">=</span> l.email</span><br><span class="line"><span class="keyword">WHEN</span> <span class="keyword">NOT</span> MATCHED <span class="keyword">THEN</span> </span><br><span class="line">   <span class="keyword">INSERT</span> (name, email)</span><br><span class="line">   <span class="keyword">VALUES</span>(l.name, l.email);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 示例2: 插入和更新</span></span><br><span class="line"><span class="keyword">MERGE</span> <span class="keyword">INTO</span> customers c</span><br><span class="line"><span class="keyword">USING</span> leads l <span class="keyword">ON</span> c.email <span class="operator">=</span> l.email</span><br><span class="line"><span class="keyword">WHEN</span> <span class="keyword">NOT</span> MATCHED <span class="keyword">THEN</span> </span><br><span class="line">   <span class="keyword">INSERT</span> (name, email)</span><br><span class="line">   <span class="keyword">VALUES</span>(l.name, l.email)</span><br><span class="line"><span class="keyword">WHEN</span> MATCHED <span class="keyword">THEN</span></span><br><span class="line">   <span class="keyword">UPDATE</span> <span class="keyword">SET</span> </span><br><span class="line">      name <span class="operator">=</span> l.name, </span><br><span class="line">      email <span class="operator">=</span> l.email;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 示例3: 插入、更新和删除</span></span><br><span class="line"><span class="keyword">MERGE</span> <span class="keyword">INTO</span> customers c</span><br><span class="line"><span class="keyword">USING</span> leads l <span class="keyword">ON</span> c.email <span class="operator">=</span> l.email</span><br><span class="line"><span class="keyword">WHEN</span> <span class="keyword">NOT</span> MATCHED <span class="keyword">THEN</span> </span><br><span class="line">   <span class="keyword">INSERT</span> (name, email)</span><br><span class="line">   <span class="keyword">VALUES</span>(l.name, l.email)</span><br><span class="line"><span class="keyword">WHEN</span> MATCHED <span class="keyword">AND</span> l.active <span class="operator">=</span> <span class="literal">false</span> <span class="keyword">THEN</span></span><br><span class="line">   <span class="keyword">DELETE</span></span><br><span class="line"><span class="keyword">WHEN</span> MATCHED <span class="keyword">AND</span> l.active <span class="operator">=</span> <span class="literal">true</span> <span class="keyword">THEN</span></span><br><span class="line">   <span class="keyword">UPDATE</span> <span class="keyword">SET</span> </span><br><span class="line">      name <span class="operator">=</span> l.name, </span><br><span class="line">      email <span class="operator">=</span> l.email;</span><br></pre></td></tr></table></figure><ul><li><code>MERGE</code>语句仅在 PostgreSQL 15+ 可用</li><li>早期版本使用<code>INSERT ... ON CONFLICT</code></li><li>成功后返回<code>MERGE total_count</code>，其中<code>total_count</code>是插入、更新或删除的行的总数</li><li><code>MERGE</code>可以在一个语句中执行 INSERT、UPDATE 和 DELETE</li><li>适用于表之间的数据同步</li><li>可以使用<code>DO NOTHING</code>忽略特定条件的行</li></ul><hr><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><h3 id="44-TRANSACTION"><a href="#44-TRANSACTION" class="headerlink" title="44. TRANSACTION"></a>44. TRANSACTION</h3><ul><li>数据库事务是由一个或多个操作组成的单个工作单元。PostgreSQL 事务是原子的、一致的、隔离的和持久的（ACID）</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 开始事务</span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="comment">-- 或</span></span><br><span class="line"><span class="keyword">BEGIN</span> TRANSACTION;</span><br><span class="line"><span class="comment">-- 或</span></span><br><span class="line"><span class="keyword">BEGIN</span> WORK;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 提交事务</span></span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br><span class="line"><span class="comment">-- 或</span></span><br><span class="line"><span class="keyword">COMMIT</span> TRANSACTION;</span><br><span class="line"><span class="comment">-- 或</span></span><br><span class="line"><span class="keyword">COMMIT</span> WORK;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 回滚事务</span></span><br><span class="line"><span class="keyword">ROLLBACK</span>;</span><br><span class="line"><span class="comment">-- 或</span></span><br><span class="line"><span class="keyword">ROLLBACK</span> TRANSACTION;</span><br><span class="line"><span class="comment">-- 或</span></span><br><span class="line"><span class="keyword">ROLLBACK</span> WORK;</span><br></pre></td></tr></table></figure><ul><li><strong>原子性 (Atomicity)</strong>: 事务以全有或全无的方式完成</li><li><strong>一致性 (Consistency)</strong>: 写入数据库的数据更改必须有效并遵循预定义的规则</li><li><strong>隔离性 (Isolation)</strong>: 事务完整性如何对其他事务可见</li><li><strong>持久性 (Durability)</strong>: 已提交的事务将永久存储在数据库中</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- accounts</span></span><br><span class="line"><span class="comment">-- | id | name  | balance  |</span></span><br><span class="line"><span class="comment">-- |----|-------|----------|</span></span><br><span class="line"><span class="comment">-- | 1  | Bob   | 10000.00 |</span></span><br><span class="line"><span class="comment">-- | 2  | Alice | 10000.00 |</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 银行转账示例：从 Bob 转账 1000 到 Alice</span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 从 Bob 账户扣款</span></span><br><span class="line"><span class="keyword">UPDATE</span> accounts </span><br><span class="line"><span class="keyword">SET</span> balance <span class="operator">=</span> balance <span class="operator">-</span> <span class="number">1000</span></span><br><span class="line"><span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 给 Alice 账户加款</span></span><br><span class="line"><span class="keyword">UPDATE</span> accounts</span><br><span class="line"><span class="keyword">SET</span> balance <span class="operator">=</span> balance <span class="operator">+</span> <span class="number">1000</span></span><br><span class="line"><span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 提交事务</span></span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看结果</span></span><br><span class="line"><span class="keyword">SELECT</span> id, name, balance <span class="keyword">FROM</span> accounts;</span><br><span class="line"><span class="comment">-- | id | name  | balance  |</span></span><br><span class="line"><span class="comment">-- |----|-------|----------|</span></span><br><span class="line"><span class="comment">-- | 1  | Bob   | 9000.00  |</span></span><br><span class="line"><span class="comment">-- | 2  | Alice | 11000.00 |</span></span><br></pre></td></tr></table></figure><ul><li>事务开始后，更改对其他会话不可见，直到提交</li><li><code>COMMIT</code>使更改持久化，<code>ROLLBACK</code>撤销更改</li><li>会话断开连接时，未提交的事务会自动回滚</li><li>建议保持事务尽可能短</li></ul><hr><h2 id="管理表"><a href="#管理表" class="headerlink" title="管理表"></a>管理表</h2><h3 id="45-CREATE-TABLE"><a href="#45-CREATE-TABLE" class="headerlink" title="45. CREATE TABLE"></a>45. CREATE TABLE</h3><ul><li>关系数据库由多个相关表组成。表格由行和列组成。要创建新表，请使用<code>CREATE TABLE</code>语句</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> [IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>] table_name (</span><br><span class="line">   column1 datatype(length) column_constraint,</span><br><span class="line">   column2 datatype(length) column_constraint,</span><br><span class="line">   column3 datatype(length) column_constraint,</span><br><span class="line">   table_constraints</span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>首先，在<code>CREATE TABLE</code>关键字后指定表的名称</li><li>其次，<code>IF NOT EXISTS</code>选项允许您仅当表不存在时才创建新表</li><li>第三，指定以逗号分隔的表列列表，包括列名、数据类型、长度和约束</li><li>最后，指定表约束，包括主键、外键和检查约束</li></ul><h4 id="约束类型"><a href="#约束类型" class="headerlink" title="约束类型"></a>约束类型</h4><ul><li><code>NOT NULL</code> - 确保列中的值不能为<code>NULL</code></li><li><code>UNIQUE</code> - 确保列的值在表中是唯一的</li><li><code>PRIMARY KEY</code> - 唯一标识表中的行，一个表只能有一个主键</li><li><code>CHECK</code> - 确保数据必须满足布尔表达式</li><li><code>FOREIGN KEY</code> - 确保列中的值存在于另一个表中</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建 accounts 表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> accounts (</span><br><span class="line">    user_id SERIAL <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    username <span class="type">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">UNIQUE</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    password <span class="type">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    email <span class="type">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">UNIQUE</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    created_on <span class="type">TIMESTAMP</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    last_login <span class="type">TIMESTAMP</span> </span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建 roles 表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> roles(</span><br><span class="line">   role_id SERIAL <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">   role_name <span class="type">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">UNIQUE</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建 account_roles 表（复合主键和外键）</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> account_roles (</span><br><span class="line">  user_id <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  role_id <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  grant_date <span class="type">TIMESTAMP</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (user_id, role_id),</span><br><span class="line">  <span class="keyword">FOREIGN</span> KEY (role_id) <span class="keyword">REFERENCES</span> roles (role_id),</span><br><span class="line">  <span class="keyword">FOREIGN</span> KEY (user_id) <span class="keyword">REFERENCES</span> accounts (user_id)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 使用 IF NOT EXISTS</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> products (</span><br><span class="line">    product_id SERIAL <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    product_name <span class="type">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    price <span class="type">DECIMAL</span>(<span class="number">10</span>, <span class="number">2</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">CHECK</span> (price <span class="operator">&gt;</span> <span class="number">0</span>),</span><br><span class="line">    stock <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 使用 CHECK 约束</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> employees (</span><br><span class="line">    employee_id SERIAL <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    age <span class="type">INT</span> <span class="keyword">CHECK</span> (age <span class="operator">&gt;=</span> <span class="number">18</span>),</span><br><span class="line">    salary <span class="type">DECIMAL</span>(<span class="number">10</span>, <span class="number">2</span>) <span class="keyword">CHECK</span> (salary <span class="operator">&gt;</span> <span class="number">0</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><ul><li>创建已存在的表会导致错误，使用<code>IF NOT EXISTS</code>可以避免</li><li><code>SERIAL</code>是自增整数，常用于主键</li><li>表约束（如复合主键）必须在列定义之后单独定义</li><li>外键引用的列必须是唯一的或主键</li><li>约束可以在创建表时定义，也可以后续使用<code>ALTER TABLE</code>添加</li></ul><hr><h3 id="46-SERIAL-自增列"><a href="#46-SERIAL-自增列" class="headerlink" title="46. SERIAL 自增列"></a>46. SERIAL 自增列</h3><ul><li>在 PostgreSQL 中，序列是一种特殊的数据库对象，它生成整数序列。序列通常用作表中的主键列。可以通过<code>SERIAL</code>伪类型创建自增列</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> table_name(</span><br><span class="line">    id SERIAL</span><br><span class="line">);</span><br></pre></td></tr></table></figure><ul><li><code>SERIAL</code>不是真正的数据类型，而是伪类型（语法糖）</li><li>序列生成器操作不是事务安全的，回滚不会回滚序列号</li><li>删除表或列时，关联的序列也会被删除</li></ul><hr><h3 id="47-ALTER-TABLE"><a href="#47-ALTER-TABLE" class="headerlink" title="47. ALTER TABLE"></a>47. ALTER TABLE</h3><ul><li>要更改现有表的结构，可以使用 PostgreSQL 的<code>ALTER TABLE</code>语句</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name action;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建示例表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> products (</span><br><span class="line">   product_id SERIAL <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">   name <span class="type">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">   price <span class="type">DECIMAL</span>(<span class="number">10</span>, <span class="number">2</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 添加列</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> products</span><br><span class="line"><span class="keyword">ADD</span> <span class="keyword">COLUMN</span> stock <span class="type">INT</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除列</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> products </span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">COLUMN</span> stock;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 重命名列</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> products </span><br><span class="line">RENAME <span class="keyword">COLUMN</span> name <span class="keyword">TO</span> product_name;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 添加列并设置默认值</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> products </span><br><span class="line"><span class="keyword">ADD</span> <span class="keyword">COLUMN</span> status <span class="type">VARCHAR</span>(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> products </span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">COLUMN</span> status <span class="keyword">SET</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;active&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 添加 CHECK 约束</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> products </span><br><span class="line"><span class="keyword">ADD</span> <span class="keyword">CHECK</span> (price <span class="operator">&gt;</span> <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 添加 UNIQUE 约束</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> products </span><br><span class="line"><span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> unique_product_name <span class="keyword">UNIQUE</span> (product_name);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 添加 NOT NULL 约束</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> products </span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">COLUMN</span> price <span class="keyword">SET</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 修改列类型</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> products </span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">COLUMN</span> product_name TYPE <span class="type">VARCHAR</span>(<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 重命名表</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> products </span><br><span class="line">RENAME <span class="keyword">TO</span> items;</span><br></pre></td></tr></table></figure><ul><li>删除列会永久删除该列及其数据</li><li>添加<code>NOT NULL</code>约束前，确保列中没有<code>NULL</code>值</li><li>修改列类型可能导致数据丢失或转换错误</li><li>添加约束可能失败，如果现有数据不满足约束条件</li><li>某些操作可能需要锁定整个表，影响并发访问</li><li>可以在一个<code>ALTER TABLE</code>语句中执行多个操作</li></ul><hr><h3 id="48-ADD-COLUMN"><a href="#48-ADD-COLUMN" class="headerlink" title="48. ADD COLUMN"></a>48. ADD COLUMN</h3><ul><li>要将新列添加到现有表，请使用<code>ALTER TABLE ADD COLUMN</code>语句</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 添加单列</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name</span><br><span class="line"><span class="keyword">ADD</span> <span class="keyword">COLUMN</span> column_name data_type <span class="keyword">constraint</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 添加多列</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name</span><br><span class="line"><span class="keyword">ADD</span> <span class="keyword">COLUMN</span> column_name1 data_type <span class="keyword">constraint</span>,</span><br><span class="line"><span class="keyword">ADD</span> <span class="keyword">COLUMN</span> column_name2 data_type <span class="keyword">constraint</span>,</span><br><span class="line">...</span><br><span class="line"><span class="keyword">ADD</span> <span class="keyword">COLUMN</span> column_namen data_type <span class="keyword">constraint</span>;</span><br></pre></td></tr></table></figure><ul><li>首先，在<code>ALTER TABLE</code>关键字后指定要添加新列的表名</li><li>其次，在<code>ADD COLUMN</code>关键字后指定新列的名称、数据类型和约束</li><li>新列会被附加到表的末尾</li></ul><hr><h3 id="49-DROP-COLUMN"><a href="#49-DROP-COLUMN" class="headerlink" title="49. DROP COLUMN"></a>49. DROP COLUMN</h3><ul><li>要删除表中的列，请在<code>ALTER TABLE</code>语句中使用<code>DROP COLUMN</code>子句</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 删除单列</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name </span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">COLUMN</span> column_name;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除列（如果存在）</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name </span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">COLUMN</span> IF <span class="keyword">EXISTS</span> column_name;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除列及其依赖对象</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name </span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">COLUMN</span> column_name CASCADE;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除多列</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">COLUMN</span> column_name1,</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">COLUMN</span> column_name2,</span><br><span class="line">...;</span><br></pre></td></tr></table></figure><ul><li>删除列时，PostgreSQL 会自动删除涉及该列的所有索引和约束</li><li>如果列被其他对象依赖，需要使用<code>CASCADE</code>选项</li><li><code>IF EXISTS</code>选项可以避免删除不存在的列时报错</li></ul><hr><h3 id="50-DROP-TABLE"><a href="#50-DROP-TABLE" class="headerlink" title="50. DROP TABLE"></a>50. DROP TABLE</h3><ul><li>要从数据库中删除表，请使用<code>DROP TABLE</code>语句</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 删除单个表</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> [IF <span class="keyword">EXISTS</span>] table_name </span><br><span class="line">[CASCADE <span class="operator">|</span> RESTRICT];</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除多个表</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> [IF <span class="keyword">EXISTS</span>] </span><br><span class="line">   table_name_1,</span><br><span class="line">   table_name_2,</span><br><span class="line">   ...</span><br><span class="line">[CASCADE <span class="operator">|</span> RESTRICT];</span><br></pre></td></tr></table></figure><ul><li>首先，在<code>DROP TABLE</code>关键字后指定要删除的表名</li><li>其次，使用<code>IF EXISTS</code>选项仅在表存在时才删除</li><li><code>CASCADE</code>选项允许删除表及其依赖对象</li><li><code>RESTRICT</code>选项在有依赖对象时拒绝删除（默认）</li></ul><hr><h3 id="51-TRUNCATE-TABLE"><a href="#51-TRUNCATE-TABLE" class="headerlink" title="51. TRUNCATE TABLE"></a>51. TRUNCATE TABLE</h3><ul><li>要快速删除表中的所有数据，请使用<code>TRUNCATE TABLE</code>语句。它比<code>DELETE</code>语句更快，因为不扫描表</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 截断单个表</span></span><br><span class="line"><span class="keyword">TRUNCATE</span> <span class="keyword">TABLE</span> table_name;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 重置自增序列</span></span><br><span class="line"><span class="keyword">TRUNCATE</span> <span class="keyword">TABLE</span> table_name </span><br><span class="line">RESTART <span class="keyword">IDENTITY</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 截断多个表</span></span><br><span class="line"><span class="keyword">TRUNCATE</span> <span class="keyword">TABLE</span> </span><br><span class="line">    table_name1, </span><br><span class="line">    table_name2,</span><br><span class="line">    ...;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 级联截断</span></span><br><span class="line"><span class="keyword">TRUNCATE</span> <span class="keyword">TABLE</span> table_name </span><br><span class="line">CASCADE;</span><br></pre></td></tr></table></figure><ul><li><code>TRUNCATE TABLE</code>删除所有数据而不扫描表，比<code>DELETE</code>快</li><li>立即回收存储空间，不需要后续的<code>VACUUM</code>操作</li><li><code>RESTART IDENTITY</code>重置自增列的序列值</li><li><code>CASCADE</code>截断引用该表的其他表</li></ul><hr><h3 id="52-临时表"><a href="#52-临时表" class="headerlink" title="52. 临时表"></a>52. 临时表</h3><ul><li>临时表是在数据库会话期间存在的短期表。PostgreSQL 在会话或事务结束时自动删除临时表</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建临时表</span></span><br><span class="line"><span class="keyword">CREATE</span> TEMPORARY <span class="keyword">TABLE</span> temp_table_name(</span><br><span class="line">   column_list</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 或使用 TEMP</span></span><br><span class="line"><span class="keyword">CREATE</span> TEMP <span class="keyword">TABLE</span> temp_table_name(</span><br><span class="line">   column_list</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除临时表</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> temp_table_name;</span><br></pre></td></tr></table></figure><ul><li><code>TEMP</code>和<code>TEMPORARY</code>关键字是等效的，可以互换使用</li><li>临时表仅对创建它的会话可见</li><li>会话结束时自动删除</li><li>不能在<code>CREATE TEMP TABLE</code>中指定模式</li></ul><hr><h2 id="PostgreSQL-约束"><a href="#PostgreSQL-约束" class="headerlink" title="PostgreSQL 约束"></a>PostgreSQL 约束</h2><h3 id="53-主键约束-PRIMARY-KEY"><a href="#53-主键约束-PRIMARY-KEY" class="headerlink" title="53. 主键约束 (PRIMARY KEY)"></a>53. 主键约束 (PRIMARY KEY)</h3><ul><li>主键是用于唯一标识表中的行的一列或一组列。主键约束是非空约束和 UNIQUE 约束的组合。一张表只能有一个主键</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建表时定义单列主键</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> table_name (</span><br><span class="line">    column_1 data_type <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    column_2 data_type,</span><br><span class="line">    ...</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建表时定义复合主键</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> table_name (</span><br><span class="line">    column_1 data_type,</span><br><span class="line">    column_2 data_type,</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (column_1, column_2)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 指定主键约束名称</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> table_name (</span><br><span class="line">    column_1 data_type,</span><br><span class="line">    column_2 data_type,</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> constraint_name <span class="keyword">PRIMARY</span> KEY (column_1, column_2)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 单列主键</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> po_headers (</span><br><span class="line">    po_no <span class="type">INTEGER</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    vendor_no <span class="type">INTEGER</span>,</span><br><span class="line">    description TEXT,</span><br><span class="line">    shipping_address TEXT</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 复合主键</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> po_items (</span><br><span class="line">    po_no <span class="type">INTEGER</span>,</span><br><span class="line">    item_no <span class="type">INTEGER</span>,</span><br><span class="line">    product_no <span class="type">INTEGER</span>,</span><br><span class="line">    qty <span class="type">INTEGER</span>,</span><br><span class="line">    net_price <span class="type">NUMERIC</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (po_no, item_no)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 使用 SERIAL 自增主键</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> customers (</span><br><span class="line">    customer_id SERIAL <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    email <span class="type">VARCHAR</span>(<span class="number">255</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 指定主键约束名称</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> orders (</span><br><span class="line">    order_id <span class="type">INTEGER</span>,</span><br><span class="line">    customer_id <span class="type">INTEGER</span>,</span><br><span class="line">    order_date <span class="type">DATE</span>,</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> orders_pk <span class="keyword">PRIMARY</span> KEY (order_id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><ul><li>一张表只能有一个主键</li><li>主键列不能包含<code>NULL</code>值，值必须唯一</li><li>PostgreSQL 自动为主键创建唯一的 B-tree 索引</li><li>默认主键约束名称为<code>table_name_pkey</code></li></ul><hr><h3 id="54-外键约束-FOREIGN-KEY"><a href="#54-外键约束-FOREIGN-KEY" class="headerlink" title="54. 外键约束 (FOREIGN KEY)"></a>54. 外键约束 (FOREIGN KEY)</h3><ul><li>外键是表中引用另一个表的主键的一列或一组列。外键约束有助于维护子表和父表之间数据的引用完整性</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">[<span class="keyword">CONSTRAINT</span> fk_name]</span><br><span class="line">   <span class="keyword">FOREIGN</span> KEY(fk_columns) </span><br><span class="line">   <span class="keyword">REFERENCES</span> parent_table(parent_key_columns)</span><br><span class="line">   [<span class="keyword">ON</span> <span class="keyword">DELETE</span> delete_action]</span><br><span class="line">   [<span class="keyword">ON</span> <span class="keyword">UPDATE</span> update_action]</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建父表：部门</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> departments(</span><br><span class="line">   department_id <span class="type">INT</span> GENERATED ALWAYS <span class="keyword">AS</span> <span class="keyword">IDENTITY</span>,</span><br><span class="line">   department_name <span class="type">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">   <span class="keyword">PRIMARY</span> KEY(department_id)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建子表：员工（NO ACTION）</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> employees(</span><br><span class="line">   employee_id <span class="type">INT</span> GENERATED ALWAYS <span class="keyword">AS</span> <span class="keyword">IDENTITY</span>,</span><br><span class="line">   employee_name <span class="type">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">   department_id <span class="type">INT</span>,</span><br><span class="line">   salary <span class="type">DECIMAL</span>(<span class="number">10</span>, <span class="number">2</span>),</span><br><span class="line">   <span class="keyword">PRIMARY</span> KEY(employee_id),</span><br><span class="line">   <span class="keyword">CONSTRAINT</span> fk_department</span><br><span class="line">      <span class="keyword">FOREIGN</span> KEY(department_id) </span><br><span class="line">      <span class="keyword">REFERENCES</span> departments(department_id)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 插入数据</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> departments(department_name)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="string">&#x27;Engineering&#x27;</span>), (<span class="string">&#x27;Sales&#x27;</span>), (<span class="string">&#x27;HR&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employees(employee_name, department_id, salary)</span><br><span class="line"><span class="keyword">VALUES</span></span><br><span class="line">   (<span class="string">&#x27;Alice&#x27;</span>, <span class="number">1</span>, <span class="number">75000</span>),</span><br><span class="line">   (<span class="string">&#x27;Bob&#x27;</span>, <span class="number">1</span>, <span class="number">68000</span>),</span><br><span class="line">   (<span class="string">&#x27;Charlie&#x27;</span>, <span class="number">2</span>, <span class="number">62000</span>),</span><br><span class="line">   (<span class="string">&#x27;David&#x27;</span>, <span class="number">3</span>, <span class="number">58000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 尝试删除有员工的部门</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> departments <span class="keyword">WHERE</span> department_id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="comment">-- ERROR: update or delete on table &quot;departments&quot; violates foreign key constraint</span></span><br><span class="line"><span class="comment">-- 阻止删除，因为有员工属于该部门</span></span><br></pre></td></tr></table></figure><ul><li>首先，在<code>CONSTRAINT</code>关键字后指定外键约束的名称（可选）</li><li>其次，在<code>FOREIGN KEY</code>关键字后指定一个或多个外键列</li><li>第三，在<code>REFERENCES</code>子句中指定父表和父键列</li><li>最后，指定删除和更新操作</li></ul><hr><h3 id="55-CHECK-约束"><a href="#55-CHECK-约束" class="headerlink" title="55. CHECK 约束"></a>55. CHECK 约束</h3><ul><li><code>CHECK</code>约束允许您指定列中的值是否必须满足特定要求。在插入或更新值之前，<code>CHECK</code>约束使用布尔表达式来验证值</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 列级 CHECK 约束</span></span><br><span class="line">column_name data_type <span class="keyword">CHECK</span> (expression)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 列级 CHECK 约束（指定名称）</span></span><br><span class="line">column_name data_type <span class="keyword">CONSTRAINT</span> constraint_name <span class="keyword">CHECK</span> (expression)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 表级 CHECK 约束</span></span><br><span class="line"><span class="keyword">CONSTRAINT</span> constraint_name <span class="keyword">CHECK</span> (expression)</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> students (</span><br><span class="line">    student_id SERIAL <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    age <span class="type">INT</span> <span class="keyword">CHECK</span> (age <span class="operator">&gt;=</span> <span class="number">18</span> <span class="keyword">AND</span> age <span class="operator">&lt;=</span> <span class="number">100</span>),</span><br><span class="line">    grade <span class="type">CHAR</span>(<span class="number">1</span>) <span class="keyword">CHECK</span> (grade <span class="keyword">IN</span> (<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;F&#x27;</span>)),</span><br><span class="line">    gpa <span class="type">DECIMAL</span>(<span class="number">3</span>, <span class="number">2</span>) <span class="keyword">CHECK</span> (gpa <span class="keyword">BETWEEN</span> <span class="number">0.0</span> <span class="keyword">AND</span> <span class="number">4.0</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 尝试插入无效数据</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> students (name, age, grade, gpa)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;Alice&#x27;</span>, <span class="number">15</span>, <span class="string">&#x27;A&#x27;</span>, <span class="number">3.8</span>);</span><br><span class="line"><span class="comment">-- ERROR: new row for relation &quot;students&quot; violates check constraint</span></span><br><span class="line"><span class="comment">-- age 必须 &gt;= 18</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 插入有效数据</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> students (name, age, grade, gpa)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;Bob&#x27;</span>, <span class="number">20</span>, <span class="string">&#x27;B&#x27;</span>, <span class="number">3.5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 指定约束名称</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> bank_accounts (</span><br><span class="line">    account_id SERIAL <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    account_number <span class="type">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    balance <span class="type">DECIMAL</span>(<span class="number">15</span>, <span class="number">2</span>) <span class="keyword">CONSTRAINT</span> non_negative_balance <span class="keyword">CHECK</span> (balance <span class="operator">&gt;=</span> <span class="number">0</span>),</span><br><span class="line">    account_type <span class="type">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">CONSTRAINT</span> valid_account_type </span><br><span class="line">        <span class="keyword">CHECK</span> (account_type <span class="keyword">IN</span> (<span class="string">&#x27;checking&#x27;</span>, <span class="string">&#x27;savings&#x27;</span>, <span class="string">&#x27;business&#x27;</span>))</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 表级 CHECK 约束（多列）</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> events (</span><br><span class="line">    event_id SERIAL <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    event_name <span class="type">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    start_date <span class="type">DATE</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    end_date <span class="type">DATE</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    min_participants <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    max_participants <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> valid_date_range </span><br><span class="line">        <span class="keyword">CHECK</span> (end_date <span class="operator">&gt;=</span> start_date),</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> valid_participant_range </span><br><span class="line">        <span class="keyword">CHECK</span> (max_participants <span class="operator">&gt;=</span> min_participants <span class="keyword">AND</span> min_participants <span class="operator">&gt;</span> <span class="number">0</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><ul><li>可以引用同一行的多个列</li><li>NULL 值通过 CHECK 约束（除非同时有 NOT NULL 约束）</li><li>默认约束名称格式：<code>&#123;table&#125;_&#123;column&#125;_check</code></li></ul><hr><h3 id="56-UNIQUE-约束"><a href="#56-UNIQUE-约束" class="headerlink" title="56. UNIQUE 约束"></a>56. UNIQUE 约束</h3><ul><li><code>UNIQUE</code>约束确保存储在一个列或一组列中的值在表中的所有行中是唯一的。当添加<code>UNIQUE</code>约束时，PostgreSQL 会自动在该列或列组上创建唯一索引</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 列级 UNIQUE 约束</span></span><br><span class="line">column_name data_type <span class="keyword">UNIQUE</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 表级 UNIQUE 约束</span></span><br><span class="line"><span class="keyword">UNIQUE</span> (column_name)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 多列 UNIQUE 约束</span></span><br><span class="line"><span class="keyword">UNIQUE</span> (column1, column2, ...)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 指定约束名称</span></span><br><span class="line"><span class="keyword">CONSTRAINT</span> constraint_name <span class="keyword">UNIQUE</span> (column_name)</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建带 UNIQUE 约束的表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> users (</span><br><span class="line">    user_id SERIAL <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    username <span class="type">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">UNIQUE</span>,</span><br><span class="line">    email <span class="type">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">UNIQUE</span>,</span><br><span class="line">    phone <span class="type">VARCHAR</span>(<span class="number">20</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 插入数据</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> users (username, email, phone)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;alice&#x27;</span>, <span class="string">&#x27;alice@example.com&#x27;</span>, <span class="string">&#x27;123-456-7890&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 尝试插入重复的 email</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> users (username, email, phone)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;bob&#x27;</span>, <span class="string">&#x27;alice@example.com&#x27;</span>, <span class="string">&#x27;098-765-4321&#x27;</span>);</span><br><span class="line"><span class="comment">-- ERROR: duplicate key value violates unique constraint &quot;users_email_key&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 表级 UNIQUE 约束</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> employees (</span><br><span class="line">    employee_id SERIAL <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    first_name <span class="type">VARCHAR</span>(<span class="number">50</span>),</span><br><span class="line">    last_name <span class="type">VARCHAR</span>(<span class="number">50</span>),</span><br><span class="line">    email <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    <span class="keyword">UNIQUE</span> (email)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 多列 UNIQUE 约束</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> course_enrollments (</span><br><span class="line">    enrollment_id SERIAL <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    student_id <span class="type">INT</span>,</span><br><span class="line">    course_id <span class="type">INT</span>,</span><br><span class="line">    semester <span class="type">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">    <span class="keyword">UNIQUE</span> (student_id, course_id, semester)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 指定约束名称</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> products (</span><br><span class="line">    product_id SERIAL <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    product_code <span class="type">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">    barcode <span class="type">VARCHAR</span>(<span class="number">50</span>),</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> unique_product_code <span class="keyword">UNIQUE</span> (product_code),</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> unique_barcode <span class="keyword">UNIQUE</span> (barcode)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><ul><li>PostgreSQL 自动为<code>UNIQUE</code>约束创建唯一索引</li><li><code>UNIQUE</code>约束允许多个<code>NULL</code>值</li><li>多列<code>UNIQUE</code>约束要求列组合唯一</li><li>一个表可以有多个<code>UNIQUE</code>约束</li></ul><hr><h3 id="57-NOT-NULL-约束"><a href="#57-NOT-NULL-约束" class="headerlink" title="57. NOT NULL 约束"></a>57. NOT NULL 约束</h3><ul><li><code>NOT NULL</code>约束确保列的值不为空。在数据库中，NULL 代表未知或信息缺失，与空字符串或数字零不同</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建表时声明 NOT NULL</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> table_name(</span><br><span class="line">   column_name data_type <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">   ...</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 为现有列添加 NOT NULL</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">COLUMN</span> column_name <span class="keyword">SET</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除 NOT NULL 约束</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">COLUMN</span> column_name <span class="keyword">DROP</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>;</span><br></pre></td></tr></table></figure><ul><li>默认情况下，列可以保存 NULL</li><li>使用<code>IS NULL</code>或<code>IS NOT NULL</code>检查 NULL 值</li><li>切勿使用<code>=</code>来比较 NULL，因为<code>NULL = NULL</code>返回 NULL</li><li>一列可以有多个约束，顺序不重要</li><li><code>NOT NULL</code>约束等同于<code>CHECK(column IS NOT NULL)</code></li></ul><hr><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="58-BOOLEAN-布尔类型"><a href="#58-BOOLEAN-布尔类型" class="headerlink" title="58. BOOLEAN 布尔类型"></a>58. BOOLEAN 布尔类型</h3><ul><li>PostgreSQL 支持单一的布尔数据类型：<code>BOOLEAN</code>，它可以具有三个值：<code>true</code>、<code>false</code>和<code>NULL</code>。PostgreSQL 使用一个字节存储布尔值，<code>BOOLEAN</code>可以简写为<code>BOOL</code></li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 定义布尔列</span></span><br><span class="line">column_name <span class="type">BOOLEAN</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 或使用简写</span></span><br><span class="line">column_name BOOL</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 带默认值</span></span><br><span class="line">column_name <span class="type">BOOLEAN</span> <span class="keyword">DEFAULT</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><ul><li>PostgreSQL 使用一个字节存储布尔值</li><li><code>BOOLEAN</code>可以简写为<code>BOOL</code></li><li>布尔列可以有三个值：<code>true</code>、<code>false</code>、<code>NULL</code></li><li>前导或尾随空格不影响布尔值</li><li>除<code>true</code>和<code>false</code>外的常量值必须用单引号引起来</li><li>可以直接使用布尔列名作为条件（隐式为 true）</li></ul><hr><h3 id="59-字符类型-CHAR、VARCHAR-和-TEXT"><a href="#59-字符类型-CHAR、VARCHAR-和-TEXT" class="headerlink" title="59. 字符类型: CHAR、VARCHAR 和 TEXT"></a>59. 字符类型: CHAR、VARCHAR 和 TEXT</h3><ul><li>PostgreSQL 提供三种主要字符类型：<code>CHARACTER(n)</code>或<code>CHAR(n)</code>、<code>CHARACTER VARYING(n)</code>或<code>VARCHAR(n)</code>、和<code>TEXT</code></li></ul><table><thead><tr><th>类型</th><th>描述</th></tr></thead><tbody><tr><td><code>CHAR(n)</code></td><td>固定长度，空白填充</td></tr><tr><td><code>VARCHAR(n)</code></td><td>可变长度，有长度限制</td></tr><tr><td><code>TEXT</code> 或 <code>VARCHAR</code></td><td>可变长度，无限制</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建带字符类型的表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> character_tests (</span><br><span class="line">    id SERIAL <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    x <span class="type">CHAR</span>(<span class="number">1</span>),</span><br><span class="line">    y <span class="type">VARCHAR</span>(<span class="number">10</span>),</span><br><span class="line">    z TEXT</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 插入数据</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> character_tests (x, y, z)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="string">&#x27;Y&#x27;</span>, <span class="string">&#x27;varchar(n)&#x27;</span>, <span class="string">&#x27;This is a very long text for the PostgreSQL text column&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 尝试插入超长字符串</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> character_tests (x, y, z)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="string">&#x27;Yes&#x27;</span>, <span class="string">&#x27;This is a test&#x27;</span>, <span class="string">&#x27;text&#x27;</span>);</span><br><span class="line"><span class="comment">-- ERROR: value too long for type character(1)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> character_tests (x, y, z)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="string">&#x27;Y&#x27;</span>, <span class="string">&#x27;This is a test for varchar&#x27;</span>, <span class="string">&#x27;text&#x27;</span>);</span><br><span class="line"><span class="comment">-- ERROR: value too long for type character varying(10)</span></span><br></pre></td></tr></table></figure><ul><li>三种字符类型之间没有性能差异</li><li><code>CHAR(n)</code>和<code>VARCHAR(n)</code>最多存储<code>n</code>个字符</li><li><code>TEXT</code>可以存储无限长度的字符串</li><li><code>VARCHAR</code>不带长度限制时等同于<code>TEXT</code></li><li>大多数情况下应使用<code>TEXT</code>或<code>VARCHAR</code></li><li>需要检查长度时使用<code>VARCHAR(n)</code></li><li><code>CHAR</code>不带长度限制时等同于<code>CHAR(1)</code></li></ul><hr><h3 id="60-NUMERIC-数值类型"><a href="#60-NUMERIC-数值类型" class="headerlink" title="60. NUMERIC 数值类型"></a>60. NUMERIC 数值类型</h3><ul><li><code>NUMERIC</code>类型可以存储具有很多位数的数字。通常用于需要精确性的数字，例如货币金额或数量</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 指定精度和小数位数</span></span><br><span class="line"><span class="type">NUMERIC</span>(<span class="keyword">precision</span>, scale)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 只指定精度（小数位数为0）</span></span><br><span class="line"><span class="type">NUMERIC</span>(<span class="keyword">precision</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 不指定精度和小数位数</span></span><br><span class="line"><span class="type">NUMERIC</span></span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建带 NUMERIC 列的表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> products (</span><br><span class="line">    id SERIAL <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    price <span class="type">NUMERIC</span>(<span class="number">5</span>, <span class="number">2</span>)  <span class="comment">-- 最多5位数字，其中2位小数</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 插入数据（自动四舍五入）</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> products (name, price)</span><br><span class="line"><span class="keyword">VALUES</span> </span><br><span class="line">    (<span class="string">&#x27;Phone&#x27;</span>, <span class="number">500.215</span>),   <span class="comment">-- 四舍五入为 500.22</span></span><br><span class="line">    (<span class="string">&#x27;Tablet&#x27;</span>, <span class="number">500.214</span>);  <span class="comment">-- 四舍五入为 500.21</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> products;</span><br><span class="line"><span class="comment">-- | id | name   | price  |</span></span><br><span class="line"><span class="comment">-- |----|--------|--------|</span></span><br><span class="line"><span class="comment">-- | 1  | Phone  | 500.22 |</span></span><br><span class="line"><span class="comment">-- | 2  | Tablet | 500.21 |</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 插入超出精度的值会报错</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> products (name, price)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="string">&#x27;Phone&#x27;</span>, <span class="number">123456.21</span>);</span><br><span class="line"><span class="comment">-- ERROR: numeric field overflow</span></span><br></pre></td></tr></table></figure><ul><li><code>NUMERIC</code>和<code>DECIMAL</code>是等效的，都是 SQL 标准</li><li>最多可保存小数点前 131,072 位和小数点后 16,383 位</li><li>小数位数大于声明时会四舍五入</li><li>精度超出声明时会报错</li><li><code>NUMERIC</code>计算通常比整数、浮点数慢</li><li>不需要精确性时不应使用<code>NUMERIC</code></li><li><code>NaN</code>表示”非数字”，大于所有数字</li></ul><hr><h3 id="61-INTEGER-整数类型"><a href="#61-INTEGER-整数类型" class="headerlink" title="61. INTEGER 整数类型"></a>61. INTEGER 整数类型</h3><ul><li>PostgreSQL 提供三种整数类型：<code>SMALLINT</code>、<code>INTEGER</code>和<code>BIGINT</code>，用于存储不同范围的整数</li></ul><table><thead><tr><th>名称</th><th>存储大小</th><th>最小值</th><th>最大值</th></tr></thead><tbody><tr><td><code>SMALLINT</code></td><td>2 字节</td><td>-32,768</td><td>+32,767</td></tr><tr><td><code>INTEGER</code></td><td>4 字节</td><td>-2,147,483,648</td><td>+2,147,483,647</td></tr><tr><td><code>BIGINT</code></td><td>8 字节</td><td>-9,223,372,036,854,775,808</td><td>+9,223,372,036,854,775,807</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- SMALLINT 示例（适用于小范围数值）</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> books (</span><br><span class="line">    book_id SERIAL <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    title <span class="type">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    pages <span class="type">SMALLINT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">CHECK</span> (pages <span class="operator">&gt;</span> <span class="number">0</span>),</span><br><span class="line">    <span class="keyword">year</span> <span class="type">SMALLINT</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> books (title, pages, <span class="keyword">year</span>)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;PostgreSQL Guide&#x27;</span>, <span class="number">350</span>, <span class="number">2024</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- INTEGER 示例（最常用）</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> cities (</span><br><span class="line">    city_id SERIAL <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    city_name <span class="type">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    population <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">CHECK</span> (population <span class="operator">&gt;=</span> <span class="number">0</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> cities (city_name, population)</span><br><span class="line"><span class="keyword">VALUES</span> </span><br><span class="line">    (<span class="string">&#x27;New York&#x27;</span>, <span class="number">8336817</span>),</span><br><span class="line">    (<span class="string">&#x27;Los Angeles&#x27;</span>, <span class="number">3979576</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- BIGINT 示例（大数值）</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> analytics (</span><br><span class="line">    id SERIAL <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    page_views <span class="type">BIGINT</span>,</span><br><span class="line">    user_id <span class="type">INT</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> analytics (page_views, user_id)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="number">9223372036854775000</span>, <span class="number">1001</span>);</span><br></pre></td></tr></table></figure><ul><li>PostgreSQL 不提供无符号整数类型</li><li><code>INTEGER</code>是最常用的整数类型，提供最佳平衡</li><li><code>INT</code>是<code>INTEGER</code>的同义词</li><li>超出范围的值会导致错误</li><li><code>BIGINT</code>消耗更多存储空间并降低性能，应谨慎使用</li><li>选择合适的类型可以节省存储空间并提高性能</li></ul><hr><h3 id="62-DATE-日期类型"><a href="#62-DATE-日期类型" class="headerlink" title="62. DATE 日期类型"></a>62. DATE 日期类型</h3><ul><li>PostgreSQL 使用<code>DATE</code>数据类型存储日期值。PostgreSQL 使用 4 个字节来存储日期值，范围为 4713 BC 至 5874897 AD</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 定义 DATE 列</span></span><br><span class="line">column_name <span class="type">DATE</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 使用当前日期作为默认值</span></span><br><span class="line">column_name <span class="type">DATE</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_DATE</span></span><br></pre></td></tr></table></figure><blockquote><p>PostgreSQL 使用<code>yyyy-mm-dd</code>格式存储和插入日期值，例如 2000-12-31</p></blockquote><h4 id="日期函数"><a href="#日期函数" class="headerlink" title="日期函数"></a>日期函数</h4><p><strong>1) 获取当前日期</strong></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 方式1：使用 NOW() 并转换为日期</span></span><br><span class="line"><span class="keyword">SELECT</span> NOW()::<span class="type">DATE</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 方式2：使用 CURRENT_DATE</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">CURRENT_DATE</span>;</span><br><span class="line"><span class="comment">-- 2024-11-22</span></span><br></pre></td></tr></table></figure><p><strong>2) 格式化日期输出</strong></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- dd/mm/yyyy 格式</span></span><br><span class="line"><span class="keyword">SELECT</span> TO_CHAR(NOW()::<span class="type">DATE</span>, <span class="string">&#x27;dd/mm/yyyy&#x27;</span>);</span><br><span class="line"><span class="comment">-- 22/11/2024</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- Mon dd, yyyy 格式</span></span><br><span class="line"><span class="keyword">SELECT</span> TO_CHAR(NOW()::<span class="type">DATE</span>, <span class="string">&#x27;Mon dd, yyyy&#x27;</span>);</span><br><span class="line"><span class="comment">-- Nov 22, 2024</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- yyyy-mm-dd 格式</span></span><br><span class="line"><span class="keyword">SELECT</span> TO_CHAR(NOW()::<span class="type">DATE</span>, <span class="string">&#x27;yyyy-mm-dd&#x27;</span>);</span><br><span class="line"><span class="comment">-- 2024-11-22</span></span><br></pre></td></tr></table></figure><p><strong>3) 计算日期间隔</strong></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 计算员工工作天数</span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    first_name,</span><br><span class="line">    last_name,</span><br><span class="line">    NOW() <span class="operator">-</span> hire_date <span class="keyword">AS</span> service_days</span><br><span class="line"><span class="keyword">FROM</span> employees;</span><br><span class="line"><span class="comment">-- | first_name | last_name | service_days            |</span></span><br><span class="line"><span class="comment">-- |------------|-----------|-------------------------|</span></span><br><span class="line"><span class="comment">-- | Shannon    | Freeman   | 7266 days 08:25:30      |</span></span><br><span class="line"><span class="comment">-- | Sheila     | Wells     | 7997 days 08:25:30      |</span></span><br></pre></td></tr></table></figure><p><strong>4) 计算年龄</strong></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 计算员工当前年龄</span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    employee_id,</span><br><span class="line">    first_name,</span><br><span class="line">    last_name,</span><br><span class="line">    AGE(birth_date) <span class="keyword">AS</span> age</span><br><span class="line"><span class="keyword">FROM</span> employees;</span><br><span class="line"><span class="comment">-- | employee_id | first_name | age                     |</span></span><br><span class="line"><span class="comment">-- |-------------|------------|-------------------------|</span></span><br><span class="line"><span class="comment">-- | 1           | Shannon    | 44 years 10 mons 22 days|</span></span><br><span class="line"><span class="comment">-- | 2           | Sheila     | 46 years 9 mons 17 days |</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 计算特定日期时的年龄</span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    first_name,</span><br><span class="line">    last_name,</span><br><span class="line">    AGE(<span class="string">&#x27;2015-01-01&#x27;</span>, birth_date) <span class="keyword">AS</span> age_in_2015</span><br><span class="line"><span class="keyword">FROM</span> employees;</span><br></pre></td></tr></table></figure><p><strong>5) 提取日期部分</strong></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 提取年、月、日</span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    employee_id,</span><br><span class="line">    first_name,</span><br><span class="line">    <span class="built_in">EXTRACT</span>(<span class="keyword">YEAR</span> <span class="keyword">FROM</span> birth_date) <span class="keyword">AS</span> <span class="keyword">year</span>,</span><br><span class="line">    <span class="built_in">EXTRACT</span>(<span class="keyword">MONTH</span> <span class="keyword">FROM</span> birth_date) <span class="keyword">AS</span> <span class="keyword">month</span>,</span><br><span class="line">    <span class="built_in">EXTRACT</span>(<span class="keyword">DAY</span> <span class="keyword">FROM</span> birth_date) <span class="keyword">AS</span> <span class="keyword">day</span></span><br><span class="line"><span class="keyword">FROM</span> employees;</span><br><span class="line"><span class="comment">-- | employee_id | first_name | year | month | day |</span></span><br><span class="line"><span class="comment">-- |-------------|------------|------|-------|-----|</span></span><br><span class="line"><span class="comment">-- | 1           | Shannon    | 1980 | 1     | 1   |</span></span><br><span class="line"><span class="comment">-- | 2           | Sheila     | 1978 | 2     | 5   |</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 提取星期几（0=周日，6=周六）</span></span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    <span class="built_in">EXTRACT</span>(DOW <span class="keyword">FROM</span> <span class="built_in">CURRENT_DATE</span>) <span class="keyword">AS</span> day_of_week;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 提取一年中的第几天</span></span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    <span class="built_in">EXTRACT</span>(DOY <span class="keyword">FROM</span> <span class="built_in">CURRENT_DATE</span>) <span class="keyword">AS</span> day_of_year;</span><br></pre></td></tr></table></figure><ul><li>PostgreSQL 使用<code>yyyy-mm-dd</code>格式存储日期</li><li>使用<code>CURRENT_DATE</code>获取当前日期</li><li>使用<code>TO_CHAR()</code>格式化日期输出</li><li>使用<code>AGE()</code>计算年龄</li><li>使用<code>EXTRACT()</code>提取日期部分</li><li>日期减法返回间隔（interval）类型</li></ul><hr><h3 id="63-TIMESTAMP-时间戳"><a href="#63-TIMESTAMP-时间戳" class="headerlink" title="63. TIMESTAMP 时间戳"></a>63. TIMESTAMP 时间戳</h3><ul><li>PostgreSQL 提供两种时间戳数据类型：<code>TIMESTAMP</code>（不带时区）和<code>TIMESTAMPTZ</code>（带时区）</li></ul><table><thead><tr><th>类型</th><th>描述</th><th>存储大小</th></tr></thead><tbody><tr><td><code>TIMESTAMP</code></td><td>不带时区的时间戳</td><td>8 字节</td></tr><tr><td><code>TIMESTAMPTZ</code></td><td>带时区的时间戳</td><td>8 字节</td></tr></tbody></table><ul><li><code>TIMESTAMP</code> - 存储日期和时间，不包含时区信息</li><li><code>TIMESTAMPTZ</code> - 时区感知的日期和时间，以 UTC 存储</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建带时间戳列的表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> timestamp_demo (</span><br><span class="line">    ts <span class="type">TIMESTAMP</span>, </span><br><span class="line">    tstz TIMESTAMPTZ</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 设置时区</span></span><br><span class="line"><span class="keyword">SET</span> timezone <span class="operator">=</span> <span class="string">&#x27;America/Los_Angeles&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看当前时区</span></span><br><span class="line"><span class="keyword">SHOW</span> TIMEZONE;</span><br><span class="line"><span class="comment">-- America/Los_Angeles</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 插入数据</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> timestamp_demo (ts, tstz)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="string">&#x27;2016-06-22 19:10:25-07&#x27;</span>, <span class="string">&#x27;2016-06-22 19:10:25-07&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询数据</span></span><br><span class="line"><span class="keyword">SELECT</span> ts, tstz <span class="keyword">FROM</span> timestamp_demo;</span><br><span class="line"><span class="comment">-- | ts                  | tstz                   |</span></span><br><span class="line"><span class="comment">-- |---------------------|------------------------|</span></span><br><span class="line"><span class="comment">-- | 2016-06-22 19:10:25 | 2016-06-22 19:10:25-07 |</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 修改时区</span></span><br><span class="line"><span class="keyword">SET</span> timezone <span class="operator">=</span> <span class="string">&#x27;America/New_York&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 再次查询</span></span><br><span class="line"><span class="keyword">SELECT</span> ts, tstz <span class="keyword">FROM</span> timestamp_demo;</span><br><span class="line"><span class="comment">-- | ts                  | tstz                   |</span></span><br><span class="line"><span class="comment">-- |---------------------|------------------------|</span></span><br><span class="line"><span class="comment">-- | 2016-06-22 19:10:25 | 2016-06-22 22:10:25-04 |</span></span><br><span class="line"><span class="comment">-- TIMESTAMP 不变，TIMESTAMPTZ 自动调整</span></span><br></pre></td></tr></table></figure><h4 id="时间戳函数"><a href="#时间戳函数" class="headerlink" title="时间戳函数"></a>时间戳函数</h4><p><strong>获取当前时间</strong></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 获取当前时间戳（带时区）</span></span><br><span class="line"><span class="keyword">SELECT</span> NOW();</span><br><span class="line"><span class="comment">-- 2024-11-22 20:44:52.134125-07</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 使用 CURRENT_TIMESTAMP</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">CURRENT_TIMESTAMP</span>;</span><br><span class="line"><span class="comment">-- 2024-11-22 20:44:52.134125-07</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 仅获取时间（带时区）</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">CURRENT_TIME</span>;</span><br><span class="line"><span class="comment">-- 20:49:04.566025-07</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 获取字符串格式的时间</span></span><br><span class="line"><span class="keyword">SELECT</span> TIMEOFDAY();</span><br><span class="line"><span class="comment">-- Wed Nov 22 20:51:12.632420 2024 PST</span></span><br></pre></td></tr></table></figure><p><strong>时区转换</strong></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查看当前时区</span></span><br><span class="line"><span class="keyword">SHOW</span> TIMEZONE;</span><br><span class="line"><span class="comment">-- America/Los_Angeles</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 转换到另一个时区</span></span><br><span class="line"><span class="keyword">SELECT</span> timezone(<span class="string">&#x27;America/New_York&#x27;</span>, <span class="string">&#x27;2016-06-01 00:00&#x27;</span>);</span><br><span class="line"><span class="comment">-- 2016-06-01 03:00:00</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 显式转换为 timestamptz</span></span><br><span class="line"><span class="keyword">SELECT</span> timezone(<span class="string">&#x27;America/New_York&#x27;</span>, <span class="string">&#x27;2016-06-01 00:00&#x27;</span>::TIMESTAMPTZ);</span><br></pre></td></tr></table></figure><ul><li><code>TIMESTAMPTZ</code>以 UTC 存储，查询时转换为当前时区</li><li>建议使用<code>TIMESTAMPTZ</code>存储时间戳数据</li><li><code>TIMESTAMP</code>不包含时区信息，更改时区不影响存储值</li><li>两种类型都使用 8 字节存储</li><li>PostgreSQL 不存储时区数据，只存储 UTC 时间</li></ul><hr><h3 id="64-INTERVAL-间隔类型"><a href="#64-INTERVAL-间隔类型" class="headerlink" title="64. INTERVAL 间隔类型"></a>64. INTERVAL 间隔类型</h3><ul><li>间隔数据类型允许您存储和操作一段时间（以年、月、日、小时、分钟、秒等为单位）</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="type">INTERVAL</span> <span class="string">&#x27;quantity unit [quantity unit...] [direction]&#x27;</span></span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 基本间隔值</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="type">INTERVAL</span> <span class="string">&#x27;2 months&#x27;</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="type">INTERVAL</span> <span class="string">&#x27;3 hours 20 minutes&#x27;</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="type">INTERVAL</span> <span class="string">&#x27;1 year 2 months 3 days&#x27;</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="type">INTERVAL</span> <span class="string">&#x27;2 weeks ago&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 使用间隔进行日期运算</span></span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    NOW(),</span><br><span class="line">    NOW() <span class="operator">-</span> <span class="type">INTERVAL</span> <span class="string">&#x27;1 year 3 hours 20 minutes&#x27;</span> <span class="keyword">AS</span> past_time;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 加减间隔</span></span><br><span class="line"><span class="keyword">SELECT</span> NOW() <span class="operator">+</span> <span class="type">INTERVAL</span> <span class="string">&#x27;1 day&#x27;</span>;</span><br><span class="line"><span class="keyword">SELECT</span> NOW() <span class="operator">-</span> <span class="type">INTERVAL</span> <span class="string">&#x27;2 hours&#x27;</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">CURRENT_DATE</span> <span class="operator">+</span> <span class="type">INTERVAL</span> <span class="string">&#x27;7 days&#x27;</span>;</span><br></pre></td></tr></table></figure><hr><h3 id="65-UUID-数据类型"><a href="#65-UUID-数据类型" class="headerlink" title="65. UUID 数据类型"></a>65. UUID 数据类型</h3><ul><li>UUID 代表通用唯一标识符（Universal Unique Identifier），是由算法生成的 128 位数值。UUID 值由连字符分隔的 32 位十六进制数字组成</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- UUID 格式示例</span></span><br><span class="line"><span class="number">40e6215</span>d<span class="operator">-</span>b5c6<span class="number">-4896</span><span class="number">-987</span>c<span class="operator">-</span>f30f3678f608</span><br><span class="line"><span class="number">6</span>ecd8c99<span class="number">-4036</span><span class="number">-403</span>d<span class="operator">-</span>bf84<span class="operator">-</span>cf8400f67836</span><br><span class="line"><span class="number">3</span>f333df6<span class="number">-90</span>a4<span class="number">-4</span>fda<span class="number">-8</span>dd3<span class="number">-9485</span>d27cee36</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 安装 uuid-ossp 模块</span></span><br><span class="line"><span class="keyword">CREATE</span> EXTENSION IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> &quot;uuid-ossp&quot;;</span><br></pre></td></tr></table></figure><h4 id="生成-UUID-值"><a href="#生成-UUID-值" class="headerlink" title="生成 UUID 值"></a>生成 UUID 值</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 基于 MAC 地址、时间戳和随机值生成</span></span><br><span class="line"><span class="keyword">SELECT</span> uuid_generate_v1();</span><br><span class="line"><span class="comment">-- 0e37df36-f698-11e6-8dd4-cb9ced3df976</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 基于随机数生成（推荐）</span></span><br><span class="line"><span class="keyword">SELECT</span> uuid_generate_v4();</span><br><span class="line"><span class="comment">-- a81bc81b-dead-4e5d-abff-90865d1e13b1</span></span><br><span class="line"></span><br><span class="line"><span class="operator">-</span> 创建带 UUID 主键的表</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> contacts (</span><br><span class="line">    contact_id UUID <span class="keyword">DEFAULT</span> uuid_generate_v4(),</span><br><span class="line">    first_name <span class="type">VARCHAR</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    last_name <span class="type">VARCHAR</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    email <span class="type">VARCHAR</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    phone <span class="type">VARCHAR</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (contact_id)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 插入数据（UUID 自动生成）</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> contacts (first_name, last_name, email, phone)</span><br><span class="line"><span class="keyword">VALUES</span></span><br><span class="line">    (<span class="string">&#x27;John&#x27;</span>, <span class="string">&#x27;Smith&#x27;</span>, <span class="string">&#x27;john.smith@example.com&#x27;</span>, <span class="string">&#x27;408-237-2345&#x27;</span>),</span><br><span class="line">    (<span class="string">&#x27;Jane&#x27;</span>, <span class="string">&#x27;Smith&#x27;</span>, <span class="string">&#x27;jane.smith@example.com&#x27;</span>, <span class="string">&#x27;408-237-2344&#x27;</span>),</span><br><span class="line">    (<span class="string">&#x27;Alex&#x27;</span>, <span class="string">&#x27;Smith&#x27;</span>, <span class="string">&#x27;alex.smith@example.com&#x27;</span>, <span class="string">&#x27;408-237-2343&#x27;</span>);</span><br></pre></td></tr></table></figure><ul><li>UUID 保证在分布式系统中的唯一性</li><li>UUID 比 SERIAL 占用更多存储空间（16 字节 vs 4&#x2F;8 字节）</li><li><code>uuid_generate_v4()</code> 基于随机数，最常用</li><li><code>uuid_generate_v1()</code> 基于 MAC 地址和时间戳</li><li>适合分布式系统、微服务架构</li><li>索引性能略低于整数类型</li></ul><hr><h3 id="66-UUID-v7"><a href="#66-UUID-v7" class="headerlink" title="66. UUID v7"></a>66. UUID v7</h3><ul><li>UUID v7 是最新的 UUID 标准（RFC 9562），基于时间戳生成，具有更好的排序性能和索引效率。</li></ul><blockquote><p><a target="_blank" rel="noopener" href="https://github.com/dverite/postgres-uuidv7-sql">https://github.com/dverite/postgres-uuidv7-sql</a></p></blockquote><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 安装 pg_uuidv7 扩展（需要 PostgreSQL 13+）</span></span><br><span class="line"><span class="keyword">CREATE</span> EXTENSION IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> pg_uuidv7;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 生成 UUID v7</span></span><br><span class="line"><span class="keyword">SELECT</span> uuid_generate_v7();</span><br><span class="line"><span class="comment">-- 018c4e62-45a2-7000-8000-000000000001</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 批量生成</span></span><br><span class="line"><span class="keyword">SELECT</span> uuid_generate_v7() <span class="keyword">FROM</span> generate_series(<span class="number">1</span>, <span class="number">5</span>);</span><br></pre></td></tr></table></figure><ul><li>UUID v7 基于时间戳，提供更好的排序性能</li><li>索引效率优于 UUID v4（减少索引碎片）</li><li>适合需要时间排序的场景（日志、事件、交易）</li><li>需要安装 <code>pg_uuidv7</code> 扩展</li><li>仍然保证全局唯一性</li><li>比 SERIAL 更适合分布式系统</li></ul><hr><h3 id="67-JSON-数据类型"><a href="#67-JSON-数据类型" class="headerlink" title="67. JSON 数据类型"></a>67. JSON 数据类型</h3><ul><li>JSON（JavaScript Object Notation）是一种由键值对组成的开放标准格式。PostgreSQL 从 9.2 版本开始支持原生 JSON 数据类型</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 定义 JSON 列</span></span><br><span class="line">column_name JSON</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 或使用 JSONB（二进制 JSON，推荐）</span></span><br><span class="line">column_name JSONB</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建带 JSON 列的表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> orders (</span><br><span class="line">    id SERIAL <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    info JSON <span class="keyword">NOT</span> <span class="keyword">NULL</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 插入 JSON 数据</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> orders (info)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="string">&#x27;&#123;&quot;customer&quot;: &quot;John Doe&quot;, &quot;items&quot;: &#123;&quot;product&quot;: &quot;Beer&quot;, &quot;qty&quot;: 6&#125;&#125;&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> orders (info)</span><br><span class="line"><span class="keyword">VALUES</span></span><br><span class="line">    (<span class="string">&#x27;&#123;&quot;customer&quot;: &quot;Lily Bush&quot;, &quot;items&quot;: &#123;&quot;product&quot;: &quot;Diaper&quot;, &quot;qty&quot;: 24&#125;&#125;&#x27;</span>),</span><br><span class="line">    (<span class="string">&#x27;&#123;&quot;customer&quot;: &quot;Josh William&quot;, &quot;items&quot;: &#123;&quot;product&quot;: &quot;Toy Car&quot;, &quot;qty&quot;: 1&#125;&#125;&#x27;</span>),</span><br><span class="line">    (<span class="string">&#x27;&#123;&quot;customer&quot;: &quot;Mary Clark&quot;, &quot;items&quot;: &#123;&quot;product&quot;: &quot;Toy Train&quot;, &quot;qty&quot;: 2&#125;&#125;&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询 JSON 数据</span></span><br><span class="line"><span class="keyword">SELECT</span> info <span class="keyword">FROM</span> orders;</span><br></pre></td></tr></table></figure><h4 id="JSON-运算符"><a href="#JSON-运算符" class="headerlink" title="JSON 运算符"></a>JSON 运算符</h4><p><strong><code>-&gt;</code> 运算符：返回 JSON 对象字段</strong></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 获取客户信息（JSON 格式）</span></span><br><span class="line"><span class="keyword">SELECT</span> info <span class="operator">-</span><span class="operator">&gt;</span> <span class="string">&#x27;customer&#x27;</span> <span class="keyword">AS</span> customer</span><br><span class="line"><span class="keyword">FROM</span> orders;</span><br><span class="line"><span class="comment">-- | customer   |</span></span><br><span class="line"><span class="comment">-- |------------|</span></span><br><span class="line"><span class="comment">-- | &quot;John Doe&quot; |</span></span><br></pre></td></tr></table></figure><p><strong><code>-&gt;&gt;</code> 运算符：返回 JSON 对象字段（文本格式）</strong></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 获取客户信息（文本格式）</span></span><br><span class="line"><span class="keyword">SELECT</span> info <span class="operator">-</span><span class="operator">&gt;&gt;</span> <span class="string">&#x27;customer&#x27;</span> <span class="keyword">AS</span> customer</span><br><span class="line"><span class="keyword">FROM</span> orders;</span><br><span class="line"><span class="comment">-- | customer     |</span></span><br><span class="line"><span class="comment">-- |--------------|</span></span><br><span class="line"><span class="comment">-- | John Doe     |</span></span><br><span class="line"><span class="comment">-- | Lily Bush    |</span></span><br><span class="line"><span class="comment">-- | Josh William |</span></span><br></pre></td></tr></table></figure><h4 id="WHERE-子句中使用-JSON-运算符"><a href="#WHERE-子句中使用-JSON-运算符" class="headerlink" title="WHERE 子句中使用 JSON 运算符"></a>WHERE 子句中使用 JSON 运算符</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查找购买 Diaper 的客户</span></span><br><span class="line"><span class="keyword">SELECT</span> info <span class="operator">-</span><span class="operator">&gt;&gt;</span> <span class="string">&#x27;customer&#x27;</span> <span class="keyword">AS</span> customer</span><br><span class="line"><span class="keyword">FROM</span> orders</span><br><span class="line"><span class="keyword">WHERE</span> info <span class="operator">-</span><span class="operator">&gt;</span> <span class="string">&#x27;items&#x27;</span> <span class="operator">-</span><span class="operator">&gt;&gt;</span> <span class="string">&#x27;product&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;Diaper&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查找购买 2 个产品的客户</span></span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    info <span class="operator">-</span><span class="operator">&gt;&gt;</span> <span class="string">&#x27;customer&#x27;</span> <span class="keyword">AS</span> customer,</span><br><span class="line">    info <span class="operator">-</span><span class="operator">&gt;</span> <span class="string">&#x27;items&#x27;</span> <span class="operator">-</span><span class="operator">&gt;&gt;</span> <span class="string">&#x27;product&#x27;</span> <span class="keyword">AS</span> product</span><br><span class="line"><span class="keyword">FROM</span> orders</span><br><span class="line"><span class="keyword">WHERE</span> <span class="built_in">CAST</span>(info <span class="operator">-</span><span class="operator">&gt;</span> <span class="string">&#x27;items&#x27;</span> <span class="operator">-</span><span class="operator">&gt;&gt;</span> <span class="string">&#x27;qty&#x27;</span> <span class="keyword">AS</span> <span class="type">INTEGER</span>) <span class="operator">=</span> <span class="number">2</span>;</span><br></pre></td></tr></table></figure><h4 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 计算最小、最大、总和、平均数量</span></span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    <span class="built_in">MIN</span>(<span class="built_in">CAST</span>(info <span class="operator">-</span><span class="operator">&gt;</span> <span class="string">&#x27;items&#x27;</span> <span class="operator">-</span><span class="operator">&gt;&gt;</span> <span class="string">&#x27;qty&#x27;</span> <span class="keyword">AS</span> <span class="type">INTEGER</span>)) <span class="keyword">AS</span> min_qty,</span><br><span class="line">    <span class="built_in">MAX</span>(<span class="built_in">CAST</span>(info <span class="operator">-</span><span class="operator">&gt;</span> <span class="string">&#x27;items&#x27;</span> <span class="operator">-</span><span class="operator">&gt;&gt;</span> <span class="string">&#x27;qty&#x27;</span> <span class="keyword">AS</span> <span class="type">INTEGER</span>)) <span class="keyword">AS</span> max_qty,</span><br><span class="line">    <span class="built_in">SUM</span>(<span class="built_in">CAST</span>(info <span class="operator">-</span><span class="operator">&gt;</span> <span class="string">&#x27;items&#x27;</span> <span class="operator">-</span><span class="operator">&gt;&gt;</span> <span class="string">&#x27;qty&#x27;</span> <span class="keyword">AS</span> <span class="type">INTEGER</span>)) <span class="keyword">AS</span> total_qty,</span><br><span class="line">    <span class="built_in">AVG</span>(<span class="built_in">CAST</span>(info <span class="operator">-</span><span class="operator">&gt;</span> <span class="string">&#x27;items&#x27;</span> <span class="operator">-</span><span class="operator">&gt;&gt;</span> <span class="string">&#x27;qty&#x27;</span> <span class="keyword">AS</span> <span class="type">INTEGER</span>)) <span class="keyword">AS</span> avg_qty</span><br><span class="line"><span class="keyword">FROM</span> orders;</span><br><span class="line"><span class="comment">-- | min_qty | max_qty | total_qty | avg_qty |</span></span><br><span class="line"><span class="comment">-- |---------|---------|-----------|---------|</span></span><br><span class="line"><span class="comment">-- | 1       | 24      | 33        | 8.25    |</span></span><br></pre></td></tr></table></figure><h4 id="JSON-函数"><a href="#JSON-函数" class="headerlink" title="JSON 函数"></a>JSON 函数</h4><p><strong>json_each() - 展开 JSON 对象为键值对</strong></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> json_each(info)</span><br><span class="line"><span class="keyword">FROM</span> orders;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 获取文本格式的键值对</span></span><br><span class="line"><span class="keyword">SELECT</span> json_each_text(info)</span><br><span class="line"><span class="keyword">FROM</span> orders;</span><br></pre></td></tr></table></figure><p><strong>json_object_keys() - 获取 JSON 对象的键</strong></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 获取 items 对象的所有键</span></span><br><span class="line"><span class="keyword">SELECT</span> json_object_keys(info <span class="operator">-</span><span class="operator">&gt;</span> <span class="string">&#x27;items&#x27;</span>)</span><br><span class="line"><span class="keyword">FROM</span> orders;</span><br><span class="line"><span class="comment">-- | json_object_keys |</span></span><br><span class="line"><span class="comment">-- |------------------|</span></span><br><span class="line"><span class="comment">-- | product          |</span></span><br><span class="line"><span class="comment">-- | qty              |</span></span><br></pre></td></tr></table></figure><p><strong>json_typeof() - 获取 JSON 值的类型</strong></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 获取 items 的数据类型</span></span><br><span class="line"><span class="keyword">SELECT</span> json_typeof(info <span class="operator">-</span><span class="operator">&gt;</span> <span class="string">&#x27;items&#x27;</span>)</span><br><span class="line"><span class="keyword">FROM</span> orders;</span><br><span class="line"><span class="comment">-- | json_typeof |</span></span><br><span class="line"><span class="comment">-- |-------------|</span></span><br><span class="line"><span class="comment">-- | object      |</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 获取 qty 的数据类型</span></span><br><span class="line"><span class="keyword">SELECT</span> json_typeof(info <span class="operator">-</span><span class="operator">&gt;</span> <span class="string">&#x27;items&#x27;</span> <span class="operator">-</span><span class="operator">&gt;</span> <span class="string">&#x27;qty&#x27;</span>)</span><br><span class="line"><span class="keyword">FROM</span> orders;</span><br><span class="line"><span class="comment">-- | json_typeof |</span></span><br><span class="line"><span class="comment">-- |-------------|</span></span><br><span class="line"><span class="comment">-- | number      |</span></span><br></pre></td></tr></table></figure><h4 id="JSON-vs-JSONB"><a href="#JSON-vs-JSONB" class="headerlink" title="JSON vs JSONB"></a>JSON vs JSONB</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- JSON：存储文本格式，保留空格和顺序</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> data_json (</span><br><span class="line">    id SERIAL <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    data JSON</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- JSONB：存储二进制格式，支持索引，性能更好（推荐）</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> data_jsonb (</span><br><span class="line">    id SERIAL <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    data JSONB</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- JSONB 支持更多运算符</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="string">&#x27;&#123;&quot;a&quot;: 1, &quot;b&quot;: 2&#125;&#x27;</span>::JSONB @<span class="operator">&gt;</span> <span class="string">&#x27;&#123;&quot;a&quot;: 1&#125;&#x27;</span>::JSONB;  <span class="comment">-- true</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="string">&#x27;&#123;&quot;a&quot;: 1&#125;&#x27;</span>::JSONB <span class="operator">&lt;</span>@ <span class="string">&#x27;&#123;&quot;a&quot;: 1, &quot;b&quot;: 2&#125;&#x27;</span>::JSONB;  <span class="comment">-- true</span></span><br></pre></td></tr></table></figure><ul><li><code>JSON</code> 存储原始文本，<code>JSONB</code> 存储二进制格式（推荐使用 JSONB）</li><li><code>-&gt;</code> 返回 JSON 对象，<code>-&gt;&gt;</code> 返回文本</li><li>JSONB 支持索引，查询性能更好</li><li>使用 <code>CAST</code> 转换 JSON 值到其他数据类型</li><li>JSONB 支持更多运算符（<code>@&gt;</code>、<code>&lt;@</code>、<code>?</code> 等）</li></ul><hr><h2 id="条件表达式"><a href="#条件表达式" class="headerlink" title="条件表达式"></a>条件表达式</h2><h3 id="68-CASE-表达式"><a href="#68-CASE-表达式" class="headerlink" title="68. CASE 表达式"></a>68. CASE 表达式</h3><ul><li>PostgreSQL 的<code>CASE</code>表达式类似于其他编程语言中的 IF&#x2F;ELSE 语句，允许您向查询添加条件逻辑</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CASE</span> </span><br><span class="line">    <span class="keyword">WHEN</span> condition_1 <span class="keyword">THEN</span> result_1</span><br><span class="line">    <span class="keyword">WHEN</span> condition_2 <span class="keyword">THEN</span> result_2</span><br><span class="line">    [<span class="keyword">WHEN</span> ...]</span><br><span class="line">    [<span class="keyword">ELSE</span> else_result]</span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 员工薪资等级分类</span></span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    employee_id,</span><br><span class="line">    name,</span><br><span class="line">    salary,</span><br><span class="line">    <span class="keyword">CASE</span></span><br><span class="line">        <span class="keyword">WHEN</span> salary <span class="operator">&lt;</span> <span class="number">40000</span> <span class="keyword">THEN</span> <span class="string">&#x27;Low&#x27;</span></span><br><span class="line">        <span class="keyword">WHEN</span> salary <span class="operator">&gt;=</span> <span class="number">40000</span> <span class="keyword">AND</span> salary <span class="operator">&lt;</span> <span class="number">70000</span> <span class="keyword">THEN</span> <span class="string">&#x27;Medium&#x27;</span></span><br><span class="line">        <span class="keyword">WHEN</span> salary <span class="operator">&gt;=</span> <span class="number">70000</span> <span class="keyword">THEN</span> <span class="string">&#x27;High&#x27;</span></span><br><span class="line">    <span class="keyword">END</span> <span class="keyword">AS</span> salary_level</span><br><span class="line"><span class="keyword">FROM</span> employees;</span><br><span class="line"><span class="comment">-- | employee_id | name    | salary | salary_level |</span></span><br><span class="line"><span class="comment">-- |-------------|---------|--------|--------------|</span></span><br><span class="line"><span class="comment">-- | 1           | Alice   | 75000  | High         |</span></span><br><span class="line"><span class="comment">-- | 2           | Bob     | 55000  | Medium       |</span></span><br><span class="line"><span class="comment">-- | 3           | Charlie | 35000  | Low          |</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 订单状态描述</span></span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    order_id,</span><br><span class="line">    status,</span><br><span class="line">    <span class="keyword">CASE</span></span><br><span class="line">        <span class="keyword">WHEN</span> status <span class="operator">=</span> <span class="string">&#x27;pending&#x27;</span> <span class="keyword">THEN</span> <span class="string">&#x27;Order received&#x27;</span></span><br><span class="line">        <span class="keyword">WHEN</span> status <span class="operator">=</span> <span class="string">&#x27;processing&#x27;</span> <span class="keyword">THEN</span> <span class="string">&#x27;Being prepared&#x27;</span></span><br><span class="line">        <span class="keyword">WHEN</span> status <span class="operator">=</span> <span class="string">&#x27;shipped&#x27;</span> <span class="keyword">THEN</span> <span class="string">&#x27;On the way&#x27;</span></span><br><span class="line">        <span class="keyword">WHEN</span> status <span class="operator">=</span> <span class="string">&#x27;delivered&#x27;</span> <span class="keyword">THEN</span> <span class="string">&#x27;Completed&#x27;</span></span><br><span class="line">        <span class="keyword">ELSE</span> <span class="string">&#x27;Unknown status&#x27;</span></span><br><span class="line">    <span class="keyword">END</span> <span class="keyword">AS</span> status_description</span><br><span class="line"><span class="keyword">FROM</span> orders;</span><br></pre></td></tr></table></figure><ul><li><code>CASE</code>是一个表达式，可以在 SELECT、WHERE、GROUP BY、HAVING、ORDER BY 等子句中使用</li><li>通用 CASE 使用条件表达式，简单 CASE 使用值比较</li><li>如果省略<code>ELSE</code>子句，默认返回 NULL</li><li><code>CASE</code>表达式从上到下顺序评估，找到第一个匹配后立即返回</li><li>可以嵌套使用 CASE 表达式</li></ul><hr><h3 id="69-COALESCE-函数"><a href="#69-COALESCE-函数" class="headerlink" title="69. COALESCE 函数"></a>69. COALESCE 函数</h3><ul><li><code>COALESCE</code>函数返回参数列表中的第一个非空值。常用于处理和替换 NULL 值</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="built_in">COALESCE</span>(argument_1, argument_2, ...)</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 基本用法</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COALESCE</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="comment">-- 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COALESCE</span>(<span class="keyword">NULL</span>, <span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line"><span class="comment">-- 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COALESCE</span>(<span class="keyword">NULL</span>, <span class="keyword">NULL</span>, <span class="string">&#x27;default&#x27;</span>);</span><br><span class="line"><span class="comment">-- &#x27;default&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COALESCE</span>(<span class="keyword">NULL</span>, <span class="keyword">NULL</span>, <span class="keyword">NULL</span>);</span><br><span class="line"><span class="comment">-- NULL</span></span><br></pre></td></tr></table></figure><ul><li><code>COALESCE</code>函数与 SQL 标准的<code>NVL</code>（Oracle）或<code>IFNULL</code>（MySQL）功能相同</li><li>性能与<code>CASE</code>表达式相同，但更简洁</li><li>第一个非 NULL 参数后的参数不会被评估</li><li>所有参数应具有兼容的数据类型</li><li>比<code>CASE</code>表达式更易读和维护</li></ul><hr><h3 id="70-NULLIF-函数"><a href="#70-NULLIF-函数" class="headerlink" title="70. NULLIF 函数"></a>70. NULLIF 函数</h3><ul><li><code>NULLIF</code>函数比较两个参数，如果相等则返回 NULL，否则返回第一个参数。常用于处理特殊值和防止错误</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NULLIF</span>(argument_1, argument_2)</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 基本用法</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">NULLIF</span>(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="comment">-- NULL</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">NULLIF</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="comment">-- 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">NULLIF</span>(<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>);</span><br><span class="line"><span class="comment">-- &#x27;A&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">NULLIF</span>(<span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;&#x27;</span>);</span><br><span class="line"><span class="comment">-- NULL</span></span><br></pre></td></tr></table></figure><ul><li>常与 <code>COALESCE</code> 组合，防止除零和处理空字符串</li><li>比 <code>CASE</code> 简洁，但返回 NULL 需后续处理</li><li>两参数需类型兼容</li></ul><hr><h3 id="71-CAST-类型转换"><a href="#71-CAST-类型转换" class="headerlink" title="71. CAST 类型转换"></a>71. CAST 类型转换</h3><ul><li>PostgreSQL 的<code>CAST</code>运算符允许将一种数据类型的值转换为另一种数据类型</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- CAST 语法（SQL 标准）</span></span><br><span class="line"><span class="built_in">CAST</span>(expression <span class="keyword">AS</span> target_type)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- :: 运算符（PostgreSQL 特定）</span></span><br><span class="line">expression::target_type</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 字符串转整数</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">CAST</span>(<span class="string">&#x27;100&#x27;</span> <span class="keyword">AS</span> <span class="type">INTEGER</span>);</span><br><span class="line"><span class="comment">-- 100</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="string">&#x27;100&#x27;</span>::<span class="type">INTEGER</span>;</span><br><span class="line"><span class="comment">-- 100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 字符串转日期</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">CAST</span>(<span class="string">&#x27;2015-01-01&#x27;</span> <span class="keyword">AS</span> <span class="type">DATE</span>);</span><br><span class="line"><span class="comment">-- 2015-01-01</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="string">&#x27;01-OCT-2015&#x27;</span>::<span class="type">DATE</span>;</span><br><span class="line"><span class="comment">-- 2015-10-01</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 字符串转浮点数</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">CAST</span>(<span class="string">&#x27;10.2&#x27;</span> <span class="keyword">AS</span> <span class="type">DOUBLE PRECISION</span>);</span><br><span class="line"><span class="comment">-- 10.2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="string">&#x27;10.2&#x27;</span>::<span class="type">NUMERIC</span>;</span><br><span class="line"><span class="comment">-- 10.2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 字符串转布尔值</span></span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    <span class="built_in">CAST</span>(<span class="string">&#x27;true&#x27;</span> <span class="keyword">AS</span> <span class="type">BOOLEAN</span>),</span><br><span class="line">    <span class="built_in">CAST</span>(<span class="string">&#x27;false&#x27;</span> <span class="keyword">AS</span> <span class="type">BOOLEAN</span>),</span><br><span class="line">    <span class="built_in">CAST</span>(<span class="string">&#x27;T&#x27;</span> <span class="keyword">AS</span> <span class="type">BOOLEAN</span>),</span><br><span class="line">    <span class="built_in">CAST</span>(<span class="string">&#x27;F&#x27;</span> <span class="keyword">AS</span> <span class="type">BOOLEAN</span>);</span><br><span class="line"><span class="comment">-- | true | false | true | false |</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 字符串转时间戳</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="string">&#x27;2019-06-15 14:30:20&#x27;</span>::<span class="type">TIMESTAMP</span>;</span><br><span class="line"><span class="comment">-- 2019-06-15 14:30:20</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 字符串转间隔</span></span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    <span class="string">&#x27;15 minute&#x27;</span>::<span class="type">INTERVAL</span>,</span><br><span class="line">    <span class="string">&#x27;2 hour&#x27;</span>::<span class="type">INTERVAL</span>,</span><br><span class="line">    <span class="string">&#x27;1 day&#x27;</span>::<span class="type">INTERVAL</span>,</span><br><span class="line">    <span class="string">&#x27;2 week&#x27;</span>::<span class="type">INTERVAL</span>,</span><br><span class="line">    <span class="string">&#x27;3 month&#x27;</span>::<span class="type">INTERVAL</span>;</span><br></pre></td></tr></table></figure><ul><li><code>CAST</code>是 SQL 标准，<code>::</code>是 PostgreSQL 特定语法</li><li>无效转换会导致错误</li><li>转换可能导致精度损失（如 NUMERIC 转 INTEGER）</li><li>在列上使用<code>CAST</code>可能影响索引性能</li><li>使用<code>CASE</code>表达式处理可能失败的转换</li><li>某些类型需要特定格式（如<code>DOUBLE PRECISION</code>而非<code>DOUBLE</code>）</li></ul><hr><h2 id="处理-JSON"><a href="#处理-JSON" class="headerlink" title="处理 JSON"></a>处理 JSON</h2><h3 id="72-查询-JSON-数组"><a href="#72-查询-JSON-数组" class="headerlink" title="72. 查询 JSON 数组"></a>72. 查询 JSON 数组</h3><ul><li>PostgreSQL 提供多种函数将 JSON 列中嵌套的数组转换为表行，便于查询和处理</li><li><code>json_array_elements()</code> - 将 JSON 数组展开为行集</li><li><code>jsonb_array_elements()</code> - 将 JSONB 数组展开为行集（推荐）</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 展开简单数组</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> json_array_elements(<span class="string">&#x27;[1, 2, 3]&#x27;</span>) <span class="keyword">AS</span> elem;</span><br><span class="line"><span class="comment">-- | elem |</span></span><br><span class="line"><span class="comment">-- |------|</span></span><br><span class="line"><span class="comment">-- | 1    |</span></span><br><span class="line"><span class="comment">-- | 2    |</span></span><br><span class="line"><span class="comment">-- | 3    |</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 展开字符串数组</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> json_array_elements(<span class="string">&#x27;[&quot;apple&quot;, &quot;banana&quot;, &quot;orange&quot;]&#x27;</span>) <span class="keyword">AS</span> fruit;</span><br><span class="line"><span class="comment">-- | fruit    |</span></span><br><span class="line"><span class="comment">-- |----------|</span></span><br><span class="line"><span class="comment">-- | &quot;apple&quot;  |</span></span><br><span class="line"><span class="comment">-- | &quot;banana&quot; |</span></span><br><span class="line"><span class="comment">-- | &quot;orange&quot; |</span></span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建用户表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> users(</span><br><span class="line">    user_id SERIAL <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    username <span class="type">VARCHAR</span>(<span class="number">50</span>),</span><br><span class="line">    hobbies JSONB</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 插入数据</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> users(username, hobbies) </span><br><span class="line"><span class="keyword">VALUES</span> </span><br><span class="line">    (<span class="string">&#x27;alice&#x27;</span>, <span class="string">&#x27;[&quot;reading&quot;, &quot;coding&quot;, &quot;gaming&quot;]&#x27;</span>),</span><br><span class="line">    (<span class="string">&#x27;bob&#x27;</span>, <span class="string">&#x27;[&quot;music&quot;, &quot;sports&quot;]&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 展开爱好数组</span></span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    user_id,</span><br><span class="line">    username,</span><br><span class="line">    jsonb_array_elements_text(hobbies) <span class="keyword">AS</span> hobby</span><br><span class="line"><span class="keyword">FROM</span> users;</span><br><span class="line"><span class="comment">-- | user_id | username | hobby   |</span></span><br><span class="line"><span class="comment">-- |---------|----------|---------|</span></span><br><span class="line"><span class="comment">-- | 1       | alice    | reading |</span></span><br><span class="line"><span class="comment">-- | 1       | alice    | coding  |</span></span><br><span class="line"><span class="comment">-- | 1       | alice    | gaming  |</span></span><br><span class="line"><span class="comment">-- | 2       | bob      | music   |</span></span><br><span class="line"><span class="comment">-- | 2       | bob      | sports  |</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 使用 WITH ORDINALITY 获取位置</span></span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    username,</span><br><span class="line">    position,</span><br><span class="line">    hobby</span><br><span class="line"><span class="keyword">FROM</span> users,</span><br><span class="line">    jsonb_array_elements_text(hobbies) <span class="keyword">WITH</span> ORDINALITY <span class="keyword">AS</span> t(hobby, position);</span><br><span class="line"><span class="comment">-- | username | position | hobby   |</span></span><br><span class="line"><span class="comment">-- |----------|----------|---------|</span></span><br><span class="line"><span class="comment">-- | alice    | 1        | reading |</span></span><br><span class="line"><span class="comment">-- | alice    | 2        | coding  |</span></span><br><span class="line"><span class="comment">-- | alice    | 3        | gaming  |</span></span><br><span class="line"><span class="comment">-- | bob      | 1        | music   |</span></span><br><span class="line"><span class="comment">-- | bob      | 2        | sports  |</span></span><br></pre></td></tr></table></figure><ul><li><code>json_to_recordset()</code> - 将 JSON 对象数组转换为记录集</li><li><code>jsonb_to_recordset()</code> - 将 JSONB 对象数组转换为记录集</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 将 JSON 对象数组转换为记录集</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span></span><br><span class="line">    json_to_recordset(<span class="string">&#x27;[</span></span><br><span class="line"><span class="string">        &#123;&quot;id&quot;: 1, &quot;name&quot;: &quot;Alice&quot;, &quot;age&quot;: 28&#125;,</span></span><br><span class="line"><span class="string">        &#123;&quot;id&quot;: 2, &quot;name&quot;: &quot;Bob&quot;, &quot;age&quot;: 35&#125;</span></span><br><span class="line"><span class="string">    ]&#x27;</span>) <span class="keyword">AS</span> t(id <span class="type">INT</span>, name TEXT, age <span class="type">INT</span>);</span><br><span class="line"><span class="comment">-- | id | name  | age |</span></span><br><span class="line"><span class="comment">-- |----|-------|-----|</span></span><br><span class="line"><span class="comment">-- | 1  | Alice | 28  |</span></span><br><span class="line"><span class="comment">-- | 2  | Bob   | 35  |</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 使用 JSONB</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span></span><br><span class="line">    jsonb_to_recordset(<span class="string">&#x27;[</span></span><br><span class="line"><span class="string">        &#123;&quot;id&quot;: 1, &quot;name&quot;: &quot;Alice&quot;&#125;,</span></span><br><span class="line"><span class="string">        &#123;&quot;id&quot;: 2, &quot;name&quot;: &quot;Bob&quot;&#125;</span></span><br><span class="line"><span class="string">    ]&#x27;</span>) <span class="keyword">AS</span> t(id <span class="type">INT</span>, name TEXT);</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 订单表包含商品数组</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> orders (</span><br><span class="line">    order_id SERIAL <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    customer_name <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    items JSONB</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> orders (customer_name, items)</span><br><span class="line"><span class="keyword">VALUES</span> </span><br><span class="line">    (<span class="string">&#x27;John&#x27;</span>, <span class="string">&#x27;[</span></span><br><span class="line"><span class="string">        &#123;&quot;product&quot;: &quot;Laptop&quot;, &quot;price&quot;: 999.99, &quot;quantity&quot;: 1&#125;,</span></span><br><span class="line"><span class="string">        &#123;&quot;product&quot;: &quot;Mouse&quot;, &quot;price&quot;: 29.99, &quot;quantity&quot;: 2&#125;</span></span><br><span class="line"><span class="string">    ]&#x27;</span>),</span><br><span class="line">    (<span class="string">&#x27;Jane&#x27;</span>, <span class="string">&#x27;[</span></span><br><span class="line"><span class="string">        &#123;&quot;product&quot;: &quot;Monitor&quot;, &quot;price&quot;: 299.99, &quot;quantity&quot;: 1&#125;</span></span><br><span class="line"><span class="string">    ]&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询所有订单项</span></span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    o.order_id,</span><br><span class="line">    o.customer_name,</span><br><span class="line">    item<span class="operator">-</span><span class="operator">&gt;&gt;</span><span class="string">&#x27;product&#x27;</span> <span class="keyword">AS</span> product,</span><br><span class="line">    (item<span class="operator">-</span><span class="operator">&gt;&gt;</span><span class="string">&#x27;price&#x27;</span>)::<span class="type">NUMERIC</span> <span class="keyword">AS</span> price,</span><br><span class="line">    (item<span class="operator">-</span><span class="operator">&gt;&gt;</span><span class="string">&#x27;quantity&#x27;</span>)::<span class="type">INTEGER</span> <span class="keyword">AS</span> quantity</span><br><span class="line"><span class="keyword">FROM</span> orders o,</span><br><span class="line">    jsonb_array_elements(o.items) <span class="keyword">AS</span> item;</span><br><span class="line"><span class="comment">-- | order_id | customer_name | product | price  | quantity |</span></span><br><span class="line"><span class="comment">-- |----------|---------------|---------|--------|----------|</span></span><br><span class="line"><span class="comment">-- | 1        | John          | Laptop  | 999.99 | 1        |</span></span><br><span class="line"><span class="comment">-- | 1        | John          | Mouse   | 29.99  | 2        |</span></span><br><span class="line"><span class="comment">-- | 2        | Jane          | Monitor | 299.99 | 1        |</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 计算订单总额</span></span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    o.order_id,</span><br><span class="line">    o.customer_name,</span><br><span class="line">    <span class="built_in">SUM</span>((item<span class="operator">-</span><span class="operator">&gt;&gt;</span><span class="string">&#x27;price&#x27;</span>)::<span class="type">NUMERIC</span> <span class="operator">*</span> (item<span class="operator">-</span><span class="operator">&gt;&gt;</span><span class="string">&#x27;quantity&#x27;</span>)::<span class="type">INTEGER</span>) <span class="keyword">AS</span> total</span><br><span class="line"><span class="keyword">FROM</span> orders o,</span><br><span class="line">    jsonb_array_elements(o.items) <span class="keyword">AS</span> item</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> o.order_id, o.customer_name;</span><br><span class="line"><span class="comment">-- | order_id | customer_name | total   |</span></span><br><span class="line"><span class="comment">-- |----------|---------------|---------|</span></span><br><span class="line"><span class="comment">-- | 1        | John          | 1059.97 |</span></span><br><span class="line"><span class="comment">-- | 2        | Jane          | 299.99  |</span></span><br></pre></td></tr></table></figure><ul><li><code>jsonb_array_elements()</code>比<code>json_array_elements()</code>性能更好（推荐）</li><li>使用<code>WITH ORDINALITY</code>可以获取数组元素的位置（从 1 开始）</li><li><code>json_to_recordset()</code>需要显式指定列名和类型</li><li>展开数组会产生笛卡尔积，注意性能影响</li><li>使用<code>-&gt;</code>获取 JSON 对象，<code>-&gt;&gt;</code>获取文本值</li></ul><hr><h3 id="73-修改-JSON-数组"><a href="#73-修改-JSON-数组" class="headerlink" title="73. 修改 JSON 数组"></a>73. 修改 JSON 数组</h3><ul><li>PostgreSQL 提供多种方法来修改 JSON 列中嵌套的数组，包括添加、删除和更新元素</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 添加元素</span></span><br><span class="line"><span class="keyword">UPDATE</span> table_name</span><br><span class="line"><span class="keyword">SET</span> json_column <span class="operator">=</span> jsonb_set(</span><br><span class="line">    json_column, </span><br><span class="line">    <span class="string">&#x27;&#123;array_key&#125;&#x27;</span>,</span><br><span class="line">    json_column<span class="operator">-</span><span class="operator">&gt;</span><span class="string">&#x27;array_key&#x27;</span> <span class="operator">||</span> <span class="string">&#x27;[&quot;new_value&quot;]&#x27;</span>::jsonb</span><br><span class="line">)</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">condition</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除元素</span></span><br><span class="line"><span class="keyword">UPDATE</span> table_name</span><br><span class="line"><span class="keyword">SET</span> json_column <span class="operator">=</span> jsonb_set(</span><br><span class="line">    json_column,</span><br><span class="line">    <span class="string">&#x27;&#123;array_key&#125;&#x27;</span>,</span><br><span class="line">    (<span class="keyword">SELECT</span> jsonb_agg(elem)</span><br><span class="line">     <span class="keyword">FROM</span> jsonb_array_elements(json_column<span class="operator">-</span><span class="operator">&gt;</span><span class="string">&#x27;array_key&#x27;</span>) elem</span><br><span class="line">     <span class="keyword">WHERE</span> elem <span class="operator">!=</span> <span class="string">&#x27;&quot;value_to_remove&quot;&#x27;</span>::jsonb)</span><br><span class="line">)</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">condition</span>;</span><br></pre></td></tr></table></figure><h4 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建用户表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> users (</span><br><span class="line">    id SERIAL <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    username TEXT <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    meta_data JSONB <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#123;&#125;&#x27;</span>::jsonb</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 插入数据</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> users (username, meta_data)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;johndoe&#x27;</span>, <span class="string">&#x27;&#123;&quot;roles&quot;: [&quot;hr&quot;, &quot;marketing&quot;, &quot;sales&quot;]&#125;&#x27;</span>::jsonb);</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users;</span><br><span class="line"><span class="comment">-- | id | username | meta_data                               |</span></span><br><span class="line"><span class="comment">-- |----|----------|-----------------------------------------|</span></span><br><span class="line"><span class="comment">-- | 1  | johndoe  | &#123;&quot;roles&quot;: [&quot;hr&quot;, &quot;marketing&quot;, &quot;sales&quot;]&#125; |</span></span><br></pre></td></tr></table></figure><h4 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 删除特定角色</span></span><br><span class="line"><span class="keyword">UPDATE</span> users</span><br><span class="line"><span class="keyword">SET</span> meta_data <span class="operator">=</span> jsonb_set(</span><br><span class="line">    meta_data,</span><br><span class="line">    <span class="string">&#x27;&#123;roles&#125;&#x27;</span>,</span><br><span class="line">    (<span class="keyword">SELECT</span> jsonb_agg(elem)</span><br><span class="line">     <span class="keyword">FROM</span> jsonb_array_elements(meta_data<span class="operator">-</span><span class="operator">&gt;</span><span class="string">&#x27;roles&#x27;</span>) elem</span><br><span class="line">     <span class="keyword">WHERE</span> elem <span class="operator">!=</span> <span class="string">&#x27;&quot;marketing&quot;&#x27;</span>::jsonb)</span><br><span class="line">)</span><br><span class="line"><span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users;</span><br><span class="line"><span class="comment">-- | id | username | meta_data                           |</span></span><br><span class="line"><span class="comment">-- |----|----------|-------------------------------------|</span></span><br><span class="line"><span class="comment">-- | 1  | johndoe  | &#123;&quot;roles&quot;: [&quot;hr&quot;, &quot;sales&quot;, &quot;development&quot;]&#125; |</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除多个元素</span></span><br><span class="line"><span class="keyword">UPDATE</span> users</span><br><span class="line"><span class="keyword">SET</span> meta_data <span class="operator">=</span> jsonb_set(</span><br><span class="line">    meta_data,</span><br><span class="line">    <span class="string">&#x27;&#123;roles&#125;&#x27;</span>,</span><br><span class="line">    (<span class="keyword">SELECT</span> jsonb_agg(elem)</span><br><span class="line">     <span class="keyword">FROM</span> jsonb_array_elements(meta_data<span class="operator">-</span><span class="operator">&gt;</span><span class="string">&#x27;roles&#x27;</span>) elem</span><br><span class="line">     <span class="keyword">WHERE</span> elem <span class="keyword">NOT</span> <span class="keyword">IN</span> (<span class="string">&#x27;&quot;hr&quot;&#x27;</span>::jsonb, <span class="string">&#x27;&quot;sales&quot;&#x27;</span>::jsonb))</span><br><span class="line">)</span><br><span class="line"><span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><h4 id="替换特定位置的元素"><a href="#替换特定位置的元素" class="headerlink" title="替换特定位置的元素"></a>替换特定位置的元素</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 替换第一个元素（索引从0开始）</span></span><br><span class="line"><span class="keyword">UPDATE</span> users</span><br><span class="line"><span class="keyword">SET</span> meta_data <span class="operator">=</span> jsonb_set(</span><br><span class="line">    meta_data, </span><br><span class="line">    <span class="string">&#x27;&#123;roles,0&#125;&#x27;</span>, </span><br><span class="line">    <span class="string">&#x27;&quot;admin&quot;&#x27;</span>::jsonb</span><br><span class="line">)</span><br><span class="line"><span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 替换第二个元素</span></span><br><span class="line"><span class="keyword">UPDATE</span> users</span><br><span class="line"><span class="keyword">SET</span> meta_data <span class="operator">=</span> jsonb_set(</span><br><span class="line">    meta_data, </span><br><span class="line">    <span class="string">&#x27;&#123;roles,1&#125;&#x27;</span>, </span><br><span class="line">    <span class="string">&#x27;&quot;manager&quot;&#x27;</span>::jsonb</span><br><span class="line">)</span><br><span class="line"><span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><ul><li><code>||</code> 连接数组，<code>jsonb_agg()</code> 聚合行为数组</li><li><code>?</code> 检查键&#x2F;元素存在性，索引从 0 开始</li><li>修改替换整个数组（非原地），用 <code>COALESCE</code> 处理空值</li></ul><hr><h3 id="74-提取-JSON-数据"><a href="#74-提取-JSON-数据" class="headerlink" title="74. 提取 JSON 数据"></a>74. 提取 JSON 数据</h3><ul><li>PostgreSQL 提供<code>-&gt;</code>和<code>-&gt;&gt;</code>运算符从 JSON 数组中提取元素，或从 JSON 对象中提取键的值</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 从数组中提取元素（返回 JSONB）</span></span><br><span class="line">json_array <span class="operator">-</span><span class="operator">&gt;</span> n</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 从数组中提取元素（返回文本）</span></span><br><span class="line">json_array <span class="operator">-</span><span class="operator">&gt;&gt;</span> n</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 从对象中提取值（返回 JSONB）</span></span><br><span class="line">json_object <span class="operator">-</span><span class="operator">&gt;</span> <span class="string">&#x27;key&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 从对象中提取值（返回文本）</span></span><br><span class="line">json_object <span class="operator">-</span><span class="operator">&gt;&gt;</span> <span class="string">&#x27;key&#x27;</span></span><br></pre></td></tr></table></figure><ul><li><code>n</code> - 数组索引，从 0 开始，负数从末尾开始（-1 是最后一个）</li><li><code>-&gt;</code> 返回 JSONB 值</li><li><code>-&gt;&gt;</code> 返回文本字符串</li></ul><h4 id="从数组中提取元素"><a href="#从数组中提取元素" class="headerlink" title="从数组中提取元素"></a>从数组中提取元素</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建员工表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> employees(</span><br><span class="line">    id SERIAL <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    phones JSONB <span class="keyword">NOT</span> <span class="keyword">NULL</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 插入数据</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employees (name, phones)</span><br><span class="line"><span class="keyword">VALUES</span></span><br><span class="line">    (<span class="string">&#x27;John Doe&#x27;</span>, <span class="string">&#x27;[&quot;(408) 555-1111&quot;, &quot;(408) 555-2222&quot;, &quot;(408) 555-3333&quot;]&#x27;</span>),</span><br><span class="line">    (<span class="string">&#x27;Jane Smith&#x27;</span>, <span class="string">&#x27;[&quot;(408) 666-1111&quot;, &quot;(408) 666-2222&quot;, &quot;(408) 666-3333&quot;]&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 提取第一个电话（JSONB 格式）</span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    name,</span><br><span class="line">    phones <span class="operator">-</span><span class="operator">&gt;</span> <span class="number">0</span> <span class="keyword">AS</span> phone</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">&#x27;John Doe&#x27;</span>;</span><br><span class="line"><span class="comment">-- | name     | phone            |</span></span><br><span class="line"><span class="comment">-- |----------|------------------|</span></span><br><span class="line"><span class="comment">-- | John Doe | &quot;(408) 555-1111&quot; |</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 提取第一个电话（文本格式）</span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    name,</span><br><span class="line">    phones <span class="operator">-</span><span class="operator">&gt;&gt;</span> <span class="number">0</span> <span class="keyword">AS</span> phone</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">&#x27;John Doe&#x27;</span>;</span><br><span class="line"><span class="comment">-- | name     | phone          |</span></span><br><span class="line"><span class="comment">-- |----------|----------------|</span></span><br><span class="line"><span class="comment">-- | John Doe | (408) 555-1111 |</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 提取最后一个电话</span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    name,</span><br><span class="line">    phones <span class="operator">-</span><span class="operator">&gt;&gt;</span> <span class="number">-1</span> <span class="keyword">AS</span> phone</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">&#x27;Jane Smith&#x27;</span>;</span><br><span class="line"><span class="comment">-- | name       | phone          |</span></span><br><span class="line"><span class="comment">-- |------------|----------------|</span></span><br><span class="line"><span class="comment">-- | Jane Smith | (408) 666-3333 |</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 提取不存在的元素（返回 NULL）</span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    name,</span><br><span class="line">    phones <span class="operator">-</span><span class="operator">&gt;</span> <span class="number">5</span> <span class="keyword">AS</span> phone</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">&#x27;John Doe&#x27;</span>;</span><br><span class="line"><span class="comment">-- | name     | phone |</span></span><br><span class="line"><span class="comment">-- |----------|-------|</span></span><br><span class="line"><span class="comment">-- | John Doe | null  |</span></span><br></pre></td></tr></table></figure><h4 id="从对象中提取值"><a href="#从对象中提取值" class="headerlink" title="从对象中提取值"></a>从对象中提取值</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建请求表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> requests(</span><br><span class="line">    id SERIAL <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    employee_id <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    request_date <span class="type">DATE</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    data JSONB <span class="keyword">NOT</span> <span class="keyword">NULL</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 插入数据</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> requests (employee_id, request_date, data)</span><br><span class="line"><span class="keyword">VALUES</span></span><br><span class="line">    (<span class="number">1</span>, <span class="string">&#x27;2024-02-23&#x27;</span>, <span class="string">&#x27;&#123;</span></span><br><span class="line"><span class="string">        &quot;current_position&quot;: &quot;Software Engineer&quot;,</span></span><br><span class="line"><span class="string">        &quot;new_position&quot;: &quot;Senior Software Engineer&quot;,</span></span><br><span class="line"><span class="string">        &quot;effective_date&quot;: &quot;2024-03-01&quot;</span></span><br><span class="line"><span class="string">    &#125;&#x27;</span>),</span><br><span class="line">    (<span class="number">2</span>, <span class="string">&#x27;2024-02-24&#x27;</span>, <span class="string">&#x27;&#123;</span></span><br><span class="line"><span class="string">        &quot;current_position&quot;: &quot;Data Analyst&quot;,</span></span><br><span class="line"><span class="string">        &quot;new_position&quot;: &quot;Senior Data Analyst&quot;,</span></span><br><span class="line"><span class="string">        &quot;effective_date&quot;: &quot;2024-03-15&quot;</span></span><br><span class="line"><span class="string">    &#125;&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 提取当前职位（JSONB 格式）</span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    data <span class="operator">-</span><span class="operator">&gt;</span> <span class="string">&#x27;current_position&#x27;</span> <span class="keyword">AS</span> current_position</span><br><span class="line"><span class="keyword">FROM</span> requests</span><br><span class="line"><span class="keyword">WHERE</span> employee_id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="comment">-- | current_position    |</span></span><br><span class="line"><span class="comment">-- |---------------------|</span></span><br><span class="line"><span class="comment">-- | &quot;Software Engineer&quot; |</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 提取当前职位（文本格式）</span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    data <span class="operator">-</span><span class="operator">&gt;&gt;</span> <span class="string">&#x27;current_position&#x27;</span> <span class="keyword">AS</span> current_position</span><br><span class="line"><span class="keyword">FROM</span> requests</span><br><span class="line"><span class="keyword">WHERE</span> employee_id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="comment">-- | current_position  |</span></span><br><span class="line"><span class="comment">-- |-------------------|</span></span><br><span class="line"><span class="comment">-- | Software Engineer |</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 提取多个键</span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    employee_id,</span><br><span class="line">    data <span class="operator">-</span><span class="operator">&gt;&gt;</span> <span class="string">&#x27;current_position&#x27;</span> <span class="keyword">AS</span> current_position,</span><br><span class="line">    data <span class="operator">-</span><span class="operator">&gt;&gt;</span> <span class="string">&#x27;new_position&#x27;</span> <span class="keyword">AS</span> new_position,</span><br><span class="line">    data <span class="operator">-</span><span class="operator">&gt;&gt;</span> <span class="string">&#x27;effective_date&#x27;</span> <span class="keyword">AS</span> effective_date</span><br><span class="line"><span class="keyword">FROM</span> requests;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 提取不存在的键（返回 NULL）</span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    data <span class="operator">-</span><span class="operator">&gt;&gt;</span> <span class="string">&#x27;salary&#x27;</span> <span class="keyword">AS</span> salary</span><br><span class="line"><span class="keyword">FROM</span> requests</span><br><span class="line"><span class="keyword">WHERE</span> employee_id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="comment">-- | salary |</span></span><br><span class="line"><span class="comment">-- |--------|</span></span><br><span class="line"><span class="comment">-- | null   |</span></span><br></pre></td></tr></table></figure><h4 id="嵌套提取"><a href="#嵌套提取" class="headerlink" title="嵌套提取"></a>嵌套提取</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建用户表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> users(</span><br><span class="line">    user_id SERIAL <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    profile JSONB</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> users (profile)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;&#123;</span></span><br><span class="line"><span class="string">    &quot;name&quot;: &quot;Alice&quot;,</span></span><br><span class="line"><span class="string">    &quot;contact&quot;: &#123;</span></span><br><span class="line"><span class="string">        &quot;email&quot;: &quot;alice@example.com&quot;,</span></span><br><span class="line"><span class="string">        &quot;phone&quot;: &quot;123-456-7890&quot;</span></span><br><span class="line"><span class="string">    &#125;,</span></span><br><span class="line"><span class="string">    &quot;skills&quot;: [&quot;Python&quot;, &quot;SQL&quot;, &quot;Docker&quot;]</span></span><br><span class="line"><span class="string">&#125;&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 提取嵌套对象的值</span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    profile <span class="operator">-</span><span class="operator">&gt;</span> <span class="string">&#x27;contact&#x27;</span> <span class="operator">-</span><span class="operator">&gt;&gt;</span> <span class="string">&#x27;email&#x27;</span> <span class="keyword">AS</span> email</span><br><span class="line"><span class="keyword">FROM</span> users;</span><br><span class="line"><span class="comment">-- | email              |</span></span><br><span class="line"><span class="comment">-- |--------------------|</span></span><br><span class="line"><span class="comment">-- | alice@example.com  |</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 提取嵌套数组的元素</span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    profile <span class="operator">-</span><span class="operator">&gt;</span> <span class="string">&#x27;skills&#x27;</span> <span class="operator">-</span><span class="operator">&gt;&gt;</span> <span class="number">0</span> <span class="keyword">AS</span> first_skill</span><br><span class="line"><span class="keyword">FROM</span> users;</span><br><span class="line"><span class="comment">-- | first_skill |</span></span><br><span class="line"><span class="comment">-- |-------------|</span></span><br><span class="line"><span class="comment">-- | Python      |</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 链式提取</span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    profile <span class="operator">-</span><span class="operator">&gt;&gt;</span> <span class="string">&#x27;name&#x27;</span> <span class="keyword">AS</span> name,</span><br><span class="line">    profile <span class="operator">-</span><span class="operator">&gt;</span> <span class="string">&#x27;contact&#x27;</span> <span class="operator">-</span><span class="operator">&gt;&gt;</span> <span class="string">&#x27;email&#x27;</span> <span class="keyword">AS</span> email,</span><br><span class="line">    profile <span class="operator">-</span><span class="operator">&gt;</span> <span class="string">&#x27;contact&#x27;</span> <span class="operator">-</span><span class="operator">&gt;&gt;</span> <span class="string">&#x27;phone&#x27;</span> <span class="keyword">AS</span> phone,</span><br><span class="line">    profile <span class="operator">-</span><span class="operator">&gt;</span> <span class="string">&#x27;skills&#x27;</span> <span class="operator">-</span><span class="operator">&gt;&gt;</span> <span class="number">0</span> <span class="keyword">AS</span> primary_skill</span><br><span class="line"><span class="keyword">FROM</span> users;</span><br></pre></td></tr></table></figure><h4 id="在-WHERE-子句中使用"><a href="#在-WHERE-子句中使用" class="headerlink" title="在 WHERE 子句中使用"></a>在 WHERE 子句中使用</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查找特定职位的请求</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> requests</span><br><span class="line"><span class="keyword">WHERE</span> data <span class="operator">-</span><span class="operator">&gt;&gt;</span> <span class="string">&#x27;current_position&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;Software Engineer&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查找有效日期在特定范围内的请求</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> requests</span><br><span class="line"><span class="keyword">WHERE</span> (data <span class="operator">-</span><span class="operator">&gt;&gt;</span> <span class="string">&#x27;effective_date&#x27;</span>)::<span class="type">DATE</span> <span class="operator">&gt;=</span> <span class="string">&#x27;2024-03-01&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查找特定电话号码的员工</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> phones <span class="operator">-</span><span class="operator">&gt;&gt;</span> <span class="number">0</span> <span class="operator">=</span> <span class="string">&#x27;(408) 555-1111&#x27;</span>;</span><br></pre></td></tr></table></figure><ul><li><code>-&gt;</code> 返回 JSONB，<code>-&gt;&gt;</code> 返回文本</li><li>数组索引从 0 开始，负数从末尾开始（-1 为最后）</li><li>不存在的键&#x2F;索引返回 NULL，支持链式提取嵌套值</li></ul></article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/PostgreSQL/">PostgreSQL</a><a class="post-meta__tags" href="/tags/SQL/">SQL</a></div><div class="post_share"></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/69cd31bf.html" title="GraphQL 学习笔记"><img class="cover" src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img700px-Dot_raid_manacar_1.png" onerror='onerror=null,src="https://cdn.jsdelivr.net/gh/Hongda-OSU/PicGo/image/404.GIF"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">GraphQL 学习笔记</div></div></a></div><div class="next-post pull-right"><a href="/posts/13fe9182.html" title="JS 原型链"><img class="cover" src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img700px-Dot_scenario_s1_ep3.png" onerror='onerror=null,src="https://cdn.jsdelivr.net/gh/Hongda-OSU/PicGo/image/404.GIF"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">JS 原型链</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://cdn.jsdelivr.net/gh/Hongda-OSU/PicGo/image/德狗子.GIF" onerror='this.onerror=null,this.src="https://cdn.jsdelivr.net/gh/Hongda-OSU/PicGo/image/404.GIF"' alt="avatar"></div><div class="author-info__name">鴻達</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">31</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">15</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Hongda-OSU" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="https://www.linkedin.com/in/hongda-lin" target="_blank" title="Linkedin"><i class="fab fa-linkedin"></i></a><a class="social-icon" href="https://hongdalin.me" target="_blank" title="Portfolio"><i class="iconfont icon-guanfangwangzhan"></i></a></div></div><script src="https://npm.elemecdn.com/ethan4116-blog/lib/js/other/two-people/twopeople1.js"></script><script src="https://npm.elemecdn.com/ethan4116-blog/lib/js/other/two-people/zdog.dist.js"></script><script id="rendered-js" src="https://npm.elemecdn.com/ethan4116-blog/lib/js/other/two-people/twopeople.js"></script><style>.card-widget.card-announcement{margin:0;align-items:center;justify-content:center;text-align:center}canvas{display:block;margin:0 auto;cursor:move}</style><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E6%95%B0%E6%8D%AE"><span class="toc-text">查询数据</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%AE%80%E5%8D%95%E6%9F%A5%E8%AF%A2-SELECT"><span class="toc-text">1. 简单查询 SELECT</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%88%97%E5%88%AB%E5%90%8D"><span class="toc-text">2. 列别名</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%8E%92%E5%BA%8F-ORDER-BY"><span class="toc-text">3. 排序 ORDER BY</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%8E%BB%E9%87%8D%E6%9F%A5%E8%AF%A2-DISTINCT"><span class="toc-text">4. 去重查询 DISTINCT</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2"><span class="toc-text">5. 分页查询</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#OFFSET-x2F-LIMIT-%E5%88%86%E9%A1%B5"><span class="toc-text">OFFSET&#x2F;LIMIT 分页</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8EID%E7%9A%84%E5%88%86%E9%A1%B5"><span class="toc-text">基于ID的分页</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Cursor-%E6%B8%B8%E6%A0%87-%E5%88%86%E9%A1%B5"><span class="toc-text">Cursor (游标) 分页</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%87%E6%BB%A4%E6%95%B0%E6%8D%AE"><span class="toc-text">过滤数据</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-WHERE"><span class="toc-text">6. WHERE</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-LIMIT"><span class="toc-text">7. LIMIT</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-OFFSET-x2F-FETCH"><span class="toc-text">8. OFFSET&#x2F;FETCH</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-IN"><span class="toc-text">9. IN</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-BETWEEN"><span class="toc-text">10. BETWEEN</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-LIKE"><span class="toc-text">11. LIKE</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-NULL-%E5%92%8C-IS-NULL"><span class="toc-text">12. NULL 和 IS NULL</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5%E5%A4%9A%E4%B8%AA%E8%A1%A8"><span class="toc-text">连接多个表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#13-%E8%A1%A8%E5%88%AB%E5%90%8D"><span class="toc-text">13. 表别名</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-INNER-JOIN"><span class="toc-text">14. INNER JOIN</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-LEFT-JOIN"><span class="toc-text">15. LEFT JOIN</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-SELF-JOIN"><span class="toc-text">16. SELF JOIN</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-FULL-OUTER-JOIN"><span class="toc-text">17. FULL OUTER JOIN</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-CROSS-JOIN"><span class="toc-text">18. CROSS JOIN</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9B%BF%E4%BB%A3%E5%86%99%E6%B3%95"><span class="toc-text">替代写法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">常见应用场景</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19-NATURAL-JOIN"><span class="toc-text">19. NATURAL JOIN</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E6%9B%BF%E5%86%99%E6%B3%95"><span class="toc-text">代替写法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E6%8E%A8%E8%8D%90%E4%BD%BF%E7%94%A8"><span class="toc-text">为什么不推荐使用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20-LATERAL-JOIN"><span class="toc-text">20. LATERAL JOIN</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-1"><span class="toc-text">常见应用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%BC%E5%AE%B9%E6%80%A7"><span class="toc-text">数据库兼容性</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%88%86%E7%BB%84"><span class="toc-text">数据分组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#21-GROUP-BY-%E5%88%86%E7%BB%84"><span class="toc-text">21. GROUP BY 分组</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0"><span class="toc-text">常用聚合函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%94%99%E8%AF%AF%E7%A4%BA%E4%BE%8B"><span class="toc-text">错误示例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-HAVING"><span class="toc-text">22. HAVING</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#WHERE-vs-HAVING"><span class="toc-text">WHERE vs HAVING</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F"><span class="toc-text">执行顺序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF"><span class="toc-text">常见错误</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#23-PARTITION-BY-%E5%88%86%E5%8C%BA"><span class="toc-text">23. PARTITION BY 分区</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0%E7%A4%BA%E4%BE%8B"><span class="toc-text">常见窗口函数示例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E8%BF%90%E7%AE%97"><span class="toc-text">集合运算</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#24-UNION-%E7%BB%84%E5%90%88"><span class="toc-text">24. UNION 组合</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-2"><span class="toc-text">常见应用场景</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#25-INTERSECT-%E4%BA%A4%E9%9B%86"><span class="toc-text">25. INTERSECT 交集</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#26-EXCEPT-%E5%B7%AE%E9%9B%86"><span class="toc-text">26. EXCEPT 差集</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E7%BB%84%E9%9B%86"><span class="toc-text">分组集</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#27-GROUPING-SETS"><span class="toc-text">27. GROUPING SETS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#28-CUBE-%E5%88%86%E7%BB%84"><span class="toc-text">28. CUBE 分组</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%9F%E6%88%90%E7%9A%84%E5%88%86%E7%BB%84%E7%BB%84%E5%90%88"><span class="toc-text">生成的分组组合</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#29-ROLLUP-%E5%88%86%E7%BB%84"><span class="toc-text">29. ROLLUP 分组</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%9F%E6%88%90%E7%9A%84%E5%88%86%E7%BB%84%E7%BB%84%E5%90%88-1"><span class="toc-text">生成的分组组合</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ROLLUP-vs-CUBE"><span class="toc-text">ROLLUP vs CUBE</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%90%E6%9F%A5%E8%AF%A2"><span class="toc-text">子查询</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#30-PostgreSQL-%E5%AD%90%E6%9F%A5%E8%AF%A2"><span class="toc-text">30. PostgreSQL 子查询</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ANY-x2F-ALL-%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-text">ANY&#x2F;ALL 操作符</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#31-ANY"><span class="toc-text">31. ANY</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#32-ALL"><span class="toc-text">32. ALL</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#33-EXISTS"><span class="toc-text">33. EXISTS</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AC%E5%85%B1%E8%A1%A8%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-text">公共表表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#34-WITH-%E6%9F%A5%E8%AF%A2-CTE"><span class="toc-text">34. WITH 查询 (CTE)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%E6%95%B0%E6%8D%AE"><span class="toc-text">修改数据</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#35-INSERT"><span class="toc-text">35. INSERT</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E6%9C%80%E5%90%8E%E6%8F%92%E5%85%A5ID"><span class="toc-text">获取最后插入ID</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#36-INSERT-%E6%8F%92%E5%85%A5%E5%A4%9A%E8%A1%8C"><span class="toc-text">36. INSERT 插入多行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#37-UNNEST-%E6%89%B9%E9%87%8F%E6%8F%92%E5%85%A5"><span class="toc-text">37. UNNEST 批量插入</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#UNNEST-vs-VALUES"><span class="toc-text">UNNEST vs VALUES</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#38-UPDATE"><span class="toc-text">38. UPDATE</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#39-UPDATE-JOIN"><span class="toc-text">39. UPDATE JOIN</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#40-DELETE"><span class="toc-text">40. DELETE</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#41-TRUNCATE"><span class="toc-text">41. TRUNCATE</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#42-UPSERT"><span class="toc-text">42. UPSERT</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#EXCLUDED-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">EXCLUDED 关键字</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#43-MERGE"><span class="toc-text">43. MERGE</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1"><span class="toc-text">事务</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#44-TRANSACTION"><span class="toc-text">44. TRANSACTION</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%A1%E7%90%86%E8%A1%A8"><span class="toc-text">管理表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#45-CREATE-TABLE"><span class="toc-text">45. CREATE TABLE</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%A6%E6%9D%9F%E7%B1%BB%E5%9E%8B"><span class="toc-text">约束类型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#46-SERIAL-%E8%87%AA%E5%A2%9E%E5%88%97"><span class="toc-text">46. SERIAL 自增列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#47-ALTER-TABLE"><span class="toc-text">47. ALTER TABLE</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#48-ADD-COLUMN"><span class="toc-text">48. ADD COLUMN</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#49-DROP-COLUMN"><span class="toc-text">49. DROP COLUMN</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#50-DROP-TABLE"><span class="toc-text">50. DROP TABLE</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#51-TRUNCATE-TABLE"><span class="toc-text">51. TRUNCATE TABLE</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#52-%E4%B8%B4%E6%97%B6%E8%A1%A8"><span class="toc-text">52. 临时表</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PostgreSQL-%E7%BA%A6%E6%9D%9F"><span class="toc-text">PostgreSQL 约束</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#53-%E4%B8%BB%E9%94%AE%E7%BA%A6%E6%9D%9F-PRIMARY-KEY"><span class="toc-text">53. 主键约束 (PRIMARY KEY)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#54-%E5%A4%96%E9%94%AE%E7%BA%A6%E6%9D%9F-FOREIGN-KEY"><span class="toc-text">54. 外键约束 (FOREIGN KEY)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#55-CHECK-%E7%BA%A6%E6%9D%9F"><span class="toc-text">55. CHECK 约束</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#56-UNIQUE-%E7%BA%A6%E6%9D%9F"><span class="toc-text">56. UNIQUE 约束</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#57-NOT-NULL-%E7%BA%A6%E6%9D%9F"><span class="toc-text">57. NOT NULL 约束</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text">数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#58-BOOLEAN-%E5%B8%83%E5%B0%94%E7%B1%BB%E5%9E%8B"><span class="toc-text">58. BOOLEAN 布尔类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#59-%E5%AD%97%E7%AC%A6%E7%B1%BB%E5%9E%8B-CHAR%E3%80%81VARCHAR-%E5%92%8C-TEXT"><span class="toc-text">59. 字符类型: CHAR、VARCHAR 和 TEXT</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#60-NUMERIC-%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B"><span class="toc-text">60. NUMERIC 数值类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#61-INTEGER-%E6%95%B4%E6%95%B0%E7%B1%BB%E5%9E%8B"><span class="toc-text">61. INTEGER 整数类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#62-DATE-%E6%97%A5%E6%9C%9F%E7%B1%BB%E5%9E%8B"><span class="toc-text">62. DATE 日期类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A5%E6%9C%9F%E5%87%BD%E6%95%B0"><span class="toc-text">日期函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#63-TIMESTAMP-%E6%97%B6%E9%97%B4%E6%88%B3"><span class="toc-text">63. TIMESTAMP 时间戳</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E6%88%B3%E5%87%BD%E6%95%B0"><span class="toc-text">时间戳函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#64-INTERVAL-%E9%97%B4%E9%9A%94%E7%B1%BB%E5%9E%8B"><span class="toc-text">64. INTERVAL 间隔类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#65-UUID-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text">65. UUID 数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%9F%E6%88%90-UUID-%E5%80%BC"><span class="toc-text">生成 UUID 值</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#66-UUID-v7"><span class="toc-text">66. UUID v7</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#67-JSON-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text">67. JSON 数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#JSON-%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">JSON 运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#WHERE-%E5%AD%90%E5%8F%A5%E4%B8%AD%E4%BD%BF%E7%94%A8-JSON-%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">WHERE 子句中使用 JSON 运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0"><span class="toc-text">聚合函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JSON-%E5%87%BD%E6%95%B0"><span class="toc-text">JSON 函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JSON-vs-JSONB"><span class="toc-text">JSON vs JSONB</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-text">条件表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#68-CASE-%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-text">68. CASE 表达式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#69-COALESCE-%E5%87%BD%E6%95%B0"><span class="toc-text">69. COALESCE 函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#70-NULLIF-%E5%87%BD%E6%95%B0"><span class="toc-text">70. NULLIF 函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#71-CAST-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-text">71. CAST 类型转换</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%84%E7%90%86-JSON"><span class="toc-text">处理 JSON</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#72-%E6%9F%A5%E8%AF%A2-JSON-%E6%95%B0%E7%BB%84"><span class="toc-text">72. 查询 JSON 数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#73-%E4%BF%AE%E6%94%B9-JSON-%E6%95%B0%E7%BB%84"><span class="toc-text">73. 修改 JSON 数组</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E5%85%83%E7%B4%A0"><span class="toc-text">添加元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0"><span class="toc-text">删除元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9B%BF%E6%8D%A2%E7%89%B9%E5%AE%9A%E4%BD%8D%E7%BD%AE%E7%9A%84%E5%85%83%E7%B4%A0"><span class="toc-text">替换特定位置的元素</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#74-%E6%8F%90%E5%8F%96-JSON-%E6%95%B0%E6%8D%AE"><span class="toc-text">74. 提取 JSON 数据</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8E%E6%95%B0%E7%BB%84%E4%B8%AD%E6%8F%90%E5%8F%96%E5%85%83%E7%B4%A0"><span class="toc-text">从数组中提取元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8E%E5%AF%B9%E8%B1%A1%E4%B8%AD%E6%8F%90%E5%8F%96%E5%80%BC"><span class="toc-text">从对象中提取值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B5%8C%E5%A5%97%E6%8F%90%E5%8F%96"><span class="toc-text">嵌套提取</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8-WHERE-%E5%AD%90%E5%8F%A5%E4%B8%AD%E4%BD%BF%E7%94%A8"><span class="toc-text">在 WHERE 子句中使用</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/c888933a.html" title="Liquibase 101"><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/image/1100px-Event_top_01.png" onerror='this.onerror=null,this.src="https://cdn.jsdelivr.net/gh/Hongda-OSU/PicGo/image/404.GIF"' alt="Liquibase 101"></a><div class="content"><a class="title" href="/posts/c888933a.html" title="Liquibase 101">Liquibase 101</a><time datetime="2025-06-15T17:03:05.000Z" title="发表于 2025-06-15 12:03:05">2025-06-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/50096d59.html" title="AWS MLA-C01"><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/image/700px-卡冈图雅-像素.png" onerror='this.onerror=null,this.src="https://cdn.jsdelivr.net/gh/Hongda-OSU/PicGo/image/404.GIF"' alt="AWS MLA-C01"></a><div class="content"><a class="title" href="/posts/50096d59.html" title="AWS MLA-C01">AWS MLA-C01</a><time datetime="2025-06-14T17:03:05.000Z" title="发表于 2025-06-14 12:03:05">2025-06-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/998b6089.html" title="JS &amp; Python 小技巧"><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/image/700px-荷赛拉大战-机械淘淘宣传图.png" onerror='this.onerror=null,this.src="https://cdn.jsdelivr.net/gh/Hongda-OSU/PicGo/image/404.GIF"' alt="JS &amp; Python 小技巧"></a><div class="content"><a class="title" href="/posts/998b6089.html" title="JS &amp; Python 小技巧">JS &amp; Python 小技巧</a><time datetime="2025-06-14T17:03:05.000Z" title="发表于 2025-06-14 12:03:05">2025-06-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/3f28c94.html" title="GCP 实操练习"><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/imgf46582az111imog7tayrkhdegi73sg9.png" onerror='this.onerror=null,this.src="https://cdn.jsdelivr.net/gh/Hongda-OSU/PicGo/image/404.GIF"' alt="GCP 实操练习"></a><div class="content"><a class="title" href="/posts/3f28c94.html" title="GCP 实操练习">GCP 实操练习</a><time datetime="2025-06-13T17:03:05.000Z" title="发表于 2025-06-13 12:03:05">2025-06-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/733301f0.html" title="System Design 101"><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img5r931hxtc55u09sm6oxjl3b0bp0v1z6.png" onerror='this.onerror=null,this.src="https://cdn.jsdelivr.net/gh/Hongda-OSU/PicGo/image/404.GIF"' alt="System Design 101"></a><div class="content"><a class="title" href="/posts/733301f0.html" title="System Design 101">System Design 101</a><time datetime="2025-06-13T17:03:05.000Z" title="发表于 2025-06-13 12:03:05">2025-06-13</time></div></div></div></div></div></div></main><footer id="footer" style="background:rgba(0,0,0,.25)"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2025 &nbsp;<i id="heartbeat" class="fa fas fa-heartbeat"></i> &nbsp;鴻達</div><div class="footer_custom_text"><p class="badge"><a style="margin-inline:5px" target="_blank" href="https://hexo.io/"><img src="https://img.shields.io/badge/Frame-Hexo-informational?style=flat&logo=hexo"></a><a style="margin-inline:5px" target="_blank" href="https://domains.google/"><img src="https://img.shields.io/badge/Hosted-Google-ff69b4?style=flat&logo=googledomains"></a><a style="margin-inline:5px" target="_blank" href="https://gulpjs.com/"><img src="https://img.shields.io/badge/Compress-gulp-critical?style=flat&logo=gulp"></a><a style="margin-inline:5px" target="_blank" href="https://www.jsdelivr.com/"><img src="https://img.shields.io/badge/CDN-jsDelivr-orange?style=flat&logo=jsDelivr"></a><a style="margin-inline:5px" target="_blank" href="https://github.com/"><img src="https://img.shields.io/badge/Source-Github-black?style=flat&logo=GitHub"></a><a style="margin-inline:5px" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&logo=Claris"></a></p></div></div><link rel="stylesheet" href="https://fastly.jsdelivr.net/gh/HCLonely/images@master/others/heartbeat.min.css"></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i> <span>数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script>function panguFn(){"object"==typeof pangu?pangu.autoSpacingPage():getScript("https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js").then((()=>{pangu.autoSpacingPage()}))}function panguInit(){GLOBAL_CONFIG_SITE.isPost&&panguFn()}document.addEventListener("DOMContentLoaded",panguInit)</script><script src="/js/search/local-search.js"></script><div class="js-pjax"></div><script defer src="/js/util.js"></script><script defer src="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js"></script><script disable-devtool-auto src="https://cdn.jsdelivr.net/npm/disable-devtool"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors=["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"];var pjax=new Pjax({elements:'a:not([target="_blank"])',selectors:pjaxSelectors,cacheBust:!1,analytics:!1,scrollRestoration:!1});document.addEventListener("pjax:send",(function(){if(window.tocScrollFn&&window.removeEventListener("scroll",window.tocScrollFn),window.scrollCollect&&window.removeEventListener("scroll",scrollCollect),document.getElementById("rightside").style.cssText="opacity: ''; transform: ''",window.aplayers)for(let e=0;e<window.aplayers.length;e++)window.aplayers[e].options.fixed||window.aplayers[e].destroy();"object"==typeof typed&&typed.destroy();const e=document.body.classList;e.contains("read-mode")&&e.remove("read-mode"),"object"==typeof disqusjs&&disqusjs.destroy()})),document.addEventListener("pjax:complete",(function(){window.refreshFn(),document.querySelectorAll("script[data-pjax]").forEach((e=>{const t=document.createElement("script"),o=e.text||e.textContent||e.innerHTML||"";Array.from(e.attributes).forEach((e=>t.setAttribute(e.name,e.value))),t.appendChild(document.createTextNode(o)),e.parentNode.replaceChild(t,e)})),GLOBAL_CONFIG.islazyload&&window.lazyLoadInstance.update(),"function"==typeof chatBtnFn&&chatBtnFn(),"function"==typeof panguInit&&panguInit(),"function"==typeof gtag&&gtag("config","",{page_path:window.location.pathname}),"object"==typeof _hmt&&_hmt.push(["_trackPageview",window.location.pathname]),"function"==typeof loadMeting&&document.getElementsByClassName("aplayer").length&&loadMeting(),"object"==typeof Prism&&Prism.highlightAll()})),document.addEventListener("pjax:error",(e=>{404===e.request.status&&pjax.loadUrl("/404.html")}))</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>