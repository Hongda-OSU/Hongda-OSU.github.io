<!DOCTYPE html><html lang="zh-CN" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><title>WebGL 学习笔记 | 鴻鵠誌達</title><meta name="author" content="鴻達"><meta name="copyright" content="鴻達"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#1a1a1a"><meta name="description" content="WebGL 学习笔记"><meta property="og:type" content="article"><meta property="og:title" content="WebGL 学习笔记"><meta property="og:url" content="https://hongdalin.blog/posts/d58818f0.html"><meta property="og:site_name" content="鴻鵠誌達"><meta property="og:description" content="WebGL 学习笔记"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/imgdip29s0ui3xcpinvtb8pelnc00xb05s.jpg"><meta property="article:published_time" content="2024-12-08T16:15:05.000Z"><meta property="article:modified_time" content="2025-01-04T02:14:09.644Z"><meta property="article:author" content="鴻達"><meta property="article:tag" content="WebGL"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/imgdip29s0ui3xcpinvtb8pelnc00xb05s.jpg"><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/Hongda-OSU/PicGo/image/德克萨斯.GIF"><link rel="canonical" href="https://hongdalin.blog/posts/d58818f0.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:{path:"/search.xml",preload:!0,languages:{hits_empty:"找不到您查询的内容：${query}"}},translate:void 0,noticeOutdate:void 0,highlight:{plugin:"highlighjs",highlightCopy:!0,highlightLang:!0,highlightHeightLimit:!1},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"},relativeDate:{homepage:!1,post:!1},runtime:"天",date_suffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:void 0,lightbox:"fancybox",Snackbar:void 0,source:{justifiedGallery:{js:"https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js",css:"https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css"}},isPhotoFigcaption:!0,islazyload:!1,isAnchor:!1,percent:{toc:!0,rightside:!1}}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"WebGL 学习笔记",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2025-01-03 20:14:09"}</script><noscript><style>#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(e=>{e.saveToLocal={set:function(e,t,n){if(0===n)return;const o=864e5*n,a={value:t,expiry:(new Date).getTime()+o};localStorage.setItem(e,JSON.stringify(a))},get:function(e){const t=localStorage.getItem(e);if(!t)return;const n=JSON.parse(t);if(!((new Date).getTime()>n.expiry))return n.value;localStorage.removeItem(e)}},e.getScript=e=>new Promise(((t,n)=>{const o=document.createElement("script");o.src=e,o.async=!0,o.onerror=n,o.onload=o.onreadystatechange=function(){const e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(o.onload=o.onreadystatechange=null,t())},document.head.appendChild(o)})),e.getCSS=e=>new Promise(((t,n)=>{const o=document.createElement("link");o.rel="stylesheet",o.href=e,o.onload=()=>t(),o.onerror=()=>n(),document.head.appendChild(o)}));/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")})(window)</script><link rel="stylesheet" href="/css/color.css" media="defer" onload='this.media="all"'><link rel="stylesheet" href="/css/font.css" media="defer" onload='this.media="all"'><link rel="stylesheet" href="/css/icon.css" media="defer" onload='this.media="all"'><link rel="stylesheet" href="/css/layout.css" media="defer" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.css" media="defer" onload='this.media="all"'><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://cdn.jsdelivr.net/gh/Hongda-OSU/PicGo/image/德狗子.GIF" onerror='onerror=null,src="https://cdn.jsdelivr.net/gh/Hongda-OSU/PicGo/image/404.GIF"' alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">23</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">13</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i> <span>时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i> <span>标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>分类</span></a></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i> <span>链接</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i> <span>友情链接</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i> <span>关于</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url('https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/imgdip29s0ui3xcpinvtb8pelnc00xb05s.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="鴻鵠誌達"><span class="site-name">鴻鵠誌達</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i> <span>搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i> <span>时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i> <span>标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>分类</span></a></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i> <span>链接</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i> <span>友情链接</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i> <span>关于</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">WebGL 学习笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-12-08T16:15:05.000Z" title="发表于 2024-12-08 10:15:05">2024-12-08</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-01-04T02:14:09.644Z" title="更新于 2025-01-03 20:14:09">2025-01-03</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">6.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>25分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" data-flag-title="WebGL 学习笔记"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p><a target="_blank" rel="noopener" href="https://webglfundamentals.org/">WebGL Fundamentals</a>: 适合初学者，包含详细的教程和示例代码</p></blockquote><h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><h4 id="什么是Shader"><a href="#什么是Shader" class="headerlink" title="什么是Shader"></a>什么是<code>Shader</code></h4><p><code>Shader</code>是运行在<code>GPU</code>上的一段程序，主要负责控制图形渲染管线中的一部分。主要类型</p><ul><li>顶点着色器 (<code>Vertex Shader</code>): 确定图形的每一个顶点的位置</li><li>片元着色器 (<code>Fragment Shader</code>): 渲染图形的每一个片元（像素）的颜色</li></ul><h4 id="Shader和其他技术"><a href="#Shader和其他技术" class="headerlink" title="Shader和其他技术"></a><code>Shader</code>和其他技术</h4><p><code>Shader</code>是前端图形技术中的重要一环，它与常见的图形技术如<code>CSS</code>、<code>SVG</code>、<code>Canvas2D</code>和<code>WebGL</code>都有着密切的关系，每一种技术都在不同层面提供了图形渲染的能力，但<code>Shader</code>的独特之处在于它直接操作<code>GPU</code>，能够实现高度复杂的视觉效果</p><ul><li><p><code>CSS</code>: <code>CSS</code>的主要功能是网页布局，但它也可以通过一些属性（如<code>animation</code>和<code>transform</code>）实现简单的动画效果。它的局限性在于无法很好地处理复杂的动态变化，尤其是像素级的精细操作</p></li><li><p><code>SVG</code>: <code>SVG</code>提供了矢量图形的能力，允许开发者通过路径（<code>path</code>标签）定义任意形状，并结合属性（如 <code>stroke-dasharray</code>和<code>stroke-dashoffset</code>）实现动画。相比<code>CSS</code>，<code>SVG</code>更适合处理复杂的几何图形。然而，它仍然难以实现动态粒子效果或像素级控制</p></li><li><p><code>Canvas2D</code>: <code>Canvas2D</code>提供了对每个像素的直接控制，开发者可以通过数学运算和随机函数实现动态效果，例如粒子拖尾动画。但它的设计初衷是处理<code>2D</code>图形，对<code>3D</code>图形的支持相对较弱</p></li><li><p><code>WebGL</code>: <code>WebGL</code>是在浏览器中渲染<code>3D</code>图形的标准，它通过“渲染管线”处理图形数据。<code>WebGL</code>的强大之处在于既可以处理<code>2D</code>图形，也可以实现<code>3D</code>场景。<code>Shader</code>是<code>WebGL</code>的核心组成部分，用于自定义渲染管线中的特定部分，提供开发者完全的渲染控制能力</p></li></ul><hr><h3 id="Shader基础知识"><a href="#Shader基础知识" class="headerlink" title="Shader基础知识"></a><code>Shader</code>基础知识</h3><h4 id="Shader编程语言选择"><a href="#Shader编程语言选择" class="headerlink" title="Shader编程语言选择"></a><code>Shader</code>编程语言选择</h4><p>目前主要的<code>Shader</code>编程语言有以下几种</p><ul><li><code>GLSL</code>: 主要用于<code>OpenGL</code>平台的图形<code>API</code></li><li><code>HLSL</code>: 由微软开发，主要用于<code>DirectX</code>平台的图形API</li><li><code>Cg</code>: 由<code>Nvidia</code>开发，可被编译为<code>GLSL</code>和<code>HLSL</code>，主要被用于<code>Unity</code>平台</li><li><code>WGSL</code>: <code>WebGPU</code>的专用语言，适用于未来的浏览器图形开发</li></ul><p>本学习笔记重点是<code>Web</code>环境中的<code>Shader</code>开发，并基于<code>WebGL</code>平台，选择<code>GLSL</code>作为主要的学习语言</p><h4 id="WebGL渲染管线流程"><a href="#WebGL渲染管线流程" class="headerlink" title="WebGL渲染管线流程"></a><code>WebGL</code>渲染管线流程</h4><p><code>WebGL</code>的渲染管线的核心流程（一个物体是如何被渲染到屏幕上的）主要包括以下几个步骤</p><ul><li>顶点着色器: 处理顶点数据（如位置、颜色、纹理坐标）</li><li>图元装配: 将顶点数据组合成图元（如点、线、三角形）</li><li>光栅化: 将图元转换为屏幕上的像素</li><li>片元着色器: 计算每个像素的颜色</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img0a729b8d1dae444c9799c7083aa84f65%7Etplv-k3u1fbpfcp-jj-mark_3024_0_0_0_q75.awebp"></p><blockquote><p>整个流程是: 在<code>JS</code>中提供顶点的数据（通常是<code>Float32Array</code>类型的数组，包含了顶点的位置等信息），将这些数据传递给顶点着色器，让它计算每个顶点的位置，然后<code>WebGL</code>将顶点装配成图元（如三角形），图元再被转换成屏幕上的空像素（光栅化），让片元着色器来计算每个像素的颜色并填充上去，最终将物体渲染到屏幕上</p></blockquote><ul><li>图元装配和光栅化是<code>WebGL</code>自带的操作，无法进行额外的定制，但<strong>顶点着色器和片元着色器则是完全可通过编程来定制化的</strong></li></ul><h4 id="Shader开发环境"><a href="#Shader开发环境" class="headerlink" title="Shader开发环境"></a><code>Shader</code>开发环境</h4><p>在线开发工具</p><ul><li><a target="_blank" rel="noopener" href="https://www.shadertoy.com/">ShaderToy</a>: 一个实时运行和分享<code>Shader</code>的在线平台</li><li><a target="_blank" rel="noopener" href="https://codesandbox.io/s/kokomi-js-starter-tjh29w?file=/src/app.ts">codesandbox</a>: 偏向工程化的<code>Template</code></li><li><code>jsfiddle</code>: <code>Fork</code>下面的<code>fiddle</code>然后编辑<code>JS</code> (当然也可以在<code>codepen</code>里写)</li></ul><iframe width="100%" height="400" src="//jsfiddle.net/HDL52/ftos1vp6/15/embedded/result/dark/" frameborder="0" loading="lazy" allowtransparency="true" allowfullscreen></iframe><p>编辑器开发工具</p><ul><li><code>VSCode</code>: 安装以下插件 <code>Shader language support</code>, <code>Shader Toy</code>, <code>Live Preview</code>, <code>glsl-canvas</code></li></ul><h4 id="实现第一个Shader"><a href="#实现第一个Shader" class="headerlink" title="实现第一个Shader"></a>实现第一个<code>Shader</code></h4><p><code>GLSL</code>语言的<code>Shader</code>文件后缀名是<code>.glsl</code></p><ul><li>下面定义了一个<code>mainImage</code>函数，它不返回任何值，故返回类型为<code>void</code>。它接受<code>2</code>个参数，一个是<code>4</code>维的<code>fragColor</code>，代表输出的像素颜色。另一个是<code>2</code>维的<code>fragCoord</code>，代表输入的像素坐标</li></ul><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> mainImage(<span class="keyword">out</span> <span class="type">vec4</span> fragColor,<span class="keyword">in</span> <span class="type">vec2</span> fragCoord)&#123;</span><br><span class="line">    <span class="type">vec3</span> color = <span class="type">vec3</span>(<span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>); <span class="comment">// 定义红色</span></span><br><span class="line">    fragColor = <span class="type">vec4</span>(color, <span class="number">1.0</span>);     <span class="comment">// 输出红色</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>上面代码定义了一个名为<code>color</code>的<code>3</code>维变量，将它的值设置为红色，红色的<code>RGB</code>颜色值为<code>(255,0,0)</code>，在<code>GLSL</code>中，需要先将颜色原先的值进行归一化操作（除以<code>255</code>）后才能将它正确地输出，因此将红色的值归一化后就得到了<code>(1,0,0)</code>这个值，将它转换为<code>3</code>维变量<code>vec3(1.,0.,0.)</code>赋给<code>color</code>变量</p></li><li><p>最后给输出颜色<code>fragColor</code>赋值一个<code>4</code>维变量，前<code>3</code>维就是<code>color</code>这个颜色变量，最后一维是透明度，由于纯红色并不透明，直接将其设为<code>1</code>即可</p></li></ul><iframe width="100%" height="400" src="//jsfiddle.net/HDL52/8p2obeju/1/embedded/result/dark/" frameborder="0" loading="lazy" allowtransparency="true" allowfullscreen></iframe><ul><li><p>当然也可以通过判断像素坐标范围，给不同区域填充不同的颜色</p></li><li><p>这里就要用到<code>fragCoord</code>变量，它代表了输入的像素坐标，有<code>2</code>个维度<code>xy</code>，它们的大小取决于画面本身的大小。假设画面当前的大小为<code>1536x864</code>，那么每一个像素的<code>fragCoord</code>的<code>x</code>坐标值将会分布在<code>(0,1536)</code>之间，<code>y</code>坐标值则分布在<code>(0,864)</code>之间</p></li><li><p>在当前的<code>Shader</code>开发环境内，还有个内置的变量<code>iResolution</code>，代表了画面整体的大小，使用它时一般会取它的<code>xy</code>维度</p></li></ul><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> mainImage(<span class="keyword">out</span> <span class="type">vec4</span> fragColor, <span class="keyword">in</span> <span class="type">vec2</span> fragCoord) &#123;</span><br><span class="line">    <span class="type">vec3</span> color1 = <span class="type">vec3</span>(<span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>); <span class="comment">// 红色</span></span><br><span class="line">    <span class="type">vec3</span> color2 = <span class="type">vec3</span>(<span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>); <span class="comment">// 绿色</span></span><br><span class="line">    <span class="type">vec3</span> color3 = <span class="type">vec3</span>(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>); <span class="comment">// 蓝色</span></span><br><span class="line">    <span class="type">vec3</span> color4 = <span class="type">vec3</span>(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>); <span class="comment">// 黄色</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fragCoord.x &lt; iResolution.x * <span class="number">0.25</span>) &#123;</span><br><span class="line">        fragColor = <span class="type">vec4</span>(color1, <span class="number">1.0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (fragCoord.x &lt; iResolution.x * <span class="number">0.5</span>) &#123;</span><br><span class="line">        fragColor = <span class="type">vec4</span>(color2, <span class="number">1.0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (fragCoord.x &lt; iResolution.x * <span class="number">0.75</span>) &#123;</span><br><span class="line">        fragColor = <span class="type">vec4</span>(color3, <span class="number">1.0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fragColor = <span class="type">vec4</span>(color4, <span class="number">1.0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>之所以能够显示出四种颜色，是因为<code>GPU</code>会对屏幕上的每一个像素点进行独立的并行计算</li></ul><iframe width="100%" height="400" src="//jsfiddle.net/HDL52/qtzxg7dj/1/embedded/result/dark/" frameborder="0" loading="lazy" allowtransparency="true" allowfullscreen></iframe><hr><h3 id="GLSL基础知识"><a href="#GLSL基础知识" class="headerlink" title="GLSL基础知识"></a><code>GLSL</code>基础知识</h3><p><code>GLSL</code>是一种类似<code>C</code>的语言，用于控制<code>GPU</code>的渲染逻辑，如果有<code>C/C++</code>的基础会更容易理解，以下内容将逐步介绍<code>GLSL</code>的核心知识</p><h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><ul><li>一维变量（标量）: 比如<code>int</code>，<code>float</code>，<code>bool</code>。浮点型<code>float</code>可以说是<code>GLSL</code>里最常用的类型，浮点型变量必须要有小数点，不能省略，而且语句结尾一定要加一个分号<code>;</code></li></ul><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span> foo = <span class="number">1.0</span>; <span class="comment">// 浮点型</span></span><br><span class="line"><span class="type">int</span> bar = <span class="number">10</span>;    <span class="comment">// 整型</span></span><br><span class="line"><span class="type">bool</span> flag = <span class="literal">true</span>; <span class="comment">// 布尔型</span></span><br></pre></td></tr></table></figure><ul><li>向量变量: 向量类型支持<code>3</code>种维度，二维<code>vec2</code>、三维<code>vec3</code>和四维<code>vec4</code>，通过<code>.x</code>,<code>.y</code>,<code>.z</code>,<code>.w</code>（或<code>.r</code>,<code>.g</code>,<code>.b</code>,<code>.a</code>）访问。如果想对多维度变量进行取值或赋值操作，就要用到<code>.</code>符号，并且四个维度可以任意组合（称为<code>Swizzling</code>）</li></ul><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="type">vec2</span> a = <span class="type">vec2</span>(<span class="number">1.0</span>, <span class="number">0.0</span>);  <span class="comment">// 二维向量</span></span><br><span class="line"></span><br><span class="line"><span class="type">vec3</span> b = <span class="type">vec3</span>(<span class="number">1.0</span>, <span class="number">0.5</span>, <span class="number">0.0</span>);  <span class="comment">// 三维向量</span></span><br><span class="line"><span class="type">vec2</span> d = b.xy; <span class="comment">// 提取 b 的 x 和 y 分量，构成二维向量 d (1.0, 0.5)</span></span><br><span class="line">d.y = <span class="number">2.0</span>; <span class="comment">// 修改 d 的 y 分量为 2.0</span></span><br><span class="line"></span><br><span class="line"><span class="type">vec4</span> c = <span class="type">vec4</span>(<span class="number">1.0</span>, <span class="number">0.5</span>, <span class="number">0.0</span>, <span class="number">1.0</span>); <span class="comment">// 四维向量</span></span><br><span class="line"><span class="type">vec3</span> e = c.yxy; <span class="comment">// 重组 c 的分量，形成一个新的三维向量 (0.5, 1.0, 0.5)</span></span><br><span class="line">e.zx = <span class="type">vec2</span>(<span class="number">1.0</span>); <span class="comment">// 修改 e 的 z 和 x 分量为 1.0</span></span><br></pre></td></tr></table></figure><ul><li>矩阵变量: 矩阵用于线性变换，<code>mat2</code>类型代表了一个大小是<code>2x2</code>的矩阵，<code>mat3</code>类型则代表了一个<code>3x3</code>的矩阵、<code>mat4</code>类型是<code>4x4</code>的矩阵</li></ul><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="type">mat2</span> m1 = <span class="type">mat2</span>(<span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>);  <span class="comment">// 2x2 矩阵</span></span><br><span class="line"><span class="type">mat3</span> m2 = <span class="type">mat3</span>(<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">2.0</span>, <span class="number">1.0</span>); <span class="comment">// 3x3 矩阵</span></span><br></pre></td></tr></table></figure><ul><li>结构体: 如果想把多个变量捆绑到一个变量上，可以使用结构体<code>struct</code></li></ul><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">struct Ray &#123;</span><br><span class="line">    <span class="type">vec3</span> ro;  <span class="comment">// 起点</span></span><br><span class="line">    <span class="type">vec3</span> rd;  <span class="comment">// 方向</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Ray ray = Ray(<span class="type">vec3</span>(<span class="number">0.0</span>), <span class="type">vec3</span>(<span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>));</span><br></pre></td></tr></table></figure><h4 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h4><ul><li><p><code>GLSL</code>支持常见的算术运算符和赋值运算符</p></li><li><p>要注意的一点是，运算一定要保证维度的匹配，比如不能将一个<code>vec2</code>的变量与一个<code>vec3</code>的变量相加，要加的话得选取<code>vec3</code>变量的其中<code>2</code>个维度，转成<code>vec2</code>变量才能与另一个<code>vec2</code>变量相加</p></li><li><p>也有一种特殊的情况，当<strong>一个向量和一个标量进行运算</strong>时，<code>GLSL</code>会将标量广播（<code>broadcast</code>）到向量的每一个分量上</p></li></ul><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="type">vec2</span> v = <span class="type">vec2</span>(<span class="number">1.0</span>, <span class="number">2.0</span>);</span><br><span class="line">v += <span class="number">1.0</span>; <span class="comment">// v 的值为 vec2(2.0, 3.0)</span></span><br></pre></td></tr></table></figure><h4 id="控制流"><a href="#控制流" class="headerlink" title="控制流"></a>控制流</h4><ul><li>和常规的编程语言一样，<code>GLSL</code>有基本的控制流结构</li></ul><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line">    <span class="comment">// 条件满足时执行</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 条件不满足时执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>这里要注意一点，<code>Shader</code>是针对整个屏幕的像素进行处理的，因此<code>if</code>的所有分支只要满足一定的条件，都会被执行。这是由于<code>GPU</code>的<strong>并行特性</strong>和<strong>像素级独立处理</strong>的工作方式</li></ul><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (fragCoord.x &lt; iResolution.x * <span class="number">0.25</span>)</span><br><span class="line">    fragColor = <span class="type">vec4</span>(<span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>); <span class="comment">// 红色</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (fragCoord.x &lt; iResolution.x * <span class="number">0.5</span>)</span><br><span class="line">    fragColor = <span class="type">vec4</span>(<span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>); <span class="comment">// 绿色</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    fragColor = <span class="type">vec4</span>(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>); <span class="comment">// 蓝色</span></span><br></pre></td></tr></table></figure><ul><li><code>GPU</code>会为屏幕上的每个像素单独运行一遍<code>Fragment Shader</code>代码，代码中的<code>if</code>条件根据每个像素的位置（<code>fragCoord.x</code>）来决定应该执行哪一段代码</li></ul><iframe width="100%" height="400" src="//jsfiddle.net/HDL52/0wrkqhm2/2/embedded/result/dark/" frameborder="0" loading="lazy" allowtransparency="true" allowfullscreen></iframe><h4 id="变量限定符"><a href="#变量限定符" class="headerlink" title="变量限定符"></a>变量限定符</h4><p>变量限定符是用来描述变量的存储和使用方式的关键词</p><ul><li><code>GLSL</code>中常用的变量限定符有以下几种，<code>uniform</code>、<code>const</code>、<code>varying</code>、<code>attribute</code></li></ul><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="keyword">uniform</span> <span class="type">vec3</span> uColor; <span class="comment">// 定义统一的颜色变量</span></span><br><span class="line"><span class="keyword">varying</span> <span class="type">vec3</span> vColor; <span class="comment">// 顶点着色器向片元着色器传递的颜色 (旧版 GLSL)</span></span><br><span class="line"><span class="keyword">attribute</span> <span class="type">vec3</span> aPosition; <span class="comment">// 传递顶点位置 (旧版 GLSL)</span></span><br></pre></td></tr></table></figure><ul><li><code>uniform</code>: 全局变量，一旦定义后会同时存在于顶点着色器与片元着色器中，并且它在每一个顶点和片元上的值都是相同的，是一个“统一”的值</li><li><code>const</code>: 定义常量，它是无法被改变的一个值</li><li><code>iTime</code>: 表示<code>Shader</code>从开始到现在执行所经过的时间，用于创作动画效果</li><li><code>iResolution</code>: 表示<code>Shader</code>所在画布的大小，默认是占满整个屏幕</li><li><code>iMouse</code>: 表示用户鼠标当前所在的位置</li></ul><h4 id="宏定义"><a href="#宏定义" class="headerlink" title="宏定义"></a>宏定义</h4><p>宏（<code>macros</code>）是一种预处理指令，用于在编译时进行文本的替换，常用于定义常量、函数、条件编译等</p><ul><li>宏定义的格式是<code>#define 宏的名称 宏的值</code>，语句结尾没有分号。下面代码定义了一个名为<code>PI</code>的宏，<code>Shader</code>编译时会将所有的<code>PI</code>替换为<code>3.14159265359</code>这个值</li></ul><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="meta">#define PI 3.14159265359</span></span><br></pre></td></tr></table></figure><ul><li>宏也可以带有参数。下面代码定义了一个名为<code>add</code>的宏，接受<code>2</code>个参数<code>a</code>和<code>b</code>，对它们应用相加的运算，并且无需指定明确的类型，调用这个宏时只要参数的类型相匹配，就能正确执行宏定义的运算</li></ul><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="meta">#define add(a,b) a+b</span></span><br></pre></td></tr></table></figure><ul><li>宏也可以条件编译。下面代码会在<strong>编译时</strong>通过<code>#if</code>判断宏<code>USE_COLOR</code>的值是否为<code>1</code>，如果<code>USE_COLOR == 1</code>，代码会保留红色的定义，反之，代码会保留黑色的定义</li></ul><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="meta">#define USE_COLOR 1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#if USE_COLOR == 1</span></span><br><span class="line">    <span class="type">vec3</span> color = <span class="type">vec3</span>(<span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>);</span><br><span class="line"><span class="meta">#else</span></span><br><span class="line">    <span class="type">vec3</span> color = <span class="type">vec3</span>(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>);</span><br><span class="line"><span class="meta">#endif</span></span><br></pre></td></tr></table></figure><hr><h3 id="UV基础与核心概念"><a href="#UV基础与核心概念" class="headerlink" title="UV基础与核心概念"></a><code>UV</code>基础与核心概念</h3><h4 id="UV坐标"><a href="#UV坐标" class="headerlink" title="UV坐标"></a><code>UV</code>坐标</h4><ul><li><code>UV</code>坐标是一种将像素坐标归一化到<code>[0.0, 1.0]</code>范围的坐标系，其中<code>U</code>代表水平方向（<code>x</code>坐标），<code>V</code>代表垂直方向（<code>y</code>坐标）</li><li>在<code>Shader</code>编程中，<code>UV</code>坐标用于描述画布上的归一化像素位置，通常由片元着色器中的<code>fragCoord</code>和<code>iResolution</code>计算得出，下面是<strong>归一化公式</strong></li></ul><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> mainImage(<span class="keyword">out</span> <span class="type">vec4</span> fragColor, <span class="keyword">in</span> <span class="type">vec2</span> fragCoord) &#123;</span><br><span class="line">    <span class="type">vec2</span> uv = fragCoord / iResolution.xy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="UV坐标的分布特性"><a href="#UV坐标的分布特性" class="headerlink" title="UV坐标的分布特性"></a><code>UV</code>坐标的分布特性</h4><ul><li>先看下<code>x</code>坐标的分布情况</li></ul><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> mainImage(<span class="keyword">out</span> <span class="type">vec4</span> fragColor, <span class="keyword">in</span> <span class="type">vec2</span> fragCoord) &#123;</span><br><span class="line">    <span class="type">vec2</span> uv = fragCoord / iResolution.xy;</span><br><span class="line">    fragColor = <span class="type">vec4</span>(uv.x, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>现在默认颜色的第<code>3</code>个值是<code>0</code>，只看前<code>2</code>个值。可以看到<code>x</code>坐标从左边开始是黑色，值是<code>(0,0)</code>，到最右边是纯红色，值是<code>(1,0)</code>，而中间则是分布在<code>(0,1)</code>之间的值。从整体上看，得到了一个横向的渐变图案</li></ul><iframe width="100%" height="400" src="//jsfiddle.net/HDL52/q0wxagrm/1/embedded/result/dark/" frameborder="0" loading="lazy" allowtransparency="true" allowfullscreen></iframe><ul><li>再看下<code>y</code>坐标的分布情况</li></ul><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> mainImage(<span class="keyword">out</span> <span class="type">vec4</span> fragColor, <span class="keyword">in</span> <span class="type">vec2</span> fragCoord) &#123;</span><br><span class="line">    <span class="type">vec2</span> uv = fragCoord / iResolution.xy;</span><br><span class="line">    fragColor = <span class="type">vec4</span>(<span class="number">0.0</span>, uv.y, <span class="number">0.0</span>, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>可以看到<code>y</code>坐标从底下开始是黑色，值是<code>(0,0)</code>，到最上面是纯绿色，值是<code>(0,1)</code>，而中间则是分布在<code>(0,1)</code>之间的值。从整体上看，得到了一个纵向的渐变图案</li></ul><iframe width="100%" height="400" src="//jsfiddle.net/HDL52/arktw6dy/14/embedded/result/dark/" frameborder="0" loading="lazy" allowtransparency="true" allowfullscreen></iframe><ul><li>接下来同时输出<code>x</code>坐标和<code>y</code>坐标的分布</li></ul><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> mainImage(<span class="keyword">out</span> <span class="type">vec4</span> fragColor, <span class="keyword">in</span> <span class="type">vec2</span> fragCoord) &#123;</span><br><span class="line">    <span class="type">vec2</span> uv = fragCoord / iResolution.xy;</span><br><span class="line">    fragColor = <span class="type">vec4</span>(uv, <span class="number">0.0</span>, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>左下角原点是黑色，值是<code>(0,0)</code>，右下角是红色，值是<code>(1,0)</code>，左上角是绿色，值是<code>(0,1)</code>，右上角是黄色，值是<code>(1,1)</code>，中间的所有值在<code>(0,0)</code>到<code>(1,1)</code>这<code>2</code>个区间分布。从整体上看，得到了一个有多种颜色的渐变图案</li></ul><iframe width="100%" height="400" src="//jsfiddle.net/HDL52/beun0ztc/1/embedded/result/dark/" frameborder="0" loading="lazy" allowtransparency="true" allowfullscreen></iframe><ul><li>上面就是所谓的<code>UV</code>坐标，它代表了图像（这里指画布）上所有像素的归一化后的坐标位置，其中<code>U</code>代表水平方向，<code>V</code>代表垂直方向</li></ul><h4 id="图形绘制-圆形"><a href="#图形绘制-圆形" class="headerlink" title="图形绘制 (圆形)"></a>图形绘制 (圆形)</h4><ul><li>先计算<code>UV</code>坐标上的点到原点的距离，然后根据这些距离的值来设定对应点的颜色</li><li>为了计算<code>UV</code>上点到原点的距离，可以用<code>GLSL</code>的内置函数<code>length</code>函数来实现</li></ul><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> mainImage(<span class="keyword">out</span> <span class="type">vec4</span> fragColor, <span class="keyword">in</span> <span class="type">vec2</span> fragCoord) &#123;</span><br><span class="line">    <span class="type">vec2</span> uv = fragCoord / iResolution.xy;</span><br><span class="line">    <span class="type">float</span> d = <span class="built_in">length</span>(uv);</span><br><span class="line">    fragColor = <span class="type">vec4</span>(<span class="type">vec3</span>(d), <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>左下角原点是黑色，值是<code>(0,0)</code>，从原点向右上方向辐射的径向渐变，上面每个点的值代表的就是该点到原点的距离，越靠近原点距离越小，越接近黑色，反之越远离原点距离越大，越接近白色</li></ul><iframe width="100%" height="400" src="//jsfiddle.net/HDL52/tphn4ge7/1/embedded/result/dark/" frameborder="0" loading="lazy" allowtransparency="true" allowfullscreen></iframe><ul><li>目前图形的位置在左下角，把它挪到中间，将<code>UV</code>的坐标减去<code>0.5</code>，再整体乘上<code>2</code>，这一步被称为“<code>UV</code>的居中处理”</li></ul><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> mainImage(<span class="keyword">out</span> <span class="type">vec4</span> fragColor, <span class="keyword">in</span> <span class="type">vec2</span> fragCoord) &#123;</span><br><span class="line">    <span class="type">vec2</span> uv = fragCoord / iResolution.xy;</span><br><span class="line">    uv = (uv - <span class="number">0.5</span>) * <span class="number">2.0</span>;</span><br><span class="line">    fragColor = <span class="type">vec4</span>(uv, <span class="number">0.0</span>, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><iframe width="100%" height="400" src="//jsfiddle.net/HDL52/kc9tjwpq/2/embedded/result/dark/" frameborder="0" loading="lazy" allowtransparency="true" allowfullscreen></iframe><ul><li>看下操作前后的对比图</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/imgb29b63a75cb74fb9abe31376184db120%7Etplv-k3u1fbpfcp-jj-mark_3024_0_0_0_q75.awebp"></p><ul><li><p>之前的坐标系原点是第一幅图左下角的<code>(0,0)</code>，通过整体减去<code>0.5</code>，将原点变成了<code>(-0.5,-0.5)</code>，也就是第二幅图左下角的那个点的位置，第一幅图的中点<code>(0.5,0.5)</code>就变成了第二幅图的中点<code>(0,0)</code>，然后，将坐标整体乘上<code>2</code>，将<code>0.5</code>变成了<code>1</code>，这样归一化后能方便后续的计算</p></li><li><p>理解<code>UV</code>的居中处理后，将<code>UV</code>坐标输出的代码注释掉，换回之前的距离代码</p></li></ul><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> mainImage(<span class="keyword">out</span> <span class="type">vec4</span> fragColor, <span class="keyword">in</span> <span class="type">vec2</span> fragCoord) &#123;</span><br><span class="line">    <span class="type">vec2</span> uv = fragCoord / iResolution.xy;</span><br><span class="line">    uv = (uv - <span class="number">0.5</span>) * <span class="number">2.0</span>;</span><br><span class="line">    <span class="type">float</span> d = <span class="built_in">length</span>(uv);</span><br><span class="line">    fragColor = <span class="type">vec4</span>(<span class="type">vec3</span>(d), <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>可以看到图形确实被挪到了中间。然而，图形目前的形状是一个椭圆，这是为什么呢？因为<code>UV</code>坐标的值并不会自动地适应画布的比例，导致了图形被拉伸这一现象</li></ul><iframe width="100%" height="400" src="//jsfiddle.net/HDL52/rcogqxp6/2/embedded/result/dark/" frameborder="0" loading="lazy" allowtransparency="true" allowfullscreen></iframe><ul><li>为了修正这一点，需要计算画布的比例，将画布长除以画布宽就能算出，再将<code>UV</code>的<code>x</code>坐标与比例相乘即可</li></ul><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> mainImage(<span class="keyword">out</span> <span class="type">vec4</span> fragColor, <span class="keyword">in</span> <span class="type">vec2</span> fragCoord) &#123;</span><br><span class="line">    <span class="type">vec2</span> uv = fragCoord / iResolution.xy;</span><br><span class="line">    uv = (uv - <span class="number">0.5</span>) * <span class="number">2.0</span>;</span><br><span class="line">    uv.x *= iResolution.x / iResolution.y;</span><br><span class="line">    <span class="type">float</span> d = <span class="built_in">length</span>(uv);</span><br><span class="line">    fragColor = <span class="type">vec4</span>(<span class="type">vec3</span>(d), <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>上面代码得到了一个完整的圆形径向渐变。中点的值是<code>(0,0)</code>，颜色是纯黑色，然而从中点开始向四周辐射的那些区域，它们的值都大于<code>0</code>，不是纯黑色。我们的目标，是要把其中的一片区域也变成纯黑色，也就是说要把分布在这片区域上面的点的值也变成<code>0</code></li></ul><iframe width="100%" height="400" src="//jsfiddle.net/HDL52/hnfbt9a7/2/embedded/result/dark/" frameborder="0" loading="lazy" allowtransparency="true" allowfullscreen></iframe><ul><li>在<code>Shader</code>中，值的显示范围只会是<code>[0,1]</code>之间，小于<code>0</code>的负数实际显示的值还是<code>0</code>（黑色），大于<code>1</code>的数实际显示的值还是<code>1</code>（白色）。可以利用这一点，给距离<code>d</code>减去一个值（这里取<code>0.5</code>），制造出一片负数的区域，而这片区域就是黑色</li></ul><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> mainImage(<span class="keyword">out</span> <span class="type">vec4</span> fragColor, <span class="keyword">in</span> <span class="type">vec2</span> fragCoord) &#123;</span><br><span class="line">    <span class="type">vec2</span> uv = fragCoord / iResolution.xy;</span><br><span class="line">    uv = (uv - <span class="number">0.5</span>) * <span class="number">2.0</span>;</span><br><span class="line">    uv.x *= iResolution.x / iResolution.y;</span><br><span class="line">    <span class="type">float</span> d = <span class="built_in">length</span>(uv);</span><br><span class="line">    d -= <span class="number">0.5</span>;</span><br><span class="line">    fragColor = <span class="type">vec4</span>(<span class="type">vec3</span>(d), <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>中间确实出现了纯黑色的圆形区域，然后只需把周围的渐变给消除，就能得到真正的圆形</li></ul><iframe width="100%" height="400" src="//jsfiddle.net/HDL52/waL3k1b0/1/embedded/result/dark/" frameborder="0" loading="lazy" allowtransparency="true" allowfullscreen></iframe><ul><li>先定义一个中间变量<code>c</code>，用<code>if</code>语句来判断距离<code>d</code>的大小，如果大于<code>0</code>，代表的是除了中间纯黑区域外的渐变区域，将它们的值设为<code>1</code>（白色）。反之，就代表的是中间的纯黑区域，将它们的值设为<code>0</code>（黑色），最后将中间变量直接作为结果输出即可</li></ul><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> mainImage(<span class="keyword">out</span> <span class="type">vec4</span> fragColor, <span class="keyword">in</span> <span class="type">vec2</span> fragCoord) &#123;</span><br><span class="line">    <span class="type">vec2</span> uv = fragCoord / iResolution.xy;</span><br><span class="line">    uv = (uv - <span class="number">0.5</span>) * <span class="number">2.0</span>;</span><br><span class="line">    uv.x *= iResolution.x / iResolution.y;</span><br><span class="line">    <span class="type">float</span> d = <span class="built_in">length</span>(uv);</span><br><span class="line">    d -= <span class="number">0.5</span>;</span><br><span class="line">    <span class="type">float</span> c = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">if</span> (d &gt; <span class="number">0.0</span>) &#123;</span><br><span class="line">        c = <span class="number">1.0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        c = <span class="number">0.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    fragColor = <span class="type">vec4</span>(<span class="type">vec3</span>(c), <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><iframe width="100%" height="400" src="//jsfiddle.net/HDL52/1hgnwc0r/5/embedded/result/dark/" frameborder="0" loading="lazy" allowtransparency="true" allowfullscreen></iframe><ul><li>在<code>Shader</code>的编写中，应当尽量避免使用<code>if</code>语句。因为<code>GPU</code>是并行处理结果的，而<code>if</code>语句会让处理器进行分支切换这一操作，处理多个分支会降低并行处理的性能。</li><li>可以用<code>GLSL</code>其中的一个内置函数来优化掉<code>if</code>语句，这个内置函数是 <code>step</code>函数，也被称作“阶梯函数”，是因为它的图像是阶梯的形状</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/imgc6098091ff504641b13f961d79233dd7%7Etplv-k3u1fbpfcp-jj-mark_3024_0_0_0_q75.awebp"></p><ul><li>它的代码表示形式是这样的</li></ul><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="built_in">step</span>(edge, x)</span><br></pre></td></tr></table></figure><ul><li>它接受<code>2</code>个参数，边界值<code>edge</code>和目标值<code>x</code>，如果目标值<code>x</code>大于边界值<code>edge</code>，则返回<code>1</code>，反之返回<code>0</code></li></ul><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> mainImage(<span class="keyword">out</span> <span class="type">vec4</span> fragColor, <span class="keyword">in</span> <span class="type">vec2</span> fragCoord) &#123;</span><br><span class="line">    <span class="type">vec2</span> uv = fragCoord / iResolution.xy;</span><br><span class="line">    uv = (uv - <span class="number">0.5</span>) * <span class="number">2.0</span>;</span><br><span class="line">    uv.x *= iResolution.x / iResolution.y;</span><br><span class="line">    <span class="type">float</span> d = <span class="built_in">length</span>(uv);</span><br><span class="line">    d -= <span class="number">0.5</span>;</span><br><span class="line">    <span class="type">float</span> c = <span class="built_in">step</span>(<span class="number">0.0</span>, d);</span><br><span class="line">    fragColor = <span class="type">vec4</span>(<span class="type">vec3</span>(c), <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><iframe width="100%" height="400" src="//jsfiddle.net/HDL52/2nz7p9bg/1/embedded/result/dark/" frameborder="0" loading="lazy" allowtransparency="true" allowfullscreen></iframe><ul><li>尽管圆形是画出来了，但仔细一看，就会发现图形的周围有锯齿，比较影响美观，要消除它们</li><li>再来认识一个<code>GLSL</code>的内置函数——<code>smoothstep</code>函数，它也被称作“平滑阶梯函数”，是因为它的函数图像是一个平滑过的阶梯的形状</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img4553d587e19e41af8e44b5639e4b09df%7Etplv-k3u1fbpfcp-jj-mark_3024_0_0_0_q75.awebp"></p><ul><li>它的代码表示形式是这样的</li></ul><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="built_in">smoothstep</span>(edge1, edge2, x)</span><br></pre></td></tr></table></figure><ul><li>它的边界值比<code>step</code>函数要多一个，可以将它的边界值定为<code>edge1</code>和<code>edge2</code>。如果目标值<code>x</code>小于边界值<code>edge1</code>，则返回<code>0</code>。如果目标值<code>x</code>大于边界值<code>edge2</code>，则返回<code>1</code>。如果目标值<code>x</code>在<code>2</code>个边界值之间，则返回从<code>0</code>到<code>1</code>平滑过渡的值</li><li>把之前代码里的<code>step</code>函数的语句注释掉，改成用<code>smoothstep</code>函数来实现，再将第<code>2</code>个边界值设定为一个比<code>0</code>稍微大一点的值。这里取了<code>0.02</code></li></ul><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> mainImage(<span class="keyword">out</span> <span class="type">vec4</span> fragColor, <span class="keyword">in</span> <span class="type">vec2</span> fragCoord) &#123;</span><br><span class="line">    <span class="type">vec2</span> uv = fragCoord / iResolution.xy;</span><br><span class="line">    uv = (uv - <span class="number">0.5</span>) * <span class="number">2.0</span>;</span><br><span class="line">    uv.x *= iResolution.x / iResolution.y;</span><br><span class="line">    <span class="type">float</span> d = <span class="built_in">length</span>(uv);</span><br><span class="line">    d -= <span class="number">0.5</span>;</span><br><span class="line">    <span class="type">float</span> c = <span class="built_in">smoothstep</span>(<span class="number">0.0</span>, <span class="number">0.02</span>, d);</span><br><span class="line">    fragColor = <span class="type">vec4</span>(<span class="type">vec3</span>(c), <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>这样，就得到了一个边缘是平滑的，没有锯齿的圆形</li></ul><iframe width="100%" height="400" src="//jsfiddle.net/HDL52/q3vu9nb7/1/embedded/result/dark/" frameborder="0" loading="lazy" allowtransparency="true" allowfullscreen></iframe><h4 id="图形效果"><a href="#图形效果" class="headerlink" title="图形效果"></a>图形效果</h4><ul><li>尽管<code>Shader</code>的绘图步骤确实要比传统的绘图方式要繁琐一点，但是也带来了很多意想不到的可能性，比方说，它能实现一些特殊的图形效果</li></ul><h5 id="模糊效果"><a href="#模糊效果" class="headerlink" title="模糊效果"></a><p style="font-size:14px">模糊效果</p></h5><ul><li>上面代码用到了<code>smoothstep</code>函数来绘制圆形，它的第二个参数用的是一个很小的值<code>0.02</code>，尝试把这个值改大一点，比如<code>0.2</code></li></ul><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> mainImage(<span class="keyword">out</span> <span class="type">vec4</span> fragColor, <span class="keyword">in</span> <span class="type">vec2</span> fragCoord) &#123;</span><br><span class="line">    <span class="type">vec2</span> uv = fragCoord / iResolution.xy;</span><br><span class="line">    uv = (uv - <span class="number">0.5</span>) * <span class="number">2.0</span>;</span><br><span class="line">    uv.x *= iResolution.x / iResolution.y;</span><br><span class="line">    <span class="type">float</span> d = <span class="built_in">length</span>(uv);</span><br><span class="line">    d -= <span class="number">0.5</span>;</span><br><span class="line">    <span class="type">float</span> c = <span class="built_in">smoothstep</span>(<span class="number">0.0</span>, <span class="number">0.2</span>, d);</span><br><span class="line">    fragColor = <span class="type">vec4</span>(<span class="type">vec3</span>(c), <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>随着渐变区域的扩大，圆形的边缘变得模糊了起来，这是因为两个边界值的差变大了，渐变的区域也就随着变大了，这样就营造出了一种模糊的效果</li></ul><iframe width="100%" height="400" src="//jsfiddle.net/HDL52/298mf57z/1/embedded/result/dark/" frameborder="0" loading="lazy" allowtransparency="true" allowfullscreen></iframe><h5 id="发光效果"><a href="#发光效果" class="headerlink" title="发光效果"></a><p style="font-size:14px">发光效果</p></h5><ul><li>这里不用<code>smoothstep</code>函数来绘制图形，取距离<code>d</code>的倒数，并且乘上一个比较小的值</li></ul><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> mainImage(<span class="keyword">out</span> <span class="type">vec4</span> fragColor, <span class="keyword">in</span> <span class="type">vec2</span> fragCoord) &#123;</span><br><span class="line">    <span class="type">vec2</span> uv = fragCoord / iResolution.xy;</span><br><span class="line">    uv = (uv - <span class="number">0.5</span>) * <span class="number">2.0</span>;</span><br><span class="line">    uv.x *= iResolution.x / iResolution.y;</span><br><span class="line">    <span class="type">float</span> d = <span class="built_in">length</span>(uv);</span><br><span class="line">    <span class="type">float</span> c = <span class="number">0.25</span> / d;</span><br><span class="line">    fragColor = <span class="type">vec4</span>(<span class="type">vec3</span>(c), <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><iframe width="100%" height="400" src="//jsfiddle.net/HDL52/20jhyq9m/2/embedded/result/dark/" frameborder="0" loading="lazy" allowtransparency="true" allowfullscreen></iframe><ul><li>画面上出现了一个美丽的光球，它是怎么形成的呢</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img59b48526299f48f4b5e1b3adac92425b%7Etplv-k3u1fbpfcp-jj-mark_3024_0_0_0_q75.awebp"></p><ul><li><p>这是个反比例函数的图像，目前输入值范围是<code>(0.,1.)</code>，在这段范围内，输入值位于<code>(0.,.25)</code>时，输出值都大于<code>1</code>，<code>Shader</code>中比<code>1</code>大的值输出的还是白色，因此能看到中间的白色圆形部分。输入值位于<code>(.25,1.)</code>时，输出的值开始变成了比<code>1</code>小的值，而且是逐渐变化的，因此会产生一种渐变的效果</p></li><li><p>目前光的辐射范围太大了，要稍微缩小一些</p></li><li><p>再来认识一个新的内置函数——<code>pow</code>函数，它用于计算数字的指数幂，比如<code>pow(4.,3.)</code>，返回的值就是<code>4</code>的<code>3</code>次方——<code>64</code>，也就是说，<code>pow</code>这个函数能让数值指数般地增长</p></li></ul><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> mainImage(<span class="keyword">out</span> <span class="type">vec4</span> fragColor, <span class="keyword">in</span> <span class="type">vec2</span> fragCoord) &#123;</span><br><span class="line">    <span class="type">vec2</span> uv = fragCoord / iResolution.xy;</span><br><span class="line">    uv = (uv - <span class="number">0.5</span>) * <span class="number">2.0</span>;</span><br><span class="line">    uv.x *= iResolution.x / iResolution.y;</span><br><span class="line">    <span class="type">float</span> d = <span class="built_in">length</span>(uv);</span><br><span class="line">    <span class="type">float</span> c = <span class="number">0.25</span> / d;</span><br><span class="line">    c = <span class="built_in">pow</span>(c, <span class="number">1.6</span>);</span><br><span class="line">    fragColor = <span class="type">vec4</span>(<span class="type">vec3</span>(c), <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><iframe width="100%" height="400" src="//jsfiddle.net/HDL52/yf4gt3L5/1/embedded/result/dark/" frameborder="0" loading="lazy" allowtransparency="true" allowfullscreen></iframe><ul><li>为了理解这一步，依旧来看图</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img88ddcf2cfc24418aa5c405b7e57b2110%7Etplv-k3u1fbpfcp-jj-mark_3024_0_0_0_q75.awebp"></p><ul><li>函数图像比之前要往下“躺”了一些，输出值总体变小了，这样光的辐射也稍微缩小了一点</li></ul><h4 id="SDF函数"><a href="#SDF函数" class="headerlink" title="SDF函数"></a><code>SDF</code>函数</h4><ul><li>圆形是众多几何图形中的其中一种，既然已经通过上面的方式将它画了出来，那肯定也能用类似的手段来把其他图形给画出来</li><li>绘制圆形时，在调用<code>smoothstep</code>函数之前做了如下的操作</li></ul><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span> d = <span class="built_in">length</span>(uv);</span><br><span class="line">d -= <span class="number">0.5</span>;</span><br></pre></td></tr></table></figure><ul><li>其实，可以把这些操作抽象成一个函数，叫<code>sdCircle</code></li></ul><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span> sdCircle(<span class="type">vec2</span> p, <span class="type">float</span> r) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">length</span>(p) - r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> mainImage(<span class="keyword">out</span> <span class="type">vec4</span> fragColor, <span class="keyword">in</span> <span class="type">vec2</span> fragCoord) &#123;</span><br><span class="line">    <span class="type">vec2</span> uv = fragCoord / iResolution.xy;</span><br><span class="line">    <span class="type">float</span> d = sdCircle(uv, <span class="number">0.5</span>);</span><br><span class="line">    fragColor = <span class="type">vec4</span>(<span class="type">vec3</span>(d), <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>尽管这个函数的调用结果跟之前写的一模一样，但它有一个特殊的含义，它是一个<code>SDF</code>函数</li><li><code>SDF</code>函数（<code>Signed Distance Function</code>），中文译作“符号距离函数”，它用于描述这么一个函数，它将空间里的一个位置作为输入，并返回该位置到给定形状的距离，它的前面还有个“符号”，是因为在形状外的距离为正数（“<code>+</code>”号），在形状内的距离为负数（“<code>-</code>”号），边界处的值恰好为<code>0</code></li><li>下图是圆形<code>SDF</code>函数的可视化图，可以更形象地理解它的意义</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img302511b0a5124c039ddcc8b15bd2a764%7Etplv-k3u1fbpfcp-jj-mark_3024_0_0_0_q75.awebp"></p><blockquote><p>图形学大咖<code>Inigo Quilez</code>（后文简称<code>iq</code>）的博客上有篇文章把常用的<code>2D</code>图形的<code>SDF</code>函数都列了出来，如果有需要可以<a target="_blank" rel="noopener" href="https://iquilezles.org/articles/distfunctions2d/">随时查阅</a></p></blockquote><ul><li>知道<code>SDF</code>函数的概念后，绘制其他图形将会变得非常轻松，比如想要画一个长方形，那么只需找到长方形的<code>SDF</code>函数（<code>sdBox</code>），调用它获取距离，再用<code>step</code>或<code>smoothstep</code>函数勾画出图形即可</li></ul><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span> sdBox(<span class="keyword">in</span> <span class="type">vec2</span> p, <span class="keyword">in</span> <span class="type">vec2</span> b)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">vec2</span> d = <span class="built_in">abs</span>(p) - b;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">length</span>(<span class="built_in">max</span>(d, <span class="type">vec2</span>(<span class="number">0.</span>))) + <span class="built_in">min</span>(<span class="built_in">max</span>(d.x, d.y), <span class="number">0.</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> mainImage(<span class="keyword">out</span> <span class="type">vec4</span> fragColor, <span class="keyword">in</span> <span class="type">vec2</span> fragCoord)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">vec2</span> uv = fragCoord / iResolution.xy;</span><br><span class="line">    uv = (uv - <span class="type">vec2</span>(<span class="number">0.5</span>)) * <span class="number">2.0</span>;</span><br><span class="line">    uv.x *= iResolution.x / iResolution.y;</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> d = sdBox(uv, <span class="type">vec2</span>(<span class="number">0.6</span>, <span class="number">0.3</span>));</span><br><span class="line">    <span class="type">float</span> c = <span class="built_in">smoothstep</span>(<span class="number">0.0</span>, <span class="number">0.02</span>, d);</span><br><span class="line">    fragColor = <span class="type">vec4</span>(<span class="type">vec3</span>(c), <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>上面的代码画出了一个半尺寸长为<code>0.6</code>、宽为<code>0.3</code>（实际长为<code>1.2</code>、宽为<code>0.6</code>）的长方形</li><li>在<code>SDF</code>中，矩形的<code>sdBox</code>函数定义的<code>b</code>参数（如<code>vec2(0.6, 0.3)</code>）表示的是矩形的半尺寸。这是因为<code>SDF</code>函数设计时，通常使用半尺寸来计算方便</li></ul><iframe width="100%" height="400" src="//jsfiddle.net/HDL52/f6Lwb17t/2/embedded/result/dark/" frameborder="0" loading="lazy" allowtransparency="true" allowfullscreen></iframe><h4 id="UV变换"><a href="#UV变换" class="headerlink" title="UV变换"></a><code>UV</code>变换</h4><ul><li>基于已经画好的这个长方形，来学习一些基本的<code>UV</code>变换操作</li></ul><h5 id="平移"><a href="#平移" class="headerlink" title="平移"></a><p style="font-size:14px">平移</p></h5><ul><li>先尝试给<code>UV</code>的<code>x</code>或<code>y</code>坐标加上想移动的值</li></ul><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span> sdBox(<span class="keyword">in</span> <span class="type">vec2</span> p, <span class="keyword">in</span> <span class="type">vec2</span> b)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">vec2</span> d = <span class="built_in">abs</span>(p) - b;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">length</span>(<span class="built_in">max</span>(d, <span class="type">vec2</span>(<span class="number">0.0</span>))) + <span class="built_in">min</span>(<span class="built_in">max</span>(d.x, d.y), <span class="number">0.0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> mainImage(<span class="keyword">out</span> <span class="type">vec4</span> fragColor, <span class="keyword">in</span> <span class="type">vec2</span> fragCoord)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">vec2</span> uv = fragCoord / iResolution.xy;</span><br><span class="line">    uv = (uv - <span class="type">vec2</span>(<span class="number">0.5</span>)) * <span class="number">2.0</span>;</span><br><span class="line">    uv.x *= iResolution.x / iResolution.y;</span><br><span class="line">    uv.x += <span class="number">0.2</span>;</span><br><span class="line">    uv.y += <span class="number">0.4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> d = sdBox(uv, <span class="type">vec2</span>(<span class="number">0.6</span>, <span class="number">0.3</span>));</span><br><span class="line">    <span class="type">float</span> c = <span class="built_in">smoothstep</span>(<span class="number">0.0</span>, <span class="number">0.02</span>, d);</span><br><span class="line">    fragColor = <span class="type">vec4</span>(<span class="type">vec3</span>(c), <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><iframe width="100%" height="400" src="//jsfiddle.net/HDL52/b2Lmw09n/1/embedded/result/dark/" frameborder="0" loading="lazy" allowtransparency="true" allowfullscreen></iframe><ul><li>明明是给坐标加上了值，为什么图形的坐标并未朝右上移动，而是朝相反的左下方向移动了呢</li></ul><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> mainImage(<span class="keyword">out</span> <span class="type">vec4</span> fragColor, <span class="keyword">in</span> <span class="type">vec2</span> fragCoord)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">vec2</span> uv = fragCoord / iResolution.xy;</span><br><span class="line">    uv = (uv - <span class="type">vec2</span>(<span class="number">0.5</span>)) * <span class="number">2.0</span>;</span><br><span class="line">    uv.x *= iResolution.x / iResolution.y;</span><br><span class="line">    uv.x += <span class="number">0.2</span>;</span><br><span class="line">    uv.y += <span class="number">0.4</span>;</span><br><span class="line">    fragColor = <span class="type">vec4</span>(uv, <span class="number">0.0</span>, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img57f5a49e288c4afa9bbd2e9cf103fba6%7Etplv-k3u1fbpfcp-jj-mark_3024_0_0_0_q75.awebp"></p><ul><li>之前位于中间的原点值是<code>(0,0)</code>，现在则变成了<code>(0.2,0.4)</code>，上一个<code>(0,0)</code>移动到了当前中间点的左下方，<code>SDF</code>函数输入的坐标值的原点值是<code>(0,0)</code>，正好对应左下方的那个点，因此图形才会整体往左下方移动</li><li>为了确定<code>SDF</code>图形位置的变化，要看目前<code>(0,0)</code>这个点的位置变化。如果要平移符合正方向的移动（右上方），把之前的加法操作改成与其相反的减法操作即可</li></ul><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span> sdBox(<span class="keyword">in</span> <span class="type">vec2</span> p, <span class="keyword">in</span> <span class="type">vec2</span> b)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">vec2</span> d = <span class="built_in">abs</span>(p) - b;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">length</span>(<span class="built_in">max</span>(d, <span class="type">vec2</span>(<span class="number">0.0</span>))) + <span class="built_in">min</span>(<span class="built_in">max</span>(d.x, d.y), <span class="number">0.0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> mainImage(<span class="keyword">out</span> <span class="type">vec4</span> fragColor, <span class="keyword">in</span> <span class="type">vec2</span> fragCoord)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">vec2</span> uv = fragCoord / iResolution.xy;</span><br><span class="line">    uv = (uv - <span class="type">vec2</span>(<span class="number">0.5</span>)) * <span class="number">2.0</span>;</span><br><span class="line">    uv.x *= iResolution.x / iResolution.y;</span><br><span class="line">    uv -= <span class="type">vec2</span>(<span class="number">0.2</span>, <span class="number">0.4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> d = sdBox(uv, <span class="type">vec2</span>(<span class="number">0.6</span>, <span class="number">0.3</span>));</span><br><span class="line">    <span class="type">float</span> c = <span class="built_in">smoothstep</span>(<span class="number">0.0</span>, <span class="number">0.02</span>, d);</span><br><span class="line">    fragColor = <span class="type">vec4</span>(<span class="type">vec3</span>(c), <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><iframe width="100%" height="400" src="//jsfiddle.net/HDL52/94f6p7zd/2/embedded/result/dark/" frameborder="0" loading="lazy" allowtransparency="true" allowfullscreen></iframe><h5 id="缩放"><a href="#缩放" class="headerlink" title="缩放"></a><p style="font-size:14px">缩放</p></h5><ul><li>先尝试给<code>UV</code>的<code>x</code>或<code>y</code>坐标乘上想缩放的值</li></ul><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span> sdBox(<span class="keyword">in</span> <span class="type">vec2</span> p, <span class="keyword">in</span> <span class="type">vec2</span> b)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">vec2</span> d = <span class="built_in">abs</span>(p) - b;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">length</span>(<span class="built_in">max</span>(d, <span class="type">vec2</span>(<span class="number">0.0</span>))) + <span class="built_in">min</span>(<span class="built_in">max</span>(d.x, d.y), <span class="number">0.0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> mainImage(<span class="keyword">out</span> <span class="type">vec4</span> fragColor, <span class="keyword">in</span> <span class="type">vec2</span> fragCoord)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">vec2</span> uv = fragCoord / iResolution.xy;</span><br><span class="line">    uv = (uv - <span class="type">vec2</span>(<span class="number">0.5</span>)) * <span class="number">2.0</span>;</span><br><span class="line">    uv.x *= iResolution.x / iResolution.y;</span><br><span class="line">    uv *= <span class="type">vec2</span>(<span class="number">2.0</span>, <span class="number">2.0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> d = sdBox(uv, <span class="type">vec2</span>(<span class="number">0.6</span>, <span class="number">0.3</span>));</span><br><span class="line">    <span class="type">float</span> c = <span class="built_in">smoothstep</span>(<span class="number">0.0</span>, <span class="number">0.02</span>, d);</span><br><span class="line">    fragColor = <span class="type">vec4</span>(<span class="type">vec3</span>(c), <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><iframe width="100%" height="400" src="//jsfiddle.net/HDL52/3o56r9kp/1/embedded/result/dark/" frameborder="0" loading="lazy" allowtransparency="true" allowfullscreen></iframe><ul><li>果不其然，图形并非扩大，而是缩小了相应的倍数</li><li>当坐标范围从<code>[-1.0, 1.0]</code>扩大到<code>[-2.0, 2.0]</code>时，矩形的顶点坐标虽然变大了（例如从<code>0.6</code>变成<code>1.2</code>），但由于画布的整体范围也变大了，矩形在整个画布中的相对比例缩小了。因此，矩形看起来变小了。简单来说，矩形的“绝对大小”没有改变，但它在画布中的“相对大小”变小了</li><li>同样地，如果要符合正方向的缩放（扩大），把之前的乘法操作改成与其相反的除法操作即可</li></ul><h5 id="翻转"><a href="#翻转" class="headerlink" title="翻转"></a><p style="font-size:14px">翻转</p></h5><hr><h3 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h3><blockquote></blockquote></article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/WebGL/">WebGL</a></div><div class="post_share"></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/558bc4fb.html" title="GO 学习笔记"><img class="cover" src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/imgbqwt4ir73bffcbd68bcq4c0turzstua.jpg" onerror='onerror=null,src="https://cdn.jsdelivr.net/gh/Hongda-OSU/PicGo/image/404.GIF"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">GO 学习笔记</div></div></a></div><div class="next-post pull-right"><a href="/posts/7c522c36.html" title="切图仔 2"><img class="cover" src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/imgbmcrg53uzso0a5lk4rcm76njiw0mw0m.jpg" onerror='onerror=null,src="https://cdn.jsdelivr.net/gh/Hongda-OSU/PicGo/image/404.GIF"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">切图仔 2</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://cdn.jsdelivr.net/gh/Hongda-OSU/PicGo/image/德狗子.GIF" onerror='this.onerror=null,this.src="https://cdn.jsdelivr.net/gh/Hongda-OSU/PicGo/image/404.GIF"' alt="avatar"></div><div class="author-info__name">鴻達</div><div class="author-info__description">记录 我的 生活</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">23</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">13</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Hongda-OSU" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="https://www.linkedin.com/in/hongda-lin" target="_blank" title="Linkedin"><i class="fab fa-linkedin"></i></a><a class="social-icon" href="https://hongdalin.me" target="_blank" title="Portfolio"><i class="iconfont icon-guanfangwangzhan"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">文章右下角小工具进入阅读模式</div></div><div class="xpand" style="height:200px"><canvas class="illo" width="800" height="800" style="max-width:200px;max-height:200px;touch-action:none;width:640px;height:640px"></canvas></div><script src="https://npm.elemecdn.com/ethan4116-blog/lib/js/other/two-people/twopeople1.js"></script><script src="https://npm.elemecdn.com/ethan4116-blog/lib/js/other/two-people/zdog.dist.js"></script><script id="rendered-js" src="https://npm.elemecdn.com/ethan4116-blog/lib/js/other/two-people/twopeople.js"></script><style>.card-widget.card-announcement{margin:0;align-items:center;justify-content:center;text-align:center}canvas{display:block;margin:0 auto;cursor:move}</style><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-text">前言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-text">基础知识</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFShader"><span class="toc-text">什么是Shader</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Shader%E5%92%8C%E5%85%B6%E4%BB%96%E6%8A%80%E6%9C%AF"><span class="toc-text">Shader和其他技术</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Shader%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-text">Shader基础知识</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Shader%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E9%80%89%E6%8B%A9"><span class="toc-text">Shader编程语言选择</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#WebGL%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E6%B5%81%E7%A8%8B"><span class="toc-text">WebGL渲染管线流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Shader%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83"><span class="toc-text">Shader开发环境</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E7%AC%AC%E4%B8%80%E4%B8%AAShader"><span class="toc-text">实现第一个Shader</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GLSL%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-text">GLSL基础知识</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%98%E9%87%8F"><span class="toc-text">变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E6%B5%81"><span class="toc-text">控制流</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E9%99%90%E5%AE%9A%E7%AC%A6"><span class="toc-text">变量限定符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%8F%E5%AE%9A%E4%B9%89"><span class="toc-text">宏定义</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#UV%E5%9F%BA%E7%A1%80%E4%B8%8E%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5"><span class="toc-text">UV基础与核心概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#UV%E5%9D%90%E6%A0%87"><span class="toc-text">UV坐标</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#UV%E5%9D%90%E6%A0%87%E7%9A%84%E5%88%86%E5%B8%83%E7%89%B9%E6%80%A7"><span class="toc-text">UV坐标的分布特性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6-%E5%9C%86%E5%BD%A2"><span class="toc-text">图形绘制 (圆形)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%BE%E5%BD%A2%E6%95%88%E6%9E%9C"><span class="toc-text">图形效果</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A8%A1%E7%B3%8A%E6%95%88%E6%9E%9C"><span class="toc-text">模糊效果</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%91%E5%85%89%E6%95%88%E6%9E%9C"><span class="toc-text">发光效果</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SDF%E5%87%BD%E6%95%B0"><span class="toc-text">SDF函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#UV%E5%8F%98%E6%8D%A2"><span class="toc-text">UV变换</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B9%B3%E7%A7%BB"><span class="toc-text">平移</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BC%A9%E6%94%BE"><span class="toc-text">缩放</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BF%BB%E8%BD%AC"><span class="toc-text">翻转</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%99%84%E5%BD%95"><span class="toc-text">附录</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/7c522c36.html" title="切图仔 2"><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/imgbmcrg53uzso0a5lk4rcm76njiw0mw0m.jpg" onerror='this.onerror=null,this.src="https://cdn.jsdelivr.net/gh/Hongda-OSU/PicGo/image/404.GIF"' alt="切图仔 2"></a><div class="content"><a class="title" href="/posts/7c522c36.html" title="切图仔 2">切图仔 2</a><time datetime="2024-12-23T18:03:05.000Z" title="发表于 2024-12-23 12:03:05">2024-12-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/d58818f0.html" title="WebGL 学习笔记"><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/imgdip29s0ui3xcpinvtb8pelnc00xb05s.jpg" onerror='this.onerror=null,this.src="https://cdn.jsdelivr.net/gh/Hongda-OSU/PicGo/image/404.GIF"' alt="WebGL 学习笔记"></a><div class="content"><a class="title" href="/posts/d58818f0.html" title="WebGL 学习笔记">WebGL 学习笔记</a><time datetime="2024-12-08T16:15:05.000Z" title="发表于 2024-12-08 10:15:05">2024-12-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/558bc4fb.html" title="GO 学习笔记"><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/imgbqwt4ir73bffcbd68bcq4c0turzstua.jpg" onerror='this.onerror=null,this.src="https://cdn.jsdelivr.net/gh/Hongda-OSU/PicGo/image/404.GIF"' alt="GO 学习笔记"></a><div class="content"><a class="title" href="/posts/558bc4fb.html" title="GO 学习笔记">GO 学习笔记</a><time datetime="2024-11-23T16:15:05.000Z" title="发表于 2024-11-23 10:15:05">2024-11-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/13fe9182.html" title="原型链解析"><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/imgl5zrba8rs677k0siqvc37eh5l0hdzqu.jpg" onerror='this.onerror=null,this.src="https://cdn.jsdelivr.net/gh/Hongda-OSU/PicGo/image/404.GIF"' alt="原型链解析"></a><div class="content"><a class="title" href="/posts/13fe9182.html" title="原型链解析">原型链解析</a><time datetime="2024-11-14T16:15:05.000Z" title="发表于 2024-11-14 10:15:05">2024-11-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/29dadae9.html" title="PostgreSQL 学习笔记"><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/imgied0v0dgsgyqeoh7804b0ca54buj0qd.jpg" onerror='this.onerror=null,this.src="https://cdn.jsdelivr.net/gh/Hongda-OSU/PicGo/image/404.GIF"' alt="PostgreSQL 学习笔记"></a><div class="content"><a class="title" href="/posts/29dadae9.html" title="PostgreSQL 学习笔记">PostgreSQL 学习笔记</a><time datetime="2024-08-02T15:15:06.000Z" title="发表于 2024-08-02 10:15:06">2024-08-02</time></div></div></div></div></div></div></main><footer id="footer" style="background:rgba(0,0,0,.25)"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2025 &nbsp;<i id="heartbeat" class="fa fas fa-heartbeat"></i> &nbsp;鴻達</div><div class="footer_custom_text"><p class="badge"><a style="margin-inline:5px" target="_blank" href="https://hexo.io/"><img src="https://img.shields.io/badge/Frame-Hexo-informational?style=flat&logo=hexo"></a><a style="margin-inline:5px" target="_blank" href="https://domains.google/"><img src="https://img.shields.io/badge/Hosted-Google-ff69b4?style=flat&logo=googledomains"></a><a style="margin-inline:5px" target="_blank" href="https://gulpjs.com/"><img src="https://img.shields.io/badge/Compress-gulp-critical?style=flat&logo=gulp"></a><a style="margin-inline:5px" target="_blank" href="https://www.jsdelivr.com/"><img src="https://img.shields.io/badge/CDN-jsDelivr-orange?style=flat&logo=jsDelivr"></a><a style="margin-inline:5px" target="_blank" href="https://github.com/"><img src="https://img.shields.io/badge/Source-Github-black?style=flat&logo=GitHub"></a><a style="margin-inline:5px" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&logo=Claris"></a></p></div></div><link rel="stylesheet" href="https://fastly.jsdelivr.net/gh/HCLonely/images@master/others/heartbeat.min.css"></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i> <span>数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script>function panguFn(){"object"==typeof pangu?pangu.autoSpacingPage():getScript("https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js").then((()=>{pangu.autoSpacingPage()}))}function panguInit(){GLOBAL_CONFIG_SITE.isPost&&panguFn()}document.addEventListener("DOMContentLoaded",panguInit)</script><script src="/js/search/local-search.js"></script><div class="js-pjax"></div><script defer src="/js/util.js"></script><script defer src="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js"></script><script disable-devtool-auto src="https://cdn.jsdelivr.net/npm/disable-devtool"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors=["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"];var pjax=new Pjax({elements:'a:not([target="_blank"])',selectors:pjaxSelectors,cacheBust:!1,analytics:!1,scrollRestoration:!1});document.addEventListener("pjax:send",(function(){if(window.tocScrollFn&&window.removeEventListener("scroll",window.tocScrollFn),window.scrollCollect&&window.removeEventListener("scroll",scrollCollect),document.getElementById("rightside").style.cssText="opacity: ''; transform: ''",window.aplayers)for(let e=0;e<window.aplayers.length;e++)window.aplayers[e].options.fixed||window.aplayers[e].destroy();"object"==typeof typed&&typed.destroy();const e=document.body.classList;e.contains("read-mode")&&e.remove("read-mode"),"object"==typeof disqusjs&&disqusjs.destroy()})),document.addEventListener("pjax:complete",(function(){window.refreshFn(),document.querySelectorAll("script[data-pjax]").forEach((e=>{const t=document.createElement("script"),o=e.text||e.textContent||e.innerHTML||"";Array.from(e.attributes).forEach((e=>t.setAttribute(e.name,e.value))),t.appendChild(document.createTextNode(o)),e.parentNode.replaceChild(t,e)})),GLOBAL_CONFIG.islazyload&&window.lazyLoadInstance.update(),"function"==typeof chatBtnFn&&chatBtnFn(),"function"==typeof panguInit&&panguInit(),"function"==typeof gtag&&gtag("config","",{page_path:window.location.pathname}),"object"==typeof _hmt&&_hmt.push(["_trackPageview",window.location.pathname]),"function"==typeof loadMeting&&document.getElementsByClassName("aplayer").length&&loadMeting(),"object"==typeof Prism&&Prism.highlightAll()})),document.addEventListener("pjax:error",(e=>{404===e.request.status&&pjax.loadUrl("/404.html")}))</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>