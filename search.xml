<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Web 拦截</title>
      <link href="/posts/c888933a.html"/>
      <url>/posts/c888933a.html</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3>]]></content>
      
      
      
        <tags>
            
            <tag> Web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AWS MLA-C01</title>
      <link href="/posts/50096d59.html"/>
      <url>/posts/50096d59.html</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>官网: <a href="https://aws.amazon.com/certification/certified-ai-practitioner/">https://aws.amazon.com/certification/certified-ai-practitioner/</a></p><hr><h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><h3 id="1-Intro-to-AWS"><a href="#1-Intro-to-AWS" class="headerlink" title="1. Intro to AWS"></a>1. Intro to AWS</h3><h4 id="Cloud-Computing"><a href="#Cloud-Computing" class="headerlink" title="Cloud Computing"></a>Cloud Computing</h4><ul><li>Cloud computing 是按需提供计算能力、数据库存储、应用程序和其他 IT 资源，通过云服务平台以 pay-as-you-go 定价模式，你可以获取所需的精确类型和大小的计算资源。</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img22147.png"></p><p><strong>Deployment Models</strong></p><ul><li><strong>Private Cloud:</strong> 单个组织使用的云服务，不对外公开</li><li><strong>Public Cloud:</strong> 由第三方云服务商拥有和运营，通过互联网提供</li><li><strong>Hybrid Cloud:</strong> 部分服务器保留在本地，部分能力扩展到云端</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img24237.png"></p><p><strong>Types of Cloud Computing</strong></p><ul><li><strong>IaaS (Infrastructure as a Service):</strong> 提供基础设施</li><li><strong>PaaS (Platform as a Service):</strong> 提供平台</li><li><strong>SaaS (Software as a Service):</strong> 提供软件</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img24409.png"></p><hr><h4 id="AWS-Regions"><a href="#AWS-Regions" class="headerlink" title="AWS Regions"></a>AWS Regions</h4><ul><li>AWS 在全球都有 Region，大多数 AWS 服务都是 region-scoped。</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img24853.png"></p><p><strong>Availability Zones</strong></p><ul><li>每个 Region 有多个 Availability Zone（通常 3 个，最少 3 个，最多 6 个）。每个 AZ 是一个或多个独立的数据中心，有冗余的电源、网络和连接。</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img25649.png"></p><p><strong>Points of Presence</strong></p><ul><li>Amazon 在 40+ 个国家、90+ 个城市有 400+ 个 Points of Presence（400+ Edge Locations 和 10+ Regional Caches），用于以更低延迟向用户交付内容。</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img25752.png"></p><hr><h3 id="2-AWS-GEN-AI"><a href="#2-AWS-GEN-AI" class="headerlink" title="2. AWS GEN AI"></a>2. AWS GEN AI</h3><h4 id="Intro-to-GEN-AI"><a href="#Intro-to-GEN-AI" class="headerlink" title="Intro to GEN AI"></a>Intro to GEN AI</h4><ul><li>Generative AI (Gen-AI) 是 Deep Learning 的一个子集，用于生成与训练数据相似的新数据。</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img1130343.png"></p><p><strong>Foundation Model</strong></p><ul><li>Foundation Model 是在大量多样化输入数据上训练的模型。</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img1130904.png"></p><p><strong>Large Language Models (LLM)</strong></p><ul><li>LLM 是一种 AI，用于生成连贯的、类人的文本。</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img1130905.png"></p><p><strong>Generative Language Models</strong></p><ul><li>我们通常通过给 LLM 一个 prompt 来交互，模型会利用它学到的所有内容来生成新内容。</li><li>值得注意的是，LLM 是 non-deterministic 的: 即使使用相同的 prompt，每次生成的文本也可能不同。</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img1130906.png"></p><hr><h4 id="AWS-Bedrock"><a href="#AWS-Bedrock" class="headerlink" title="AWS Bedrock"></a>AWS Bedrock</h4><p>AWS Bedrock 是一个用于构建 Generative AI 应用的服务</p><ul><li>Fully-managed service，无需管理服务器</li><li>Pay-per-use 定价模式</li><li>可以控制用于训练模型的数据</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img1130954.png"><br><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img1130955.png"></p><hr><h4 id="Bedrock-Fundamental-Model"><a href="#Bedrock-Fundamental-Model" class="headerlink" title="Bedrock - Fundamental Model"></a>Bedrock - Fundamental Model</h4><p><strong>How to choose</strong></p><ul><li>Model types, performance requirements, capabilities, constraints, compliance</li><li>Level of customization, model size, inference options, licensing agreements, context windows, latency</li><li>Multimodal models（支持多种类型的输入和输出）</li></ul><p><strong>Amazon Titan</strong></p><ul><li>AWS 提供的高性能 Foundation Model</li><li>通过全托管 API 提供 image、text、multimodal 等模型选择</li><li>Smaller models 更 cost-effective</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img11301041.png"></p><hr><h4 id="Bedrock-Fine-Tuning-a-Model"><a href="#Bedrock-Fine-Tuning-a-Model" class="headerlink" title="Bedrock - Fine Tuning a Model"></a>Bedrock - Fine Tuning a Model</h4><ul><li>用你自己的数据对 foundation model 的副本进行调整</li><li>Fine-tuning 会改变 base foundation model 的 weights</li><li>必须使用 “Provisioned Throughput” 才能使用 fine-tuned model</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img11301119.png"></p><p><strong>Instruction-based Fine Tuning</strong></p><ul><li>提升 pre-trained FM 在特定领域任务上的表现</li><li>使用 labeled examples（prompt-response pairs）</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img11301120.png"></p><p><strong>Continued Pre-training</strong></p><ul><li>提供 unlabeled data 继续训练 FM</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img11301121.png"></p><p><strong>Single-Turn Messaging</strong></p><ul><li>Instruction-based fine-tuning 的一部分</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img11301122.png"></p><p><strong>Multi-Turn Messaging</strong></p><ul><li>为对话场景提供 instruction-based fine tuning（相对于 Single-Turn Messaging）</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img11301123.png"></p><p><strong>Transfer Learning</strong></p><ul><li>重用 pre-trained model 并将其适配到新的相关任务的更广泛概念</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img11301124.png"></p><hr><h4 id="Bedrock-FM-Evaluation"><a href="#Bedrock-FM-Evaluation" class="headerlink" title="Bedrock - FM Evaluation"></a>Bedrock - FM Evaluation</h4><p><strong>Automatic Evaluation</strong></p><ul><li>用于模型的质量控制</li><li>一些 benchmark datasets 可以快速检测 bias 和潜在的歧视问题</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img1201800.png"></p><p><strong>Human Evaluation</strong></p><ul><li>选择一个 work team 进行评估</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img1201801.png"></p><p><strong>Automated Metrics to Evaluate an FM</strong></p><ul><li>ROUGE: Recall-Oriented Understudy for Gisting Evaluation</li><li>BLEU: Bilingual Evaluation Understudy</li><li>BERTScore: 生成文本之间的语义相似度</li><li>Perplexity: 模型预测下一个 token 的能力（越低越好）</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img1201803.png"></p><hr><h4 id="Bedrock-RAG-amp-Knowledge-Base"><a href="#Bedrock-RAG-amp-Knowledge-Base" class="headerlink" title="Bedrock - RAG &amp; Knowledge Base"></a>Bedrock - RAG &amp; Knowledge Base</h4><p><strong>RAG (Retrieval-Augmented Generation)</strong></p><ul><li>让 Foundation Model 可以引用训练数据之外的数据源</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img1201815.png"></p><p><strong>RAG Vector Databases by AWS</strong></p><ul><li>Amazon OpenSearch Service (Serverless &amp; Managed Cluster): search &amp; analytics database，支持 real time similarity queries，存储数百万 vector embeddings，scalable index management，fast nearest-neighbor (kNN) search</li><li>Amazon Aurora PostgreSQL: AWS 上的关系型数据库</li><li>Amazon Neptune Analytics: graph database，支持高性能 graph analytics 和 graph-based RAG (GraphRAG)</li><li>Amazon S3 Vectors: cost-effective 和 durable storage，sub-second query performance</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img1201817.png"></p><p><strong>RAG Data Sources</strong></p><ul><li>Amazon S3, Confluence, Microsoft SharePoint 等等</li></ul><p><strong>RAG Use Cases</strong></p><ul><li>Customer Service Chatbot: 产品、功能、规格、故障排除指南、FAQ</li><li>Legal Research and Analysis: 法律、法规、案例、法律意见、专家分析</li><li>Healthcare Question-Answering: 疾病、治疗、临床指南、研究论文、患者信息</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img1201819.png"></p><hr><h4 id="GenAI-Concepts"><a href="#GenAI-Concepts" class="headerlink" title="GenAI Concepts"></a>GenAI Concepts</h4><p><strong>Tokenization</strong></p><ul><li>将 raw text 转换成 token 序列</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img1201837.png"></p><p><strong>Context Window</strong></p><ul><li>LLM 在生成文本时能考虑的 token 数量</li><li>选择模型时首先要看的因素</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img1201839.png"></p><p><strong>Embeddings</strong></p><ul><li>将 text、images 或 audio 转换成 vectors（数值数组）</li><li>Embedding models 可以支持搜索应用</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img12011022.png"></p><hr><h4 id="Bedrock-Guardrails"><a href="#Bedrock-Guardrails" class="headerlink" title="Bedrock - Guardrails"></a>Bedrock - Guardrails</h4><ul><li>控制用户与 Foundation Models (FMs) 之间的交互</li><li>过滤不良和有害内容</li><li>移除 Personally Identifiable Information (PII)</li><li>可以创建多个 Guardrails，监控和分析违反 Guardrails 的用户输入</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img12011039.png"></p><hr><h4 id="AWS-Bedrock-Agents"><a href="#AWS-Bedrock-Agents" class="headerlink" title="AWS Bedrock - Agents"></a>AWS Bedrock - Agents</h4><ul><li>管理和执行与基础设施配置、应用部署和运维相关的多步骤任务</li><li>Agents 被配置为执行特定的预定义 action groups</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img12021213.png"><br><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img12021214.png"></p><hr><h4 id="Bedrock-CloudWatch-Integration"><a href="#Bedrock-CloudWatch-Integration" class="headerlink" title="Bedrock - CloudWatch Integration"></a>Bedrock - CloudWatch Integration</h4><ul><li>Model Invocation Logging: 将所有调用日志发送到 Amazon CloudWatch 和 S3</li><li>CloudWatch Metrics: 将 Bedrock 的 metrics 发布到 CloudWatch</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img12021215.png"></p><hr><h4 id="Bedrock-Pricing"><a href="#Bedrock-Pricing" class="headerlink" title="Bedrock - Pricing"></a>Bedrock - Pricing</h4><ul><li><p><strong>On-Demand</strong></p><ul><li>Pay-as-you-go，无需承诺</li><li>Text Models: 按处理的 input&#x2F;output token 收费</li><li>Embedding Models: 按处理的 input token 收费</li><li>Image Models: 按生成的图片收费</li><li>只支持 Base Models</li></ul></li><li><p><strong>Batch</strong></p><ul><li>一次多个 predictions，输出为 S3 中的单个文件</li><li>最高可享 50% 折扣</li></ul></li><li><p><strong>Provisioned Throughput</strong></p><ul><li>购买一定时间的 Model units（1 个月、6 个月…）</li><li>Throughput: 每分钟处理的最大 input&#x2F;output tokens</li><li>支持 Base、Fine-tuned 和 Custom Models</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img12021219.png"></p><p><strong>Model Improvement Techniques Cost Order</strong></p><p>从便宜到贵</p><ol><li><strong>Prompt Engineering ($)</strong> - 无需 model training，无额外计算或 fine-tuning</li><li><strong>RAG ($$)</strong> - 使用外部知识，FM 不需要”知道一切”，无需修改 FM</li><li><strong>Instruction-based Fine-tuning ($$$)</strong> - 用特定指令 fine-tune FM，需要额外计算</li><li><strong>Domain Adaptation Fine-tuning ($$$$)</strong> - 在特定领域数据集上训练，需要大量计算</li></ol><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img12021222.png"></p><p><strong>Bedrock - Cost Savings</strong></p><ul><li>On-Demand: 适合不可预测的 workloads，无长期承诺</li><li>Batch: 最高 50% 折扣</li><li>Provisioned Throughput: 通常不是省钱的方式，适合 “reserve” capacity</li><li>Temperature, Top K, Top P: 对定价无影响</li><li>Model size: 通常 smaller model 更便宜（因 provider 而异）</li><li>Number of Input and Output Tokens: 成本的主要驱动因素</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img12021224.png"></p><hr><h3 id="3-Prompt-Engineering"><a href="#3-Prompt-Engineering" class="headerlink" title="3. Prompt Engineering"></a>3. Prompt Engineering</h3><h4 id="What-is-Prompt-Engineering"><a href="#What-is-Prompt-Engineering" class="headerlink" title="What is Prompt Engineering"></a>What is Prompt Engineering</h4><p>Prompt Engineering 是开发、设计和优化 prompts，以增强 FMs 输出以满足你的需求。</p><p><strong>Improved Prompting 包含:</strong></p><ul><li>Instructions: 给模型的任务（描述、模型应该如何执行）</li><li>Context: 引导模型的外部信息</li><li>Input data: 你需要响应的输入</li><li>Output Indicator: 输出类型或格式</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img1202616.png"><br><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img1202617.png"></p><p><strong>Negative Prompting</strong></p><p>明确告诉模型在响应中不要包含或做什么的技术。</p><ul><li>Avoid Unwanted Content: 明确说明不要包含什么，减少不相关或不当内容</li><li>Maintain Focus: 帮助模型保持主题，不偏离到无用的领域</li><li>Enhance Clarity: 防止使用复杂术语或详细数据，使输出更清晰易懂</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img1202618.png"></p><hr><h4 id="Prompt-Performance-Optimization"><a href="#Prompt-Performance-Optimization" class="headerlink" title="Prompt Performance Optimization"></a>Prompt Performance Optimization</h4><ul><li>System Prompts: 定义模型应该如何行为和回复</li><li>Temperature (0 to 1): 控制创造性，低值更保守，高值更有创意</li><li>Top P (0 to 1): 低值响应更连贯，高值更多样</li><li>Top K: 限制可能词的数量，低值更连贯，高值更多样</li><li>Length: 答案的最大长度</li><li>Stop Sequences: 信号模型停止生成输出的 tokens</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img1202621.png"></p><ul><li>Prompt Latency: 模型响应的速度，不受 Top P、Top K、Temperature 影响</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img1202623.png"></p><hr><h4 id="Prompt-Engineering-Techniques"><a href="#Prompt-Engineering-Techniques" class="headerlink" title="Prompt Engineering Techniques"></a>Prompt Engineering Techniques</h4><p><strong>Zero-Shot Prompting</strong></p><ul><li>不提供示例，完全依赖模型的通用知识</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img1202625.png"></p><p><strong>Few-Shots Prompting</strong></p><ul><li>提供示例来引导模型输出</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img1202626.png"></p><p><strong>Chain of Thought Prompting</strong></p><ul><li>将任务分解为一系列推理步骤，使输出更有结构和连贯性</li><li>使用 “Think step by step” 这类句子有帮助</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img1202627.png"></p><p><strong>Retrieval-Augmented Generation (RAG)</strong> (这不算在 Technique 里)</p><ul><li>结合模型能力与外部数据源，生成更有信息量和上下文的响应</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img1202628.png"></p><hr><h4 id="Prompt-Templates"><a href="#Prompt-Templates" class="headerlink" title="Prompt Templates"></a>Prompt Templates</h4><ul><li>简化和标准化生成 Prompts 的过程</li><li>可与 Bedrock Agents 一起使用</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img1202630.png"></p><p><strong>Prompt Template Injections</strong></p><ul><li>用户可能尝试输入恶意内容来劫持 prompt，获取禁止或有害话题的信息</li><li>防护方法: 添加明确指令，忽略任何不相关或潜在恶意内容</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img1202631.png"></p><hr><h3 id="4-AWS-Q"><a href="#4-AWS-Q" class="headerlink" title="4. AWS Q"></a>4. AWS Q</h3><h4 id="AWS-Q-Business"><a href="#AWS-Q-Business" class="headerlink" title="AWS Q Business"></a>AWS Q Business</h4><ul><li>为员工打造的全托管 Gen-AI 助手</li><li>基于公司的知识和数据</li><li>构建在 Amazon Bedrock 上（但不能选择底层 FM）</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img12021004.png"></p><p><strong>Data Connectors (fully managed RAG)</strong></p><ul><li>连接 40+ 企业数据源：Amazon S3, RDS, Aurora, WorkDocs, Microsoft 365, Salesforce, GDrive, Gmail, Slack, Sharepoint…</li><li>Plugins：与第三方服务交互，如 Jira, ServiceNow, Zendesk, Salesforce</li><li>Custom Plugins：通过 API 连接任何第三方应用</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img12021018.png"></p><p><strong>IAM Identity Center</strong></p><ul><li>用户通过 IAM Identity Center 认证</li><li>可配置外部 Identity Providers</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img12021019.png"></p><p><strong>Admin Controls</strong></p><ul><li>控制和自定义响应以满足组织需求</li><li>Admin controls &#x3D;&#x3D; Guardrails</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img12021020.png"></p><hr><h4 id="AWS-Q-App"><a href="#AWS-Q-App" class="headerlink" title="AWS Q App"></a>AWS Q App</h4><ul><li>用自然语言创建 Gen AI 应用，无需编码</li><li>利用公司内部数据</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img12031020.png"></p><hr><h4 id="AWS-Q-Developer"><a href="#AWS-Q-Developer" class="headerlink" title="AWS Q Developer"></a>AWS Q Developer</h4><ul><li>回答关于 AWS 文档和服务选择的问题</li><li>回答关于你 AWS 账户中资源的问题</li><li>AI 代码助手，帮助编写新应用（类似 GitHub Copilot）</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img12031022.png"></p><hr><h4 id="AWS-Q-AWS-Services"><a href="#AWS-Q-AWS-Services" class="headerlink" title="AWS Q + AWS Services"></a>AWS Q + AWS Services</h4><p><strong>Amazon Q for QuickSight</strong></p><ul><li>QuickSight 用于数据可视化和创建 dashboards</li><li>Amazon Q 理解自然语言，可以对数据提问</li><li>可创建数据的 executive summaries</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img12031036.png"></p><p><strong>Amazon Q for EC2</strong></p><ul><li>EC2 是 AWS 上的虚拟服务器</li><li>Amazon Q 为新 workload 提供最适合的 EC2 instance 类型建议</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img12031037.png"></p><p><strong>Amazon Q for AWS Chatbot</strong></p><ul><li>AWS Chatbot 可在 Slack 或 Microsoft Teams 中部署，了解你的 AWS 账户</li><li>通过 Amazon Q 加速理解 AWS 服务、排查问题、找到解决方案</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img12031038.png"></p><p><strong>Amazon Q for Glue</strong></p><ul><li>AWS Glue 是 ETL (Extract Transform and Load) 服务，用于数据迁移</li><li>Amazon Q 可以：回答 Glue 相关问题、提供文档链接、生成数据集成代码、排查 Glue job 错误</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img12031039.png"></p><hr><h3 id="5-AI-amp-ML"><a href="#5-AI-amp-ML" class="headerlink" title="5. AI &amp; ML"></a>5. AI &amp; ML</h3><h4 id="AI-ML-Deep-Learning-GenAI"><a href="#AI-ML-Deep-Learning-GenAI" class="headerlink" title="AI, ML, Deep Learning, GenAI"></a>AI, ML, Deep Learning, GenAI</h4><p><strong>What is Artificial Intelligence</strong></p><ul><li>AI 是一个广泛的领域，开发能够执行通常需要人类智能任务的智能系统</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img12031100.png"></p><p><strong>AI Components</strong></p><ul><li>Data Layer: 收集大量数据</li><li>ML Framework and Algorithm Layer: 数据科学家和工程师合作理解 use cases、需求和可解决问题的框架</li><li>Model Layer: 实现并训练模型，包括结构、参数、函数和优化器</li><li>Application Layer: 如何服务模型，向用户提供能力</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img12031106.png"></p><p><strong>What is Machine Learning (ML)</strong></p><ul><li>ML 是一种 AI，用于构建让机器学习的方法</li><li>利用数据提升计算机在特定任务上的表现</li><li>基于训练数据进行预测</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img12031107.png"></p><p><strong>What is Deep Learning (DL)</strong></p><ul><li>使用神经元和突触（类似大脑）来训练模型</li><li>处理比传统 ML 更复杂的数据模式</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img12031108.png"></p><p><strong>What is Generative AI (Gen-AI)</strong></p><ul><li>Deep Learning 的子集</li><li>由神经网络支持的多用途 foundation models</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img12031109.png"></p><p><strong>What is the Transformer Model (LLM)</strong></p><ul><li>能够整体处理句子而不是逐词处理</li><li>更快更高效的文本处理（更少训练时间）</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img12031110.png"></p><hr><h4 id="ML-Terms"><a href="#ML-Terms" class="headerlink" title="ML Terms"></a>ML Terms</h4><ul><li><strong>GPT (Generative Pre-trained Transformer):</strong> 根据输入 prompts 生成人类文本或代码</li><li><strong>BERT (Bidirectional Encoder Representations from Transformers):</strong> 类似 GPT，但双向读取文本</li><li><strong>RNN (Recurrent Neural Network):</strong> 用于序列数据如时间序列或文本，适用于语音识别、时间序列预测</li><li><strong>ResNet (Residual Network):</strong> 深度卷积神经网络 (CNN)，用于图像识别、目标检测、人脸识别</li><li><strong>SVM (Support Vector Machine):</strong> 用于分类和回归的 ML 算法</li><li><strong>WaveNet:</strong> 生成原始音频波形的模型，用于语音合成</li><li><strong>GAN (Generative Adversarial Network):</strong> 生成类似训练数据的合成图像、视频或声音，适用于数据增强</li><li><strong>XGBoost (Extreme Gradient Boosting):</strong> 梯度提升的一种实现</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img12031119.png"></p><hr><h4 id="Training-Data"><a href="#Training-Data" class="headerlink" title="Training Data"></a>Training Data</h4><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img12041042.png"></p><p><strong>Labeled vs. Unlabeled Data</strong></p><ul><li>Labeled Data: 包含输入特征和对应输出标签，用于 Supervised Learning</li><li>Unlabeled Data: 只有输入特征没有输出标签，用于 Unsupervised Learning</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img12041044.png"></p><p><strong>Structured Data</strong></p><ul><li>数据以结构化格式组织，通常是行和列</li><li>Tabular Data: 表格形式，行是记录，列是特征</li><li>Time Series Data: 按时间顺序收集的数据点</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img12041046.png"></p><p><strong>Unstructured Data</strong></p><ul><li>没有特定结构，通常是文本或多媒体内容</li><li>Text Data: 文章、社交媒体帖子、客户评论等</li><li>Image Data: 图像数据，格式和内容多样</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img12041049.png"></p><hr><h4 id="Supervised-Learning"><a href="#Supervised-Learning" class="headerlink" title="Supervised Learning"></a>Supervised Learning</h4><ul><li>学习一个映射函数，为新的未见输入数据预测输出</li><li>需要 labeled data：很强大，但在百万级数据上难以执行</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img1207402.png"></p><p><strong>Regression</strong></p><ul><li>根据输入数据预测数值</li><li>输出是连续的，可以是范围内的任何值</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img1207403.png"></p><p><strong>Classification</strong></p><ul><li>预测输入数据的类别标签</li><li>输出是离散的，落入特定类别</li><li>关键算法：K-nearest neighbors (k-NN)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img1207404.png"></p><p><strong>Training vs. Validation vs. Test Set</strong></p><ul><li>Training Set: 用于训练模型</li><li>Validation Set: 用于调整参数和验证性能</li><li>Test Set: 用于评估最终模型性能</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img1207405.png"></p><p><strong>Feature Engineering</strong></p><ul><li>使用领域知识将原始数据转换为有意义的特征</li><li>帮助提升 ML 模型性能</li><li>Structured Data 例子：根据面积、位置、房间数预测房价</li><li>Unstructured Data 例子：客户评论的情感分析</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img1207406.png"></p><hr><h4 id="Unsupervised-Learning"><a href="#Unsupervised-Learning" class="headerlink" title="Unsupervised Learning"></a>Unsupervised Learning</h4><ul><li>目标是发现数据中的内在模式、结构或关系</li><li>常用技术：Clustering、Association Rule Learning、Anomaly Detection</li><li>Feature Engineering 可以提升训练质量</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img1207411.png"></p><p><strong>Clustering</strong></p><ul><li>根据特征将相似数据点分组</li><li>例子：Customer Segmentation</li><li>结果：公司可以针对不同细分市场制定营销策略</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img1207412.png"></p><p><strong>Association Rule Learning</strong></p><ul><li>例子：Market Basket Analysis</li><li>结果：超市可以将关联商品放在一起提升销量</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img1207413.png"></p><p><strong>Anomaly Detection</strong></p><ul><li>例子：Fraud Detection</li><li>结果：系统标记可疑交易进行进一步调查</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img1207414.png"></p><p><strong>Semi-supervised Learning</strong></p><ul><li>用少量 labeled data 和大量 unlabeled data 训练系统</li><li>之后，部分训练的算法自动标注 unlabeled data</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img1207415.png"></p><hr><h4 id="Self-Supervised-Learning"><a href="#Self-Supervised-Learning" class="headerlink" title="Self-Supervised Learning"></a>Self-Supervised Learning</h4><ul><li>模型为自己的数据生成 pseudo-labels，无需人工标注</li><li>然后用 pseudo labels 解决传统 Supervised Learning 的问题</li><li>广泛用于 NLP（如 BERT、GPT）和图像识别任务</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img1207434.png"></p><hr><h4 id="Reinforcement-Learning"><a href="#Reinforcement-Learning" class="headerlink" title="Reinforcement Learning"></a>Reinforcement Learning</h4><ul><li>一种 ML，agent 通过在环境中执行动作来学习决策，目标是最大化累积奖励</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img1207438.png"></p><hr><h4 id="RLHF"><a href="#RLHF" class="headerlink" title="RLHF"></a>RLHF</h4><ul><li>RLHF &#x3D; Reinforcement Learning from Human Feedback</li><li>使用人类反馈帮助 ML 模型更高效地自我学习</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img1207440.png"><br><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img1207442.png"></p><hr><h4 id="Model-Fit-Bias-and-Variance"><a href="#Model-Fit-Bias-and-Variance" class="headerlink" title="Model Fit, Bias and Variance"></a>Model Fit, Bias and Variance</h4><p><strong>Model Fit</strong></p><ul><li>Overfitting: 训练数据表现好，评估数据表现差</li><li>Underfitting: 训练数据表现差，可能模型太简单或特征不好</li><li>Balanced: 既不 overfitting 也不 underfitting</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img1207503.png"></p><p><strong>Bias</strong></p><ul><li>预测值与实际值的差异或误差，由 ML 过程中的错误选择导致</li><li>High Bias: 模型不能很好匹配训练数据，属于 underfitting</li><li>减少 Bias: 使用更复杂的模型，增加特征数量</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img1207505.png"></p><p><strong>Variance</strong></p><ul><li>模型在不同但分布相似的数据集上训练时性能变化的程度</li><li>High Variance: 模型对训练数据变化很敏感，属于 overfitting</li><li>减少 Variance: 特征选择（更少但更重要的特征），多次划分训练和测试数据集</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img1207506.png"></p><hr><h4 id="Model-Evaluation-Metrics"><a href="#Model-Evaluation-Metrics" class="headerlink" title="Model Evaluation Metrics"></a>Model Evaluation Metrics</h4><p><strong>Confusion Matrix</strong></p><ul><li>用于分类模型的评估矩阵</li><li>True Positive (TP): 预测为正，实际为正</li><li>True Negative (TN): 预测为负，实际为负</li><li>False Positive (FP): 预测为正，实际为负（误报）</li><li>False Negative (FN): 预测为负，实际为正（漏报）</li><li>Accuracy &#x3D; (TP + TN) &#x2F; Total</li><li>Precision &#x3D; TP &#x2F; (TP + FP)</li><li>Recall &#x3D; TP &#x2F; (TP + FN)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img1208754.png"></p><p><strong>Regression Metrics</strong></p><ul><li>MAE (Mean Absolute Error): 预测值与实际值差的绝对值平均</li><li>MSE (Mean Squared Error): 预测值与实际值差的平方平均</li><li>RMSE (Root Mean Squared Error): MSE 的平方根</li><li>R² (R-Squared): 模型解释数据变异的程度，越接近 1 越好</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img1208755.png"></p><hr><h4 id="Machine-Learning-–-Inferencing"><a href="#Machine-Learning-–-Inferencing" class="headerlink" title="Machine Learning – Inferencing"></a>Machine Learning – Inferencing</h4><ul><li>Inferencing 是模型对新数据进行预测</li><li>Real Time: 数据到达时快速做出决策</li><li>Batch: 一次性分析大量数据</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img1208759.png"></p><p><strong>Inferencing at the Edge</strong></p><ul><li>Edge devices 是计算能力较弱、靠近数据源、网络连接可能有限的设备</li><li>Small Language Model (SLM) 部署在 edge device</li><li>Large Language Model (LLM) 部署在远程服务器</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img1208800.png"></p><hr><h4 id="Phases-of-Machine-Learning-Project"><a href="#Phases-of-Machine-Learning-Project" class="headerlink" title="Phases of Machine Learning Project"></a>Phases of Machine Learning Project</h4><ul><li><strong>Define Business Goals:</strong> 定义价值、预算、成功标准和 KPI</li><li><strong>ML Problem Framing:</strong> 将业务问题转换为 ML 问题，判断 ML 是否合适</li><li><strong>Data Processing:</strong> 数据收集、预处理、可视化、feature engineering</li><li><strong>Exploratory Data Analysis:</strong> 用图表和 Correlation Matrix 分析数据</li><li><strong>Model Development:</strong> 模型训练、调参、评估（迭代过程）</li><li><strong>Deployment:</strong> 选择部署模式（real-time、batch、serverless 等）</li><li><strong>Monitoring:</strong> 监控性能、debug 问题</li><li><strong>Iterations:</strong> 持续改进模型</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img1208805.png"></p><hr><h4 id="Hyperparameter"><a href="#Hyperparameter" class="headerlink" title="Hyperparameter"></a>Hyperparameter</h4><ul><li>Hyperparameter: 定义模型结构和学习算法的设置</li><li>Hyperparameter tuning: 找到最佳参数值以优化模型性能，提高准确性、减少 overfitting、增强泛化能力</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img1208807.png"></p><p><strong>Important Hyperparameters</strong></p><ul><li>Learning rate, Batch size, Number of Epochs, Regularization</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img1208808.png"></p><p><strong>Overfitting</strong></p><ul><li>模型在训练数据上表现好，但在新数据上表现差</li><li>原因: 训练数据太少、训练太久、模型太复杂从 noise 中学习</li><li>防止: 增加训练数据量、Early stopping、Data augmentation、调整 hyperparameters</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img1208811.png"></p><hr><h3 id="6-AWS-Managed-AI-Services"><a href="#6-AWS-Managed-AI-Services" class="headerlink" title="6. AWS Managed AI Services"></a>6. AWS Managed AI Services</h3><h4 id="AWS-Comprehend"><a href="#AWS-Comprehend" class="headerlink" title="AWS Comprehend"></a>AWS Comprehend</h4><ul><li>用于 Natural Language Processing (NLP)</li><li>使用 ML 从文本中发现洞察和关系</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img12081110.png"></p><p><strong>Custom Classification</strong></p><ul><li>将文档组织到你定义的类别中</li><li>Real-time Analysis: 单个文档，同步</li><li>Async Analysis: 多个文档（batch），异步</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img12081111.png"></p><p><strong>Named Entity Recognition (NER)</strong></p><ul><li>从文本中提取预定义的通用实体，如人物、地点、组织、日期等</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img12081111.png"></p><p><strong>Custom Entity Recognition</strong></p><ul><li>分析文本中的特定术语和名词短语</li><li>提取如保单号或客户投诉相关短语等业务特定内容</li><li>用自定义数据训练模型</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img12081113.png"></p><hr><h4 id="AWS-Translate"><a href="#AWS-Translate" class="headerlink" title="AWS Translate"></a>AWS Translate</h4><ul><li>自然准确的语言翻译</li><li>用于本地化网站和应用内容，高效翻译大量文本</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img12081117.png"></p><hr><h4 id="AWS-Transcribe"><a href="#AWS-Transcribe" class="headerlink" title="AWS Transcribe"></a>AWS Transcribe</h4><ul><li>自动将语音转换为文本</li><li>通过 Redaction 自动移除 PII（个人身份信息）</li><li>支持多语言音频的自动语言识别</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img1209927.png"></p><p><strong>Toxicity Detection</strong></p><ul><li>基于 ML 的语音毒性检测能力</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img1209935.png"></p><p><strong>Improving Accuracy</strong></p><ul><li>允许 Transcribe 捕获领域特定或非标准术语</li><li>Custom Vocabularies: 添加特定词汇、短语、领域术语</li><li>Custom Language Models: 用自己的领域文本数据训练模型</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img1209936.png"></p><hr><h4 id="AWS-Polly"><a href="#AWS-Polly" class="headerlink" title="AWS Polly"></a>AWS Polly</h4><ul><li>使用 deep learning 将文本转换为逼真的语音</li><li>创建会说话的应用</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img1209937.png"></p><p><strong>Advanced Features</strong></p><ul><li>Lexicons: 定义如何朗读特定文本</li><li>SSML: 标记文本以指示发音方式</li><li>Voice engine: generative、long-form、neural、standard</li><li>Speech mark: 标记音频中句子&#x2F;单词的起始和结束位置</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img1209939.png"></p><hr><h4 id="AWS-Rekognition"><a href="#AWS-Rekognition" class="headerlink" title="AWS Rekognition"></a>AWS Rekognition</h4><ul><li>使用 ML 在图像和视频中识别物体、人物、文本、场景</li><li>人脸分析和搜索，用于用户验证、人数统计</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img12091053.png"></p><p><strong>Custom Labels</strong></p><ul><li>标记训练图像并上传到 Rekognition</li><li>新图像将按你定义的自定义方式分类</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img12091054.png"></p><p><strong>Content Moderation</strong></p><ul><li>自动检测不当、有害或冒犯性内容</li><li>Custom Moderation Adaptors: 提供自己标记的图像集扩展 Rekognition 能力</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img12091055.png"></p><hr><h4 id="AWS-Lex"><a href="#AWS-Lex" class="headerlink" title="AWS Lex"></a>AWS Lex</h4><ul><li>使用语音和文本快速为应用构建聊天机器人</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img12091056.png"></p><hr><h4 id="AWS-Personalize"><a href="#AWS-Personalize" class="headerlink" title="AWS Personalize"></a>AWS Personalize</h4><ul><li>全托管 ML 服务，构建实时个性化推荐应用</li><li>集成到现有网站、应用、SMS、邮件营销系统</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img12091059.png"></p><hr><h4 id="AWS-Textract"><a href="#AWS-Textract" class="headerlink" title="AWS Textract"></a>AWS Textract</h4><ul><li>使用 AI 和 ML 自动从扫描文档中提取文本、手写内容和数据</li><li>读取和处理任何类型文档（PDF、图像等）</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img12091104.png"></p><hr><h4 id="AWS-Kendra"><a href="#AWS-Kendra" class="headerlink" title="AWS Kendra"></a>AWS Kendra</h4><ul><li>全托管的 ML 文档搜索服务</li><li>从文档中提取答案（text、pdf、HTML、PowerPoint、Word、FAQs 等）</li><li>从用户交互&#x2F;反馈中学习，提升首选结果（Incremental Learning）</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img12091115.png"></p><hr><h4 id="AWS-Mechanical-Turk"><a href="#AWS-Mechanical-Turk" class="headerlink" title="AWS Mechanical Turk"></a>AWS Mechanical Turk</h4><ul><li>众包市场，用于执行简单的人工任务</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img12091124.png"></p><hr><h4 id="AWS-Augmented-AI-A2I"><a href="#AWS-Augmented-AI-A2I" class="headerlink" title="AWS Augmented AI (A2I)"></a>AWS Augmented AI (A2I)</h4><ul><li>在生产环境中对 ML 预测进行人工监督</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img12091125.png"></p><hr><h4 id="AWS-Transcribe-Medical"><a href="#AWS-Transcribe-Medical" class="headerlink" title="AWS Transcribe Medical"></a>AWS Transcribe Medical</h4><ul><li>自动将医疗相关语音转换为文本（符合 HIPAA）</li><li>支持实时（麦克风）和批量（上传文件）转录</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img12091127.png"></p><hr><h4 id="AWS-Comprehend-Medical"><a href="#AWS-Comprehend-Medical" class="headerlink" title="AWS Comprehend Medical"></a>AWS Comprehend Medical</h4><ul><li>从非结构化临床文本中检测并返回有用信息</li><li>使用 NLP 检测 Protected Health Information (PHI) — DetectPHI API</li><li>配合 Amazon Transcribe 将患者叙述转录为文本，再由 Comprehend Medical 分析</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img12091129.png"></p><hr><h4 id="AWS-Hardware-for-AI"><a href="#AWS-Hardware-for-AI" class="headerlink" title="AWS Hardware for AI"></a>AWS Hardware for AI</h4><ul><li><strong>AWS Trainium:</strong> 用于 100B+ 参数模型 Deep Learning 的 ML 芯片，训练成本降低 50%</li><li><strong>AWS Inferentia:</strong> 用于高性能低成本推理的 ML 芯片，吞吐量提升 4x，成本降低 70%</li><li>Trn 和 Inf 具有最低的环境足迹</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img12091136.png"></p><hr><h3 id="7-AWS-SageMaker"><a href="#7-AWS-SageMaker" class="headerlink" title="7. AWS SageMaker"></a>7. AWS SageMaker</h3><h4 id="AWS-SageMaker-AI"><a href="#AWS-SageMaker-AI" class="headerlink" title="AWS SageMaker AI"></a>AWS SageMaker AI</h4><ul><li>全托管服务，供开发者&#x2F;数据科学家构建 ML 模型</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img1211536.png"></p><p><strong>End-to-End ML Service</strong></p><ul><li>收集和准备数据</li><li>构建和训练 ML 模型</li><li>部署模型并监控预测性能</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img1211537.png"></p><p><strong>Built-in Algorithms</strong></p><ul><li>Supervised: Linear regressions&#x2F;classifications, KNN</li><li>Unsupervised: PCA（降维）, K-means（聚类）, Anomaly Detection</li><li>Textual: NLP, 摘要</li><li>Image Processing: 分类, 检测</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img1211538.png"></p><p><strong>Automatic Model Tuning (AMT)</strong></p><ul><li>定义 Objective Metric</li><li>AMT 自动选择 hyperparameter ranges、搜索策略、最大运行时间、早停条件</li><li>节省时间和成本</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img1211539.png"></p><p><strong>Model Deployment &amp; Inference</strong></p><ul><li>一键部署，自动扩展，无需管理服务器</li><li>Real-time: 单次预测</li><li>Serverless: 流量高峰之间有空闲期</li><li>Asynchronous: 大 payload（最大 1GB），请求&#x2F;响应在 S3</li><li>Batch: 整个数据集的预测</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img1211540.png"><br><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img1211541.png"></p><p><strong>SageMaker Studio</strong></p><ul><li>统一界面进行端到端 ML 开发</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img1211542.png"></p><hr><h4 id="SageMaker-Data-Tools"><a href="#SageMaker-Data-Tools" class="headerlink" title="SageMaker Data Tools"></a>SageMaker Data Tools</h4><p><strong>SageMaker - Data Wrangler</strong></p><ul><li>为 ML 准备表格和图像数据</li><li>数据准备、转换和 feature engineering</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img1211544.png"></p><p><strong>SageMaker - Feature Store</strong></p><ul><li>从多种来源摄取 features</li><li>可在 Feature Store 内定义数据到 feature 的转换</li><li>Features 可在 SageMaker Studio 中发现</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img1211545.png"></p><hr><h4 id="SageMaker-Models-and-Humans"><a href="#SageMaker-Models-and-Humans" class="headerlink" title="SageMaker - Models and Humans"></a>SageMaker - Models and Humans</h4><p><strong>SageMaker Clarify</strong></p><ul><li>评估 Foundation Models</li><li>评估人类因素如友好度或幽默感</li><li>SageMaker Studio 的一部分</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img1211639.png"></p><p><strong>SageMaker Clarify - Model Explainability</strong></p><ul><li>帮助解释 ML 模型如何做出预测的工具集</li><li>部署前理解模型整体特征</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img1211640.png"></p><p><strong>SageMaker Clarify - Detect Bias</strong></p><ul><li>检测和解释数据集和模型中的偏见</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img1211641.png"></p><p><strong>SageMaker Ground Truth</strong></p><ul><li>RLHF: 将人类反馈纳入 reward function 的强化学习</li><li>Ground Truth Plus: 数据标注</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img1211643.png"></p><hr><h4 id="SageMaker-Governance"><a href="#SageMaker-Governance" class="headerlink" title="SageMaker - Governance"></a>SageMaker - Governance</h4><ul><li>SageMaker Model Cards: 基本模型信息</li><li>SageMaker Model Dashboard: 所有模型的集中仓库</li><li>SageMaker Role Manager: 为角色定义权限</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img1211650.png"></p><p><strong>Model Dashboard</strong></p><ul><li>查看、搜索、探索所有模型的集中门户</li><li>帮助发现违反数据质量、模型质量、偏见、可解释性阈值的模型</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img1211651.png"></p><p><strong>Model Monitor</strong></p><ul><li>监控生产环境中模型质量：持续或按计划</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img1211652.png"></p><p><strong>Model Registry</strong></p><ul><li>追踪、管理和版本控制 ML 模型的集中仓库</li><li>管理模型审批状态、自动化部署、共享模型</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img1211653.png"></p><p><strong>SageMaker Pipelines</strong></p><ul><li>自动化构建、训练、部署 ML 模型的工作流</li><li>ML 的 CI&#x2F;CD 服务</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img1211654.png"><br><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img1211656.png"></p><hr><h4 id="SageMaker-Consoles"><a href="#SageMaker-Consoles" class="headerlink" title="SageMaker Consoles"></a>SageMaker Consoles</h4><p><strong>SageMaker JumpStart</strong></p><ul><li>ML Hub，查找预训练 Foundation Model、计算机视觉模型、NLP 模型</li><li>预建 ML 解决方案：需求预测、信用评级预测、欺诈检测、计算机视觉</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img1211657.png"></p><p><strong>SageMaker Canvas</strong></p><ul><li>使用可视化界面构建 ML 模型（无需编码）</li><li>使用 SageMaker Autopilot 的 AutoML 构建自定义模型</li><li>SageMaker Studio 的一部分</li><li>利用 Data Wrangler 进行数据准备</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img1211659.png"></p><hr><h3 id="8-AI-Challenges-and-Responsibilities"><a href="#8-AI-Challenges-and-Responsibilities" class="headerlink" title="8. AI Challenges and Responsibilities"></a>8. AI Challenges and Responsibilities</h3><h4 id="Responsible-AI"><a href="#Responsible-AI" class="headerlink" title="Responsible AI"></a>Responsible AI</h4><ul><li>Amazon Bedrock: 人工或自动模型评估</li><li>Guardrails for Amazon Bedrock: 过滤内容、隐藏 PII、增强安全和隐私</li><li>SageMaker Clarify: FM 评估准确性、鲁棒性、毒性</li><li>SageMaker Data Wrangler: 通过平衡数据集修复偏见</li><li>SageMaker Model Monitor: 生产环境质量分析</li><li>Amazon Augmented AI (A2I): ML 预测的人工审核</li><li>Governance: SageMaker Role Manager, Model Cards, Model Dashboard</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img12121049.png"></p><p><strong>AWS AI Service Cards</strong></p><ul><li>负责任 AI 的文档形式</li><li>帮助理解服务及其功能</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img12121051.png"></p><p><strong>Interpretability Trade-Offs</strong></p><ul><li>Interpretability: 人类理解决策原因的程度</li><li>高透明度 &#x3D;&gt; 高可解释性 &#x3D;&gt; 性能较差</li><li>Explainability: 理解模型的本质和行为</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img12121052.png"></p><p><strong>Partial Dependence Plots (PDP)</strong></p><ul><li>显示单个特征如何影响预测结果，同时保持其他特征不变</li><li>对 “black box” 模型（如 Neural Networks）特别有帮助</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img12121053.png"></p><p><strong>Human-Centered Design (HCD) for Explainable AI</strong></p><ul><li>Design for amplified decision-making: 在高压环境中最小化风险和错误</li><li>Design for unbiased decision-making: 决策过程无偏见</li><li>Design for human and AI learning: 认知学徒制、个性化、用户中心设计</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img12121054.png"></p><hr><h4 id="GenAI-Challenges"><a href="#GenAI-Challenges" class="headerlink" title="GenAI Challenges"></a>GenAI Challenges</h4><p><strong>Toxicity</strong></p><ul><li>生成冒犯性、令人不安或不当内容</li><li>缓解：预先筛选训练数据，识别和移除冒犯性内容</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img12121059.png"></p><p><strong>Hallucinations</strong></p><ul><li>听起来正确但实际错误的断言</li><li>缓解：教育用户必须核实模型生成的内容</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img12121100.png"></p><p><strong>Plagiarism and Cheating</strong></p><ul><li>担忧 Gen AI 被用于写论文、求职写作样本等作弊行为</li><li>检测 AI 生成文本&#x2F;图像的技术兴起</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img12121101.png"></p><p><strong>Prompt Misuses</strong></p><ul><li>Poisoning: 故意向训练数据集注入恶意或有偏见的数据</li><li>Hijacking&#x2F;Prompt Injection: 在 prompt 中嵌入特定指令影响输出</li><li>Exposure: 训练或推理时暴露敏感信息的风险</li><li>Prompt Leaking: 无意泄露模型使用的 prompt 或输入</li><li>Jailbreaking: 绕过 AI 模型的伦理和安全约束</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img12121102.png"></p><hr><h4 id="Governance-of-AI"><a href="#Governance-of-AI" class="headerlink" title="Governance of AI"></a>Governance of AI</h4><ul><li>管理、优化和扩展组织 AI 计划</li><li>治理对于建立信任至关重要</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img1213912.png"></p><p><strong>Governance Strategies</strong></p><ul><li>Policies: 原则、指南和负责任 AI 考量</li><li>Review Cadence: 技术、法律和负责任 AI 审查的结合</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img1213922.png"></p><ul><li>Transparency Standards: 发布 AI 模型、训练数据、关键决策的信息</li><li>Team Training Requirements: 培训相关政策、指南和最佳实践</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img1213923.png"></p><hr><h4 id="Security-and-Privacy-for-AI-Systems"><a href="#Security-and-Privacy-for-AI-Systems" class="headerlink" title="Security and Privacy for AI Systems"></a>Security and Privacy for AI Systems</h4><ul><li>Threat Detection: 检测假内容、篡改数据、自动化攻击</li><li>Vulnerability Management: 识别 AI 系统漏洞：软件 bug、模型弱点</li><li>Infrastructure Protection: 保护云计算平台、边缘设备、数据存储</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img1213926.png"></p><ul><li>Prompt Injection: 操纵输入 prompt 生成恶意或不良内容</li><li>Data Encryption: 静态和传输中数据加密</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img1213927.png"></p><p><strong>AWS Shared Responsibility Model</strong></p><ul><li>AWS 责任: Security of the Cloud（云的安全）</li><li>客户责任: Security in the Cloud（云中的安全）</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img1213929.png"></p><hr><h3 id="9-AWS-Services"><a href="#9-AWS-Services" class="headerlink" title="9. AWS Services"></a>9. AWS Services</h3><h4 id="AWS-IAM"><a href="#AWS-IAM" class="headerlink" title="AWS IAM"></a>AWS IAM</h4><ul><li>Root Account(根账户) - 默认创建,拥有完全权限,不要与他人共享。</li><li>Users(用户) - 组织内的个人,可以属于多个组。</li><li>Groups(组) - 只能包含用户,不能包含其他组。</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img145736.png"></p><hr><h4 id="IAM-Permissions"><a href="#IAM-Permissions" class="headerlink" title="IAM Permissions"></a>IAM Permissions</h4><ul><li>定义用户或组的访问权限</li><li>最小权限原则(Least Privilege Principle) - 只授予完成任务所需的最小权限,避免过度授权。</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img160124.png"></p><hr><h4 id="IAM-Polices"><a href="#IAM-Polices" class="headerlink" title="IAM Polices"></a>IAM Polices</h4><ul><li><p>定义操作权限,与执行方法无关。</p></li><li><p>策略结构 - Statements 必须包含:</p><ul><li>Effect - Allow 或 Deny</li><li>Principal - 谁可以访问</li><li>Action - 允许或拒绝的操作</li><li>Resource - 作用于哪些资源</li></ul></li><li><p>Inline Policy (内联策略) - 直接分配给单个用户、组或角色的策略。</p></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img175653.png"></p><hr><h4 id="IAM-Roles"><a href="#IAM-Roles" class="headerlink" title="IAM Roles"></a>IAM Roles</h4><ul><li>授权 AWS 服务去做某些事 (比如 EB 需要 EC2 Role 和 Service Role)</li><li>常见的 Role<ul><li>EC2 Instance Role - 允许 EC2 实例访问其他 AWS 服务</li><li>Lambda Function Role - 授予 Lambda 函数执行权限</li><li>Service Role - 如 Elastic Beanstalk 需要 EC2 Role 和 Service Role</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img203306.png"></p><hr><h4 id="AWS-S3-Simple-Storage-Service"><a href="#AWS-S3-Simple-Storage-Service" class="headerlink" title="AWS S3 (Simple Storage Service)"></a>AWS S3 (Simple Storage Service)</h4><p><strong>S3 Buckets (存储桶)</strong></p><ul><li>S3 服务是全球性的，但 Bucket 是区域性的</li><li>在 buckets 中存储对象（文件）</li><li>Bucket 名称必须全球唯一</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img171839.png"></p><p><strong>Objects (对象)</strong></p><ul><li>每个对象有一个 key（完整路径 &#x3D; prefix + object name）</li><li>最大对象大小 5TB</li><li>单次上传限制 5GB，超过需使用 Multi-Part Upload</li><li>可使用 S3 Transfer Acceleration 加速上传</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img172025.png"></p><p><strong>S3 重要特性</strong></p><ul><li>S3 总是返回对象的最新版本</li><li>S3 无法加密 metadata</li><li>S3 是 serverless 服务</li><li>S3 sync 命令使用 CopyObject API 在 buckets 间复制对象</li><li>对象所有权：默认情况下，S3 对象归上传它的 AWS 账户所有，即使 bucket 属于另一个账户</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/imglifecycle-transitions-v2.png"></p><hr><h4 id="S3-Storage-Classes"><a href="#S3-Storage-Classes" class="headerlink" title="S3 Storage Classes"></a>S3 Storage Classes</h4><ul><li>共 7 种存储类别: 1 个 General + 2 个 IA + 3 个 Glacier + 1 个 Intelligent</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img175742.png"></p><p><strong>S3 Standard (标准通用型)</strong></p><ul><li>频繁访问的数据，最常见</li><li>高持久性、高可用性、低延迟</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img175932.png"></p><p><strong>S3 Infrequent Access (IA)</strong></p><ul><li>Standard-IA: 多 AZ，高可用，最少存储 30 天</li><li>One Zone-IA: 单 AZ，成本更低，AZ 可能故障所以不适合高可用需求</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img180147.png"></p><p><strong>S3 Glacier (归档存储)</strong></p><ul><li>Instant Retrieval: 毫秒级检索，最贵，最少 90 天</li><li>Flexible Retrieval: 1-5 分钟 &#x2F; 3-5 小时 &#x2F; 5-12 小时，最少 90 天</li><li>Deep Archive: 12 小时 &#x2F; 48 小时，最便宜，最少 180 天</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img180642.png"></p><p><strong>S3 Intelligent-Tiering</strong></p><ul><li>根据使用情况自动在存储类别之间移动</li><li>无检索费用，无需手动管理</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img180806.png"></p><hr><h4 id="AWS-EC2-Elastic-Compute-Cloud"><a href="#AWS-EC2-Elastic-Compute-Cloud" class="headerlink" title="AWS EC2 (Elastic Compute Cloud)"></a>AWS EC2 (Elastic Compute Cloud)</h4><ul><li>属于 Infrastructure as a Service (IaaS),绑定到特定 AZ。</li><li>User Data (用户数据) - EC2 启动时自动运行的脚本 (如安装 Apache)。<ul><li>默认只在首次启动时运行</li><li>默认以 root 用户权限执行</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img214749.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img214956.png"></p><ul><li>SSH 连接 - 使用 EC2 实例的公网 IP 地址连接。</li><li>Instance Metadata (实例元数据) - 通过特殊 IP 获取实例信息:<ul><li><a href="http://169.254.169.254/latest/meta-data/public-ipv4">http://169.254.169.254/latest/meta-data/public-ipv4</a> - 获取公网 IP</li><li>记住 169 这个数字</li></ul></li></ul><hr><h4 id="AWS-Lambda"><a href="#AWS-Lambda" class="headerlink" title="AWS Lambda"></a>AWS Lambda</h4><ul><li>虚拟函数，Serverless，短期执行（最长 15 分钟）</li><li>按需运行，自动扩展，按毫秒计费</li><li>无需管理服务器</li><li>Event-Driven: S3 事件、DynamoDB 流、API Gateway 等</li><li>CRON Job: 使用 EventBridge 定期触发（如每小时）</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img212846.png"></p><p><strong>Lambda Limits</strong></p><ul><li>Execution: Memory 128MB-10GB，最长 15 分钟</li><li>Deployment: 压缩包 50MB，解压 250MB，容器镜像 10GB</li><li>有 account quota 限制，需联系 AWS 提高</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img213554.png"></p><p><strong>VPC 访问</strong></p><ul><li>默认 Lambda 运行在 AWS VPC，可访问公共互联网和 AWS API</li><li>启用 VPC 后，需通过公共子网的 NAT Gateway 访问公共资源</li></ul><hr><h4 id="AWS-Macie"><a href="#AWS-Macie" class="headerlink" title="AWS Macie"></a>AWS Macie</h4><ul><li>使用机器学习保护敏感数据<ul><li>使用 ML 保护 AWS 中的敏感数据 (PII)</li><li>自动发现和分类敏感数据</li><li>持续监控 S3 存储桶</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img180224.png"></p><hr><h4 id="AWS-Config"><a href="#AWS-Config" class="headerlink" title="AWS Config"></a>AWS Config</h4><ul><li>资源配置监控和合规性服务</li><li>提供 AWS 资源配置的详细视图，记录配置和随时间的变更</li><li>示例：检查 ACM 证书是否临近过期</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img192656.png"></p><p><strong>Config Rules</strong></p><ul><li>自定义 Rule 检查资源合规性，也有 AWS managed rules</li><li>常见规则：检查 S3 bucket 公开访问、EC2 是否使用批准的 AMI、EBS 卷是否加密</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img045705.png"></p><p><strong>Config Remediations</strong></p><ul><li>使用 SSM Automation Documents 自动修复不合规资源</li><li>例如：自动关闭不受限制的 SSH 访问</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img192951.png"></p><p><strong>Config Notifications</strong></p><ul><li>使用 EventBridge 在资源不合规时触发通知</li><li>集成 SNS、Lambda 等</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img193119.png"></p><p><strong>CloudTrail vs. Config</strong></p><ul><li>CloudTrail：谁在什么时候做了什么（API 调用审计）</li><li>Config：资源配置是什么，如何变化（配置管理）</li></ul><hr><h4 id="AWS-Inspector"><a href="#AWS-Inspector" class="headerlink" title="AWS Inspector"></a>AWS Inspector</h4><ul><li>自动化安全评估服<ul><li>自动化安全评估 (Automated Security Assessments)</li><li>持续扫描漏洞</li><li>生成安全发现报告</li></ul></li><li>支持的资源类型<ul><li>EC2 Instance - 操作系统漏洞</li><li>Container Images (ECR) - 容器镜像漏洞</li><li>Lambda Functions - 函数代码和依赖漏洞</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img180110.png"></p><hr><h4 id="AWS-CloudTrail"><a href="#AWS-CloudTrail" class="headerlink" title="AWS CloudTrail"></a>AWS CloudTrail</h4><ul><li>AWS 账户的治理、合规和审计服务</li><li>记录事件历史和 API 调用，全球服务</li><li>资源被误删时，第一时间查看 CloudTrail</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img191802.png"></p><p><strong>CloudTrail Events</strong></p><ul><li>Management Events：创建、删除、修改资源等操作</li><li>Data Events：S3 对象级活动、Lambda 执行、DynamoDB 操作</li><li>Insights Events：使用 ML 检测异常活动</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img192042.png"></p><p><strong>CloudTrail Insights</strong></p><ul><li>检测账户中的异常活动</li><li>检测场景：API 调用激增、资源配置异常变化</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img192157.png"></p><hr><h4 id="AWS-Artifact"><a href="#AWS-Artifact" class="headerlink" title="AWS Artifact"></a>AWS Artifact</h4><ul><li>提供AWS合规报告和协议的自助服务门户</li><li>下载SOC报告、PCI报告等合规文档,管理协议(如BAA)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img124706.png"></p><hr><h4 id="AWS-Audit-Manager"><a href="#AWS-Audit-Manager" class="headerlink" title="AWS Audit Manager"></a>AWS Audit Manager</h4><ul><li>评估 AWS 工作负载的风险和合规性</li><li>持续审计 AWS 服务使用情况并准备审计</li><li>生成合规报告和证据文件夹</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img12131028.png"></p><hr><h4 id="AWS-Trusted-Advisor"><a href="#AWS-Trusted-Advisor" class="headerlink" title="AWS Trusted Advisor"></a>AWS Trusted Advisor</h4><ul><li>分析 AWS 账户并在 6 个类别提供建议<ul><li>Cost optimization, Performance, Security, Fault tolerance, Service limits, Operational Excellence</li></ul></li><li>需要 Business 或 Enterprise Support plan</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img12131029.png"></p><hr><h4 id="AWS-VPC"><a href="#AWS-VPC" class="headerlink" title="AWS VPC"></a>AWS VPC</h4><ul><li>AWS 中的虚拟私有网络。</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img075533.png"></p><p><strong>Subnets</strong></p><ul><li>VPC 内的子网分区（公有&#x2F;私有）</li><li>公有子网: 有路由到 Internet Gateway，可以直接访问互联网（如 web server）</li><li>私有子网: 没有直接路由到互联网，需通过 NAT Gateway 访问外网（如数据库）</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img075637.png"></p><p><strong>Internet Gateway &amp; NAT Gateway</strong></p><ul><li>Internet Gateway (IGW): 让公有子网的资源访问互联网，双向通信</li><li>NAT Gateway: 让私有子网的资源访问互联网，但外部无法主动连入（单向）</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img075859.png"></p><p><strong>Security Group vs NACL</strong></p><ul><li>Security Group: 实例级防火墙，只有允许规则，有状态</li><li>NACL: 子网级防火墙，允许和拒绝规则，无状态</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img080543.png"></p><p><strong>VPC Flow Logs</strong></p><ul><li>捕获 VPC 内网络流量日志，用于监控和排查网络问题</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img080849.png"></p><p><strong>VPC Peering</strong></p><ul><li>连接两个 VPC，使它们可以像在同一网络中一样通信</li><li>不支持传递（A-B、B-C 不意味着 A-C 能通）</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img080936.png"></p><p><strong>VPC Endpoints</strong></p><ul><li>私密访问 AWS 服务（如 S3、DynamoDB），流量不经过互联网，更安全</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img101047.png"></p><hr><h4 id="AWS-PrivateLink"><a href="#AWS-PrivateLink" class="headerlink" title="AWS PrivateLink"></a>AWS PrivateLink</h4><ul><li>将第三方 VPC 或本地网络私密连接到 AWS 服务</li><li>不经过公网，最安全的暴露服务方式</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img101255.png"></p><hr><h4 id="Site-to-Site-VPN-amp-Direct-Connect"><a href="#Site-to-Site-VPN-amp-Direct-Connect" class="headerlink" title="Site to Site VPN &amp; Direct Connect"></a>Site to Site VPN &amp; Direct Connect</h4><ul><li><p><strong>Site-to-Site VPN</strong></p><ul><li>通过公网建立加密连接，连接本地网络和 AWS VPC</li><li>组件: Virtual Private Gateway (VGW) + Customer Gateway</li></ul></li><li><p><strong>Direct Connect</strong></p><ul><li>专用物理网络连接，从本地直连 AWS</li><li>比 VPN 更稳定、低延迟、高带宽，但成本更高</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img101436.png"></p><hr><h4 id="AWS-Client-VPN"><a href="#AWS-Client-VPN" class="headerlink" title="AWS Client VPN"></a>AWS Client VPN</h4><ul><li>允许用户从任何地方安全连接到 AWS 和本地网络</li><li>基于 OpenVPN 的托管 VPN 服务，适合远程办公</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img101635.png"></p><hr><h4 id="AWS-Transit-Gateway"><a href="#AWS-Transit-Gateway" class="headerlink" title="AWS Transit Gateway"></a>AWS Transit Gateway</h4><ul><li>中心化网络连接枢纽</li><li>通过单个网关连接多个 VPC 和本地网络，简化复杂网络拓扑</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img101746.png"></p>]]></content>
      
      
      <categories>
          
          <category> Certification </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AWS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS &amp; Python 小技巧</title>
      <link href="/posts/998b6089.html"/>
      <url>/posts/998b6089.html</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="密码错误" data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="15e82533bcb1293ce756ee9fbcc59de43332ea84af97385de66d9d2187f15914">03c03690e5a2c7a44b2aa66e251c66b95173940c42de79c65734cf256d748a1f3392aea18f5ba83a6ce29c7e1144d90c760cb672ac36819a3e414f16924b3610a129f4732b5b01d6a33086e7ec72383eec2d6c734fee1bd49b773e9dadb57d7103ffc8c872c93bfddda3671e1478d25af326387f2008078db54c42a5501acd5a88b40d06637002c29490e6eca76633cc7d9b1a85d00f9656c8af1ca351c236f451caeb05ff7c8f920c7e6c94d7ac82f57f55764ee39687bd81232ce46b396a6841b9dada990a9709e8d90afcb07cc5a1e3493665540714003cad9c3f0e28a22a</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-xray">      <input class="hbe hbe-input-field hbe-input-field-xray" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-xray" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-xray">密码</span>      </label>      <svg class="hbe hbe-graphic hbe-graphic-xray" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>        <path d="M0,2.5c0,0,298.666,0,399.333,0C448.336,2.5,513.994,13,597,13c77.327,0,135-10.5,200.999-10.5c95.996,0,402.001,0,402.001,0"></path>      </svg>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>GCP 实操练习</title>
      <link href="/posts/3f28c94.html"/>
      <url>/posts/3f28c94.html</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="密码错误" data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="15e82533bcb1293ce756ee9fbcc59de43332ea84af97385de66d9d2187f15914">03c03690e5a2c7a44b2aa66e251c66b95173940c42de79c65734cf256d748a1f3392aea18f5ba83a6ce29c7e1144d90c760cb672ac36819a3e414f16924b3610a129f4732b5b01d6a33086e7ec72383eec2d6c734fee1bd49b773e9dadb57d7103ffc8c872c93bfddda3671e1478d25af326387f2008078db54c42a5501acd5a88b40d06637002c29490e6eca76633cc7d9b1a85d00f9656c8af1ca351c236f451caeb05ff7c8f920c7e6c94d7ac82f57f55764ee39687bd81232ce46b396a6841b9dada990a9709e8d90afcb07cc5a1e3493665540714003cad9c3f0e28a22a</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-xray">      <input class="hbe hbe-input-field hbe-input-field-xray" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-xray" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-xray">密码</span>      </label>      <svg class="hbe hbe-graphic hbe-graphic-xray" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>        <path d="M0,2.5c0,0,298.666,0,399.333,0C448.336,2.5,513.994,13,597,13c77.327,0,135-10.5,200.999-10.5c95.996,0,402.001,0,402.001,0"></path>      </svg>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 练习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GCP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Security 101</title>
      <link href="/posts/e7e09e2.html"/>
      <url>/posts/e7e09e2.html</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="密码错误" data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="15e82533bcb1293ce756ee9fbcc59de43332ea84af97385de66d9d2187f15914">03c03690e5a2c7a44b2aa66e251c66b95173940c42de79c65734cf256d748a1f3392aea18f5ba83a6ce29c7e1144d90c760cb672ac36819a3e414f16924b3610a129f4732b5b01d6a33086e7ec72383eec2d6c734fee1bd49b773e9dadb57d7103ffc8c872c93bfddda3671e1478d25af326387f2008078db54c42a5501acd5a88b40d06637002c29490e6eca76633cc7d9b1a85d00f9656c8af1ca351c236f451caeb05ff7c8f920c7e6c94d7ac82f57f55764ee39687bd81232ce46b396a6841b9dada990a9709e8d90afcb07cc5a1e3493665540714003cad9c3f0e28a22a</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-xray">      <input class="hbe hbe-input-field hbe-input-field-xray" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-xray" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-xray">密码</span>      </label>      <svg class="hbe hbe-graphic hbe-graphic-xray" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>        <path d="M0,2.5c0,0,298.666,0,399.333,0C448.336,2.5,513.994,13,597,13c77.327,0,135-10.5,200.999-10.5c95.996,0,402.001,0,402.001,0"></path>      </svg>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 练习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Security </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>System Design 101</title>
      <link href="/posts/733301f0.html"/>
      <url>/posts/733301f0.html</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="密码错误" data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="15e82533bcb1293ce756ee9fbcc59de43332ea84af97385de66d9d2187f15914">03c03690e5a2c7a44b2aa66e251c66b95173940c42de79c65734cf256d748a1f3392aea18f5ba83a6ce29c7e1144d90c760cb672ac36819a3e414f16924b3610a129f4732b5b01d6a33086e7ec72383eec2d6c734fee1bd49b773e9dadb57d7103ffc8c872c93bfddda3671e1478d25af326387f2008078db54c42a5501acd5a88b40d06637002c29490e6eca76633cc7d9b1a85d00f9656c8af1ca351c236f451caeb05ff7c8f920c7e6c94d7ac82f57f55764ee39687bd81232ce46b396a6841b9dada990a9709e8d90afcb07cc5a1e3493665540714003cad9c3f0e28a22a</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-xray">      <input class="hbe hbe-input-field hbe-input-field-xray" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-xray" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-xray">密码</span>      </label>      <svg class="hbe hbe-graphic hbe-graphic-xray" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>        <path d="M0,2.5c0,0,298.666,0,399.333,0C448.336,2.5,513.994,13,597,13c77.327,0,135-10.5,200.999-10.5c95.996,0,402.001,0,402.001,0"></path>      </svg>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 练习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> System Design </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用算法集合</title>
      <link href="/posts/5470c8ce.html"/>
      <url>/posts/5470c8ce.html</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="密码错误" data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="15e82533bcb1293ce756ee9fbcc59de43332ea84af97385de66d9d2187f15914">03c03690e5a2c7a44b2aa66e251c66b95173940c42de79c65734cf256d748a1f3392aea18f5ba83a6ce29c7e1144d90c760cb672ac36819a3e414f16924b3610a129f4732b5b01d6a33086e7ec72383eec2d6c734fee1bd49b773e9dadb57d7103ffc8c872c93bfddda3671e1478d25af326387f2008078db54c42a5501acd5a88b40d06637002c29490e6eca76633cc7d9b1a85d00f9656c8af1ca351c236f451caeb05ff7c8f920c7e6c94d7ac82f57f55764ee39687bd81232ce46b396a6841b9dada990a9709e8d90afcb07cc5a1e3493665540714003cad9c3f0e28a22a</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-xray">      <input class="hbe hbe-input-field hbe-input-field-xray" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-xray" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-xray">密码</span>      </label>      <svg class="hbe hbe-graphic hbe-graphic-xray" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>        <path d="M0,2.5c0,0,298.666,0,399.333,0C448.336,2.5,513.994,13,597,13c77.327,0,135-10.5,200.999-10.5c95.996,0,402.001,0,402.001,0"></path>      </svg>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 练习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Google Cloud Associate Cloud Engineer</title>
      <link href="/posts/3fb7a84c.html"/>
      <url>/posts/3fb7a84c.html</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p>官网: <a href="https://cloud.google.com/learn/certification/cloud-engineer/">https://cloud.google.com/learn/certification/cloud-engineer/</a></p></blockquote><hr><h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3>]]></content>
      
      
      <categories>
          
          <category> Certification </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GCP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Terraform Associate 003</title>
      <link href="/posts/bb3fbb6d.html"/>
      <url>/posts/bb3fbb6d.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/imgrj2v0kxiwnf99hfja1ood1dwupdaex6.png"></p><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p>官网: <a href="https://developer.hashicorp.com/terraform">https://developer.hashicorp.com/terraform</a><br>Terraform Registry: <a href="https://registry.terraform.io/namespaces/hashicorp">https://registry.terraform.io/namespaces/hashicorp</a></p></blockquote><hr><h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><h4 id="What-is-Terraform"><a href="#What-is-Terraform" class="headerlink" title="What is Terraform"></a>What is Terraform</h4><ul><li><p>Terraform 是一个开源的“基础设施即代码（IaC）”工具，由 HashiCorp 开发。它允许你使用一种声明式语言（HCL，HashiCorp Configuration Language）来定义和管理云资源，比如服务器、数据库、网络、防火墙等</p><ul><li>Terraform 可以管理多个云平台上的基础设施</li><li>基础设施像写代码一样管理</li><li>Terraform 的状态允许您在整个部署过程中跟踪资源变化</li><li>代码审计 + 版本控制（配合 Git）</li></ul></li><li><p>为什么使用 Terraform</p><ul><li>传统部署方式手动点点点 ➜ 易出错、不可重复</li></ul></li><li><p>一些 Terraform 的 Alternatives</p><ul><li>AWS CloudFormation, Azure Resource Manager, GCP Deployment Manager, Pulumi</li></ul></li></ul><hr><h4 id="What-is-Infrastructure-as-Code"><a href="#What-is-Infrastructure-as-Code" class="headerlink" title="What is Infrastructure as Code"></a>What is Infrastructure as Code</h4><ul><li><p><a href="https://www.hashicorp.com/en/blog/infrastructure-as-code-in-a-private-or-public-cloud">Infrastructure as Code</a> 是一种用代码管理和部署基础设施（如服务器、网络、数据库等）的方式。它就像 DevOps 的“建筑图纸”，让你用脚本来创建和管理 IT 环境，而不是手动点击界面操作。</p></li><li><p>IaC 的核心价值</p><ul><li>协作平台: 作为团队协作的中心，让开发、运维等多角色共同构建和管理基础设施</li><li>快速扩展: 用代码快速复制和扩容资源，实现自动化部署</li><li>标准化部署: 所有环境都用相同模板，减少人为错误、提高一致性</li></ul></li></ul><blockquote><p>假设你需要在 AWS 上建一个 S3 桶，传统做法是登录控制台点点点<br>而用 Terraform，你可以写一个文件</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">resource &quot;aws_s3_bucket&quot; &quot;my_bucket&quot; &#123;</span><br><span class="line">  bucket = &quot;hongda-demo-bucket&quot;</span><br><span class="line">  acl    = &quot;private&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="Benefits-of-IaC"><a href="#Benefits-of-IaC" class="headerlink" title="Benefits of IaC"></a>Benefits of IaC</h4>]]></content>
      
      
      <categories>
          
          <category> Certification </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Terraform </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AWS SAP-C02</title>
      <link href="/posts/da74417d.html"/>
      <url>/posts/da74417d.html</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p>官网: <a href="https://aws.amazon.com/certification/certified-solutions-architect-professional/?ch=sec&sec=rmg&d=1">https://aws.amazon.com/certification/certified-solutions-architect-professional/?ch=sec&amp;sec=rmg&amp;d=1</a><br>题库: <a href="https://www.examtopics.com/exams/amazon/aws-certified-solutions-architect-professional-sap-c02/">https://www.examtopics.com/exams/amazon/aws-certified-solutions-architect-professional-sap-c02/</a></p></blockquote><hr><h3 id="1-Identity-amp-Federation"><a href="#1-Identity-amp-Federation" class="headerlink" title="1. Identity &amp; Federation"></a>1. Identity &amp; Federation</h3><h4 id="IAM"><a href="#IAM" class="headerlink" title="IAM"></a>IAM</h4><div style="text-align: center; padding: 0.5rem">🔐 IAM 身份类型一览</div><table><thead><tr><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>Users</td><td>长期凭证用户（用户名+密码 &#x2F; access key）</td></tr><tr><td>Groups</td><td>用户集合，用于统一授权</td></tr><tr><td>Roles</td><td>使用 STS 签发的临时凭证（跨账户、服务访问、EC2 等）</td></tr><tr><td>EC2 Instance Roles</td><td>通过 Instance Metadata Service 获取临时凭证（每个 EC2 一次只能有一个角色）</td></tr><tr><td>Service Roles</td><td>用于 AWS 服务访问另一个服务，如 API Gateway、CodeDeploy 等</td></tr><tr><td>Cross Account Roles</td><td>跨账户访问权限，使用 AssumeRole 实现</td></tr></tbody></table><div style="text-align: center; padding: 0.5rem">📝 IAM 策略类型</div><table><thead><tr><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>AWS Managed Policy</td><td>AWS 预定义的策略，如 <code>AdministratorAccess</code></td></tr><tr><td>Customer Managed</td><td>你创建和维护的可复用策略</td></tr><tr><td>Inline Policy</td><td>直接嵌入到用户 &#x2F; 组 &#x2F; 角色上的策略，作用域限于该实体</td></tr><tr><td>Resource-based Policy</td><td>应用于资源上的策略，如 S3 Bucket、SQS Queue 等</td></tr></tbody></table><div style="text-align: center; padding: 0.5rem">🔍 IAM 工具与可视化</div><table><thead><tr><th>工具名称</th><th>作用</th></tr></thead><tbody><tr><td>Access Advisor</td><td>查看角色或用户的权限实际使用情况（支持最近访问时间）</td></tr><tr><td>Access Analyzer</td><td>检查资源是否被外部实体共享（例如 S3 Bucket 公开、KMS Key 共享）</td></tr><tr><td>Policy Simulator</td><td>模拟策略效果，验证策略是否按预期生效</td></tr></tbody></table><hr><h4 id="IAM-Policy"><a href="#IAM-Policy" class="headerlink" title="IAM Policy"></a>IAM Policy</h4><ul><li>IAM 策略是一个 JSON 文档，通常包含以下字段</li></ul><table><thead><tr><th>字段</th><th>说明</th></tr></thead><tbody><tr><td><code>&quot;Effect&quot;</code></td><td>策略效果，可为 <code>&quot;Allow&quot;</code> 或 <code>&quot;Deny&quot;</code></td></tr><tr><td><code>&quot;Action&quot;</code></td><td>允许的操作，例如 <code>&quot;s3:GetObject&quot;</code></td></tr><tr><td><code>&quot;NotAction&quot;</code></td><td>明确排除的操作（通常与 <code>&quot;Effect&quot;: &quot;Allow&quot;</code> 搭配使用）</td></tr><tr><td><code>&quot;Resource&quot;</code></td><td>作用的资源 ARN，例如 <code>&quot;arn:aws:s3:::my-bucket/*&quot;</code></td></tr><tr><td><code>&quot;Condition&quot;</code></td><td>可选字段，用于添加附加限制条件</td></tr></tbody></table><ul><li><strong>显式 <code>Deny</code> 优先于 <code>Allow</code></strong>  </li><li><strong>最佳实践：始终遵循最小权限原则（Least Privilege）</strong></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img520756.png"></p><hr><h4 id="IAM-Policies-Variables-and-Tags"><a href="#IAM-Policies-Variables-and-Tags" class="headerlink" title="IAM Policies Variables and Tags"></a>IAM Policies Variables and Tags</h4><ul><li><code>$&#123;aws:username&#125;</code>: 代表当前执行请求的 IAM 用户名</li><li><code>AWS Specific</code>: aws:CurrentTime, aws:TokenIssueTime, aws:principaltype…</li><li><code>Service Specific</code>: s3:prefix, s3:max-keys, s3:x-amz-acl…</li><li><code>Tag Based</code>: iam:ResourceTag&#x2F;key-name, aws:PrincipalTag&#x2F;key-name…</li></ul><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;Effect&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Allow&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;Action&quot;</span><span class="punctuation">:</span> <span class="string">&quot;s3:*&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;Resource&quot;</span><span class="punctuation">:</span> <span class="string">&quot;arn:aws:s3:::mybucket/$&#123;aws:username&#125;/*&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><ul><li>假设 IAM 用户 alice 发起了请求，那么这个 policy 中的变量就会自动替换成</li></ul><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;Resource&quot;</span><span class="punctuation">:</span> <span class="string">&quot;arn:aws:s3:::mybucket/alice/*&quot;</span></span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img042721.png"></p><hr><h4 id="IAM-Roles-vs-Resource-Based-Policies"><a href="#IAM-Roles-vs-Resource-Based-Policies" class="headerlink" title="IAM Roles vs Resource Based Policies"></a>IAM Roles vs Resource Based Policies</h4><ul><li>IAM 中的访问控制可以通过两种方式实现<ul><li>使用角色（IAM Role）：通过扮演角色进行访问（代理身份）</li><li>使用资源策略（Resource-based Policy）：直接将权限附加在资源上</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img042719.png"></p><ul><li>IAM Role 示例：A 账户中的 Lambda 要访问 B 账户中的 DynamoDB，A 账户的 Lambda 必须 Assume B 账户中的角色</li><li>Resource-based Policy 示例：B 账户的 S3 Bucket Policy 直接允许 A 账户的某个角色或服务访问该 Bucket</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img421721.png"></p><div style="text-align: center; padding: 0.5rem">🆚 IAM Role vs Resource-based Policy 对比总结</div><table><thead><tr><th>维度</th><th>IAM Role（角色）</th><th>Resource-based Policy（资源策略）</th></tr></thead><tbody><tr><td>附加位置</td><td>附加在身份（User、Service、Account）上</td><td>附加在资源上（如 S3 Bucket、SQS、KMS 等）</td></tr><tr><td>使用方式</td><td>访问方先 AssumeRole，临时获取权限</td><td>资源接收外部请求时，根据策略判断是否允许访问</td></tr><tr><td>适用场景</td><td>用户 &#x2F; 服务访问其他账户资源</td><td>资源授权给外部账户、服务或匿名用户</td></tr><tr><td>支持跨账户访问</td><td>✅ 是，通过 <code>AssumeRole</code> 实现</td><td>✅ 是，直接在资源上允许其他账户 &#x2F; 服务访问</td></tr><tr><td>例子</td><td>EC2 实例角色、Lambda 执行角色、跨账户访问角色</td><td>S3 Bucket Policy、SQS Queue Policy、KMS Key Policy</td></tr><tr><td>授权主体控制权在哪一方？</td><td>访问者（主动扮演角色）</td><td>资源拥有者（决定谁可访问资源）</td></tr></tbody></table><hr><h4 id="IAM-Permission-Boundaries"><a href="#IAM-Permission-Boundaries" class="headerlink" title="IAM Permission Boundaries"></a>IAM Permission Boundaries</h4><ul><li>Permission Boundary 是一种高级 IAM 控制机制，用于为 User 或 Role 设置权限上限。⚠️ 不支持用于 Group<ul><li>假设用户 A 被授予了 AdministratorAccess（几乎所有权限）</li><li>但他的 Permission Boundary 限定为只允许：s3:<em>, ec2:</em>, cloudwatch:*</li><li>结果, 用户 A 无法执行 iam:CreateUser，即使他的策略中写了也无效</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img421726.png"></p><ul><li>委托权限给非管理员: 比如让开发者自行管理权限（但不能升权）</li><li>允许自助权限管理: 用户可以 attach policy，但受 boundary 限制</li><li>精细限制特定用户或角色: 针对关键岗位做严格边界控制</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img421729.png"></p><hr><h4 id="IAM-Access-Analyzer"><a href="#IAM-Access-Analyzer" class="headerlink" title="IAM Access Analyzer"></a>IAM Access Analyzer</h4><ul><li>Access Analyzer 是 IAM 的可视化工具，用于帮助你识别资源是否被意外共享，并提供策略分析与建议功能。</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img425312.png"></p><ul><li>IAM Access Analyzer Policy Validation<ul><li>Validates your policy against IAM policy grammar and best practices</li><li>自动检查 IAM Policy 是否符合语法 + 安全最佳实践</li></ul></li><li>IAM Access Analyzer Policy Generation<ul><li>Generates IAM policy based on access activity</li><li>根据实际访问行为自动生成最小权限策略（least privilege）</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img425314.png"></p><hr><h4 id="STS-Security-Token-Service"><a href="#STS-Security-Token-Service" class="headerlink" title="STS (Security Token Service)"></a>STS (Security Token Service)</h4><ul><li><p>使用 AWS Security Token Service (STS)，你可以让一个用户、服务或应用 临时扮演另一个 IAM Role，获取一组短期凭证</p></li><li><p>定义 IAM Role（本账户或跨账户）</p><ul><li>信任策略（Trust Policy）：定义谁可以 assume 这个角色（哪些 Principal）</li><li>权限策略（Permissions Policy）：定义这个角色 assume 后能做什么操作</li></ul></li><li><p>示例 Trust Policy（允许 IAM 用户 assume 该角色）</p></li></ul><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;Effect&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Allow&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;Principal&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;AWS&quot;</span><span class="punctuation">:</span> <span class="string">&quot;arn:aws:iam::123456789012:user/developer&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;Action&quot;</span><span class="punctuation">:</span> <span class="string">&quot;sts:AssumeRole&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><ul><li>使用 AWS STS 获取临时凭证：调用 AssumeRole API，获得临时凭证</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">aws sts assume-role \</span><br><span class="line">  --role-arn <span class="string">&quot;arn:aws:iam::123456789012:role/MyRole&quot;</span> \</span><br><span class="line">  --role-session-name <span class="string">&quot;example-session&quot;</span></span><br></pre></td></tr></table></figure><ul><li>临时凭证有效期：可配置范围：15 分钟 ~ 12 小时</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img204619.png"></p><table><thead><tr><th>场景</th><th>描述</th></tr></thead><tbody><tr><td>🔄 跨账户访问</td><td>让账户 A 的用户访问账户 B 的资源（你拥有两个账户）</td></tr><tr><td>🤝 第三方访问授权</td><td>授权第三方（如供应商）账户的 IAM 用户访问你账户中的资源</td></tr><tr><td>☁️ AWS 服务间访问</td><td>EC2、Lambda 等 AWS 服务通过 role 访问其他资源（S3、DynamoDB 等）</td></tr><tr><td>🌐 身份联合（Federation）</td><td>外部身份源（如 AD、Google、SAML）用户通过联合登录后 assume 角色</td></tr><tr><td>⛔ 会话吊销机制</td><td>使用 <code>aws:TokenIssueTime</code> + 条件策略吊销旧会话（<code>AWSRevokeOlderSessions</code>）</td></tr></tbody></table><ul><li>你可以让某个账户中的 IAM 用户切换身份，访问另一个账户（或同账户）中的 IAM Role</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img204957.png"></p><ul><li>如何安全地授权第三方 AWS 账户访问你资源中的 IAM Role<ul><li>Zone of Trust：你自己拥有的账户或 AWS Organization</li><li>Outside Zone of Trust：第三方拥有的 AWS 账户（如供应商、合作伙伴）</li></ul></li><li>访问授权流程（给第三方账户）<ul><li>第三方的 AWS Account ID</li><li>一个 External ID（共享的 secret 字符串，由第三方提供）</li><li>在你账户中创建 IAM Role<ul><li>指定允许 AssumeRole 的 AWS 账户 ID</li><li>添加 Condition 限制 External ID，确保只授权给特定第三方</li></ul></li><li>第三方 assume 该角色<ul><li>在调用 AssumeRole 时必须提供正确的 External ID，否则拒绝访问</li></ul></li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img205645.png"></p><ul><li>External ID 的重要性</li></ul><table><thead><tr><th>功能</th><th>说明</th></tr></thead><tbody><tr><td>🧿 防止“confused deputy” 攻击</td><td>防止别人冒用第三方身份去 assume 你暴露的角色</td></tr><tr><td>🔒 安全通道</td><td>External ID 是你与第三方之间的秘密，AWS 作为验证者</td></tr><tr><td>🤝 明确授权对象</td><td>你可以根据不同第三方使用不同 External ID，实现绑定</td></tr></tbody></table><ul><li>Session Tags in STS<ul><li>当你通过 STS AssumeRole &#x2F; AssumeRoleWithSAML &#x2F; AssumeRoleWithWebIdentity 获取临时凭证时，可以附带自定义 Tag，这些 Tag 会作为“身份元信息”跟随该会话</li></ul></li></ul><table><thead><tr><th>功能</th><th>描述</th></tr></thead><tbody><tr><td>🏷️ 权限控制</td><td>可用于通过 IAM Policy 中的 <code>aws:PrincipalTag</code> 条件限制资源访问</td></tr><tr><td>🔍 审计追踪</td><td>Session tags 会显示在 CloudTrail 中，便于审计</td></tr><tr><td>🧑‍💼 用户信息传递</td><td>可以传递比如 <code>Department=Finance</code>、<code>Project=Alpha</code> 这样的上下文信息</td></tr><tr><td>🔐 安全增强</td><td>限制只有具有特定 tag 的用户才能传递某些 tag（防止伪造）</td></tr></tbody></table><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img210325.png"></p><table><thead><tr><th>API 名称</th><th>描述</th></tr></thead><tbody><tr><td><strong>AssumeRole</strong></td><td>获取临时凭证以访问本账户或跨账户的 IAM Role，最常用的 STS 接口。</td></tr><tr><td><strong>AssumeRoleWithSAML</strong></td><td>为通过 SAML 登录的用户返回临时凭证，常用于企业 SSO（如 AD FS）。</td></tr><tr><td><strong>AssumeRoleWithWebIdentity</strong></td><td>为通过 Web Identity Provider（如 Cognito、Facebook、Google、OIDC）登录的用户提供临时凭证。AWS 推荐使用 Cognito。</td></tr><tr><td><strong>GetSessionToken</strong></td><td>获取当前 IAM 用户或 Root 用户的临时凭证，常与 MFA 一起使用。</td></tr><tr><td><strong>GetFederationToken</strong></td><td>为联合用户（不在 IAM 中注册的用户）获取临时凭证，常用于代理程序或内部网络中的应用。</td></tr></tbody></table><hr><h4 id="Identity-Federation-in-AWS"><a href="#Identity-Federation-in-AWS" class="headerlink" title="Identity Federation in AWS"></a>Identity Federation in AWS</h4><ul><li>Give users outside of AWS permissions to access AWS resources in your account</li><li>允许 AWS 账户外部的用户 获取对 AWS 资源的访问权限，无需创建 IAM 用户<ul><li>SAML 2.0, Custom Identity Broker, WebIdentityFederationWith(out)AmazonCognito, IAM Identity Center</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img426112.png"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+----------+     Authenticate    +-----------------+</span><br><span class="line">|   User   | -----------------&gt; | External IdP     |</span><br><span class="line">+----------+                    +-----------------+</span><br><span class="line">                                    |</span><br><span class="line">                                    v</span><br><span class="line">                      [Get Token / Assertion from IdP]</span><br><span class="line">                                    |</span><br><span class="line">                                    v</span><br><span class="line">                     +-----------------------------+</span><br><span class="line">                     | STS (AssumeRoleXxx)         |</span><br><span class="line">                     +-----------------------------+</span><br><span class="line">                                    |</span><br><span class="line">                                    v</span><br><span class="line">                     [Get Temporary Credentials]</span><br><span class="line">                                    |</span><br><span class="line">                                    v</span><br><span class="line">                          Access AWS Resources</span><br></pre></td></tr></table></figure><hr><h4 id="AWS-Directroy-Service-AD"><a href="#AWS-Directroy-Service-AD" class="headerlink" title="AWS Directroy Service (AD)"></a>AWS Directroy Service (AD)</h4><ul><li>Active Directory（AD） 是微软在 Windows Server 中提供的目录服务，用于集中管理网络中的用户、计算机、资源和权限</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img426133.png"></p><table><thead><tr><th>功能</th><th>说明</th></tr></thead><tbody><tr><td>🎯 用户管理</td><td>创建&#x2F;修改用户账号，设置密码策略、登录权限等</td></tr><tr><td>🖥️ 资源管理</td><td>统一管理计算机、打印机、文件共享等资源</td></tr><tr><td>🔐 权限分配</td><td>使用组（Security Groups）来简化访问控制</td></tr><tr><td>🗂️ 集中认证（SSO）</td><td>用户只需登录一次，便可访问多个网络资源（Kerberos 协议）</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Forest</span><br><span class="line">└── Tree (example.com)</span><br><span class="line">    ├── Domain: example.com</span><br><span class="line">    │   ├── OU: HR</span><br><span class="line">    │   │   └── User: Alice</span><br><span class="line">    │   ├── OU: IT</span><br><span class="line">    │   │   └── Computer: IT-PC-01</span><br><span class="line">    └── Domain: sub.example.com</span><br></pre></td></tr></table></figure><ul><li>AWS Directory Services</li></ul><table><thead><tr><th>服务名称</th><th>描述</th><th>是否与本地 AD 集成</th><th>支持 MFA</th><th>用户存储位置</th></tr></thead><tbody><tr><td>AWS Managed Microsoft AD</td><td>AWS 托管的 Microsoft AD，完全兼容，支持 AD 信任关系</td><td>✅（支持信任）</td><td>✅</td><td>存在 AWS 托管 AD 中</td></tr><tr><td>AD Connector</td><td>目录代理，充当 AWS 和本地 AD 的桥梁（不存储用户数据）</td><td>✅（直连）</td><td>✅</td><td>用户存储在本地 AD</td></tr><tr><td>Simple AD</td><td>AWS 提供的简化版、兼容 AD 协议的托管目录，适合轻量应用</td><td>❌（无法信任）</td><td>❌</td><td>存储在 AWS Simple AD</td></tr></tbody></table><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img4261136.png"></p><ul><li><code>AWS Managed Microsoft AD</code>（托管 Microsoft AD）<ul><li>完全托管的 Active Directory，运行在你的 AWS VPC 内，适合需要微软 AD 功能的企业工作负载</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+----------------------+        +----------------------+</span><br><span class="line">|   Availability Zone 1|        |   Availability Zone 2|</span><br><span class="line">|                      |        |                      |</span><br><span class="line">|  +----------------+  |        |  +----------------+  |</span><br><span class="line">|  |   AD DC        |  |        |  |   AD DC        |  |</span><br><span class="line">|  +----------------+  |        |  +----------------+  |</span><br><span class="line">|        ^   ^         |        |        ^   ^         |</span><br><span class="line">|       /     \        |        |       /     \        |</span><br><span class="line">|   EC2 / Apps  \      |        |   EC2 / Apps  \      |</span><br><span class="line">+----------------------+        +----------------------+</span><br><span class="line"></span><br><span class="line">            ↕  Auto replication</span><br><span class="line">      ↔ Cross-VPC / Multi-Account Join</span><br></pre></td></tr></table></figure><ul><li>Connect to on-premises AD<ul><li>在 AWS 中部署 AWS Managed Microsoft AD 后，可以通过 VPN 或 Direct Connect 与你现有的 本地 AD（on-premises AD） 建立 信任关系（Trust）</li></ul></li></ul><p>连接方式</p><table><thead><tr><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>🛰️ VPN</td><td>使用 AWS Site-to-Site VPN 建立加密连接</td></tr><tr><td>⚡ Direct Connect</td><td>使用 AWS DX 提供更稳定的私网连接</td></tr></tbody></table><p>支持的信任类型（Forest Trust）</p><table><thead><tr><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>🔁 双向信任 (Two-way)</td><td>AWS 和本地 AD 相互信任，可双向身份验证</td></tr><tr><td>👉 单向信任：AWS ➝ 本地 AD</td><td>AWS 用户可以访问本地资源</td></tr><tr><td>👉 单向信任：本地 ➝ AWS</td><td>本地用户可以访问 AWS 中的资源</td></tr></tbody></table><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img426123.png"></p><ul><li>Solution Architecture: Active Directory Replication<ul><li>为了降低延迟并提高可用性，可在 AWS 中部署本地 AD 的副本，以便在 VPN 或 Direct Connect 连接中断时仍可正常认证和访问资源</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img4261229.png"></p><ul><li><code>AWS Directory Services AD Connector</code><ul><li>AD Connector 是一种目录网关（Directory Gateway），用于将 AWS 内的身份验证请求转发至你的 本地 Microsoft Active Directory</li><li>适合纯身份验证代理，不支持 SQL Server</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img4261231.png"></p><ul><li><code>AWS Directory Services Simple AD</code><ul><li>Simple AD 是一种低成本、轻量级的目录服务，兼容 Microsoft Active Directory，适用于小规模身份认证需求</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img42561234.png"></p><table><thead><tr><th>目录服务类型</th><th>是否支持 Trust</th><th>支持 SSO</th><th>支持 MFA</th><th>用户管理位置</th><th>最大用户数</th></tr></thead><tbody><tr><td>Simple AD</td><td>❌ 不支持</td><td>❌ 不支持</td><td>❌ 不支持</td><td>托管在 AWS</td><td>500 &#x2F; 5000</td></tr><tr><td>AD Connector</td><td>❌ 不支持</td><td>✅ 支持</td><td>✅ 支持</td><td>本地 AD</td><td>取决于本地 AD</td></tr><tr><td>Managed Microsoft AD</td><td>✅ 支持</td><td>✅ 支持</td><td>✅ 支持</td><td>托管在 AWS</td><td>可扩展</td></tr></tbody></table><hr><h4 id="AWS-Organizations"><a href="#AWS-Organizations" class="headerlink" title="AWS Organizations"></a>AWS Organizations</h4><ul><li>AWS Organizations 允许你在一个统一的管理框架下，集中管理多个 AWS 账户。可通过组织单元（Organizational Units，OUs）分组，并应用策略统一控制<ul><li><code>Root</code>: 整个组织的顶层节点，包含所有 OUs 和账号</li><li><code>Management Account</code>: 用于创建组织、邀请账号、应用 SCP 策略</li><li><code>Organizational Unit (OU)</code>: 类似目录结构中的文件夹，用于逻辑分组账户（如 Dev、Prod、HR）</li><li><code>Member Accounts</code>: 加入组织的子账户，可继承 OU 的策略限制，但不具备组织控制权</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img4261238.png"></p><ul><li>AWS Organizations - <code>OrganizationAccountAccessRole</code><ul><li>这是一个 IAM 角色，用于允许 管理账户（Management Account） 对 成员账户（Member Accounts） 执行管理员操作</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img4261240.png"></p><ul><li>AWS Multi-Account Strategies<ul><li>在企业级架构中，采用多个 AWS 账户（Multi-Account）可以带来更高的安全性、资源隔离性和可扩展性</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img4261242.png"></p><ul><li>AWS Organizations – Feature Modes<ul><li>AWS Organizations 提供两种功能模式（Feature Sets），控制组织可用的功能范</li></ul></li></ul><p><code>Consolidated Billing Features</code>（账单整合模式）</p><table><thead><tr><th>特性</th><th>说明</th></tr></thead><tbody><tr><td>💳 统一账单管理</td><td>所有成员账户共享一个支付方式，由管理账户付款</td></tr><tr><td>💰 使用量聚合优惠</td><td>像 EC2、S3 这类资源使用量可跨账户聚合，享受更高折扣</td></tr><tr><td>🚫 无 SCP（Service Control Policies）支持</td><td>无法进行权限统一限制管理</td></tr></tbody></table><p><code>All Features</code>（全功能模式）✅ 默认选项</p><table><thead><tr><th>特性</th><th>说明</th></tr></thead><tbody><tr><td>✅ 包含 Consolidated Billing 所有功能</td><td>继承账单整合模式的所有优点</td></tr><tr><td>✅ 启用 Service Control Policies（SCP） 管理成员账户权限</td><td>可统一管理成员账户的服务访问权限</td></tr><tr><td>✅ 可将账户从组织中“锁定”</td><td>通过 SCP 防止成员账户擅自离开组织</td></tr><tr><td>🔐 更细粒度控制</td><td>适用于多账户安全与合规性架构</td></tr><tr><td>⚠️ 一旦启用，无法回退 到仅账单模式</td><td>启用后无法降级回 Consolidated Billing 模式</td></tr></tbody></table><ul><li>AWS Organizations – Moving Accounts（迁移账户）<ul><li>从原 Organization 中移除成员账户</li><li>从目标 Organization 发送邀请</li><li>成员账户接受邀请</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img4261248.png"></p><hr><h4 id="Service-Control-Policies-SCP"><a href="#Service-Control-Policies-SCP" class="headerlink" title="Service Control Policies (SCP)"></a>Service Control Policies (SCP)</h4><ul><li>SCP 是 AWS Organizations 的一种权限控制机制，用于对组织中的账户进行统一的服务访问控制</li><li>作用范围为 OU 或账户层级, 不作用于管理账户（Management Account）</li><li>作用于账号中的所有用户和角色, 包括 Root User，但不包括 Service-linked Roles</li><li>策略继承机制: SCP 的生效路径必须从 Root OU 到目标账号 每一层都有 Allow，默认不允许任何操作</li></ul><table><thead><tr><th>对象</th><th>作用域</th><th>控制行为</th></tr></thead><tbody><tr><td>IAM Policy</td><td>用户 &#x2F; 角色</td><td>定义用户可做什么</td></tr><tr><td>SCP</td><td>账号 &#x2F; OU</td><td>定义账号最多能做什么（权限上限）</td></tr></tbody></table><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img427514.png"></p><table><thead><tr><th>用例场景</th><th>示例</th></tr></thead><tbody><tr><td>🚫 禁止使用某些服务</td><td>禁止某个 OU 下使用 EMR、CloudShell 等高风险服务</td></tr><tr><td>✅ 限制资源创建区域</td><td>限制只能在 us-east-1 区域中使用服务</td></tr><tr><td>📋 强制合规策略</td><td>确保某些服务（如 RDS）开启加密，或关闭不合规服务以满足 PCI、HIPAA 要求</td></tr><tr><td>🔐 限制 root 权限</td><td>虽然 root 无法被删除，但可通过 SCP 禁止其访问敏感服务</td></tr></tbody></table><ul><li>Service Control Policies (SCP) 会沿着 Organizational Unit (OU) 层级向下继承，形成最终每个账户的权限上限</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Root OU (applies: FullAWSAccess)</span><br><span class="line">│</span><br><span class="line">├── Management Account → ✅ 不受 SCP 限制（Can do anything）</span><br><span class="line">│</span><br><span class="line">├── OU: Workloads (applies: FullAWSAccess)</span><br><span class="line">│   ├── OU: Test (applies: Deny EC2)</span><br><span class="line">│   │   └── Account D → ❌ EC2 被禁止，其余允许</span><br><span class="line">│   │</span><br><span class="line">│   └── OU: Prod (applies: FullAWSAccess)</span><br><span class="line">│       ├── Account E → ✅ 全部允许</span><br><span class="line">│       └── Account F → ✅ 全部允许</span><br><span class="line">│</span><br><span class="line">└── OU: Sandbox (applies: Deny S3)</span><br><span class="line">    ├── Account A → ❌ S3 被禁止（来自 Sandbox OU）  </span><br><span class="line">    ├── Account B → ❌ S3 被禁止（Sandbox）  </span><br><span class="line">    └── Account C → ❌ S3 被禁止（Sandbox）  </span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img427517.png"></p><ul><li>左边: 除了 DynamoDB 被禁用，其他服务（S3、EC2、Lambda 等）都可以用</li><li>右边: 除了 ec2:* 和 cloudwatch:* 以外的服务（如 S3、RDS、IAM）全部不允许访问</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img4275518.png"></p><ul><li>IAM Policy Evaluation Logic（权限评估逻辑）<ul><li><ol><li><code>Deny Evaluation</code>（最先评估）: 是否有明确 Deny? 如果存在显式 Deny（例如 IAM Policy、SCP、Resource Policy 中），立即终止评估，决策为 Deny（优先级最高）</li></ol></li><li><ol start="2"><li><code>Organizations SCPs</code>（组织级服务控制策略）: 如果账户有 SCP，则必须在 SCP 中允许相应操作</li></ol></li><li><ol start="3"><li><code>Resource-based Policies</code>（资源级策略）: 比如 S3 Bucket Policy、Lambda Resource Policy、KMS Key Policy 等, 若不允许，继续下一个阶段</li></ol></li><li><ol start="4"><li><code>Identity-based Policies</code>（身份策略）: 评估 IAM User&#x2F;Role&#x2F;Group 的策略是否存在有效的 Allow? 若无，则隐式拒绝（Implicit Deny）</li></ol></li><li><ol start="5"><li><code>IAM Permissions Boundaries</code>（权限边界）: 权限边界也会限制一个用户&#x2F;角色的最大权限范围, 必须同时满足 Identity Policy 和 Boundary 才能通过</li></ol></li><li><ol start="6"><li><code>Session Policies</code>（会话策略）: 如果是通过临时凭证（例如 AssumeRole）访问，会话中可能附带 policy</li></ol></li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img427519.png"></p><hr><h4 id="IAM-Identity-Center"><a href="#IAM-Identity-Center" class="headerlink" title="IAM Identity Center"></a>IAM Identity Center</h4><ul><li>Formerly known as AWS Single Sign-On (SSO)</li></ul><table><thead><tr><th>功能</th><th>描述</th></tr></thead><tbody><tr><td>🔐 统一登录（Single Sign-On）</td><td>实现一次登录，访问多个 AWS 账户及业务应用</td></tr><tr><td>🔄 集中式身份访问管理</td><td>统一管理用户权限，跨账户&#x2F;跨区域生效</td></tr><tr><td>🧑‍💼 支持多种身份源</td><td>内置用户目录 + 第三方 IdP（如 AD、Okta）</td></tr></tbody></table><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img427534.png"></p><ul><li>AWS IAM Identity Center（前 AWS SSO） 的架构整合与工作流程</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 用户通过浏览器登录 Identity Center</span><br><span class="line">2. 后端通过内置目录或 AD 确认身份</span><br><span class="line">3. 根据用户绑定的 Permission Set 分配访问权限</span><br><span class="line">4. 自动 SSO 到：</span><br><span class="line">   - AWS 控制台（多个账户）</span><br><span class="line">   - SaaS 应用</span><br><span class="line">   - 支持 SAML2.0 的自定义系统</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img427536.png"></p><ul><li>IAM Identity Center 与 AWS Organizations 的集成结构 <ul><li>如何通过权限集（Permission Set）为用户跨账户赋权</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Bob 和 Alice 属于 Developers 组 →</span><br><span class="line">Developers 组被赋予：</span><br><span class="line">  - ReadOnlyAccess → Dev Account A</span><br><span class="line">  - FullAccess → Prod Account A</span><br><span class="line"></span><br><span class="line">➡️ 用户登录后会看到对应 AWS 账户及其可选的 Role</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img427538.png"></p><ul><li>AWS IAM Identity Center – Fine-grained Permissions and Assignments（细粒度权限与授权）</li></ul><p>Multi-Account Permissions（跨账户权限）</p><table><thead><tr><th>功能</th><th>描述</th></tr></thead><tbody><tr><td>✅ 跨账户权限管理</td><td>管理整个 AWS Organization 中多个账户的访问权限</td></tr><tr><td>📦 Permission Set</td><td>一组 IAM Policy 的集合，用于赋予用户&#x2F;组 AWS 账户访问权限</td></tr><tr><td>➕ 权限赋予机制</td><td>将 Permission Set 分配给用户&#x2F;组 + 指定账户，即可跨账户访问</td></tr></tbody></table><p>Application Assignments（SAML 应用授权）</p><table><thead><tr><th>功能</th><th>描述</th></tr></thead><tbody><tr><td>✅ SSO 访问企业 SaaS 应用</td><td>支持 Salesforce、Box、Microsoft 365 等 SAML 2.0 应用</td></tr><tr><td>🔐 提供所需的连接信息</td><td>包括 SAML URL、证书、Metadata 供应用配置使用</td></tr></tbody></table><p>Attribute-Based Access Control (ABAC)</p><table><thead><tr><th>功能</th><th>描述</th></tr></thead><tbody><tr><td>🏷️ 基于用户属性的权限控制</td><td>可根据用户属性自动应用权限，降低手动维护成本</td></tr><tr><td>示例属性</td><td><code>costcenter</code>, <code>title</code>, <code>locale</code> 等</td></tr><tr><td>用例</td><td>定义一次权限，后续通过修改属性控制访问范围，无需修改策略</td></tr></tbody></table><hr><h4 id="AWS-Control-Tower"><a href="#AWS-Control-Tower" class="headerlink" title="AWS Control Tower"></a>AWS Control Tower</h4><ul><li>AWS Control Tower 是一种自动化搭建、管理安全合规多账户环境的服务，基于 AWS 最佳实践</li><li>Control Tower 依赖 AWS Organizations 管理多账户结构</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img428831.png"></p><ul><li>AWS Control Tower – Account Factory<ul><li>Account Factory 是 AWS Control Tower 提供的一个自动化工具，用来标准化和批量创建新的 AWS 账户</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img428832.png"></p><ul><li>AWS Control Tower – Detect and Remediate Policy Violations<ul><li>Control Tower 通过 Guardrails（护栏规则） 来持续监控和管理账户环境中的合规性</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img428834.png"></p><ul><li>AWS Control Tower – Guardrails Levels<ul><li>Guardrails（护栏规则）按重要性和强制性被分为三种不同级别</li></ul></li></ul><table><thead><tr><th>等级</th><th>描述</th><th>示例</th></tr></thead><tbody><tr><td>🛡️ Mandatory （强制）</td><td>自动启用，AWS Control Tower 必须强制执行</td><td>禁止 Log Archive 账户对外公开读权限</td></tr><tr><td>💬 Strongly Recommended （强烈推荐）</td><td>根据 AWS 最佳实践推荐，启用可提升安全性，但可选</td><td>建议为 EC2 挂载的 EBS 卷启用加密</td></tr><tr><td>📝 Elective （自选）</td><td>企业常用的附加控制措施，可根据需要选择性启用</td><td>禁止无 MFA 的 S3 删除操作</td></tr></tbody></table><hr><h4 id="AWS-Resource-Access-Manager-RAM"><a href="#AWS-Resource-Access-Manager-RAM" class="headerlink" title="AWS Resource Access Manager (RAM)"></a>AWS Resource Access Manager (RAM)</h4><ul><li>AWS RAM 允许你将 AWS 资源跨账户共享，避免资源重复创建，提高资源利用率和成本效益</li><li>利用 RAM 共享 VPC 子网，多个账户的资源可以部署在同一个 VPC 中，同时保持账户级资源隔离</li><li></li></ul><p>支持共享的资源示例</p><table><thead><tr><th>资源类型</th><th>说明</th></tr></thead><tbody><tr><td>🌐 VPC 子网（Subnets）</td><td>允许多个账户的资源部署到同一个子网内（但必须同属一个 AWS Organization）</td></tr><tr><td>🚫 限制</td><td>不支持共享 Security Groups 和 Default VPC</td></tr><tr><td>🚍 Transit Gateway</td><td>多账户共用同一个 Transit Gateway 实现网络互通</td></tr><tr><td>🌎 Route 53</td><td>可以共享 Resolver 规则、DNS Firewall 规则组等</td></tr><tr><td>🛡️ License Manager 配置</td><td>跨账户统一管理许可证分配</td></tr></tbody></table><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img428837.png"></p><hr><h3 id="2-Security"><a href="#2-Security" class="headerlink" title="2. Security"></a>2. Security</h3><h4 id="CloudTrail"><a href="#CloudTrail" class="headerlink" title="CloudTrail"></a>CloudTrail</h4><ul><li>CloudTrail 是 AWS 的日志审计服务，用于记录账号中的所有 API 调用历史，便于审计、合规与安全调查（资源删除了？先查 CloudTrail！）</li><li><code>默认启用</code>: 每个 AWS 账户自动启用基本事件记录（90 天内）</li><li><code>记录所有 API 调用</code>: 包括通过控制台、SDK、CLI、AWS 服务内部调用等</li><li><code>跨区域支持</code>: 可选择记录单个 Region，或跨 Region（默认 All Regions）</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img220750.png"></p><p>CloudTrail 事件类型对比</p><table><thead><tr><th>事件类型</th><th>默认启用</th><th>是否高频</th><th>是否区分读写</th><th>示例</th></tr></thead><tbody><tr><td>Management Events</td><td>✅ 是</td><td>中频</td><td>✅ 可区分</td><td>IAM, EC2, CloudTrail</td></tr><tr><td>Data Events</td><td>❌ 否</td><td>高频</td><td>✅ 可区分</td><td>S3 对象, Lambda 调用</td></tr><tr><td>CloudTrail Insights</td><td>❌ 否</td><td>智能检测</td><td>无需区分</td><td>检测突增&#x2F;异常行为</td></tr></tbody></table><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img221339.png"></p><ul><li>CloudTrail Events Retention<ul><li>默认保留期限: 90 天（CloudTrail 控制台中默认可查询的事件时间范围）</li><li>长期保存: 若需保存超过 90 天，需将日志写入 S3 存储桶</li><li>查询分析: 可配合 Amazon Athena 查询存储在 S3 中的历史日志，实现结构化分析</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img221603.png"></p><ul><li>EventBridge + CloudTrail<ul><li>通过 Amazon EventBridge + CloudTrail 拦截 AWS API 调用，用于实时安全响应与告警</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">用户发起 DeleteTable API 操作 ➝ 被 CloudTrail 记录 ➝ 事件被 EventBridge 捕捉 ➝ 发出 SNS 告警</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img221813.png"></p><hr><h4 id="KMS-Key-Management-Service"><a href="#KMS-Key-Management-Service" class="headerlink" title="KMS (Key Management Service)"></a>KMS (Key Management Service)</h4><ul><li>KMS 是 AWS 提供的托管密钥服务，用于管理加密、解密和密钥授权，几乎涉及所有数据加密的场景</li><li><code>数据加密引擎</code>: AWS 中所有“加密”相关功能几乎都依赖 KMS</li><li><code>密钥托管与控制</code>: AWS 管理密钥的生命周期（创建、轮换、禁用等）</li><li><code>与 IAM 集成授权</code>: 使用 IAM 权限控制谁能访问或使用密钥</li><li>KMS 支持两种类型的密钥：对称密钥（Symmetric） 和 非对称密钥（Asymmetric）</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img224545.png"></p><p>KMS 密钥类型对比</p><table><thead><tr><th>特性</th><th>Customer Managed Key</th><th>AWS Managed Key</th><th>AWS Owned Key</th></tr></thead><tbody><tr><td>用户控制</td><td>✅ 完全控制</td><td>❌ 受限</td><td>❌ 无法控制</td></tr><tr><td>自动轮换</td><td>✅ 可启用</td><td>✅ 自动启用</td><td>✅ AWS 自管</td></tr><tr><td>支持 CloudTrail 审计</td><td>✅ 支持</td><td>✅ 支持</td><td>❌ 不支持</td></tr><tr><td>可用作 Envelope 加密</td><td>✅ 是</td><td>✅ 是</td><td>❌ 否</td></tr><tr><td>常见使用场景</td><td>高敏感数据</td><td>服务默认加密</td><td>AWS 内部使用</td></tr></tbody></table><ul><li>KMS Key Material Origin（密钥材料来源）<ul><li><code>AWS_KMS</code>: 由 AWS 自动生成, KMS 在其受控的密钥存储中创建并管理密钥材料</li><li><code>EXTERNAL</code>: 用户自行导入密钥材料, 使用 ImportKeyMaterial API 将密钥注入到 KMS 中</li><li><code>AWS_CLOUDHSM</code>: 使用 AWS CloudHSM 创建密钥材料, CloudHSM 是基于硬件的密钥模块（HSM）服务</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img502823.png"></p><ul><li>KMS Key Source – Custom Key Store (CloudHSM)<ul><li>将 KMS 与 CloudHSM 集群集成，使 KMS 密钥材料托管在你自有的 HSM 中，进一步增强安全边界与合规能力</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img105554.png"></p><ul><li>KMS Key Source – External（Bring Your Own Key, BYOK）<ul><li>将你自己的密钥材料（Key Material）导入到 AWS KMS 中，使你能在 AWS 内部使用外部生成的密钥来进行加密操作</li><li>AWS 提供使用接口，但不再负责密钥生命周期的管理与安全</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img105739.png"></p><ul><li>AWS KMS Multi-Region Keys<ul><li>在多个 Region 中创建一组 功能上等效的 KMS 密钥，支持跨区域加密&#x2F;解密，无需重新加密或跨区域 API 调用</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img110341.png"></p><hr><h4 id="SSM-Parameter-Store"><a href="#SSM-Parameter-Store" class="headerlink" title="SSM Parameter Store"></a>SSM Parameter Store</h4><ul><li>Parameter Store 是 AWS 提供的 配置与密钥值存储服务，适用于环境变量、凭证、密钥等的安全管理</li></ul><p>SSM Parameter Store – 常见用途</p><table><thead><tr><th>用途</th><th>示例</th></tr></thead><tbody><tr><td>🧪 环境配置注入</td><td>Dev &#x2F; Staging &#x2F; Prod 使用不同参数</td></tr><tr><td>🔐 密钥存储</td><td>存储数据库密码、API 密钥、令牌等</td></tr><tr><td>🔁 CI&#x2F;CD 集成</td><td>Pipeline 中动态读取版本化配置</td></tr><tr><td>🧩 服务间解耦配置</td><td>多个 Lambda &#x2F; ECS 服务共享相同配置但不硬编码</td></tr></tbody></table><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img110601.png"></p><ul><li>SSM Parameter Store – 分层结构（Hierarchy）<ul><li>Parameter Store 支持以“路径”方式组织参数，非常适合大型项目的多环境配置管理</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/my-department/</span><br><span class="line">├── my-app/</span><br><span class="line">│   ├── dev/</span><br><span class="line">│   │   ├── db-url</span><br><span class="line">│   │   └── db-password</span><br><span class="line">│   └── prod/</span><br><span class="line">│       ├── db-url</span><br><span class="line">│       └── db-password</span><br><span class="line">├── other-app/</span><br><span class="line">/other-department/</span><br></pre></td></tr></table></figure><ul><li>SSM Parameter Store – Standard 与 Advanced 参数层级对比</li></ul><table><thead><tr><th>特性</th><th>Standard</th><th>Advanced</th></tr></thead><tbody><tr><td>参数总数量上限（每账户每区域）</td><td>10,000</td><td>100,000</td></tr><tr><td>单个参数最大值大小</td><td>4 KB</td><td>8 KB</td></tr><tr><td>是否支持参数策略（过期等）</td><td>❌ 不支持</td><td>✅ 支持</td></tr><tr><td>成本</td><td>✅ 免费</td><td>💲 每个参数 $0.05&#x2F;月</td></tr><tr><td>典型用途</td><td>一般配置、小规模系统</td><td>大型企业系统、合规要求、多版本配置等</td></tr></tbody></table><ul><li>SSM Parameter Store – Parameter Policies（参数策略，仅限 Advanced 参数）<ul><li>Parameter Policies 是为高级参数（Advanced Tier）提供的附加功能，用于控制参数的生命周期、安全性与合规性</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img110924.png"></p><hr><h4 id="AWS-Secrets-Manager"><a href="#AWS-Secrets-Manager" class="headerlink" title="AWS Secrets Manager"></a>AWS Secrets Manager</h4><ul><li>Secrets Manager 是 AWS 专门用于存储和自动轮换敏感凭证（如密码、API 密钥等）的服务，比 Parameter Store 更安全、更自动化</li></ul><p>Secrets Manager vs SSM Parameter Store 对比简表</p><table><thead><tr><th>项目</th><th>Secrets Manager</th><th>SSM Parameter Store (SecureString)</th></tr></thead><tbody><tr><td>自动轮换</td><td>✅ 支持</td><td>❌ 不支持（需手动）</td></tr><tr><td>成本</td><td>💲 $0.40 每密钥 &#x2F; 月</td><td>标准免费，高级 $0.05 &#x2F; 月</td></tr><tr><td>支持 Lambda 集成</td><td>✅ 原生支持</td><td>❌ 无</td></tr><tr><td>原生服务集成</td><td>✅ 强（RDS、Redshift）</td><td>✅ 一般</td></tr></tbody></table><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img506823.png"></p><ul><li>AWS Secrets Manager – 跨账户共享（Sharing Across Accounts）<ul><li>要让其他 AWS 账户访问某个 Secrets Manager 中的密钥，需 同时配置 KMS 策略与 Resource-based Policy</li></ul></li></ul><p>SSM Parameter Store vs. Secrets Manager – Rotation</p><table><thead><tr><th>特性</th><th>Secrets Manager</th><th>SSM Parameter Store</th></tr></thead><tbody><tr><td>轮换方式</td><td>✅ 内建自动轮换</td><td>❌ 需自建 EventBridge + Lambda</td></tr><tr><td>RDS 支持</td><td>✅ 原生集成</td><td>✅ 需自行实现连接与更新逻辑</td></tr><tr><td>Lambda 模板支持</td><td>✅ AWS 提供模板</td><td>❌ 无模板</td></tr><tr><td>成本</td><td>💲 $0.40 &#x2F; 月 &#x2F; 密钥</td><td>💲 免费（标准）或 $0.05 &#x2F; 月（高级）</td></tr><tr><td>使用建议</td><td>高敏感数据，数据库密码管理</td><td>简单配置轮换或成本敏感场景</td></tr></tbody></table><hr><h4 id="SSL-x2F-TLS-Basics"><a href="#SSL-x2F-TLS-Basics" class="headerlink" title="SSL&#x2F;TLS - Basics"></a>SSL&#x2F;TLS - Basics</h4><ul><li>SSL&#x2F;TLS 是用于网络连接加密的协议，常用于保护浏览器与服务器之间的数据传输安全</li></ul><table><thead><tr><th>项目</th><th>描述</th></tr></thead><tbody><tr><td>🔐 SSL（Secure Sockets Layer）</td><td>最初用于实现安全通信的协议，现已被淘汰</td></tr><tr><td>🔐 TLS（Transport Layer Security）</td><td>SSL 的升级版，当前主流安全传输协议（如 TLS 1.2, TLS 1.3）</td></tr><tr><td>🗣️ 通俗叫法</td><td>尽管使用的是 TLS，大家仍习惯说 “SSL 证书”</td></tr></tbody></table><ul><li>SSL – Man-in-the-Middle (MITM) Attack<ul><li>MITM（中间人攻击）是指攻击者在用户与服务器之间悄悄插入，拦截、读取甚至篡改传输的数据，常见于公共 Wi-Fi 或 DNS 欺骗场景</li></ul></li></ul><p>MITM 攻击防护措施分类</p><table><thead><tr><th>等级</th><th>描述</th><th>示例或建议</th></tr></thead><tbody><tr><td>🛡️ Mandatory （强制）</td><td>基本防护措施，必须启用</td><td>所有公网流量使用 HTTPS，部署有效 SSL&#x2F;TLS 证书</td></tr><tr><td>💬 Strongly Recommended （强烈推荐）</td><td>AWS 推荐的增强防护手段，可显著提升安全性</td><td>启用 DNSSEC 来防止 DNS 被劫持</td></tr><tr><td>📝 Elective （自选）</td><td>企业常用的附加手段，可视情况启用</td><td>使用自定义 DNS 服务器提升控制力（如 Bind、dnsmasq）</td></tr></tbody></table><hr><h4 id="AWS-Certificate-Manager-ACM"><a href="#AWS-Certificate-Manager-ACM" class="headerlink" title="AWS Certificate Manager (ACM)"></a>AWS Certificate Manager (ACM)</h4><ul><li>ACM（AWS Certificate Manager）是 AWS 提供的 SSL&#x2F;TLS 证书管理服务，支持申请、托管、分发、续期等功能，极大简化了证书在云中的部署流程</li></ul><p>ACM 支持集成的服务</p><table><thead><tr><th>集成服务</th><th>描述</th></tr></thead><tbody><tr><td>⚖️ Load Balancer</td><td>支持 ALB &#x2F; NLB，包括由 Elastic Beanstalk 创建的负载均衡器</td></tr><tr><td>🌎 CloudFront</td><td>可为分发的内容启用 HTTPS 支持</td></tr><tr><td>📡 API Gateway</td><td>为 API 网关的自定义域名配置 SSL 证书</td></tr></tbody></table><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img509401.png"></p><p>建议使用场景总结</p><table><thead><tr><th>场景</th><th>建议</th></tr></thead><tbody><tr><td>✅ 外部网站或 API</td><td>使用 ACM 公有证书（自动续期 + 免费）</td></tr><tr><td>🔐 内部微服务通信（非公网）</td><td>创建 Private CA + 私有证书，并配置系统信任链</td></tr><tr><td>🌍 多区域应用部署</td><td>在每个 AWS Region 内单独签发证书，<strong>不支持跨区域复制或复用</strong></td></tr></tbody></table><hr><h4 id="CloudHSM"><a href="#CloudHSM" class="headerlink" title="CloudHSM"></a>CloudHSM</h4><ul><li><p>CloudHSM 是 AWS 提供的 专属硬件加密模块服务（HSM &#x3D; Hardware Security Module），适用于对密钥有高度控制要求的场景</p></li><li><p>CloudHSM 特性概览</p><ul><li>💡 专属硬件实例（HSM）：每个用户拥有独立的物理设备</li><li>🔑 密钥全权管理：只有你拥有密钥控制权，AWS 无法访问</li><li>📜 合规优势：通过 FIPS 140-2 Level 3 安全认证</li><li>🔁 支持加解密算法：对称（AES）、非对称（RSA、ECC）、TLS 证书管理等</li><li>🧩 集成支持：如 Redshift 可使用 CloudHSM 进行数据库加密和密钥管理（SSE-C 场景推荐）</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img509405.png"></p><p>KMS vs. CloudHSM 选择建议</p><table><thead><tr><th>场景</th><th>建议选择</th></tr></thead><tbody><tr><td>✅ 一般加密需求，使用 AWS 服务集成</td><td>AWS KMS（托管式 + 易用）</td></tr><tr><td>🔐 高合规场景（如政府、金融、医疗）</td><td>AWS CloudHSM（专属硬件 + 用户控密钥）</td></tr></tbody></table><hr><h4 id="S3-Security"><a href="#S3-Security" class="headerlink" title="S3 Security"></a>S3 Security</h4><ul><li>S3 提供多种对象加密方式，确保数据静态加密（encryption at rest），适用于不同的密钥管理需求</li><li>S3 提供 HTTP 与 HTTPS 两种访问方式，建议始终使用 加密传输（HTTPS） 来保护数据在网络传输过程中的安全</li></ul><table><thead><tr><th>加密方式</th><th>描述</th></tr></thead><tbody><tr><td>🟣 SSE-S3</td><td>- 使用 AWS 自主管理的密钥（AES-256）<br>- 完全托管、零配置</td></tr><tr><td>🟡 SSE-KMS</td><td>- 使用 AWS KMS 管理密钥<br>- 支持访问控制与 CloudTrail 审计日志</td></tr><tr><td>🔒 SSE-C</td><td>- 自定义客户提供密钥（Client-Provided Keys）<br>- S3 不保存密钥，仅临时使用</td></tr><tr><td>💻 Client-Side</td><td>- 加密在客户端完成后再上传到 S3<br>- 客户端负责密钥生成、加密与解密逻辑</td></tr></tbody></table><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img509432.png"></p><ul><li>Events in S3 Buckets<ul><li>S3 支持多种事件与日志机制，用于追踪对象访问、变更与安全状态</li></ul></li></ul><table><thead><tr><th>目的</th><th>建议使用机制</th></tr></thead><tbody><tr><td>获取完整访问日志</td><td>S3 Access Logs</td></tr><tr><td>实时触发函数&#x2F;消息</td><td>S3 Event Notifications</td></tr><tr><td>对接跨服务事件处理</td><td>CloudTrail + EventBridge</td></tr><tr><td>检查桶权限是否合规</td><td>Trusted Advisor</td></tr></tbody></table><ul><li>S3 Security 安全控制方式<ul><li>S3 提供两种主要的访问控制机制：基于用户 与 基于资源，可灵活搭配使用以实现精细权限控制</li></ul></li></ul><p>👤 User-based（基于用户）</p><table><thead><tr><th>控制方式</th><th>描述</th></tr></thead><tbody><tr><td>🔐 IAM Policy</td><td>在 IAM 控制台中配置，定义特定用户可执行哪些 S3 API 操作（如 GetObject、PutObject）</td></tr></tbody></table><p>📦 Resource-based（基于资源）</p><table><thead><tr><th>控制方式</th><th>描述</th></tr></thead><tbody><tr><td>📜 Bucket Policy</td><td>在 S3 控制台中为 Bucket 设置的策略，支持跨账户访问控制</td></tr><tr><td>🧾 Object ACL</td><td>物件级权限控制，粒度更细（可控制单个对象的读&#x2F;写权限）</td></tr><tr><td>📦 Bucket ACL</td><td>针对整个桶的访问控制，不常用，功能已被 Bucket Policy 替代为主</td></tr></tbody></table><ul><li>S3 Bucket Policies<ul><li>S3 Bucket Policy 是一种 资源级别的访问控制机制，用于集中定义整桶对象的权限策略</li><li>授予公共访问权限（用于静态网站托管或公开资源）</li><li>强制上传对象时加密（通过条件限制加密方式）</li><li>跨账户授权访问（授予其他 AWS 账户访问权限）</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img222722.png"></p><ul><li>S3 Pre-signed URLs<ul><li>预签名 URL 允许临时授权用户访问 S3 中的对象，常用于 临时下载 或 受控上传 场景</li></ul></li></ul><p>使用场景示例</p><table><thead><tr><th>场景描述</th><th>示例效果</th></tr></thead><tbody><tr><td>🎬 仅登录用户可下载付费视频</td><td>生成 GET 类型的预签名 URL，供登录用户使用</td></tr><tr><td>📥 动态授权用户下载文件</td><td>根据用户身份动态生成 GET URL，实现灵活文件访问控制</td></tr><tr><td>📤 临时上传文件至指定位置（如头像、PDF）</td><td>为某路径生成 PUT 类型的预签名 URL，仅临时开放上传权限</td></tr></tbody></table><ul><li>S3 Object Lock &amp; Glacier Vault Lock<ul><li>这两种锁定机制都采用 WORM（Write Once Read Many）模型，主要用于 合规存储 与 防篡改数据保护</li></ul></li></ul><table><thead><tr><th>场景</th><th>推荐机制</th></tr></thead><tbody><tr><td>普通对象防删（含版本控制）</td><td>S3 Object Lock</td></tr><tr><td>归档数据长期不可更改（如交易记录）</td><td>Glacier Vault Lock</td></tr><tr><td>合规要求 + 防篡改 + 永久保存需求</td><td>可结合 S3 Object Lock + Glacier Vault Lock 双层保护</td></tr></tbody></table><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img510114.png"></p><hr><h4 id="S3-–-Access-Points"><a href="#S3-–-Access-Points" class="headerlink" title="S3 – Access Points"></a>S3 – Access Points</h4><ul><li>S3 Access Points 提供一种更灵活、安全的方式来管理不同用户或应用程序对同一 Bucket 的访问权限，按角色或业务线划分权限，简化 Bucket Policy 管理复杂度</li></ul><table><thead><tr><th>用户角色</th><th>访问前缀</th><th>Access Point 名称</th><th>策略说明</th></tr></thead><tbody><tr><td>Users (Finance)</td><td>&#x2F;finance&#x2F;*</td><td>FinanceAccessPoint</td><td>允许读写 &#x2F;finance 区域</td></tr><tr><td>Users (Sales)</td><td>&#x2F;sales&#x2F;*</td><td>SalesAccessPoint</td><td>允许读写 &#x2F;sales 区域</td></tr><tr><td>Users (Analytics)</td><td>所有路径（只读）</td><td>AnalyticsAccessPoint</td><td>对整个 Bucket 只读</td></tr></tbody></table><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img510115.png"></p><ul><li>S3 – Access Points（VPC Origin）<ul><li>S3 Access Points 可配置为 仅允许来自特定 VPC 内部的访问，提高安全性与隔离性，适合私有网络内的企业应用</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img510117.png"></p><ul><li>S3 – Multi-Region Access Points（MRAP）<ul><li>Multi-Region Access Points（MRAP）提供一个 全球统一的访问入口，自动将请求路由到多个 AWS 区域中的 S3 存储桶，实现跨区域高可用、低延迟访问</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img510118.png"></p><hr><h4 id="S3-Object-Lambda"><a href="#S3-Object-Lambda" class="headerlink" title="S3 Object Lambda"></a>S3 Object Lambda</h4><ul><li>S3 Object Lambda 允许在对象被读取前，通过 AWS Lambda 实时处理对象内容，无需修改原始 S3 对象</li></ul><table><thead><tr><th>使用场景描述</th><th>示例说明</th></tr></thead><tbody><tr><td>🔒 屏蔽敏感信息（如 PII）</td><td>在分析或测试环境中自动脱敏数据（如隐藏邮箱、手机号）</td></tr><tr><td>🔄 转换数据格式</td><td>将对象从 XML 转换为 JSON，提升兼容性</td></tr><tr><td>🖼️ 实时处理图片</td><td>根据调用用户信息动态缩放图片或添加水印</td></tr></tbody></table><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img511445.png"></p><hr><h4 id="DDoS-Protection-on-AWS"><a href="#DDoS-Protection-on-AWS" class="headerlink" title="DDoS Protection on AWS"></a>DDoS Protection on AWS</h4><ul><li>DDoS Protection on AWS<ul><li>AWS 提供多层次的防护方案，结合网络架构与服务配置，可有效缓解分布式拒绝服务（DDoS）攻击带来的影响</li></ul></li></ul><table><thead><tr><th>服务&#x2F;机制</th><th>描述</th></tr></thead><tbody><tr><td>🛡️ AWS Shield Standard</td><td>默认启用，免费为所有 AWS 用户提供基础 DDoS 防护（L3&#x2F;L4 攻击）</td></tr><tr><td>🛡️ AWS Shield Advanced</td><td>付费服务，提供 24&#x2F;7 SOC 支持、攻击检测、流量分析、费用保护等高级功能</td></tr><tr><td>🌐 AWS WAF</td><td>应用层防护（L7），可自定义规则过滤恶意请求（如 IP 黑名单、SQL 注入等）</td></tr><tr><td>🚀 CloudFront &amp; Route 53</td><td>借助 AWS 全球边缘网络进行流量分发，结合 AWS Shield 可实现边缘层 DDoS 缓解</td></tr></tbody></table><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img511449.png"></p><p>选择建议总结</p><table><thead><tr><th>需求场景</th><th>推荐机制</th></tr></thead><tbody><tr><td>基本防护（无需额外配置）</td><td>AWS Shield Standard</td></tr><tr><td>面对业务关键系统&#x2F;高风险目标</td><td>AWS Shield Advanced + WAF + CDN</td></tr><tr><td>Web 应用层级访问控制</td><td>AWS WAF（结合 CloudFront 效果更佳）</td></tr></tbody></table><hr><h4 id="AWS-Shield"><a href="#AWS-Shield" class="headerlink" title="AWS Shield"></a>AWS Shield</h4><ul><li>AWS Shield 是 AWS 提供的 分布式拒绝服务（DDoS）防护服务，分为 Standard 与 Advanced 两个等级，覆盖 L3&#x2F;L4 层的攻击防护</li></ul><p>🛡️ Shield Standard vs Advanced 简要对比</p><table><thead><tr><th>特性</th><th>Shield Standard</th><th>Shield Advanced</th></tr></thead><tbody><tr><td>费用</td><td>免费</td><td>$3,000&#x2F;月</td></tr><tr><td>攻击类型支持</td><td>基础网络攻击（L3&#x2F;L4）</td><td>复杂攻击（如应用层滥用、状态耗尽等）</td></tr><tr><td>保护服务范围</td><td>所有 AWS 公网服务</td><td>限定服务（EC2、ELB、CloudFront 等）</td></tr><tr><td>DDoS 响应团队支持</td><td>❌ 无</td><td>✅ 提供 24&#x2F;7 专家支持</td></tr><tr><td>费用豁免保障</td><td>❌ 无</td><td>✅ 提供（需符合 AWS 条件）</td></tr></tbody></table><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img511450.png"></p><hr><h4 id="AWS-WAF"><a href="#AWS-WAF" class="headerlink" title="AWS WAF"></a>AWS WAF</h4><ul><li>AWS WAF 是一款 应用层防火墙（Layer 7），用于保护 Web 应用免受常见攻击如 SQL 注入、XSS、恶意请求等</li><li>注意：WAF 并非 DDoS 防护工具，但可配合 Shield 使用以提升整体防护能力</li></ul><table><thead><tr><th>部署目标</th><th>描述</th></tr></thead><tbody><tr><td>⚖️ Application Load Balancer</td><td>在 ALB 上部署区域性规则，用于 EC2、ECS、Lambda 后端</td></tr><tr><td>🌐 CloudFront</td><td>在全球边缘节点上拦截攻击（全球生效）</td></tr><tr><td>📡 API Gateway</td><td>在 REST 或 HTTP API 前部署规则（区域级或边缘）</td></tr><tr><td>🧠 AppSync</td><td>保护 GraphQL 接口，防止恶意查询</td></tr><tr><td>🧱 支持自定义源站</td><td>如 Classic Load Balancer、EC2、S3 网站托管、自建应用等</td></tr></tbody></table><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img511455.png"></p><ul><li>Web ACL（Web Access Control List）<ul><li>Web ACL 是 WAF 的核心配置单元，由一组规则组成，控制哪些请求被允许、阻止或进一步挑战</li></ul></li></ul><table><thead><tr><th>规则内容类型</th><th>说明</th></tr></thead><tbody><tr><td>🔢 IP 地址过滤</td><td>包括黑名单 &#x2F; 白名单</td></tr><tr><td>📄 HTTP 内容匹配</td><td>可基于 Header、Body、URI 进行模式匹配</td></tr><tr><td>🔍 SQL Injection &#x2F; XSS 检测</td><td>AWS 提供内建规则集可直接启用防护</td></tr><tr><td>🌍 地理位置（Geo Match）</td><td>按国家 &#x2F; 区域限制访问</td></tr><tr><td>🔁 速率限制（Rate-based）</td><td>限制同一 IP 的请求频率，防止爬虫&#x2F;爆破</td></tr><tr><td>📏 请求大小限制（Size Constraint）</td><td>限制 URI、Header、Body 的最大长度</td></tr></tbody></table><ul><li>AWS WAF – Managed Rules（托管规则集）</li><li>AWS WAF 提供超过 190 条 托管规则（Managed Rules），由 AWS 与 AWS Marketplace 合作伙伴维护，开箱即用，简化防护配置</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img511457.png"></p><ul><li>AWS WAF – Web ACL Logging（日志记录）<ul><li>WAF 支持将 Web ACL 的匹配记录导出至多种日志系统，用于 安全审计、可视化分析和合规留档</li><li>CloudWatch Logs → 用于实时分析与可视化告警（搭配 Metric Filter）</li><li>S3 → 便于合规审计、存储与 Athena 分析</li><li>Firehose → 实时流处理、集成第三方 SIEM&#x2F;可观测平台</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img511459.png"></p><hr><h4 id="AWS-Firewall-Manager"><a href="#AWS-Firewall-Manager" class="headerlink" title="AWS Firewall Manager"></a>AWS Firewall Manager</h4><ul><li>AWS Firewall Manager 是一个集中式安全策略管理服务，适用于多账户环境（如 AWS Organizations），可统一下发并自动应用网络安全规则</li></ul><table><thead><tr><th>需求场景</th><th>建议操作</th></tr></thead><tbody><tr><td>统一管理所有账户的 WAF &#x2F; Shield 策略</td><td>启用 Firewall Manager 并创建 WAF Policy</td></tr><tr><td>实现自动化合规保障</td><td>结合 SCP + Firewall Manager + Config</td></tr><tr><td>集中控制 EC2&#x2F;ALB 安全组配置</td><td>启用 Security Group Policy 管理</td></tr></tbody></table><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img511541.png"></p><ul><li>WAF vs. Firewall Manager vs. Shield</li></ul><table><thead><tr><th>服务</th><th>作用范围</th></tr></thead><tbody><tr><td><strong>AWS WAF</strong></td><td>定义 Web ACL 规则，提供资源级别的应用层（Layer 7）攻击防护</td></tr><tr><td><strong>AWS Firewall Manager</strong></td><td>用于跨账户集中管理 WAF、Shield、Security Group、Network Firewall 策略</td></tr><tr><td><strong>AWS Shield</strong></td><td>防御 DDoS 攻击，包含免费版（Standard）和高级版（Advanced）</td></tr></tbody></table><hr><h4 id="AWS-Inspecctor"><a href="#AWS-Inspecctor" class="headerlink" title="AWS Inspecctor"></a>AWS Inspecctor</h4><ul><li>Amazon Inspector 是一项自动化安全评估服务，用于检测 AWS 上资源（如 EC2、ECR、Lambda）中存在的漏洞与配置风险，并集成报告和告警流程</li></ul><table><thead><tr><th>场景描述</th><th>建议配置</th></tr></thead><tbody><tr><td>需要定期评估 EC2 主机系统与网络风险</td><td>启用 Amazon Inspector + 安装&#x2F;激活 SSM Agent</td></tr><tr><td>容器镜像安全治理</td><td>启用 ECR 推送镜像扫描，配合 Inspector 自动检测依赖漏洞</td></tr><tr><td>保障 Serverless 函数运行时安全</td><td>启用对 Lambda 函数的 Inspector 扫描</td></tr><tr><td>多工具集成与统一监控</td><td>将 Inspector Findings 发送到 Security Hub &#x2F; EventBridge</td></tr></tbody></table><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img511545.png"></p><hr><h4 id="AWS-Config"><a href="#AWS-Config" class="headerlink" title="AWS Config"></a>AWS Config</h4><ul><li>AWS Config 是一项资源审计与合规性检查服务，能持续记录和追踪 AWS 资源的配置变更，帮助满足审计、合规与运营分析需求</li></ul><table><thead><tr><th>场景</th><th>建议操作</th></tr></thead><tbody><tr><td>持续合规审计与资源追踪</td><td>启用 AWS Config + 关键规则集</td></tr><tr><td>多账户环境统一合规视图</td><td>使用 Config Aggregator 聚合所有账户合规状态</td></tr><tr><td>定制企业规则</td><td>配置自定义 Lambda 规则，与 AWS Config 集成</td></tr><tr><td>结合响应机制</td><td>配置 SNS + EventBridge 实现实时响应或自动修复流程</td></tr></tbody></table><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img511547.png"></p><ul><li>AWS Config Rules<ul><li>AWS Config Rules 用于自动检查资源是否符合期望配置，并可与 EventBridge + Lambda &#x2F; SSM 配合实现自动修复</li></ul></li></ul><table><thead><tr><th>用例描述</th><th>规则示例</th></tr></thead><tbody><tr><td>确保所有 EBS 卷类型为 gp2</td><td>自定义规则：检查 EBS 类型是否为 gp2</td></tr><tr><td>检查所有 EC2 实例是否为 t2.micro</td><td>自定义规则：实例类型为 t2.micro 才合规</td></tr><tr><td>检查安全组是否开放 0.0.0.0&#x2F;0 的 SSH 端口</td><td>使用托管规则 <code>restricted-ssh</code></td></tr><tr><td>S3 Bucket 是否关闭公有访问</td><td>使用托管规则 <code>s3-bucket-public-read-prohibited</code> 等</td></tr></tbody></table><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img511548.png"></p><hr><h4 id="AWS-Managed-Logs"><a href="#AWS-Managed-Logs" class="headerlink" title="AWS Managed Logs"></a>AWS Managed Logs</h4><ul><li>AWS 提供多种服务的 托管日志记录功能，可将关键操作、流量或访问行为记录到 S3、CloudWatch Logs 或 Kinesis 中，供后续审计、监控与分析使用</li></ul><table><thead><tr><th>目标场景</th><th>建议配置</th></tr></thead><tbody><tr><td>审计账户 API 操作</td><td>启用 CloudTrail，写入 S3 + CloudWatch Logs</td></tr><tr><td>分析网络流量与安全行为</td><td>启用 VPC Flow Logs，结合 CloudWatch Logs 或 Athena 使用</td></tr><tr><td>回溯存储访问行为</td><td>启用 S3 或 CloudFront Access Logs</td></tr><tr><td>合规监管 &#x2F; 配置变更溯源</td><td>启用 AWS Config 并将日志导出至 S3</td></tr></tbody></table><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img511550.png"></p><hr><h4 id="AWS-GuardDuty"><a href="#AWS-GuardDuty" class="headerlink" title="AWS GuardDuty"></a>AWS GuardDuty</h4><ul><li>Amazon GuardDuty 是一项基于机器学习的智能威胁检测服务，可识别 AWS 环境中的异常行为、恶意活动与潜在攻击，无需安装代理或修改资源配置</li></ul><table><thead><tr><th>场景</th><th>推荐操作</th></tr></thead><tbody><tr><td>快速启用账户级安全监控</td><td>启用 GuardDuty，默认开启 CloudTrail、VPC、DNS 分析</td></tr><tr><td>自动化安全响应</td><td>配置 EventBridge + Lambda 处理 GuardDuty Findings</td></tr><tr><td>多账户统一检测</td><td>配置 GuardDuty 管理账户（Master-Detector 架构）</td></tr><tr><td>高风险资源（如 S3、Lambda）监控</td><td>启用可选数据源如 S3 Data Events、Lambda 运行监控等</td></tr></tbody></table><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img511555.png"></p><p>⚠️ 检测示例（Findings）</p><table><thead><tr><th>威胁类型</th><th>示例描述</th></tr></thead><tbody><tr><td>💰 加密货币挖矿攻击</td><td>检测 EC2 实例疑似被劫持用于挖矿（有专用 Finding 类型）</td></tr><tr><td>🔓 被盗凭证操作</td><td>使用已泄露的 API 密钥进行非常规操作</td></tr><tr><td>🔄 反常流量模式</td><td>某实例短时间内访问大量外部 IP 或发送异常 DNS 查询</td></tr></tbody></table><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img511558.png"></p><p>📥 输入日志源</p><table><thead><tr><th>来源类型</th><th>说明</th></tr></thead><tbody><tr><td>📋 CloudTrail Events</td><td>检测异常 API 调用、未授权操作（如 createTrail、createVpc、updateSecurityGroup）</td></tr><tr><td>🪣 CloudTrail S3 Data Events</td><td>检测异常访问行为（如 getObject、listObjects、deleteObject）</td></tr><tr><td>🌐 VPC Flow Logs</td><td>分析流量模式（如端口扫描、可疑内网通信、通信异常 IP）</td></tr><tr><td>🌍 DNS 查询日志</td><td>检测域名滥用，如 EC2 通过 DNS 隐蔽传输数据（数据渗漏）</td></tr><tr><td>🧪 可选数据源</td><td>包括 EKS 审计日志、RDS、Aurora、EBS 卷行为、Lambda、S3 数据事件等</td></tr></tbody></table><ul><li>GuardDuty – Delegated Administrator（委派管理员）<ul><li>在多账户架构下，可通过 委派管理员（Delegated Administrator） 集中管理 Amazon GuardDuty，适用于 AWS Organizations</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img511559.png"></p><hr><h4 id="IAM-Conditions"><a href="#IAM-Conditions" class="headerlink" title="IAM Conditions"></a>IAM Conditions</h4><ul><li>IAM 支持通过条件（Condition）限制策略作用范围，提升权限控制的灵活性与精细度</li></ul><p>✅ 常见 IAM 条件键（Condition Keys）</p><table><thead><tr><th>条件键</th><th>功能说明</th></tr></thead><tbody><tr><td><code>aws:SourceIp</code></td><td>限制 API 请求只能从指定 IP 范围发起</td></tr><tr><td><code>aws:RequestedRegion</code></td><td>限制 API 请求只能针对特定 AWS 区域</td></tr><tr><td><code>aws:MultiFactorAuthPresent</code></td><td>强制要求请求者启用并使用 MFA（多重身份验证）</td></tr><tr><td><code>ec2:ResourceTag</code></td><td>限制操作仅适用于包含指定标签的 EC2 资源（例如强制打标签）</td></tr></tbody></table><ul><li><code>aws:PrincipalOrgID</code> 是一个可用于 资源策略（Resource Policies） 的条件，用于限制访问者必须属于某个 AWS Organization，实现跨账户但受组织边界控制的安全授权</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img213524.png"></p><hr><h4 id="IAM-for-S3"><a href="#IAM-for-S3" class="headerlink" title="IAM for S3"></a>IAM for S3</h4><ul><li>针对 S3，权限粒度划分为 Bucket 级别 与 Object 级别</li></ul><p>🪣 S3 操作权限与 ARN 示例</p><table><thead><tr><th>操作权限</th><th>ARN 示例</th><th>权限说明</th></tr></thead><tbody><tr><td><code>s3:ListBucket</code></td><td><code>arn:aws:s3:::my-bucket</code></td><td>✅ Bucket 级权限</td></tr><tr><td><code>s3:GetObject</code><br><code>s3:PutObject</code><br><code>s3:DeleteObject</code></td><td><code>arn:aws:s3:::my-bucket/*</code></td><td>✅ Object 级权限</td></tr></tbody></table><hr><h4 id="AWS-Security-Hub"><a href="#AWS-Security-Hub" class="headerlink" title="AWS Security Hub"></a>AWS Security Hub</h4><ul><li>AWS Security Hub 是一个集中化的安全与合规状态可视化平台，自动聚合来自多个 AWS 服务与第三方工具的安全发现（Findings），并支持跨账户集中管理</li></ul><p>🧰 核心功能</p><table><thead><tr><th>功能</th><th>描述</th></tr></thead><tbody><tr><td>📊 统一仪表盘</td><td>提供多账户、多服务的安全状态总览，支持快速发现问题并响应</td></tr><tr><td>🔎 安全发现聚合</td><td>自动整合来自 AWS 服务与合作厂商的 Findings（支持 AWS Security Finding Format）</td></tr><tr><td>✅ 安全检查自动化</td><td>内建对照如 CIS Benchmarks、PCI DSS 的合规性检查规则集</td></tr><tr><td>🔔 集成通知与响应</td><td>可结合 EventBridge + Lambda&#x2F;SNS 触发自动修复或提醒流程</td></tr></tbody></table><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img511603.png"></p><p>📥 支持的 AWS 服务（Findings 来源）</p><table><thead><tr><th>来源服务</th><th>检测内容示例</th></tr></thead><tbody><tr><td>🧾 AWS Config</td><td>合规规则触发、不合规配置变更</td></tr><tr><td>🛡️ GuardDuty</td><td>异常行为、恶意流量、账号滥用等</td></tr><tr><td>🔍 Inspector</td><td>主机、容器、Lambda 漏洞扫描</td></tr><tr><td>🔐 Macie</td><td>S3 中的敏感数据检测（如 PII、信用卡号）</td></tr><tr><td>👁️ IAM Access Analyzer</td><td>资源暴露、外部可访问路径发现</td></tr><tr><td>⚙️ Systems Manager</td><td>异常补丁状态、实例合规性评估</td></tr><tr><td>🔥 Firewall Manager</td><td>防火墙规则不一致、策略未应用</td></tr><tr><td>🏥 AWS Health</td><td>AWS 服务层事件影响和通知</td></tr></tbody></table><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img511604.png"></p><hr><h4 id="Amazon-Detective"><a href="#Amazon-Detective" class="headerlink" title="Amazon Detective"></a>Amazon Detective</h4><ul><li>Amazon Detective 是一款专为深入分析和调查 AWS 安全事件根因而设计的服务，结合图数据库和机器学习技术，从大量日志中构建清晰的可视化上下文</li></ul><table><thead><tr><th>场景</th><th>建议操作</th></tr></thead><tbody><tr><td>分析 GuardDuty&#x2F;Macie Findings 背后的根因</td><td>启用 Detective 并结合图形分析视图使用</td></tr><tr><td>需要追溯用户 &#x2F; 资源行为全链路</td><td>使用 Detective 的行为图谱与时间线</td></tr><tr><td>多账户环境集中调查安全事件</td><td>在管理账户中启用 Amazon Detective 并连接所有子账户</td></tr></tbody></table><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img511605.png"></p><hr><h3 id="3-Compute-amp-Load-Balancing"><a href="#3-Compute-amp-Load-Balancing" class="headerlink" title="3. Compute &amp; Load Balancing"></a>3. Compute &amp; Load Balancing</h3><h4 id="EC2"><a href="#EC2" class="headerlink" title="EC2"></a>EC2</h4><ul><li>EC2 Instance Types – 常见类别速览<ul><li>Amazon EC2 提供多种实例类型，针对不同计算、内存、存储和图形加速需求进行优化</li></ul></li></ul><p>常见主流实例族对照表</p><table><thead><tr><th>实例类型</th><th>用途场景描述</th><th>特点关键词</th></tr></thead><tbody><tr><td><code>R</code></td><td>高内存场景，如 Redis、Memcached</td><td>内存优化型（RAM 优先）</td></tr><tr><td><code>C</code></td><td>高计算需求，如批量处理、数据库</td><td>计算优化型（CPU 性能优先）</td></tr><tr><td><code>M</code></td><td>通用业务，如 Web 应用、开发环境</td><td>均衡型（“M” &#x3D; Medium）</td></tr><tr><td><code>I</code></td><td>高本地 I&#x2F;O，如 NoSQL、日志聚合数据库</td><td>存储优化型（本地 SSD）</td></tr><tr><td><code>G</code></td><td>GPU 加速需求，如深度学习、图像处理</td><td>图形&#x2F;GPU 优化型</td></tr><tr><td><code>T2 / T3</code></td><td>突发型场景，轻量 Web、测试环境</td><td>突发性能型（CPU credit 模型）</td></tr><tr><td><code>T2/T3 - unlimited</code></td><td>支持持续突发，无性能限制</td><td>超出 baseline 不限时</td></tr></tbody></table><ul><li>EC2 – Placement Groups<ul><li>Placement Groups 可用于控制 EC2 实例在 AWS 数据中心中的物理部署方式，优化网络延迟、容错能力或分布策略</li><li><code>Cluster</code>: 低延迟网络、高带宽通信</li><li><code>Spread</code>: 高可用性 &#x2F; 避免单点故障硬件依赖</li><li><code>Partition</code>: 大规模分布式系统架构部署</li></ul></li></ul><p></p><p>🧩 三种 Placement Group 策略类型</p><table><thead><tr><th>策略类型</th><th>描述</th><th>场景示例</th></tr></thead><tbody><tr><td>Cluster</td><td>实例部署在同一个可用区（AZ）的近距离硬件上，实现超低网络延迟与高吞吐量</td><td>HPC、高频交易、分布式缓存</td></tr><tr><td>Spread</td><td>实例分布在多个底层硬件（每个 AZ 最多 7 个实例），以提升容错性</td><td>关键系统（如数据库主备、前端节点）</td></tr><tr><td>Partition</td><td>实例分布在多个“分区”内，每个分区基于不同的机架组，可扩展到数百台实例</td><td>大规模分布式系统（如 Hadoop、Kafka、Cassandra）</td></tr></tbody></table><ul><li>Placement Groups – Cluster 策略<ul><li>极高的网络性能，<strong>实例间带宽可达 10 Gbps</strong>（需启用 Enhanced Networking）</li><li>非常适合需要<strong>低延迟、高吞吐量</strong>的内部通信场景</li><li>所有实例集中在同一机架组，<strong>若该机架故障，则所有实例同时宕机</strong></li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img512712.png"></p><ul><li>Placement Groups – Spread 策略 <ul><li><strong>可跨多个可用区（AZ）部署</strong></li><li>实例部署在不同的物理硬件上，<strong>大大降低同时故障的风险</strong></li><li>合关键业务场景下的<strong>实例隔离</strong></li><li><strong>每个 AZ 限制最多 7 个实例</strong>（每个 Placement Group 中）</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img512722.png"></p><ul><li>Placement Groups – Partition 策略 <ul><li>每个 <strong>可用区（AZ）最多支持 7 个分区</strong></li><li>单个分区可包含 <strong>数百个 EC2 实例</strong></li><li>同一分区内的实例共享机架，不同分区的实例<strong>物理隔离</strong></li><li><strong>分区级故障</strong> 只影响单个分区，<strong>不会波及其它分区</strong></li><li>实例可以通过 <strong>实例元数据（Metadata）获取所属分区信息</strong></li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img512724.png"></p><ul><li>EC2 Instance Launch Types（启动类型）<ul><li>EC2 提供多种实例启动方式，适用于不同业务场景和成本策略</li></ul></li></ul><p>🚀 启动类型对照表</p><table><thead><tr><th>启动类型</th><th>适用场景</th><th>特点 &#x2F; 优势</th></tr></thead><tbody><tr><td>On-Demand Instances</td><td>短期、灵活性需求</td><td>✅ 按小时&#x2F;秒计费，可靠、无承诺</td></tr><tr><td>Spot Instances</td><td>可中断型短期任务</td><td>💰 价格低至按需的 90% 折扣，⚠️ 可能随时被回收</td></tr><tr><td>Reserved Instances</td><td>长期稳定工作负载（≥1 年）</td><td>💰 提前承诺换折扣（最多 75%），支持区域或实例预定</td></tr><tr><td>Convertible Reserved Instances</td><td>长期工作负载 + 实例类型灵活</td><td>✅ 允许在期限内更换实例规格，适合不确定未来实例类型的情况</td></tr><tr><td>Dedicated Instances</td><td>需隔离硬件、提升安全性</td><td>🛡️ 仅该客户使用物理服务器的部分资源，适合合规性需求</td></tr><tr><td>Dedicated Hosts</td><td>控制实例部署 + 软件许可需求</td><td>🧩 拥有整个物理服务器资源</td></tr></tbody></table><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img512834.png"></p><ul><li>EC2 Graviton 处理器<ul><li>AWS Graviton 是基于 Arm 架构 的自研处理器系列，提供卓越的性价比与能效优势，适用于多种计算场景</li></ul></li></ul><p>🧠 处理器版本对比</p><table><thead><tr><th>版本</th><th>性能提升</th><th>特点摘要</th></tr></thead><tbody><tr><td>Graviton2</td><td>比第 5 代 x86 实例高出约 40%</td><td>最早广泛部署的高性价比 Arm 实例</td></tr><tr><td>Graviton3</td><td>比 Graviton2 快 最高 3 倍</td><td>提升浮点计算、加密、ML 推理性能，功耗更低</td></tr></tbody></table><ul><li>EC2 默认监控指标（CloudWatch Metrics）<ul><li>EC2 实例在不额外配置的情况下，会自动收集以下基础指标，适用于性能监控与状态排查</li><li>内存（RAM）使用情况不是默认指标</li></ul></li></ul><p>📊 内建指标分类（EC2 默认 CloudWatch Metrics）</p><table><thead><tr><th>维度</th><th>监控项名称</th><th>说明</th></tr></thead><tbody><tr><td>🧠 CPU</td><td><code>CPUUtilization</code></td><td>CPU 使用率（%）</td></tr><tr><td></td><td><code>CPUCreditUsage</code> &#x2F; <code>CPUCreditBalance</code></td><td>仅适用于 T 系列突发型实例</td></tr><tr><td>🌐 网络</td><td><code>NetworkIn</code> &#x2F; <code>NetworkOut</code></td><td>网络流量（字节）</td></tr><tr><td>✅ 状态检查</td><td><code>InstanceStatusCheck</code></td><td>检查 EC2 虚拟机级别问题</td></tr><tr><td></td><td><code>SystemStatusCheck</code></td><td>检查宿主机硬件和网络是否正常</td></tr><tr><td>💽 磁盘（临时存储）</td><td><code>DiskReadOps</code> &#x2F; <code>WriteOps</code><br><code>DiskReadBytes</code> &#x2F; <code>WriteBytes</code></td><td>仅适用于 Instance Store，不包含 EBS</td></tr></tbody></table><ul><li>EC2 Instance Recovery（实例恢复）<ul><li>当 EC2 实例发生系统级故障时，AWS 支持通过 自动恢复机制（Instance Recovery）将实例迁移至健康硬件上，保留原有配置不变</li><li>只有 System Status Check 失败（StatusCheckFailed_System） 时才可触发 EC2 Recovery</li></ul></li></ul><p>✅ 状态检查（Status Check）</p><table><thead><tr><th>检查类型</th><th>说明</th></tr></thead><tbody><tr><td>Instance Status</td><td>检查 EC2 实例内操作系统、网络配置等</td></tr><tr><td>System Status</td><td>检查底层硬件（如宿主物理服务器故障）</td></tr></tbody></table><hr><h4 id="High-Performance-Computing-HPC"><a href="#High-Performance-Computing-HPC" class="headerlink" title="High Performance Computing (HPC)"></a>High Performance Computing (HPC)</h4><ul><li>云计算平台（特别是 AWS）非常适合进行 高性能计算（HPC），可动态扩展、快速部署并降低成本</li></ul><p>📦 Data Management &amp; Transfer for HPC</p><table><thead><tr><th>服务</th><th>用途场景</th></tr></thead><tbody><tr><td><strong>AWS Direct Connect</strong></td><td>提供高带宽、低延迟、专线连接 AWS，适合传输 GB&#x2F;s 数据</td></tr><tr><td><strong>AWS Snowball</strong></td><td>物理设备，适合批量传输 PB 级数据 到 AWS</td></tr><tr><td><strong>AWS DataSync</strong></td><td>快速将大量数据 从本地同步到 S3、EFS、FSx</td></tr></tbody></table><p>⚙️ Compute and Networking for HPC</p><table><thead><tr><th>选项</th><th>用途说明</th></tr></thead><tbody><tr><td><strong>EC2 实例</strong></td><td>提供基础的计算资源，可选择 CPU 优化型、GPU 优化型 实例</td></tr><tr><td><strong>Spot 实例 &#x2F; Spot Fleet</strong></td><td>适用于弹性、短时批处理任务，极大降低成本，可结合 Auto Scaling 使用</td></tr><tr><td><strong>Auto Scaling</strong></td><td>根据计算需求自动扩缩 EC2 数量，适应动态负载变化</td></tr></tbody></table><p>🚀 EC2 Enhanced Networking（基于 SR-IOV）</p><table><thead><tr><th>网络类型</th><th>特性说明</th><th>适用带宽</th></tr></thead><tbody><tr><td>Elastic Network Adapter (ENA)</td><td>默认推荐，支持多种实例类型，最高 100 Gbps</td><td>✅ 高速（现代标准）</td></tr><tr><td>Intel 82599 VF (Legacy)</td><td>较旧的选项，适用于部分早期实例</td><td>⛔ 最多 10 Gbps</td></tr><tr><td>Elastic Fabric Adapter (EFA)</td><td>基于 ENA 增强，适用于 HPC，支持 MPI，绕过内核，提供超低延迟通信</td><td>✅ 高速 + 极低延迟</td></tr></tbody></table><p>📌 实例附加存储（与 EC2 紧耦合）</p><table><thead><tr><th>类型</th><th>特点</th><th>使用建议</th></tr></thead><tbody><tr><td>Amazon EBS</td><td>可持久化、可独立挂载，支持快照、加密、IOPS 调优</td><td>✅ 通用存储，如数据库磁盘、容器卷</td></tr><tr><td>- io2 Block Express</td><td>提供高达 256,000 IOPS，适合高性能场景</td><td>高性能数据库、日志系统</td></tr><tr><td>Instance Store</td><td>与 EC2 实例生命周期绑定，超低延迟，可达百万级 IOPS</td><td>临时数据缓存、HPC 临时结果</td></tr></tbody></table><p>📦 网络存储（通过网络访问）</p><table><thead><tr><th>服务</th><th>特点</th><th>适用场景</th></tr></thead><tbody><tr><td>Amazon S3</td><td>对象存储服务，支持无限扩展，不是真正的文件系统</td><td>✅ 静态文件、模型数据、备份归档等</td></tr><tr><td>Amazon EFS</td><td>分布式共享文件系统，自动扩展，按容量计费，支持 provisioned IOPS</td><td>多实例共享挂载、容器、Web 文件存储</td></tr><tr><td>Amazon FSx for Lustre</td><td>面向 HPC 优化的高并行文件系统，支持百万级 IOPS，可挂载到 S3</td><td>Genomics、渲染、AI 模型训练等 HPC 场景</td></tr></tbody></table><p>🤖 自动化与编排工具（Automation &amp; Orchestration for HPC）</p><table><thead><tr><th>工具</th><th>特点</th><th>适用场景</th></tr></thead><tbody><tr><td><strong>AWS Batch</strong></td><td>支持多节点并行作业（Multi-node Parallel Jobs），自动调度和扩缩 EC2 实例</td><td>✅ 动态批处理任务调度、分布式训练、仿真、渲染等</td></tr><tr><td><strong>AWS ParallelCluster</strong></td><td>开源集群管理工具，基于文本配置，自动创建 VPC、子网、实例类型与作业调度器</td><td>✅ 构建完整 HPC 集群（支持 Lustre、EFA、Slurm 等）</td></tr></tbody></table><hr><h4 id="Auto-Scaling"><a href="#Auto-Scaling" class="headerlink" title="Auto Scaling"></a>Auto Scaling</h4><ul><li>Auto Scaling Groups – Dynamic Scaling Policies（动态扩缩容策略）<ul><li>动态扩缩容策略可以根据实时指标或已知使用模式自动调整 EC2 实例数量，确保系统既具备弹性又避免资源浪费</li></ul></li></ul><table><thead><tr><th>策略类型</th><th>描述</th><th>示例</th></tr></thead><tbody><tr><td>🎯 Target Tracking Scaling</td><td>✅ 最简单易用，自动将实例数维持在某个目标指标附近</td><td>希望平均 CPU 利用率维持在 40%</td></tr><tr><td>📈 Simple &#x2F; Step Scaling</td><td>基于 CloudWatch 警报进行扩缩容，支持多个阈值与动作，适合精细控制</td><td>CPU &gt; 70% ➝ 扩容 2 台<br>CPU &lt; 30% ➝ 缩容 1 台</td></tr><tr><td>⏰ Scheduled Actions</td><td>预设时间点触发扩缩计划，适用于流量规律明显的场景</td><td>每周五 17:00 ➝ 设置最小容量为 10，应对周末高峰</td></tr></tbody></table><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img223430.png"></p><ul><li>Auto Scaling Groups – Predictive Scaling（预测型扩缩策略<ul><li>预测型扩缩容通过 机器学习算法分析历史负载趋势，提前预测即将到来的负载变化，并提前预热实例，从而避免响应延迟或冷启动问题</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img225447.png"></p><p>📈 推荐用于扩缩容的指标</p><table><thead><tr><th>指标名称</th><th>描述</th></tr></thead><tbody><tr><td>CPUUtilization</td><td>实例的平均 CPU 使用率，最常用的通用扩缩容指标</td></tr><tr><td>RequestCountPerTarget</td><td>每个目标实例的请求量（适用于带有负载均衡器的 Web 应用）</td></tr><tr><td>Average Network In&#x2F;Out</td><td>平均网络流入 &#x2F; 流出字节数，适合网络密集型应用（如视频流、数据传输）</td></tr><tr><td>自定义指标（Custom Metric）</td><td>可使用 CloudWatch 自行推送任意业务相关指标（如队列长度、响应时间等）</td></tr></tbody></table><ul><li>Auto Scaling – Instance Refresh<ul><li>在不完全重建 Auto Scaling Group 的前提下，自动滚动更新 EC2 实例以使用新的启动模板（Launch Template）或配置</li><li>由用户主动调用 StartInstanceRefresh, 按照指定比例逐步替换现有实例，确保服务不中断</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img515727.png"></p><ul><li>Auto Scaling – Health Checks（健康检查机制）<ul><li>Auto Scaling Group（ASG）会根据健康检查结果自动识别失效实例，并执行终止 + 替换操作，确保服务高可用</li></ul></li></ul><table><thead><tr><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>EC2 Status Checks</td><td>默认启用，检查实例自身状态（如 CPU 卡死、内核崩溃）<br>包括系统级（System）和实例级（Instance）状态检查</td></tr><tr><td>ELB Health Checks</td><td>适用于 ASG 关联了 Load Balancer（ALB &#x2F; NLB &#x2F; CLB）<br>使用 HTTP&#x2F;TCP 定期探测实例健康，贴近业务层</td></tr><tr><td>自定义健康检查（Custom）</td><td>使用 AWS CLI &#x2F; SDK 主动上报实例健康状态<br>命令示例：<code>set-instance-health</code>（将实例标记为 Unhealthy）</td></tr></tbody></table><hr><h4 id="EC2-Spot-Instances"><a href="#EC2-Spot-Instances" class="headerlink" title="EC2 Spot Instances"></a>EC2 Spot Instances</h4><ul><li>EC2 Spot 实例是一种高性价比的计算资源获取方式，可以为弹性工作负载显著节省成本。适用于对中断容忍度高的场景，例如批处理、数据分析等</li></ul><table><thead><tr><th>特性</th><th>描述</th></tr></thead><tbody><tr><td>成本极低</td><td>相较 On-Demand 实例最高可省 90%</td></tr><tr><td>自定义最大竞价</td><td>用户设定最大可接受价格，当前市场价格低于该值时获取实例</td></tr><tr><td>实时价格浮动</td><td>价格依据区域容量供需情况每小时调整</td></tr><tr><td>可配置中断行为</td><td>价格上涨超出设定时可选择 Stop &#x2F; Terminate，提前 2 分钟通知</td></tr></tbody></table><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img515752.png"></p><hr><h4 id="EC2-Spot-Fleets"><a href="#EC2-Spot-Fleets" class="headerlink" title="EC2 Spot Fleets"></a>EC2 Spot Fleets</h4><ul><li>Spot Fleet 是 AWS 提供的一种方式，用于自动管理多个 Spot 实例 + 可选的 On-Demand 实例组合，以满足你设定的计算容量目标</li><li>大规模数据处理（如 Spark、EMR）, 训练机器学习模型, 非关键但高算力密集型任务</li></ul><p>🧩 Spot Fleet 启动池（Launch Pools）示例</p><ul><li>你可以定义多个候选配置池，Spot Fleet 会从这些池中自动选择最优组合以满足策略</li></ul><table><thead><tr><th>属性</th><th>示例</th></tr></thead><tbody><tr><td>实例类型</td><td><code>m5.large</code>, <code>c5.xlarge</code></td></tr><tr><td>操作系统</td><td>Amazon Linux 2, Ubuntu</td></tr><tr><td>可用区</td><td><code>us-east-1a</code>, <code>us-east-1b</code></td></tr></tbody></table><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img515754.png"></p><hr><h4 id="AWS-ECS-Elastic-Container-Service"><a href="#AWS-ECS-Elastic-Container-Service" class="headerlink" title="AWS ECS (Elastic Container Service)"></a>AWS ECS (Elastic Container Service)</h4><ul><li>要在 AWS 上管理 Docker 容器，你可以选择以下平台</li></ul><table><thead><tr><th>服务名称</th><th>描述</th></tr></thead><tbody><tr><td>Amazon ECS</td><td>AWS 自研容器编排平台，支持 Docker，易于集成 AWS 生态</td></tr><tr><td>Amazon EKS</td><td>托管版 Kubernetes（开源），适合已有 K8s 经验的团队</td></tr><tr><td>AWS Fargate</td><td>无服务器容器运行平台（Serverless），可搭配 ECS 或 EKS 使用</td></tr></tbody></table><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img517216.png"></p><ul><li>Amazon ECS – Use Cases<ul><li>Amazon ECS 是 AWS 自研的容器编排服务，适用于从微服务架构到批处理作业的多种场景</li></ul></li></ul><table><thead><tr><th>场景类型</th><th>示例与说明</th></tr></thead><tbody><tr><td>微服务架构</td><td>部署多个容器，支持模块化服务与独立扩展</td></tr><tr><td>自动扩缩容</td><td>支持任务和服务的动态扩缩容，匹配流量需求</td></tr><tr><td>与负载均衡集成</td><td>原生集成 ALB &#x2F; NLB，自动注册目标容器</td></tr><tr><td>批处理与定时任务</td><td>使用 ECS 运行定期任务，兼容 Spot &#x2F; On-Demand 等实例类型</td></tr><tr><td>应用上云迁移</td><td>将本地 Docker 化应用无缝迁移至 ECS 平台</td></tr></tbody></table><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img517219.png"></p><ul><li>Amazon ECS – 核心概念<ul><li>Amazon ECS 采用任务驱动模型，结合服务定义与 IAM 控制，适合高可用容器化部署</li></ul></li></ul><table><thead><tr><th>概念</th><th>描述</th></tr></thead><tbody><tr><td>ECS Cluster</td><td>EC2 实例的逻辑分组，容器任务在此集群中运行（Fargate 模式下可为空）</td></tr><tr><td>ECS Service</td><td>定义运行多少个任务，如何部署与维持任务副本数</td></tr><tr><td>Task Definition</td><td>任务定义文件（JSON），描述容器镜像、CPU、内存、端口等配置</td></tr><tr><td>ECS Task</td><td>某个 Task Definition 的运行实例，即一个或多个实际运行的容器</td></tr></tbody></table><ul><li>🔐 ECS IAM 角色</li></ul><table><thead><tr><th>IAM 角色类型</th><th>用途说明</th></tr></thead><tbody><tr><td>EC2 Instance Profile</td><td>附加在 ECS 所属 EC2 上，用于访问 ECS API、CloudWatch 等服务</td></tr><tr><td>Task IAM Role</td><td>附加在具体任务上，用于访问 S3、DynamoDB 等 AWS 服务，实现任务级权限隔离</td></tr></tbody></table><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img517221.png"></p><ul><li>Amazon ECS – ALB Integration（动态端口映射）<ul><li>Amazon ECS 可通过 ALB（Application Load Balancer） 实现容器的智能路由，支持 动态端口映射（Dynamic Port Mapping）</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Users</span><br><span class="line">  ↓</span><br><span class="line">Application Load Balancer</span><br><span class="line">  ├──→ EC2 Instance: Task A (port 36789)</span><br><span class="line">  └──→ EC2 Instance: Task B (port 39586)</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img522822.png"></p><ul><li>Amazon ECS – 安全与网络配置<ul><li>ECS 提供强大的配置注入与灵活的网络选项，支持不同任务隔离级别与安全需求</li><li>可将 参数和密钥 作为环境变量注入容器</li><li>支持集成以下服务: SSM Parameter Store, Secrets Manager</li></ul></li></ul><table><thead><tr><th>网络模式</th><th>描述</th></tr></thead><tbody><tr><td><code>none</code></td><td>无网络连接，无法与外部通信，通常用于完全离线的计算任务</td></tr><tr><td><code>bridge</code></td><td>Docker 默认桥接网络模式，容器间通过虚拟网桥通信，支持端口映射</td></tr><tr><td><code>host</code></td><td>容器直接使用主机网络接口，端口冲突风险高，但性能更好</td></tr><tr><td><code>awsvpc</code></td><td>每个任务获得独立 ENI + 私有 IP，支持 Security Groups、VPC Flow Logs 等</td></tr><tr><td></td><td>➤ Fargate 的默认网络模式，也是最推荐的生产部署模式</td></tr></tbody></table><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img522829.png"></p><ul><li>Amazon ECS – Service Auto Scaling<ul><li>ECS 支持在 服务层级自动扩缩容任务（Tasks），无需人工干预</li></ul></li></ul><table><thead><tr><th>策略类型</th><th>描述</th><th>示例</th></tr></thead><tbody><tr><td>🎯 Target Tracking</td><td>设置目标值，自动追踪（最常用，推荐）</td><td>维持 CPU 利用率在 50%</td></tr><tr><td>📉 Step Scaling</td><td>绑定 CloudWatch Alarm，设置触发阈值 + 调整步进</td><td>CPU &gt; 70% ➝ 扩容 2 个任务</td></tr><tr><td>⏰ Scheduled Scaling</td><td>预设某个时间自动扩缩容，适合预测性变化</td><td>每天 9:00 设置最小任务为 5</td></tr></tbody></table><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img522831.png"></p><ul><li>Amazon ECS – Spot Instances 支持<ul><li>ECS 支持使用 Spot 实例来降低成本，具体取决于 启动方式（EC2 vs Fargate）</li></ul></li></ul><table><thead><tr><th>特性</th><th>🖥️ ECS（EC2 Launch Type）</th><th>⚙️ Fargate（含 FARGATE_SPOT）</th></tr></thead><tbody><tr><td>Spot 控制方式</td><td>通过 Auto Scaling Group 管理 Spot 实例</td><td>每个任务可指定运行在 FARGATE 或 FARGATE_SPOT</td></tr><tr><td>中断机制</td><td>实例回收前进入 Draining Mode，任务自动迁移或终止</td><td>Spot 任务可随时被 AWS 回收（无预警），需容错设计</td></tr><tr><td>成本与稳定性平衡</td><td>成本低但中断影响较大，需搭配 ASG 和多 AZ 策略应对</td><td>支持混合部署，On-Demand 保底 + Spot 弹性</td></tr><tr><td>配置与运维复杂度</td><td>需要配置 EC2、ASG、Capacity Provider 等</td><td>更加简单，Serverless，任务级别指定运行方式</td></tr><tr><td>扩展弹性</td><td>依赖 EC2 容量，扩容受限于底层资源可用性</td><td>弹性强，无需 EC2，直接根据负载水平扩缩任务</td></tr></tbody></table><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img522833.png"></p><hr><h4 id="AWS-Fargate"><a href="#AWS-Fargate" class="headerlink" title="AWS Fargate"></a>AWS Fargate</h4><ul><li>AWS Fargate 是一种 无服务器（Serverless）容器运行平台，可搭配 ECS 或 EKS 使用，无需管理底层 EC2 实例</li></ul><table><thead><tr><th>特性</th><th>描述</th></tr></thead><tbody><tr><td>无需管理 EC2</td><td>无需预配 &#x2F; 管理任何虚拟机，真正 Serverless</td></tr><tr><td>按需分配资源</td><td>你只需定义任务所需的 CPU &#x2F; 内存，Fargate 自动调度运行</td></tr><tr><td>简化扩展</td><td>只需增加任务数量即可实现扩容，无需考虑实例容量或 Auto Scaling</td></tr><tr><td>与 ECS &#x2F; EKS 集成</td><td>可作为两者的运行模式，适配不同容器编排系统</td></tr></tbody></table><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img522826.png"></p><hr><h4 id="AWS-ECR-Elastic-Container-Registry"><a href="#AWS-ECR-Elastic-Container-Registry" class="headerlink" title="AWS ECR (Elastic Container Registry)"></a>AWS ECR (Elastic Container Registry)</h4><ul><li>Amazon ECR 是 AWS 提供的托管式 Docker 镜像仓库，可安全存储、管理和部署容器镜像<ul><li>ECR ≠ DockerHub：默认私有，更适合生产部署，权限可控</li><li>若使用 CodePipeline、ECS、Fargate，建议统一使用 ECR 管理镜像</li><li>推送镜像前需执行 aws ecr get-login-password 登录命令</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img522834.png"></p><ul><li>Amazon ECR – Cross Region Replication<ul><li>Amazon ECR 支持<strong>跨区域（Cross-Region）与跨账户（Cross-Account）</strong>镜像复制，用于提升多区域可用性与部署效率</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img523114.png"></p><ul><li>Amazon ECR 镜像扫描（Image Scanning）<ul><li>ECR 支持两种镜像扫描方式，用于发现潜在的安全漏洞</li><li>手动扫描（Manual Scan）：用户在控制台或 CLI 中手动触发扫描</li><li>推送即扫（Scan on Push）：镜像推送到 ECR 时自动触发扫描</li><li>扫描类型: 基础扫描（Basic Scanning）,增强扫描（Enhanced Scanning, 结合 Amazon Inspector）</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img523117.png"></p><hr><h4 id="AWS-EKS-Elastic-Kubernetes-Service"><a href="#AWS-EKS-Elastic-Kubernetes-Service" class="headerlink" title="AWS EKS (Elastic Kubernetes Service)"></a>AWS EKS (Elastic Kubernetes Service)</h4><ul><li>Amazon EKS：全托管的 Kubernetes 服务，在 AWS 上运行容器化应用</li><li>Kubernetes：开源系统，用于 自动部署、扩展和管理容器化应用（如 Docker 应用）</li><li>EKS 是 ECS 的替代方案：目标类似（运行容器），但 API 和生态不同（ECS 是 AWS 专有，EKS 是开源标准）</li><li>支持两种运行环境: EC2, Fargate</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img523158.png"></p><ul><li>Amazon EKS – Node Types（节点类型）<ul><li>在 EKS 中，你可以选择三种方式来运行 Kubernetes Pod：托管节点、自托管节点、或 Fargate 模式</li></ul></li></ul><table><thead><tr><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>托管节点组（Managed Node Groups）</td><td>由 EKS 自动创建和管理的 EC2 实例，自动加入集群；属于 ASG，支持 On-Demand &#x2F; Spot</td></tr><tr><td>自托管节点（Self-Managed Nodes）</td><td>你自己创建和管理的 EC2 实例，手动注册至集群；更灵活但需自行维护</td></tr><tr><td>AWS Fargate</td><td>完全 Serverless；无需管理任何节点，适合按需、自动化的容器部署</td></tr></tbody></table><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img523200.png"></p><ul><li>Amazon EKS – Data Volumes（数据卷）<ul><li>在 EKS 中，持久化数据需要通过存储插件（CSI 驱动）并配合 Kubernetes 的 StorageClass 来定义卷的生命周期和类型</li><li>使用 Fargate 时，仅支持 EFS（当前不支持 EBS）</li></ul></li></ul><table><thead><tr><th>存储类型</th><th>说明</th></tr></thead><tbody><tr><td>Amazon EBS</td><td>块存储，适用于 EC2 节点；不能跨 AZ</td></tr><tr><td>Amazon EFS</td><td>网络文件系统；支持多个 Pod 并发访问；支持 Fargate</td></tr><tr><td>Amazon FSx for Lustre</td><td>高性能文件系统，适合机器学习、大数据分析等高吞吐量场景</td></tr><tr><td>Amazon FSx for NetApp ONTAP</td><td>支持企业级文件系统功能，如快照、复制、数据压缩</td></tr></tbody></table><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img523202.png"></p><hr><h4 id="AWS-App-Runner"><a href="#AWS-App-Runner" class="headerlink" title="AWS App Runner"></a>AWS App Runner</h4><ul><li>AWS App Runner 是一种全托管服务，用于轻松部署 Web 应用和 API，无需管理底层基础设施</li></ul><table><thead><tr><th>特性</th><th>描述</th></tr></thead><tbody><tr><td>无需基础设施经验</td><td>完全托管，无需管理服务器、扩展或负载均衡</td></tr><tr><td>源码 &#x2F; 镜像部署</td><td>支持从 GitHub 或 ECR 容器镜像直接部署</td></tr><tr><td>自动扩缩容</td><td>根据流量自动调整资源，无需手动配置 Auto Scaling</td></tr><tr><td>高可用 &amp; 加密</td><td>默认提供负载均衡与 TLS 加密</td></tr><tr><td>VPC 支持</td><td>可访问 RDS、ElastiCache 等 VPC 内部资源</td></tr><tr><td>URL 直接访问</td><td>部署后自动分配公开访问地址</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1️⃣ Source Code / Container Image (ECR)</span><br><span class="line">        ↓</span><br><span class="line">2️⃣ 配置：vCPU、RAM、Auto Scaling、Health Check</span><br><span class="line">        ↓</span><br><span class="line">3️⃣ 创建并部署（Create &amp; Deploy）</span><br><span class="line">        ↓</span><br><span class="line">4️⃣ 获得访问 URL，立即可用</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img523204.png"></p><hr><h4 id="ECS-Anywhere-amp-EKS-Anywhere"><a href="#ECS-Anywhere-amp-EKS-Anywhere" class="headerlink" title="ECS Anywhere &amp; EKS Anywhere"></a>ECS Anywhere &amp; EKS Anywhere</h4><ul><li>Amazon ECS Anywhere<ul><li>让你能在本地数据中心、虚拟机或其他自管基础设施上运行原生 ECS 任务，结合云端控制面板与本地执行能力</li><li>满足 合规性 &#x2F; 数据本地化 &#x2F; 低延迟 要求, 运行在 无 AWS 区域覆盖的地方</li><li>本地机器学习、视频处理、大数据分析 等边缘计算需求</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img523209.png"></p><ul><li>Amazon EKS Anywhere<ul><li>EKS Anywhere 允许你在 本地或其他云环境中创建并运行 Kubernetes 集群</li><li>想保留 本地运行环境，但又想用上 EKS 管理体验</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img523210.png"></p><hr><h4 id="AWS-Lambda"><a href="#AWS-Lambda" class="headerlink" title="AWS Lambda"></a>AWS Lambda</h4><ul><li>AWS Lambda 是一种 无服务器计算服务，让你只需写代码，不用管服务器。你上传函数，设置触发条件，AWS 自动运行它</li><li>AWS Lambda 可无服务器执行函数，常被以下服务触发或与之集成</li></ul><table><thead><tr><th>服务名称</th><th>触发 &#x2F; 集成方式说明</th></tr></thead><tbody><tr><td>API Gateway</td><td>通过 HTTP 请求触发 Lambda，常用于构建无服务器 API</td></tr><tr><td>Amazon S3</td><td>对象创建 &#x2F; 删除触发（如上传图片自动处理）</td></tr><tr><td>Amazon DynamoDB</td><td>表更新事件触发（使用 DynamoDB Streams）</td></tr><tr><td>Amazon Kinesis</td><td>流式数据处理，如日志分析、实时计算</td></tr><tr><td>Amazon EventBridge</td><td>基于事件总线实现复杂事件驱动架构 (CRON JOB)</td></tr><tr><td>Amazon SQS</td><td>从消息队列中拉取消息处理</td></tr><tr><td>AWS IoT Core</td><td>设备消息触发 Lambda</td></tr><tr><td>AWS Cognito</td><td>用户注册、登录等事件触发 Lambda（如验证逻辑）</td></tr><tr><td>CloudWatch Logs</td><td>可配合日志处理 &#x2F; 告警</td></tr><tr><td>AWS SNS</td><td>订阅 SNS 主题，处理发布消息</td></tr></tbody></table><ul><li>AWS Lambda 限制<ul><li>内存（RAM）：最小 128MB，最大 10GB</li><li>CPU：不能手动设置，跟内存挂钩</li><li>最长运行时间：15 分钟</li><li>部署包限制：ZIP 格式最大 50MB，解压后 + Layer 总共不能超过 250MB</li><li>并发执行数：默认 1000（可以申请提高）</li><li>容器镜像大小：最大 10GB</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img523230.png"></p><ul><li>Lambda 并发与限流（Concurrency &amp; Throttling）<ul><li>默认并发限制是 1000 个，也就是最多同时跑 1000 个函数实例</li><li>可以给某个函数设置 Reserved Concurrency，意思是给它专门留几个名额</li><li>一旦请求超出这个并发限制，就会触发 Throttle（被限流），导致调用失败或延迟</li><li>如果不够用，可以去 Service Quotas 页面申请提高并发上限</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img523248.png"></p><ul><li>Lambda 并发问题（Concurrency Issue）<ul><li>如果你不设置 Reserved Concurrency，就默认大家一起抢那 1000 个并发名额</li><li>用户多的时候，像 API Gateway、ALB（负载均衡器） 都可能因为没抢到资源而 被限流（Throttle）</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img523313.png"></p><ul><li>Lambda &amp; CodeDeploy 简介<ul><li>AWS CodeDeploy 可以帮你自动管理 Lambda 的流量切换，实现平滑部署（渐进式发布），防止直接上线出问题</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img225541.png"></p><hr><h4 id=""><a href="#" class="headerlink" title=""></a></h4>]]></content>
      
      
      <categories>
          
          <category> Certification </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AWS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>伊利诺伊州交规</title>
      <link href="/posts/80b8adf.html"/>
      <url>/posts/80b8adf.html</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.ilsos.gov/publications/pdf_publications/dsd_a112.pdf">ILLINOIS RULES OF THE ROAD 2025 链接</a></p><h3 id="1-交通法规"><a href="#1-交通法规" class="headerlink" title="1. 交通法规"></a>1. 交通法规</h3><h4 id="被警察拦下时该怎么做"><a href="#被警察拦下时该怎么做" class="headerlink" title="被警察拦下时该怎么做"></a>被警察拦下时该怎么做</h4><ul><li><p>慢慢减速，打转向灯，安全地<ins>靠右</ins>停车</p><ul><li>如果路肩太窄或没有路肩，就继续慢慢开，<ins>找到安全的位置再停车</ins></li><li>不要突然急刹车或停在车道中间</li></ul></li><li><p>停车后，双手放在方向盘上，保持可见</p></li><li><p>未经允许，不要下车</p></li><li><p>配合警察检查驾驶证和保险证明</p><ul><li>如果证件在手套箱、座位下，或手机里，<ins>提前告诉警察</ins>，等他同意后再去拿</li></ul></li><li><p>如果不确定是警车或警察</p><ul><li>保持低速、安全行驶</li><li><ins>开到灯光明亮、人多的地方再停车</ins></li><li>慢慢开到最近的警察局，寻求穿制服警察帮助</li><li><ins>拨打911确认</ins></li></ul></li><li><p>如果是晚上被拦</p><ul><li>可以打开车内灯，让警察看到车内情况，增加安全感</li></ul></li></ul><hr><h4 id="交通拦截导致开罚单或被逮捕"><a href="#交通拦截导致开罚单或被逮捕" class="headerlink" title="交通拦截导致开罚单或被逮捕"></a>交通拦截导致开罚单或被逮捕</h4><ul><li><p>不要当场和警察争论或辩解</p><ul><li><ins>无论你觉得自己有没有错，不要在现场争执，可以后续去法庭申诉</ins></li></ul></li><li><p>如果收到罚单，不要拒绝签字</p><ul><li><ins>签字只是确认收到罚单，不是承认你有罪</ins></li></ul></li><li><p>保持配合，礼貌对待警察</p></li><li><p>如果被逮捕，不要反抗</p><ul><li>反抗逮捕（比如挣脱、推搡）会让你面临更多罪名，后果严重</li></ul></li><li><p>警察必须尊重你的尊严，不得无礼或滥用权力</p></li><li><p>如果你觉得警察行为不当（比如态度恶劣、滥权），应该</p><ul><li>尽快向警方上级举报</li><li><ins>警察必须提供姓名和警号，如果你要求</ins></li><li>可以向<strong>内部事务部门（Internal Affairs）或民众投诉委员会（Civilian Complaint Board）</strong>提出书面投诉</li></ul></li></ul><hr><h4 id="分心驾驶"><a href="#分心驾驶" class="headerlink" title="分心驾驶"></a>分心驾驶</h4><ul><li><p>禁止开车时手持手机，即使开扬声器</p></li><li><p>禁止发短信或使用其他电子通讯设备（如平板、笔记本等）</p></li><li><p>禁止佩戴耳机（只允许单边使用）</p></li><li><p>允许的行为（有限制）</p><ul><li>19岁及以上驾驶员可以使用 免提设备（hands-free），如蓝牙、语音助手</li></ul></li><li><p>唯一允许手持手机的情况（例外）</p><ul><li><ins>报告紧急情况（如报警、求救）</ins></li><li>车辆停在路肩上，安全状态</li><li>因正常交通阻塞导致停车，且挂空挡或停车挡（如遇红灯时，不允许拿手机，只有真正完全停住且挂P或N挡才行）</li></ul></li></ul><hr><h4 id="安全带法规"><a href="#安全带法规" class="headerlink" title="安全带法规"></a>安全带法规</h4><ul><li>所有8岁及以上的司机和乘客（不论前排还是后排），都必须系安全带</li><li>8岁以下的儿童 必须使用符合规定的 儿童安全座椅</li></ul><hr><h4 id="伊利诺伊州限速规定"><a href="#伊利诺伊州限速规定" class="headerlink" title="伊利诺伊州限速规定"></a>伊利诺伊州限速规定</h4><p>道路限速规定（除非另有标示）</p><ul><li>州际公路和收费公路（Interstates and Tollways）：最高限速 70 mph</li><li>四车道公路（Highways with Four Lanes）：最高限速 65 mph</li><li>其他公路和乡村道路（Other Highways and Rural Areas）：最高限速 55 mph</li><li>城市&#x2F;城镇地区（City&#x2F;Town Areas）：最高限速 30 mph</li><li>小巷（Alleys）：最高限速 15 mph</li><li>学校区域（School Zones）：最高限速 20 mph（仅在上学日 6:30 a.m. 至 4 p.m.，且孩子在场且有标志的情况下）</li></ul><p>以下情形必须减速</p><ul><li>接近或穿越路口：为了避免与其他车辆或行人相撞</li><li>转弯或绕弯：控制车速，防止转弯时失控</li><li>上坡或接近坡顶：防止突然遇到看不见的对向车辆或障碍物</li><li>行驶在狭窄或曲折的道路上：保障行车安全和可控性</li><li>遇到行人、自行车、恶劣天气、机械故障或糟糕路况时：减少事故风险，防止发生意外</li></ul><hr><h4 id="工地区域驾驶规定"><a href="#工地区域驾驶规定" class="headerlink" title="工地区域驾驶规定"></a>工地区域驾驶规定</h4><ul><li>减速慢行: 进入或靠近施工&#x2F;养护区域时必须减速，确保安全</li><li>禁止使用手机</li><li>为施工车辆和工人让行</li><li>变道避开施工人员: 如果条件允许，应该变道远离施工人员所在的车道</li><li>工地限速全天有效，不管有没有工人在现场</li></ul><hr><h4 id="应急车辆"><a href="#应急车辆" class="headerlink" title="应急车辆"></a>应急车辆</h4><p>遇到停在路边的应急车辆（开启警示灯）</p><ul><li>如果看到<ins>停靠路边</ins>且开启闪烁警示灯（蓝色、红色、橙色、白色、绿色，旋转或闪烁灯）的车辆，或现场出现这些灯光的紧急场景，驾驶人必须<ul><li>减速慢行或让行</li><li>变道远离，如果无法变道，必须减速并特别小心通过</li><li>保持减速状态，直到完全通过该区域</li><li>禁止在距离500英尺（约152米）内 拍照或使用手机，除非特殊情况（如报警）</li></ul></li></ul><p>遇到行驶中的应急车辆（鸣笛+闪灯）</p><ul><li><p>当应急车辆（如救护车、消防车、警车等）鸣响警笛并闪灯接近时</p><ul><li><ins>立刻靠右停车</ins>，为其让路</li><li>视情况完全停车，确保应急车辆可以安全通过</li><li>如果在十字路口等红灯，保持停车状态，直到应急车辆完全通过路口</li></ul></li><li><p>其他特殊规定</p><ul><li>禁止压过消防水管，除非得到现场消防指挥官的许可</li></ul></li></ul><hr><h4 id="学校区域驾驶规"><a href="#学校区域驾驶规" class="headerlink" title="学校区域驾驶规"></a>学校区域驾驶规</h4><ul><li>在上学日 6:30 a.m. - 4:00 p.m.，如果有孩子在场，必须减速到 20 mph、禁止手持手机、停车让人先行，确保儿童安全<ul><li>限速 20 mph</li><li>停车让行: 必须停车让行给所有在斑马线上的儿童或成年人</li></ul></li></ul><hr><h4 id="送葬队伍驾驶规定"><a href="#送葬队伍驾驶规定" class="headerlink" title="送葬队伍驾驶规定"></a>送葬队伍驾驶规定</h4><ul><li><p>所有参与送葬队伍的车辆应打开大灯和危险警示灯（双闪灯），以示识别</p><ul><li>有一辆领头车辆（通常是一辆挂着闪光灯和葬礼旗帜的黑色轿车），后面跟着灵车，然后是载有亲朋好友的车辆，所有车辆都打开了前灯和可能的危险警告灯</li></ul></li><li><p>必须让行，不得插队进入送葬车队中间，靠右停车</p></li><li><p>不得穿插队伍，不得尾随或借送葬队伍占道</p></li></ul><hr><h4 id="让路规定"><a href="#让路规定" class="headerlink" title="让路规定"></a>让路规定</h4><ul><li><p>驾驶员必须让路的情况</p></li><li><ol><li><ins>红灯右转时，在完全停车后必须让行</ins></li></ol></li><li><ol start="2"><li>在<code>STOP</code>标志或红灯闪烁信号处 (闪烁的红灯) 完全停车后</li></ol><ul><li>若无停止线，停在人行横道前</li><li>无人行横道或停止线时，停在能看到来车的位置</li></ul></li><li><ol start="3"><li><ins>红灯下，从单行道左转到另一条单行道，且有车辆向左行驶时</ins>，让行 (Figure A)</li></ol></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img035426.png"></p><ul><li><ol start="4"><li>四路停车（四方停，四向 STOP）路口</li></ol><ul><li>谁先停，谁先走</li><li><ins>如果同时到达，左侧车辆让右侧车辆先行</ins> (Figure B)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img035426.png"></p><ul><li><ol start="5"><li>当进入<ins>有闪烁黄色箭头</ins>的路口时</li></ol></li><li><ol start="6"><li>无人管控的普通路口，<ins>左侧车辆让右侧车辆先行</ins></li></ol></li><li><ol start="7"><li>左转时遇对面来车，必须等来车通过或让行</li></ol><ul><li><ins>如果在绿灯亮时进入路口，即使灯变成红灯，您也可以完成转弯</ins></li></ul></li><li><ol start="8"><li>遇到<code>MERGE</code>合流标志时，调整车速避让主路车辆，避免碰撞</li></ol></li><li><ol start="9"><li>遇到<code>YIELD</code>让行标志时，减速或停车避让，确保安全</li></ol></li><li><ol start="10"><li>绿灯时，如果路口内有车未清空，必须等待 (针对第7点)</li></ol></li><li><ol start="11"><li>从 巷子、建筑物、私人道路或车道出来时，先停车，后让行 (Figure C)</li></ol></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img035426.png"></p><ul><li><ol start="12"><li>在“T字路口”准备进入主路时（主路无任何交通标志或信号灯），让行主路所有车辆 (Figure D)</li></ol></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img035426.png"></p><ul><li><ol start="13"><li>遇到鸣笛+闪灯的应急车辆 (救护车)，必须让行</li></ol></li></ul><p>禁止行为</p><ul><li>如果前方没有足够的空间让车顺利通过整个路口，就不可以开进路口<ul><li>前面堵车或者行人过马路，被堵住，挡住其他方向来车或者行人道上的行人</li></ul></li><li>不得驶入铁路道口（火车道），除非前方有空间安全通过<ul><li>开车来到铁路道口，前面排了很多车，车队移动得很慢</li></ul></li></ul><hr><h4 id="行人优先权规定"><a href="#行人优先权规定" class="headerlink" title="行人优先权规定"></a>行人优先权规定</h4><ul><li><p>必须停车让行的情况（完全停车 并 让行人先过）</p><ul><li>行人在有标线的人行横道内时（Marked Crosswalk）</li><li>学校区域内的斑马线附近有儿童时，尤其在上学日</li><li>有残疾人士（包括肢体、听力或视力障碍）过马路时</li></ul></li><li><p>必须减速或停车让行的其他情况</p><ul><li>没有红绿灯管控的无标线人行横道</li><li>在任何路口转弯时</li><li>红灯允许右转时，转弯前必须先停车，并让行人先过</li><li>在<code>STOP</code>停止标志或红灯闪烁处停车后，如果有行人，必须让行人先走</li><li>行人在交通灯变灯前已进入人行横道时，必须等行人先过完</li><li>在闪烁黄色箭头的路口转弯时，让行人先过</li></ul></li></ul><hr><h4 id="超车规定"><a href="#超车规定" class="headerlink" title="超车规定"></a>超车规定</h4><p>两车道公路上超车</p><ul><li><p>左侧车道必须清晰可见，且没有迎面来车，确保有足够距离完成超车</p></li><li><p><ins>超车完成后，必须等到被超车辆在你的后视镜里完全可见，才可以安全返回原车道</ins> (意思就是超车过后不能马上改变车道回去)</p></li><li><p>在与迎面车辆相距 200 英尺内，必须回到自己的车道，不得继续占用对面车道超车</p></li><li><p>被超车辆不得加速，必须配合你完成超车动作</p></li><li><p>禁止通过闪灯或打转向灯提醒对方“可以超车”，这种做法违法</p></li><li><p>禁止开车压路肩或驶离主道进行超车，不论是左边还是右边</p></li></ul><p>哪些情况下可以从右侧超车</p><ul><li>前车准备左转或正在左转，你右侧有足够空间</li><li>单行道，或每个方向有两条或以上车道的道路</li><li>为超车而拓宽的路口区域</li></ul><p>禁止超车的情况</p><ul><li>在道路中间是黄色实线或有“禁止超车”(<code>DO NOT PASS</code>)标志的区域</li><li>在上坡或弯道，无法清楚看到对向来车的地方</li><li>在距离交叉路口或铁路道口100英尺以内</li><li>在桥梁、天桥或隧道中，如果视线受阻，且距离障碍物不足100英尺</li><li>当前方车辆因让行人而停在斑马线或路口时</li><li>在施工区域，无论有无标志，一律禁止超车</li><li>在郊区（非市区）的学校区域内</li><li>在市区内有标示的学校区域</li><li>当校车停靠上下学生，且停车标志臂伸出、红灯闪烁时</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img316518.png"></p><hr><h4 id="车道使用"><a href="#车道使用" class="headerlink" title="车道使用"></a>车道使用</h4><ul><li><p><ins>通常情况下: 必须靠右侧行驶</ins>，除非符合以下例外情况</p></li><li><p>允许不靠右侧行驶的情况</p><ul><li>超车时: 在两车道或高速公路&#x2F;受控高速公路上，超车时可以占用左车道</li><li>右侧被阻挡: 遇到障碍（如停着的车、路障），必须让行对向车辆后，绕道左侧行驶</li><li>道路划分为三条车道: 按照车道标线分流，不一定非要靠右</li><li>单行道: 有两条及以上车道时，可在任一车道行驶</li><li>交通标志指示: 多车道双向公路上，如果有交通标志指示需使用左车道，按规定行驶</li><li>左转时: 从巷子、私人道路、车道左转进入马路，或准备左转时</li><li>避让紧急或故障车辆: 遇到停在路边的应急车辆或故障车辆，须变更至左车道避让</li><li>右侧施工: 道路右侧施工或封闭时，须进入左车道</li></ul></li><li><p><ins>高速公路&#x2F;受控高速公路特别规定: 左车道仅用于超车</ins>，除非以下情况</p><ul><li>交通状况&#x2F;拥堵使右车道行驶不切实际</li><li>天气状况使您必须使用左车道</li><li>右车道有障碍物或危险</li><li>您正在变道以让路给紧急车辆或施工车辆</li></ul></li></ul><hr><h4 id="转向灯规定"><a href="#转向灯规定" class="headerlink" title="转向灯规定"></a>转向灯规定</h4><ul><li><p>打灯的两种方法</p></li><li><p>电子转向灯: 右转 ➡️ 打右转灯，左转 ⬅️ 打左转灯</p></li><li><p>手势信号（Hand and Arm Signals）（如电子灯坏了时必须使用）</p><ul><li>右转: 左手向上举，手掌平伸，呈90度直角向上</li><li>左转: 左手平直伸向左侧</li><li>减速或停车: 左手向下伸，手掌朝后，垂直向下</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img316515.png"></p><hr><h4 id="转弯、变道、掉头"><a href="#转弯、变道、掉头" class="headerlink" title="转弯、变道、掉头"></a>转弯、变道、掉头</h4><p>右转规定</p><ul><li>从正确的右转车道打右转灯</li><li>观察左侧来车，确保安全</li><li><ins>转入您要进入的道路的右侧车道</ins></li></ul><p>左转规定</p><ul><li>从正确的左转车道打左转灯</li><li>观察所有方向的来车，确认安全</li><li><ins>完成转弯，进入最接近预定方向的车道</ins></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img316624.png"></p><p>变道规定</p><ul><li>从右向左变道时<ul><li>回头查看左后方盲区，确认没有来车</li><li>打左转灯示意变道意图</li><li>在确保安全的情况下，缓慢而平稳地变道</li></ul></li><li>从左向右变道时<ul><li>回头查看右后方盲区，确认没有来车</li><li>打右转灯示意变道意图</li><li>在确保安全的情况下，缓慢而平稳地变道</li></ul></li></ul><p>掉头规定</p><ul><li>除非您能看到至少 500 英尺的各个方向，否则您不得在弯​​道和山丘上掉头。市政当局可能禁止在某些道路上掉头</li></ul><p>危险信号</p><ul><li>同时打开左右转向灯（双闪灯），表示故障车辆或临时停靠车辆，用于警示其他司机注意避让</li></ul><p>双向左转车道</p><ul><li>路中间划有左右双向箭头的专用左转区，专供等候左转进&#x2F;出道路、巷子、车道</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/imgimage002.jpg"></p><hr><h4 id="环形交叉口"><a href="#环形交叉口" class="headerlink" title="环形交叉口"></a>环形交叉口</h4><ul><li><p>环形交叉口: 一种绕中心岛以逆时针方向（Counter-clockwise）行驶的交叉路口</p><ul><li><ins>进入和离开环岛时，必须让行所有车辆、行人和自行车</ins></li></ul></li><li><p>通过环形交叉口步骤</p><ul><li>减速慢行，准备进入环岛</li><li>观察交通标志和地面标线，注意是否有禁止某些方向的提示</li><li>当安全时，向右进入环岛</li><li>保持在自己的车道，不随意换道</li><li>准备离开环岛时打右转灯，告知其他车辆你将出口</li></ul></li></ul><hr><h4 id="特殊停车规定"><a href="#特殊停车规定" class="headerlink" title="特殊停车规定"></a>特殊停车规定</h4><ul><li><p>校车（School Buses）停车规定</p><ul><li><ins>当校车停靠上下乘客、开启闪光灯、伸出停车标志牌时，双向来车和同向跟车都必须停车，直到停车标志收回、闪光灯熄灭、或司机示意可以通行</ins></li></ul></li><li><p>铁路道口（Railroad Crossings）停车规定</p><ul><li>距离铁轨 15-50英尺 内停车，以下情况: 有停车标志、闪光电灯开启、栏杆放下、火车临近&#x2F;发出警告</li><li>无提示设备（仅有铁路交叉标志）的处理: 减速，观察两侧轨道，听声音，确认无火车，再通过</li><li>如果车被卡在轨道: 立刻下车，以与火车成 45 度角的方向逃离，拨打 911</li></ul></li><li><p>巷道&#x2F;车道出口（Alleys&#x2F;Driveways）停车规定</p><ul><li>完全停车，让行人、车辆优先</li></ul></li></ul><hr><h4 id="停车规则"><a href="#停车规则" class="headerlink" title="停车规则"></a>停车规则</h4><p>坡道停车</p><ul><li>在坡道停车时，必须正确调整车轮方向，以防车辆滑动<ul><li><ins>下坡时（有路缘）：将前轮朝向路缘，这样如果车辆滑动，会被路缘挡住</ins></li><li><ins>上坡时（有路缘）：将前轮远离路缘，让车轮靠住路缘，防止车辆后滑</ins></li><li><ins>上坡或下坡时（无路缘）：将前轮朝向路边，以确保滑动时不会冲入车道</ins></li></ul></li><li>停车后，务必挂P档（自动挡）或手刹（手动挡），并拉起手刹，确保车辆固定。在启动车辆离开时，检查来车，释放手刹，打开转向灯后安全驶离</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img224340.png"></p><p>平行停车</p><ul><li>在双向车道停车时，车辆的右侧车轮必须距离路缘不超过12英寸。在单行道上停车时，可以停在道路的任意一侧，但必须与车辆行驶方向一致</li></ul><p>残疾人停车位</p><ul><li>残疾人专用停车位仅限持有有效残疾人停车证或残疾人车牌的车辆使用。</li></ul><p>电动车停车位</p><ul><li>一些停车场设有电动车专用停车位，通常配备充电桩。这些车位仅供电动车使用，普通燃油车不得占用，否则可能会面临罚款或拖车处理</li></ul><hr><h4 id="禁止停车、停留或临时停车的规定"><a href="#禁止停车、停留或临时停车的规定" class="headerlink" title="禁止停车、停留或临时停车的规定"></a>禁止停车、停留或临时停车的规定</h4><p>在某些地点禁止停车、停留（短暂停靠）或临时停车，即使没有标志，也必须遵守相关规定。此外，各地政府可能会设立额外的停车限制，需要注意交通标志指示</p><ul><li>停在已停放车辆旁 (就是停在已经停着的车的旁边)</li><li>人行道、斑马线或交叉路口内</li><li>安全区域（如公交站台）与路缘之间</li><li>自行车道内（包括划线、自行车缓冲区或用护栏隔开的车道）</li><li>靠近施工区域或任何可能阻碍交通的位置</li><li>桥梁、天桥、铁路轨道或公路隧道内</li><li>高速公路或受控公路（只能在指定入口或出口上下）</li><li>分隔公路的中央隔离带（包括用于紧急掉头的区域）</li></ul><p>禁止停车或临时停留（即使车上有人）的地点</p><ul><li>公共或私人车道前（不能挡住进出）</li><li>消防栓 15 英尺范围内</li><li>消防站出入口 20 英尺范围内，以及交叉路口的斑马线 20 英尺内</li><li>STOP 标志、YIELD 标志或红绿灯 30 英尺范围内</li><li>铁路道口 50 英尺范围内</li></ul><hr><h4 id="额外交通法规"><a href="#额外交通法规" class="headerlink" title="额外交通法规"></a>额外交通法规</h4><ul><li>不得向行驶车辆投掷物品</li><li>禁止驶上人行道，除非该人行道是车道的一部分，例如私人车道的出入口</li><li>不得超载</li><li>不得制造噪音污染</li></ul><hr><h3 id="2-道路共用"><a href="#2-道路共用" class="headerlink" title="2. 道路共用"></a>2. 道路共用</h3><h4 id="与行人共用道路"><a href="#与行人共用道路" class="headerlink" title="与行人共用道路"></a>与行人共用道路</h4><p>在法律中，“行人”不仅指走路的人，还包括</p><ul><li>使用滑板、<strong>轮滑（in-line speed skates）</strong>的人</li><li>使用轮椅、导盲犬、白手杖等辅助工具的残障人士</li><li>行动不便、视力或听力受限者也都属于行人</li></ul><p>行人与驾驶员的共同责任</p><ul><li>行人与驾驶员都应为交通安全负责</li><li>驾驶员应始终准备让行人优先通行，尤其不要贴太近</li></ul><hr><h4 id="儿童与交通安全"><a href="#儿童与交通安全" class="headerlink" title="儿童与交通安全"></a>儿童与交通安全</h4><p>驾驶员须注意</p><ul><li>特别注意危险区域标志：如学校区域、校车上下客点、游乐场、公园等，这些都是儿童高频出没区域</li><li>在居民区、学校周边或有孩子可能出现的地方，务必提前减速、保持警觉</li><li>倒车进出车道时，尤其要小心，儿童个子矮小，容易出现在盲区</li><li>留意突然跑出马路的孩子，不要指望孩子知道交通规则，要靠你防范</li></ul><hr><h4 id="与摩托车共用道路"><a href="#与摩托车共用道路" class="headerlink" title="与摩托车共用道路"></a>与摩托车共用道路</h4><p>摩托车和其他机动车享有相同的通行权利与责任，但由于摩托车体积小、缺乏保护、容易受伤，驾驶员应给予特别注意</p><ul><li>很多摩托车事故发生的原因是：驾驶员没有看到摩托车，或低估了摩托车的速度</li><li>超过50%的摩托车事故发生在交叉路口, 最常见情形是：汽车左转时，撞上对向直行的摩托车</li><li>当摩托车从你身边超车时，你应<ul><li>保持原车道，不要向一侧挪动</li><li>保持当前车速</li><li>等摩托车完成变道，留出空间</li></ul></li></ul><hr><h4 id="故障车辆处理规定"><a href="#故障车辆处理规定" class="headerlink" title="故障车辆处理规定"></a>故障车辆处理规定</h4><p>靠近故障车辆时该怎么做</p><ul><li>当你在四车道高速公路上遇到一辆开启双闪灯的抛锚车辆时<ul><li>如果安全可以变道：必须变道远离故障车</li><li>如果不能变道：应减速通过，不要高速从旁边驶过</li><li>直到完全超过该车辆后，才可以恢复原本车速</li></ul></li></ul><p>禁止的行为</p><ul><li>不得在乡村公路上推车，除非是紧急情况，且必须尽快将其移除以避免造成危险</li><li>不得移走事故车辆时留下碎玻璃或残骸。必须将所有碎片清理干净</li><li>车辆之间拖车必须使用连接杆（drawbar）。在多数情况下<ul><li>拖车距离不得超过 15 英尺</li><li>必须使用 两根链条或缆绳将拖车固定连接</li></ul></li></ul><hr><h3 id="3-酒后驾驶-DUI"><a href="#3-酒后驾驶-DUI" class="headerlink" title="3. 酒后驾驶 (DUI)"></a>3. 酒后驾驶 (DUI)</h3><h4 id="血液酒精浓度"><a href="#血液酒精浓度" class="headerlink" title="血液酒精浓度"></a>血液酒精浓度</h4><p>什么是 BAC</p><ul><li>BAC（Blood-Alcohol Concentration）是指血液中的酒精浓度，可以通过以下方式测量<ul><li>呼气测试, 血液检测, 尿液检测</li></ul></li></ul><p>BAC 与 DUI 的法律底线</p><ul><li>如果你的 BAC ≥ 0.08%，驾驶即违法</li><li>即使 BAC &lt; 0.08%，只要酒精影响了你的驾驶能力，也可能被认定为酒驾（DUI）</li></ul><hr><h4 id="DUI-法律详解"><a href="#DUI-法律详解" class="headerlink" title="DUI 法律详解"></a>DUI 法律详解</h4><p>在伊利诺伊州，酒驾（DUI）被认定为暴力犯罪<br>一旦被判定为 DUI，记录将永久保留在你的驾驶记录上</p><p>默示同意法（Implied Consent Law）</p><ul><li>你只要在伊州开车，就自动同意接受下列检测<ul><li>呼气测试, 血液测试, 尿液或其他体液测试</li></ul></li></ul><p>法定摘要性吊销</p><ul><li>检测结果达到以下标准将被吊销驾照<ul><li>BAC ≥ 0.08%</li><li>THC ≥ 5 ng&#x2F;mL（血液）或 ≥ 10 ng&#x2F;mL（其他体液）</li><li>检测出任何受控药物&#x2F;致幻化合物&#x2F;冰毒</li></ul></li></ul><hr><h4 id="DUI-相关违法行为"><a href="#DUI-相关违法行为" class="headerlink" title="DUI 相关违法行为"></a>DUI 相关违法行为</h4><p>加重酒驾（Aggravated DUI）</p><ul><li>你在以下情况下将被起诉为加重酒驾（Aggravated DUI），处罚远重于普通 DUI<ul><li>酒驾时发生致人死亡或人身伤害</li><li>是第三次或以上 DUI 犯罪</li><li>酒驾时没有有效驾照、许可证或保险</li></ul></li></ul><p>酒精饮品的非法运输 &#x2F; 开放容器法（Open Container Law）</p><ul><li>任何人在车内饮酒都是违法行为，包括司机与乘客</li><li>开封的酒精饮料不得放在乘客区，即使不喝也违法</li></ul><p>父母或监护人责任（Parental Responsibility）</p><ul><li>禁止让未满21岁者饮酒；</li><li>不得纵容或未控制孩子在自家或自己管理的场所饮酒（包括车辆或船上）</li></ul><p>协助酒驾也违法（Contributing to a DUI）</p><ul><li>你不得把车借给已知正在酒驾的人</li><li>若你向未满21岁者提供酒精，你可能会被判刑入狱</li></ul><hr><h3 id="4-交通违规-x2F-事故处理"><a href="#4-交通违规-x2F-事故处理" class="headerlink" title="4. 交通违规 &#x2F; 事故处理"></a>4. 交通违规 &#x2F; 事故处理</h3><h4 id="发生或遇到交通事故时怎么办"><a href="#发生或遇到交通事故时怎么办" class="headerlink" title="发生或遇到交通事故时怎么办"></a>发生或遇到交通事故时怎么办</h4><p>若你卷入或目睹交通事故，应立即按以下步骤处理</p><ul><li><ol><li>停车</li></ol><ul><li>立即将车辆停在安全、明亮、不会阻碍交通的公共区域</li><li>若车辆还能移动，应尽量把车移到不影响道路的位置</li></ul></li><li><ol start="2"><li>帮助伤者</li></ol><ul><li>如果有人员受伤，应在能力范围内提供帮助，或者在对方请求时提供协助</li></ul></li><li><ol start="3"><li>立即拨打 911</li></ol><ul><li>报警并告知是否有人伤亡</li></ul></li><li><ol start="4"><li>警示其他车辆</li></ol><ul><li>开启双闪警示灯</li><li>如有条件，可摆放三角警示牌或照明警示灯，防止二次事故</li></ul></li><li><ol start="5"><li>信息交换</li></ol><ul><li>向所有涉事人员收集并提供以下信息</li><li>姓名，地址，电话号码，驾照号码，车牌号码</li></ul></li></ul><hr><h4 id="出庭相关规定"><a href="#出庭相关规定" class="headerlink" title="出庭相关规定"></a>出庭相关规定</h4><ul><li>如果你因为轻微交通违规而收到罚单，罚单上会写明你必须出庭的日期</li><li>不付款也不出庭会导致<ul><li>安排第二次出庭日期（至少提前30天通知）</li><li>法院书记员会通过你提供的地址、手机、邮箱或短信系统通知你</li><li>若你第二次仍未出庭，将会被视为默认有罪（Ex-Parte Conviction），记录会被上报到伊利诺伊州务卿（Secretary of State）</li><li>最终结果：等同于一次正式交通违法定罪</li></ul></li></ul><p>在外州被开罚单怎么办？（非居民违规者协议）</p><ul><li>如果你在其他州（该州为“非居民违规者协议成员州”）被开罚单，你有三个选择<ul><li>当场留在该州打官司</li><li>直接缴纳罚款</li><li>签字承诺后回家处理（Promise to Comply）</li></ul></li></ul><hr><h4 id="交通事故报告"><a href="#交通事故报告" class="headerlink" title="交通事故报告"></a>交通事故报告</h4><p>哪些情况必须提交事故报告</p><ul><li>无论是否为事故责任方，只要满足以下任一情况，就必须提交事故报告<ul><li>事故导致人员死亡</li><li>事故导致人员受伤</li><li>财产损失超过 1500 美元</li><li>如果其中任一辆车没有保险，只要财产损失超过 500 美元，也必须上报</li><li>涉及校车并造成任何财产损失或人员受伤</li><li>事故发生在距离校车 50 英尺内，并导致上下车人员受伤或死亡</li></ul></li></ul><p>报告时限及方式</p><ul><li>事故发生后，必须在 30 分钟内报告</li><li>如果警察已在现场，会当场记录</li><li>如果现场无警察，应尽快前往最近的警察局报案</li><li>在农村地区，需联系郡治安官或伊利诺伊州州警</li><li>如果司机因伤无法报案，乘客有责任代为报告</li></ul><p>未按规定报告的后果</p><ul><li>最严重可被罚款 2500 美元，还可能面临最长 1 年监禁</li></ul><hr><h4 id="肇事逃逸、无人车辆事故、安全责任法"><a href="#肇事逃逸、无人车辆事故、安全责任法" class="headerlink" title="肇事逃逸、无人车辆事故、安全责任法"></a>肇事逃逸、无人车辆事故、安全责任法</h4><p>离开事故现场（Leaving the Scene of a Crash）</p><ul><li>如果在交通事故中，司机擅自离开现场，尤其是在有人员伤亡的情况下<ul><li>将会被依法追究刑事责任</li><li>若事故造成人员受伤或死亡: 伊利诺伊州务卿（Secretary of State）必须吊销该驾驶员的驾照</li><li>若事故造成财产损失超过 1000 美元: 驾驶员的驾驶资格将被暂</li></ul></li></ul><p>无人车辆事故处理（Unattended Vehicles）</p><ul><li>如果你发生了撞到无人车辆或财产的事故（即对方不在现场）<ul><li>停车并将车辆移至不妨碍交通的位置</li><li>如果找不到车主，必须在对方车或财产上留下以下信息<ul><li>姓名、地址、电话号码、车牌号</li></ul></li><li>向警方报告</li><li>完成所有规定的事故报告</li></ul></li></ul><p>安全责任法（Safety Responsibility Law）</p><ul><li>如果你在事故中负主要责任，且<strong>没有投保责任险</strong>，还需要遵守下列额外规定<ul><li>你必须向伊利诺伊州交通部（IDOT）缴纳<strong>保证金（security）</strong>来赔偿受害方损失</li><li>金额由交通部决定</li></ul></li></ul><hr><h3 id="5-道路标志"><a href="#5-道路标志" class="headerlink" title="5. 道路标志"></a>5. 道路标志</h3><h4 id="标志的形状与颜色"><a href="#标志的形状与颜色" class="headerlink" title="标志的形状与颜色"></a>标志的形状与颜色</h4><p>伊利诺伊州将道路标志分为三类，每类标志都有特定的形状和颜色，用于传达不同的道路信息</p><p>标志的形状及用途</p><ol><li><p>八角形: 专用于“停车（STOP）”标志<br><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img322133.png"></p></li><li><p>倒三角形: 表示“让行（YIELD）”，车辆需减速或停下让其他车辆或行人先行<br><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img322135.png"></p></li><li><p>圆形: 专用于铁路道口警示<br><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img322136.png"></p></li><li><p>五边形（顶部尖、底部平）: 用于学校区域或学生穿越标志，提示前方有学校或学生正在穿越马路<br><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img322137.png"></p></li><li><p>菱形: 表示警告标志，用来提示前方道路可能存在危险或变化（如弯道、滑路、施工等）<br><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img322138.png"></p></li><li><p>朝右的等腰三角形（立在路左侧）: 表示“禁止超车区域（NO PASSING ZONE）”开始<br><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img322139.png"></p></li><li><p>正方形或矩形: 可用于规章标志（如限速）或指示标志（如路名、方向、距离等）<br><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img322140.png"></p></li></ol><p>交通标志颜色及其意义</p><ol><li><p>红色（RED）: 用于规章标志，必须遵守<br>常见于: 停车（STOP）、让行（YIELD）、禁止进入（DO NOT ENTER）、逆行（WRONG WAY）<br><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img322142.png"></p></li><li><p>黑色和白色（BLACK and WHITE）: 大多数是规章标志，也必须遵守<br>部分黑白标志也用于路线编号或方向指示<br><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img322143.png"></p></li><li><p>黄色（YELLOW）: 用于常规警告标志，提醒前方道路状况或危险<br>例如：弯道、滑路、交叉口等<br><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img322144.png"></p></li><li><p>黄绿色（YELLOW-GREEN）: 用于专门警告行人、自行车和学校相关区域<br><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img322145.png"></p></li><li><p>橙色（ORANGE）: 用于施工或养护区域的警告标志，提示前方可能存在道路施工或设备<br><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img322146.png"></p></li><li><p>绿色（GREEN）: 用于引导标志，提供方向、路名、出口、距离等信息<br><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img322147.png"></p></li><li><p>蓝色（BLUE）: 用于服务类引导标志，提供与交通相关的服务信息<br><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img322148.png"></p></li><li><p>棕色（BROWN）: 用于公园、文化和休闲地点的指示标志<br><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img322149.png"></p></li><li><p>粉色（PINK）: 用于突发事件相关标志，警告可能由于事故或自然灾害而产生的交通风险<br><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img322150.png"></p></li></ol><hr><h4 id="规章标志"><a href="#规章标志" class="headerlink" title="规章标志"></a>规章标志</h4><p>这类标志用来明确规定你“必须做什么”或“不能做什么”，具有法律效力，必须遵守</p><ol><li><p>停车（Stop）: 八角形标志，在停车线前完全停车<br><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img322205.png"></p></li><li><p>四向停车（All-Way Stop）: 所有方向都设有停车标志<br>谁先停，谁先走；其他车辆按顺序等待<br><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img322207.png"></p></li><li><p>让行（Yield）: 倒三角形标志，表示你必须让行，让所有车辆或行人优先通行<br><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img322208.png"></p></li><li><p>禁止进入（Do Not Enter）: 通常用于单行道反方向入口或高速公路错误方向的匝道，表示此方向禁止进入<br><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img322209.png"></p></li><li><p>前方限速区域（Speed Zone Ahead）: 提醒你即将进入一个新的限速区域，准备减速<br><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img322210.png"></p></li><li><p>限速（Speed Limit）: 显示最大和最小车速限制<br>如果你慢到影响正常交通，是违法的（除非出于安全考虑）<br><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img322214.png"></p></li><li><p>方向错误（Wrong Way）: 表示你正在逆向行驶，必须立即调整方向<br><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img322215.png"></p></li><li><p>禁止行为（No ___）: 红圈+对角斜杠的标志表示某种行为不被允许<br>比如：No U-turn：禁止掉头，No Right Turn &#x2F; No Left Turn：禁止右转或左转<br><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img322216.png"></p></li><li><p>单行道（One-Way）: 只能按照箭头指示方向行驶，常见于市区单行道<br><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img322217.png"></p></li><li><p>中央左转车道（Two-Way Left Turn Lanes）: 表示中间为双向共用左转道<br><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img322221.png"></p></li><li><p>红灯禁止转弯（No Turn on Red）: 指定交叉口禁止红灯时右转或左转<br><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img322222.png"></p></li><li><p>接近分隔公路（Approaching a Divided Highway）: 表示前方道路有中央隔离带，两边是相反方向的车道<br><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img322223.png"></p></li><li><p>靠右行驶（Keep Right）: 当你遇到中央岛、隔离带或障碍物时，必须靠右通行<br><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img322224.png"></p></li><li><p>慢车靠右（Slower Traffic Keep Right）: 通常用于高速公路，慢速车辆必须行驶在右侧车道<br><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img322225.png"></p></li><li><p>红灯停车位置（Stop Here on Red）: 指明在红灯时你必须在哪里停车，常用于视线不清的路口<br><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img322226.png"></p></li><li><p>禁止超车（Do Not Pass）+ 可安全超车（Pass With Care）<br>表示在该路段禁止超车 + 表示禁止超车区域结束<br><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img322227.png"></p></li><li><p>道路封闭（Road Closed）: 道路对所有车辆封闭，禁止通行<br><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img322228.png"></p></li><li><p>自行车道（Bike Lane）: 标记了专用的自行车车道，不可停放或行驶<br><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img322229.png"></p></li></ol><hr><h4 id="警告标志"><a href="#警告标志" class="headerlink" title="警告标志"></a>警告标志</h4><p>警告标志通常为菱形，颜色多为黄色或橙色（施工区域），部分地区对行人、自行车、学校相关标志使用荧光黄绿色。这些标志提醒你前方有特殊路况或危险情况，需格外小心</p><ol><li><p>行人横道（Pedestrian Crosswalk）: 提醒前方有行人可能横穿马路，横道不一定在路口，需注意左右两侧，部分标志配有闪烁灯<br><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img322248.png"></p></li><li><p>特殊通行区域: 行人&#x2F;牲畜穿越区、轮椅通行区、自行车道交汇点等<br><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img322249.png"></p></li><li><p>学校区域与学校横道: 提醒靠近学校或学生穿越区域<br>上学日 6:30 a.m. - 4 p.m. 时段减速至标明限速（通常为 20mph），注意学校巡逻员、交警等指挥交通<br><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img322250.png"></p></li><li><p>红灯&#x2F;让行&#x2F;信号灯预告（Stop Ahead &#x2F; Yield Ahead &#x2F; Signal Ahead）: 提醒前方即将进入有交通信号控制的区域，即使信号灯还看不见，也应减速准备停车<br><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img322251.png"></p></li><li><p>路口预告（Intersections Ahead）: 常见的四种路口，十字路口、T字型路口、Y字型路口、侧路接入<br><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img322252.png"></p></li><li><p>转弯与弯道（Turns and Curves）: 标志上会用箭头表示，右转&#x2F;左转、S形弯道、单侧弯道、指定的转弯速度（标志下方可能会有附加限速）<br><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img322253.png"></p></li><li><p>高速出口限速（Exit Ramp Speed）: 高速公路出口或匝道上标注的“安全最大车速”<br><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img322254.png"></p></li><li><p>湿滑路面（Slippery Pavement）: 提示雨天或潮湿路段易打滑，需减速慢行、保持车距<br><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img322255.png"></p></li><li><p>陡坡（Downgrade）: 前方为长或陡峭下坡，可能还有急弯，应提前减速<br><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img322256.png"></p></li><li><p>桥面变窄（Narrow Bridge）: 桥面比原道路狭窄，通常比路面窄 2 英尺，小心会车<br><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img322257.png"></p></li><li><p>车道减少（Reduction in Lanes）: 原多车道将变成少车道（可能是施工导致），需提前变道或合流<br><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img322258.png"></p></li><li><p>道路变窄（Road Narrows）: 双车道即将变窄，小心会车<br><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img322259.png"></p></li><li><p>禁止超车区开始（No Passing Zone）: 设置在双向两车道，标志通常放在路左侧，配合黄色实线<br><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img322300.png"></p></li><li><p>合流（Merging Lanes）: 提示你即将进入合并区域（如匝道合流），应减速或允许他车并入<br><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img322301.png"></p></li><li><p>方向变化或路面收窄（Change in Direction）: 常见于急转弯外侧、窄桥入口，提示方向急变<br><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img322302.png"></p></li><li><p>分隔公路开始&#x2F;结束（Divided Highway Begins&#x2F;Ends）: 开始：即将进入有中央隔离带的双向道路，结束：即将离开分隔公路，注意迎面来车<br><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img322304.png"></p></li><li><p>双向道路（Two-Way Roadway）: 提醒你正在进入一条双向行驶的道路，要靠右侧行驶并注意来车<br><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img322325.png"></p></li></ol><hr><h4 id="施工与养护标志"><a href="#施工与养护标志" class="headerlink" title="施工与养护标志"></a>施工与养护标志</h4><p>这类标志提醒驾驶者注意道路状况的改变，同时保障道路工作人员的安全</p><ol><li><p>工人前方（Workers Ahead）: 标志通常设置在距离施工区域较远的位置，为你提供提前减速的时间<br><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img322306.png"></p></li><li><p>警示锥筒、路障桶与路障（Warning Cones, Drums, and Barricades）: 用于标示行车路线，引导车辆安全通过施工区域，也用于提醒现有的危险区域，例如坑洞、障碍物或车道变化<br><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img322307.png"></p></li><li><p>警示灯与方向箭板（Warning Lights and Arrow Boards）: 警示灯：在夜间帮助你发现路障、锥桶、施工边界等障碍，方向箭板：用于提醒你即将车道关闭或变道合流，并指示安全的行驶方向<br><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img322308.png"></p></li><li><p>旗手标志（Flagger）: 表示前方有交通指挥员（旗手）协助交通控制，驶近时要减速，注意其发出的手势或旗语指令，如被示意停车，必须停下<br><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img322309.png"></p></li></ol><hr><h4 id="可变信息标志"><a href="#可变信息标志" class="headerlink" title="可变信息标志"></a>可变信息标志</h4><p>这些是道路上常见的电子显示屏，通常架设在三脚架或大型拖车上，能实时更新内容</p><ul><li>提醒交通拥堵、前方事故、慢车道段落</li><li>通知车道&#x2F;道路关闭</li><li>提示路线变更或行车方式变化</li><li>提供延误时间或绕行建议</li><li>告知你需要合流（使用“拉链式合流”）</li></ul><p>其他特殊标志（Other Special Signs）</p><ol><li><p>慢速车辆标志（Slow-Moving Vehicle）: 这个橙色三角标志出现在农用车、建筑设备、动物牵引车等慢速移动的车辆后方<br><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img322310.png"></p></li><li><p>残障人士专用停车标志: 标示停车位专为以下车辆保留，持有残障人士专用车牌、持有合法停车通行证（Placard）、退伍残障军人牌照<br><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img322311.png"></p></li></ol><hr><h4 id="指引标志"><a href="#指引标志" class="headerlink" title="指引标志"></a>指引标志</h4><p>指引标志用于告诉你: 你在哪里、你正在行驶的是哪条道路、如何到达某个特定地点</p><p>这些标志单独使用或搭配小标志，用于引导你前往特定路线或道路，常见的类型包括</p><ul><li>州际公路（Interstate）</li><li>美国国道（U.S. Route）</li><li>州道（State Route）</li><li>县道（County Road）</li><li>出口编号（Exit Numbers）</li><li>方向牌（如“North 55”或“East 90”）</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img322312.png"></p><hr><h4 id="危险品标志"><a href="#危险品标志" class="headerlink" title="危险品标志"></a>危险品标志</h4><p>危险品标志是一种张贴在运输车辆、容器或包装外部的标识，用于说明所运输的危险物品的种类和危险程度</p><p>如果你靠近一辆张贴有危险品标志的事故车辆</p><ul><li>立即远离事故现场，尤其是当你看到烟雾、有毒标志、或听到爆炸声</li><li>服从紧急救援人员指示，他们受过专业训练</li><li>如果现场没有应急车辆，应尽快远离事故区域，并在安全地点报警</li><li>即使短时间内没感觉不适，也有可能存在延迟性中毒反应，如有不适，请立即就医</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img322313.png"></p><hr><h3 id="6-交通信号灯与路面标记"><a href="#6-交通信号灯与路面标记" class="headerlink" title="6. 交通信号灯与路面标记"></a>6. 交通信号灯与路面标记</h3><h4 id="交通信号灯"><a href="#交通信号灯" class="headerlink" title="交通信号灯"></a>交通信号灯</h4><ol><li>红灯</li></ol><ul><li>必须停车</li><li>可以右转（除非有标志禁止），但需先停并让行人和来车先行</li><li>从单行道左转到另一条左向单行道也可以在红灯时左转，前提同上</li></ul><ol start="2"><li>黄灯</li></ol><ul><li>灯即将变红，不要进入路口</li></ul><ol start="3"><li>绿灯</li></ol><ul><li>可以通行，但要礼让路口中行人和车辆</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img322428.png"></p><p>闪烁灯（Flashing Lights）</p><ol><li>闪烁红灯：像“Stop”标志，停车，让行后再通行</li><li>闪烁黄灯：减速，小心通行</li></ol><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img322429.png"></p><p>箭头灯（Arrows）</p><ol><li>红箭头：禁止对应方向的转弯。但可以右转或从单行道左转入另一条左向单行道，条件和红灯相同</li><li>常亮黄箭头：绿箭头即将结束，准备变红</li><li>闪烁黄箭头：在让行后可以转弯</li><li>绿箭头: 向上：直行，向左：左转，向右：右转</li></ol><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img322431.png"></p><p>车道灯（Lane Signals）</p><ol><li>红 X：禁止驶入此车道</li><li>黄 X：该车道将关闭，尽快换道</li><li>闪烁黄箭头：该车道可左转</li><li>绿箭头：可以使用该车道</li></ol><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img322432.png"></p><hr><h4 id="道路标线"><a href="#道路标线" class="headerlink" title="道路标线"></a>道路标线</h4><p>白色车道线（White Lane Lines）: 用于<ins>同向行驶</ins>的车道之间</p><ul><li>白色虚线：可变道或转弯</li><li>白色实线：尽量不要变道，只有在非常必要时可小心越过</li><li>双白色实线：禁止变道</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img322436.png"></p><p>黄色中心线（Yellow Center Lines）: 用于<ins>相反方向行驶</ins>的车道之间</p><ul><li>黄色虚线：可越线超车</li><li>双黄实线：禁止穿越，仅可左转进&#x2F;出小路或车道</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img322437.png"></p><p>黄色禁止超车线（No Passing Lines）</p><ul><li>单侧黄色实线在你这边：不能起始超车，只能完成超车或左转</li><li>一虚一实黄线：只有靠虚线一侧的车道可以超车</li><li>双黄实线：不能超车，但允许左转进出小路</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img322439.png"></p><p>双向左转车道（Two-Way Left Turn Lanes）</p><ul><li>中间专用左转车道，两侧用黄色线和白色箭头标识</li><li>仅可用来左转或调头，不能在此车道上长时间行驶</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img322440.png"></p><hr><h4 id="铁路道口"><a href="#铁路道口" class="headerlink" title="铁路道口"></a>铁路道口</h4><p>铁路道口警示标志</p><ol><li>圆形黄色预警标志（Advance Warning Sign）: 标有黑色“X”和“RR”，意味着你即将到达铁路道口，通常设置在道口前750英尺以内</li><li>铁路交叉标志（Railroad Crossbuck Sign）: 类似于“让行”标志，如果是多轨道交叉，会显示有多少条轨道</li><li>闪烁灯光信号（Flashing Light Signals）: 灯光开始闪烁时必须停车，直到火车完全通过且灯光停止闪烁</li><li>道闸（Gates）: 不能试图在道闸下降时抢行，也不能绕过道闸，必须等到闸杆完全抬起、灯光熄灭后再继续前进</li></ol><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img322457.png"></p><p>紧急联系信息（ENS）</p><ul><li>ENS（Emergency Notification System） 是铁路道口上提供的蓝色紧急联系标识</li><li>如果发生紧急情况（比如车辆卡在轨道上），你可以立刻拨打这个电话联系铁路公司并报告准确位置</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img322458.png"></p><hr><h3 id="7-安全驾驶小贴士"><a href="#7-安全驾驶小贴士" class="headerlink" title="7. 安全驾驶小贴士"></a>7. 安全驾驶小贴士</h3><h4 id="防御性驾驶"><a href="#防御性驾驶" class="headerlink" title="防御性驾驶"></a>防御性驾驶</h4><ul><li>保持警觉，预判他人行为: 不要假设其他驾驶者一定会遵守交通规则或让你</li><li>保持安全距离: 给自己留出足够的反应空间，比如和前车保持 3 秒或以上的跟车距离</li><li>控制车速: 根据路况、天气和交通状况适当减速</li><li>随时做好应对突发情况的准备: 比如突然有人变道、急刹车、横穿马路的行人或动物等</li><li>保持冷静，选择最安全的处理方式: 万一无法避免碰撞，尽可能选择“最小伤害”的解决方案，比如控制方向，避让人群、灯柱等硬物</li></ul><hr><h4 id="跟车距离"><a href="#跟车距离" class="headerlink" title="跟车距离"></a>跟车距离</h4><p>为什么保持跟车距离很重要</p><ul><li>尾随过近（Tailgating） 是导致追尾事故的最常见原因</li><li>在紧急情况（比如前车突然刹车）时，没有足够的反应空间容易出事故</li></ul><p>三秒规则（Three-Second Rule）怎么用</p><ul><li>选一个固定物体：比如路边的标志牌、树、天桥等</li><li>当前车经过该物体时开始计数</li><li>如果你数到三之前已经到达那个物体，说明你跟太近了，应该放慢速度、拉开距离</li></ul><p>特殊情况需增加距离</p><ul><li>雨、雪、雾、冰滑路面：延长为 4-6 秒甚至更多</li><li>高速行驶时：反应距离更长，建议超过 3 秒</li><li>跟大型车辆（如卡车、公交）：因视线受阻也应拉大距离</li></ul><p>如果被别人尾随太紧怎么办</p><ul><li>切换车道：让他先过去</li><li>逐渐减速靠边：找安全的地方让对方超车，不要急刹车挑衅</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img223047.png"></p><hr><h4 id="车速"><a href="#车速" class="headerlink" title="车速"></a>车速</h4><p>为什么控制车速很重要</p><ul><li>开太快或太慢 都可能造成危险</li><li>安全车速 ≠ 限速标志，而是要结合天气、道路、交通状况调整</li><li>就算限速是 55mph，如果大雾大雨，可能只能开 35mph 才安全</li><li><ins>速度翻倍，刹车距离是四倍（不是两倍）</ins></li></ul><p>决定车速时要考虑什么</p><ul><li>你自己的反应能力：精神状态好不好？是否疲劳</li><li>道路状况：坑洼、打滑、下坡、施工等都得减速</li><li>轮胎大小和花纹深度：越大的轮胎、花纹越深，越容易刹住</li><li>风向和风速：逆风能帮助你刹车，顺风（tailwind）反而会延长刹车距离</li></ul><hr><h4 id="疲劳驾驶"><a href="#疲劳驾驶" class="headerlink" title="疲劳驾驶"></a>疲劳驾驶</h4><p>即使你没有真的睡着，疲劳也会严重影响你开车的反应时间和判断力</p><ul><li>很多疲劳驾驶者在关键时刻无法及时刹车或转向避险</li><li>一瞬间的打瞌睡，可能就造成车祸，尤其在高速上</li></ul><p>如何避免疲劳驾驶</p><ul><li>保证充足睡眠，尤其是长途出发前</li><li>经常停车休息，建议每2小时或100英里停一次</li><li>不要硬撑！ 如果困了，就找安全的地方休息</li></ul><hr><h4 id="不同天气条件下的安全驾驶建议"><a href="#不同天气条件下的安全驾驶建议" class="headerlink" title="不同天气条件下的安全驾驶建议"></a>不同天气条件下的安全驾驶建议</h4><p>雾天驾驶（Fog）</p><ul><li>建议避免在浓雾中驾驶，如必须开车，请注意<ul><li>关闭巡航控制，加大跟车距离</li><li>减速行驶，若看到前方车灯，更要减速，防止对方在中线行驶或停着不动</li><li>开启近光灯或雾灯，切勿开远光灯</li><li>不要“盲目开车”，切记不能超出视野范围驾驶，如果雾太浓，应尽快驶出路面，安全停车</li><li>提前打转向灯，增加他人反应时间</li><li>提前刹车提醒后车，避免追尾</li></ul></li></ul><p>雨天驾驶（Rain）</p><ul><li>雨天地面湿滑、能见度低<ul><li>根据伊利诺伊州法律：雨刷一开，车灯也必须开启</li><li>关闭巡航控制，减速慢行，注意弯道、刹车时打滑风险</li><li>避免水滑现象（Hydroplaning）：若车轮失控打滑，松油门，不要急刹车，尽量掌控方向</li><li>若遇积水路段或桥下积水，不可冒险通过，应掉头寻找替代路线</li></ul></li></ul><p>大风天气（High Winds）</p><ul><li>降低车速，特别是从遮挡区驶入开阔区域或与大车交会时</li><li>注意路面湿滑、冰雪或大雨伴随的大风</li><li>在伊利诺伊收费公路上，大风天气禁止拖挂房车通行</li></ul><p>冬季驾驶（Winter Driving）</p><ul><li>冬季常见冰雪低温、视线差，是一年中最难驾驶的季节<ul><li>减速，拉开车距，冰雪阴影区域尤其滑</li><li>清除车身所有冰雪，确保前后灯、挡风玻璃和窗户都干净</li><li>轻踩刹车，以测试当前路况抓地力</li><li>桥梁、阴影、匝道、弯道可能比道路更早结冰，需提前减速</li><li>车内准备好毛毯、食物、小铲子等应急装备，如果抛锚，应待在车内，短时间启动发动机保暖，并打开窗户防止一氧化碳中毒，确保排气管无积雪</li></ul></li></ul><hr><h4 id="特殊驾驶情况与潜在危险的应对方法"><a href="#特殊驾驶情况与潜在危险的应对方法" class="headerlink" title="特殊驾驶情况与潜在危险的应对方法"></a>特殊驾驶情况与潜在危险的应对方法</h4><p>高速公路（Expressway）驾驶安全提示</p><ul><li>加速合流区：上高速时利用加速车道提速，与主路车速一致再合流</li><li>使用转向灯，变道前先观察后视镜与盲区</li><li>保持安全车距，避免追尾</li><li>右车道行驶，左车道超车用，不要长时间占用左车道</li><li>如遇故障不可在高速上停车行走，应尽快靠边开启双闪、打开引擎盖等待救援</li><li>错过出口不可倒车，应继续前行到下一个出口</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img223857.png"></p><p>夜间驾驶（Night Driving）</p><ul><li>不要超出车灯照射范围行驶（避免“盲驾”</li><li>开远光灯时<ul><li>遇对向来车提前500英尺改为近光</li><li>准备超车前300英尺也要切换为近光</li></ul></li></ul><p>弯道（Curves）</p><ul><li>弯前减速，不要急刹或过弯时踩刹车，否则易打滑或翻车</li><li>切勿越过道路中心线</li></ul><p>正面来车驶入你的车道（Head-on Approaches）</p><ul><li>立刻减速，向右侧避让，并鸣喇叭提醒</li></ul><p>打滑（Skidding）</p><ul><li>若车辆打滑：松开油门或刹车，<ins>顺着打滑方向轻打方向盘</ins>恢复控制，然后重新调整方向</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img224051.png"></p><p>驶出路面（Driving Off the Pavement）</p><ul><li>车辆驶出路缘，紧握方向盘，慢松油门并轻刹车</li><li>等安全后，确认后方无车再缓慢驶回路面</li><li>切勿猛打方向盘，以防偏到对向车道</li></ul><p>车辆起火（Fire）</p><ul><li>立刻停车，关闭发动机，远离车辆，拨打911</li></ul><p>掉入水中（Water Crashes）</p><ul><li>若车辆暂未沉没，迅速通过窗户逃生（车门通常打不开）</li><li>若车辆已沉入水中，移至后排空气口袋区，深呼吸后从后窗逃生</li></ul><p>一氧化碳中毒（Carbon Monoxide Poisoning）</p><ul><li>一氧化碳无色无味，症状像感冒：头痛、恶心、眩晕</li><li>不要在封闭车库中启动汽车</li></ul><p>高压电（Power Line）</p><ul><li>如果有电线落在车上，留在车内等救援</li><li>若有火灾风险需逃生：双脚跳车，保持身体不接触车和地面同时，之后用双脚跳或小步滑行50英尺远离车体</li></ul><p>加油安全（Explosive Fire Hazard）</p><ul><li>熄火加油，禁止吸烟</li><li>加油时请勿离开油枪</li></ul><hr><h4 id="设备故障时的应对措施"><a href="#设备故障时的应对措施" class="headerlink" title="设备故障时的应对措施"></a>设备故障时的应对措施</h4><p>轮胎爆胎（Blowouts）</p><ul><li>爆胎前会听到“砰砰”的声音</li><li>不要猛踩刹车</li><li>做法<ul><li>慢慢松开油门</li><li>双手紧握方向盘，保持控制</li><li>稳定方向后慢慢靠边停车</li><li>打开双闪灯</li><li>下车检查轮胎</li></ul></li></ul><p>轮胎或车轮脱落（Loss of Wheel or Tire）</p><ul><li>应对方式与爆胎一致：松油门、保持方向、慢慢停车</li></ul><p>转向失灵（Steering Failure）</p><ul><li>没法控制方向盘时<ul><li>松开油门</li><li>打开双闪灯</li><li>轻踩刹车（不能猛踩，避免打滑或原地旋转</li><li>不要关闭点火开关</li></ul></li></ul><p>刹车失灵（Brake Failure）</p><ul><li>踩刹车发现刹车踏板直接踩到底<ul><li>连续快速踩几下，试图重新建立刹车压力</li><li>如果无效，<strong>拉手刹（紧急&#x2F;驻车刹车）</strong>减速</li><li>同时，将挡位换到低速档辅助减速</li><li>小心控制方向，靠边停车</li></ul></li></ul><p>大灯失效（Headlight Failure）</p><ul><li>如果灯突然全灭<ul><li>尝试打开: 双闪灯、转向灯、停车灯</li><li>慢慢靠边停车</li><li>不要再行驶，等待修理或救援</li></ul></li></ul><p>油门卡住（Stuck Gas Pedal）</p><ul><li>油门无法松开时<ul><li>用脚勾住油门试图拉回来</li><li>如果没法解卡: 立即挂入空挡（N）、轻踩刹车减速、打双闪，靠边安全停车</li></ul></li></ul><p>视线受阻（Blocked Vision）</p><ul><li>如果突然视线模糊或完全遮挡<ul><li>摇下侧窗来观察外面</li><li>打开双闪，慢慢靠边停车</li><li>等视线恢复或问题排除再继续开车</li></ul></li></ul><hr><h4 id="攻击性驾驶"><a href="#攻击性驾驶" class="headerlink" title="攻击性驾驶"></a>攻击性驾驶</h4><p>攻击性驾驶是指一种可能危及他人或财产安全的驾驶方式，常见的行为包括</p><ul><li>超速驾驶</li><li>闯红灯、闯停车标志</li><li>贴车尾（尾随距离过近）</li><li>从路肩强行超车</li><li>强行插队、突然变道切入他人车道</li><li>故意急刹车报复后车</li><li>对其他司机做出侮辱性手势或面部表情</li><li>大声咆哮或辱骂</li><li>反复按喇叭</li><li>不停闪远光灯骚扰前车</li></ul><p>遇到攻击性驾驶者怎么办</p><ul><li>保持冷静，不要还击或回应对方行为</li><li>避免眼神接触，不要激怒对方</li><li>锁好车门窗</li><li>保持车距，避免被困在前车和攻击者之间</li><li>如果对方试图逼停你，尽量开往人多或安全的地方（如警察局、加油站）</li><li>不要低估对方的潜在威胁性，避免冲突升级</li></ul><hr><h4 id="不同类型道上遇到车辆抛锚或紧急状况时该如何自保"><a href="#不同类型道上遇到车辆抛锚或紧急状况时该如何自保" class="headerlink" title="不同类型道上遇到车辆抛锚或紧急状况时该如何自保"></a>不同类型道上遇到车辆抛锚或紧急状况时该如何自保</h4><p>在高容量道路（如高速、高架、主要干道）</p><ul><li>尽量驶入最右侧的应急车道或安全区域，远离正常车流</li><li>留在车内，并系好安全带</li><li>打开双闪灯（Hazard Lights）</li><li>拨打 911 求助</li><li>等待救援人员到来，不要贸然下车</li></ul><p>在低容量道路（如乡村公路、住宅区、次要道路）</p><ul><li>尽可能靠边停车，避开车流</li><li>如果安全，从远离来车方向一侧下车</li><li>离车后，站在人行道、护栏后方或田边安全处</li><li>如果无法安全下车，继续留在车内并系好安全带</li><li>打开双闪灯</li><li>拨打 911</li></ul><p>在 Illinois Tollway（收费公路）</p><ul><li>尽可能驶入最右侧路肩</li><li>留在车内，系好安全带</li><li>打开双闪灯</li><li>拨打 *999 或 911</li><li>候 Tollway 维护人员或紧急响应人员救援</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>TAG 工作总结</title>
      <link href="/posts/d1eea1ad.html"/>
      <url>/posts/d1eea1ad.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>这个是我工作了 1.5 年的一个小总结</p></blockquote><h3 id="我在-TAG-的职责"><a href="#我在-TAG-的职责" class="headerlink" title="我在 TAG 的职责"></a>我在 TAG 的职责</h3><ul><li><p>负责 Clinical 微服务开发和维护（TAG 是大型医疗集团，旗下 Aspen Dental 有 1400+ 门店，使用自研系统，需要持续维护和迭代）</p><ul><li>采用 Model-Service-Repository 设计模式，优化代码结构，提高可维护性</li><li>日常维护多个 .NET 微服务，修复 bug，开发新业务功能</li></ul></li><li><p>负责 Monolith 维护 (也是 .NET) 和 Bug 修复</p><ul><li>阅读和理解遗留代码，定位并修复问题</li><li>将 Clinical 相关功能从 Monolith 拆分到微服务</li></ul></li><li><p>数据库相关工作</p><ul><li>Monolith 用 SQL Server，微服务用 PostgreSQL</li><li>根据 PM 需求开发新功能或调整数据</li></ul></li><li><p>跨团队协作</p><ul><li>帮后端队友做 Code Review （团队里唯一非 Senior）</li><li>帮前端队友解答后端相关问题，协助前后端联调</li><li>帮 PM 做技术研究（SPIKE）</li><li>需要时支援其他 team</li></ul></li></ul><hr><h3 id="我在-TAG-的技术栈"><a href="#我在-TAG-的技术栈" class="headerlink" title="我在 TAG 的技术栈"></a>我在 TAG 的技术栈</h3><ul><li><strong>Frontend:</strong> 能读懂 Angular 和 React（微前端）</li><li><strong>Backend:</strong> C#, .NET 6 到 9 (Monolith 是 .NET 6, 其他微服务基本上都是 .NET 9), GraphQL (是的我们有 GraphQL layer, 但我个人并不喜欢), gRPC</li><li><strong>Database:</strong> PostgreSQL, SQL Server, AlloyDB, Firestore (GCP)</li><li><strong>ORM:</strong> Dapper, Entity Framework (主要用的还是 Dapper, Monolith用的是 Entity Framework)</li><li><strong>Cloud:</strong> GCP (Pub&#x2F;Sub, AlloyDB, DMS, BigQuery)</li><li><strong>DevOps:</strong> Docker, Kubernetes, Terraform, Spinnaker, Liquibase</li><li><strong>Monitoring:</strong> Grafana</li><li><strong>Other Tools:</strong> LaunchDarkly, Nuget, Git, GitHub</li></ul><hr><h3 id="我自己主导的项目"><a href="#我自己主导的项目" class="headerlink" title="我自己主导的项目"></a>我自己主导的项目</h3><blockquote><p>虽然我是初入职场，但能力还是可以的，所以除了日常维护我们组的微服务，我也有一些自己开发的项目，为公司带来收益</p></blockquote><h4 id="TAG-Notifications"><a href="#TAG-Notifications" class="headerlink" title="TAG Notifications"></a>TAG Notifications</h4><p>从零搭建的完整服务，从数据库设计到微服务开发全程独立完成。用于患者 recall exam (也就是复诊) 管理——当患者来到诊所时，系统会根据历史 procedure 记录提醒进行复检，提升诊所服务质量和营收。</p><blockquote><p>下面是整个 data flow 的设计图</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">┌─────────────┐         </span><br><span class="line">│  Monolith   │──publish──┐</span><br><span class="line">└─────────────┘           │</span><br><span class="line">                          ▼</span><br><span class="line">┌─────────────┐     ┌─────────────┐     ┌──────────────────┐</span><br><span class="line">│  Schedule   │────▶│   Pub/Sub   │────▶│   Notification   │</span><br><span class="line">│     MS      │     │   (GCP)     │     │   Subscriber     │</span><br><span class="line">└─────────────┘     └─────────────┘     └────────┬─────────┘</span><br><span class="line">                          ▲                      │</span><br><span class="line">┌─────────────┐           │                      │</span><br><span class="line">│  Other MS   │──publish──┘                      │</span><br><span class="line">└─────────────┘                                  ▼</span><br><span class="line">                                           ┌─────────────┐</span><br><span class="line">┌─────────────┐     ┌─────────────┐        │   AlloyDB   │</span><br><span class="line">│   Frontend  │────▶│ Notification│───────▶│ (PostgreSQL)│</span><br><span class="line">└─────────────┘     │     MS      │        └─────────────┘</span><br><span class="line">                    └─────────────┘              ▲</span><br><span class="line">                                                 │</span><br><span class="line">                    ┌─────────────┐              │</span><br><span class="line">                    │   Nightly   │──────────────┘</span><br><span class="line">                    │   Cron Job  │</span><br><span class="line">                    └─────────────┘</span><br></pre></td></tr></table></figure><p><strong>1. 数据库设计</strong></p><p>使用 AlloyDB + PostgreSQL 作为数据存储，通过 Liquibase 管理 schema 变更。独立设计数据库 schema，与 Senior 和 Tech Lead 多次讨论修改。在完成 MS 和 Cron Job 开发后，根据需求设计 index 优化性能。</p><p><br><br></p><p><strong>2. Nightly Cron Job (定时任务)</strong></p><p>Cron Job 主要负责两件事</p><ul><li><strong>Populate database:</strong> 从 Monolith 拿取需要的数据，populate 所需的 notification</li><li><strong>每日增量同步:</strong> 每天晚上根据 checkpoint 从 Monolith 更新所需数据，确保与 Monolith 保持一致（Monolith 是 source of truth）</li></ul><p>由于 Monolith 数据量是千万级别，学习并应用了多种优化技术</p><ul><li><strong>Batch operation:</strong> 无法一次读完所有数据，将 table 数据分批读取</li><li><strong>Parallel programming:</strong> 设置 concurrent worker，每个 batch 读出后用空闲 thread 进行 bulk upsert，这样就可以不需要等待 upsert 直接进入下一个 batch</li><li><strong>Task 并行:</strong> 让互不冲突的 task 同时运行</li></ul><p>通过这些优化，可以在 10 秒内处理 100,000 条数据。</p><p><br><br></p><p><strong>3. Notification Subscriber (发布-订阅)</strong></p><ul><li><p>Subscriber 是一个独立的 Worker，专门处理 GCP Pub&#x2F;Sub subscription，监听从 Monolith 和其他 team 发来的 event，实时更新数据库，确保用户在白天可以获得最准确的数据。</p></li><li><p>之所以没有在 MS 里集成 Subscriber，是因为这个服务需要高并发且流量很大 (因为是在类似 Visit Manager 里被使用)，如果在 MS 里处理，流量上来就得 scale MS，这显然不合理。独立出 Subscriber 可以单独 scale，实现服务解耦。</p></li></ul><p>技术要点</p><ul><li>用 Terraform 创建 GCP subscription 和 dead letter queue</li><li>研究并确定所需的 event，针对不同 event 写了不同的 message handler</li><li>应用 Cron Job 中学到的优化: 互不冲突的 task 同时运行</li><li>加 Redis 缓存静态数据，减少数据库查询</li></ul><p><br><br></p><p><strong>4. Notification MS (微服务)</strong></p><p>一个标准的 .NET 9 微服务，为前端、GraphQL team 和其他 MS team 提供所需的 API。</p><p><br><br></p><blockquote><p><strong>总结</strong><br>通过这个项目学到了很多，包括数据库设计和 PostgreSQL 的使用、parallel programming 和 Cron Job 开发（通过 GCP Log Explorer + Stopwatch 进行速度测试）、GCP Pub&#x2F;Sub 的使用并处理不同的 Messaage，以及如何将 PM 比较宽泛的需求落地成具体的技术方案（Notification 概念简单，但实现复杂）。<br><br><br>最重要的是，这个服务设计了很强的扩展性。不止我们 Clinical team 在用，其他 team 也会依赖这个服务并提出自己的 notification 需求，不同的 stakeholder 也可以为自己的 brand 提出不同的要求。所以这算是我比较大的一个项目，并且正在持续完善整个服务。</p></blockquote><hr><h4 id="TAG-LaunchDarkly"><a href="#TAG-LaunchDarkly" class="headerlink" title="TAG LaunchDarkly"></a>TAG LaunchDarkly</h4><ul><li><p>之所以做这个项目，是因为我一部分负责的工作是 pilot project（试点项目），就是在一部分 facility 中先试用新功能。之前我们控制 pilot 是用 Monolith 的数据库，有专门的 pilot project 和 pilot facility 表，但问题在于 Monolith 数据库不能随便 deploy，要等每周固定时间。这样就导致新的 pilot project 需要等到下周才能上线，影响业务敏捷性。</p></li><li><p>正好那时候前端刚采用了 LaunchDarkly 作为 feature flag 控制，我的 manager 就让我研究后端怎么用 LaunchDarkly 作为 modern solution 进行 pilot 控制。</p></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img213sadsd.png"></p><p><strong>技术实现</strong><br>我设计并实现了一个 Feature Flag NuGet Package，包含两部分</p><ul><li><strong>Abstraction package:</strong> 避免 vendor lock-in，统一 API 设计 (意思就是如果将来从 Launchdarkly 换成其他 feature flag 产品，都需要 implement 这个 package)</li><li><strong>Implementation package:</strong> 使用 LaunchDarkly，采用 Factory Pattern + Lazy Client Initialization 优化性能</li></ul><p><strong>成果</strong><br>这个 package 被多个 team 采用，服务全国 2000+ dental facilities。各 team 可以独立管理和上线 pilot project，不用等 database release。现在还和 Metric team 合作，可以在他们那边看到 pilot project 的 adoption rate。</p><br><blockquote><p>总结<br>通过这个项目学会了怎么写 NuGet package（类似 npm package），以及怎么设计低耦合的软件</p></blockquote><hr><h3 id="我学会的东西"><a href="#我学会的东西" class="headerlink" title="我学会的东西"></a>我学会的东西</h3><h4 id="如何设计微服务"><a href="#如何设计微服务" class="headerlink" title="如何设计微服务"></a>如何设计微服务</h4><p>在我们 Clinical team，采用 Model-Service-Repository 模式构建 C# 微服务，以提升代码的可维护性和扩展性：</p><ul><li><strong>Model:</strong> 定义数据结构，Request 或 Response 的结构</li><li><strong>Repository:</strong> 负责数据库操作，封装 SQL 查询，提供数据访问接口（使用 Dapper 写和数据库交互的逻辑）</li><li><strong>Service:</strong> 负责核心业务逻辑，调用 Repository 获取和修改数据</li></ul><p>对于 Repository 和 Service，需要建立对应的 Interface，用来定义方法签名和写注释说明方法的用途。</p><hr><h4 id="如何使用-IaC-Terraform"><a href="#如何使用-IaC-Terraform" class="headerlink" title="如何使用 IaC (Terraform)"></a>如何使用 IaC (Terraform)</h4><p>之前团队都是用 GCP Console 手动创建资源，不好管理也难以回溯。我自己学习了 Terraform, 就可以在不影响 Devops 的情况下</p><ul><li>创建 Pub&#x2F;Sub subscription 和 dead letter queue</li><li>写 GCP DMS template，用于数据迁移</li></ul><p>之前团队用 SSIS 做数据迁移（从 Monolith SQL Server 迁移到 AlloyDB），非常复杂而且没有很多人知道怎么做。所以在写 PubSub template 的同时我研究了 GCP DMS (Database Migration Service)，并且组合了 Terraform 提供的 DMS tempalte，让其他 team 可以更方便地进行数据迁移。</p><hr><h4 id="如何提高-API-Performance"><a href="#如何提高-API-Performance" class="headerlink" title="如何提高 API Performance"></a>如何提高 API Performance</h4><p>在 Aspen，我们用两种方式衡量 API 性能: 用 Grafana 监控 response time 等指标，以及做 stress testing 了解 API 在高负载下的表现。</p><br><p>性能优化方面主要是 SQL query optimization、caching strategies（如 Redis 缓存静态数据）、和 Senior 做 Code Review 讨论 API 设计。</p><hr><h4 id="如何从零开始做东西"><a href="#如何从零开始做东西" class="headerlink" title="如何从零开始做东西"></a>如何从零开始做东西</h4><p>不管是做 MS 还是 NuGet Package，最重要的是做一个 template 出来，可以让别人复用。这样后续的项目可以基于 template 快速开始，不需要从头配置。</p>]]></content>
      
      
      <categories>
          
          <category> 工作回忆 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>hireEZ 实习总结</title>
      <link href="/posts/79e72cc1.html"/>
      <url>/posts/79e72cc1.html</url>
      
        <content type="html"><![CDATA[<h2 id="2022-HireEZ-实习"><a href="#2022-HireEZ-实习" class="headerlink" title="2022 HireEZ 实习"></a>2022 HireEZ 实习</h2><h3 id="Jira-工单生成器"><a href="#Jira-工单生成器" class="headerlink" title="Jira 工单生成器"></a>Jira 工单生成器</h3><p>为 BI team 开发了一个自动化工单创建工具，替代原来手动从 Excel 复制粘贴到 Jira 的流程。工具支持树状结构批量创建 parent&#x2F;child ticket，大幅减少重复性工作</p><ul><li>前端用 React 构建，渲染树状工单结构</li><li>Consume AWS Lambda 返回的员工信息数据</li><li>调用 Jira REST API 批量创建工单</li><li>为 BI team 节省每周数小时的手动操作时间</li></ul><blockquote><p>技术栈: React, AWS Lambda, Jira REST API</p></blockquote><hr><h3 id="GA4-Tracking-amp-测试"><a href="#GA4-Tracking-amp-测试" class="headerlink" title="GA4 Tracking &amp; 测试"></a>GA4 Tracking &amp; 测试</h3><p>在现有产品上集成 Google Analytics 4 埋点，追踪用户行为数据。用 Playwright 写 UI 测试验证埋点数据采集的准确性</p><ul><li>GA4: 埋点追踪用户行为数据（页面浏览、按钮点击、功能使用等），为产品决策和 UX 优化提供数据支持</li><li>Playwright: 写端到端 UI 测试，模拟用户操作验证埋点事件是否正确触发和采集</li></ul><blockquote><p>技术栈: Google Analytics 4, Playwright</p></blockquote><hr><h2 id="2024-HireEZ-实习"><a href="#2024-HireEZ-实习" class="headerlink" title="2024 HireEZ 实习"></a>2024 HireEZ 实习</h2><h3 id="Chrome-Extension-Candidate-Matching"><a href="#Chrome-Extension-Candidate-Matching" class="headerlink" title="Chrome Extension Candidate Matching"></a>Chrome Extension Candidate Matching</h3><p>为公司 Chrome extension 添加候选人匹配功能，将原本只在 web 端有的功能移植到 extension</p><ul><li>用 content script 解析页面，从 Greenhouse URL 和 LinkedIn 页面提取候选人 ID</li><li>支持单个 profile 页和 LinkedIn My Network 页面批量匹配</li><li>调用现有后端 API，匹配数据库中具有相同经验或技能的候选人</li><li>用 React + 公司组件库构建展示组件</li></ul><blockquote><p>技术栈: Chrome Extension, React, JavaScript, HTML, CSS</p></blockquote><hr><h3 id="AWS-Q-Business-知识检索系统（Research）"><a href="#AWS-Q-Business-知识检索系统（Research）" class="headerlink" title="AWS Q Business 知识检索系统（Research）"></a>AWS Q Business 知识检索系统（Research）</h3><p>研究使用 AWS Q Business 搭建内部知识库系统，通过 Low-Code 方式连接公司的 Jira、Confluence 和 Slack 作为数据源</p><ul><li>用 AWS Q Business 的 connector 整合多个内部工具的文档和数据</li><li>用 CloudFormation 写 IaC template，方便重复部署 (ref: <a href="https://www.youtube.com/watch?v=hX0FHWnvyKY">https://www.youtube.com/watch?v=hX0FHWnvyKY</a>)</li><li>产出 demo 和研究文档给团队</li><li>因 Q Business 当时刚发布功能较基础，最终作为可行性研究</li></ul><blockquote><p>技术栈: AWS Q Business, CloudFormation, Jira, Confluence, Slack</p></blockquote><hr><h3 id="GitHub-Actions-CI-x2F-CD"><a href="#GitHub-Actions-CI-x2F-CD" class="headerlink" title="GitHub Actions CI&#x2F;CD"></a>GitHub Actions CI&#x2F;CD</h3><p>研究并实现 GitHub Actions 自动化流程，用于前端项目的依赖版本检查</p><ul><li>写 Shell 脚本检查 package.json 依赖版本一致性</li><li>集成到公司的 GitHub Actions 公共 repo，供后续新项目复用</li></ul><blockquote><p>技术栈: GitHub Actions, Shell</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 工作回忆 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>前端 stackblitz</title>
      <link href="/posts/7c522c36.html"/>
      <url>/posts/7c522c36.html</url>
      
        <content type="html"><![CDATA[<h3 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h3><h4 id="Image-Hover-Ripple"><a href="#Image-Hover-Ripple" class="headerlink" title="Image Hover Ripple"></a>Image Hover Ripple</h4><iframe width="100%" height="400px" src="https://stackblitz.com/edit/stackblitz-starters-5hhc9hv2?embed=1&file=script.js&theme=dark&view=preview" frameborder="0" loading="lazy" allowtransparency="true" allowfullscreen="true"></iframe><p>React Version</p><iframe width="100%" height="400px" src="https://stackblitz.com/edit/vitejs-vite-7za7qnuw?embed=1&file=src%2Fcomponents%2FWebGLGallery.jsx&theme=dark&view=preview" frameborder="0" loading="lazy" allowtransparency="true" allowfullscreen="true"></iframe>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>WebGL 学习笔记</title>
      <link href="/posts/d58818f0.html"/>
      <url>/posts/d58818f0.html</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p><a href="https://webglfundamentals.org/">WebGL Fundamentals</a>: 适合初学者，包含详细的教程和示例代码</p></blockquote><h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><h4 id="什么是Shader"><a href="#什么是Shader" class="headerlink" title="什么是Shader"></a>什么是<code>Shader</code></h4><p><code>Shader</code>是运行在<code>GPU</code>上的一段程序，主要负责控制图形渲染管线中的一部分。主要类型</p><ul><li>顶点着色器 (<code>Vertex Shader</code>): 确定图形的每一个顶点的位置</li><li>片元着色器 (<code>Fragment Shader</code>): 渲染图形的每一个片元（像素）的颜色</li></ul><h4 id="Shader和其他技术"><a href="#Shader和其他技术" class="headerlink" title="Shader和其他技术"></a><code>Shader</code>和其他技术</h4><p><code>Shader</code>是前端图形技术中的重要一环，它与常见的图形技术如<code>CSS</code>、<code>SVG</code>、<code>Canvas2D</code>和<code>WebGL</code>都有着密切的关系，每一种技术都在不同层面提供了图形渲染的能力，但<code>Shader</code>的独特之处在于它直接操作<code>GPU</code>，能够实现高度复杂的视觉效果</p><ul><li><p><code>CSS</code>: <code>CSS</code>的主要功能是网页布局，但它也可以通过一些属性（如<code>animation</code>和<code>transform</code>）实现简单的动画效果。它的局限性在于无法很好地处理复杂的动态变化，尤其是像素级的精细操作</p></li><li><p><code>SVG</code>: <code>SVG</code>提供了矢量图形的能力，允许开发者通过路径（<code>path</code>标签）定义任意形状，并结合属性（如 <code>stroke-dasharray</code>和<code>stroke-dashoffset</code>）实现动画。相比<code>CSS</code>，<code>SVG</code>更适合处理复杂的几何图形。然而，它仍然难以实现动态粒子效果或像素级控制</p></li><li><p><code>Canvas2D</code>: <code>Canvas2D</code>提供了对每个像素的直接控制，开发者可以通过数学运算和随机函数实现动态效果，例如粒子拖尾动画。但它的设计初衷是处理<code>2D</code>图形，对<code>3D</code>图形的支持相对较弱</p></li><li><p><code>WebGL</code>: <code>WebGL</code>是在浏览器中渲染<code>3D</code>图形的标准，它通过“渲染管线”处理图形数据。<code>WebGL</code>的强大之处在于既可以处理<code>2D</code>图形，也可以实现<code>3D</code>场景。<code>Shader</code>是<code>WebGL</code>的核心组成部分，用于自定义渲染管线中的特定部分，提供开发者完全的渲染控制能力</p></li></ul><hr><h3 id="Shader基础知识"><a href="#Shader基础知识" class="headerlink" title="Shader基础知识"></a><code>Shader</code>基础知识</h3><h4 id="Shader编程语言选择"><a href="#Shader编程语言选择" class="headerlink" title="Shader编程语言选择"></a><code>Shader</code>编程语言选择</h4><p>目前主要的<code>Shader</code>编程语言有以下几种</p><ul><li><code>GLSL</code>: 主要用于<code>OpenGL</code>平台的图形<code>API</code></li><li><code>HLSL</code>: 由微软开发，主要用于<code>DirectX</code>平台的图形API</li><li><code>Cg</code>: 由<code>Nvidia</code>开发，可被编译为<code>GLSL</code>和<code>HLSL</code>，主要被用于<code>Unity</code>平台</li><li><code>WGSL</code>: <code>WebGPU</code>的专用语言，适用于未来的浏览器图形开发</li></ul><p>本学习笔记重点是<code>Web</code>环境中的<code>Shader</code>开发，并基于<code>WebGL</code>平台，选择<code>GLSL</code>作为主要的学习语言</p><h4 id="WebGL渲染管线流程"><a href="#WebGL渲染管线流程" class="headerlink" title="WebGL渲染管线流程"></a><code>WebGL</code>渲染管线流程</h4><p><code>WebGL</code>的渲染管线的核心流程（一个物体是如何被渲染到屏幕上的）主要包括以下几个步骤</p><ul><li>顶点着色器: 处理顶点数据（如位置、颜色、纹理坐标）</li><li>图元装配: 将顶点数据组合成图元（如点、线、三角形）</li><li>光栅化: 将图元转换为屏幕上的像素</li><li>片元着色器: 计算每个像素的颜色</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img0a729b8d1dae444c9799c7083aa84f65%7Etplv-k3u1fbpfcp-jj-mark_3024_0_0_0_q75.awebp"></p><blockquote><p>整个流程是: 在<code>JS</code>中提供顶点的数据（通常是<code>Float32Array</code>类型的数组，包含了顶点的位置等信息），将这些数据传递给顶点着色器，让它计算每个顶点的位置，然后<code>WebGL</code>将顶点装配成图元（如三角形），图元再被转换成屏幕上的空像素（光栅化），让片元着色器来计算每个像素的颜色并填充上去，最终将物体渲染到屏幕上</p></blockquote><ul><li>图元装配和光栅化是<code>WebGL</code>自带的操作，无法进行额外的定制，但<strong>顶点着色器和片元着色器则是完全可通过编程来定制化的</strong></li></ul><h4 id="Shader开发环境"><a href="#Shader开发环境" class="headerlink" title="Shader开发环境"></a><code>Shader</code>开发环境</h4><p>在线开发工具</p><ul><li><a href="https://www.shadertoy.com/">ShaderToy</a>: 一个实时运行和分享<code>Shader</code>的在线平台</li><li><a href="https://codesandbox.io/s/kokomi-js-starter-tjh29w?file=/src/app.ts">codesandbox</a>: 偏向工程化的<code>Template</code></li><li><code>jsfiddle</code>: <code>Fork</code>下面的<code>fiddle</code>然后编辑<code>JS</code> (当然也可以在<code>codepen</code>里写)</li></ul><iframe width="100%" height="400" src="//jsfiddle.net/HDL52/ftos1vp6/15/embedded/result/dark/" frameborder="0" loading="lazy" allowtransparency="true" allowfullscreen="true"></iframe><!-- - `stackblitz`: `Fork`下面的`blitz`然后编辑`JS`<iframe width="100%" height="400" src="https://stackblitz.com/edit/stackblitz-starters-7fggovzz?embed=1&file=script.js&hideExplorer=1&hideNavigation=1&theme=dark&view=preview" frameborder="0" loading="lazy" allowtransparency="true" allowfullscreen="true"></iframe> --><p>编辑器开发工具</p><ul><li><code>VSCode</code>: 安装以下插件 <code>Shader language support</code>, <code>Shader Toy</code>, <code>Live Preview</code>, <code>glsl-canvas</code></li></ul><h4 id="实现第一个Shader"><a href="#实现第一个Shader" class="headerlink" title="实现第一个Shader"></a>实现第一个<code>Shader</code></h4><p><code>GLSL</code>语言的<code>Shader</code>文件后缀名是<code>.glsl</code></p><ul><li>下面定义了一个<code>mainImage</code>函数，它不返回任何值，故返回类型为<code>void</code>。它接受<code>2</code>个参数，一个是<code>4</code>维的<code>fragColor</code>，代表输出的像素颜色。另一个是<code>2</code>维的<code>fragCoord</code>，代表输入的像素坐标</li></ul><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> mainImage(<span class="keyword">out</span> <span class="type">vec4</span> fragColor,<span class="keyword">in</span> <span class="type">vec2</span> fragCoord)&#123;</span><br><span class="line">    <span class="type">vec3</span> color = <span class="type">vec3</span>(<span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>); <span class="comment">// 定义红色</span></span><br><span class="line">    fragColor = <span class="type">vec4</span>(color, <span class="number">1.0</span>);     <span class="comment">// 输出红色</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>上面代码定义了一个名为<code>color</code>的<code>3</code>维变量，将它的值设置为红色，红色的<code>RGB</code>颜色值为<code>(255,0,0)</code>，在<code>GLSL</code>中，需要先将颜色原先的值进行归一化操作（除以<code>255</code>）后才能将它正确地输出，因此将红色的值归一化后就得到了<code>(1,0,0)</code>这个值，将它转换为<code>3</code>维变量<code>vec3(1.,0.,0.)</code>赋给<code>color</code>变量</p></li><li><p>最后给输出颜色<code>fragColor</code>赋值一个<code>4</code>维变量，前<code>3</code>维就是<code>color</code>这个颜色变量，最后一维是透明度，由于纯红色并不透明，直接将其设为<code>1</code>即可</p></li></ul><iframe width="100%" height="400" src="//jsfiddle.net/HDL52/8p2obeju/1/embedded/result/dark/" frameborder="0" loading="lazy" allowtransparency="true" allowfullscreen="true"></iframe><ul><li><p>当然也可以通过判断像素坐标范围，给不同区域填充不同的颜色</p></li><li><p>这里就要用到<code>fragCoord</code>变量，它代表了输入的像素坐标，有<code>2</code>个维度<code>xy</code>，它们的大小取决于画面本身的大小。假设画面当前的大小为<code>1536x864</code>，那么每一个像素的<code>fragCoord</code>的<code>x</code>坐标值将会分布在<code>(0,1536)</code>之间，<code>y</code>坐标值则分布在<code>(0,864)</code>之间</p></li><li><p>在当前的<code>Shader</code>开发环境内，还有个内置的变量<code>iResolution</code>，代表了画面整体的大小，使用它时一般会取它的<code>xy</code>维度</p></li></ul><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> mainImage(<span class="keyword">out</span> <span class="type">vec4</span> fragColor, <span class="keyword">in</span> <span class="type">vec2</span> fragCoord) &#123;</span><br><span class="line">    <span class="type">vec3</span> color1 = <span class="type">vec3</span>(<span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>); <span class="comment">// 红色</span></span><br><span class="line">    <span class="type">vec3</span> color2 = <span class="type">vec3</span>(<span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>); <span class="comment">// 绿色</span></span><br><span class="line">    <span class="type">vec3</span> color3 = <span class="type">vec3</span>(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>); <span class="comment">// 蓝色</span></span><br><span class="line">    <span class="type">vec3</span> color4 = <span class="type">vec3</span>(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>); <span class="comment">// 黄色</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fragCoord.x &lt; iResolution.x * <span class="number">0.25</span>) &#123;</span><br><span class="line">        fragColor = <span class="type">vec4</span>(color1, <span class="number">1.0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (fragCoord.x &lt; iResolution.x * <span class="number">0.5</span>) &#123;</span><br><span class="line">        fragColor = <span class="type">vec4</span>(color2, <span class="number">1.0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (fragCoord.x &lt; iResolution.x * <span class="number">0.75</span>) &#123;</span><br><span class="line">        fragColor = <span class="type">vec4</span>(color3, <span class="number">1.0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fragColor = <span class="type">vec4</span>(color4, <span class="number">1.0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>之所以能够显示出四种颜色，是因为<code>GPU</code>会对屏幕上的每一个像素点进行独立的并行计算</li></ul><iframe width="100%" height="400" src="//jsfiddle.net/HDL52/qtzxg7dj/1/embedded/result/dark/" frameborder="0" loading="lazy" allowtransparency="true" allowfullscreen="true"></iframe><hr><h3 id="GLSL基础知识"><a href="#GLSL基础知识" class="headerlink" title="GLSL基础知识"></a><code>GLSL</code>基础知识</h3><p><code>GLSL</code>是一种类似<code>C</code>的语言，用于控制<code>GPU</code>的渲染逻辑，如果有<code>C/C++</code>的基础会更容易理解，以下内容将逐步介绍<code>GLSL</code>的核心知识</p><h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><ul><li>一维变量（标量）: 比如<code>int</code>，<code>float</code>，<code>bool</code>。浮点型<code>float</code>可以说是<code>GLSL</code>里最常用的类型，浮点型变量必须要有小数点，不能省略，而且语句结尾一定要加一个分号<code>;</code></li></ul><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span> foo = <span class="number">1.0</span>; <span class="comment">// 浮点型</span></span><br><span class="line"><span class="type">int</span> bar = <span class="number">10</span>;    <span class="comment">// 整型</span></span><br><span class="line"><span class="type">bool</span> flag = <span class="literal">true</span>; <span class="comment">// 布尔型</span></span><br></pre></td></tr></table></figure><ul><li>向量变量: 向量类型支持<code>3</code>种维度，二维<code>vec2</code>、三维<code>vec3</code>和四维<code>vec4</code>，通过<code>.x</code>,<code>.y</code>,<code>.z</code>,<code>.w</code>（或<code>.r</code>,<code>.g</code>,<code>.b</code>,<code>.a</code>）访问。如果想对多维度变量进行取值或赋值操作，就要用到<code>.</code>符号，并且四个维度可以任意组合（称为<code>Swizzling</code>）</li></ul><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="type">vec2</span> a = <span class="type">vec2</span>(<span class="number">1.0</span>, <span class="number">0.0</span>);  <span class="comment">// 二维向量</span></span><br><span class="line"></span><br><span class="line"><span class="type">vec3</span> b = <span class="type">vec3</span>(<span class="number">1.0</span>, <span class="number">0.5</span>, <span class="number">0.0</span>);  <span class="comment">// 三维向量</span></span><br><span class="line"><span class="type">vec2</span> d = b.xy; <span class="comment">// 提取 b 的 x 和 y 分量，构成二维向量 d (1.0, 0.5)</span></span><br><span class="line">d.y = <span class="number">2.0</span>; <span class="comment">// 修改 d 的 y 分量为 2.0</span></span><br><span class="line"></span><br><span class="line"><span class="type">vec4</span> c = <span class="type">vec4</span>(<span class="number">1.0</span>, <span class="number">0.5</span>, <span class="number">0.0</span>, <span class="number">1.0</span>); <span class="comment">// 四维向量</span></span><br><span class="line"><span class="type">vec3</span> e = c.yxy; <span class="comment">// 重组 c 的分量，形成一个新的三维向量 (0.5, 1.0, 0.5)</span></span><br><span class="line">e.zx = <span class="type">vec2</span>(<span class="number">1.0</span>); <span class="comment">// 修改 e 的 z 和 x 分量为 1.0</span></span><br></pre></td></tr></table></figure><ul><li>矩阵变量: 矩阵用于线性变换，<code>mat2</code>类型代表了一个大小是<code>2x2</code>的矩阵，<code>mat3</code>类型则代表了一个<code>3x3</code>的矩阵、<code>mat4</code>类型是<code>4x4</code>的矩阵</li></ul><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="type">mat2</span> m1 = <span class="type">mat2</span>(<span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>);  <span class="comment">// 2x2 矩阵</span></span><br><span class="line"><span class="type">mat3</span> m2 = <span class="type">mat3</span>(<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">2.0</span>, <span class="number">1.0</span>); <span class="comment">// 3x3 矩阵</span></span><br></pre></td></tr></table></figure><ul><li>结构体: 如果想把多个变量捆绑到一个变量上，可以使用结构体<code>struct</code></li></ul><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">struct Ray &#123;</span><br><span class="line">    <span class="type">vec3</span> ro;  <span class="comment">// 起点</span></span><br><span class="line">    <span class="type">vec3</span> rd;  <span class="comment">// 方向</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Ray ray = Ray(<span class="type">vec3</span>(<span class="number">0.0</span>), <span class="type">vec3</span>(<span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>));</span><br></pre></td></tr></table></figure><h4 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h4><ul><li><p><code>GLSL</code>支持常见的算术运算符和赋值运算符</p></li><li><p>要注意的一点是，运算一定要保证维度的匹配，比如不能将一个<code>vec2</code>的变量与一个<code>vec3</code>的变量相加，要加的话得选取<code>vec3</code>变量的其中<code>2</code>个维度，转成<code>vec2</code>变量才能与另一个<code>vec2</code>变量相加</p></li><li><p>也有一种特殊的情况，当<strong>一个向量和一个标量进行运算</strong>时，<code>GLSL</code>会将标量广播（<code>broadcast</code>）到向量的每一个分量上</p></li></ul><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="type">vec2</span> v = <span class="type">vec2</span>(<span class="number">1.0</span>, <span class="number">2.0</span>);</span><br><span class="line">v += <span class="number">1.0</span>; <span class="comment">// v 的值为 vec2(2.0, 3.0)</span></span><br></pre></td></tr></table></figure><h4 id="控制流"><a href="#控制流" class="headerlink" title="控制流"></a>控制流</h4><ul><li>和常规的编程语言一样，<code>GLSL</code>有基本的控制流结构</li></ul><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line">    <span class="comment">// 条件满足时执行</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 条件不满足时执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>这里要注意一点，<code>Shader</code>是针对整个屏幕的像素进行处理的，因此<code>if</code>的所有分支只要满足一定的条件，都会被执行。这是由于<code>GPU</code>的<strong>并行特性</strong>和<strong>像素级独立处理</strong>的工作方式</li></ul><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (fragCoord.x &lt; iResolution.x * <span class="number">0.25</span>)</span><br><span class="line">    fragColor = <span class="type">vec4</span>(<span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>); <span class="comment">// 红色</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (fragCoord.x &lt; iResolution.x * <span class="number">0.5</span>)</span><br><span class="line">    fragColor = <span class="type">vec4</span>(<span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>); <span class="comment">// 绿色</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    fragColor = <span class="type">vec4</span>(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>); <span class="comment">// 蓝色</span></span><br></pre></td></tr></table></figure><ul><li><code>GPU</code>会为屏幕上的每个像素单独运行一遍<code>Fragment Shader</code>代码，代码中的<code>if</code>条件根据每个像素的位置（<code>fragCoord.x</code>）来决定应该执行哪一段代码</li></ul><iframe width="100%" height="400" src="//jsfiddle.net/HDL52/0wrkqhm2/2/embedded/result/dark/" frameborder="0" loading="lazy" allowtransparency="true" allowfullscreen="true"></iframe><h4 id="变量限定符"><a href="#变量限定符" class="headerlink" title="变量限定符"></a>变量限定符</h4><p>变量限定符是用来描述变量的存储和使用方式的关键词</p><ul><li><code>GLSL</code>中常用的变量限定符有以下几种，<code>uniform</code>、<code>const</code>、<code>varying</code>、<code>attribute</code></li></ul><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="keyword">uniform</span> <span class="type">vec3</span> uColor; <span class="comment">// 定义统一的颜色变量</span></span><br><span class="line"><span class="keyword">varying</span> <span class="type">vec3</span> vColor; <span class="comment">// 顶点着色器向片元着色器传递的颜色 (旧版 GLSL)</span></span><br><span class="line"><span class="keyword">attribute</span> <span class="type">vec3</span> aPosition; <span class="comment">// 传递顶点位置 (旧版 GLSL)</span></span><br></pre></td></tr></table></figure><ul><li><code>uniform</code>: 全局变量，一旦定义后会同时存在于顶点着色器与片元着色器中，并且它在每一个顶点和片元上的值都是相同的，是一个“统一”的值</li><li><code>const</code>: 定义常量，它是无法被改变的一个值</li><li><code>iTime</code>: 表示<code>Shader</code>从开始到现在执行所经过的时间，用于创作动画效果</li><li><code>iResolution</code>: 表示<code>Shader</code>所在画布的大小，默认是占满整个屏幕</li><li><code>iMouse</code>: 表示用户鼠标当前所在的位置</li></ul><h4 id="宏定义"><a href="#宏定义" class="headerlink" title="宏定义"></a>宏定义</h4><p>宏（<code>macros</code>）是一种预处理指令，用于在编译时进行文本的替换，常用于定义常量、函数、条件编译等</p><ul><li>宏定义的格式是<code>#define 宏的名称 宏的值</code>，语句结尾没有分号。下面代码定义了一个名为<code>PI</code>的宏，<code>Shader</code>编译时会将所有的<code>PI</code>替换为<code>3.14159265359</code>这个值</li></ul><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="meta">#define PI 3.14159265359</span></span><br></pre></td></tr></table></figure><ul><li>宏也可以带有参数。下面代码定义了一个名为<code>add</code>的宏，接受<code>2</code>个参数<code>a</code>和<code>b</code>，对它们应用相加的运算，并且无需指定明确的类型，调用这个宏时只要参数的类型相匹配，就能正确执行宏定义的运算</li></ul><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="meta">#define add(a,b) a+b</span></span><br></pre></td></tr></table></figure><ul><li>宏也可以条件编译。下面代码会在<strong>编译时</strong>通过<code>#if</code>判断宏<code>USE_COLOR</code>的值是否为<code>1</code>，如果<code>USE_COLOR == 1</code>，代码会保留红色的定义，反之，代码会保留黑色的定义</li></ul><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="meta">#define USE_COLOR 1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#if USE_COLOR == 1</span></span><br><span class="line">    <span class="type">vec3</span> color = <span class="type">vec3</span>(<span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>);</span><br><span class="line"><span class="meta">#else</span></span><br><span class="line">    <span class="type">vec3</span> color = <span class="type">vec3</span>(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>);</span><br><span class="line"><span class="meta">#endif</span></span><br></pre></td></tr></table></figure><hr><h3 id="UV基础与核心概念"><a href="#UV基础与核心概念" class="headerlink" title="UV基础与核心概念"></a><code>UV</code>基础与核心概念</h3><h4 id="UV坐标"><a href="#UV坐标" class="headerlink" title="UV坐标"></a><code>UV</code>坐标</h4><ul><li><code>UV</code>坐标是一种将像素坐标归一化到<code>[0.0, 1.0]</code>范围的坐标系，其中<code>U</code>代表水平方向（<code>x</code>坐标），<code>V</code>代表垂直方向（<code>y</code>坐标）</li><li>在<code>Shader</code>编程中，<code>UV</code>坐标用于描述画布上的归一化像素位置，通常由片元着色器中的<code>fragCoord</code>和<code>iResolution</code>计算得出，下面是<strong>归一化公式</strong></li></ul><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> mainImage(<span class="keyword">out</span> <span class="type">vec4</span> fragColor, <span class="keyword">in</span> <span class="type">vec2</span> fragCoord) &#123;</span><br><span class="line">    <span class="type">vec2</span> uv = fragCoord / iResolution.xy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="UV坐标的分布特性"><a href="#UV坐标的分布特性" class="headerlink" title="UV坐标的分布特性"></a><code>UV</code>坐标的分布特性</h4><ul><li>先看下<code>x</code>坐标的分布情况</li></ul><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> mainImage(<span class="keyword">out</span> <span class="type">vec4</span> fragColor, <span class="keyword">in</span> <span class="type">vec2</span> fragCoord) &#123;</span><br><span class="line">    <span class="type">vec2</span> uv = fragCoord / iResolution.xy;</span><br><span class="line">    fragColor = <span class="type">vec4</span>(uv.x, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>现在默认颜色的第<code>3</code>个值是<code>0</code>，只看前<code>2</code>个值。可以看到<code>x</code>坐标从左边开始是黑色，值是<code>(0,0)</code>，到最右边是纯红色，值是<code>(1,0)</code>，而中间则是分布在<code>(0,1)</code>之间的值。从整体上看，得到了一个横向的渐变图案</li></ul><iframe width="100%" height="400" src="//jsfiddle.net/HDL52/q0wxagrm/1/embedded/result/dark/" frameborder="0" loading="lazy" allowtransparency="true" allowfullscreen="true"></iframe><ul><li>再看下<code>y</code>坐标的分布情况</li></ul><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> mainImage(<span class="keyword">out</span> <span class="type">vec4</span> fragColor, <span class="keyword">in</span> <span class="type">vec2</span> fragCoord) &#123;</span><br><span class="line">    <span class="type">vec2</span> uv = fragCoord / iResolution.xy;</span><br><span class="line">    fragColor = <span class="type">vec4</span>(<span class="number">0.0</span>, uv.y, <span class="number">0.0</span>, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>可以看到<code>y</code>坐标从底下开始是黑色，值是<code>(0,0)</code>，到最上面是纯绿色，值是<code>(0,1)</code>，而中间则是分布在<code>(0,1)</code>之间的值。从整体上看，得到了一个纵向的渐变图案</li></ul><iframe width="100%" height="400" src="//jsfiddle.net/HDL52/arktw6dy/14/embedded/result/dark/" frameborder="0" loading="lazy" allowtransparency="true" allowfullscreen="true"></iframe><ul><li>接下来同时输出<code>x</code>坐标和<code>y</code>坐标的分布</li></ul><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> mainImage(<span class="keyword">out</span> <span class="type">vec4</span> fragColor, <span class="keyword">in</span> <span class="type">vec2</span> fragCoord) &#123;</span><br><span class="line">    <span class="type">vec2</span> uv = fragCoord / iResolution.xy;</span><br><span class="line">    fragColor = <span class="type">vec4</span>(uv, <span class="number">0.0</span>, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>左下角原点是黑色，值是<code>(0,0)</code>，右下角是红色，值是<code>(1,0)</code>，左上角是绿色，值是<code>(0,1)</code>，右上角是黄色，值是<code>(1,1)</code>，中间的所有值在<code>(0,0)</code>到<code>(1,1)</code>这<code>2</code>个区间分布。从整体上看，得到了一个有多种颜色的渐变图案</li></ul><iframe width="100%" height="400" src="//jsfiddle.net/HDL52/beun0ztc/1/embedded/result/dark/" frameborder="0" loading="lazy" allowtransparency="true" allowfullscreen="true"></iframe><ul><li>上面就是所谓的<code>UV</code>坐标，它代表了图像（这里指画布）上所有像素的归一化后的坐标位置，其中<code>U</code>代表水平方向，<code>V</code>代表垂直方向</li></ul><h4 id="图形绘制-圆形"><a href="#图形绘制-圆形" class="headerlink" title="图形绘制 (圆形)"></a>图形绘制 (圆形)</h4><ul><li>先计算<code>UV</code>坐标上的点到原点的距离，然后根据这些距离的值来设定对应点的颜色</li><li>为了计算<code>UV</code>上点到原点的距离，可以用<code>GLSL</code>的内置函数<code>length</code>函数来实现</li></ul><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> mainImage(<span class="keyword">out</span> <span class="type">vec4</span> fragColor, <span class="keyword">in</span> <span class="type">vec2</span> fragCoord) &#123;</span><br><span class="line">    <span class="type">vec2</span> uv = fragCoord / iResolution.xy;</span><br><span class="line">    <span class="type">float</span> d = <span class="built_in">length</span>(uv);</span><br><span class="line">    fragColor = <span class="type">vec4</span>(<span class="type">vec3</span>(d), <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>左下角原点是黑色，值是<code>(0,0)</code>，从原点向右上方向辐射的径向渐变，上面每个点的值代表的就是该点到原点的距离，越靠近原点距离越小，越接近黑色，反之越远离原点距离越大，越接近白色</li></ul><iframe width="100%" height="400" src="//jsfiddle.net/HDL52/tphn4ge7/1/embedded/result/dark/" frameborder="0" loading="lazy" allowtransparency="true" allowfullscreen="true"></iframe><ul><li>目前图形的位置在左下角，把它挪到中间，将<code>UV</code>的坐标减去<code>0.5</code>，再整体乘上<code>2</code>，这一步被称为“<code>UV</code>的居中处理”</li></ul><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> mainImage(<span class="keyword">out</span> <span class="type">vec4</span> fragColor, <span class="keyword">in</span> <span class="type">vec2</span> fragCoord) &#123;</span><br><span class="line">    <span class="type">vec2</span> uv = fragCoord / iResolution.xy;</span><br><span class="line">    uv = (uv - <span class="number">0.5</span>) * <span class="number">2.0</span>;</span><br><span class="line">    fragColor = <span class="type">vec4</span>(uv, <span class="number">0.0</span>, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><iframe width="100%" height="400" src="//jsfiddle.net/HDL52/kc9tjwpq/2/embedded/result/dark/" frameborder="0" loading="lazy" allowtransparency="true" allowfullscreen="true"></iframe><ul><li>看下操作前后的对比图</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/imgb29b63a75cb74fb9abe31376184db120%7Etplv-k3u1fbpfcp-jj-mark_3024_0_0_0_q75.awebp"></p><ul><li><p>之前的坐标系原点是第一幅图左下角的<code>(0,0)</code>，通过整体减去<code>0.5</code>，将原点变成了<code>(-0.5,-0.5)</code>，也就是第二幅图左下角的那个点的位置，第一幅图的中点<code>(0.5,0.5)</code>就变成了第二幅图的中点<code>(0,0)</code>，然后，将坐标整体乘上<code>2</code>，将<code>0.5</code>变成了<code>1</code>，这样归一化后能方便后续的计算</p></li><li><p>理解<code>UV</code>的居中处理后，将<code>UV</code>坐标输出的代码注释掉，换回之前的距离代码</p></li></ul><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> mainImage(<span class="keyword">out</span> <span class="type">vec4</span> fragColor, <span class="keyword">in</span> <span class="type">vec2</span> fragCoord) &#123;</span><br><span class="line">    <span class="type">vec2</span> uv = fragCoord / iResolution.xy;</span><br><span class="line">    uv = (uv - <span class="number">0.5</span>) * <span class="number">2.0</span>;</span><br><span class="line">    <span class="type">float</span> d = <span class="built_in">length</span>(uv);</span><br><span class="line">    fragColor = <span class="type">vec4</span>(<span class="type">vec3</span>(d), <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>可以看到图形确实被挪到了中间。然而，图形目前的形状是一个椭圆，这是为什么呢？因为<code>UV</code>坐标的值并不会自动地适应画布的比例，导致了图形被拉伸这一现象</li></ul><iframe width="100%" height="400" src="//jsfiddle.net/HDL52/rcogqxp6/2/embedded/result/dark/" frameborder="0" loading="lazy" allowtransparency="true" allowfullscreen="true"></iframe><ul><li>为了修正这一点，需要计算画布的比例，将画布长除以画布宽就能算出，再将<code>UV</code>的<code>x</code>坐标与比例相乘即可</li></ul><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> mainImage(<span class="keyword">out</span> <span class="type">vec4</span> fragColor, <span class="keyword">in</span> <span class="type">vec2</span> fragCoord) &#123;</span><br><span class="line">    <span class="type">vec2</span> uv = fragCoord / iResolution.xy;</span><br><span class="line">    uv = (uv - <span class="number">0.5</span>) * <span class="number">2.0</span>;</span><br><span class="line">    uv.x *= iResolution.x / iResolution.y;</span><br><span class="line">    <span class="type">float</span> d = <span class="built_in">length</span>(uv);</span><br><span class="line">    fragColor = <span class="type">vec4</span>(<span class="type">vec3</span>(d), <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>上面代码得到了一个完整的圆形径向渐变。中点的值是<code>(0,0)</code>，颜色是纯黑色，然而从中点开始向四周辐射的那些区域，它们的值都大于<code>0</code>，不是纯黑色。我们的目标，是要把其中的一片区域也变成纯黑色，也就是说要把分布在这片区域上面的点的值也变成<code>0</code></li></ul><iframe width="100%" height="400" src="//jsfiddle.net/HDL52/hnfbt9a7/2/embedded/result/dark/" frameborder="0" loading="lazy" allowtransparency="true" allowfullscreen="true"></iframe><ul><li>在<code>Shader</code>中，值的显示范围只会是<code>[0,1]</code>之间，小于<code>0</code>的负数实际显示的值还是<code>0</code>（黑色），大于<code>1</code>的数实际显示的值还是<code>1</code>（白色）。可以利用这一点，给距离<code>d</code>减去一个值（这里取<code>0.5</code>），制造出一片负数的区域，而这片区域就是黑色</li></ul><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> mainImage(<span class="keyword">out</span> <span class="type">vec4</span> fragColor, <span class="keyword">in</span> <span class="type">vec2</span> fragCoord) &#123;</span><br><span class="line">    <span class="type">vec2</span> uv = fragCoord / iResolution.xy;</span><br><span class="line">    uv = (uv - <span class="number">0.5</span>) * <span class="number">2.0</span>;</span><br><span class="line">    uv.x *= iResolution.x / iResolution.y;</span><br><span class="line">    <span class="type">float</span> d = <span class="built_in">length</span>(uv);</span><br><span class="line">    d -= <span class="number">0.5</span>;</span><br><span class="line">    fragColor = <span class="type">vec4</span>(<span class="type">vec3</span>(d), <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>中间确实出现了纯黑色的圆形区域，然后只需把周围的渐变给消除，就能得到真正的圆形</li></ul><iframe width="100%" height="400" src="//jsfiddle.net/HDL52/waL3k1b0/1/embedded/result/dark/" frameborder="0" loading="lazy" allowtransparency="true" allowfullscreen="true"></iframe><ul><li>先定义一个中间变量<code>c</code>，用<code>if</code>语句来判断距离<code>d</code>的大小，如果大于<code>0</code>，代表的是除了中间纯黑区域外的渐变区域，将它们的值设为<code>1</code>（白色）。反之，就代表的是中间的纯黑区域，将它们的值设为<code>0</code>（黑色），最后将中间变量直接作为结果输出即可</li></ul><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> mainImage(<span class="keyword">out</span> <span class="type">vec4</span> fragColor, <span class="keyword">in</span> <span class="type">vec2</span> fragCoord) &#123;</span><br><span class="line">    <span class="type">vec2</span> uv = fragCoord / iResolution.xy;</span><br><span class="line">    uv = (uv - <span class="number">0.5</span>) * <span class="number">2.0</span>;</span><br><span class="line">    uv.x *= iResolution.x / iResolution.y;</span><br><span class="line">    <span class="type">float</span> d = <span class="built_in">length</span>(uv);</span><br><span class="line">    d -= <span class="number">0.5</span>;</span><br><span class="line">    <span class="type">float</span> c = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">if</span> (d &gt; <span class="number">0.0</span>) &#123;</span><br><span class="line">        c = <span class="number">1.0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        c = <span class="number">0.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    fragColor = <span class="type">vec4</span>(<span class="type">vec3</span>(c), <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><iframe width="100%" height="400" src="//jsfiddle.net/HDL52/1hgnwc0r/5/embedded/result/dark/" frameborder="0" loading="lazy" allowtransparency="true" allowfullscreen="true"></iframe><ul><li>在<code>Shader</code>的编写中，应当尽量避免使用<code>if</code>语句。因为<code>GPU</code>是并行处理结果的，而<code>if</code>语句会让处理器进行分支切换这一操作，处理多个分支会降低并行处理的性能。</li><li>可以用<code>GLSL</code>其中的一个内置函数来优化掉<code>if</code>语句，这个内置函数是 <code>step</code>函数，也被称作“阶梯函数”，是因为它的图像是阶梯的形状</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/imgc6098091ff504641b13f961d79233dd7%7Etplv-k3u1fbpfcp-jj-mark_3024_0_0_0_q75.awebp"></p><ul><li>它的代码表示形式是这样的</li></ul><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="built_in">step</span>(edge, x)</span><br></pre></td></tr></table></figure><ul><li>它接受<code>2</code>个参数，边界值<code>edge</code>和目标值<code>x</code>，如果目标值<code>x</code>大于边界值<code>edge</code>，则返回<code>1</code>，反之返回<code>0</code></li></ul><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> mainImage(<span class="keyword">out</span> <span class="type">vec4</span> fragColor, <span class="keyword">in</span> <span class="type">vec2</span> fragCoord) &#123;</span><br><span class="line">    <span class="type">vec2</span> uv = fragCoord / iResolution.xy;</span><br><span class="line">    uv = (uv - <span class="number">0.5</span>) * <span class="number">2.0</span>;</span><br><span class="line">    uv.x *= iResolution.x / iResolution.y;</span><br><span class="line">    <span class="type">float</span> d = <span class="built_in">length</span>(uv);</span><br><span class="line">    d -= <span class="number">0.5</span>;</span><br><span class="line">    <span class="type">float</span> c = <span class="built_in">step</span>(<span class="number">0.0</span>, d);</span><br><span class="line">    fragColor = <span class="type">vec4</span>(<span class="type">vec3</span>(c), <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><iframe width="100%" height="400" src="//jsfiddle.net/HDL52/2nz7p9bg/1/embedded/result/dark/" frameborder="0" loading="lazy" allowtransparency="true" allowfullscreen="true"></iframe><ul><li>尽管圆形是画出来了，但仔细一看，就会发现图形的周围有锯齿，比较影响美观，要消除它们</li><li>再来认识一个<code>GLSL</code>的内置函数——<code>smoothstep</code>函数，它也被称作“平滑阶梯函数”，是因为它的函数图像是一个平滑过的阶梯的形状</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img4553d587e19e41af8e44b5639e4b09df%7Etplv-k3u1fbpfcp-jj-mark_3024_0_0_0_q75.awebp"></p><ul><li>它的代码表示形式是这样的</li></ul><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="built_in">smoothstep</span>(edge1, edge2, x)</span><br></pre></td></tr></table></figure><ul><li>它的边界值比<code>step</code>函数要多一个，可以将它的边界值定为<code>edge1</code>和<code>edge2</code>。如果目标值<code>x</code>小于边界值<code>edge1</code>，则返回<code>0</code>。如果目标值<code>x</code>大于边界值<code>edge2</code>，则返回<code>1</code>。如果目标值<code>x</code>在<code>2</code>个边界值之间，则返回从<code>0</code>到<code>1</code>平滑过渡的值</li><li>把之前代码里的<code>step</code>函数的语句注释掉，改成用<code>smoothstep</code>函数来实现，再将第<code>2</code>个边界值设定为一个比<code>0</code>稍微大一点的值。这里取了<code>0.02</code></li></ul><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> mainImage(<span class="keyword">out</span> <span class="type">vec4</span> fragColor, <span class="keyword">in</span> <span class="type">vec2</span> fragCoord) &#123;</span><br><span class="line">    <span class="type">vec2</span> uv = fragCoord / iResolution.xy;</span><br><span class="line">    uv = (uv - <span class="number">0.5</span>) * <span class="number">2.0</span>;</span><br><span class="line">    uv.x *= iResolution.x / iResolution.y;</span><br><span class="line">    <span class="type">float</span> d = <span class="built_in">length</span>(uv);</span><br><span class="line">    d -= <span class="number">0.5</span>;</span><br><span class="line">    <span class="type">float</span> c = <span class="built_in">smoothstep</span>(<span class="number">0.0</span>, <span class="number">0.02</span>, d);</span><br><span class="line">    fragColor = <span class="type">vec4</span>(<span class="type">vec3</span>(c), <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>这样，就得到了一个边缘是平滑的，没有锯齿的圆形</li></ul><iframe width="100%" height="400" src="//jsfiddle.net/HDL52/q3vu9nb7/1/embedded/result/dark/" frameborder="0" loading="lazy" allowtransparency="true" allowfullscreen="true"></iframe><h4 id="图形效果"><a href="#图形效果" class="headerlink" title="图形效果"></a>图形效果</h4><ul><li>尽管<code>Shader</code>的绘图步骤确实要比传统的绘图方式要繁琐一点，但是也带来了很多意想不到的可能性，比方说，它能实现一些特殊的图形效果</li></ul><h5 id="模糊效果"><a href="#模糊效果" class="headerlink" title="模糊效果"></a><p style='font-size: 14px'>模糊效果</p></h5><ul><li>上面代码用到了<code>smoothstep</code>函数来绘制圆形，它的第二个参数用的是一个很小的值<code>0.02</code>，尝试把这个值改大一点，比如<code>0.2</code></li></ul><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> mainImage(<span class="keyword">out</span> <span class="type">vec4</span> fragColor, <span class="keyword">in</span> <span class="type">vec2</span> fragCoord) &#123;</span><br><span class="line">    <span class="type">vec2</span> uv = fragCoord / iResolution.xy;</span><br><span class="line">    uv = (uv - <span class="number">0.5</span>) * <span class="number">2.0</span>;</span><br><span class="line">    uv.x *= iResolution.x / iResolution.y;</span><br><span class="line">    <span class="type">float</span> d = <span class="built_in">length</span>(uv);</span><br><span class="line">    d -= <span class="number">0.5</span>;</span><br><span class="line">    <span class="type">float</span> c = <span class="built_in">smoothstep</span>(<span class="number">0.0</span>, <span class="number">0.2</span>, d);</span><br><span class="line">    fragColor = <span class="type">vec4</span>(<span class="type">vec3</span>(c), <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>随着渐变区域的扩大，圆形的边缘变得模糊了起来，这是因为两个边界值的差变大了，渐变的区域也就随着变大了，这样就营造出了一种模糊的效果</li></ul><iframe width="100%" height="400" src="//jsfiddle.net/HDL52/298mf57z/1/embedded/result/dark/" frameborder="0" loading="lazy" allowtransparency="true" allowfullscreen="true"></iframe><h5 id="发光效果"><a href="#发光效果" class="headerlink" title="发光效果"></a><p style='font-size: 14px'>发光效果</p></h5><ul><li>这里不用<code>smoothstep</code>函数来绘制图形，取距离<code>d</code>的倒数，并且乘上一个比较小的值</li></ul><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> mainImage(<span class="keyword">out</span> <span class="type">vec4</span> fragColor, <span class="keyword">in</span> <span class="type">vec2</span> fragCoord) &#123;</span><br><span class="line">    <span class="type">vec2</span> uv = fragCoord / iResolution.xy;</span><br><span class="line">    uv = (uv - <span class="number">0.5</span>) * <span class="number">2.0</span>;</span><br><span class="line">    uv.x *= iResolution.x / iResolution.y;</span><br><span class="line">    <span class="type">float</span> d = <span class="built_in">length</span>(uv);</span><br><span class="line">    <span class="type">float</span> c = <span class="number">0.25</span> / d;</span><br><span class="line">    fragColor = <span class="type">vec4</span>(<span class="type">vec3</span>(c), <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><iframe width="100%" height="400" src="//jsfiddle.net/HDL52/20jhyq9m/2/embedded/result/dark/" frameborder="0" loading="lazy" allowtransparency="true" allowfullscreen="true"></iframe><ul><li>画面上出现了一个美丽的光球，它是怎么形成的呢</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img59b48526299f48f4b5e1b3adac92425b%7Etplv-k3u1fbpfcp-jj-mark_3024_0_0_0_q75.awebp"></p><ul><li><p>这是个反比例函数的图像，目前输入值范围是<code>(0.,1.)</code>，在这段范围内，输入值位于<code>(0.,.25)</code>时，输出值都大于<code>1</code>，<code>Shader</code>中比<code>1</code>大的值输出的还是白色，因此能看到中间的白色圆形部分。输入值位于<code>(.25,1.)</code>时，输出的值开始变成了比<code>1</code>小的值，而且是逐渐变化的，因此会产生一种渐变的效果</p></li><li><p>目前光的辐射范围太大了，要稍微缩小一些</p></li><li><p>再来认识一个新的内置函数——<code>pow</code>函数，它用于计算数字的指数幂，比如<code>pow(4.,3.)</code>，返回的值就是<code>4</code>的<code>3</code>次方——<code>64</code>，也就是说，<code>pow</code>这个函数能让数值指数般地增长</p></li></ul><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> mainImage(<span class="keyword">out</span> <span class="type">vec4</span> fragColor, <span class="keyword">in</span> <span class="type">vec2</span> fragCoord) &#123;</span><br><span class="line">    <span class="type">vec2</span> uv = fragCoord / iResolution.xy;</span><br><span class="line">    uv = (uv - <span class="number">0.5</span>) * <span class="number">2.0</span>;</span><br><span class="line">    uv.x *= iResolution.x / iResolution.y;</span><br><span class="line">    <span class="type">float</span> d = <span class="built_in">length</span>(uv);</span><br><span class="line">    <span class="type">float</span> c = <span class="number">0.25</span> / d;</span><br><span class="line">    c = <span class="built_in">pow</span>(c, <span class="number">1.6</span>);</span><br><span class="line">    fragColor = <span class="type">vec4</span>(<span class="type">vec3</span>(c), <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><iframe width="100%" height="400" src="//jsfiddle.net/HDL52/yf4gt3L5/1/embedded/result/dark/" frameborder="0" loading="lazy" allowtransparency="true" allowfullscreen="true"></iframe><ul><li>为了理解这一步，依旧来看图</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img88ddcf2cfc24418aa5c405b7e57b2110%7Etplv-k3u1fbpfcp-jj-mark_3024_0_0_0_q75.awebp"></p><ul><li>函数图像比之前要往下“躺”了一些，输出值总体变小了，这样光的辐射也稍微缩小了一点</li></ul><h4 id="SDF函数"><a href="#SDF函数" class="headerlink" title="SDF函数"></a><code>SDF</code>函数</h4><ul><li>圆形是众多几何图形中的其中一种，既然已经通过上面的方式将它画了出来，那肯定也能用类似的手段来把其他图形给画出来</li><li>绘制圆形时，在调用<code>smoothstep</code>函数之前做了如下的操作</li></ul><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span> d = <span class="built_in">length</span>(uv);</span><br><span class="line">d -= <span class="number">0.5</span>;</span><br></pre></td></tr></table></figure><ul><li>其实，可以把这些操作抽象成一个函数，叫<code>sdCircle</code></li></ul><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span> sdCircle(<span class="type">vec2</span> p, <span class="type">float</span> r) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">length</span>(p) - r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> mainImage(<span class="keyword">out</span> <span class="type">vec4</span> fragColor, <span class="keyword">in</span> <span class="type">vec2</span> fragCoord) &#123;</span><br><span class="line">    <span class="type">vec2</span> uv = fragCoord / iResolution.xy;</span><br><span class="line">    <span class="type">float</span> d = sdCircle(uv, <span class="number">0.5</span>);</span><br><span class="line">    fragColor = <span class="type">vec4</span>(<span class="type">vec3</span>(d), <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>尽管这个函数的调用结果跟之前写的一模一样，但它有一个特殊的含义，它是一个<code>SDF</code>函数</li><li><code>SDF</code>函数（<code>Signed Distance Function</code>），中文译作“符号距离函数”，它用于描述这么一个函数，它将空间里的一个位置作为输入，并返回该位置到给定形状的距离，它的前面还有个“符号”，是因为在形状外的距离为正数（“<code>+</code>”号），在形状内的距离为负数（“<code>-</code>”号），边界处的值恰好为<code>0</code></li><li>下图是圆形<code>SDF</code>函数的可视化图，可以更形象地理解它的意义</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img302511b0a5124c039ddcc8b15bd2a764%7Etplv-k3u1fbpfcp-jj-mark_3024_0_0_0_q75.awebp"></p><blockquote><p>图形学大咖<code>Inigo Quilez</code>（后文简称<code>iq</code>）的博客上有篇文章把常用的<code>2D</code>图形的<code>SDF</code>函数都列了出来，如果有需要可以<a href="https://iquilezles.org/articles/distfunctions2d/">随时查阅</a></p></blockquote><ul><li>知道<code>SDF</code>函数的概念后，绘制其他图形将会变得非常轻松，比如想要画一个长方形，那么只需找到长方形的<code>SDF</code>函数（<code>sdBox</code>），调用它获取距离，再用<code>step</code>或<code>smoothstep</code>函数勾画出图形即可</li></ul><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span> sdBox(<span class="keyword">in</span> <span class="type">vec2</span> p, <span class="keyword">in</span> <span class="type">vec2</span> b)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">vec2</span> d = <span class="built_in">abs</span>(p) - b;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">length</span>(<span class="built_in">max</span>(d, <span class="type">vec2</span>(<span class="number">0.</span>))) + <span class="built_in">min</span>(<span class="built_in">max</span>(d.x, d.y), <span class="number">0.</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> mainImage(<span class="keyword">out</span> <span class="type">vec4</span> fragColor, <span class="keyword">in</span> <span class="type">vec2</span> fragCoord)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">vec2</span> uv = fragCoord / iResolution.xy;</span><br><span class="line">    uv = (uv - <span class="type">vec2</span>(<span class="number">0.5</span>)) * <span class="number">2.0</span>;</span><br><span class="line">    uv.x *= iResolution.x / iResolution.y;</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> d = sdBox(uv, <span class="type">vec2</span>(<span class="number">0.6</span>, <span class="number">0.3</span>));</span><br><span class="line">    <span class="type">float</span> c = <span class="built_in">smoothstep</span>(<span class="number">0.0</span>, <span class="number">0.02</span>, d);</span><br><span class="line">    fragColor = <span class="type">vec4</span>(<span class="type">vec3</span>(c), <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>上面的代码画出了一个半尺寸长为<code>0.6</code>、宽为<code>0.3</code>（实际长为<code>1.2</code>、宽为<code>0.6</code>）的长方形</li><li>在<code>SDF</code>中，矩形的<code>sdBox</code>函数定义的<code>b</code>参数（如<code>vec2(0.6, 0.3)</code>）表示的是矩形的半尺寸。这是因为<code>SDF</code>函数设计时，通常使用半尺寸来计算方便</li></ul><iframe width="100%" height="400" src="//jsfiddle.net/HDL52/f6Lwb17t/2/embedded/result/dark/" frameborder="0" loading="lazy" allowtransparency="true" allowfullscreen="true"></iframe><h4 id="UV变换"><a href="#UV变换" class="headerlink" title="UV变换"></a><code>UV</code>变换</h4><ul><li>基于已经画好的这个长方形，来学习一些基本的<code>UV</code>变换操作</li></ul><h5 id="平移"><a href="#平移" class="headerlink" title="平移"></a><p style='font-size: 14px'>平移</p></h5><ul><li>先尝试给<code>UV</code>的<code>x</code>或<code>y</code>坐标加上想移动的值</li></ul><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span> sdBox(<span class="keyword">in</span> <span class="type">vec2</span> p, <span class="keyword">in</span> <span class="type">vec2</span> b)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">vec2</span> d = <span class="built_in">abs</span>(p) - b;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">length</span>(<span class="built_in">max</span>(d, <span class="type">vec2</span>(<span class="number">0.0</span>))) + <span class="built_in">min</span>(<span class="built_in">max</span>(d.x, d.y), <span class="number">0.0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> mainImage(<span class="keyword">out</span> <span class="type">vec4</span> fragColor, <span class="keyword">in</span> <span class="type">vec2</span> fragCoord)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">vec2</span> uv = fragCoord / iResolution.xy;</span><br><span class="line">    uv = (uv - <span class="type">vec2</span>(<span class="number">0.5</span>)) * <span class="number">2.0</span>;</span><br><span class="line">    uv.x *= iResolution.x / iResolution.y;</span><br><span class="line">    uv.x += <span class="number">0.2</span>;</span><br><span class="line">    uv.y += <span class="number">0.4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> d = sdBox(uv, <span class="type">vec2</span>(<span class="number">0.6</span>, <span class="number">0.3</span>));</span><br><span class="line">    <span class="type">float</span> c = <span class="built_in">smoothstep</span>(<span class="number">0.0</span>, <span class="number">0.02</span>, d);</span><br><span class="line">    fragColor = <span class="type">vec4</span>(<span class="type">vec3</span>(c), <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><iframe width="100%" height="400" src="//jsfiddle.net/HDL52/b2Lmw09n/1/embedded/result/dark/" frameborder="0" loading="lazy" allowtransparency="true" allowfullscreen="true"></iframe><ul><li>明明是给坐标加上了值，为什么图形的坐标并未朝右上移动，而是朝相反的左下方向移动了呢</li></ul><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> mainImage(<span class="keyword">out</span> <span class="type">vec4</span> fragColor, <span class="keyword">in</span> <span class="type">vec2</span> fragCoord)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">vec2</span> uv = fragCoord / iResolution.xy;</span><br><span class="line">    uv = (uv - <span class="type">vec2</span>(<span class="number">0.5</span>)) * <span class="number">2.0</span>;</span><br><span class="line">    uv.x *= iResolution.x / iResolution.y;</span><br><span class="line">    uv.x += <span class="number">0.2</span>;</span><br><span class="line">    uv.y += <span class="number">0.4</span>;</span><br><span class="line">    fragColor = <span class="type">vec4</span>(uv, <span class="number">0.0</span>, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img57f5a49e288c4afa9bbd2e9cf103fba6%7Etplv-k3u1fbpfcp-jj-mark_3024_0_0_0_q75.awebp"></p><ul><li>之前位于中间的原点值是<code>(0,0)</code>，现在则变成了<code>(0.2,0.4)</code>，上一个<code>(0,0)</code>移动到了当前中间点的左下方，<code>SDF</code>函数输入的坐标值的原点值是<code>(0,0)</code>，正好对应左下方的那个点，因此图形才会整体往左下方移动</li><li>为了确定<code>SDF</code>图形位置的变化，要看目前<code>(0,0)</code>这个点的位置变化。如果要平移符合正方向的移动（右上方），把之前的加法操作改成与其相反的减法操作即可</li></ul><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span> sdBox(<span class="keyword">in</span> <span class="type">vec2</span> p, <span class="keyword">in</span> <span class="type">vec2</span> b)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">vec2</span> d = <span class="built_in">abs</span>(p) - b;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">length</span>(<span class="built_in">max</span>(d, <span class="type">vec2</span>(<span class="number">0.0</span>))) + <span class="built_in">min</span>(<span class="built_in">max</span>(d.x, d.y), <span class="number">0.0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> mainImage(<span class="keyword">out</span> <span class="type">vec4</span> fragColor, <span class="keyword">in</span> <span class="type">vec2</span> fragCoord)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">vec2</span> uv = fragCoord / iResolution.xy;</span><br><span class="line">    uv = (uv - <span class="type">vec2</span>(<span class="number">0.5</span>)) * <span class="number">2.0</span>;</span><br><span class="line">    uv.x *= iResolution.x / iResolution.y;</span><br><span class="line">    uv -= <span class="type">vec2</span>(<span class="number">0.2</span>, <span class="number">0.4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> d = sdBox(uv, <span class="type">vec2</span>(<span class="number">0.6</span>, <span class="number">0.3</span>));</span><br><span class="line">    <span class="type">float</span> c = <span class="built_in">smoothstep</span>(<span class="number">0.0</span>, <span class="number">0.02</span>, d);</span><br><span class="line">    fragColor = <span class="type">vec4</span>(<span class="type">vec3</span>(c), <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><iframe width="100%" height="400" src="//jsfiddle.net/HDL52/94f6p7zd/2/embedded/result/dark/" frameborder="0" loading="lazy" allowtransparency="true" allowfullscreen="true"></iframe><h5 id="缩放"><a href="#缩放" class="headerlink" title="缩放"></a><p style='font-size: 14px'>缩放</p></h5><ul><li>先尝试给<code>UV</code>的<code>x</code>或<code>y</code>坐标乘上想缩放的值</li></ul><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span> sdBox(<span class="keyword">in</span> <span class="type">vec2</span> p, <span class="keyword">in</span> <span class="type">vec2</span> b)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">vec2</span> d = <span class="built_in">abs</span>(p) - b;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">length</span>(<span class="built_in">max</span>(d, <span class="type">vec2</span>(<span class="number">0.0</span>))) + <span class="built_in">min</span>(<span class="built_in">max</span>(d.x, d.y), <span class="number">0.0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> mainImage(<span class="keyword">out</span> <span class="type">vec4</span> fragColor, <span class="keyword">in</span> <span class="type">vec2</span> fragCoord)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">vec2</span> uv = fragCoord / iResolution.xy;</span><br><span class="line">    uv = (uv - <span class="type">vec2</span>(<span class="number">0.5</span>)) * <span class="number">2.0</span>;</span><br><span class="line">    uv.x *= iResolution.x / iResolution.y;</span><br><span class="line">    uv *= <span class="type">vec2</span>(<span class="number">2.0</span>, <span class="number">2.0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> d = sdBox(uv, <span class="type">vec2</span>(<span class="number">0.6</span>, <span class="number">0.3</span>));</span><br><span class="line">    <span class="type">float</span> c = <span class="built_in">smoothstep</span>(<span class="number">0.0</span>, <span class="number">0.02</span>, d);</span><br><span class="line">    fragColor = <span class="type">vec4</span>(<span class="type">vec3</span>(c), <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><iframe width="100%" height="400" src="//jsfiddle.net/HDL52/3o56r9kp/1/embedded/result/dark/" frameborder="0" loading="lazy" allowtransparency="true" allowfullscreen="true"></iframe><ul><li>果不其然，图形并非扩大，而是缩小了相应的倍数</li><li>当坐标范围从<code>[-1.0, 1.0]</code>扩大到<code>[-2.0, 2.0]</code>时，矩形的顶点坐标虽然变大了（例如从<code>0.6</code>变成<code>1.2</code>），但由于画布的整体范围也变大了，矩形在整个画布中的相对比例缩小了。因此，矩形看起来变小了。简单来说，矩形的“绝对大小”没有改变，但它在画布中的“相对大小”变小了</li><li>同样地，如果要符合正方向的缩放（扩大），把之前的乘法操作改成与其相反的除法操作即可</li></ul><h5 id="翻转"><a href="#翻转" class="headerlink" title="翻转"></a><p style='font-size: 14px'>翻转</p></h5><hr><h3 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h3><blockquote></blockquote>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WebGL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GO 学习笔记</title>
      <link href="/posts/558bc4fb.html"/>
      <url>/posts/558bc4fb.html</url>
      
        <content type="html"><![CDATA[<h3 id="1-什么是Go语言"><a href="#1-什么是Go语言" class="headerlink" title="1. 什么是Go语言"></a>1. 什么是<code>Go</code>语言</h3><ul><li><code>Go</code>是由<code>Google</code>开发的一种开源编程语言，设计初衷是让开发者可以快速构建高效的现代应用。<code>Go</code>结合了静态语言的性能和动态语言的开发效率，<ins>特别适合开发高并发的后端服务</ins></li></ul><hr><h3 id="2-包的概念"><a href="#2-包的概念" class="headerlink" title="2. 包的概念"></a>2. 包的概念</h3><ul><li><p><code>Go</code> 用包 (<code>package</code>) 来组织代码，和 <code>Python</code> 的模块差不多。把相关功能的代码放一个目录，就是一个包。包可以被其他包引用，方便复用。</p></li><li><p>有一个特殊的包叫 <code>main</code>，它是程序的入口。每个可执行程序必须有且只有一个 <code>main</code> 包，里面必须有一个 <code>main()</code> 函数。</p></li></ul><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main  <span class="comment">// 声明这是 main 包</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span>  <span class="comment">// 引入 fmt 包，用于打印输出</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;hello go&quot;</span>)</span><br><span class="line">    fmt.Println(<span class="string">&quot;hello haha&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>几个注意点:</p><ul><li>每个 <code>.go</code> 文件开头必须声明属于哪个包</li><li>左花括号 <code>&#123;</code> 必须和函数名同一行，不能换行 (<code>Go</code> 的强制风格)</li><li>语句结尾不用加分号</li><li>注释用 <code>//</code> 或 <code>/* */</code></li></ul><hr><h3 id="3-变量声明"><a href="#3-变量声明" class="headerlink" title="3. 变量声明"></a>3. 变量声明</h3><p><code>Go</code> 声明变量有三种写法:</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name <span class="type">string</span> = <span class="string">&quot;Hongda&quot;</span>   <span class="comment">// 完整写法: var + 名字 + 类型 + 值</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;Hongda&quot;</span>          <span class="comment">// 省略类型，编译器自动推断</span></span><br><span class="line">name := <span class="string">&quot;Hongda&quot;</span>             <span class="comment">// 短声明，最常用</span></span><br></pre></td></tr></table></figure><p>短声明 <code>:=</code> 写起来最简洁，日常用得最多。但它只能在函数内部用，包级别的变量必须用 <code>var</code>。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> globalVar = <span class="string">&quot;我是全局变量&quot;</span>  <span class="comment">// 包级别，必须用 var</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    localVar := <span class="string">&quot;我是局部变量&quot;</span>  <span class="comment">// 函数内，短声明 OK</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>零值</strong>: 变量声明了但没赋值，<code>Go</code> 会给默认值，叫”零值”。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> count <span class="type">int</span>     <span class="comment">// 0</span></span><br><span class="line"><span class="keyword">var</span> text <span class="type">string</span>   <span class="comment">// &quot;&quot;（空字符串）</span></span><br><span class="line"><span class="keyword">var</span> flag <span class="type">bool</span>     <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p><strong>批量声明</strong>: 多个变量可以放一起声明。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 同类型</span></span><br><span class="line"><span class="keyword">var</span> i, j, k <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不同类型，自动推断</span></span><br><span class="line"><span class="keyword">var</span> a, b, c = <span class="number">1</span>, <span class="string">&quot;hello&quot;</span>, <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用括号组织，适合包级别变量</span></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    host = <span class="string">&quot;localhost&quot;</span></span><br><span class="line">    port = <span class="number">5432</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><strong>多变量赋值</strong>: <code>Go</code> 支持一行给多个变量赋值，交换变量值特别方便。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">x, y := <span class="number">10</span>, <span class="number">20</span>    <span class="comment">// 声明并赋值</span></span><br><span class="line">x, y = y, x       <span class="comment">// 交换，不需要临时变量</span></span><br></pre></td></tr></table></figure><p>注意 <code>:=</code> 是声明+赋值，<code>=</code> 是纯赋值。已经声明过的变量再用 <code>:=</code> 会报错。</p><hr><h3 id="4-赋值"><a href="#4-赋值" class="headerlink" title="4. 赋值"></a>4. 赋值</h3><p><code>Go</code> 的赋值操作很直接:</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">x = <span class="number">1</span>              <span class="comment">// 基本赋值</span></span><br><span class="line">*p = <span class="literal">true</span>          <span class="comment">// 指针解引用赋值</span></span><br><span class="line">person.name = <span class="string">&quot;bob&quot;</span> <span class="comment">// 结构体字段赋值</span></span><br></pre></td></tr></table></figure><p><strong>复合赋值</strong>: 简化 <code>x = x + 5</code> 这种写法。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">count[x] *= scale  <span class="comment">// 等价于 count[x] = count[x] * scale</span></span><br><span class="line">x += <span class="number">5</span>             <span class="comment">// 等价于 x = x + 5</span></span><br></pre></td></tr></table></figure><p><strong>自增自减</strong>: 注意 <code>Go</code> 里 <code>v++</code> 是语句不是表达式，不能写 <code>x = i++</code>。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">v := <span class="number">1</span></span><br><span class="line">v++  <span class="comment">// v 变为 2</span></span><br><span class="line">v--  <span class="comment">// v 变为 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// x = i++  // 错误! Go 不允许这样写</span></span><br></pre></td></tr></table></figure><h4 id="元组赋值"><a href="#元组赋值" class="headerlink" title="元组赋值"></a>元组赋值</h4><p>可以一行给多个变量赋值，右边表达式先全部求值，再赋给左边。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 交换变量，不需要临时变量</span></span><br><span class="line">x, y = y, x</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最大公约数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcd</span><span class="params">(x, y <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> y != <span class="number">0</span> &#123;</span><br><span class="line">        x, y = y, x%y</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 斐波那契</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fib</span><span class="params">(n <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    x, y := <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        x, y = y, x+y</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>函数多返回值</strong>: <code>Go</code> 函数可以返回多个值，常见的模式是返回结果和错误。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">f, err := os.Open(<span class="string">&quot;foo.txt&quot;</span>)</span><br></pre></td></tr></table></figure><p><strong><code>ok</code> 模式</strong>: <code>map</code> 查找、类型断言、<code>channel</code> 接收都可以返回第二个 <code>bool</code> 值表示是否成功。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">v, ok := m[key]    <span class="comment">// map 查找</span></span><br><span class="line">v, ok := x.(T)     <span class="comment">// 类型断言</span></span><br><span class="line">v, ok := &lt;-ch      <span class="comment">// channel 接收</span></span><br></pre></td></tr></table></figure><p><strong>丢弃不需要的值</strong>: 用 <code>_</code> 占位。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">_, err := io.Copy(dst, src)  <span class="comment">// 只关心 err，不关心拷贝了多少字节</span></span><br></pre></td></tr></table></figure><h4 id="可赋值性"><a href="#可赋值性" class="headerlink" title="可赋值性"></a>可赋值性</h4><p>赋值分显式和隐式两种:</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 显式赋值</span></span><br><span class="line">x = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 隐式赋值 - 函数调用时参数传递</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(a, b <span class="type">int</span>)</span></span> &#123;&#125;  <span class="comment">// 调用时实参赋给 a, b</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 隐式赋值 - 字面量初始化</span></span><br><span class="line">medals := []<span class="type">string</span>&#123;<span class="string">&quot;gold&quot;</span>, <span class="string">&quot;silver&quot;</span>, <span class="string">&quot;bronze&quot;</span>&#125;</span><br></pre></td></tr></table></figure><p>赋值规则: 类型必须匹配。<code>nil</code> 可以赋给指针、<code>slice</code>、<code>map</code>、<code>channel</code>、<code>interface</code> 等引用类型。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p *<span class="type">int</span> = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">var</span> m <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span> = <span class="literal">nil</span></span><br></pre></td></tr></table></figure><hr><h3 id="5-函数基础"><a href="#5-函数基础" class="headerlink" title="5. 函数基础"></a>5. 函数基础</h3><p>用 <code>func</code> 关键字声明函数。函数名首字母小写是包内私有，大写是公开可导出。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sayHello</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Hello&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><p>参数格式是 <code>变量名 类型</code>，多个参数用逗号分隔。<code>Go</code> 不支持默认参数。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">greet</span><span class="params">(name <span class="type">string</span>, age <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%s is %d years old\n&quot;</span>, name, age)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 相同类型可以简写</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>不定参数</strong>: 用 <code>...</code> 表示，必须放在最后。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(nums ...<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    total := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        total += v</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> total</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sum()           <span class="comment">// 0 个参数</span></span><br><span class="line">sum(<span class="number">1</span>)          <span class="comment">// 1 个参数</span></span><br><span class="line">sum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)    <span class="comment">// 3 个参数</span></span><br></pre></td></tr></table></figure><h4 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h4><p>单个返回值不用括号，多个要括号。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 单个返回值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">double</span><span class="params">(x <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x * <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多个返回值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap</span><span class="params">(x, y <span class="type">string</span>)</span></span> (<span class="type">string</span>, <span class="type">string</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> y, x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 命名返回值，可以直接 return</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">split</span><span class="params">(sum <span class="type">int</span>)</span></span> (x, y <span class="type">int</span>) &#123;</span><br><span class="line">    x = sum * <span class="number">4</span> / <span class="number">9</span></span><br><span class="line">    y = sum - x</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>丢弃不需要的返回值</strong>: 用 <code>_</code> 占位。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">max, _ := MaxAndMin(<span class="number">10</span>, <span class="number">20</span>)  <span class="comment">// 只要 max，不要 min</span></span><br></pre></td></tr></table></figure><h4 id="函数调用流程"><a href="#函数调用流程" class="headerlink" title="函数调用流程"></a>函数调用流程</h4><p>函数调用是栈结构，后进先出 (LIFO)。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">funcc</span><span class="params">(c <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;c =&quot;</span>, c)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">funcb</span><span class="params">(b <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    funcc(b - <span class="number">1</span>)</span><br><span class="line">    fmt.Println(<span class="string">&quot;b =&quot;</span>, b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">funca</span><span class="params">(a <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    funcb(a - <span class="number">1</span>)</span><br><span class="line">    fmt.Println(<span class="string">&quot;a =&quot;</span>, a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    funca(<span class="number">3</span>)</span><br><span class="line">    fmt.Println(<span class="string">&quot;main&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行流程:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">main() → funca(3) → funcb(2) → funcc(1)</span><br><span class="line">                                打印 &quot;c = 1&quot;</span><br><span class="line">                    打印 &quot;b = 2&quot;</span><br><span class="line">         打印 &quot;a = 3&quot;</span><br><span class="line">打印 &quot;main&quot;</span><br></pre></td></tr></table></figure><p>输出: <code>c = 1</code> → <code>b = 2</code> → <code>a = 3</code> → <code>main</code></p><h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><p>函数调用自身，必须有退出条件。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 累加: 1 + 2 + ... + n</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(n <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n + sum(n<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sum(<span class="number">100</span>)  <span class="comment">// 5050</span></span><br></pre></td></tr></table></figure><p>执行流程:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sum(100) = 100 + sum(99)</span><br><span class="line">         = 100 + 99 + sum(98)</span><br><span class="line">         = ...</span><br><span class="line">         = 100 + 99 + ... + 1</span><br><span class="line">         = 5050</span><br></pre></td></tr></table></figure><hr><h3 id="6-函数进阶"><a href="#6-函数进阶" class="headerlink" title="6. 函数进阶"></a>6. 函数进阶</h3><h4 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h4><p>函数在 <code>Go</code> 里是一等公民，可以赋值给变量、作为参数传递。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Add</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Minus</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a - b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义函数类型</span></span><br><span class="line"><span class="keyword">type</span> CalcFunc <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span> <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> f CalcFunc</span><br><span class="line">    </span><br><span class="line">    f = Add</span><br><span class="line">    fmt.Println(f(<span class="number">10</span>, <span class="number">5</span>))  <span class="comment">// 15</span></span><br><span class="line">    </span><br><span class="line">    f = Minus</span><br><span class="line">    fmt.Println(f(<span class="number">10</span>, <span class="number">5</span>))  <span class="comment">// 5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>函数作为参数 (回调函数)</strong>: 实现多态，同一个函数传入不同的函数参数，实现不同功能。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> CalcFunc <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span> <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Calc</span><span class="params">(a, b <span class="type">int</span>, f CalcFunc)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> f(a, b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Calc(<span class="number">3</span>, <span class="number">3</span>, Add)    <span class="comment">// 6，加法</span></span><br><span class="line">    Calc(<span class="number">3</span>, <span class="number">3</span>, Minus)  <span class="comment">// 0，减法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h4><p>没有名字的函数，可以赋值给变量，也可以定义后立即调用。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 赋值给变量</span></span><br><span class="line">f := <span class="function"><span class="keyword">func</span><span class="params">(x, y <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line">f(<span class="number">1</span>, <span class="number">2</span>)  <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义并立即调用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(x, y <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    fmt.Println(x + y)</span><br><span class="line">&#125;(<span class="number">1</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure><h4 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h4><p>闭包是引用了外部变量的匿名函数。关键点: 变量以引用方式捕获，会保留状态。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 普通函数: 每次调用 a 都重新初始化</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test01</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> a <span class="type">int</span>  <span class="comment">// 每次都是 0</span></span><br><span class="line">    a++</span><br><span class="line">    <span class="keyword">return</span> a * a</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用 5 次输出: 1 1 1 1 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 闭包: a 只初始化一次，状态保留</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test02</span><span class="params">()</span></span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> a <span class="type">int</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">        a++</span><br><span class="line">        <span class="keyword">return</span> a * a</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    f := test02()</span><br><span class="line">    fmt.Println(f())  <span class="comment">// 1</span></span><br><span class="line">    fmt.Println(f())  <span class="comment">// 4</span></span><br><span class="line">    fmt.Println(f())  <span class="comment">// 9</span></span><br><span class="line">    fmt.Println(f())  <span class="comment">// 16</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h4><p><code>defer</code> 延迟执行，函数返回前才执行。常用于资源清理: 关闭文件、释放连接等。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> fmt.Println(<span class="string">&quot;最后执行&quot;</span>)</span><br><span class="line">    fmt.Println(<span class="string">&quot;先执行&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出:</span></span><br><span class="line"><span class="comment">// 先执行</span></span><br><span class="line"><span class="comment">// 最后执行</span></span><br></pre></td></tr></table></figure><p><strong>典型用法</strong>:</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">readFile</span><span class="params">()</span></span> &#123;</span><br><span class="line">    f, err := os.Open(<span class="string">&quot;file.txt&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> f.Close()  <span class="comment">// 确保文件关闭</span></span><br><span class="line">    <span class="comment">// 处理文件...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>多个 <code>defer</code></strong>: 后进先出 (LIFO)，先定义的后执行。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> fmt.Println(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">    <span class="keyword">defer</span> fmt.Println(<span class="string">&quot;2&quot;</span>)</span><br><span class="line">    <span class="keyword">defer</span> fmt.Println(<span class="string">&quot;3&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出: 3 2 1</span></span><br></pre></td></tr></table></figure><p><strong><code>defer</code> 与闭包</strong>: 注意捕获变量的时机。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := <span class="number">10</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 无参数: 捕获变量，使用最终值</span></span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Println(a)  <span class="comment">// 100</span></span><br><span class="line">    &#125;()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 有参数: 定义时传值，使用当时的值</span></span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">(x <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">        fmt.Println(x)  <span class="comment">// 10</span></span><br><span class="line">    &#125;(a)</span><br><span class="line">    </span><br><span class="line">    a = <span class="number">100</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出:</span></span><br><span class="line"><span class="comment">// 10</span></span><br><span class="line"><span class="comment">// 100</span></span><br></pre></td></tr></table></figure><p>总结: 想要 <code>defer</code> 时的值，就传参数; 想要最终值，就用闭包捕获。</p><hr><h3 id="7-指针"><a href="#7-指针" class="headerlink" title="7. 指针"></a>7. 指针</h3><p>指针存的是内存地址。<code>&amp;</code> 取地址，<code>*</code> 取值。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="type">int</span> = <span class="number">10</span></span><br><span class="line"></span><br><span class="line">fmt.Println(a)   <span class="comment">// 10，变量的值</span></span><br><span class="line">fmt.Println(&amp;a)  <span class="comment">// 0xc0000..，变量的地址</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p *<span class="type">int</span> = &amp;a  <span class="comment">// p 是指针，存的是 a 的地址</span></span><br><span class="line">fmt.Println(p)   <span class="comment">// 0xc0000..，和 &amp;a 一样</span></span><br><span class="line">fmt.Println(*p)  <span class="comment">// 10，指针指向的值</span></span><br><span class="line"></span><br><span class="line">*p = <span class="number">20</span>          <span class="comment">// 通过指针修改值</span></span><br><span class="line">fmt.Println(a)   <span class="comment">// 20，a 被改了</span></span><br></pre></td></tr></table></figure><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><p><strong>不要操作未初始化的指针</strong>: 指针默认值是 <code>nil</code>，解引用会崩。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p *<span class="type">int</span>       <span class="comment">// nil</span></span><br><span class="line"><span class="comment">// *p = 666      // panic!</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a <span class="type">int</span></span><br><span class="line">p = &amp;a           <span class="comment">// 先指向一个变量</span></span><br><span class="line">*p = <span class="number">666</span>         <span class="comment">// OK</span></span><br></pre></td></tr></table></figure><p><strong>不能取常量或字面量的地址</strong>:</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> i = <span class="number">5</span></span><br><span class="line"><span class="comment">// &amp;i   // 错误</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// &amp;10  // 错误</span></span><br></pre></td></tr></table></figure><p><strong>不支持指针运算</strong>: 和 <code>C</code> 不一样，<code>Go</code> 不能 <code>p++</code> 或 <code>p + 2</code>。</p><h4 id="值传递-vs-指针传递"><a href="#值传递-vs-指针传递" class="headerlink" title="值传递 vs 指针传递"></a>值传递 vs 指针传递</h4><p>值传递复制一份，改不了原变量; 指针传递传地址，能改原变量。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 值传递: 交换失败</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swapByValue</span><span class="params">(a, b <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    a, b = b, a  <span class="comment">// 只改了副本</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指针传递: 交换成功</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swapByPointer</span><span class="params">(a, b *<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    *a, *b = *b, *a</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x, y := <span class="number">10</span>, <span class="number">20</span></span><br><span class="line">    </span><br><span class="line">    swapByValue(x, y)</span><br><span class="line">    fmt.Println(x, y)  <span class="comment">// 10 20，没变</span></span><br><span class="line">    </span><br><span class="line">    swapByPointer(&amp;x, &amp;y)</span><br><span class="line">    fmt.Println(x, y)  <span class="comment">// 20 10，交换了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="8-数组"><a href="#8-数组" class="headerlink" title="8. 数组"></a>8. 数组</h3><p>数组是固定长度、同一类型的数据集合。长度必须是常量，定义后不能改。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr [<span class="number">5</span>]<span class="type">int</span>              <span class="comment">// 5 个 int，默认都是 0</span></span><br><span class="line">fmt.Println(arr)            <span class="comment">// [0 0 0 0 0]</span></span><br><span class="line">fmt.Println(<span class="built_in">len</span>(arr))       <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line">arr[<span class="number">0</span>] = <span class="number">10</span>                 <span class="comment">// 下标从 0 开始</span></span><br><span class="line">fmt.Println(arr[<span class="number">0</span>])         <span class="comment">// 10</span></span><br></pre></td></tr></table></figure><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 全部初始化</span></span><br><span class="line">a := [<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 部分初始化，剩下的是零值</span></span><br><span class="line">b := [<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;        <span class="comment">// [1 2 3 0 0]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定下标初始化</span></span><br><span class="line">c := [<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">2</span>: <span class="number">10</span>, <span class="number">4</span>: <span class="number">20</span>&#125;   <span class="comment">// [0 0 10 0 20]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 让编译器数长度</span></span><br><span class="line">d := [...]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;      <span class="comment">// 长度是 3</span></span><br></pre></td></tr></table></figure><h4 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">arr := [<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// for 循环</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(arr); i++ &#123;</span><br><span class="line">    fmt.Println(arr[i])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// range，更简洁</span></span><br><span class="line"><span class="keyword">for</span> i, v := <span class="keyword">range</span> arr &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;arr[%d] = %d\n&quot;</span>, i, v)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只要值，不要下标</span></span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> arr &#123;</span><br><span class="line">    fmt.Println(v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="9-切片"><a href="#9-切片" class="headerlink" title="9. 切片"></a>9. 切片</h3><p>数组长度固定，切片长度可变。切片是引用类型。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数组: 长度固定，类型是 [5]int</span></span><br><span class="line"><span class="keyword">var</span> arr [<span class="number">5</span>]<span class="type">int</span> = [<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 切片: 长度可变，类型是 []int</span></span><br><span class="line"><span class="keyword">var</span> s []<span class="type">int</span> = []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br></pre></td></tr></table></figure><h4 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 直接初始化</span></span><br><span class="line">s := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// make(类型, 长度, 容量)</span></span><br><span class="line">s1 := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">5</span>, <span class="number">10</span>)  <span class="comment">// 长度 5，容量 10</span></span><br><span class="line">s2 := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">5</span>)      <span class="comment">// 长度和容量都是 5</span></span><br></pre></td></tr></table></figure><p><code>len()</code> 是当前元素个数，<code>cap()</code> 是底层数组能容纳的最大个数。</p><h4 id="切片截取"><a href="#切片截取" class="headerlink" title="切片截取"></a>切片截取</h4><p>切片可以从数组或另一个切片截取，语法是 <code>s[low:high]</code>，包含 <code>low</code> 不包含 <code>high</code>。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s := []<span class="type">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;</span><br><span class="line"></span><br><span class="line">s[<span class="number">2</span>]      <span class="comment">// 2，单个元素</span></span><br><span class="line">s[:]      <span class="comment">// [0 1 2 3 4 5 6 7 8 9]，全部</span></span><br><span class="line">s[<span class="number">3</span>:]     <span class="comment">// [3 4 5 6 7 8 9]，从下标 3 到末尾</span></span><br><span class="line">s[:<span class="number">5</span>]     <span class="comment">// [0 1 2 3 4]，从开头到下标 4</span></span><br><span class="line">s[<span class="number">2</span>:<span class="number">7</span>]    <span class="comment">// [2 3 4 5 6]，下标 2 到 6</span></span><br></pre></td></tr></table></figure><p>还可以用第三个参数限制容量: <code>s[low:high:max]</code>，容量是 <code>max - low</code>。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s[<span class="number">2</span>:<span class="number">5</span>:<span class="number">8</span>]  <span class="comment">// [2 3 4]，长度 3，容量 6</span></span><br></pre></td></tr></table></figure><hr><h3 id="10-Map"><a href="#10-Map" class="headerlink" title="10. Map"></a>10. Map</h3><p><code>map</code> 是键值对的集合，无序。<code>key</code> 必须是可比较的类型 (支持 <code>==</code>)。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明</span></span><br><span class="line"><span class="keyword">var</span> m1 <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>          <span class="comment">// nil map，不能直接用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// make 创建</span></span><br><span class="line">m2 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)     <span class="comment">// 空 map，可以用</span></span><br><span class="line">m3 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>, <span class="number">10</span>) <span class="comment">// 指定初始容量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接初始化</span></span><br><span class="line">m4 := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;</span><br><span class="line">    <span class="string">&quot;alice&quot;</span>: <span class="number">18</span>,</span><br><span class="line">    <span class="string">&quot;bob&quot;</span>:   <span class="number">20</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="增删改查"><a href="#增删改查" class="headerlink" title="增删改查"></a>增删改查</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">m := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;<span class="string">&quot;alice&quot;</span>: <span class="number">18</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加/修改</span></span><br><span class="line">m[<span class="string">&quot;bob&quot;</span>] = <span class="number">20</span>     <span class="comment">// 添加</span></span><br><span class="line">m[<span class="string">&quot;alice&quot;</span>] = <span class="number">19</span>   <span class="comment">// 修改</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询</span></span><br><span class="line">age := m[<span class="string">&quot;alice&quot;</span>]           <span class="comment">// 19</span></span><br><span class="line">age, ok := m[<span class="string">&quot;charlie&quot;</span>]     <span class="comment">// 0, false (不存在)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断 key 是否存在</span></span><br><span class="line"><span class="keyword">if</span> val, ok := m[<span class="string">&quot;bob&quot;</span>]; ok &#123;</span><br><span class="line">    fmt.Println(val)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除</span></span><br><span class="line"><span class="built_in">delete</span>(m, <span class="string">&quot;alice&quot;</span>)</span><br></pre></td></tr></table></figure><h4 id="遍历-1"><a href="#遍历-1" class="headerlink" title="遍历"></a>遍历</h4><p><code>map</code> 遍历顺序是随机的。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">m := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;<span class="string">&quot;a&quot;</span>: <span class="number">1</span>, <span class="string">&quot;b&quot;</span>: <span class="number">2</span>, <span class="string">&quot;c&quot;</span>: <span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> m &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%s: %d\n&quot;</span>, k, v)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只要 key</span></span><br><span class="line"><span class="keyword">for</span> k := <span class="keyword">range</span> m &#123;</span><br><span class="line">    fmt.Println(k)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h4><p><code>map</code> 是引用类型，传参时不会复制，函数内修改会影响原 <code>map</code>。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addKey</span><span class="params">(m <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    m[<span class="string">&quot;new&quot;</span>] = <span class="number">100</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    m := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;<span class="string">&quot;a&quot;</span>: <span class="number">1</span>&#125;</span><br><span class="line">    addKey(m)</span><br><span class="line">    fmt.Println(m)  <span class="comment">// map[a:1 new:100]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="11-结构体"><a href="#11-结构体" class="headerlink" title="11. 结构体"></a>11. 结构体</h3><p>结构体是不同类型数据的集合。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">    ID   <span class="type">int</span></span><br><span class="line">    Name <span class="type">string</span></span><br><span class="line">    Age  <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="初始化-2"><a href="#初始化-2" class="headerlink" title="初始化"></a>初始化</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 顺序初始化，必须全部字段</span></span><br><span class="line">s1 := Student&#123;<span class="number">1</span>, <span class="string">&quot;mike&quot;</span>, <span class="number">18</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定字段，未指定的是零值</span></span><br><span class="line">s2 := Student&#123;Name: <span class="string">&quot;bob&quot;</span>, Age: <span class="number">20</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 先声明后赋值</span></span><br><span class="line"><span class="keyword">var</span> s3 Student</span><br><span class="line">s3.ID = <span class="number">1</span></span><br><span class="line">s3.Name = <span class="string">&quot;alice&quot;</span></span><br></pre></td></tr></table></figure><h4 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 取地址</span></span><br><span class="line">p1 := &amp;Student&#123;<span class="number">1</span>, <span class="string">&quot;mike&quot;</span>, <span class="number">18</span>&#125;</span><br><span class="line">p2 := &amp;Student&#123;Name: <span class="string">&quot;bob&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// new 创建</span></span><br><span class="line">p3 := <span class="built_in">new</span>(Student)</span><br><span class="line">p3.ID = <span class="number">1</span></span><br><span class="line">p3.Name = <span class="string">&quot;alice&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 指针访问成员，p.Name 和 (*p).Name 等价</span></span><br><span class="line">fmt.Println(p1.Name)</span><br></pre></td></tr></table></figure><h4 id="比较和赋值"><a href="#比较和赋值" class="headerlink" title="比较和赋值"></a>比较和赋值</h4><p>同类型结构体可以用 <code>==</code> 比较，也可以直接赋值。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s1 := Student&#123;<span class="number">1</span>, <span class="string">&quot;mike&quot;</span>, <span class="number">18</span>&#125;</span><br><span class="line">s2 := Student&#123;<span class="number">1</span>, <span class="string">&quot;mike&quot;</span>, <span class="number">18</span>&#125;</span><br><span class="line">s3 := Student&#123;<span class="number">2</span>, <span class="string">&quot;bob&quot;</span>, <span class="number">20</span>&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(s1 == s2)  <span class="comment">// true</span></span><br><span class="line">fmt.Println(s1 == s3)  <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">s4 := s1  <span class="comment">// 复制一份</span></span><br></pre></td></tr></table></figure><h4 id="值传递-vs-指针传递-1"><a href="#值传递-vs-指针传递-1" class="headerlink" title="值传递 vs 指针传递"></a>值传递 vs 指针传递</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 值传递: 改不了原变量</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">updateByValue</span><span class="params">(s Student)</span></span> &#123;</span><br><span class="line">    s.Age = <span class="number">100</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指针传递: 能改原变量</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">updateByPointer</span><span class="params">(s *Student)</span></span> &#123;</span><br><span class="line">    s.Age = <span class="number">100</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s := Student&#123;<span class="number">1</span>, <span class="string">&quot;mike&quot;</span>, <span class="number">18</span>&#125;</span><br><span class="line">    </span><br><span class="line">    updateByValue(s)</span><br><span class="line">    fmt.Println(s.Age)  <span class="comment">// 18，没变</span></span><br><span class="line">    </span><br><span class="line">    updateByPointer(&amp;s)</span><br><span class="line">    fmt.Println(s.Age)  <span class="comment">// 100，改了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h4><p>首字母大写是公开的 (<code>public</code>)，小写是私有的 (<code>private</code>，仅包内可见)。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">    ID   <span class="type">int</span>     <span class="comment">// 公开</span></span><br><span class="line">    Name <span class="type">string</span>  <span class="comment">// 公开</span></span><br><span class="line">    age  <span class="type">int</span>     <span class="comment">// 私有，其他包访问不了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="12-匿名组合"><a href="#12-匿名组合" class="headerlink" title="12. 匿名组合"></a>12. 匿名组合</h3><p><code>Go</code> 没有传统的继承，但可以通过匿名字段实现类似效果。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="type">string</span></span><br><span class="line">    Age  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">    Person       <span class="comment">// 匿名字段，继承 Person 的所有字段</span></span><br><span class="line">    ID   <span class="type">int</span></span><br><span class="line">    Addr <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="初始化-3"><a href="#初始化-3" class="headerlink" title="初始化"></a>初始化</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 顺序初始化</span></span><br><span class="line">s1 := Student&#123;Person&#123;<span class="string">&quot;mike&quot;</span>, <span class="number">18</span>&#125;, <span class="number">1</span>, <span class="string">&quot;beijing&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定字段</span></span><br><span class="line">s2 := Student&#123;</span><br><span class="line">    Person: Person&#123;Name: <span class="string">&quot;bob&quot;</span>&#125;,</span><br><span class="line">    ID:     <span class="number">2</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="访问成员"><a href="#访问成员" class="headerlink" title="访问成员"></a>访问成员</h4><p>匿名字段的成员可以直接访问，不用写完整路径。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s := Student&#123;Person&#123;<span class="string">&quot;mike&quot;</span>, <span class="number">18</span>&#125;, <span class="number">1</span>, <span class="string">&quot;beijing&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接访问</span></span><br><span class="line">fmt.Println(s.Name)  <span class="comment">// mike</span></span><br><span class="line">fmt.Println(s.Age)   <span class="comment">// 18</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以写完整路径</span></span><br><span class="line">fmt.Println(s.Person.Name)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改</span></span><br><span class="line">s.Name = <span class="string">&quot;bob&quot;</span></span><br><span class="line">s.Person = Person&#123;<span class="string">&quot;alice&quot;</span>, <span class="number">20</span>&#125;</span><br></pre></td></tr></table></figure><h4 id="同名字段"><a href="#同名字段" class="headerlink" title="同名字段"></a>同名字段</h4><p>如果外层和匿名字段有同名成员，就近原则。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">    Person</span><br><span class="line">    Name <span class="type">string</span>  <span class="comment">// 和 Person.Name 重名</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> s Student</span><br><span class="line">    s.Name = <span class="string">&quot;student&quot;</span>        <span class="comment">// Student.Name</span></span><br><span class="line">    s.Person.Name = <span class="string">&quot;person&quot;</span>  <span class="comment">// Person.Name</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="指针类型匿名字段"><a href="#指针类型匿名字段" class="headerlink" title="指针类型匿名字段"></a>指针类型匿名字段</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">    *Person  <span class="comment">// 指针类型</span></span><br><span class="line">    ID <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s1 := Student&#123;&amp;Person&#123;<span class="string">&quot;mike&quot;</span>, <span class="number">18</span>&#125;, <span class="number">1</span>&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 或者用 new</span></span><br><span class="line">    <span class="keyword">var</span> s2 Student</span><br><span class="line">    s2.Person = <span class="built_in">new</span>(Person)</span><br><span class="line">    s2.Name = <span class="string">&quot;bob&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="13-方法"><a href="#13-方法" class="headerlink" title="13. 方法"></a>13. 方法</h3><p>方法是带接收者的函数，语法: <code>func (receiver Type) methodName(params) returns</code></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="type">string</span></span><br><span class="line">    Age  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 值接收者</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span></span> PrintInfo() &#123;</span><br><span class="line">    fmt.Println(p.Name, p.Age)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指针接收者</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Person)</span></span> SetAge(age <span class="type">int</span>) &#123;</span><br><span class="line">    p.Age = age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    p := Person&#123;<span class="string">&quot;mike&quot;</span>, <span class="number">18</span>&#125;</span><br><span class="line">    p.PrintInfo()   <span class="comment">// mike 18</span></span><br><span class="line">    p.SetAge(<span class="number">20</span>)</span><br><span class="line">    fmt.Println(p.Age)  <span class="comment">// 20</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="值接收者-vs-指针接收者"><a href="#值接收者-vs-指针接收者" class="headerlink" title="值接收者 vs 指针接收者"></a>值接收者 vs 指针接收者</h4><p>值接收者是拷贝，改不了原变量; 指针接收者是引用，能改原变量。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span></span> SetByValue(name <span class="type">string</span>) &#123;</span><br><span class="line">    p.Name = name  <span class="comment">// 改的是副本</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Person)</span></span> SetByPointer(name <span class="type">string</span>) &#123;</span><br><span class="line">    p.Name = name  <span class="comment">// 改的是原变量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    p := Person&#123;<span class="string">&quot;mike&quot;</span>, <span class="number">18</span>&#125;</span><br><span class="line">    </span><br><span class="line">    p.SetByValue(<span class="string">&quot;bob&quot;</span>)</span><br><span class="line">    fmt.Println(p.Name)  <span class="comment">// mike，没变</span></span><br><span class="line">    </span><br><span class="line">    p.SetByPointer(<span class="string">&quot;bob&quot;</span>)</span><br><span class="line">    fmt.Println(p.Name)  <span class="comment">// bob，变了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方法继承"><a href="#方法继承" class="headerlink" title="方法继承"></a>方法继承</h4><p>匿名字段的方法会被继承。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span></span> Say() &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;I&#x27;m&quot;</span>, p.Name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">    Person</span><br><span class="line">    ID <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s := Student&#123;Person&#123;<span class="string">&quot;mike&quot;</span>&#125;, <span class="number">1</span>&#125;</span><br><span class="line">    s.Say()  <span class="comment">// I&#x27;m mike</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方法重写"><a href="#方法重写" class="headerlink" title="方法重写"></a>方法重写</h4><p>子类型可以定义同名方法覆盖父类型，就近原则。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Student)</span></span> Say() &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Student:&quot;</span>, s.Name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s := Student&#123;Person&#123;<span class="string">&quot;mike&quot;</span>&#125;, <span class="number">1</span>&#125;</span><br><span class="line">    s.Say()         <span class="comment">// Student: mike</span></span><br><span class="line">    s.Person.Say()  <span class="comment">// I&#x27;m mike，显式调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="14-接口"><a href="#14-接口" class="headerlink" title="14. 接口"></a>14. 接口</h3><p>接口是方法签名的集合，定义行为不定义实现。实现了接口所有方法的类型就实现了该接口，不需要显式声明。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Humaner <span class="keyword">interface</span> &#123;</span><br><span class="line">    SayHi()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="实现接口"><a href="#实现接口" class="headerlink" title="实现接口"></a>实现接口</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Student)</span></span> SayHi() &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Student:&quot;</span>, s.Name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Teacher <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Teacher)</span></span> SayHi() &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Teacher:&quot;</span>, t.Name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> h Humaner</span><br><span class="line">    </span><br><span class="line">    h = &amp;Student&#123;<span class="string">&quot;mike&quot;</span>&#125;</span><br><span class="line">    h.SayHi()  <span class="comment">// Student: mike</span></span><br><span class="line">    </span><br><span class="line">    h = &amp;Teacher&#123;<span class="string">&quot;bob&quot;</span>&#125;</span><br><span class="line">    h.SayHi()  <span class="comment">// Teacher: bob</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h4><p>同一个接口，不同类型有不同表现。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WhoSayHi</span><span class="params">(h Humaner)</span></span> &#123;</span><br><span class="line">    h.SayHi()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s := &amp;Student&#123;<span class="string">&quot;mike&quot;</span>&#125;</span><br><span class="line">    t := &amp;Teacher&#123;<span class="string">&quot;bob&quot;</span>&#125;</span><br><span class="line">    </span><br><span class="line">    WhoSayHi(s)  <span class="comment">// Student: mike</span></span><br><span class="line">    WhoSayHi(t)  <span class="comment">// Teacher: bob</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 切片存不同类型</span></span><br><span class="line">    people := []Humaner&#123;s, t&#125;</span><br><span class="line">    <span class="keyword">for</span> _, p := <span class="keyword">range</span> people &#123;</span><br><span class="line">        p.SayHi()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="接口继承"><a href="#接口继承" class="headerlink" title="接口继承"></a>接口继承</h4><p>接口可以嵌入其他接口。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Humaner <span class="keyword">interface</span> &#123;</span><br><span class="line">    SayHi()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Personer <span class="keyword">interface</span> &#123;</span><br><span class="line">    Humaner           <span class="comment">// 继承 Humaner</span></span><br><span class="line">    Sing(lrc <span class="type">string</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现 <code>Personer</code> 必须同时实现 <code>SayHi()</code> 和 <code>Sing()</code>。</p><h4 id="空接口"><a href="#空接口" class="headerlink" title="空接口"></a>空接口</h4><p><code>interface&#123;&#125;</code> 可以存任意类型。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> i <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">i = <span class="number">1</span></span><br><span class="line">i = <span class="string">&quot;hello&quot;</span></span><br><span class="line">i = &amp;Student&#123;<span class="string">&quot;mike&quot;</span>&#125;</span><br></pre></td></tr></table></figure><h4 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h4><p>从空接口取出具体类型。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> i <span class="keyword">interface</span>&#123;&#125; = <span class="string">&quot;hello&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// if 判断</span></span><br><span class="line"><span class="keyword">if</span> s, ok := i.(<span class="type">string</span>); ok &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;是 string:&quot;</span>, s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// switch 判断</span></span><br><span class="line"><span class="keyword">switch</span> v := i.(<span class="keyword">type</span>) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="type">int</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;int:&quot;</span>, v)</span><br><span class="line"><span class="keyword">case</span> <span class="type">string</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;string:&quot;</span>, v)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;其他类型&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="15-Error-接口"><a href="#15-Error-接口" class="headerlink" title="15. Error 接口"></a>15. Error 接口</h3><p><code>error</code> 是 <code>Go</code> 内建的接口，用于错误处理。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="type">error</span> <span class="keyword">interface</span> &#123;</span><br><span class="line">    Error() <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="创建-error"><a href="#创建-error" class="headerlink" title="创建 error"></a>创建 error</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;errors&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// errors.New</span></span><br><span class="line">err1 := errors.New(<span class="string">&quot;something went wrong&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// fmt.Errorf，支持格式化</span></span><br><span class="line">err2 := fmt.Errorf(<span class="string">&quot;user %d not found&quot;</span>, <span class="number">123</span>)</span><br></pre></td></tr></table></figure><h4 id="错误处理模式"><a href="#错误处理模式" class="headerlink" title="错误处理模式"></a>错误处理模式</h4><p><code>Go</code> 的惯例是函数返回值最后一个是 <code>error</code>，调用后检查是否为 <code>nil</code>。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Divide</span><span class="params">(a, b <span class="type">int</span>)</span></span> (<span class="type">int</span>, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> b == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>, errors.New(<span class="string">&quot;division by zero&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a / b, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    result, err := Divide(<span class="number">10</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;错误:&quot;</span>, err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;结果:&quot;</span>, result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>标准模式:</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">result, err := someFunction()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="comment">// 处理错误</span></span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 继续用 result</span></span><br></pre></td></tr></table></figure><hr><h3 id="16-Panic"><a href="#16-Panic" class="headerlink" title="16. Panic"></a>16. Panic</h3><p><code>panic</code> 是严重错误，触发后程序崩溃。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;开始&quot;</span>)</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;出错了&quot;</span>)</span><br><span class="line">    fmt.Println(<span class="string">&quot;不会执行&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出:</span></span><br><span class="line"><span class="comment">// 开始</span></span><br><span class="line"><span class="comment">// panic: 出错了</span></span><br></pre></td></tr></table></figure><h4 id="触发方式"><a href="#触发方式" class="headerlink" title="触发方式"></a>触发方式</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 手动触发</span></span><br><span class="line"><span class="built_in">panic</span>(<span class="string">&quot;something went wrong&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行时错误自动触发</span></span><br><span class="line"><span class="keyword">var</span> a [<span class="number">10</span>]<span class="type">int</span></span><br><span class="line">a[<span class="number">20</span>] = <span class="number">1</span>  <span class="comment">// 数组越界 -&gt; panic</span></span><br></pre></td></tr></table></figure><h4 id="panic-与-defer"><a href="#panic-与-defer" class="headerlink" title="panic 与 defer"></a>panic 与 defer</h4><p><code>panic</code> 之前注册的 <code>defer</code> 会执行，常用于清理资源。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> fmt.Println(<span class="string">&quot;清理工作&quot;</span>)</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;出错&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出:</span></span><br><span class="line"><span class="comment">// 清理工作</span></span><br><span class="line"><span class="comment">// panic: 出错</span></span><br></pre></td></tr></table></figure><hr><h3 id="17-Recover"><a href="#17-Recover" class="headerlink" title="17. Recover"></a>17. Recover</h3><p><code>recover</code> 捕获 <code>panic</code>，防止程序崩溃。必须在 <code>defer</code> 中使用。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> err := <span class="built_in">recover</span>(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">&quot;捕获到:&quot;</span>, err)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;出错了&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    test()</span><br><span class="line">    fmt.Println(<span class="string">&quot;程序继续运行&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出:</span></span><br><span class="line"><span class="comment">// 捕获到: 出错了</span></span><br><span class="line"><span class="comment">// 程序继续运行</span></span><br></pre></td></tr></table></figure><p>不用 <code>recover</code>，<code>panic</code> 会让整个程序崩溃; 用了 <code>recover</code>，程序可以继续执行。</p><hr><h3 id="18-Goroutine"><a href="#18-Goroutine" class="headerlink" title="18. Goroutine"></a>18. Goroutine</h3><p><code>go</code> 关键字创建协程，非常轻量，可以轻松创建成千上万个。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">task</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;任务执行&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> task()  <span class="comment">// 创建协程，异步执行</span></span><br><span class="line">    time.Sleep(time.Second)  <span class="comment">// 等一下，否则 main 退出子协程也没了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主协程退出，所有子协程也会退出。</p><h4 id="WaitGroup"><a href="#WaitGroup" class="headerlink" title="WaitGroup"></a>WaitGroup</h4><p>用 <code>sync.WaitGroup</code> 等待所有协程完成。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">task</span><span class="params">(id <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> wg.Done()</span><br><span class="line">    fmt.Println(<span class="string">&quot;任务&quot;</span>, id)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">go</span> task(i)</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Wait()  <span class="comment">// 等待全部完成</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">runtime.Gosched()       <span class="comment">// 让出 CPU，让其他协程先跑</span></span><br><span class="line">runtime.Goexit()        <span class="comment">// 退出当前协程</span></span><br><span class="line">runtime.GOMAXPROCS(n)   <span class="comment">// 设置使用的 CPU 核数</span></span><br></pre></td></tr></table></figure><hr><h3 id="19-Channel"><a href="#19-Channel" class="headerlink" title="19. Channel"></a>19. Channel</h3><p><code>channel</code> 用于 <code>goroutine</code> 之间通信，类似管道，一端发一端收，并发安全。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)      <span class="comment">// 无缓冲</span></span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">10</span>)  <span class="comment">// 有缓冲，容量 10</span></span><br><span class="line"></span><br><span class="line">ch &lt;- <span class="number">10</span>    <span class="comment">// 发送</span></span><br><span class="line">x := &lt;-ch   <span class="comment">// 接收</span></span><br></pre></td></tr></table></figure><h4 id="无缓冲-channel"><a href="#无缓冲-channel" class="headerlink" title="无缓冲 channel"></a>无缓冲 channel</h4><p>发送方会阻塞，直到有接收方准备好。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch &lt;- <span class="number">10</span>  <span class="comment">// 阻塞，直到有人接收</span></span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">x := &lt;-ch  <span class="comment">// 接收</span></span><br></pre></td></tr></table></figure><h4 id="有缓冲-channel"><a href="#有缓冲-channel" class="headerlink" title="有缓冲 channel"></a>有缓冲 channel</h4><p>缓冲区没满就不阻塞，满了才阻塞。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">ch &lt;- <span class="number">1</span>  <span class="comment">// 不阻塞</span></span><br><span class="line">ch &lt;- <span class="number">2</span>  <span class="comment">// 不阻塞</span></span><br><span class="line">ch &lt;- <span class="number">3</span>  <span class="comment">// 不阻塞</span></span><br><span class="line">ch &lt;- <span class="number">4</span>  <span class="comment">// 阻塞，满了</span></span><br><span class="line"></span><br><span class="line">&lt;-ch     <span class="comment">// 取走一个，腾出位置</span></span><br></pre></td></tr></table></figure><h4 id="关闭和遍历"><a href="#关闭和遍历" class="headerlink" title="关闭和遍历"></a>关闭和遍历</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">        ch &lt;- i</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(ch)  <span class="comment">// 发完了，关闭</span></span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> v := <span class="keyword">range</span> ch &#123;  <span class="comment">// 自动遍历直到关闭</span></span><br><span class="line">    fmt.Println(v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关闭后不能再发送，但可以继续接收剩余数据。</p><h4 id="单向-channel"><a href="#单向-channel" class="headerlink" title="单向 channel"></a>单向 channel</h4><p>限制只能发或只能收，用于函数参数约束。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">send</span><span class="params">(ch <span class="keyword">chan</span>&lt;- <span class="type">int</span>)</span></span> &#123;  <span class="comment">// 只能发</span></span><br><span class="line">    ch &lt;- <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">receive</span><span class="params">(ch &lt;-<span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;  <span class="comment">// 只能收</span></span><br><span class="line">    x := &lt;-ch</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Timer: 一次性</span></span><br><span class="line">timer := time.NewTimer(<span class="number">2</span> * time.Second)</span><br><span class="line">&lt;-timer.C</span><br><span class="line">fmt.Println(<span class="string">&quot;时间到&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Ticker: 周期性</span></span><br><span class="line">ticker := time.NewTicker(time.Second)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">    &lt;-ticker.C</span><br><span class="line">    fmt.Println(<span class="string">&quot;tick&quot;</span>, i)</span><br><span class="line">&#125;</span><br><span class="line">ticker.Stop()</span><br></pre></td></tr></table></figure><hr><h3 id="20-Select"><a href="#20-Select" class="headerlink" title="20. Select"></a>20. Select</h3><p><code>select</code> 同时监听多个 <code>channel</code>，哪个准备好就执行哪个。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> x := &lt;-ch1:</span><br><span class="line">    fmt.Println(<span class="string">&quot;从 ch1 收到&quot;</span>, x)</span><br><span class="line"><span class="keyword">case</span> ch2 &lt;- y:</span><br><span class="line">    fmt.Println(<span class="string">&quot;发送到 ch2&quot;</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;都没准备好&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ch1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">ch2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    time.Sleep(time.Second)</span><br><span class="line">    ch1 &lt;- <span class="number">1</span></span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">    ch2 &lt;- <span class="number">2</span></span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> x := &lt;-ch1:</span><br><span class="line">    fmt.Println(<span class="string">&quot;ch1:&quot;</span>, x)  <span class="comment">// 先到，执行这个</span></span><br><span class="line"><span class="keyword">case</span> x := &lt;-ch2:</span><br><span class="line">    fmt.Println(<span class="string">&quot;ch2:&quot;</span>, x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="超时处理"><a href="#超时处理" class="headerlink" title="超时处理"></a>超时处理</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> x := &lt;-ch:</span><br><span class="line">    fmt.Println(<span class="string">&quot;收到:&quot;</span>, x)</span><br><span class="line"><span class="keyword">case</span> &lt;-time.After(<span class="number">3</span> * time.Second):</span><br><span class="line">    fmt.Println(<span class="string">&quot;超时&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="斐波那契示例"><a href="#斐波那契示例" class="headerlink" title="斐波那契示例"></a>斐波那契示例</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fibonacci</span><span class="params">(ch <span class="keyword">chan</span>&lt;- <span class="type">int</span>, quit &lt;-<span class="keyword">chan</span> <span class="type">bool</span>)</span></span> &#123;</span><br><span class="line">    x, y := <span class="number">1</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> ch &lt;- x:</span><br><span class="line">            x, y = y, x+y</span><br><span class="line">        <span class="keyword">case</span> &lt;-quit:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">    quit := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">8</span>; i++ &#123;</span><br><span class="line">            fmt.Println(&lt;-ch)</span><br><span class="line">        &#125;</span><br><span class="line">        quit &lt;- <span class="literal">true</span></span><br><span class="line">    &#125;()</span><br><span class="line">    </span><br><span class="line">    fibonacci(ch, quit)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h4><ul><li>多个 <code>case</code> 同时准备好时随机选一个</li><li><code>default</code> 在所有 <code>case</code> 阻塞时执行</li><li>常用于超时控制和多路复用</li></ul><hr><h3 id="21-锁-sync"><a href="#21-锁-sync" class="headerlink" title="21. 锁 (sync)"></a>21. 锁 (sync)</h3><p>多个 <code>goroutine</code> 同时访问共享资源会有竞态问题，需要锁来保证安全。</p><h4 id="互斥锁-sync-Mutex"><a href="#互斥锁-sync-Mutex" class="headerlink" title="互斥锁 sync.Mutex"></a>互斥锁 sync.Mutex</h4><p>同一时刻只有一个 <code>goroutine</code> 能访问。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"><span class="keyword">var</span> lock sync.Mutex</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> wg.Done()</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++ &#123;</span><br><span class="line">        lock.Lock()</span><br><span class="line">        x = x + <span class="number">1</span></span><br><span class="line">        lock.Unlock()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    wg.Add(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">go</span> add()</span><br><span class="line">    <span class="keyword">go</span> add()</span><br><span class="line">    wg.Wait()</span><br><span class="line">    fmt.Println(x)  <span class="comment">// 10000</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="读写锁-sync-RWMutex"><a href="#读写锁-sync-RWMutex" class="headerlink" title="读写锁 sync.RWMutex"></a>读写锁 sync.RWMutex</h4><p>读多写少的场景用这个。多个读可以同时进行，写独占。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> rwlock sync.RWMutex</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">write</span><span class="params">()</span></span> &#123;</span><br><span class="line">    rwlock.Lock()      <span class="comment">// 写锁</span></span><br><span class="line">    x = x + <span class="number">1</span></span><br><span class="line">    rwlock.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">read</span><span class="params">()</span></span> &#123;</span><br><span class="line">    rwlock.RLock()     <span class="comment">// 读锁</span></span><br><span class="line">    fmt.Println(x)</span><br><span class="line">    rwlock.RUnlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="sync-Once"><a href="#sync-Once" class="headerlink" title="sync.Once"></a>sync.Once</h4><p>确保某操作只执行一次，常用于单例初始化。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> once sync.Once</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    once.Do(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;只执行一次&quot;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="sync-Map"><a href="#sync-Map" class="headerlink" title="sync.Map"></a>sync.Map</h4><p>并发安全的 <code>map</code>，不需要额外加锁。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> m sync.Map</span><br><span class="line"></span><br><span class="line">m.Store(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;value&quot;</span>)        <span class="comment">// 存</span></span><br><span class="line">value, ok := m.Load(<span class="string">&quot;key&quot;</span>)     <span class="comment">// 取</span></span><br><span class="line">m.Delete(<span class="string">&quot;key&quot;</span>)                <span class="comment">// 删</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS 原型链</title>
      <link href="/posts/13fe9182.html"/>
      <url>/posts/13fe9182.html</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p>参考文章: <a href="https://juejin.cn/post/7007416743215759373">https://juejin.cn/post/7007416743215759373</a></p></blockquote><h3 id="1-显式原型和隐式原型"><a href="#1-显式原型和隐式原型" class="headerlink" title="1. 显式原型和隐式原型"></a>1. 显式原型和隐式原型</h3><ul><li><p><code>prototype</code>: 显式原型</p><ul><li>是构造函数的一个属性, 用于定义实例共享的方法和属性</li><li>它指向原型对象，该对象上的属性和方法会被实例继承</li></ul></li><li><p><code>__proto__</code>: 隐式原型</p><ul><li>是每个对象都有的内部属性</li><li>它指向创建该对象的构造函数的<code>prototype</code>，用于建立原型链</li></ul></li><li><p>构造函数的<code>prototype</code>和其实例的<code>__proto__</code>指向同一个地方，这个地方叫做原型对象</p></li><li><p>原型对象是实现继承的核心</p></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, age</span>) &#123; <span class="comment">// 构造函数</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person1 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;小明&#x27;</span>, <span class="number">20</span>); <span class="comment">// 构造函数的实例</span></span><br><span class="line"><span class="keyword">const</span> person2 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;小红&#x27;</span>, <span class="number">30</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span> === person1.<span class="property">__proto__</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span> === person2.<span class="property">__proto__</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h5 id="什么是构造函数"><a href="#什么是构造函数" class="headerlink" title="什么是构造函数"></a><p style='font-size: 14px'>什么是构造函数</p></h5><ul><li>可构造函数是可以用<code>new</code>操作符调用的函数，用于创建对象</li><li>箭头函数不能作为构造函数</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, age</span>) &#123; <span class="comment">// 这个就是构造函数</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person1 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;小明&#x27;</span>, <span class="number">20</span>) <span class="comment">// 这个是Person构造函数的实例</span></span><br><span class="line"><span class="keyword">const</span> person2 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;小红&#x27;</span>, <span class="number">30</span>) <span class="comment">// 这个也是Person构造函数的实例</span></span><br></pre></td></tr></table></figure><ul><li>构造函数的<code>prototype</code>定义实例可以继承的方法</li><li>实例的<code>__proto__</code>指向构造函数的<code>prototype</code></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123; <span class="comment">// 在原型对象上定义方法</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person1 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;小明&#x27;</span>, <span class="number">20</span>);</span><br><span class="line"><span class="keyword">const</span> person2 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;小红&#x27;</span>, <span class="number">30</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 验证 prototype 和 __proto__</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>); <span class="comment">// &#123; sayName: [Function] &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person1.<span class="property">__proto__</span>); <span class="comment">// &#123; sayName: [Function] &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span> === person1.<span class="property">__proto__</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span> === person2.<span class="property">__proto__</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用原型方法</span></span><br><span class="line">person1.<span class="title function_">sayName</span>(); <span class="comment">// 小明</span></span><br><span class="line">person2.<span class="title function_">sayName</span>(); <span class="comment">// 小红</span></span><br></pre></td></tr></table></figure><hr><h3 id="2-构造函数与对象的关系"><a href="#2-构造函数与对象的关系" class="headerlink" title="2. 构造函数与对象的关系"></a>2. 构造函数与对象的关系</h3><ul><li>构造函数本质上是函数，用来创建对象。定义构造函数有以下几种常见方式</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn1</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`我是<span class="subst">$&#123;name&#125;</span>, 我今年<span class="subst">$&#123;age&#125;</span>岁`</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">fn1</span>(<span class="string">&#x27;abc&#x27;</span>, <span class="number">10</span>); <span class="comment">// 输出：我是abc, 我今年10岁</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数表达式</span></span><br><span class="line"><span class="keyword">const</span> fn2 = <span class="keyword">function</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`我是<span class="subst">$&#123;name&#125;</span>, 我今年<span class="subst">$&#123;age&#125;</span>岁`</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title function_">fn2</span>(<span class="string">&#x27;abc&#x27;</span>, <span class="number">10</span>); <span class="comment">// 输出：我是abc, 我今年10岁</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 箭头函数</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">arrowFn</span> = (<span class="params">name, age</span>) =&gt; &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`我是<span class="subst">$&#123;name&#125;</span>, 我今年<span class="subst">$&#123;age&#125;</span>岁`</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title function_">arrowFn</span>(<span class="string">&#x27;abc&#x27;</span>, <span class="number">10</span>); <span class="comment">// 输出：我是abc, 我今年10岁</span></span><br></pre></td></tr></table></figure><h4 id="构造函数与原型的关系"><a href="#构造函数与原型的关系" class="headerlink" title="构造函数与原型的关系"></a><p style='font-size: 14px'>构造函数与原型的关系</p></h4><ul><li>每个构造函数的<code>prototype</code>和其实例的<code>__proto__</code>都指向同一个原型对象</li><li>同时，所有函数本身都是<code>Function</code>构造函数的实例</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn1</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`我是<span class="subst">$&#123;name&#125;</span>, 我今年<span class="subst">$&#123;age&#125;</span>岁`</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> fn2 = <span class="keyword">function</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`我是<span class="subst">$&#123;name&#125;</span>, 我今年<span class="subst">$&#123;age&#125;</span>岁`</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">arrowFn</span> = (<span class="params">name, age</span>) =&gt; &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`我是<span class="subst">$&#123;name&#125;</span>, 我今年<span class="subst">$&#123;age&#125;</span>岁`</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span> === fn1.<span class="property">__proto__</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span> === fn2.<span class="property">__proto__</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span> === arrowFn.<span class="property">__proto__</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h4 id="创建对象的方式"><a href="#创建对象的方式" class="headerlink" title="创建对象的方式"></a><p style='font-size: 14px'>创建对象的方式</p></h4><p>在开发中，创建对象有以下几种方式 <br></p><ol><li>构造函数创建对象: 使用<code>new</code>调用构造函数创建对象</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> person1 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;abc&#x27;</span>, <span class="number">10</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person1); <span class="comment">// 输出：Person &#123; name: &#x27;abc&#x27;, age: 10 &#125;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>字面量创建对象</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person2 = &#123; <span class="attr">name</span>: <span class="string">&#x27;abc&#x27;</span>, <span class="attr">age</span>: <span class="number">10</span> &#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person2); <span class="comment">// 输出：&#123; name: &#x27;abc&#x27;, age: 10 &#125;</span></span><br></pre></td></tr></table></figure><ol start="3"><li><code>new Object</code>创建对象</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person3 = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">person3.<span class="property">name</span> = <span class="string">&#x27;abc&#x27;</span>;</span><br><span class="line">person3.<span class="property">age</span> = <span class="number">10</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person3); <span class="comment">// 输出：&#123; name: &#x27;abc&#x27;, age: 10 &#125;</span></span><br></pre></td></tr></table></figure><ol start="4"><li><code>Object.create</code>创建对象: 创建一个具有指定原型的空对象</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person4 = <span class="title class_">Object</span>.<span class="title function_">create</span>(&#123;&#125;);</span><br><span class="line">person4.<span class="property">name</span> = <span class="string">&#x27;abc&#x27;</span>;</span><br><span class="line">person4.<span class="property">age</span> = <span class="number">10</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person4); <span class="comment">// 输出：&#123; name: &#x27;abc&#x27;, age: 10 &#125;</span></span><br></pre></td></tr></table></figure><ul><li>字面量和<code>new Object</code>创建的对象本质上都是<code>Object</code>构造函数的实例</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person2 = &#123; <span class="attr">name</span>: <span class="string">&#x27;abc&#x27;</span>, <span class="attr">age</span>: <span class="number">10</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> person3 = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">person3.<span class="property">name</span> = <span class="string">&#x27;abc&#x27;</span>;</span><br><span class="line">person3.<span class="property">age</span> = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span> === person2.<span class="property">__proto__</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span> === person3.<span class="property">__proto__</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h4 id="Function-和-Object"><a href="#Function-和-Object" class="headerlink" title="Function 和 Object"></a><p style='font-size: 14px'><code>Function</code> 和 <code>Object</code></p></h4><ul><li>函数是<code>Function</code>构造函数的实例</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span> === fn.<span class="property">__proto__</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><ul><li>对象是<code>Object</code>构造函数的实例</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span> === obj.<span class="property">__proto__</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><ul><li>特殊关系<ul><li><code>Object</code>是一个函数，因此它是<code>Function</code>的实例</li><li><code>Function</code>本身也是一个函数，因此它是自己的实例</li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span> === <span class="title class_">Object</span>.<span class="property">__proto__</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span> === <span class="title class_">Function</span>.<span class="property">__proto__</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><hr><h3 id="3-原型链的起点与终点"><a href="#3-原型链的起点与终点" class="headerlink" title="3. 原型链的起点与终点"></a>3. 原型链的起点与终点</h3><h4 id="原型的本质"><a href="#原型的本质" class="headerlink" title="原型的本质"></a><p style='font-size: 14px'>原型的本质</p></h4><ul><li><code>Person.prototype</code>是构造函数<code>Person</code>的原型对象</li><li><code>Function.prototype</code>是构造函数<code>Function</code>的原型对象</li><li>所有的原型对象都是对象，因此本质上它们是通过<code>new Object()</code>创建的</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">__proto__</span> === <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line"> <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">__proto__</span> === <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>);</span><br></pre></td></tr></table></figure><ul><li><code>Person.prototype</code>和<code>Function.prototype</code>都是<code>Object</code>构造函数的实例</li><li>因此，它们的<code>__proto__</code>都指向<code>Object.prototype</code></li></ul><h4 id="什么是原型链"><a href="#什么是原型链" class="headerlink" title="什么是原型链"></a><p style='font-size: 14px'>什么是原型链</p></h4><ul><li>原型链是通过<code>__proto__</code>属性连接起来的对象链</li><li>当访问一个对象的属性时，如果该对象没有这个属性，会通过<code>__proto__</code>向上查找，直到<code>null</code>为止</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img0a4b669cc49c4fd39905b0e22113d66e%7Etplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp"></p><h4 id="原型链的终点"><a href="#原型链的终点" class="headerlink" title="原型链的终点"></a><p style='font-size: 14px'>原型链的终点</p></h4><ul><li>原型链的终点是<code>null</code>，这是<code>JavaScript</code>中的对象链的终止点</li><li>任何对象的<code>__proto__</code>最终都会指向<code>Object.prototype</code>，而<code>Object.prototype.__proto__ === null</code></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img61a5a0bce57948988f29fc1bedb75382%7Etplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp"></p><hr><h3 id="4-原型链的实际应用"><a href="#4-原型链的实际应用" class="headerlink" title="4. 原型链的实际应用"></a>4. 原型链的实际应用</h3><h5 id="原型继承的机制"><a href="#原型继承的机制" class="headerlink" title="原型继承的机制"></a><p style='font-size: 14px'>原型继承的机制</p></h5><ul><li>原型继承允许实例对象使用构造函数原型对象上的方法或属性</li><li>实例对象会通过<code>__proto__</code>链接到构造函数的<code>prototype</code>，实现属性和方法的继承</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name</span>) &#123; <span class="comment">// 构造函数</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name; <span class="comment">// 实例属性</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123; <span class="comment">// 定义在原型对象上的方法</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;abc&#x27;</span>); <span class="comment">// 实例化对象</span></span><br><span class="line">person.<span class="title function_">sayName</span>(); <span class="comment">// 输出：abc</span></span><br></pre></td></tr></table></figure><ul><li><code>person</code>实例对象的<code>__proto__</code>指向<code>Person.prototype</code></li><li>调用<code>person.sayName()</code>时，<code>JavaScript</code>引擎会通过<code>__proto__</code>查找到原型对象上的<code>sayName</code>方法</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img6888b0f41bd047938f1f7f287b3e3f34%7Etplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp"></p><h5 id="属性查找规则"><a href="#属性查找规则" class="headerlink" title="属性查找规则"></a><p style='font-size: 14px'>属性查找规则</p></h5><ul><li>优先查找实例对象本身的属性</li><li>如果实例对象中没有该属性，会沿着原型链向上查找，直到<code>null</code></li><li>如果在原型链中也未找到，返回<code>undefined</code></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Animal</span>(<span class="params">type</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">type</span> = type;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Animal</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayType</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">type</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> dog = <span class="keyword">new</span> <span class="title class_">Animal</span>(<span class="string">&#x27;dog&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(dog.<span class="property">type</span>); <span class="comment">// 输出：dog</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(dog.<span class="title function_">hasOwnProperty</span>(<span class="string">&#x27;type&#x27;</span>)); <span class="comment">// true（实例自身属性）</span></span><br><span class="line">dog.<span class="title function_">sayType</span>(); <span class="comment">// 输出：dog</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(dog.<span class="property">__proto__</span>.<span class="title function_">hasOwnProperty</span>(<span class="string">&#x27;sayType&#x27;</span>)); <span class="comment">// true（原型上的方法）</span></span><br></pre></td></tr></table></figure><hr><h3 id="5-原型链核心机制"><a href="#5-原型链核心机制" class="headerlink" title="5. 原型链核心机制"></a>5. 原型链核心机制</h3><h4 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h4><ul><li><strong>原理:</strong> 判断 <code>B.prototype</code> 是否在对象 <code>A</code> 的原型链上。</li><li><code>instanceof</code> 通过检查 <code>A.__proto__</code> 是否等于 <code>B.prototype</code>，如果不等则沿着原型链向上查找，直到找到匹配或到达 <code>null</code>。</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">A <span class="keyword">instanceof</span> B</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;abc&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span> <span class="keyword">instanceof</span> <span class="title class_">Function</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span> <span class="keyword">instanceof</span> <span class="title class_">Object</span>);   <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person <span class="keyword">instanceof</span> <span class="title class_">Person</span>);   <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person <span class="keyword">instanceof</span> <span class="title class_">Object</span>);   <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><strong>结果分析</strong></p><ol><li><p><strong>Person instanceof Function → true</strong><br>Person 是函数，函数是 Function 的实例<br>原型链：Person.<strong>proto</strong> &#x3D;&#x3D;&#x3D; Function.prototype</p></li><li><p><strong>Person instanceof Object → true</strong><br>所有对象（包括函数）最终继承自 Object<br>原型链：Person.<strong>proto</strong>.<strong>proto</strong> &#x3D;&#x3D;&#x3D; Object.prototype</p></li><li><p><strong>person instanceof Person → true</strong><br>person 是 Person 的实例<br>原型链：person.<strong>proto</strong> &#x3D;&#x3D;&#x3D; Person.prototype</p></li><li><p><strong>person instanceof Object → true</strong><br>所有实例对象最终继承自 Object<br>原型链：person.<strong>proto</strong>.<strong>proto</strong> &#x3D;&#x3D;&#x3D; Object.prototype</p></li></ol><p>自定义实现<code>instanceof</code></p><ul><li>以下是<code>instanceof</code>的核心逻辑，用递归实现</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">myInstanceof</span>(<span class="params">A, B</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> proto = A.<span class="property">__proto__</span>;</span><br><span class="line">  <span class="keyword">while</span> (proto) &#123;</span><br><span class="line">    <span class="keyword">if</span> (proto === B.<span class="property"><span class="keyword">prototype</span></span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    proto = proto.<span class="property">__proto__</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">myInstanceof</span>(person, <span class="title class_">Person</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">myInstanceof</span>(person, <span class="title class_">Object</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">myInstanceof</span>(person, <span class="title class_">Function</span>)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><hr><h4 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h4><ul><li><code>constructor</code> 是对象的一个属性，指向创建该对象的构造函数</li><li>原型与构造函数的互指关系<ul><li>构造函数的 <code>prototype</code> 对象有一个 <code>constructor</code> 属性，指向该构造函数本身</li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Fn</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Fn</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> === <span class="title class_">Fn</span>); </span><br></pre></td></tr></table></figure><ul><li>实例访问 <code>constructor</code><ul><li>实例对象通过 <code>__proto__</code> 继承 <code>prototype</code>，因此可以访问 <code>constructor</code></li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> instance = <span class="keyword">new</span> <span class="title class_">Fn</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(instance.<span class="property">constructor</span> === <span class="title class_">Fn</span>); </span><br><span class="line"><span class="comment">// false (继承的属性)</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(instance.<span class="title function_">hasOwnProperty</span>(<span class="string">&#x27;constructor&#x27;</span>));</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Fn.prototype.constructor → Fn</span><br><span class="line">     ↑</span><br><span class="line">instance.__proto__ (继承)</span><br></pre></td></tr></table></figure><hr><h3 id="原型链练习"><a href="#原型链练习" class="headerlink" title="原型链练习"></a>原型链练习</h3><h4 id="原型链练习-1"><a href="#原型链练习-1" class="headerlink" title="原型链练习#1"></a>原型链练习<code>#1</code></h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> F = <span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">a</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">b</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;b&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f = <span class="keyword">new</span> <span class="title function_">F</span>();</span><br><span class="line"></span><br><span class="line">f.<span class="title function_">a</span>(); <span class="comment">// ?</span></span><br><span class="line">f.<span class="title function_">b</span>(); <span class="comment">// ?</span></span><br><span class="line"></span><br><span class="line">F.<span class="title function_">a</span>(); <span class="comment">// ?</span></span><br><span class="line">F.<span class="title function_">b</span>(); <span class="comment">// ?</span></span><br></pre></td></tr></table></figure><p><strong>答案</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">f.<span class="title function_">a</span>(); <span class="comment">// 输出 &#x27;a&#x27;</span></span><br><span class="line">f.<span class="title function_">b</span>(); <span class="comment">// 报错：f.b is not a function</span></span><br><span class="line"></span><br><span class="line">F.<span class="title function_">a</span>(); <span class="comment">// 输出 &#x27;a&#x27;</span></span><br><span class="line">F.<span class="title function_">b</span>(); <span class="comment">// 输出 &#x27;b&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>原型链</strong></p><ul><li>f 的原型链：f.<strong>proto</strong> → F.prototype → Object.prototype → null</li><li>F 的原型链：F.<strong>proto</strong> → Function.prototype → Object.prototype → null</li></ul><p><strong>关键点</strong></p><ul><li>f 是实例对象，只能访问 Object.prototype</li><li>F 是函数对象，既能访问 Function.prototype 也能访问 Object.prototype</li></ul><hr><h4 id="原型链练习-2"><a href="#原型链练习-2" class="headerlink" title="原型链练习 #2"></a>原型链练习 #2</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> A = <span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;;</span><br><span class="line">A.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">n</span> = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> <span class="title function_">A</span>();</span><br><span class="line">A.<span class="property"><span class="keyword">prototype</span></span> = &#123;</span><br><span class="line">  <span class="attr">n</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">m</span>: <span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> c = <span class="keyword">new</span> <span class="title function_">A</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b.<span class="property">n</span>); <span class="comment">// ?</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b.<span class="property">m</span>); <span class="comment">// ?</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(c.<span class="property">n</span>); <span class="comment">// ?</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(c.<span class="property">m</span>); <span class="comment">// ?</span></span><br></pre></td></tr></table></figure><p><strong>答案</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b.<span class="property">n</span>); <span class="comment">// 1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b.<span class="property">m</span>); <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(c.<span class="property">n</span>); <span class="comment">// 2</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(c.<span class="property">m</span>); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p><strong>关键点</strong></p><p>重新赋值 A.prototype 不会影响已创建的实例</p><ul><li>b 创建时：b.<strong>proto</strong> → 旧原型 {n: 1}</li><li>A.prototype 重新赋值：A.prototype → 新原型 {n: 2, m: 3}</li><li>c 创建时：c.<strong>proto</strong> → 新原型 {n: 2, m: 3}</li></ul><p><strong>原型链状态</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">b.__proto__ → &#123;n: 1&#125; (旧原型)</span><br><span class="line">c.__proto__ → &#123;n: 2, m: 3&#125; (新原型)</span><br></pre></td></tr></table></figure><hr><h4 id="原型链练习-3"><a href="#原型链练习-3" class="headerlink" title="原型链练习 #3"></a>原型链练习 #3</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = &#123;&#125;,</span><br><span class="line">    F = <span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;;</span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">a</span> = <span class="string">&#x27;value a&#x27;</span>;</span><br><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">b</span> = <span class="string">&#x27;value b&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(foo.<span class="property">a</span>); <span class="comment">// ?</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(foo.<span class="property">b</span>); <span class="comment">// ?</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(F.<span class="property">a</span>); <span class="comment">// ?</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(F.<span class="property">b</span>); <span class="comment">// ?</span></span><br></pre></td></tr></table></figure><p><strong>答案</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(foo.<span class="property">a</span>); <span class="comment">// &#x27;value a&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(foo.<span class="property">b</span>); <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(F.<span class="property">a</span>); <span class="comment">// &#x27;value a&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(F.<span class="property">b</span>); <span class="comment">// &#x27;value b&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>关键点</strong></p><ul><li>foo 是普通对象，只能访问 Object.prototype</li><li>F 是函数对象，既能访问 Function.prototype 也能访问 Object.prototype</li></ul><p><strong>原型链</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">foo.__proto__ → Object.prototype → null</span><br><span class="line">F.__proto__ → Function.prototype → Object.prototype → null</span><br></pre></td></tr></table></figure><hr><h4 id="原型链练习-4"><a href="#原型链练习-4" class="headerlink" title="原型链练习#4"></a>原型链练习<code>#4</code></h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">A</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">B</span>(<span class="params">a</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">a</span> = a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">C</span>(<span class="params">a</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (a) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">a</span> = a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">A.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">a</span> = <span class="number">1</span>;</span><br><span class="line">B.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">a</span> = <span class="number">1</span>;</span><br><span class="line">C.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">a</span> = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title function_">A</span>().<span class="property">a</span>); <span class="comment">// ?</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title function_">B</span>().<span class="property">a</span>); <span class="comment">// ?</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title function_">C</span>(<span class="number">2</span>).<span class="property">a</span>); <span class="comment">// ?</span></span><br></pre></td></tr></table></figure><p><strong>答案</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title function_">A</span>().<span class="property">a</span>); <span class="comment">// 1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title function_">B</span>().<span class="property">a</span>); <span class="comment">// undefined</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title function_">C</span>(<span class="number">2</span>).<span class="property">a</span>); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p><strong>关键点</strong></p><p>实例自身的属性优先于原型链上的属性</p><ul><li>new A().a → 构造函数未设置 a，从原型链获取 → 1</li><li>new B().a → 构造函数设置了 this.a &#x3D; undefined，实例自身有 a 属性 → undefined</li><li>new C(2).a → 构造函数设置了 this.a &#x3D; 2，实例自身有 a 属性 → 2</li></ul><hr><h4 id="原型链练习-5"><a href="#原型链练习-5" class="headerlink" title="原型链练习 #5"></a>原型链练习 #5</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">123</span>[<span class="string">&#x27;toString&#x27;</span>].<span class="property">length</span> + <span class="number">123</span>); <span class="comment">// ?</span></span><br></pre></td></tr></table></figure><p><strong>答案</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">123</span>[<span class="string">&#x27;toString&#x27;</span>].<span class="property">length</span> + <span class="number">123</span>); <span class="comment">// 124</span></span><br></pre></td></tr></table></figure><p><strong>关键点</strong></p><ul><li>数字 123 包装为 Number 对象</li><li>沿原型链找到 Number.prototype.toString</li><li>toString.length 为 1（表示接受 1 个可选参数 radix）</li><li>1 + 123 &#x3D; 124</li></ul><blockquote><p>参考：<a href="https://juejin.cn/post/7003369591967596552">https://juejin.cn/post/7003369591967596552</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PostgreSQL 学习笔记</title>
      <link href="/posts/29dadae9.html"/>
      <url>/posts/29dadae9.html</url>
      
        <content type="html"><![CDATA[<h2 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h2><h3 id="1-简单查询-SELECT"><a href="#1-简单查询-SELECT" class="headerlink" title="1. 简单查询 SELECT"></a>1. 简单查询 SELECT</h3><ul><li><code>SELECT</code>是读取与组合数据的核心，按顺序写子句，按需省略未用部分。</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> [<span class="keyword">DISTINCT</span>] expr_list</span><br><span class="line"><span class="keyword">FROM</span> table_or_subquery t</span><br><span class="line">  [<span class="keyword">JOIN</span> other <span class="keyword">ON</span> <span class="keyword">condition</span>]</span><br><span class="line">[<span class="keyword">WHERE</span> row_predicate]</span><br><span class="line">[<span class="keyword">GROUP</span> <span class="keyword">BY</span> grouping_exprs]</span><br><span class="line">[<span class="keyword">HAVING</span> group_predicate]</span><br><span class="line">[<span class="keyword">UNION</span> <span class="operator">|</span> <span class="keyword">INTERSECT</span> <span class="operator">|</span> <span class="keyword">EXCEPT</span> <span class="keyword">SELECT</span> ...]</span><br><span class="line">[<span class="keyword">ORDER</span> <span class="keyword">BY</span> sort_exprs]</span><br><span class="line">[LIMIT n [<span class="keyword">OFFSET</span> m] <span class="operator">|</span> <span class="keyword">FETCH</span> <span class="keyword">FIRST</span> n <span class="keyword">ROWS</span> <span class="keyword">ONLY</span>]</span><br></pre></td></tr></table></figure><ul><li><p>子句作用速记</p><ul><li><code>DISTINCT</code>: 结果去重。</li><li><code>JOIN</code>: 组合多表行。</li><li><code>WHERE</code>: 分组前行级过滤。</li><li><code>GROUP BY</code>: 按键聚合。未分组列必须聚合。</li><li><code>HAVING</code>: 对聚合结果再过滤。</li><li>集合运算: <code>UNION</code>&#x2F;<code>INTERSECT</code>&#x2F;<code>EXCEPT</code>整集合操作。</li><li>排序 &amp; 限制: <code>ORDER BY</code> + <code>LIMIT/OFFSET</code> 或 <code>FETCH</code> 分页。</li><li>聚合函数: <code>COUNT/SUM/AVG/MAX/MIN</code> 在分组或全表上聚合。</li></ul></li><li><p>常见顺序影响</p><ul><li>执行逻辑（简化）: FROM → JOIN → WHERE → GROUP BY → HAVING → SELECT → UNION 等 → ORDER BY → LIMIT。</li><li>早过滤（WHERE）减少后续分组与排序成本。</li><li>只在需要展示顺序时才加 <code>ORDER BY</code>。分页必须与确定顺序绑定。</li></ul></li></ul><hr><h3 id="2-列别名"><a href="#2-列别名" class="headerlink" title="2. 列别名"></a>2. 列别名</h3><p>列别名用于给输出列临时命名（不改表结构），提升可读性与复用。</p><ul><li>适用: 原始列、表达式、函数、聚合、<code>CASE</code></li><li>引用: 可<code>ORDER BY</code>、外层查询中使用别名，不能在同一层<code>WHERE</code>里引用它</li><li>省略<code>AS</code>等价：<code>col alias</code></li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 基本用法</span></span><br><span class="line"><span class="keyword">SELECT</span> column_name <span class="keyword">AS</span> alias_name <span class="keyword">FROM</span> table_name;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 表达式别名</span></span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">  price <span class="operator">*</span> quantity <span class="keyword">AS</span> total,</span><br><span class="line">  <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> cnt</span><br><span class="line"><span class="keyword">FROM</span> orders</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> total <span class="keyword">DESC</span>;  <span class="comment">-- ORDER BY 可用别名</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- CASE 别名</span></span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">  <span class="keyword">CASE</span></span><br><span class="line">    <span class="keyword">WHEN</span> status <span class="operator">=</span> <span class="string">&#x27;paid&#x27;</span> <span class="keyword">THEN</span> <span class="string">&#x27;P&#x27;</span></span><br><span class="line">    <span class="keyword">ELSE</span> <span class="string">&#x27;U&#x27;</span></span><br><span class="line">  <span class="keyword">END</span> <span class="keyword">AS</span> pay_flag</span><br><span class="line"><span class="keyword">FROM</span> invoices;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- WHERE 不能用别名（错误示例）</span></span><br><span class="line"><span class="keyword">SELECT</span> price <span class="operator">*</span> quantity <span class="keyword">AS</span> total</span><br><span class="line"><span class="keyword">FROM</span> orders</span><br><span class="line"><span class="keyword">WHERE</span> total <span class="operator">&gt;</span> <span class="number">100</span>;  <span class="comment">-- ❌ 错误</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 正确做法：重复表达式或用子查询</span></span><br><span class="line"><span class="keyword">WHERE</span> price <span class="operator">*</span> quantity <span class="operator">&gt;</span> <span class="number">100</span>;  <span class="comment">-- ✅</span></span><br></pre></td></tr></table></figure><hr><h3 id="3-排序-ORDER-BY"><a href="#3-排序-ORDER-BY" class="headerlink" title="3. 排序 ORDER BY"></a>3. 排序 ORDER BY</h3><ul><li><code>ORDER BY</code>按指定列或表达式排序。多列时先按第一列排，相同再按第二列排。默认升序<code>ASC</code>，降序用<code>DESC</code>。可排别名、表达式、函数。可控制空值位置：<code>NULLS FIRST</code>&#x2F;<code>NULLS LAST</code>。不推荐用序号排序（如<code>ORDER BY 1</code>）。</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 单列排序</span></span><br><span class="line"><span class="keyword">SELECT</span> id, created_at <span class="keyword">FROM</span> posts</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> created_at <span class="keyword">DESC</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 控制NULL值位置</span></span><br><span class="line"><span class="keyword">SELECT</span> id, name <span class="keyword">FROM</span> users</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> name <span class="keyword">ASC</span> NULLS <span class="keyword">LAST</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 多列排序（先按total降序，相同则按id升序）</span></span><br><span class="line"><span class="keyword">SELECT</span> price <span class="operator">*</span> quantity <span class="keyword">AS</span> total, id</span><br><span class="line"><span class="keyword">FROM</span> orders</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> total <span class="keyword">DESC</span>, id <span class="keyword">ASC</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 表达式排序</span></span><br><span class="line"><span class="keyword">SELECT</span> name, age <span class="keyword">FROM</span> users</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> age <span class="operator">*</span> <span class="number">12</span> <span class="keyword">DESC</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 函数排序</span></span><br><span class="line"><span class="keyword">SELECT</span> email <span class="keyword">FROM</span> users</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="built_in">LOWER</span>(email);</span><br></pre></td></tr></table></figure><hr><h3 id="4-去重查询-DISTINCT"><a href="#4-去重查询-DISTINCT" class="headerlink" title="4. 去重查询 DISTINCT"></a>4. 去重查询 DISTINCT</h3><ul><li><code>SELECT DISTINCT</code>是<code>SQL</code>中的一种用法，用于从查询结果中去除重复的记录，仅返回唯一的结果行。它适用于希望从数据库表中获取不重复的值或组合的场景。</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查询所有不重复的城市</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> city <span class="keyword">FROM</span> customers;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询不重复的城市和州的组合</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> city, state <span class="keyword">FROM</span> customers;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 统计有多少个不同的城市</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> city) <span class="keyword">FROM</span> customers;</span><br></pre></td></tr></table></figure><ul><li><strong>性能考虑</strong>: <code>SELECT DISTINCT</code>需要对结果进行去重处理，这在大数据集上可能会影响查询性能。使用时应注意查询效率，特别是在处理大表时。</li><li><strong>多列去重</strong>: 当使用多列时，<code>DISTINCT</code>是对所有列的组合进行去重，而不是单独对每一列去重。</li></ul><hr><h3 id="5-分页查询"><a href="#5-分页查询" class="headerlink" title="5. 分页查询"></a>5. 分页查询</h3><ul><li>分页查询是数据库查询的一种技术，用于将查询结果分割成更小的部分（页），以方便数据的显示和管理，特别是在结果集非常大的情况下。分页能够提高应用的性能和用户体验，因为它可以减少一次性加载的数据量，并提供更快的响应时间。</li></ul><h4 id="OFFSET-x2F-LIMIT-分页"><a href="#OFFSET-x2F-LIMIT-分页" class="headerlink" title="OFFSET&#x2F;LIMIT 分页"></a>OFFSET&#x2F;LIMIT 分页</h4><ul><li>最常见的分页方式，适合小数据集。</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 基本语法</span></span><br><span class="line"><span class="keyword">SELECT</span> column1, column2, ...</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> column_name</span><br><span class="line">LIMIT page_size <span class="keyword">OFFSET</span> (page_number <span class="operator">-</span> <span class="number">1</span>) <span class="operator">*</span> page_size;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 示例：每页10条记录 (page_size = 10)</span></span><br><span class="line"><span class="comment">-- 第一页 (page_number = 1)</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees <span class="keyword">ORDER</span> <span class="keyword">BY</span> id LIMIT <span class="number">10</span> <span class="keyword">OFFSET</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 第二页 (page_number = 2)</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees <span class="keyword">ORDER</span> <span class="keyword">BY</span> id LIMIT <span class="number">10</span> <span class="keyword">OFFSET</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 第三页 (page_number = 3)</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees <span class="keyword">ORDER</span> <span class="keyword">BY</span> id LIMIT <span class="number">10</span> <span class="keyword">OFFSET</span> <span class="number">20</span>;</span><br></pre></td></tr></table></figure><ul><li><strong>计算公式</strong>: <code>OFFSET = (page_number - 1) * page_size</code></li><li><strong>优点</strong>: 实现简单，可以跳转到任意页  </li><li><strong>缺点</strong>: OFFSET很大时性能差，数据库需要扫描所有跳过的记录 (一个简单的比喻就是你每次翻书都要从第一页翻到你之前看到的页数)</li></ul><h4 id="基于ID的分页"><a href="#基于ID的分页" class="headerlink" title="基于ID的分页"></a>基于ID的分页</h4><ul><li>基于上一页最后一条记录的ID继续查询，性能好。（得从 batch 中拿到下一次开始的 id）</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 第一页</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees </span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> id </span><br><span class="line">LIMIT <span class="number">10</span>;</span><br><span class="line"><span class="comment">-- 应用层记录 last_id = 最后一条记录的id</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 第二页（使用上一页的 last_id）</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees </span><br><span class="line"><span class="keyword">WHERE</span> id <span class="operator">&gt;</span> last_id </span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> id </span><br><span class="line">LIMIT <span class="number">10</span>;</span><br><span class="line"><span class="comment">-- 应用层更新 last_id</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 第三页（使用更新后的 last_id）</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees </span><br><span class="line"><span class="keyword">WHERE</span> id <span class="operator">&gt;</span> last_id </span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> id </span><br><span class="line">LIMIT <span class="number">10</span>;</span><br></pre></td></tr></table></figure><ul><li><strong>优点</strong>: 性能稳定，不受数据量影响  </li><li><strong>缺点</strong>: 不能跳转到指定页，只能顺序翻页</li></ul><h4 id="Cursor-游标-分页"><a href="#Cursor-游标-分页" class="headerlink" title="Cursor (游标) 分页"></a>Cursor (游标) 分页</h4><ul><li>数据库提供的游标机制，常用于存储过程中。</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- PostgreSQL 示例</span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">DECLARE</span> my_cursor <span class="keyword">CURSOR</span> <span class="keyword">FOR</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees <span class="keyword">ORDER</span> <span class="keyword">BY</span> id;</span><br><span class="line"><span class="keyword">FETCH</span> <span class="number">10</span> <span class="keyword">FROM</span> my_cursor;  <span class="comment">-- 获取10条</span></span><br><span class="line"><span class="keyword">FETCH</span> <span class="number">10</span> <span class="keyword">FROM</span> my_cursor;  <span class="comment">-- 再获取10条</span></span><br><span class="line"><span class="keyword">CLOSE</span> my_cursor;</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure><ul><li><strong>优点</strong>: 数据库原生支持，可以暂停和恢复  </li><li><strong>缺点</strong>: 需要保持连接，不适合无状态的Web应用</li></ul><p>注意事项</p><ul><li><strong>性能考虑</strong>: OFFSET&#x2F;LIMIT在大数据集上性能较差，推荐使用基于ID的分页。</li><li><strong>ORDER BY的重要性</strong>: 必须使用ORDER BY确保结果顺序一致，否则分页结果可能重复或遗漏。</li><li><strong>选择合适的方案</strong>: <ul><li>需要跳页功能 → OFFSET&#x2F;LIMIT</li><li>无限滚动&#x2F;顺序浏览 → 基于ID的分页</li><li>存储过程&#x2F;批处理 → Cursor游标</li></ul></li></ul><hr><h2 id="过滤数据"><a href="#过滤数据" class="headerlink" title="过滤数据"></a>过滤数据</h2><h3 id="6-WHERE"><a href="#6-WHERE" class="headerlink" title="6. WHERE"></a>6. WHERE</h3><ul><li><code>WHERE</code>子句是<code>SQL</code>中用于指定筛选条件的部分。它用于从数据库表中筛选出符合特定条件的行。<code>WHERE</code>子句可以用在<code>SELECT</code>、<code>UPDATE</code>、<code>DELETE</code>等<code>SQL</code>语句中，限制这些操作只应用于符合条件的行。</li><li>常见运算符<ul><li><strong>比较运算符</strong>: <code>=</code>, <code>&lt;&gt;</code> (不等于), <code>!=</code>, <code>&gt;</code>, <code>&lt;</code>, <code>&gt;=</code>, <code>&lt;=</code></li><li><strong>逻辑运算符</strong>: <code>AND</code>, <code>OR</code>, <code>NOT</code></li><li><strong>范围运算符</strong>: <code>BETWEEN ... AND ...</code></li><li><strong>集合运算符</strong>: <code>IN (value1, value2, ...)</code></li><li><strong>模糊匹配</strong>: <code>LIKE</code></li><li><strong>空值判断</strong>: <code>IS NULL</code>, <code>IS NOT NULL</code></li></ul></li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 比较运算符</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> salary <span class="operator">&gt;</span> <span class="number">50000</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> department <span class="operator">=</span> <span class="string">&#x27;IT&#x27;</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> age <span class="operator">&lt;&gt;</span> <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 逻辑运算符</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> salary <span class="operator">&gt;</span> <span class="number">50000</span> <span class="keyword">AND</span> department <span class="operator">=</span> <span class="string">&#x27;IT&#x27;</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> department <span class="operator">=</span> <span class="string">&#x27;IT&#x27;</span> <span class="keyword">OR</span> department <span class="operator">=</span> <span class="string">&#x27;HR&#x27;</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> <span class="keyword">NOT</span> department <span class="operator">=</span> <span class="string">&#x27;IT&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- BETWEEN</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> salary <span class="keyword">BETWEEN</span> <span class="number">40000</span> <span class="keyword">AND</span> <span class="number">60000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- IN</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> department <span class="keyword">IN</span> (<span class="string">&#x27;IT&#x27;</span>, <span class="string">&#x27;HR&#x27;</span>, <span class="string">&#x27;Finance&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- LIKE (模糊匹配)</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> name <span class="keyword">LIKE</span> <span class="string">&#x27;John%&#x27;</span>;  <span class="comment">-- 以John开头</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> name <span class="keyword">LIKE</span> <span class="string">&#x27;%son&#x27;</span>;   <span class="comment">-- 以son结尾</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> name <span class="keyword">LIKE</span> <span class="string">&#x27;%oh%&#x27;</span>;   <span class="comment">-- 包含oh</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- IS NULL</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> phone <span class="keyword">IS</span> <span class="keyword">NULL</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> phone <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>;</span><br></pre></td></tr></table></figure><ul><li><code>NULL</code>值不能用<code>=</code>或<code>&lt;&gt;</code>比较，必须使用<code>IS NULL</code>或<code>IS NOT NULL</code></li><li><code>LIKE</code>中<code>%</code>表示任意字符，<code>_</code>表示单个字符</li><li>多个条件组合时注意使用括号明确优先级</li></ul><hr><h3 id="7-LIMIT"><a href="#7-LIMIT" class="headerlink" title="7. LIMIT"></a>7. LIMIT</h3><ul><li><code>LIMIT</code>子句是<code>SQL</code>中的一部分，用于限制查询结果中返回的行数。它通常与<code>SELECT</code>语句一起使用，以控制从数据库中提取的行数。<code>LIMIT</code>子句对于分页、性能优化和控制数据输出量非常有用。</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 基本语法</span></span><br><span class="line"><span class="keyword">SELECT</span> column1, column2, ...</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> column_name</span><br><span class="line">LIMIT number_of_rows;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查询前5条记录</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees LIMIT <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询工资最高的前3名员工</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> salary <span class="keyword">DESC</span></span><br><span class="line">LIMIT <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 结合OFFSET实现分页</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> id</span><br><span class="line">LIMIT <span class="number">10</span> <span class="keyword">OFFSET</span> <span class="number">20</span>;  <span class="comment">-- 跳过前20条，返回第21-30条</span></span><br></pre></td></tr></table></figure><ul><li><code>LIMIT</code>通常与<code>ORDER BY</code>一起使用，确保结果顺序一致</li><li>不同数据库语法略有差异：<ul><li>MySQL&#x2F;PostgreSQL: <code>LIMIT n OFFSET m</code></li><li>SQL Server: <code>TOP n</code> 或 <code>OFFSET m ROWS FETCH NEXT n ROWS ONLY</code></li><li>Oracle: <code>ROWNUM</code> 或 <code>FETCH FIRST n ROWS ONLY</code></li></ul></li></ul><hr><h3 id="8-OFFSET-x2F-FETCH"><a href="#8-OFFSET-x2F-FETCH" class="headerlink" title="8. OFFSET&#x2F;FETCH"></a>8. OFFSET&#x2F;FETCH</h3><ul><li><code>FETCH</code>子句是<code>SQL</code>中的一部分，用于从查询结果中返回特定数量的行。它通常与<code>OFFSET</code>子句一起使用，以实现更加灵活和清晰的分页操作。在不同的数据库系统中，<code>FETCH</code>子句的支持和语法可能略有不同。</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 基本语法</span></span><br><span class="line"><span class="keyword">SELECT</span> column1, column2, ...</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> column_name</span><br><span class="line"><span class="keyword">OFFSET</span> number_of_rows <span class="keyword">ROWS</span></span><br><span class="line"><span class="keyword">FETCH</span> &#123;<span class="keyword">FIRST</span> <span class="operator">|</span> NEXT&#125; number_of_rows &#123;<span class="type">ROW</span> <span class="operator">|</span> <span class="keyword">ROWS</span>&#125; <span class="keyword">ONLY</span>;</span><br></pre></td></tr></table></figure><ul><li><code>FIRST</code>: 表示从结果集的开头返回行数</li><li><code>NEXT</code>: 表示从当前偏移量位置继续返回行数</li><li><code>ROW / ROWS</code>: 用于指定返回行的单数或复数形式，两者在功能上没有差别</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 获取前10条记录</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> id</span><br><span class="line"><span class="keyword">FETCH</span> <span class="keyword">FIRST</span> <span class="number">10</span> <span class="keyword">ROWS</span> <span class="keyword">ONLY</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 跳过前20条，获取接下来的10条</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> id</span><br><span class="line"><span class="keyword">OFFSET</span> <span class="number">20</span> <span class="keyword">ROWS</span></span><br><span class="line"><span class="keyword">FETCH</span> NEXT <span class="number">10</span> <span class="keyword">ROWS</span> <span class="keyword">ONLY</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 获取工资最高的前5名员工</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> salary <span class="keyword">DESC</span></span><br><span class="line"><span class="keyword">FETCH</span> <span class="keyword">FIRST</span> <span class="number">5</span> <span class="keyword">ROWS</span> <span class="keyword">ONLY</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 分页示例：第3页，每页10条</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> id</span><br><span class="line"><span class="keyword">OFFSET</span> <span class="number">20</span> <span class="keyword">ROWS</span></span><br><span class="line"><span class="keyword">FETCH</span> NEXT <span class="number">10</span> <span class="keyword">ROWS</span> <span class="keyword">ONLY</span>;</span><br></pre></td></tr></table></figure><ul><li>使用<code>FETCH</code>时必须有<code>ORDER BY</code>子句</li><li><code>OFFSET</code>和<code>FETCH</code>提供了更清晰的语义表达</li><li>不同数据库支持情况：<ul><li>PostgreSQL: 支持<code>FETCH</code>和<code>LIMIT</code></li><li>SQL Server: 仅支持<code>FETCH</code></li><li>MySQL: 仅支持<code>LIMIT</code></li></ul></li></ul><hr><h3 id="9-IN"><a href="#9-IN" class="headerlink" title="9. IN"></a>9. IN</h3><ul><li><code>IN</code>运算符是<code>SQL</code>中用于指定多个可能值的一种条件操作符。它通常用于<code>WHERE</code>子句中，用来过滤那些列值在指定集合中的行。<code>IN</code>运算符允许你简洁地测试某个列的值是否匹配一组值中的任何一个，而无需使用多个<code>OR</code>条件。</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 基本语法</span></span><br><span class="line"><span class="keyword">SELECT</span> column1, column2, ...</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> column_name <span class="keyword">IN</span> (value1, value2, ...);</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查询特定部门的员工</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> department <span class="keyword">IN</span> (<span class="string">&#x27;IT&#x27;</span>, <span class="string">&#x27;HR&#x27;</span>, <span class="string">&#x27;Finance&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 等价于使用多个OR</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> department <span class="operator">=</span> <span class="string">&#x27;IT&#x27;</span> <span class="keyword">OR</span> department <span class="operator">=</span> <span class="string">&#x27;HR&#x27;</span> <span class="keyword">OR</span> department <span class="operator">=</span> <span class="string">&#x27;Finance&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询特定ID的员工</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> id <span class="keyword">IN</span> (<span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- NOT IN: 排除特定部门</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> department <span class="keyword">NOT</span> <span class="keyword">IN</span> (<span class="string">&#x27;HR&#x27;</span>, <span class="string">&#x27;Engineering&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 子查询配合IN</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> department_id <span class="keyword">IN</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> id <span class="keyword">FROM</span> departments <span class="keyword">WHERE</span> location <span class="operator">=</span> <span class="string">&#x27;New York&#x27;</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><ul><li><code>IN</code>比多个<code>OR</code>条件更简洁易读</li><li><code>NOT IN</code>在遇到<code>NULL</code>值时要小心，可能得到意外结果</li><li><code>IN</code>可以配合子查询使用</li><li>列表值过多时可能影响性能，考虑使用<code>JOIN</code>或临时表</li></ul><hr><h3 id="10-BETWEEN"><a href="#10-BETWEEN" class="headerlink" title="10. BETWEEN"></a>10. BETWEEN</h3><ul><li><code>BETWEEN</code>运算符是<code>SQL</code>中用于筛选范围内的值的一种条件操作符。它通常用于<code>WHERE</code>子句中，以测试某个列的值是否在指定的上下限之间。<code>BETWEEN</code>运算符包括指定的边界值（即包含上下限），它可以用于数字、日期、时间等类型的数据。</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 基本语法</span></span><br><span class="line"><span class="keyword">SELECT</span> column1, column2, ...</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> column_name <span class="keyword">BETWEEN</span> value1 <span class="keyword">AND</span> value2;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 数值范围</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> salary <span class="keyword">BETWEEN</span> <span class="number">30000</span> <span class="keyword">AND</span> <span class="number">60000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 等价于</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> salary <span class="operator">&gt;=</span> <span class="number">30000</span> <span class="keyword">AND</span> salary <span class="operator">&lt;=</span> <span class="number">60000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 日期范围</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> orders</span><br><span class="line"><span class="keyword">WHERE</span> order_date <span class="keyword">BETWEEN</span> <span class="string">&#x27;2023-01-01&#x27;</span> <span class="keyword">AND</span> <span class="string">&#x27;2023-12-31&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 字母范围</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> name <span class="keyword">BETWEEN</span> <span class="string">&#x27;A&#x27;</span> <span class="keyword">AND</span> <span class="string">&#x27;M&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- NOT BETWEEN</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> salary <span class="keyword">NOT</span> <span class="keyword">BETWEEN</span> <span class="number">30000</span> <span class="keyword">AND</span> <span class="number">60000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 等价于</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> salary <span class="operator">&lt;</span> <span class="number">30000</span> <span class="keyword">OR</span> salary <span class="operator">&gt;</span> <span class="number">60000</span>;</span><br></pre></td></tr></table></figure><ul><li><code>BETWEEN</code>是<strong>包含边界值</strong>的（闭区间）</li><li><code>BETWEEN value1 AND value2</code>等价于<code>&gt;= value1 AND &lt;= value2</code></li><li><code>value1</code>必须小于或等于<code>value2</code>，否则结果为空</li><li>日期范围查询时注意时间部分，可能需要使用<code>&lt;</code>而不是<code>BETWEEN</code>来避免边界问题</li><li>可以使用<code>NOT BETWEEN</code>排除范围内的值</li></ul><hr><h3 id="11-LIKE"><a href="#11-LIKE" class="headerlink" title="11. LIKE"></a>11. LIKE</h3><ul><li><code>LIKE</code>运算符是<code>SQL</code>中用于进行模式匹配的运算符。它通常用于<code>WHERE</code>子句中，以根据指定的模式筛选出符合条件的行。<code>LIKE</code>运算符可以匹配字符串中的部分内容，因此特别适合用于查找类似的字符串数据。</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 基本语法</span></span><br><span class="line"><span class="keyword">SELECT</span> column1, column2, ...</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> column_name <span class="keyword">LIKE</span> <span class="keyword">pattern</span>;</span><br></pre></td></tr></table></figure><ul><li><strong>百分号 <code>%</code></strong>: 匹配任意数量的字符，包括零个字符</li><li><strong>下划线 <code>_</code></strong>: 匹配单个字符</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查询名字以&quot;A&quot;开头的员工</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> name <span class="keyword">LIKE</span> <span class="string">&#x27;A%&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询名字以&quot;son&quot;结尾的员工</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> name <span class="keyword">LIKE</span> <span class="string">&#x27;%son&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询名字中包含&quot;li&quot;的员工</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> name <span class="keyword">LIKE</span> <span class="string">&#x27;%li%&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询名字第二个字母是&quot;a&quot;的员工</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> name <span class="keyword">LIKE</span> <span class="string">&#x27;_a%&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询名字正好是4个字符的员工</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> name <span class="keyword">LIKE</span> <span class="string">&#x27;____&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- NOT LIKE: 排除匹配</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> name <span class="keyword">NOT</span> <span class="keyword">LIKE</span> <span class="string">&#x27;A%&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 转义特殊字符</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> name <span class="keyword">LIKE</span> <span class="string">&#x27;%\_%&#x27;</span> <span class="keyword">ESCAPE</span> <span class="string">&#x27;\&#x27;</span>;  <span class="comment">-- 查找包含下划线的产品名</span></span><br></pre></td></tr></table></figure><ul><li><code>LIKE</code>是<strong>区分大小写</strong>的（取决于数据库和字符集设置）</li><li>使用<code>%</code>在开头会导致无法使用索引，影响性能</li><li>如果需要匹配<code>%</code>或<code>_</code>字符本身，需要使用转义符</li><li>对于复杂的模式匹配，可以考虑使用正则表达式（如PostgreSQL的<code>~</code>运算符）</li><li><code>ILIKE</code>（PostgreSQL）可以实现不区分大小写的匹配</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- ILIKE: 不区分大小写的匹配（PostgreSQL特有）</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> name ILIKE <span class="string">&#x27;john%&#x27;</span>;  <span class="comment">-- 可以匹配 &#x27;John&#x27;, &#x27;JOHN&#x27;, &#x27;john&#x27;, &#x27;JoHn&#x27; 等</span></span><br></pre></td></tr></table></figure><hr><h3 id="12-NULL-和-IS-NULL"><a href="#12-NULL-和-IS-NULL" class="headerlink" title="12. NULL 和 IS NULL"></a>12. NULL 和 IS NULL</h3><ul><li><p><code>NULL</code>是<code>SQL</code>中用于表示数据的缺失或未知值的特殊标识符。它不同于零、空字符串或任何其他值，因为它表示没有数据或数据不可用。由于<code>NULL</code>代表未知值，因此它在逻辑运算和比较中有特殊的处理方式。</p></li><li><p><strong>没有特定类型</strong>: <code>NULL</code>可以出现在任何数据类型的列中</p></li><li><p><strong>不可比较</strong>: <code>NULL</code>不等于任何值，包括它自己。因此，<code>NULL = NULL</code>的表达式结果为<code>FALSE</code>。正确的做法是使用<code>IS NULL</code>来检查<code>NULL</code>值</p></li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 检查NULL值</span></span><br><span class="line"><span class="keyword">SELECT</span> column1, column2, ...</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> column_name <span class="keyword">IS</span> <span class="keyword">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 检查非NULL值</span></span><br><span class="line"><span class="keyword">SELECT</span> column1, column2, ...</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> column_name <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查询没有电话号码的员工</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> phone <span class="keyword">IS</span> <span class="keyword">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询有电话号码的员工</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> phone <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 错误写法（永远不会返回结果）</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> phone <span class="operator">=</span> <span class="keyword">NULL</span>;  <span class="comment">-- ❌ 错误</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 正确写法</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> phone <span class="keyword">IS</span> <span class="keyword">NULL</span>;  <span class="comment">-- ✅ 正确</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- NULL在计算中的表现</span></span><br><span class="line"><span class="keyword">SELECT</span> salary <span class="operator">+</span> bonus <span class="keyword">FROM</span> employees;  <span class="comment">-- 如果bonus是NULL，结果也是NULL</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 使用COALESCE处理NULL</span></span><br><span class="line"><span class="keyword">SELECT</span> name, <span class="built_in">COALESCE</span>(phone, <span class="string">&#x27;No Phone&#x27;</span>) <span class="keyword">FROM</span> employees;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 使用IFNULL/ISNULL处理NULL（不同数据库语法不同）</span></span><br><span class="line"><span class="keyword">SELECT</span> name, IFNULL(phone, <span class="string">&#x27;No Phone&#x27;</span>) <span class="keyword">FROM</span> employees;  <span class="comment">-- MySQL</span></span><br><span class="line"><span class="keyword">SELECT</span> name, ISNULL(phone, <span class="string">&#x27;No Phone&#x27;</span>) <span class="keyword">FROM</span> employees;  <span class="comment">-- SQL Server</span></span><br></pre></td></tr></table></figure><ul><li><strong>不能使用 <code>=</code> 或 <code>!=</code> 比较NULL</strong>, 必须使用<code>IS NULL</code>或<code>IS NOT NULL</code></li><li><strong>NULL在逻辑运算中</strong><ul><li><code>NULL AND TRUE = NULL</code></li><li><code>NULL OR FALSE = NULL</code></li><li><code>NOT NULL = NULL</code></li></ul></li><li><strong>NULL在聚合函数中</strong>: 大多数聚合函数（如<code>COUNT</code>, <code>SUM</code>, <code>AVG</code>）会忽略<code>NULL</code>值</li><li><strong>NULL在排序中</strong>: <code>ORDER BY</code>时，<code>NULL</code>值通常排在最前面或最后面（取决于数据库）</li></ul><hr><h2 id="连接多个表"><a href="#连接多个表" class="headerlink" title="连接多个表"></a>连接多个表</h2><h3 id="13-表别名"><a href="#13-表别名" class="headerlink" title="13. 表别名"></a>13. 表别名</h3><ul><li>表别名<code>Table Alias</code>是<code>SQL</code>中用于为表指定临时名称的功能。表别名通常用于简化查询语句，特别是在多表联接<code>JOIN</code>或子查询中，使得查询更加简洁和易读。表别名仅在查询的上下文中有效，不会影响数据库中表的实际名称。</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 基本语法</span></span><br><span class="line"><span class="keyword">SELECT</span> column1, column2, ...</span><br><span class="line"><span class="keyword">FROM</span> table_name <span class="keyword">AS</span> alias_name</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">condition</span>;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 使用AS关键字</span></span><br><span class="line"><span class="keyword">SELECT</span> e.name, e.salary</span><br><span class="line"><span class="keyword">FROM</span> employees <span class="keyword">AS</span> e</span><br><span class="line"><span class="keyword">WHERE</span> e.salary <span class="operator">&gt;</span> <span class="number">50000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 省略AS关键字</span></span><br><span class="line"><span class="keyword">SELECT</span> e.name, e.salary</span><br><span class="line"><span class="keyword">FROM</span> employees e</span><br><span class="line"><span class="keyword">WHERE</span> e.salary <span class="operator">&gt;</span> <span class="number">50000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 多表联接中使用别名</span></span><br><span class="line"><span class="keyword">SELECT</span> e.name, d.department_name</span><br><span class="line"><span class="keyword">FROM</span> employees <span class="keyword">AS</span> e</span><br><span class="line"><span class="keyword">JOIN</span> departments <span class="keyword">AS</span> d <span class="keyword">ON</span> e.department_id <span class="operator">=</span> d.id;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 自联接中使用别名（必须使用）</span></span><br><span class="line"><span class="keyword">SELECT</span> e1.name <span class="keyword">AS</span> employee, e2.name <span class="keyword">AS</span> manager</span><br><span class="line"><span class="keyword">FROM</span> employees e1</span><br><span class="line"><span class="keyword">JOIN</span> employees e2 <span class="keyword">ON</span> e1.manager_id <span class="operator">=</span> e2.id;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 子查询中使用别名</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> name, salary <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> salary <span class="operator">&gt;</span> <span class="number">50000</span></span><br><span class="line">) <span class="keyword">AS</span> high_earners;</span><br></pre></td></tr></table></figure><ul><li>表别名在<code>SELECT</code>、<code>WHERE</code>、<code>JOIN</code>等子句中都可以使用</li><li>自联接（同一张表联接自己）时<strong>必须</strong>使用别名</li><li>使用别名可以提高查询可读性，特别是在复杂查询中</li><li>别名只在当前查询中有效，不会改变数据库中的表名</li><li>推荐使用有意义的别名，如<code>e</code>代表<code>employees</code>，<code>d</code>代表<code>departments</code></li></ul><hr><h3 id="14-INNER-JOIN"><a href="#14-INNER-JOIN" class="headerlink" title="14. INNER JOIN"></a>14. INNER JOIN</h3><ul><li><code>INNER JOIN</code>内连接是<code>SQL</code>中的一种联接操作，用于从多个表中查询相关联的数据。<code>INNER JOIN</code>只返回两个表中满足联接条件的行，也就是说，它只返回在两个表中都有匹配关系的记录。如果其中一个表没有匹配的记录，结果中不会包含该行。</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 基本语法</span></span><br><span class="line"><span class="keyword">SELECT</span> column1, column2, ...</span><br><span class="line"><span class="keyword">FROM</span> table1</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> table2</span><br><span class="line"><span class="keyword">ON</span> table1.common_column <span class="operator">=</span> table2.common_column;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- employees</span></span><br><span class="line"><span class="comment">-- | id | name    | department_id |</span></span><br><span class="line"><span class="comment">-- |----|---------|---------------|</span></span><br><span class="line"><span class="comment">-- | 1  | Alice   | 1             |</span></span><br><span class="line"><span class="comment">-- | 2  | Bob     | 2             |</span></span><br><span class="line"><span class="comment">-- | 3  | Charlie | NULL          |</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- departments</span></span><br><span class="line"><span class="comment">-- | id | department_name |</span></span><br><span class="line"><span class="comment">-- |----|-----------------| </span></span><br><span class="line"><span class="comment">-- | 1  | HR              |</span></span><br><span class="line"><span class="comment">-- | 2  | Engineering     |</span></span><br><span class="line"><span class="comment">-- | 3  | Marketing       |</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> e.name, d.department_name</span><br><span class="line"><span class="keyword">FROM</span> employees e</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> departments d <span class="keyword">ON</span> e.department_id <span class="operator">=</span> d.id;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询结果</span></span><br><span class="line"><span class="comment">-- | name  | department_name |</span></span><br><span class="line"><span class="comment">-- |-------|-----------------|</span></span><br><span class="line"><span class="comment">-- | Alice | HR              |</span></span><br><span class="line"><span class="comment">-- | Bob   | Engineering     |</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>注意</strong>: Charlie 没有出现在结果中，因为他的 <code>department_id</code> 是 <code>NULL</code>，在 <code>departments</code> 表中没有匹配的记录。同样，Marketing 部门也没有出现，因为没有员工属于该部门。</p></blockquote><ul><li><code>INNER JOIN</code> 可以简写为 <code>JOIN</code>（效果相同）</li><li>只返回两个表中都有匹配的记录</li><li><code>NULL</code> 值不会被匹配</li><li>使用表别名可以简化查询</li><li>可以连接多个表，使用多个 <code>INNER JOIN</code></li></ul><hr><h3 id="15-LEFT-JOIN"><a href="#15-LEFT-JOIN" class="headerlink" title="15. LEFT JOIN"></a>15. LEFT JOIN</h3><ul><li><code>LEFT JOIN</code>左连接是<code>SQL</code>中的一种联接操作，用于从两个表中查询相关的数据。与<code>INNER JOIN</code>不同，<code>LEFT JOIN</code>会返回左表中的所有记录，即使右表中没有匹配的记录。对于那些在右表中没有匹配的记录，结果集中相应右表的字段会显示为<code>NULL</code>。</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 基本语法</span></span><br><span class="line"><span class="keyword">SELECT</span> column1, column2, ...</span><br><span class="line"><span class="keyword">FROM</span> table1</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> table2</span><br><span class="line"><span class="keyword">ON</span> table1.common_column <span class="operator">=</span> table2.common_column;</span><br></pre></td></tr></table></figure><ul><li><strong>所有左表的行</strong>: 即使左表中的某一行在右表中没有匹配记录，该行也会包含在结果集中</li><li><strong>右表的匹配行</strong>: 如果有匹配的右表记录，这些记录会出现在结果集中</li><li><strong>NULL值</strong>: 对于在右表中没有匹配的左表记录，结果集中右表的列会显示为<code>NULL</code></li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- employees</span></span><br><span class="line"><span class="comment">-- | id | name    | department_id |</span></span><br><span class="line"><span class="comment">-- |----|---------|---------------|</span></span><br><span class="line"><span class="comment">-- | 1  | Alice   | 1             |</span></span><br><span class="line"><span class="comment">-- | 2  | Bob     | 2             |</span></span><br><span class="line"><span class="comment">-- | 3  | Charlie | NULL          |</span></span><br><span class="line"><span class="comment">-- | 4  | David   | 3             |</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- departments</span></span><br><span class="line"><span class="comment">-- | id | department_name |</span></span><br><span class="line"><span class="comment">-- |----|-----------------| </span></span><br><span class="line"><span class="comment">-- | 1  | HR              |</span></span><br><span class="line"><span class="comment">-- | 2  | Engineering     |</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> e.name, d.department_name</span><br><span class="line"><span class="keyword">FROM</span> employees e</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> departments d <span class="keyword">ON</span> e.department_id <span class="operator">=</span> d.id;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询结果</span></span><br><span class="line"><span class="comment">-- | name    | department_name |</span></span><br><span class="line"><span class="comment">-- |---------|-----------------|</span></span><br><span class="line"><span class="comment">-- | Alice   | HR              |</span></span><br><span class="line"><span class="comment">-- | Bob     | Engineering     |</span></span><br><span class="line"><span class="comment">-- | Charlie | NULL            |</span></span><br><span class="line"><span class="comment">-- | David   | NULL            |</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>注意</strong>: 所有员工都出现在结果中。Charlie 的 <code>department_id</code> 是 <code>NULL</code>，David 的 <code>department_id</code> 是 3 但在 <code>departments</code> 表中不存在，所以他们的 <code>department_name</code> 都显示为 <code>NULL</code>。</p></blockquote><ul><li><code>LEFT JOIN</code> 也可以写作 <code>LEFT OUTER JOIN</code>（效果相同）</li><li>返回左表的所有记录，右表没有匹配时显示 <code>NULL</code></li><li>常用于查找”孤立”记录（例如：没有部门的员工）</li><li>可以通过 <code>WHERE right_table.column IS NULL</code> 来筛选只在左表存在的记录</li></ul><hr><h3 id="16-SELF-JOIN"><a href="#16-SELF-JOIN" class="headerlink" title="16. SELF JOIN"></a>16. SELF JOIN</h3><ul><li><p>自连接<code>Self Join</code>是<code>SQL</code>中的一种联接操作，其中一个表与自身进行联接。自连接用于将表中的一行与同一表中的另一行进行比较或关联。这在处理表中行与行之间的关系时非常有用，例如层次结构（如员工与经理的关系）或相邻行之间的比较。</p></li><li><p><strong>同一张表</strong>: 自连接涉及的表实际上是同一张表，只是在查询中使用了不同的别名，使得它们在逻辑上看起来像是两个不同的表</p></li><li><p><strong>表别名</strong>: 为了区分表的不同实例，通常使用表别名。这样可以在同一个查询中引用表中的不同行</p></li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 基本语法</span></span><br><span class="line"><span class="keyword">SELECT</span> a.column1, b.column2, ...</span><br><span class="line"><span class="keyword">FROM</span> table_name a</span><br><span class="line"><span class="keyword">JOIN</span> table_name b</span><br><span class="line"><span class="keyword">ON</span> a.common_column <span class="operator">=</span> b.common_column;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- employees</span></span><br><span class="line"><span class="comment">-- | id | name    | manager_id |</span></span><br><span class="line"><span class="comment">-- |----|---------|------------|</span></span><br><span class="line"><span class="comment">-- | 1  | Alice   | NULL       |</span></span><br><span class="line"><span class="comment">-- | 2  | Bob     | 1          |</span></span><br><span class="line"><span class="comment">-- | 3  | Charlie | 1          |</span></span><br><span class="line"><span class="comment">-- | 4  | David   | 2          |</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> e.name <span class="keyword">AS</span> employee_name, m.name <span class="keyword">AS</span> manager_name</span><br><span class="line"><span class="keyword">FROM</span> employees e</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> employees m <span class="keyword">ON</span> e.manager_id <span class="operator">=</span> m.id;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询结果</span></span><br><span class="line"><span class="comment">-- | employee_name | manager_name |</span></span><br><span class="line"><span class="comment">-- |---------------|--------------|</span></span><br><span class="line"><span class="comment">-- | Alice         | NULL         |</span></span><br><span class="line"><span class="comment">-- | Bob           | Alice        |</span></span><br><span class="line"><span class="comment">-- | Charlie       | Alice        |</span></span><br><span class="line"><span class="comment">-- | David         | Bob          |</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>注意</strong>: Alice 是最高层级的员工，没有经理，所以 <code>manager_name</code> 显示为 <code>NULL</code>。其他员工都能找到对应的经理。</p></blockquote><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查找同一部门的员工对</span></span><br><span class="line"><span class="keyword">SELECT</span> e1.name <span class="keyword">AS</span> employee1, e2.name <span class="keyword">AS</span> employee2</span><br><span class="line"><span class="keyword">FROM</span> employees e1</span><br><span class="line"><span class="keyword">JOIN</span> employees e2 <span class="keyword">ON</span> e1.department_id <span class="operator">=</span> e2.department_id</span><br><span class="line"><span class="keyword">WHERE</span> e1.id <span class="operator">&lt;</span> e2.id;  <span class="comment">-- 避免重复和自己匹配自己</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查找没有下属的员工</span></span><br><span class="line"><span class="keyword">SELECT</span> e.name</span><br><span class="line"><span class="keyword">FROM</span> employees e</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> employees m <span class="keyword">ON</span> e.id <span class="operator">=</span> m.manager_id</span><br><span class="line"><span class="keyword">WHERE</span> m.id <span class="keyword">IS</span> <span class="keyword">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查找工资比某个特定员工高的所有员工</span></span><br><span class="line"><span class="keyword">SELECT</span> e2.name, e2.salary</span><br><span class="line"><span class="keyword">FROM</span> employees e1</span><br><span class="line"><span class="keyword">JOIN</span> employees e2 <span class="keyword">ON</span> e2.salary <span class="operator">&gt;</span> e1.salary</span><br><span class="line"><span class="keyword">WHERE</span> e1.name <span class="operator">=</span> <span class="string">&#x27;Alice&#x27;</span>;</span><br></pre></td></tr></table></figure><ul><li>自连接<strong>必须</strong>使用表别名来区分同一表的不同实例</li><li>通常使用 <code>LEFT JOIN</code> 来包含没有匹配的行（如没有经理的员工）</li><li>注意避免笛卡尔积，确保有正确的 <code>ON</code> 条件</li><li>自连接可能影响性能，大表需要注意优化</li></ul><hr><h3 id="17-FULL-OUTER-JOIN"><a href="#17-FULL-OUTER-JOIN" class="headerlink" title="17. FULL OUTER JOIN"></a>17. FULL OUTER JOIN</h3><ul><li><code>FULL OUTER JOIN</code>全外连接是<code>SQL</code>中的一种联接操作，它返回两个表中所有符合联接条件的记录，以及不符合联接条件的记录。与<code>INNER JOIN</code>只返回两个表中有匹配记录的行不同</li><li><code>FULL OUTER JOIN</code>会返回两个表中的所有记录，如果在某一表中没有匹配的记录，则该表的列会返回<code>NULL</code></li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 基本语法</span></span><br><span class="line"><span class="keyword">SELECT</span> column1, column2, ...</span><br><span class="line"><span class="keyword">FROM</span> table1</span><br><span class="line"><span class="keyword">FULL</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> table2</span><br><span class="line"><span class="keyword">ON</span> table1.common_column <span class="operator">=</span> table2.common_column;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- employees</span></span><br><span class="line"><span class="comment">-- | id | name    | department_id |</span></span><br><span class="line"><span class="comment">-- |----|---------|---------------|</span></span><br><span class="line"><span class="comment">-- | 1  | Alice   | 1             |</span></span><br><span class="line"><span class="comment">-- | 2  | Bob     | 2             |</span></span><br><span class="line"><span class="comment">-- | 3  | Charlie | NULL          |</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- departments</span></span><br><span class="line"><span class="comment">-- | id | department_name |</span></span><br><span class="line"><span class="comment">-- |----|-----------------| </span></span><br><span class="line"><span class="comment">-- | 1  | HR              |</span></span><br><span class="line"><span class="comment">-- | 2  | Engineering     |</span></span><br><span class="line"><span class="comment">-- | 3  | Marketing       |</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> e.name, d.department_name</span><br><span class="line"><span class="keyword">FROM</span> employees e</span><br><span class="line"><span class="keyword">FULL</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> departments d <span class="keyword">ON</span> e.department_id <span class="operator">=</span> d.id;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询结果</span></span><br><span class="line"><span class="comment">-- | name    | department_name |</span></span><br><span class="line"><span class="comment">-- |---------|-----------------|</span></span><br><span class="line"><span class="comment">-- | Alice   | HR              |</span></span><br><span class="line"><span class="comment">-- | Bob     | Engineering     |</span></span><br><span class="line"><span class="comment">-- | Charlie | NULL            |</span></span><br><span class="line"><span class="comment">-- | NULL    | Marketing       |</span></span><br></pre></td></tr></table></figure><blockquote><p>Charlie 出现在结果中，但 <code>department_name</code> 为 <code>NULL</code>，因为他没有分配部门<br>Marketing 部门也出现在结果中，但 <code>name</code> 为 <code>NULL</code>，因为该部门没有员工<br><code>FULL OUTER JOIN</code> 结合了 <code>LEFT JOIN</code> 和 <code>RIGHT JOIN</code> 的效果</p></blockquote><ul><li><code>FULL OUTER JOIN</code> 也可以简写为 <code>FULL JOIN</code>（效果相同）</li><li>返回两个表中的所有记录，无匹配时显示 <code>NULL</code></li><li>MySQL <strong>不支持</strong> <code>FULL OUTER JOIN</code>，需要用 <code>UNION</code> 组合 <code>LEFT JOIN</code> 和 <code>RIGHT JOIN</code> 实现</li><li>PostgreSQL、SQL Server、Oracle 支持 <code>FULL OUTER JOIN</code></li><li>常用于查找两个表中不匹配的记录</li></ul><hr><h3 id="18-CROSS-JOIN"><a href="#18-CROSS-JOIN" class="headerlink" title="18. CROSS JOIN"></a>18. CROSS JOIN</h3><ul><li><code>CROSS JOIN</code>交叉连接是<code>SQL</code>中的一种联接操作，它返回两个表中所有可能的行组合，生成笛卡尔积<code>Cartesian Product</code>。<code>CROSS JOIN</code>不使用任何联接条件，因此会将左表的每一行与右表的每一行组合在一起。</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 基本语法</span></span><br><span class="line"><span class="keyword">SELECT</span> column1, column2, ...</span><br><span class="line"><span class="keyword">FROM</span> table1</span><br><span class="line"><span class="keyword">CROSS</span> <span class="keyword">JOIN</span> table2;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- products</span></span><br><span class="line"><span class="comment">-- | id | product_name |</span></span><br><span class="line"><span class="comment">-- |----|--------------|</span></span><br><span class="line"><span class="comment">-- | 1  | Shirt        |</span></span><br><span class="line"><span class="comment">-- | 2  | Pants        |</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- colors</span></span><br><span class="line"><span class="comment">-- | id | color_name |</span></span><br><span class="line"><span class="comment">-- |----|------------| </span></span><br><span class="line"><span class="comment">-- | 1  | Red        |</span></span><br><span class="line"><span class="comment">-- | 2  | Blue       |</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> p.product_name, c.color_name</span><br><span class="line"><span class="keyword">FROM</span> products p</span><br><span class="line"><span class="keyword">CROSS</span> <span class="keyword">JOIN</span> colors c;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询结果</span></span><br><span class="line"><span class="comment">-- | product_name | color_name |</span></span><br><span class="line"><span class="comment">-- |--------------|------------|</span></span><br><span class="line"><span class="comment">-- | Shirt        | Red        |</span></span><br><span class="line"><span class="comment">-- | Shirt        | Blue       |</span></span><br><span class="line"><span class="comment">-- | Pants        | Red        |</span></span><br><span class="line"><span class="comment">-- | Pants        | Blue       |</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>注意</strong>: 结果集的行数 &#x3D; 左表行数 × 右表行数。在这个例子中，2 × 2 &#x3D; 4 行。</p></blockquote><h4 id="替代写法"><a href="#替代写法" class="headerlink" title="替代写法"></a>替代写法</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 使用逗号（隐式CROSS JOIN）</span></span><br><span class="line"><span class="keyword">SELECT</span> p.product_name, c.color_name</span><br><span class="line"><span class="keyword">FROM</span> products p, colors c;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 等价于</span></span><br><span class="line"><span class="keyword">SELECT</span> p.product_name, c.color_name</span><br><span class="line"><span class="keyword">FROM</span> products p</span><br><span class="line"><span class="keyword">CROSS</span> <span class="keyword">JOIN</span> colors c;</span><br></pre></td></tr></table></figure><h4 id="常见应用场景"><a href="#常见应用场景" class="headerlink" title="常见应用场景"></a>常见应用场景</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 生成所有尺寸和颜色的组合</span></span><br><span class="line"><span class="keyword">SELECT</span> s.size, c.color</span><br><span class="line"><span class="keyword">FROM</span> sizes s</span><br><span class="line"><span class="keyword">CROSS</span> <span class="keyword">JOIN</span> colors c;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 生成日期和员工的所有组合（用于考勤表）</span></span><br><span class="line"><span class="keyword">SELECT</span> e.name, d.date</span><br><span class="line"><span class="keyword">FROM</span> employees e</span><br><span class="line"><span class="keyword">CROSS</span> <span class="keyword">JOIN</span> dates d;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 生成测试数据</span></span><br><span class="line"><span class="keyword">SELECT</span> n1.num <span class="operator">*</span> <span class="number">10</span> <span class="operator">+</span> n2.num <span class="keyword">AS</span> number</span><br><span class="line"><span class="keyword">FROM</span> (<span class="keyword">SELECT</span> <span class="number">0</span> <span class="keyword">AS</span> num <span class="keyword">UNION</span> <span class="keyword">SELECT</span> <span class="number">1</span> <span class="keyword">UNION</span> <span class="keyword">SELECT</span> <span class="number">2</span>) n1</span><br><span class="line"><span class="keyword">CROSS</span> <span class="keyword">JOIN</span> (<span class="keyword">SELECT</span> <span class="number">0</span> <span class="keyword">AS</span> num <span class="keyword">UNION</span> <span class="keyword">SELECT</span> <span class="number">1</span> <span class="keyword">UNION</span> <span class="keyword">SELECT</span> <span class="number">2</span>) n2;</span><br></pre></td></tr></table></figure><ul><li><code>CROSS JOIN</code> 生成笛卡尔积，结果集可能非常大</li><li>没有 <code>ON</code> 条件，返回所有可能的组合</li><li>通常用于生成组合数据或测试数据</li><li>大表使用 <code>CROSS JOIN</code> 会严重影响性能</li><li>如果意外忘记写 <code>JOIN</code> 条件，会变成 <code>CROSS JOIN</code>，导致性能问题</li></ul><hr><h3 id="19-NATURAL-JOIN"><a href="#19-NATURAL-JOIN" class="headerlink" title="19. NATURAL JOIN"></a>19. NATURAL JOIN</h3><ul><li><code>NATURAL JOIN</code>自然连接是<code>SQL</code>中的一种联接操作，它根据两个表中同名的列自动进行联接。自然连接会自动比较两个表中所有同名的列，并返回这些列值相等的行。与<code>INNER JOIN</code>不同，<code>NATURAL JOIN</code>不需要显式指定联接条件，因为它会自动查找并使用同名列进行联接。</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 基本语法</span></span><br><span class="line"><span class="keyword">SELECT</span> column1, column2, ...</span><br><span class="line"><span class="keyword">FROM</span> table1</span><br><span class="line"><span class="keyword">NATURAL</span> <span class="keyword">JOIN</span> table2;</span><br></pre></td></tr></table></figure><ul><li><strong>自动联接</strong>: <code>NATURAL JOIN</code>自动查找并使用两个表中所有同名的列来进行联接</li><li><strong>同名列值相等</strong>: 只有当两个表中同名列的值相等时，才会在结果集中返回这些行</li><li><strong>不返回重复列</strong>: 结果集中不会包含重复的同名列，只会返回一次</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- employees</span></span><br><span class="line"><span class="comment">-- | id | name    | department_id |</span></span><br><span class="line"><span class="comment">-- |----|---------|---------------|</span></span><br><span class="line"><span class="comment">-- | 1  | Alice   | 1             |</span></span><br><span class="line"><span class="comment">-- | 2  | Bob     | 2             |</span></span><br><span class="line"><span class="comment">-- | 3  | Charlie | 3             |</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- departments</span></span><br><span class="line"><span class="comment">-- | id | department_name |</span></span><br><span class="line"><span class="comment">-- |----|-----------------| </span></span><br><span class="line"><span class="comment">-- | 1  | HR              |</span></span><br><span class="line"><span class="comment">-- | 2  | Engineering     |</span></span><br><span class="line"><span class="comment">-- | 4  | Marketing       |</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">NATURAL</span> <span class="keyword">JOIN</span> departments;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询结果（自动匹配 id 列）</span></span><br><span class="line"><span class="comment">-- | id | name  | department_id | department_name |</span></span><br><span class="line"><span class="comment">-- |----|-------|---------------|-----------------|</span></span><br><span class="line"><span class="comment">-- | 1  | Alice | 1             | HR              |</span></span><br><span class="line"><span class="comment">-- | 2  | Bob   | 2             | Engineering     |</span></span><br></pre></td></tr></table></figure><blockquote><p><code>NATURAL JOIN</code> 自动使用两个表中的同名列 <code>id</code> 进行匹配<br>Charlie (id&#x3D;3) 没有出现，因为 <code>departments</code> 表中没有 <code>id=3</code> 的记录<br>Marketing (id&#x3D;4) 没有出现，因为 <code>employees</code> 表中没有 <code>id=4</code> 的记录<br>结果中 <code>id</code> 列只出现一次，不会重复</p></blockquote><h4 id="代替写法"><a href="#代替写法" class="headerlink" title="代替写法"></a>代替写法</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- NATURAL JOIN</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">NATURAL</span> <span class="keyword">JOIN</span> departments;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 等价于</span></span><br><span class="line"><span class="keyword">SELECT</span> e.id, e.name, e.department_id, d.department_name</span><br><span class="line"><span class="keyword">FROM</span> employees e</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> departments d <span class="keyword">ON</span> e.id <span class="operator">=</span> d.id;</span><br></pre></td></tr></table></figure><ul><li><strong>不推荐使用</strong>: <code>NATURAL JOIN</code> 在实际开发中很少使用，因为它依赖列名，容易出错</li><li><strong>隐式条件</strong>: 联接条件不明确，代码可读性差</li><li><strong>列名变化风险</strong>: 如果表结构发生变化（添加或重命名同名列），查询结果可能意外改变</li><li><strong>多个同名列</strong>: 如果有多个同名列，会同时用于联接条件</li><li><strong>推荐替代方案</strong>: 使用显式的 <code>INNER JOIN</code> 或 <code>LEFT JOIN</code> 并明确指定 <code>ON</code> 条件</li></ul><h4 id="为什么不推荐使用"><a href="#为什么不推荐使用" class="headerlink" title="为什么不推荐使用"></a>为什么不推荐使用</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 假设后来给 departments 表添加了 department_id 列</span></span><br><span class="line"><span class="comment">-- NATURAL JOIN 会同时匹配 id 和 department_id</span></span><br><span class="line"><span class="comment">-- 导致意外的查询结果</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">NATURAL</span> <span class="keyword">JOIN</span> departments;  <span class="comment">-- 结果可能为空或不符合预期</span></span><br></pre></td></tr></table></figure><hr><h3 id="20-LATERAL-JOIN"><a href="#20-LATERAL-JOIN" class="headerlink" title="20. LATERAL JOIN"></a>20. LATERAL JOIN</h3><ul><li><code>LATERAL JOIN</code>横向连接是<code>SQL</code>中的一种高级联接操作，它允许联接的子查询可以引用来自连接左侧表的列。<code>LATERAL</code>子句使得每一行都可以独立地进行子查询，基于当前行的值进行计算或过滤。这使得<code>LATERAL JOIN</code>特别适用于那些需要处理依赖于当前行的复杂子查询的场景。</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 基本语法</span></span><br><span class="line"><span class="keyword">SELECT</span> column1, column2, ...</span><br><span class="line"><span class="keyword">FROM</span> table1</span><br><span class="line"><span class="keyword">JOIN</span> <span class="keyword">LATERAL</span> (</span><br><span class="line">  <span class="keyword">SELECT</span> ...</span><br><span class="line">  <span class="keyword">FROM</span> table2</span><br><span class="line">  <span class="keyword">WHERE</span> table2.column <span class="operator">=</span> table1.column</span><br><span class="line">) alias <span class="keyword">ON</span> <span class="keyword">condition</span>;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- employees</span></span><br><span class="line"><span class="comment">-- | id | name  |</span></span><br><span class="line"><span class="comment">-- |----|-------|</span></span><br><span class="line"><span class="comment">-- | 1  | Alice |</span></span><br><span class="line"><span class="comment">-- | 2  | Bob   |</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- projects</span></span><br><span class="line"><span class="comment">-- | employee_id | project_name | start_date |</span></span><br><span class="line"><span class="comment">-- |-------------|--------------|------------|</span></span><br><span class="line"><span class="comment">-- | 1           | Project X    | 2023-01-01 |</span></span><br><span class="line"><span class="comment">-- | 1           | Project Y    | 2023-06-01 |</span></span><br><span class="line"><span class="comment">-- | 2           | Project Z    | 2022-09-01 |</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询每个员工最新的项目</span></span><br><span class="line"><span class="keyword">SELECT</span> e.name, p.project_name, p.start_date</span><br><span class="line"><span class="keyword">FROM</span> employees e</span><br><span class="line"><span class="keyword">JOIN</span> <span class="keyword">LATERAL</span> (</span><br><span class="line">  <span class="keyword">SELECT</span> project_name, start_date</span><br><span class="line">  <span class="keyword">FROM</span> projects pr</span><br><span class="line">  <span class="keyword">WHERE</span> pr.employee_id <span class="operator">=</span> e.id</span><br><span class="line">  <span class="keyword">ORDER</span> <span class="keyword">BY</span> start_date <span class="keyword">DESC</span></span><br><span class="line">  LIMIT <span class="number">1</span></span><br><span class="line">) p <span class="keyword">ON</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询结果</span></span><br><span class="line"><span class="comment">-- | name  | project_name | start_date |</span></span><br><span class="line"><span class="comment">-- |-------|--------------|------------|</span></span><br><span class="line"><span class="comment">-- | Alice | Project Y    | 2023-06-01 |</span></span><br><span class="line"><span class="comment">-- | Bob   | Project Z    | 2022-09-01 |</span></span><br></pre></td></tr></table></figure><blockquote><p>子查询可以引用外部表 <code>e.id</code><br>对每个员工独立执行子查询<br><code>ON true</code> 表示无额外联接条件<br>Alice 的最新项目是 Project Y，Bob 的是 Project Z</p></blockquote><h4 id="常见应用场景-1"><a href="#常见应用场景-1" class="headerlink" title="常见应用场景"></a>常见应用场景</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 获取每个部门工资最高的3名员工</span></span><br><span class="line"><span class="keyword">SELECT</span> d.department_name, e.name, e.salary</span><br><span class="line"><span class="keyword">FROM</span> departments d</span><br><span class="line"><span class="keyword">JOIN</span> <span class="keyword">LATERAL</span> (</span><br><span class="line">  <span class="keyword">SELECT</span> name, salary</span><br><span class="line">  <span class="keyword">FROM</span> employees</span><br><span class="line">  <span class="keyword">WHERE</span> department_id <span class="operator">=</span> d.id</span><br><span class="line">  <span class="keyword">ORDER</span> <span class="keyword">BY</span> salary <span class="keyword">DESC</span></span><br><span class="line">  LIMIT <span class="number">3</span></span><br><span class="line">) e <span class="keyword">ON</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 计算每个客户的最近5次订单总额</span></span><br><span class="line"><span class="keyword">SELECT</span> c.name, orders.total</span><br><span class="line"><span class="keyword">FROM</span> customers c</span><br><span class="line"><span class="keyword">JOIN</span> <span class="keyword">LATERAL</span> (</span><br><span class="line">  <span class="keyword">SELECT</span> <span class="built_in">SUM</span>(amount) <span class="keyword">as</span> total</span><br><span class="line">  <span class="keyword">FROM</span> orders</span><br><span class="line">  <span class="keyword">WHERE</span> customer_id <span class="operator">=</span> c.id</span><br><span class="line">  <span class="keyword">ORDER</span> <span class="keyword">BY</span> order_date <span class="keyword">DESC</span></span><br><span class="line">  LIMIT <span class="number">5</span></span><br><span class="line">) orders <span class="keyword">ON</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 使用 LEFT JOIN LATERAL 包含没有项目的员工</span></span><br><span class="line"><span class="keyword">SELECT</span> e.name, <span class="built_in">COALESCE</span>(p.project_name, <span class="string">&#x27;No Projects&#x27;</span>) <span class="keyword">as</span> project</span><br><span class="line"><span class="keyword">FROM</span> employees e</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> <span class="keyword">LATERAL</span> (</span><br><span class="line">  <span class="keyword">SELECT</span> project_name</span><br><span class="line">  <span class="keyword">FROM</span> projects pr</span><br><span class="line">  <span class="keyword">WHERE</span> pr.employee_id <span class="operator">=</span> e.id</span><br><span class="line">  <span class="keyword">ORDER</span> <span class="keyword">BY</span> start_date <span class="keyword">DESC</span></span><br><span class="line">  LIMIT <span class="number">1</span></span><br><span class="line">) p <span class="keyword">ON</span> <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><ul><li><strong>数据库支持</strong>: PostgreSQL 9.3+, MySQL 8.0+ (使用 <code>LATERAL</code> 关键字)</li><li><strong>性能</strong>: 对左表的每一行都执行子查询，大表时需注意性能</li><li><strong>LEFT JOIN LATERAL</strong>: 允许子查询返回空结果，类似于 <code>LEFT JOIN</code></li><li><strong>ON true</strong>: 当子查询已经包含所有过滤条件时，使用 <code>ON true</code></li><li><strong>替代方案</strong>: 某些场景可以用窗口函数或普通 <code>JOIN</code> 替代</li></ul><h4 id="数据库兼容性"><a href="#数据库兼容性" class="headerlink" title="数据库兼容性"></a>数据库兼容性</h4><ul><li><strong>PostgreSQL</strong>: 完全支持 <code>LATERAL</code></li><li><strong>MySQL 8.0+</strong>: 支持 <code>LATERAL</code>（之前版本不支持）</li><li><strong>SQL Server</strong>: 使用 <code>CROSS APPLY</code> 和 <code>OUTER APPLY</code> 代替</li><li><strong>Oracle</strong>: 使用 <code>CROSS APPLY</code> 和 <code>OUTER APPLY</code> 代替</li></ul><hr><h2 id="数据分组"><a href="#数据分组" class="headerlink" title="数据分组"></a>数据分组</h2><h3 id="21-GROUP-BY-分组"><a href="#21-GROUP-BY-分组" class="headerlink" title="21. GROUP BY 分组"></a>21. GROUP BY 分组</h3><ul><li><code>GROUP BY</code>是<code>SQL</code>中的一个子句，用于将查询结果按一个或多个列进行分组。分组操作通常与聚合函数（如<code>COUNT</code>、<code>SUM</code>、<code>AVG</code>、<code>MAX</code>、<code>MIN</code>等）结合使用，以便对每个分组进行汇总计算。<code>GROUP BY</code>允许你将数据按特定的维度进行聚合，进而对这些聚合后的数据进行分析。</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 基本语法</span></span><br><span class="line"><span class="keyword">SELECT</span> column1, column2, ..., aggregate_function(<span class="keyword">column</span>)</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">condition</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> column1, column2, ...;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- sales</span></span><br><span class="line"><span class="comment">-- | id | product_id | quantity | price |</span></span><br><span class="line"><span class="comment">-- |----|------------|----------|-------|</span></span><br><span class="line"><span class="comment">-- | 1  | 101        | 5        | 10.00 |</span></span><br><span class="line"><span class="comment">-- | 2  | 102        | 3        | 15.00 |</span></span><br><span class="line"><span class="comment">-- | 3  | 101        | 2        | 10.00 |</span></span><br><span class="line"><span class="comment">-- | 4  | 101        | 4        | 10.00 |</span></span><br><span class="line"><span class="comment">-- | 5  | 102        | 1        | 15.00 |</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 按产品ID汇总销售数量</span></span><br><span class="line"><span class="keyword">SELECT</span> product_id, <span class="built_in">SUM</span>(quantity) <span class="keyword">AS</span> total_quantity</span><br><span class="line"><span class="keyword">FROM</span> sales</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> product_id;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询结果</span></span><br><span class="line"><span class="comment">-- | product_id | total_quantity |</span></span><br><span class="line"><span class="comment">-- |------------|----------------|</span></span><br><span class="line"><span class="comment">-- | 101        | 11             |</span></span><br><span class="line"><span class="comment">-- | 102        | 4              |</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 统计每个产品的销售次数和总金额</span></span><br><span class="line"><span class="keyword">SELECT</span> product_id, </span><br><span class="line">       <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> sale_count,</span><br><span class="line">       <span class="built_in">SUM</span>(quantity <span class="operator">*</span> price) <span class="keyword">AS</span> total_revenue</span><br><span class="line"><span class="keyword">FROM</span> sales</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> product_id;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 按多个列分组</span></span><br><span class="line"><span class="keyword">SELECT</span> product_id, price, <span class="built_in">SUM</span>(quantity) <span class="keyword">AS</span> total_quantity</span><br><span class="line"><span class="keyword">FROM</span> sales</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> product_id, price;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 结合WHERE过滤</span></span><br><span class="line"><span class="keyword">SELECT</span> product_id, <span class="built_in">SUM</span>(quantity) <span class="keyword">AS</span> total_quantity</span><br><span class="line"><span class="keyword">FROM</span> sales</span><br><span class="line"><span class="keyword">WHERE</span> price <span class="operator">&gt;</span> <span class="number">10</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> product_id;</span><br></pre></td></tr></table></figure><h4 id="常用聚合函数"><a href="#常用聚合函数" class="headerlink" title="常用聚合函数"></a>常用聚合函数</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- COUNT: 计数</span></span><br><span class="line"><span class="keyword">SELECT</span> department_id, <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> employee_count</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- SUM: 求和</span></span><br><span class="line"><span class="keyword">SELECT</span> department_id, <span class="built_in">SUM</span>(salary) <span class="keyword">AS</span> total_salary</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- AVG: 平均值</span></span><br><span class="line"><span class="keyword">SELECT</span> department_id, <span class="built_in">AVG</span>(salary) <span class="keyword">AS</span> avg_salary</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- MAX/MIN: 最大值/最小值</span></span><br><span class="line"><span class="keyword">SELECT</span> department_id, <span class="built_in">MAX</span>(salary) <span class="keyword">AS</span> max_salary, <span class="built_in">MIN</span>(salary) <span class="keyword">AS</span> min_salary</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 多个聚合函数组合</span></span><br><span class="line"><span class="keyword">SELECT</span> department_id,</span><br><span class="line">       <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> employee_count,</span><br><span class="line">       <span class="built_in">AVG</span>(salary) <span class="keyword">AS</span> avg_salary,</span><br><span class="line">       <span class="built_in">MAX</span>(salary) <span class="keyword">AS</span> max_salary</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id;</span><br></pre></td></tr></table></figure><ul><li><strong>SELECT中的列</strong>: <code>SELECT</code>子句中出现的非聚合列必须在<code>GROUP BY</code>中列出</li><li><strong>执行顺序</strong>: <code>WHERE</code> → <code>GROUP BY</code> → 聚合函数 → <code>HAVING</code> → <code>SELECT</code></li><li><strong>NULL值处理</strong>: <code>NULL</code>值会被分为一组</li><li><strong>性能</strong>: 在分组列上建立索引可以提高性能</li></ul><h4 id="错误示例"><a href="#错误示例" class="headerlink" title="错误示例"></a>错误示例</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- ❌ 错误: name 不在 GROUP BY 中，也不是聚合函数</span></span><br><span class="line"><span class="keyword">SELECT</span> department_id, name, <span class="built_in">COUNT</span>(<span class="operator">*</span>)</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- ✅ 正确: 所有非聚合列都在 GROUP BY 中</span></span><br><span class="line"><span class="keyword">SELECT</span> department_id, name, <span class="built_in">COUNT</span>(<span class="operator">*</span>)</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id, name;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- ✅ 正确: 只选择分组列和聚合结果</span></span><br><span class="line"><span class="keyword">SELECT</span> department_id, <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> employee_count</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id;</span><br></pre></td></tr></table></figure><hr><h3 id="22-HAVING"><a href="#22-HAVING" class="headerlink" title="22. HAVING"></a>22. HAVING</h3><ul><li><code>HAVING</code>子句是<code>SQL</code>中的一部分，主要用于在分组后的结果集上进行过滤。它通常与<code>GROUP BY</code>子句一起使用，以便对聚合后的数据进行进一步的筛选。与<code>WHERE</code>子句不同，<code>HAVING</code>子句用于过滤基于聚合函数的结果，而<code>WHERE</code>子句是在数据分组之前对行进行过滤。</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 基本语法</span></span><br><span class="line"><span class="keyword">SELECT</span> column1, column2, aggregate_function(column3)</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">condition</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> column1, column2</span><br><span class="line"><span class="keyword">HAVING</span> aggregate_condition;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- sales</span></span><br><span class="line"><span class="comment">-- | id | product_id | quantity | price |</span></span><br><span class="line"><span class="comment">-- |----|------------|----------|-------|</span></span><br><span class="line"><span class="comment">-- | 1  | 101        | 50       | 10.00 |</span></span><br><span class="line"><span class="comment">-- | 2  | 102        | 30       | 15.00 |</span></span><br><span class="line"><span class="comment">-- | 3  | 101        | 60       | 10.00 |</span></span><br><span class="line"><span class="comment">-- | 4  | 103        | 20       | 20.00 |</span></span><br><span class="line"><span class="comment">-- | 5  | 102        | 10       | 15.00 |</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询销售总量大于100的产品</span></span><br><span class="line"><span class="keyword">SELECT</span> product_id, <span class="built_in">SUM</span>(quantity) <span class="keyword">AS</span> total_quantity</span><br><span class="line"><span class="keyword">FROM</span> sales</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> product_id</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">SUM</span>(quantity) <span class="operator">&gt;</span> <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询结果</span></span><br><span class="line"><span class="comment">-- | product_id | total_quantity |</span></span><br><span class="line"><span class="comment">-- |------------|----------------|</span></span><br><span class="line"><span class="comment">-- | 101        | 110            |</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询平均价格大于12且销售次数超过2次的产品</span></span><br><span class="line"><span class="keyword">SELECT</span> product_id, </span><br><span class="line">       <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> sale_count,</span><br><span class="line">       <span class="built_in">AVG</span>(price) <span class="keyword">AS</span> avg_price</span><br><span class="line"><span class="keyword">FROM</span> sales</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> product_id</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="operator">&gt;</span> <span class="number">2</span> <span class="keyword">AND</span> <span class="built_in">AVG</span>(price) <span class="operator">&gt;</span> <span class="number">12</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询部门员工数超过5人的部门</span></span><br><span class="line"><span class="keyword">SELECT</span> department_id, <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> employee_count</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="operator">&gt;</span> <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 结合WHERE和HAVING</span></span><br><span class="line"><span class="keyword">SELECT</span> product_id, <span class="built_in">SUM</span>(quantity) <span class="keyword">AS</span> total_quantity</span><br><span class="line"><span class="keyword">FROM</span> sales</span><br><span class="line"><span class="keyword">WHERE</span> price <span class="operator">&gt;</span> <span class="number">10</span>  <span class="comment">-- 分组前过滤：只统计价格大于10的销售</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> product_id</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">SUM</span>(quantity) <span class="operator">&gt;</span> <span class="number">50</span>;  <span class="comment">-- 分组后过滤：只显示总量大于50的产品</span></span><br></pre></td></tr></table></figure><h4 id="WHERE-vs-HAVING"><a href="#WHERE-vs-HAVING" class="headerlink" title="WHERE vs HAVING"></a>WHERE vs HAVING</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- WHERE: 在分组前过滤行</span></span><br><span class="line"><span class="keyword">SELECT</span> department_id, <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> employee_count</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> salary <span class="operator">&gt;</span> <span class="number">50000</span>  <span class="comment">-- 过滤掉工资≤50000的员工</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- HAVING: 在分组后过滤组</span></span><br><span class="line"><span class="keyword">SELECT</span> department_id, <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> employee_count</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="operator">&gt;</span> <span class="number">10</span>;  <span class="comment">-- 过滤掉员工数≤10的部门</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 同时使用WHERE和HAVING</span></span><br><span class="line"><span class="keyword">SELECT</span> department_id, <span class="built_in">AVG</span>(salary) <span class="keyword">AS</span> avg_salary</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> hire_date <span class="operator">&gt;</span> <span class="string">&#x27;2020-01-01&#x27;</span>  <span class="comment">-- 先过滤：只看2020年后入职的员工</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">AVG</span>(salary) <span class="operator">&gt;</span> <span class="number">60000</span>;  <span class="comment">-- 再过滤：只看平均工资&gt;60000的部门</span></span><br></pre></td></tr></table></figure><h4 id="执行顺序"><a href="#执行顺序" class="headerlink" title="执行顺序"></a>执行顺序</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> department_id, <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> employee_count</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> salary <span class="operator">&gt;</span> <span class="number">50000</span>        <span class="comment">-- 1. 先执行WHERE过滤行</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id      <span class="comment">-- 2. 对过滤后的行分组</span></span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="operator">&gt;</span> <span class="number">5</span>         <span class="comment">-- 3. 对分组结果过滤</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> employee_count <span class="keyword">DESC</span> <span class="comment">-- 4. 最后排序</span></span><br><span class="line">LIMIT <span class="number">10</span>;                   <span class="comment">-- 5. 限制结果数量</span></span><br></pre></td></tr></table></figure><ul><li><strong>使用场景</strong>: <code>HAVING</code>用于过滤聚合结果，<code>WHERE</code>用于过滤原始行</li><li><strong>性能</strong>: 优先使用<code>WHERE</code>过滤，减少需要分组的数据量</li><li><strong>聚合函数</strong>: <code>HAVING</code>中可以使用聚合函数，<code>WHERE</code>中不能</li><li><strong>列引用</strong>: <code>HAVING</code>可以引用<code>SELECT</code>中的别名（部分数据库支持）</li><li><strong>执行顺序</strong>: <code>WHERE</code> → <code>GROUP BY</code> → <code>HAVING</code> → <code>SELECT</code> → <code>ORDER BY</code></li></ul><h4 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- ❌ 错误: WHERE中不能使用聚合函数</span></span><br><span class="line"><span class="keyword">SELECT</span> department_id, <span class="built_in">AVG</span>(salary)</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> <span class="built_in">AVG</span>(salary) <span class="operator">&gt;</span> <span class="number">60000</span>  <span class="comment">-- 错误！</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- ✅ 正确: 在HAVING中使用聚合函数</span></span><br><span class="line"><span class="keyword">SELECT</span> department_id, <span class="built_in">AVG</span>(salary)</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">AVG</span>(salary) <span class="operator">&gt;</span> <span class="number">60000</span>;</span><br></pre></td></tr></table></figure><hr><h3 id="23-PARTITION-BY-分区"><a href="#23-PARTITION-BY-分区" class="headerlink" title="23. PARTITION BY 分区"></a>23. PARTITION BY 分区</h3><ul><li><code>PARTITION BY</code>是<code>SQL</code>中的一个子句，通常与窗口函数一起使用，用于将查询结果集划分为多个分区，然后在每个分区内执行特定的计算。它类似于<code>GROUP BY</code>，但<code>PARTITION BY</code>不会将数据聚合到单一行，而是保留所有行，并在每个分区内执行计算。</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 基本语法</span></span><br><span class="line"><span class="keyword">SELECT</span> column1, </span><br><span class="line">       column2, </span><br><span class="line">       window_function() <span class="keyword">OVER</span> (</span><br><span class="line">           <span class="keyword">PARTITION</span> <span class="keyword">BY</span> column_name </span><br><span class="line">           <span class="keyword">ORDER</span> <span class="keyword">BY</span> column_name</span><br><span class="line">       ) <span class="keyword">AS</span> alias_name</span><br><span class="line"><span class="keyword">FROM</span> table_name;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- sales</span></span><br><span class="line"><span class="comment">-- | id | employee_id | sale_amount | sale_date  |</span></span><br><span class="line"><span class="comment">-- |----|-------------|-------------|------------|</span></span><br><span class="line"><span class="comment">-- | 1  | 101         | 500         | 2023-08-01 |</span></span><br><span class="line"><span class="comment">-- | 2  | 101         | 700         | 2023-08-02 |</span></span><br><span class="line"><span class="comment">-- | 3  | 102         | 300         | 2023-08-01 |</span></span><br><span class="line"><span class="comment">-- | 4  | 101         | 400         | 2023-08-03 |</span></span><br><span class="line"><span class="comment">-- | 5  | 102         | 800         | 2023-08-02 |</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 按员工分区，对每个员工的销售额排名</span></span><br><span class="line"><span class="keyword">SELECT</span> employee_id, </span><br><span class="line">       sale_date, </span><br><span class="line">       sale_amount,</span><br><span class="line">       <span class="built_in">RANK</span>() <span class="keyword">OVER</span> (</span><br><span class="line">           <span class="keyword">PARTITION</span> <span class="keyword">BY</span> employee_id </span><br><span class="line">           <span class="keyword">ORDER</span> <span class="keyword">BY</span> sale_amount <span class="keyword">DESC</span></span><br><span class="line">       ) <span class="keyword">AS</span> sales_rank</span><br><span class="line"><span class="keyword">FROM</span> sales;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询结果</span></span><br><span class="line"><span class="comment">-- | employee_id | sale_date  | sale_amount | sales_rank |</span></span><br><span class="line"><span class="comment">-- |-------------|------------|-------------|------------|</span></span><br><span class="line"><span class="comment">-- | 101         | 2023-08-02 | 700         | 1          |</span></span><br><span class="line"><span class="comment">-- | 101         | 2023-08-01 | 500         | 2          |</span></span><br><span class="line"><span class="comment">-- | 101         | 2023-08-03 | 400         | 3          |</span></span><br><span class="line"><span class="comment">-- | 102         | 2023-08-02 | 800         | 1          |</span></span><br><span class="line"><span class="comment">-- | 102         | 2023-08-01 | 300         | 2          |</span></span><br></pre></td></tr></table></figure><blockquote><p>每个员工的销售记录都保留了，同时在各自的分区内进行了排名。</p></blockquote><h4 id="常见窗口函数示例"><a href="#常见窗口函数示例" class="headerlink" title="常见窗口函数示例"></a>常见窗口函数示例</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- ROW_NUMBER: 为每个分区内的行分配唯一序号</span></span><br><span class="line"><span class="keyword">SELECT</span> employee_id, </span><br><span class="line">       sale_date, </span><br><span class="line">       sale_amount,</span><br><span class="line">       <span class="built_in">ROW_NUMBER</span>() <span class="keyword">OVER</span> (</span><br><span class="line">           <span class="keyword">PARTITION</span> <span class="keyword">BY</span> employee_id </span><br><span class="line">           <span class="keyword">ORDER</span> <span class="keyword">BY</span> sale_date</span><br><span class="line">       ) <span class="keyword">AS</span> row_num</span><br><span class="line"><span class="keyword">FROM</span> sales;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- SUM: 计算每个分区的累计总和</span></span><br><span class="line"><span class="keyword">SELECT</span> employee_id, </span><br><span class="line">       sale_date, </span><br><span class="line">       sale_amount,</span><br><span class="line">       <span class="built_in">SUM</span>(sale_amount) <span class="keyword">OVER</span> (</span><br><span class="line">           <span class="keyword">PARTITION</span> <span class="keyword">BY</span> employee_id </span><br><span class="line">           <span class="keyword">ORDER</span> <span class="keyword">BY</span> sale_date</span><br><span class="line">       ) <span class="keyword">AS</span> running_total</span><br><span class="line"><span class="keyword">FROM</span> sales;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- AVG: 计算每个分区的平均值</span></span><br><span class="line"><span class="keyword">SELECT</span> employee_id, </span><br><span class="line">       sale_date, </span><br><span class="line">       sale_amount,</span><br><span class="line">       <span class="built_in">AVG</span>(sale_amount) <span class="keyword">OVER</span> (</span><br><span class="line">           <span class="keyword">PARTITION</span> <span class="keyword">BY</span> employee_id</span><br><span class="line">       ) <span class="keyword">AS</span> avg_sale</span><br><span class="line"><span class="keyword">FROM</span> sales;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- DENSE_RANK: 排名，相同值排名相同，无间隔</span></span><br><span class="line"><span class="keyword">SELECT</span> employee_id, </span><br><span class="line">       sale_date, </span><br><span class="line">       sale_amount,</span><br><span class="line">       <span class="built_in">DENSE_RANK</span>() <span class="keyword">OVER</span> (</span><br><span class="line">           <span class="keyword">PARTITION</span> <span class="keyword">BY</span> employee_id </span><br><span class="line">           <span class="keyword">ORDER</span> <span class="keyword">BY</span> sale_amount <span class="keyword">DESC</span></span><br><span class="line">       ) <span class="keyword">AS</span> dense_rank</span><br><span class="line"><span class="keyword">FROM</span> sales;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- LAG/LEAD: 访问前一行或后一行的数据</span></span><br><span class="line"><span class="keyword">SELECT</span> employee_id, </span><br><span class="line">       sale_date, </span><br><span class="line">       sale_amount,</span><br><span class="line">       <span class="built_in">LAG</span>(sale_amount) <span class="keyword">OVER</span> (</span><br><span class="line">           <span class="keyword">PARTITION</span> <span class="keyword">BY</span> employee_id </span><br><span class="line">           <span class="keyword">ORDER</span> <span class="keyword">BY</span> sale_date</span><br><span class="line">       ) <span class="keyword">AS</span> prev_sale,</span><br><span class="line">       <span class="built_in">LEAD</span>(sale_amount) <span class="keyword">OVER</span> (</span><br><span class="line">           <span class="keyword">PARTITION</span> <span class="keyword">BY</span> employee_id </span><br><span class="line">           <span class="keyword">ORDER</span> <span class="keyword">BY</span> sale_date</span><br><span class="line">       ) <span class="keyword">AS</span> next_sale</span><br><span class="line"><span class="keyword">FROM</span> sales;</span><br></pre></td></tr></table></figure><ul><li><strong>保留所有行</strong>: <code>PARTITION BY</code>不会减少行数，而是为每行添加计算结果</li><li><strong>窗口函数</strong>: 必须与窗口函数（如<code>ROW_NUMBER</code>、<code>RANK</code>、<code>SUM</code>等）一起使用</li><li><strong>ORDER BY</strong>: 窗口函数内的<code>ORDER BY</code>定义分区内的排序，与查询的<code>ORDER BY</code>不同</li><li><strong>性能</strong>: 窗口函数可能比较耗费资源，大数据集需要注意性能</li><li><strong>数据库支持</strong>: 大多数现代数据库支持窗口函数（PostgreSQL、MySQL 8.0+、SQL Server、Oracle）</li></ul><hr><h2 id="集合运算"><a href="#集合运算" class="headerlink" title="集合运算"></a>集合运算</h2><h3 id="24-UNION-组合"><a href="#24-UNION-组合" class="headerlink" title="24. UNION 组合"></a>24. UNION 组合</h3><ul><li><code>UNION</code>是<code>SQL</code>中的一个运算符，用于将两个或多个<code>SELECT</code>语句的结果组合成一个结果集。<code>UNION</code>运算符将多个查询的结果合并为一个，且默认情况下会去除重复的行。如果你希望保留重复行，可以使用<code>UNION ALL</code>。</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 基本语法</span></span><br><span class="line"><span class="keyword">SELECT</span> column1, column2, ...</span><br><span class="line"><span class="keyword">FROM</span> table1</span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> column1, column2, ...</span><br><span class="line"><span class="keyword">FROM</span> table2;</span><br></pre></td></tr></table></figure><ul><li><strong>列数和数据类型必须一致</strong>: 参与<code>UNION</code>的每个<code>SELECT</code>语句中，列数必须相同，且对应列的数据类型应该兼容或相同</li><li><strong>列的顺序和名称</strong>: 在合并的结果集中，列的顺序以第一个<code>SELECT</code>语句中的列为准，列名也是根据第一个<code>SELECT</code>语句的列名</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- employees_2023</span></span><br><span class="line"><span class="comment">-- | id | name    | department |</span></span><br><span class="line"><span class="comment">-- |----|---------|------------|</span></span><br><span class="line"><span class="comment">-- | 1  | Alice   | HR         |</span></span><br><span class="line"><span class="comment">-- | 2  | Bob     | IT         |</span></span><br><span class="line"><span class="comment">-- | 3  | Charlie | Finance    |</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- employees_2024</span></span><br><span class="line"><span class="comment">-- | id | name  | department |</span></span><br><span class="line"><span class="comment">-- |----|-------|------------|</span></span><br><span class="line"><span class="comment">-- | 2  | Bob   | IT         |</span></span><br><span class="line"><span class="comment">-- | 4  | David | Marketing  |</span></span><br><span class="line"><span class="comment">-- | 5  | Eve   | HR         |</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- UNION: 去除重复行</span></span><br><span class="line"><span class="keyword">SELECT</span> id, name, department</span><br><span class="line"><span class="keyword">FROM</span> employees_2023</span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> id, name, department</span><br><span class="line"><span class="keyword">FROM</span> employees_2024;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询结果（Bob只出现一次）</span></span><br><span class="line"><span class="comment">-- | id | name    | department |</span></span><br><span class="line"><span class="comment">-- |----|---------|------------|</span></span><br><span class="line"><span class="comment">-- | 1  | Alice   | HR         |</span></span><br><span class="line"><span class="comment">-- | 2  | Bob     | IT         |</span></span><br><span class="line"><span class="comment">-- | 3  | Charlie | Finance    |</span></span><br><span class="line"><span class="comment">-- | 4  | David   | Marketing  |</span></span><br><span class="line"><span class="comment">-- | 5  | Eve     | HR         |</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- UNION ALL: 保留重复行</span></span><br><span class="line"><span class="keyword">SELECT</span> id, name, department</span><br><span class="line"><span class="keyword">FROM</span> employees_2023</span><br><span class="line"><span class="keyword">UNION</span> <span class="keyword">ALL</span></span><br><span class="line"><span class="keyword">SELECT</span> id, name, department</span><br><span class="line"><span class="keyword">FROM</span> employees_2024;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询结果（Bob出现两次）</span></span><br><span class="line"><span class="comment">-- | id | name    | department |</span></span><br><span class="line"><span class="comment">-- |----|---------|------------|</span></span><br><span class="line"><span class="comment">-- | 1  | Alice   | HR         |</span></span><br><span class="line"><span class="comment">-- | 2  | Bob     | IT         |</span></span><br><span class="line"><span class="comment">-- | 3  | Charlie | Finance    |</span></span><br><span class="line"><span class="comment">-- | 2  | Bob     | IT         |</span></span><br><span class="line"><span class="comment">-- | 4  | David   | Marketing  |</span></span><br><span class="line"><span class="comment">-- | 5  | Eve     | HR         |</span></span><br></pre></td></tr></table></figure><blockquote><p>UNION: 自动去重，性能较慢<br>UNION ALL: 保留所有行，性能更快</p></blockquote><h4 id="常见应用场景-2"><a href="#常见应用场景-2" class="headerlink" title="常见应用场景"></a>常见应用场景</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 合并历史数据和当前数据</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> orders_archive</span><br><span class="line"><span class="keyword">UNION</span> <span class="keyword">ALL</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> orders_current;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 合并不同条件的查询结果</span></span><br><span class="line"><span class="keyword">SELECT</span> id, name <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> department <span class="operator">=</span> <span class="string">&#x27;IT&#x27;</span></span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> id, name <span class="keyword">FROM</span> contractors <span class="keyword">WHERE</span> status <span class="operator">=</span> <span class="string">&#x27;active&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 生成报表数据</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="string">&#x27;Total Sales&#x27;</span> <span class="keyword">AS</span> metric, <span class="built_in">SUM</span>(amount) <span class="keyword">AS</span> <span class="keyword">value</span> <span class="keyword">FROM</span> sales</span><br><span class="line"><span class="keyword">UNION</span> <span class="keyword">ALL</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="string">&#x27;Average Sale&#x27;</span>, <span class="built_in">AVG</span>(amount) <span class="keyword">FROM</span> sales</span><br><span class="line"><span class="keyword">UNION</span> <span class="keyword">ALL</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="string">&#x27;Max Sale&#x27;</span>, <span class="built_in">MAX</span>(amount) <span class="keyword">FROM</span> sales;</span><br></pre></td></tr></table></figure><ul><li><strong>列数必须相同</strong>: 所有<code>SELECT</code>语句必须返回相同数量的列</li><li><strong>数据类型兼容</strong>: 对应列的数据类型必须兼容</li><li><strong>列名</strong>: 结果集使用第一个<code>SELECT</code>的列名</li><li><strong>性能</strong>: <code>UNION</code>需要去重，比<code>UNION ALL</code>慢。如果确定没有重复或不需要去重，使用<code>UNION ALL</code></li><li><strong>ORDER BY</strong>: 只能在最后一个查询后使用，对整个结果集排序</li><li><strong>NULL值</strong>: <code>NULL</code>被视为相等，会被<code>UNION</code>去重</li></ul><hr><h3 id="25-INTERSECT-交集"><a href="#25-INTERSECT-交集" class="headerlink" title="25. INTERSECT 交集"></a>25. INTERSECT 交集</h3><ul><li><code>INTERSECT</code>是<code>SQL</code>中的一个运算符，用于返回两个或多个<code>SELECT</code>语句结果集的交集。换句话说，它返回的是在所有参与查询的结果集中都存在的行。</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 基本语法</span></span><br><span class="line"><span class="keyword">SELECT</span> column1, column2, ...</span><br><span class="line"><span class="keyword">FROM</span> table1</span><br><span class="line"><span class="keyword">INTERSECT</span></span><br><span class="line"><span class="keyword">SELECT</span> column1, column2, ...</span><br><span class="line"><span class="keyword">FROM</span> table2;</span><br></pre></td></tr></table></figure><ul><li><strong>返回共有行</strong>: 只返回在所有<code>SELECT</code>语句结果集中都存在的行</li><li><strong>自动去重</strong>: 会自动去除结果中的重复行</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- employees_2023</span></span><br><span class="line"><span class="comment">-- | id | name    | department |</span></span><br><span class="line"><span class="comment">-- |----|---------|------------|</span></span><br><span class="line"><span class="comment">-- | 1  | Alice   | HR         |</span></span><br><span class="line"><span class="comment">-- | 2  | Bob     | IT         |</span></span><br><span class="line"><span class="comment">-- | 3  | Charlie | Finance    |</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- employees_2024</span></span><br><span class="line"><span class="comment">-- | id | name  | department |</span></span><br><span class="line"><span class="comment">-- |----|-------|------------|</span></span><br><span class="line"><span class="comment">-- | 2  | Bob   | IT         |</span></span><br><span class="line"><span class="comment">-- | 3  | Charlie | Finance  |</span></span><br><span class="line"><span class="comment">-- | 4  | David | Marketing  |</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询在2023年和2024年都存在的员工</span></span><br><span class="line"><span class="keyword">SELECT</span> id, name, department</span><br><span class="line"><span class="keyword">FROM</span> employees_2023</span><br><span class="line"><span class="keyword">INTERSECT</span></span><br><span class="line"><span class="keyword">SELECT</span> id, name, department</span><br><span class="line"><span class="keyword">FROM</span> employees_2024;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询结果</span></span><br><span class="line"><span class="comment">-- | id | name    | department |</span></span><br><span class="line"><span class="comment">-- |----|---------|------------|</span></span><br><span class="line"><span class="comment">-- | 2  | Bob     | IT         |</span></span><br><span class="line"><span class="comment">-- | 3  | Charlie | Finance    |</span></span><br></pre></td></tr></table></figure><ul><li>列数和数据类型必须一致</li><li>自动去除重复行</li><li>MySQL <strong>不支持</strong> <code>INTERSECT</code>，需要用 <code>INNER JOIN</code> 或 <code>WHERE EXISTS</code> 实现</li><li>PostgreSQL、SQL Server、Oracle 支持 <code>INTERSECT</code></li></ul><hr><h3 id="26-EXCEPT-差集"><a href="#26-EXCEPT-差集" class="headerlink" title="26. EXCEPT 差集"></a>26. EXCEPT 差集</h3><ul><li><code>EXCEPT</code>是<code>SQL</code>中的一个运算符，用于返回两个<code>SELECT</code>语句结果集的差集，即返回第一个查询的结果集中有但第二个查询的结果集中没有的行。</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 基本语法</span></span><br><span class="line"><span class="keyword">SELECT</span> column1, column2, ...</span><br><span class="line"><span class="keyword">FROM</span> table1</span><br><span class="line"><span class="keyword">EXCEPT</span></span><br><span class="line"><span class="keyword">SELECT</span> column1, column2, ...</span><br><span class="line"><span class="keyword">FROM</span> table2;</span><br></pre></td></tr></table></figure><ul><li><strong>返回差集</strong>: 返回第一个查询结果集中有，但第二个查询结果集中没有的行</li><li><strong>自动去重</strong>: 会自动去除结果中的重复行</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- employees_2023</span></span><br><span class="line"><span class="comment">-- | id | name    | department |</span></span><br><span class="line"><span class="comment">-- |----|---------|------------|</span></span><br><span class="line"><span class="comment">-- | 1  | Alice   | HR         |</span></span><br><span class="line"><span class="comment">-- | 2  | Bob     | IT         |</span></span><br><span class="line"><span class="comment">-- | 3  | Charlie | Finance    |</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- employees_2024</span></span><br><span class="line"><span class="comment">-- | id | name    | department |</span></span><br><span class="line"><span class="comment">-- |----|---------|------------|</span></span><br><span class="line"><span class="comment">-- | 2  | Bob     | IT         |</span></span><br><span class="line"><span class="comment">-- | 4  | David   | Marketing  |</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询在2023年存在但在2024年不存在的员工</span></span><br><span class="line"><span class="keyword">SELECT</span> id, name, department</span><br><span class="line"><span class="keyword">FROM</span> employees_2023</span><br><span class="line"><span class="keyword">EXCEPT</span></span><br><span class="line"><span class="keyword">SELECT</span> id, name, department</span><br><span class="line"><span class="keyword">FROM</span> employees_2024;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询结果</span></span><br><span class="line"><span class="comment">-- | id | name    | department |</span></span><br><span class="line"><span class="comment">-- |----|---------|------------|</span></span><br><span class="line"><span class="comment">-- | 1  | Alice   | HR         |</span></span><br><span class="line"><span class="comment">-- | 3  | Charlie | Finance    |</span></span><br></pre></td></tr></table></figure><ul><li>列数和数据类型必须一致</li><li>自动去除重复行</li><li>顺序很重要: <code>A EXCEPT B</code> ≠ <code>B EXCEPT A</code></li><li>MySQL 使用 <code>EXCEPT</code> 或 <code>MINUS</code>（MySQL 8.0.31+支持<code>EXCEPT</code>）</li><li>Oracle 使用 <code>MINUS</code> 代替 <code>EXCEPT</code></li><li>PostgreSQL、SQL Server 支持 <code>EXCEPT</code></li></ul><hr><h2 id="分组集"><a href="#分组集" class="headerlink" title="分组集"></a>分组集</h2><h3 id="27-GROUPING-SETS"><a href="#27-GROUPING-SETS" class="headerlink" title="27. GROUPING SETS"></a>27. GROUPING SETS</h3><ul><li><code>GROUPING SETS</code>是<code>SQL</code>中的一种高级分组功能，用于在单个查询中实现多种分组方式。它允许你在一次查询中指定多个分组标准，并返回每个分组标准的聚合结果。</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 基本语法</span></span><br><span class="line"><span class="keyword">SELECT</span> column1, column2, ..., aggregate_function(<span class="keyword">column</span>)</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">GROUPING</span> SETS ( (column1), (column2), ...);</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- sales</span></span><br><span class="line"><span class="comment">-- | id | employee_id | product_id | sale_amount |</span></span><br><span class="line"><span class="comment">-- |----|-------------|------------|-------------|</span></span><br><span class="line"><span class="comment">-- | 1  | 101         | 1          | 100         |</span></span><br><span class="line"><span class="comment">-- | 2  | 102         | 1          | 200         |</span></span><br><span class="line"><span class="comment">-- | 3  | 101         | 2          | 150         |</span></span><br><span class="line"><span class="comment">-- | 4  | 103         | 2          | 250         |</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 按员工、按产品、总计三种方式分组</span></span><br><span class="line"><span class="keyword">SELECT</span> employee_id, </span><br><span class="line">       product_id, </span><br><span class="line">       <span class="built_in">SUM</span>(sale_amount) <span class="keyword">AS</span> total_sales</span><br><span class="line"><span class="keyword">FROM</span> sales</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">GROUPING</span> SETS (</span><br><span class="line">    (employee_id),</span><br><span class="line">    (product_id),</span><br><span class="line">    ()</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询结果</span></span><br><span class="line"><span class="comment">-- | employee_id | product_id | total_sales |</span></span><br><span class="line"><span class="comment">-- |-------------|------------|-------------|</span></span><br><span class="line"><span class="comment">-- | 101         | NULL       | 250         |</span></span><br><span class="line"><span class="comment">-- | 102         | NULL       | 200         |</span></span><br><span class="line"><span class="comment">-- | 103         | NULL       | 250         |</span></span><br><span class="line"><span class="comment">-- | NULL        | 1          | 300         |</span></span><br><span class="line"><span class="comment">-- | NULL        | 2          | 400         |</span></span><br><span class="line"><span class="comment">-- | NULL        | NULL       | 700         |</span></span><br></pre></td></tr></table></figure><blockquote><p><code>NULL</code>表示该维度未参与分组。例如第一组是按<code>employee_id</code>分组，所以<code>product_id</code>显示为<code>NULL</code>。</p></blockquote><ul><li><code>NULL</code>表示该列未参与分组</li><li>比多个<code>UNION ALL</code>查询更高效</li><li>PostgreSQL、SQL Server、Oracle 支持</li><li>MySQL <strong>不支持</strong> <code>GROUPING SETS</code>，需要用<code>UNION ALL</code>实现</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 对比普通 GROUP BY</span></span><br><span class="line"><span class="keyword">SELECT</span> employee_id, product_id, <span class="built_in">SUM</span>(sale_amount) <span class="keyword">AS</span> total_sales</span><br><span class="line"><span class="keyword">FROM</span> sales</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> employee_id, product_id;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询结果：只有细粒度的组合</span></span><br><span class="line"><span class="comment">-- | employee_id | product_id | total_sales |</span></span><br><span class="line"><span class="comment">-- |-------------|------------|-------------|</span></span><br><span class="line"><span class="comment">-- | 101         | 1          | 100         |</span></span><br><span class="line"><span class="comment">-- | 101         | 2          | 150         |</span></span><br><span class="line"><span class="comment">-- | 102         | 1          | 200         |</span></span><br><span class="line"><span class="comment">-- | 103         | 2          | 250         |</span></span><br></pre></td></tr></table></figure><hr><h3 id="28-CUBE-分组"><a href="#28-CUBE-分组" class="headerlink" title="28. CUBE 分组"></a>28. CUBE 分组</h3><ul><li><code>CUBE</code>是<code>SQL</code>中的一个扩展分组功能，用于在单个查询中生成所有可能组合的分组和聚合结果。<code>CUBE</code>是<code>GROUP BY</code>子句的一部分，提供了一种多维分析的方式，特别适合在需要对数据进行多维度汇总的场景中使用。</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 基本语法</span></span><br><span class="line"><span class="keyword">SELECT</span> column1, column2, ..., aggregate_function(<span class="keyword">column</span>)</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">CUBE</span> (column1, column2, ...);</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- sales</span></span><br><span class="line"><span class="comment">-- | region | product | sale_amount |</span></span><br><span class="line"><span class="comment">-- |--------|---------|-------------|</span></span><br><span class="line"><span class="comment">-- | North  | A       | 100         |</span></span><br><span class="line"><span class="comment">-- | North  | B       | 150         |</span></span><br><span class="line"><span class="comment">-- | South  | A       | 200         |</span></span><br><span class="line"><span class="comment">-- | South  | B       | 250         |</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 生成所有可能的分组组合</span></span><br><span class="line"><span class="keyword">SELECT</span> region, </span><br><span class="line">       product, </span><br><span class="line">       <span class="built_in">SUM</span>(sale_amount) <span class="keyword">AS</span> total_sales</span><br><span class="line"><span class="keyword">FROM</span> sales</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">CUBE</span> (region, product);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询结果</span></span><br><span class="line"><span class="comment">-- | region | product | total_sales |</span></span><br><span class="line"><span class="comment">-- |--------|---------|-------------|</span></span><br><span class="line"><span class="comment">-- | North  | A       | 100         | ← (region, product)</span></span><br><span class="line"><span class="comment">-- | North  | B       | 150         | ← (region, product)</span></span><br><span class="line"><span class="comment">-- | North  | NULL    | 250         | ← (region)</span></span><br><span class="line"><span class="comment">-- | South  | A       | 200         | ← (region, product)</span></span><br><span class="line"><span class="comment">-- | South  | B       | 250         | ← (region, product)</span></span><br><span class="line"><span class="comment">-- | South  | NULL    | 450         | ← (region)</span></span><br><span class="line"><span class="comment">-- | NULL   | A       | 300         | ← (product)</span></span><br><span class="line"><span class="comment">-- | NULL   | B       | 400         | ← (product)</span></span><br><span class="line"><span class="comment">-- | NULL   | NULL    | 700         | ← ()</span></span><br></pre></td></tr></table></figure><h4 id="生成的分组组合"><a href="#生成的分组组合" class="headerlink" title="生成的分组组合"></a>生成的分组组合</h4><p>对于<code>CUBE(A, B)</code>，生成 2^2 &#x3D; 4 种组合</p><ul><li><code>(A, B)</code> - 按两列分组</li><li><code>(A)</code> - 只按A分组</li><li><code>(B)</code> - 只按B分组</li><li><code>()</code> - 不分组（总计）</li></ul><p>对于<code>CUBE(A, B, C)</code>，生成 2^3 &#x3D; 8 种组合。</p><ul><li><code>CUBE(n列)</code>生成 2^n 种分组组合，列数多时结果集会很大</li><li>PostgreSQL、SQL Server、Oracle 支持</li><li>MySQL <strong>不支持</strong> <code>CUBE</code>，需要用<code>GROUPING SETS</code>或<code>UNION ALL</code>实现</li><li>适合多维分析和数据透视表场景</li></ul><hr><h3 id="29-ROLLUP-分组"><a href="#29-ROLLUP-分组" class="headerlink" title="29. ROLLUP 分组"></a>29. ROLLUP 分组</h3><ul><li><code>ROLLUP</code>是<code>SQL</code>中的一个扩展分组功能，用于生成基于层次结构的分组和聚合结果。它是<code>GROUP BY</code>子句的扩展，用于在一个查询中生成从详细到汇总的多个级别的聚合结果。<code>ROLLUP</code>常用于需要对数据进行层次分析的场景，例如销售数据按区域和时间进行汇总时。</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 基本语法</span></span><br><span class="line"><span class="keyword">SELECT</span> column1, column2, ..., aggregate_function(<span class="keyword">column</span>)</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">ROLLUP</span> (column1, column2, ...);</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- sales</span></span><br><span class="line"><span class="comment">-- | region | product | sale_amount |</span></span><br><span class="line"><span class="comment">-- |--------|---------|-------------|</span></span><br><span class="line"><span class="comment">-- | North  | A       | 100         |</span></span><br><span class="line"><span class="comment">-- | North  | B       | 150         |</span></span><br><span class="line"><span class="comment">-- | South  | A       | 200         |</span></span><br><span class="line"><span class="comment">-- | South  | B       | 250         |</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 按区域和产品生成层次汇总</span></span><br><span class="line"><span class="keyword">SELECT</span> region, </span><br><span class="line">       product, </span><br><span class="line">       <span class="built_in">SUM</span>(sale_amount) <span class="keyword">AS</span> total_sales</span><br><span class="line"><span class="keyword">FROM</span> sales</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">ROLLUP</span> (region, product);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询结果</span></span><br><span class="line"><span class="comment">-- | region | product | total_sales |</span></span><br><span class="line"><span class="comment">-- |--------|---------|-------------|</span></span><br><span class="line"><span class="comment">-- | North  | A       | 100         | ← (region, product)</span></span><br><span class="line"><span class="comment">-- | North  | B       | 150         | ← (region, product)</span></span><br><span class="line"><span class="comment">-- | North  | NULL    | 250         | ← (region) 小计</span></span><br><span class="line"><span class="comment">-- | South  | A       | 200         | ← (region, product)</span></span><br><span class="line"><span class="comment">-- | South  | B       | 250         | ← (region, product)</span></span><br><span class="line"><span class="comment">-- | South  | NULL    | 450         | ← (region) 小计</span></span><br><span class="line"><span class="comment">-- | NULL   | NULL    | 700         | ← () 总计</span></span><br></pre></td></tr></table></figure><h4 id="生成的分组组合-1"><a href="#生成的分组组合-1" class="headerlink" title="生成的分组组合"></a>生成的分组组合</h4><p>对于<code>ROLLUP(A, B, C)</code>，生成<strong>层次化</strong>的组合</p><ul><li><code>(A, B, C)</code> - 最详细</li><li><code>(A, B)</code> - 去掉最右边的C</li><li><code>(A)</code> - 再去掉B</li><li><code>()</code> - 总计</li></ul><p><strong>注意</strong>: <code>ROLLUP</code>是<strong>有顺序的</strong>，从左到右逐层汇总。</p><h4 id="ROLLUP-vs-CUBE"><a href="#ROLLUP-vs-CUBE" class="headerlink" title="ROLLUP vs CUBE"></a>ROLLUP vs CUBE</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- ROLLUP: 层次汇总，生成 n+1 种组合</span></span><br><span class="line"><span class="keyword">SELECT</span> region, product, <span class="built_in">SUM</span>(sale_amount)</span><br><span class="line"><span class="keyword">FROM</span> sales</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">ROLLUP</span> (region, product);</span><br><span class="line"><span class="comment">-- 生成: (region, product), (region), ()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- CUBE: 所有组合，生成 2^n 种组合</span></span><br><span class="line"><span class="keyword">SELECT</span> region, product, <span class="built_in">SUM</span>(sale_amount)</span><br><span class="line"><span class="keyword">FROM</span> sales</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">CUBE</span> (region, product);</span><br><span class="line"><span class="comment">-- 生成: (region, product), (region), (product), ()</span></span><br></pre></td></tr></table></figure><p><strong>关键区别</strong>: <code>ROLLUP</code>不会生成<code>(product)</code>这种跳过<code>region</code>的组合。</p><ul><li><code>ROLLUP(n列)</code>生成 n+1 种分组（比<code>CUBE</code>少）</li><li>顺序很重要：<code>ROLLUP(A, B)</code> ≠ <code>ROLLUP(B, A)</code></li><li>适合层次化数据（如：年→月→日，国家→省→市）</li><li>PostgreSQL、SQL Server、Oracle 支持</li><li>MySQL 8.0+ 支持</li></ul><hr><h2 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h2><h3 id="30-PostgreSQL-子查询"><a href="#30-PostgreSQL-子查询" class="headerlink" title="30. PostgreSQL 子查询"></a>30. PostgreSQL 子查询</h3><ul><li>子查询是嵌套在另一个查询中的<code>SELECT</code>语句。子查询可以出现在<code>SELECT</code>、<code>FROM</code>、<code>WHERE</code>、<code>HAVING</code>等子句中，用于提供动态的过滤条件、计算值或临时表。</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 基本语法</span></span><br><span class="line"><span class="comment">-- WHERE子句中的子查询</span></span><br><span class="line"><span class="keyword">SELECT</span> column1, column2</span><br><span class="line"><span class="keyword">FROM</span> table1</span><br><span class="line"><span class="keyword">WHERE</span> column1 <span class="keyword">IN</span> (<span class="keyword">SELECT</span> column1 <span class="keyword">FROM</span> table2);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- FROM子句中的子查询</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> (<span class="keyword">SELECT</span> column1, column2 <span class="keyword">FROM</span> table1) <span class="keyword">AS</span> subquery;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- SELECT子句中的子查询</span></span><br><span class="line"><span class="keyword">SELECT</span> column1, (<span class="keyword">SELECT</span> <span class="built_in">MAX</span>(column2) <span class="keyword">FROM</span> table2) <span class="keyword">AS</span> max_value</span><br><span class="line"><span class="keyword">FROM</span> table1;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- employees</span></span><br><span class="line"><span class="comment">-- | id | name    | salary | department_id |</span></span><br><span class="line"><span class="comment">-- |----|---------|--------|---------------|</span></span><br><span class="line"><span class="comment">-- | 1  | Alice   | 60000  | 1             |</span></span><br><span class="line"><span class="comment">-- | 2  | Bob     | 55000  | 2             |</span></span><br><span class="line"><span class="comment">-- | 3  | Charlie | 70000  | 1             |</span></span><br><span class="line"><span class="comment">-- | 4  | David   | 50000  | 2             |</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- departments</span></span><br><span class="line"><span class="comment">-- | id | name       |</span></span><br><span class="line"><span class="comment">-- |----|------------|</span></span><br><span class="line"><span class="comment">-- | 1  | IT         |</span></span><br><span class="line"><span class="comment">-- | 2  | HR         |</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- WHERE子句：查询工资高于平均工资的员工</span></span><br><span class="line"><span class="keyword">SELECT</span> name, salary</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> salary <span class="operator">&gt;</span> (<span class="keyword">SELECT</span> <span class="built_in">AVG</span>(salary) <span class="keyword">FROM</span> employees);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询结果</span></span><br><span class="line"><span class="comment">-- | name    | salary |</span></span><br><span class="line"><span class="comment">-- |---------|--------|</span></span><br><span class="line"><span class="comment">-- | Alice   | 60000  |</span></span><br><span class="line"><span class="comment">-- | Charlie | 70000  |</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- FROM子句：查询每个部门的平均工资</span></span><br><span class="line"><span class="keyword">SELECT</span> d.name, avg_salary</span><br><span class="line"><span class="keyword">FROM</span> departments d</span><br><span class="line"><span class="keyword">JOIN</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> department_id, <span class="built_in">AVG</span>(salary) <span class="keyword">AS</span> avg_salary</span><br><span class="line">    <span class="keyword">FROM</span> employees</span><br><span class="line">    <span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id</span><br><span class="line">) dept_avg <span class="keyword">ON</span> d.id <span class="operator">=</span> dept_avg.department_id;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- SELECT子句：显示每个员工及其部门的平均工资</span></span><br><span class="line"><span class="keyword">SELECT</span> name, </span><br><span class="line">       salary,</span><br><span class="line">       (<span class="keyword">SELECT</span> <span class="built_in">AVG</span>(salary) </span><br><span class="line">        <span class="keyword">FROM</span> employees e2 </span><br><span class="line">        <span class="keyword">WHERE</span> e2.department_id <span class="operator">=</span> e1.department_id) <span class="keyword">AS</span> dept_avg</span><br><span class="line"><span class="keyword">FROM</span> employees e1;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- IN子句：查询IT部门的员工</span></span><br><span class="line"><span class="keyword">SELECT</span> name, salary</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> department_id <span class="keyword">IN</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> id <span class="keyword">FROM</span> departments <span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">&#x27;IT&#x27;</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- EXISTS子句：查询有员工的部门</span></span><br><span class="line"><span class="keyword">SELECT</span> name</span><br><span class="line"><span class="keyword">FROM</span> departments d</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">EXISTS</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="number">1</span> <span class="keyword">FROM</span> employees e <span class="keyword">WHERE</span> e.department_id <span class="operator">=</span> d.id</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h4 id="ANY-x2F-ALL-操作符"><a href="#ANY-x2F-ALL-操作符" class="headerlink" title="ANY&#x2F;ALL 操作符"></a>ANY&#x2F;ALL 操作符</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- ANY：满足任意一个条件</span></span><br><span class="line"><span class="keyword">SELECT</span> name, salary</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> salary <span class="operator">&gt;</span> <span class="keyword">ANY</span> (<span class="keyword">SELECT</span> salary <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> department_id <span class="operator">=</span> <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- ALL：满足所有条件</span></span><br><span class="line"><span class="keyword">SELECT</span> name, salary</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> salary <span class="operator">&gt;</span> <span class="keyword">ALL</span> (<span class="keyword">SELECT</span> salary <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> department_id <span class="operator">=</span> <span class="number">2</span>);</span><br></pre></td></tr></table></figure><ul><li>子查询必须用括号包裹</li><li><code>SELECT</code>子句中的子查询必须返回单个值</li><li><code>FROM</code>子句中的子查询必须有别名</li><li>相关子查询会对外部查询的每一行执行一次，性能较差</li><li>能用<code>JOIN</code>的地方优先用<code>JOIN</code>，通常性能更好</li></ul><hr><h3 id="31-ANY"><a href="#31-ANY" class="headerlink" title="31. ANY"></a>31. ANY</h3><ul><li><code>ANY</code>运算符用于将一个值与子查询返回的一组值进行比较。如果子查询的任何值满足条件，则返回<code>true</code>。</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 基本形式</span></span><br><span class="line"><span class="keyword">SELECT</span> title</span><br><span class="line"><span class="keyword">FROM</span> film</span><br><span class="line"><span class="keyword">WHERE</span> length <span class="operator">&gt;</span> <span class="keyword">ANY</span>(</span><br><span class="line">    <span class="keyword">SELECT</span> length <span class="keyword">FROM</span> film <span class="keyword">WHERE</span> category_id <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查找每个类别的最大电影时长</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">MAX</span>(length)</span><br><span class="line"><span class="keyword">FROM</span> film</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> film_category <span class="keyword">USING</span>(film_id)</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> category_id;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查找长度大于等于任何类别最大长度的电影</span></span><br><span class="line"><span class="keyword">SELECT</span> title</span><br><span class="line"><span class="keyword">FROM</span> film</span><br><span class="line"><span class="keyword">WHERE</span> length <span class="operator">&gt;=</span> <span class="keyword">ANY</span>(</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="built_in">MAX</span>(length)</span><br><span class="line">    <span class="keyword">FROM</span> film</span><br><span class="line">    <span class="keyword">INNER</span> <span class="keyword">JOIN</span> film_category <span class="keyword">USING</span>(film_id)</span><br><span class="line">    <span class="keyword">GROUP</span> <span class="keyword">BY</span> category_id</span><br><span class="line">);</span><br></pre></td></tr></table></figure><ul><li>子查询必须返回单列</li><li>如果子查询返回空结果集，整个查询返回空结果集</li><li><code>= ANY</code>等价于<code>IN</code></li><li><code>&lt;&gt; ANY</code><strong>不等价于</strong><code>NOT IN</code><ul><li><code>x &lt;&gt; ANY(a, b, c)</code>等价于<code>x &lt;&gt; a OR x &lt;&gt; b OR x &lt;&gt; c</code></li></ul></li></ul><hr><h3 id="32-ALL"><a href="#32-ALL" class="headerlink" title="32. ALL"></a>32. ALL</h3><ul><li><code>ALL</code>运算符用于将一个值与子查询返回的所有值进行比较。只有当值满足与子查询返回的所有值的比较条件时，才返回<code>true</code>。</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 基本形式</span></span><br><span class="line"><span class="keyword">SELECT</span> title</span><br><span class="line"><span class="keyword">FROM</span> film</span><br><span class="line"><span class="keyword">WHERE</span> length <span class="operator">&gt;</span> <span class="keyword">ALL</span>(</span><br><span class="line">    <span class="keyword">SELECT</span> length <span class="keyword">FROM</span> film <span class="keyword">WHERE</span> category_id <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><ul><li>ALL 运算符前面必须有比较运算符：<code>=</code>、<code>!=</code>、<code>&gt;</code>、<code>&gt;=</code>、<code>&lt;</code>、<code>&lt;=</code></li><li>ALL 运算符后面必须跟一个子查询，子查询也必须用括号括起来</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查询按电影评级分组的平均长度</span></span><br><span class="line"><span class="keyword">SELECT</span> ROUND(<span class="built_in">AVG</span>(length), <span class="number">2</span>) <span class="keyword">AS</span> avg_length</span><br><span class="line"><span class="keyword">FROM</span> film</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> rating</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> avg_length <span class="keyword">DESC</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查找长度大于所有平均长度的电影</span></span><br><span class="line"><span class="keyword">SELECT</span> film_id, </span><br><span class="line">       title, </span><br><span class="line">       length</span><br><span class="line"><span class="keyword">FROM</span> film</span><br><span class="line"><span class="keyword">WHERE</span> length <span class="operator">&gt;</span> <span class="keyword">ALL</span>(</span><br><span class="line">    <span class="keyword">SELECT</span> ROUND(<span class="built_in">AVG</span>(length), <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">FROM</span> film</span><br><span class="line">    <span class="keyword">GROUP</span> <span class="keyword">BY</span> rating</span><br><span class="line">)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> length;</span><br></pre></td></tr></table></figure><ul><li>子查询必须返回单列</li><li>如果子查询返回空结果集，ALL 运算符始终返回 true</li><li><code>&gt; ALL</code> 等价于”大于最大值”</li><li><code>&lt; ALL</code> 等价于”小于最小值”</li><li><code>!= ALL</code> 等价于 <code>NOT IN</code></li></ul><hr><h3 id="33-EXISTS"><a href="#33-EXISTS" class="headerlink" title="33. EXISTS"></a>33. EXISTS</h3><ul><li><code>EXISTS</code>运算符是一个布尔运算符，用于测试子查询中是否存在行。</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 基本形式</span></span><br><span class="line"><span class="keyword">SELECT</span> column1</span><br><span class="line"><span class="keyword">FROM</span> table_1</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">EXISTS</span>(</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">FROM</span> table_2</span><br><span class="line">    <span class="keyword">WHERE</span> column_2 <span class="operator">=</span> table_1.column_1</span><br><span class="line">);</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查找至少有一笔付款金额大于11的客户</span></span><br><span class="line"><span class="keyword">SELECT</span> first_name, last_name</span><br><span class="line"><span class="keyword">FROM</span> customer c</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">EXISTS</span>(</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">FROM</span> payment p</span><br><span class="line">    <span class="keyword">WHERE</span> p.customer_id <span class="operator">=</span> c.customer_id</span><br><span class="line">    <span class="keyword">AND</span> amount <span class="operator">&gt;</span> <span class="number">11</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> first_name, last_name;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- NOT EXISTS: 查找没有支付过金额大于11的客户</span></span><br><span class="line"><span class="keyword">SELECT</span> first_name, last_name</span><br><span class="line"><span class="keyword">FROM</span> customer c</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>(</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">FROM</span> payment p</span><br><span class="line">    <span class="keyword">WHERE</span> p.customer_id <span class="operator">=</span> c.customer_id</span><br><span class="line">    <span class="keyword">AND</span> amount <span class="operator">&gt;</span> <span class="number">11</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> first_name, last_name;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- EXISTS 和 NULL</span></span><br><span class="line"><span class="keyword">SELECT</span> first_name, last_name</span><br><span class="line"><span class="keyword">FROM</span> customer</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">EXISTS</span>(<span class="keyword">SELECT</span> <span class="keyword">NULL</span>)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> first_name, last_name;</span><br></pre></td></tr></table></figure><blockquote><p>子查询返回<code>NULL</code>时，<code>EXISTS</code>返回 true，因此查询返回<code>customer</code>表中的所有行。</p></blockquote><ul><li><code>EXISTS</code>只关心是否有行返回，不关心行的内容</li><li><code>NOT EXISTS</code>与<code>EXISTS</code>相反</li><li>如果子查询返回<code>NULL</code>，<code>EXISTS</code>返回 true</li><li><code>EXISTS</code>通常比<code>IN</code>性能更好，特别是子查询返回大量数据时</li></ul><hr><h2 id="公共表表达式"><a href="#公共表表达式" class="headerlink" title="公共表表达式"></a>公共表表达式</h2><h3 id="34-WITH-查询-CTE"><a href="#34-WITH-查询-CTE" class="headerlink" title="34. WITH 查询 (CTE)"></a>34. WITH 查询 (CTE)</h3><ul><li>公共表表达式（CTE，Common Table Expression）是一个临时结果集，您可以在另一个 SQL 语句中引用它。CTE 仅在查询执行期间存在。</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 基本形式</span></span><br><span class="line"><span class="keyword">WITH</span> cte_film <span class="keyword">AS</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> film_id, </span><br><span class="line">           title,</span><br><span class="line">           <span class="keyword">CASE</span> </span><br><span class="line">               <span class="keyword">WHEN</span> length <span class="operator">&lt;</span> <span class="number">30</span> <span class="keyword">THEN</span> <span class="string">&#x27;Short&#x27;</span></span><br><span class="line">               <span class="keyword">WHEN</span> length <span class="operator">&lt;</span> <span class="number">90</span> <span class="keyword">THEN</span> <span class="string">&#x27;Medium&#x27;</span></span><br><span class="line">               <span class="keyword">ELSE</span> <span class="string">&#x27;Long&#x27;</span></span><br><span class="line">           <span class="keyword">END</span> <span class="keyword">AS</span> length    </span><br><span class="line">    <span class="keyword">FROM</span> film</span><br><span class="line">)</span><br><span class="line"><span class="keyword">SELECT</span> film_id, title, length</span><br><span class="line"><span class="keyword">FROM</span> cte_film</span><br><span class="line"><span class="keyword">WHERE</span> length <span class="operator">=</span> <span class="string">&#x27;Long&#x27;</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> title;</span><br></pre></td></tr></table></figure><ul><li>首先，指定 CTE 的名称，后跟可选的列列表</li><li>其次，在<code>WITH</code>子句主体内，指定返回结果集的查询</li><li>第三，在<code>SELECT</code>、<code>INSERT</code>、<code>UPDATE</code>或<code>DELETE</code>等语句中，将 CTE 用作表或视图</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 将 CTE 与表连接</span></span><br><span class="line"><span class="keyword">WITH</span> cte_rental <span class="keyword">AS</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> staff_id,</span><br><span class="line">           <span class="built_in">COUNT</span>(rental_id) <span class="keyword">AS</span> rental_count</span><br><span class="line">    <span class="keyword">FROM</span> rental</span><br><span class="line">    <span class="keyword">GROUP</span> <span class="keyword">BY</span> staff_id</span><br><span class="line">)</span><br><span class="line"><span class="keyword">SELECT</span> s.staff_id,</span><br><span class="line">       first_name,</span><br><span class="line">       last_name,</span><br><span class="line">       rental_count</span><br><span class="line"><span class="keyword">FROM</span> staff s</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> cte_rental <span class="keyword">USING</span> (staff_id);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 将 CTE 与窗口函数结合使用</span></span><br><span class="line"><span class="keyword">WITH</span> cte_film <span class="keyword">AS</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> film_id,</span><br><span class="line">           title,</span><br><span class="line">           rating,</span><br><span class="line">           length,</span><br><span class="line">           <span class="built_in">RANK</span>() <span class="keyword">OVER</span> (</span><br><span class="line">               <span class="keyword">PARTITION</span> <span class="keyword">BY</span> rating</span><br><span class="line">               <span class="keyword">ORDER</span> <span class="keyword">BY</span> length <span class="keyword">DESC</span></span><br><span class="line">           ) <span class="keyword">AS</span> length_rank</span><br><span class="line">    <span class="keyword">FROM</span> film</span><br><span class="line">)</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> cte_film</span><br><span class="line"><span class="keyword">WHERE</span> length_rank <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 多个 CTE</span></span><br><span class="line"><span class="keyword">WITH</span> cte1 <span class="keyword">AS</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> table1 <span class="keyword">WHERE</span> condition1</span><br><span class="line">),</span><br><span class="line">cte2 <span class="keyword">AS</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> table2 <span class="keyword">WHERE</span> condition2</span><br><span class="line">)</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> cte1</span><br><span class="line"><span class="keyword">JOIN</span> cte2 <span class="keyword">ON</span> cte1.id <span class="operator">=</span> cte2.id;</span><br></pre></td></tr></table></figure><ul><li>CTE 是临时的，仅在查询执行期间存在</li><li>CTE 可以引用自身（递归 CTE）</li><li>可以在一个查询中定义多个 CTE</li><li>CTE 通常用于简化复杂连接和子查询</li></ul><hr><h2 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h2><h3 id="35-INSERT"><a href="#35-INSERT" class="headerlink" title="35. INSERT"></a>35. INSERT</h3><ul><li>PostgreSQL 的<code>INSERT</code>语句允许您将新行插入表中</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 基本形式</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> table_name(column1, column2, …)</span><br><span class="line"><span class="keyword">VALUES</span> (value1, value2, …);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 带 RETURNING 子句</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> table_name(column1, column2, …)</span><br><span class="line"><span class="keyword">VALUES</span> (value1, value2, …)</span><br><span class="line">RETURNING <span class="operator">*</span>;</span><br></pre></td></tr></table></figure><ul><li>首先，在<code>INSERT INTO</code>关键字后，指定要插入数据的表名和列列表</li><li>其次，在<code>VALUES</code>关键字后提供逗号分隔的值列表</li><li>列和值列表中的列和值必须具有相同的顺序</li><li><code>RETURNING</code>子句用于返回插入行的信息</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建示例表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> links (</span><br><span class="line">    id SERIAL <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    url <span class="type">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    description <span class="type">VARCHAR</span>(<span class="number">255</span>),</span><br><span class="line">    last_update <span class="type">DATE</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 将单行插入表中</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> links (url, name)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="string">&#x27;https://www.rockdata.net/tutorial/&#x27;</span>, <span class="string">&#x27;PostgreSQL Tutorial&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 插入包含单引号的字符串</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> links (url, name)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="string">&#x27;http://www.oreilly.com&#x27;</span>, <span class="string">&#x27;O&#x27;&#x27;Reilly Media&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 插入日期值</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> links (url, name, last_update)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="string">&#x27;https://www.google.com&#x27;</span>, <span class="string">&#x27;Google&#x27;</span>, <span class="string">&#x27;2013-06-01&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 获取最后插入的ID</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> links (url, name)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="string">&#x27;http://www.postgresql.org&#x27;</span>, <span class="string">&#x27;PostgreSQL&#x27;</span>) </span><br><span class="line">RETURNING id;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 返回整个插入行</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> links (url, name)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="string">&#x27;http://www.example.com&#x27;</span>, <span class="string">&#x27;Example&#x27;</span>)</span><br><span class="line">RETURNING <span class="operator">*</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 返回特定列</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> links (url, name, description)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="string">&#x27;http://www.test.com&#x27;</span>, <span class="string">&#x27;Test&#x27;</span>, <span class="string">&#x27;Test Description&#x27;</span>)</span><br><span class="line">RETURNING id, name;</span><br></pre></td></tr></table></figure><h4 id="获取最后插入ID"><a href="#获取最后插入ID" class="headerlink" title="获取最后插入ID"></a>获取最后插入ID</h4><ul><li>PostgreSQL<ul><li>RETURNING id - 直接返回插入的ID</li><li>currval(‘sequence_name’) - 获取序列当前值</li><li>lastval() - 获取最后使用的序列值</li></ul></li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 使用 RETURNING (推荐)</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> table_name (column1) <span class="keyword">VALUES</span> (value1) RETURNING id;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 使用序列函数</span></span><br><span class="line"><span class="keyword">SELECT</span> currval(<span class="string">&#x27;table_name_id_seq&#x27;</span>);</span><br><span class="line"><span class="keyword">SELECT</span> lastval();</span><br></pre></td></tr></table></figure><ul><li>SQL Server<ul><li>SCOPE_IDENTITY() - 当前作用域最后插入的标识值（最常用）</li><li>@@IDENTITY - 当前会话最后插入的标识值</li><li>IDENT_CURRENT(‘table’) - 指定表的最后标识值</li></ul></li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 使用 OUTPUT</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> table_name (column1) OUTPUT INSERTED.id <span class="keyword">VALUES</span> (value1);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 使用标识函数</span></span><br><span class="line"><span class="keyword">SELECT</span> SCOPE_IDENTITY();  <span class="comment">-- 当前作用域 (推荐)</span></span><br><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@IDENTITY</span>;        <span class="comment">-- 当前会话</span></span><br><span class="line"><span class="keyword">SELECT</span> IDENT_CURRENT(<span class="string">&#x27;table_name&#x27;</span>);  <span class="comment">-- 指定表</span></span><br></pre></td></tr></table></figure><hr><h3 id="36-INSERT-插入多行"><a href="#36-INSERT-插入多行" class="headerlink" title="36. INSERT 插入多行"></a>36. INSERT 插入多行</h3><ul><li>要使用单个<code>INSERT</code>语句将多行插入表中，可以在<code>VALUES</code>子句中提供多个值列表</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 基本形式</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> table_name (column_list)</span><br><span class="line"><span class="keyword">VALUES</span></span><br><span class="line">    (value_list_1),</span><br><span class="line">    (value_list_2),</span><br><span class="line">    ...</span><br><span class="line">    (value_list_n);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 带 RETURNING 子句</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> table_name (column_list)</span><br><span class="line"><span class="keyword">VALUES</span></span><br><span class="line">    (value_list_1),</span><br><span class="line">    (value_list_2),</span><br><span class="line">    ...</span><br><span class="line">    (value_list_n)</span><br><span class="line">RETURNING <span class="operator">*</span> <span class="operator">|</span> output_expression;</span><br></pre></td></tr></table></figure><ul><li>首先，在<code>INSERT INTO</code>关键字后指定要插入数据的表名</li><li>其次，在表名称后面的括号中列出表中所需的列</li><li>第三，在<code>VALUES</code>关键字后面提供以逗号分隔的行列表</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- employees</span></span><br><span class="line"><span class="comment">-- | employee_id | name    | department | salary |</span></span><br><span class="line"><span class="comment">-- |-------------|---------|------------|--------|</span></span><br><span class="line"><span class="comment">-- | 1           | Alice   | IT         | 60000  |</span></span><br><span class="line"><span class="comment">-- | 2           | Bob     | Sales      | 55000  |</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 插入多行</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employees (name, department, salary)</span><br><span class="line"><span class="keyword">VALUES</span></span><br><span class="line">    (<span class="string">&#x27;Charlie&#x27;</span>, <span class="string">&#x27;IT&#x27;</span>, <span class="number">65000</span>),</span><br><span class="line">    (<span class="string">&#x27;David&#x27;</span>, <span class="string">&#x27;HR&#x27;</span>, <span class="number">50000</span>),</span><br><span class="line">    (<span class="string">&#x27;Eve&#x27;</span>, <span class="string">&#x27;Sales&#x27;</span>, <span class="number">58000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 插入多行并返回所有列</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employees (name, department, salary)</span><br><span class="line"><span class="keyword">VALUES</span></span><br><span class="line">    (<span class="string">&#x27;Frank&#x27;</span>, <span class="string">&#x27;IT&#x27;</span>, <span class="number">62000</span>),</span><br><span class="line">    (<span class="string">&#x27;Grace&#x27;</span>, <span class="string">&#x27;Marketing&#x27;</span>, <span class="number">56000</span>)</span><br><span class="line">RETURNING <span class="operator">*</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 插入多行并只返回 ID</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employees (name, department, salary)</span><br><span class="line"><span class="keyword">VALUES</span></span><br><span class="line">    (<span class="string">&#x27;Henry&#x27;</span>, <span class="string">&#x27;Finance&#x27;</span>, <span class="number">70000</span>),</span><br><span class="line">    (<span class="string">&#x27;Ivy&#x27;</span>, <span class="string">&#x27;HR&#x27;</span>, <span class="number">52000</span>)</span><br><span class="line">RETURNING employee_id;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 插入多行并返回特定列</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employees (name, department, salary)</span><br><span class="line"><span class="keyword">VALUES</span></span><br><span class="line">    (<span class="string">&#x27;Jack&#x27;</span>, <span class="string">&#x27;Sales&#x27;</span>, <span class="number">59000</span>),</span><br><span class="line">    (<span class="string">&#x27;Kate&#x27;</span>, <span class="string">&#x27;IT&#x27;</span>, <span class="number">67000</span>)</span><br><span class="line">RETURNING employee_id, name, department;</span><br></pre></td></tr></table></figure><ul><li>使用单个<code>INSERT</code>语句插入多行比多个单行<code>INSERT</code>语句性能更好</li><li>每个值列表必须包含相同数量的值，且顺序与列列表匹配</li><li>可以使用<code>RETURNING</code>子句返回插入的行或特定列</li><li>PostgreSQL返回格式为<code>INSERT 0 n</code>，其中<code>n</code>是插入的行数</li></ul><hr><h3 id="37-UNNEST-批量插入"><a href="#37-UNNEST-批量插入" class="headerlink" title="37. UNNEST 批量插入"></a>37. UNNEST 批量插入</h3><ul><li><code>UNNEST</code>是PostgreSQL中用于将数组展开成行的函数，常用于批量插入数据 (Bulk Upsert&#x2F;Insert)</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 基本形式</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> table_name (column1, column2, ...)</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="built_in">UNNEST</span>(</span><br><span class="line">    <span class="keyword">ARRAY</span>[value1_1, value1_2, ...],</span><br><span class="line">    <span class="keyword">ARRAY</span>[value2_1, value2_2, ...]</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 带 RETURNING 子句</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> table_name (column1, column2, ...)</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="built_in">UNNEST</span>(</span><br><span class="line">    <span class="keyword">ARRAY</span>[value1_1, value1_2, ...],</span><br><span class="line">    <span class="keyword">ARRAY</span>[value2_1, value2_2, ...]</span><br><span class="line">)</span><br><span class="line">RETURNING <span class="operator">*</span>;</span><br></pre></td></tr></table></figure><ul><li><code>UNNEST</code>将多个数组并行展开成行</li><li>每个数组对应一列</li><li>所有数组必须具有相同的长度</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建示例表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> products (</span><br><span class="line">    id SERIAL <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    price <span class="type">DECIMAL</span>(<span class="number">10</span>, <span class="number">2</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    category <span class="type">VARCHAR</span>(<span class="number">100</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 使用 UNNEST 批量插入</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> products (name, price, category)</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="built_in">UNNEST</span>(</span><br><span class="line">    <span class="keyword">ARRAY</span>[<span class="string">&#x27;Laptop&#x27;</span>, <span class="string">&#x27;Mouse&#x27;</span>, <span class="string">&#x27;Keyboard&#x27;</span>],</span><br><span class="line">    <span class="keyword">ARRAY</span>[<span class="number">999.99</span>, <span class="number">29.99</span>, <span class="number">79.99</span>],</span><br><span class="line">    <span class="keyword">ARRAY</span>[<span class="string">&#x27;Electronics&#x27;</span>, <span class="string">&#x27;Electronics&#x27;</span>, <span class="string">&#x27;Electronics&#x27;</span>]</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 使用 UNNEST 并返回插入的行</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> products (name, price, category)</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="built_in">UNNEST</span>(</span><br><span class="line">    <span class="keyword">ARRAY</span>[<span class="string">&#x27;Monitor&#x27;</span>, <span class="string">&#x27;Webcam&#x27;</span>],</span><br><span class="line">    <span class="keyword">ARRAY</span>[<span class="number">299.99</span>, <span class="number">89.99</span>],</span><br><span class="line">    <span class="keyword">ARRAY</span>[<span class="string">&#x27;Electronics&#x27;</span>, <span class="string">&#x27;Electronics&#x27;</span>]</span><br><span class="line">)</span><br><span class="line">RETURNING <span class="operator">*</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 使用 UNNEST 只返回 ID</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> products (name, price, category)</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="built_in">UNNEST</span>(</span><br><span class="line">    <span class="keyword">ARRAY</span>[<span class="string">&#x27;Headphones&#x27;</span>, <span class="string">&#x27;Speaker&#x27;</span>],</span><br><span class="line">    <span class="keyword">ARRAY</span>[<span class="number">149.99</span>, <span class="number">199.99</span>],</span><br><span class="line">    <span class="keyword">ARRAY</span>[<span class="string">&#x27;Electronics&#x27;</span>, <span class="string">&#x27;Electronics&#x27;</span>]</span><br><span class="line">)</span><br><span class="line">RETURNING id;</span><br></pre></td></tr></table></figure><h4 id="UNNEST-vs-VALUES"><a href="#UNNEST-vs-VALUES" class="headerlink" title="UNNEST vs VALUES"></a>UNNEST vs VALUES</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 方式1: 传统 VALUES</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> products (name, price)</span><br><span class="line"><span class="keyword">VALUES</span></span><br><span class="line">    (<span class="string">&#x27;Laptop&#x27;</span>, <span class="number">999.99</span>),</span><br><span class="line">    (<span class="string">&#x27;Mouse&#x27;</span>, <span class="number">29.99</span>),</span><br><span class="line">    (<span class="string">&#x27;Keyboard&#x27;</span>, <span class="number">79.99</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 方式2: UNNEST (等价)</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> products (name, price)</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="built_in">UNNEST</span>(</span><br><span class="line">    <span class="keyword">ARRAY</span>[<span class="string">&#x27;Laptop&#x27;</span>, <span class="string">&#x27;Mouse&#x27;</span>, <span class="string">&#x27;Keyboard&#x27;</span>],</span><br><span class="line">    <span class="keyword">ARRAY</span>[<span class="number">999.99</span>, <span class="number">29.99</span>, <span class="number">79.99</span>]</span><br><span class="line">);</span><br></pre></td></tr></table></figure><ul><li>所有数组必须具有相同的长度，否则会报错</li><li><code>UNNEST</code>适合从程序传入数组参数的场景</li><li>对于大批量插入，<code>UNNEST</code>可能比多个<code>VALUES</code>性能更好</li><li>数组元素类型需要与目标列类型匹配</li><li>可以使用类型转换，如<code>ARRAY[...]::type[]</code></li></ul><hr><h3 id="38-UPDATE"><a href="#38-UPDATE" class="headerlink" title="38. UPDATE"></a>38. UPDATE</h3><ul><li>PostgreSQL 的<code>UPDATE</code>语句允许修改表中的现有数据</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 基本形式</span></span><br><span class="line"><span class="keyword">UPDATE</span> table_name</span><br><span class="line"><span class="keyword">SET</span> column1 <span class="operator">=</span> value1,</span><br><span class="line">    column2 <span class="operator">=</span> value2,</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">condition</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 带 RETURNING 子句</span></span><br><span class="line"><span class="keyword">UPDATE</span> table_name</span><br><span class="line"><span class="keyword">SET</span> column1 <span class="operator">=</span> value1,</span><br><span class="line">    column2 <span class="operator">=</span> value2,</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">condition</span></span><br><span class="line">RETURNING <span class="operator">*</span> <span class="operator">|</span> output_expression;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- employees</span></span><br><span class="line"><span class="comment">-- | employee_id | name    | salary | department |</span></span><br><span class="line"><span class="comment">-- |-------------|---------|--------|------------|</span></span><br><span class="line"><span class="comment">-- | 1           | Alice   | 60000  | IT         |</span></span><br><span class="line"><span class="comment">-- | 2           | Bob     | 55000  | Sales      |</span></span><br><span class="line"><span class="comment">-- | 3           | Charlie | 50000  | Sales      |</span></span><br><span class="line"><span class="comment">-- | 4           | David   | 65000  | IT         |</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 更新单行</span></span><br><span class="line"><span class="keyword">UPDATE</span> employees</span><br><span class="line"><span class="keyword">SET</span> salary <span class="operator">=</span> <span class="number">70000</span></span><br><span class="line"><span class="keyword">WHERE</span> employee_id <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 更新多列</span></span><br><span class="line"><span class="keyword">UPDATE</span> employees</span><br><span class="line"><span class="keyword">SET</span> salary <span class="operator">=</span> <span class="number">72000</span>,</span><br><span class="line">    department <span class="operator">=</span> <span class="string">&#x27;IT&#x27;</span></span><br><span class="line"><span class="keyword">WHERE</span> employee_id <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 更新并返回更新后的行</span></span><br><span class="line"><span class="keyword">UPDATE</span> employees</span><br><span class="line"><span class="keyword">SET</span> salary <span class="operator">=</span> salary <span class="operator">*</span> <span class="number">1.1</span></span><br><span class="line"><span class="keyword">WHERE</span> department <span class="operator">=</span> <span class="string">&#x27;Sales&#x27;</span></span><br><span class="line">RETURNING <span class="operator">*</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 只返回特定列</span></span><br><span class="line"><span class="keyword">UPDATE</span> employees</span><br><span class="line"><span class="keyword">SET</span> department <span class="operator">=</span> <span class="string">&#x27;Marketing&#x27;</span></span><br><span class="line"><span class="keyword">WHERE</span> employee_id <span class="operator">=</span> <span class="number">2</span></span><br><span class="line">RETURNING employee_id, name, department;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 使用表达式更新</span></span><br><span class="line"><span class="keyword">UPDATE</span> employees</span><br><span class="line"><span class="keyword">SET</span> salary <span class="operator">=</span> salary <span class="operator">+</span> <span class="number">5000</span></span><br><span class="line"><span class="keyword">WHERE</span> salary <span class="operator">&lt;</span> <span class="number">60000</span>;</span><br></pre></td></tr></table></figure><ul><li><code>WHERE</code>子句是可选的，但省略时会更新所有行，需谨慎使用</li><li><code>UPDATE</code>语句返回<code>UPDATE count</code>，其中<code>count</code>是更新的行数</li><li><code>SET</code>子句中未出现的列保留其原始值</li><li>可以使用<code>RETURNING</code>子句返回更新后的行</li><li>可以在<code>SET</code>子句中使用表达式或其他列的值</li></ul><hr><h3 id="39-UPDATE-JOIN"><a href="#39-UPDATE-JOIN" class="headerlink" title="39. UPDATE JOIN"></a>39. UPDATE JOIN</h3><ul><li>有时，需要根据另一个表中的值更新表中的数据。在这种情况下，可以使用 PostgreSQL 的 UPDATE 连接语法。</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 基本形式</span></span><br><span class="line"><span class="keyword">UPDATE</span> t1</span><br><span class="line"><span class="keyword">SET</span> t1.c1 <span class="operator">=</span> new_value</span><br><span class="line"><span class="keyword">FROM</span> t2</span><br><span class="line"><span class="keyword">WHERE</span> t1.c2 <span class="operator">=</span> t2.c2;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 使用表别名</span></span><br><span class="line"><span class="keyword">UPDATE</span> t1</span><br><span class="line"><span class="keyword">SET</span> c1 <span class="operator">=</span> new_value</span><br><span class="line"><span class="keyword">FROM</span> t2</span><br><span class="line"><span class="keyword">WHERE</span> t1.c2 <span class="operator">=</span> t2.c2;</span><br></pre></td></tr></table></figure><ul><li>在<code>FROM</code>子句中指定要连接的表</li><li>在<code>WHERE</code>子句中提供连接条件</li><li><code>FROM</code>子句必须紧接在<code>SET</code>子句之后出现</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建 product_segment 表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> product_segment (</span><br><span class="line">    id SERIAL <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    segment <span class="type">VARCHAR</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    discount <span class="type">NUMERIC</span>(<span class="number">4</span>, <span class="number">2</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> product_segment (segment, discount)</span><br><span class="line"><span class="keyword">VALUES</span></span><br><span class="line">    (<span class="string">&#x27;Grand Luxury&#x27;</span>, <span class="number">0.05</span>),</span><br><span class="line">    (<span class="string">&#x27;Luxury&#x27;</span>, <span class="number">0.06</span>),</span><br><span class="line">    (<span class="string">&#x27;Mass&#x27;</span>, <span class="number">0.10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建 product 表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> product(</span><br><span class="line">    id SERIAL <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    name <span class="type">VARCHAR</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    price <span class="type">NUMERIC</span>(<span class="number">10</span>, <span class="number">2</span>),</span><br><span class="line">    net_price <span class="type">NUMERIC</span>(<span class="number">10</span>, <span class="number">2</span>),</span><br><span class="line">    segment_id <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    <span class="keyword">FOREIGN</span> KEY(segment_id) <span class="keyword">REFERENCES</span> product_segment(id)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> product (name, price, segment_id) </span><br><span class="line"><span class="keyword">VALUES</span> </span><br><span class="line">    (<span class="string">&#x27;diam&#x27;</span>, <span class="number">804.89</span>, <span class="number">1</span>),</span><br><span class="line">    (<span class="string">&#x27;vestibulum aliquet&#x27;</span>, <span class="number">228.55</span>, <span class="number">3</span>),</span><br><span class="line">    (<span class="string">&#x27;lacinia erat&#x27;</span>, <span class="number">366.45</span>, <span class="number">2</span>),</span><br><span class="line">    (<span class="string">&#x27;scelerisque quam turpis&#x27;</span>, <span class="number">145.33</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 根据产品细分的折扣计算净价</span></span><br><span class="line"><span class="keyword">UPDATE</span> product</span><br><span class="line"><span class="keyword">SET</span> net_price <span class="operator">=</span> price <span class="operator">-</span> price <span class="operator">*</span> discount</span><br><span class="line"><span class="keyword">FROM</span> product_segment</span><br><span class="line"><span class="keyword">WHERE</span> product.segment_id <span class="operator">=</span> product_segment.id;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 使用表别名简化查询</span></span><br><span class="line"><span class="keyword">UPDATE</span> product p</span><br><span class="line"><span class="keyword">SET</span> net_price <span class="operator">=</span> price <span class="operator">-</span> price <span class="operator">*</span> discount</span><br><span class="line"><span class="keyword">FROM</span> product_segment s</span><br><span class="line"><span class="keyword">WHERE</span> p.segment_id <span class="operator">=</span> s.id;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 更新并返回结果</span></span><br><span class="line"><span class="keyword">UPDATE</span> product p</span><br><span class="line"><span class="keyword">SET</span> net_price <span class="operator">=</span> price <span class="operator">-</span> price <span class="operator">*</span> discount</span><br><span class="line"><span class="keyword">FROM</span> product_segment s</span><br><span class="line"><span class="keyword">WHERE</span> p.segment_id <span class="operator">=</span> s.id</span><br><span class="line">RETURNING p.id, p.name, p.price, p.net_price;</span><br></pre></td></tr></table></figure><ul><li><code>FROM</code>子句允许在<code>UPDATE</code>中引用其他表</li><li>可以使用任何类型的连接（INNER JOIN、LEFT JOIN等）</li><li>使用表别名可以简化查询</li><li>可以结合<code>RETURNING</code>子句返回更新后的行</li><li>如果连接产生多个匹配行，可能会导致意外的更新结果</li></ul><hr><h3 id="40-DELETE"><a href="#40-DELETE" class="headerlink" title="40. DELETE"></a>40. DELETE</h3><ul><li>PostgreSQL 的<code>DELETE</code>语句允许从表中删除一行或多行</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 基本形式</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">condition</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 带 RETURNING 子句</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">condition</span></span><br><span class="line">RETURNING <span class="operator">*</span> <span class="operator">|</span> select_list;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- employees</span></span><br><span class="line"><span class="comment">-- | id | name    | department | salary |</span></span><br><span class="line"><span class="comment">-- |----|---------|------------|--------|</span></span><br><span class="line"><span class="comment">-- | 1  | Alice   | IT         | 60000  |</span></span><br><span class="line"><span class="comment">-- | 2  | Bob     | HR         | 55000  |</span></span><br><span class="line"><span class="comment">-- | 3  | Charlie | IT         | 70000  |</span></span><br><span class="line"><span class="comment">-- | 4  | David   | Sales      | 50000  |</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除一行</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除并返回删除的行</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">3</span></span><br><span class="line">RETURNING <span class="operator">*</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除多行</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> department <span class="operator">=</span> <span class="string">&#x27;IT&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 只返回特定列</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">2</span></span><br><span class="line">RETURNING id, name;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除所有行</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> employees;</span><br></pre></td></tr></table></figure><ul><li><code>WHERE</code>子句是可选的，但省略时会删除所有行，需谨慎使用</li><li><code>DELETE</code>语句返回删除的行数，如果未删除任何行则返回 0</li><li>可以使用<code>RETURNING</code>子句返回已删除的行</li><li><code>DELETE</code>语句仅删除数据，不修改表结构</li><li>如果要修改表结构（如删除列），应使用<code>ALTER TABLE</code>语句</li><li>删除大量数据时，考虑使用<code>TRUNCATE</code>以获得更好的性能</li></ul><hr><h3 id="41-TRUNCATE"><a href="#41-TRUNCATE" class="headerlink" title="41. TRUNCATE"></a>41. TRUNCATE</h3><ul><li><code>TRUNCATE</code>语句用于快速删除表中的所有数据。与<code>DELETE</code>相比，<code>TRUNCATE</code>性能更高，但功能更受限</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 基本形式</span></span><br><span class="line"><span class="keyword">TRUNCATE</span> <span class="keyword">TABLE</span> table_name;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 多个表</span></span><br><span class="line"><span class="keyword">TRUNCATE</span> <span class="keyword">TABLE</span> table_name1, table_name2, ...;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 重置自增序列</span></span><br><span class="line"><span class="keyword">TRUNCATE</span> <span class="keyword">TABLE</span> table_name RESTART <span class="keyword">IDENTITY</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 级联删除</span></span><br><span class="line"><span class="keyword">TRUNCATE</span> <span class="keyword">TABLE</span> table_name CASCADE;</span><br></pre></td></tr></table></figure><ul><li><code>TRUNCATE</code>比<code>DELETE</code>快得多</li><li><code>TRUNCATE</code>不能使用<code>WHERE</code>子句</li><li><code>TRUNCATE</code>会重置自增序列（使用<code>RESTART IDENTITY</code>）</li><li><code>TRUNCATE</code>不触发<code>DELETE</code>触发器</li><li><code>TRUNCATE</code>需要表的所有者权限或<code>TRUNCATE</code>权限</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- orders</span></span><br><span class="line"><span class="comment">-- | order_id | customer_id | amount | order_date |</span></span><br><span class="line"><span class="comment">-- |----------|-------------|--------|------------|</span></span><br><span class="line"><span class="comment">-- | 1        | 101         | 250.00 | 2024-01-15 |</span></span><br><span class="line"><span class="comment">-- | 2        | 102         | 180.00 | 2024-01-16 |</span></span><br><span class="line"><span class="comment">-- | 3        | 101         | 320.00 | 2024-01-17 |</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除所有数据</span></span><br><span class="line"><span class="keyword">TRUNCATE</span> <span class="keyword">TABLE</span> orders;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除数据并重置自增ID</span></span><br><span class="line"><span class="keyword">TRUNCATE</span> <span class="keyword">TABLE</span> orders RESTART <span class="keyword">IDENTITY</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 同时清空多个表</span></span><br><span class="line"><span class="keyword">TRUNCATE</span> <span class="keyword">TABLE</span> orders, order_items;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 级联删除（如果有外键引用）</span></span><br><span class="line"><span class="keyword">TRUNCATE</span> <span class="keyword">TABLE</span> orders CASCADE;</span><br></pre></td></tr></table></figure><ul><li><code>TRUNCATE</code>不能在有外键约束的表上使用，除非使用<code>CASCADE</code></li><li><code>TRUNCATE</code>操作不能回滚（在某些事务配置下）</li><li><code>TRUNCATE</code>不记录单独的行删除日志</li><li>使用<code>RESTART IDENTITY</code>重置序列从1开始</li><li>使用<code>CONTINUE IDENTITY</code>保持序列当前值（默认）</li></ul><hr><h3 id="42-UPSERT"><a href="#42-UPSERT" class="headerlink" title="42. UPSERT"></a>42. UPSERT</h3><ul><li>在关系数据库中，upsert（更新或插入的组合）指的是当您向表中插入新行时，如果该行已存在，PostgreSQL 将更新该行，否则，它将插入新行</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> table_name(column_list) </span><br><span class="line"><span class="keyword">VALUES</span>(value_list)</span><br><span class="line"><span class="keyword">ON</span> CONFLICT target action;</span><br></pre></td></tr></table></figure><p><strong>target 可以是</strong></p><ul><li><code>(column_name)</code> - 列名称</li><li><code>ON CONSTRAINT constraint_name</code> - UNIQUE 约束的名称</li><li><code>WHERE predicate</code> - 带有谓词的 WHERE 子句</li></ul><p><strong>action 可以是</strong></p><ul><li><code>DO NOTHING</code> - 如果该行已存在，则不执行任何操作</li><li><code>DO UPDATE SET column_1 = value_1, ... WHERE condition</code> - 更新表中的字段</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建示例表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> customers (</span><br><span class="line">    customer_id SERIAL <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    name <span class="type">VARCHAR</span> <span class="keyword">UNIQUE</span>,</span><br><span class="line">    email <span class="type">VARCHAR</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    active BOOL <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="literal">TRUE</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> customers (name, email)</span><br><span class="line"><span class="keyword">VALUES</span> </span><br><span class="line">    (<span class="string">&#x27;IBM&#x27;</span>, <span class="string">&#x27;contact@ibm.com&#x27;</span>),</span><br><span class="line">    (<span class="string">&#x27;Microsoft&#x27;</span>, <span class="string">&#x27;contact@microsoft.com&#x27;</span>),</span><br><span class="line">    (<span class="string">&#x27;Intel&#x27;</span>, <span class="string">&#x27;contact@intel.com&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- customers</span></span><br><span class="line"><span class="comment">-- | customer_id | name      | email                  | active |</span></span><br><span class="line"><span class="comment">-- |-------------|-----------|------------------------|--------|</span></span><br><span class="line"><span class="comment">-- | 1           | IBM       | contact@ibm.com        | true   |</span></span><br><span class="line"><span class="comment">-- | 2           | Microsoft | contact@microsoft.com  | true   |</span></span><br><span class="line"><span class="comment">-- | 3           | Intel     | contact@intel.com      | true   |</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- DO NOTHING: 如果冲突则忽略</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> customers (name, email)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="string">&#x27;Microsoft&#x27;</span>, <span class="string">&#x27;hotline@microsoft.com&#x27;</span>) </span><br><span class="line"><span class="keyword">ON</span> CONFLICT (name) </span><br><span class="line">DO NOTHING;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 使用约束名称</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> customers (name, email)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="string">&#x27;Microsoft&#x27;</span>, <span class="string">&#x27;hotline@microsoft.com&#x27;</span>) </span><br><span class="line"><span class="keyword">ON</span> CONFLICT <span class="keyword">ON</span> <span class="keyword">CONSTRAINT</span> customers_name_key </span><br><span class="line">DO NOTHING;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- DO UPDATE: 如果冲突则更新</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> customers (name, email)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="string">&#x27;Microsoft&#x27;</span>, <span class="string">&#x27;hotline@microsoft.com&#x27;</span>) </span><br><span class="line"><span class="keyword">ON</span> CONFLICT (name) </span><br><span class="line">DO <span class="keyword">UPDATE</span> <span class="keyword">SET</span> email <span class="operator">=</span> EXCLUDED.email;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 拼接新旧值</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> customers (name, email)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="string">&#x27;Microsoft&#x27;</span>, <span class="string">&#x27;hotline@microsoft.com&#x27;</span>) </span><br><span class="line"><span class="keyword">ON</span> CONFLICT (name) </span><br><span class="line">DO <span class="keyword">UPDATE</span> <span class="keyword">SET</span> email <span class="operator">=</span> EXCLUDED.email <span class="operator">||</span> <span class="string">&#x27;;&#x27;</span> <span class="operator">||</span> customers.email;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 更新多个列</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> customers (name, email, active)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="string">&#x27;IBM&#x27;</span>, <span class="string">&#x27;newemail@ibm.com&#x27;</span>, <span class="literal">false</span>) </span><br><span class="line"><span class="keyword">ON</span> CONFLICT (name) </span><br><span class="line">DO <span class="keyword">UPDATE</span> <span class="keyword">SET</span> </span><br><span class="line">    email <span class="operator">=</span> EXCLUDED.email,</span><br><span class="line">    active <span class="operator">=</span> EXCLUDED.active;</span><br></pre></td></tr></table></figure><h4 id="EXCLUDED-关键字"><a href="#EXCLUDED-关键字" class="headerlink" title="EXCLUDED 关键字"></a>EXCLUDED 关键字</h4><ul><li><code>EXCLUDED</code>是一个特殊的表引用，代表要插入的行的值。</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- EXCLUDED.column_name 表示要插入的新值</span></span><br><span class="line"><span class="comment">-- table_name.column_name 表示表中已存在的旧值</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> customers (name, email)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="string">&#x27;Microsoft&#x27;</span>, <span class="string">&#x27;new@microsoft.com&#x27;</span>) </span><br><span class="line"><span class="keyword">ON</span> CONFLICT (name) </span><br><span class="line">DO <span class="keyword">UPDATE</span> <span class="keyword">SET</span> </span><br><span class="line">    email <span class="operator">=</span> EXCLUDED.email;  <span class="comment">-- 使用新值</span></span><br></pre></td></tr></table></figure><ul><li><code>ON CONFLICT</code>子句仅在 PostgreSQL 9.5+ 可用</li><li>必须有 UNIQUE 约束或 PRIMARY KEY 才能使用 ON CONFLICT</li><li><code>DO NOTHING</code>不返回任何内容</li><li><code>DO UPDATE</code>可以使用<code>WHERE</code>子句来限制更新条件</li><li><code>EXCLUDED</code>引用要插入的行的值</li><li>类似 MySQL 的<code>INSERT ON DUPLICATE KEY UPDATE</code></li></ul><hr><h3 id="43-MERGE"><a href="#43-MERGE" class="headerlink" title="43. MERGE"></a>43. MERGE</h3><ul><li>PostgreSQL 15 引入了<code>MERGE</code>语句，可将<code>INSERT</code>、<code>UPDATE</code>和<code>DELETE</code>操作合并到一个语句中，来简化数据操作。<code>MERGE</code>语句通常被称为 UPSERT 语句</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">MERGE</span> <span class="keyword">INTO</span> target_table</span><br><span class="line"><span class="keyword">USING</span> source_query</span><br><span class="line"><span class="keyword">ON</span> merge_condition</span><br><span class="line"><span class="keyword">WHEN</span> MATCHED [<span class="keyword">AND</span> <span class="keyword">condition</span>] <span class="keyword">THEN</span> &#123;merge_update <span class="operator">|</span> merge_delete <span class="operator">|</span> DO NOTHING&#125;</span><br><span class="line"><span class="keyword">WHEN</span> <span class="keyword">NOT</span> MATCHED [<span class="keyword">AND</span> <span class="keyword">condition</span>] <span class="keyword">THEN</span> &#123;merge_insert <span class="operator">|</span> DO NOTHING&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建示例表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> leads(</span><br><span class="line">    lead_id SERIAL <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    email <span class="type">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">UNIQUE</span>,</span><br><span class="line">    active BOOL <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="literal">TRUE</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> customers(</span><br><span class="line">    customer_id SERIAL <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    email <span class="type">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">UNIQUE</span>,</span><br><span class="line">    active BOOL <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="literal">TRUE</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 插入数据到 leads</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> leads(name, email)</span><br><span class="line"><span class="keyword">VALUES</span></span><br><span class="line">   (<span class="string">&#x27;John Doe&#x27;</span>, <span class="string">&#x27;john.doe@gmail.com&#x27;</span>),</span><br><span class="line">   (<span class="string">&#x27;Jane Doe&#x27;</span>, <span class="string">&#x27;jane.doe@yahoo.com&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 示例1: 插入不匹配的行</span></span><br><span class="line"><span class="keyword">MERGE</span> <span class="keyword">INTO</span> customers c</span><br><span class="line"><span class="keyword">USING</span> leads l <span class="keyword">ON</span> c.email <span class="operator">=</span> l.email</span><br><span class="line"><span class="keyword">WHEN</span> <span class="keyword">NOT</span> MATCHED <span class="keyword">THEN</span> </span><br><span class="line">   <span class="keyword">INSERT</span> (name, email)</span><br><span class="line">   <span class="keyword">VALUES</span>(l.name, l.email);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 示例2: 插入和更新</span></span><br><span class="line"><span class="keyword">MERGE</span> <span class="keyword">INTO</span> customers c</span><br><span class="line"><span class="keyword">USING</span> leads l <span class="keyword">ON</span> c.email <span class="operator">=</span> l.email</span><br><span class="line"><span class="keyword">WHEN</span> <span class="keyword">NOT</span> MATCHED <span class="keyword">THEN</span> </span><br><span class="line">   <span class="keyword">INSERT</span> (name, email)</span><br><span class="line">   <span class="keyword">VALUES</span>(l.name, l.email)</span><br><span class="line"><span class="keyword">WHEN</span> MATCHED <span class="keyword">THEN</span></span><br><span class="line">   <span class="keyword">UPDATE</span> <span class="keyword">SET</span> </span><br><span class="line">      name <span class="operator">=</span> l.name, </span><br><span class="line">      email <span class="operator">=</span> l.email;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 示例3: 插入、更新和删除</span></span><br><span class="line"><span class="keyword">MERGE</span> <span class="keyword">INTO</span> customers c</span><br><span class="line"><span class="keyword">USING</span> leads l <span class="keyword">ON</span> c.email <span class="operator">=</span> l.email</span><br><span class="line"><span class="keyword">WHEN</span> <span class="keyword">NOT</span> MATCHED <span class="keyword">THEN</span> </span><br><span class="line">   <span class="keyword">INSERT</span> (name, email)</span><br><span class="line">   <span class="keyword">VALUES</span>(l.name, l.email)</span><br><span class="line"><span class="keyword">WHEN</span> MATCHED <span class="keyword">AND</span> l.active <span class="operator">=</span> <span class="literal">false</span> <span class="keyword">THEN</span></span><br><span class="line">   <span class="keyword">DELETE</span></span><br><span class="line"><span class="keyword">WHEN</span> MATCHED <span class="keyword">AND</span> l.active <span class="operator">=</span> <span class="literal">true</span> <span class="keyword">THEN</span></span><br><span class="line">   <span class="keyword">UPDATE</span> <span class="keyword">SET</span> </span><br><span class="line">      name <span class="operator">=</span> l.name, </span><br><span class="line">      email <span class="operator">=</span> l.email;</span><br></pre></td></tr></table></figure><ul><li><code>MERGE</code>语句仅在 PostgreSQL 15+ 可用</li><li>早期版本使用<code>INSERT ... ON CONFLICT</code></li><li>成功后返回<code>MERGE total_count</code>，其中<code>total_count</code>是插入、更新或删除的行的总数</li><li><code>MERGE</code>可以在一个语句中执行 INSERT、UPDATE 和 DELETE</li><li>适用于表之间的数据同步</li><li>可以使用<code>DO NOTHING</code>忽略特定条件的行</li></ul><hr><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><h3 id="44-TRANSACTION"><a href="#44-TRANSACTION" class="headerlink" title="44. TRANSACTION"></a>44. TRANSACTION</h3><ul><li>数据库事务是由一个或多个操作组成的单个工作单元。PostgreSQL 事务是原子的、一致的、隔离的和持久的（ACID）</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 开始事务</span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="comment">-- 或</span></span><br><span class="line"><span class="keyword">BEGIN</span> TRANSACTION;</span><br><span class="line"><span class="comment">-- 或</span></span><br><span class="line"><span class="keyword">BEGIN</span> WORK;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 提交事务</span></span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br><span class="line"><span class="comment">-- 或</span></span><br><span class="line"><span class="keyword">COMMIT</span> TRANSACTION;</span><br><span class="line"><span class="comment">-- 或</span></span><br><span class="line"><span class="keyword">COMMIT</span> WORK;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 回滚事务</span></span><br><span class="line"><span class="keyword">ROLLBACK</span>;</span><br><span class="line"><span class="comment">-- 或</span></span><br><span class="line"><span class="keyword">ROLLBACK</span> TRANSACTION;</span><br><span class="line"><span class="comment">-- 或</span></span><br><span class="line"><span class="keyword">ROLLBACK</span> WORK;</span><br></pre></td></tr></table></figure><ul><li><strong>原子性 (Atomicity)</strong>: 事务以全有或全无的方式完成</li><li><strong>一致性 (Consistency)</strong>: 写入数据库的数据更改必须有效并遵循预定义的规则</li><li><strong>隔离性 (Isolation)</strong>: 事务完整性如何对其他事务可见</li><li><strong>持久性 (Durability)</strong>: 已提交的事务将永久存储在数据库中</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- accounts</span></span><br><span class="line"><span class="comment">-- | id | name  | balance  |</span></span><br><span class="line"><span class="comment">-- |----|-------|----------|</span></span><br><span class="line"><span class="comment">-- | 1  | Bob   | 10000.00 |</span></span><br><span class="line"><span class="comment">-- | 2  | Alice | 10000.00 |</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 银行转账示例：从 Bob 转账 1000 到 Alice</span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 从 Bob 账户扣款</span></span><br><span class="line"><span class="keyword">UPDATE</span> accounts </span><br><span class="line"><span class="keyword">SET</span> balance <span class="operator">=</span> balance <span class="operator">-</span> <span class="number">1000</span></span><br><span class="line"><span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 给 Alice 账户加款</span></span><br><span class="line"><span class="keyword">UPDATE</span> accounts</span><br><span class="line"><span class="keyword">SET</span> balance <span class="operator">=</span> balance <span class="operator">+</span> <span class="number">1000</span></span><br><span class="line"><span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 提交事务</span></span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看结果</span></span><br><span class="line"><span class="keyword">SELECT</span> id, name, balance <span class="keyword">FROM</span> accounts;</span><br><span class="line"><span class="comment">-- | id | name  | balance  |</span></span><br><span class="line"><span class="comment">-- |----|-------|----------|</span></span><br><span class="line"><span class="comment">-- | 1  | Bob   | 9000.00  |</span></span><br><span class="line"><span class="comment">-- | 2  | Alice | 11000.00 |</span></span><br></pre></td></tr></table></figure><ul><li>事务开始后，更改对其他会话不可见，直到提交</li><li><code>COMMIT</code>使更改持久化，<code>ROLLBACK</code>撤销更改</li><li>会话断开连接时，未提交的事务会自动回滚</li><li>建议保持事务尽可能短</li></ul><hr><h2 id="管理表"><a href="#管理表" class="headerlink" title="管理表"></a>管理表</h2><h3 id="45-CREATE-TABLE"><a href="#45-CREATE-TABLE" class="headerlink" title="45. CREATE TABLE"></a>45. CREATE TABLE</h3><ul><li>关系数据库由多个相关表组成。表格由行和列组成。要创建新表，请使用<code>CREATE TABLE</code>语句</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> [IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>] table_name (</span><br><span class="line">   column1 datatype(length) column_constraint,</span><br><span class="line">   column2 datatype(length) column_constraint,</span><br><span class="line">   column3 datatype(length) column_constraint,</span><br><span class="line">   table_constraints</span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>首先，在<code>CREATE TABLE</code>关键字后指定表的名称</li><li>其次，<code>IF NOT EXISTS</code>选项允许您仅当表不存在时才创建新表</li><li>第三，指定以逗号分隔的表列列表，包括列名、数据类型、长度和约束</li><li>最后，指定表约束，包括主键、外键和检查约束</li></ul><h4 id="约束类型"><a href="#约束类型" class="headerlink" title="约束类型"></a>约束类型</h4><ul><li><code>NOT NULL</code> - 确保列中的值不能为<code>NULL</code></li><li><code>UNIQUE</code> - 确保列的值在表中是唯一的</li><li><code>PRIMARY KEY</code> - 唯一标识表中的行，一个表只能有一个主键</li><li><code>CHECK</code> - 确保数据必须满足布尔表达式</li><li><code>FOREIGN KEY</code> - 确保列中的值存在于另一个表中</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建 accounts 表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> accounts (</span><br><span class="line">    user_id SERIAL <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    username <span class="type">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">UNIQUE</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    password <span class="type">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    email <span class="type">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">UNIQUE</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    created_on <span class="type">TIMESTAMP</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    last_login <span class="type">TIMESTAMP</span> </span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建 roles 表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> roles(</span><br><span class="line">   role_id SERIAL <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">   role_name <span class="type">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">UNIQUE</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建 account_roles 表（复合主键和外键）</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> account_roles (</span><br><span class="line">  user_id <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  role_id <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  grant_date <span class="type">TIMESTAMP</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (user_id, role_id),</span><br><span class="line">  <span class="keyword">FOREIGN</span> KEY (role_id) <span class="keyword">REFERENCES</span> roles (role_id),</span><br><span class="line">  <span class="keyword">FOREIGN</span> KEY (user_id) <span class="keyword">REFERENCES</span> accounts (user_id)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 使用 IF NOT EXISTS</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> products (</span><br><span class="line">    product_id SERIAL <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    product_name <span class="type">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    price <span class="type">DECIMAL</span>(<span class="number">10</span>, <span class="number">2</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">CHECK</span> (price <span class="operator">&gt;</span> <span class="number">0</span>),</span><br><span class="line">    stock <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 使用 CHECK 约束</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> employees (</span><br><span class="line">    employee_id SERIAL <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    age <span class="type">INT</span> <span class="keyword">CHECK</span> (age <span class="operator">&gt;=</span> <span class="number">18</span>),</span><br><span class="line">    salary <span class="type">DECIMAL</span>(<span class="number">10</span>, <span class="number">2</span>) <span class="keyword">CHECK</span> (salary <span class="operator">&gt;</span> <span class="number">0</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><ul><li>创建已存在的表会导致错误，使用<code>IF NOT EXISTS</code>可以避免</li><li><code>SERIAL</code>是自增整数，常用于主键</li><li>表约束（如复合主键）必须在列定义之后单独定义</li><li>外键引用的列必须是唯一的或主键</li><li>约束可以在创建表时定义，也可以后续使用<code>ALTER TABLE</code>添加</li></ul><hr><h3 id="46-SERIAL-自增列"><a href="#46-SERIAL-自增列" class="headerlink" title="46. SERIAL 自增列"></a>46. SERIAL 自增列</h3><ul><li>在 PostgreSQL 中，序列是一种特殊的数据库对象，它生成整数序列。序列通常用作表中的主键列。可以通过<code>SERIAL</code>伪类型创建自增列</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> table_name(</span><br><span class="line">    id SERIAL</span><br><span class="line">);</span><br></pre></td></tr></table></figure><ul><li><code>SERIAL</code>不是真正的数据类型，而是伪类型（语法糖）</li><li>序列生成器操作不是事务安全的，回滚不会回滚序列号</li><li>删除表或列时，关联的序列也会被删除</li></ul><hr><h3 id="47-ALTER-TABLE"><a href="#47-ALTER-TABLE" class="headerlink" title="47. ALTER TABLE"></a>47. ALTER TABLE</h3><ul><li>要更改现有表的结构，可以使用 PostgreSQL 的<code>ALTER TABLE</code>语句</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name action;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建示例表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> products (</span><br><span class="line">   product_id SERIAL <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">   name <span class="type">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">   price <span class="type">DECIMAL</span>(<span class="number">10</span>, <span class="number">2</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 添加列</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> products</span><br><span class="line"><span class="keyword">ADD</span> <span class="keyword">COLUMN</span> stock <span class="type">INT</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除列</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> products </span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">COLUMN</span> stock;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 重命名列</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> products </span><br><span class="line">RENAME <span class="keyword">COLUMN</span> name <span class="keyword">TO</span> product_name;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 添加列并设置默认值</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> products </span><br><span class="line"><span class="keyword">ADD</span> <span class="keyword">COLUMN</span> status <span class="type">VARCHAR</span>(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> products </span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">COLUMN</span> status <span class="keyword">SET</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;active&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 添加 CHECK 约束</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> products </span><br><span class="line"><span class="keyword">ADD</span> <span class="keyword">CHECK</span> (price <span class="operator">&gt;</span> <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 添加 UNIQUE 约束</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> products </span><br><span class="line"><span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> unique_product_name <span class="keyword">UNIQUE</span> (product_name);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 添加 NOT NULL 约束</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> products </span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">COLUMN</span> price <span class="keyword">SET</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 修改列类型</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> products </span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">COLUMN</span> product_name TYPE <span class="type">VARCHAR</span>(<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 重命名表</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> products </span><br><span class="line">RENAME <span class="keyword">TO</span> items;</span><br></pre></td></tr></table></figure><ul><li>删除列会永久删除该列及其数据</li><li>添加<code>NOT NULL</code>约束前，确保列中没有<code>NULL</code>值</li><li>修改列类型可能导致数据丢失或转换错误</li><li>添加约束可能失败，如果现有数据不满足约束条件</li><li>某些操作可能需要锁定整个表，影响并发访问</li><li>可以在一个<code>ALTER TABLE</code>语句中执行多个操作</li></ul><hr><h3 id="48-ADD-COLUMN"><a href="#48-ADD-COLUMN" class="headerlink" title="48. ADD COLUMN"></a>48. ADD COLUMN</h3><ul><li>要将新列添加到现有表，请使用<code>ALTER TABLE ADD COLUMN</code>语句</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 添加单列</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name</span><br><span class="line"><span class="keyword">ADD</span> <span class="keyword">COLUMN</span> column_name data_type <span class="keyword">constraint</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 添加多列</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name</span><br><span class="line"><span class="keyword">ADD</span> <span class="keyword">COLUMN</span> column_name1 data_type <span class="keyword">constraint</span>,</span><br><span class="line"><span class="keyword">ADD</span> <span class="keyword">COLUMN</span> column_name2 data_type <span class="keyword">constraint</span>,</span><br><span class="line">...</span><br><span class="line"><span class="keyword">ADD</span> <span class="keyword">COLUMN</span> column_namen data_type <span class="keyword">constraint</span>;</span><br></pre></td></tr></table></figure><ul><li>首先，在<code>ALTER TABLE</code>关键字后指定要添加新列的表名</li><li>其次，在<code>ADD COLUMN</code>关键字后指定新列的名称、数据类型和约束</li><li>新列会被附加到表的末尾</li></ul><hr><h3 id="49-DROP-COLUMN"><a href="#49-DROP-COLUMN" class="headerlink" title="49. DROP COLUMN"></a>49. DROP COLUMN</h3><ul><li>要删除表中的列，请在<code>ALTER TABLE</code>语句中使用<code>DROP COLUMN</code>子句</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 删除单列</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name </span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">COLUMN</span> column_name;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除列（如果存在）</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name </span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">COLUMN</span> IF <span class="keyword">EXISTS</span> column_name;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除列及其依赖对象</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name </span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">COLUMN</span> column_name CASCADE;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除多列</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">COLUMN</span> column_name1,</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">COLUMN</span> column_name2,</span><br><span class="line">...;</span><br></pre></td></tr></table></figure><ul><li>删除列时，PostgreSQL 会自动删除涉及该列的所有索引和约束</li><li>如果列被其他对象依赖，需要使用<code>CASCADE</code>选项</li><li><code>IF EXISTS</code>选项可以避免删除不存在的列时报错</li></ul><hr><h3 id="50-DROP-TABLE"><a href="#50-DROP-TABLE" class="headerlink" title="50. DROP TABLE"></a>50. DROP TABLE</h3><ul><li>要从数据库中删除表，请使用<code>DROP TABLE</code>语句</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 删除单个表</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> [IF <span class="keyword">EXISTS</span>] table_name </span><br><span class="line">[CASCADE <span class="operator">|</span> RESTRICT];</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除多个表</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> [IF <span class="keyword">EXISTS</span>] </span><br><span class="line">   table_name_1,</span><br><span class="line">   table_name_2,</span><br><span class="line">   ...</span><br><span class="line">[CASCADE <span class="operator">|</span> RESTRICT];</span><br></pre></td></tr></table></figure><ul><li>首先，在<code>DROP TABLE</code>关键字后指定要删除的表名</li><li>其次，使用<code>IF EXISTS</code>选项仅在表存在时才删除</li><li><code>CASCADE</code>选项允许删除表及其依赖对象</li><li><code>RESTRICT</code>选项在有依赖对象时拒绝删除（默认）</li></ul><hr><h3 id="51-TRUNCATE-TABLE"><a href="#51-TRUNCATE-TABLE" class="headerlink" title="51. TRUNCATE TABLE"></a>51. TRUNCATE TABLE</h3><ul><li>要快速删除表中的所有数据，请使用<code>TRUNCATE TABLE</code>语句。它比<code>DELETE</code>语句更快，因为不扫描表</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 截断单个表</span></span><br><span class="line"><span class="keyword">TRUNCATE</span> <span class="keyword">TABLE</span> table_name;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 重置自增序列</span></span><br><span class="line"><span class="keyword">TRUNCATE</span> <span class="keyword">TABLE</span> table_name </span><br><span class="line">RESTART <span class="keyword">IDENTITY</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 截断多个表</span></span><br><span class="line"><span class="keyword">TRUNCATE</span> <span class="keyword">TABLE</span> </span><br><span class="line">    table_name1, </span><br><span class="line">    table_name2,</span><br><span class="line">    ...;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 级联截断</span></span><br><span class="line"><span class="keyword">TRUNCATE</span> <span class="keyword">TABLE</span> table_name </span><br><span class="line">CASCADE;</span><br></pre></td></tr></table></figure><ul><li><code>TRUNCATE TABLE</code>删除所有数据而不扫描表，比<code>DELETE</code>快</li><li>立即回收存储空间，不需要后续的<code>VACUUM</code>操作</li><li><code>RESTART IDENTITY</code>重置自增列的序列值</li><li><code>CASCADE</code>截断引用该表的其他表</li></ul><hr><h3 id="52-临时表"><a href="#52-临时表" class="headerlink" title="52. 临时表"></a>52. 临时表</h3><ul><li>临时表是在数据库会话期间存在的短期表。PostgreSQL 在会话或事务结束时自动删除临时表</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建临时表</span></span><br><span class="line"><span class="keyword">CREATE</span> TEMPORARY <span class="keyword">TABLE</span> temp_table_name(</span><br><span class="line">   column_list</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 或使用 TEMP</span></span><br><span class="line"><span class="keyword">CREATE</span> TEMP <span class="keyword">TABLE</span> temp_table_name(</span><br><span class="line">   column_list</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除临时表</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> temp_table_name;</span><br></pre></td></tr></table></figure><ul><li><code>TEMP</code>和<code>TEMPORARY</code>关键字是等效的，可以互换使用</li><li>临时表仅对创建它的会话可见</li><li>会话结束时自动删除</li><li>不能在<code>CREATE TEMP TABLE</code>中指定模式</li></ul><hr><h2 id="PostgreSQL-约束"><a href="#PostgreSQL-约束" class="headerlink" title="PostgreSQL 约束"></a>PostgreSQL 约束</h2><h3 id="53-主键约束-PRIMARY-KEY"><a href="#53-主键约束-PRIMARY-KEY" class="headerlink" title="53. 主键约束 (PRIMARY KEY)"></a>53. 主键约束 (PRIMARY KEY)</h3><ul><li>主键是用于唯一标识表中的行的一列或一组列。主键约束是非空约束和 UNIQUE 约束的组合。一张表只能有一个主键</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建表时定义单列主键</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> table_name (</span><br><span class="line">    column_1 data_type <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    column_2 data_type,</span><br><span class="line">    ...</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建表时定义复合主键</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> table_name (</span><br><span class="line">    column_1 data_type,</span><br><span class="line">    column_2 data_type,</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (column_1, column_2)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 指定主键约束名称</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> table_name (</span><br><span class="line">    column_1 data_type,</span><br><span class="line">    column_2 data_type,</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> constraint_name <span class="keyword">PRIMARY</span> KEY (column_1, column_2)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 单列主键</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> po_headers (</span><br><span class="line">    po_no <span class="type">INTEGER</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    vendor_no <span class="type">INTEGER</span>,</span><br><span class="line">    description TEXT,</span><br><span class="line">    shipping_address TEXT</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 复合主键</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> po_items (</span><br><span class="line">    po_no <span class="type">INTEGER</span>,</span><br><span class="line">    item_no <span class="type">INTEGER</span>,</span><br><span class="line">    product_no <span class="type">INTEGER</span>,</span><br><span class="line">    qty <span class="type">INTEGER</span>,</span><br><span class="line">    net_price <span class="type">NUMERIC</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (po_no, item_no)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 使用 SERIAL 自增主键</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> customers (</span><br><span class="line">    customer_id SERIAL <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    email <span class="type">VARCHAR</span>(<span class="number">255</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 指定主键约束名称</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> orders (</span><br><span class="line">    order_id <span class="type">INTEGER</span>,</span><br><span class="line">    customer_id <span class="type">INTEGER</span>,</span><br><span class="line">    order_date <span class="type">DATE</span>,</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> orders_pk <span class="keyword">PRIMARY</span> KEY (order_id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><ul><li>一张表只能有一个主键</li><li>主键列不能包含<code>NULL</code>值，值必须唯一</li><li>PostgreSQL 自动为主键创建唯一的 B-tree 索引</li><li>默认主键约束名称为<code>table_name_pkey</code></li></ul><hr><h3 id="54-外键约束-FOREIGN-KEY"><a href="#54-外键约束-FOREIGN-KEY" class="headerlink" title="54. 外键约束 (FOREIGN KEY)"></a>54. 外键约束 (FOREIGN KEY)</h3><ul><li>外键是表中引用另一个表的主键的一列或一组列。外键约束有助于维护子表和父表之间数据的引用完整性</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">[<span class="keyword">CONSTRAINT</span> fk_name]</span><br><span class="line">   <span class="keyword">FOREIGN</span> KEY(fk_columns) </span><br><span class="line">   <span class="keyword">REFERENCES</span> parent_table(parent_key_columns)</span><br><span class="line">   [<span class="keyword">ON</span> <span class="keyword">DELETE</span> delete_action]</span><br><span class="line">   [<span class="keyword">ON</span> <span class="keyword">UPDATE</span> update_action]</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建父表：部门</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> departments(</span><br><span class="line">   department_id <span class="type">INT</span> GENERATED ALWAYS <span class="keyword">AS</span> <span class="keyword">IDENTITY</span>,</span><br><span class="line">   department_name <span class="type">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">   <span class="keyword">PRIMARY</span> KEY(department_id)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建子表：员工（NO ACTION）</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> employees(</span><br><span class="line">   employee_id <span class="type">INT</span> GENERATED ALWAYS <span class="keyword">AS</span> <span class="keyword">IDENTITY</span>,</span><br><span class="line">   employee_name <span class="type">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">   department_id <span class="type">INT</span>,</span><br><span class="line">   salary <span class="type">DECIMAL</span>(<span class="number">10</span>, <span class="number">2</span>),</span><br><span class="line">   <span class="keyword">PRIMARY</span> KEY(employee_id),</span><br><span class="line">   <span class="keyword">CONSTRAINT</span> fk_department</span><br><span class="line">      <span class="keyword">FOREIGN</span> KEY(department_id) </span><br><span class="line">      <span class="keyword">REFERENCES</span> departments(department_id)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 插入数据</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> departments(department_name)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="string">&#x27;Engineering&#x27;</span>), (<span class="string">&#x27;Sales&#x27;</span>), (<span class="string">&#x27;HR&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employees(employee_name, department_id, salary)</span><br><span class="line"><span class="keyword">VALUES</span></span><br><span class="line">   (<span class="string">&#x27;Alice&#x27;</span>, <span class="number">1</span>, <span class="number">75000</span>),</span><br><span class="line">   (<span class="string">&#x27;Bob&#x27;</span>, <span class="number">1</span>, <span class="number">68000</span>),</span><br><span class="line">   (<span class="string">&#x27;Charlie&#x27;</span>, <span class="number">2</span>, <span class="number">62000</span>),</span><br><span class="line">   (<span class="string">&#x27;David&#x27;</span>, <span class="number">3</span>, <span class="number">58000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 尝试删除有员工的部门</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> departments <span class="keyword">WHERE</span> department_id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="comment">-- ERROR: update or delete on table &quot;departments&quot; violates foreign key constraint</span></span><br><span class="line"><span class="comment">-- 阻止删除，因为有员工属于该部门</span></span><br></pre></td></tr></table></figure><ul><li>首先，在<code>CONSTRAINT</code>关键字后指定外键约束的名称（可选）</li><li>其次，在<code>FOREIGN KEY</code>关键字后指定一个或多个外键列</li><li>第三，在<code>REFERENCES</code>子句中指定父表和父键列</li><li>最后，指定删除和更新操作</li></ul><hr><h3 id="55-CHECK-约束"><a href="#55-CHECK-约束" class="headerlink" title="55. CHECK 约束"></a>55. CHECK 约束</h3><ul><li><code>CHECK</code>约束允许您指定列中的值是否必须满足特定要求。在插入或更新值之前，<code>CHECK</code>约束使用布尔表达式来验证值</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 列级 CHECK 约束</span></span><br><span class="line">column_name data_type <span class="keyword">CHECK</span> (expression)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 列级 CHECK 约束（指定名称）</span></span><br><span class="line">column_name data_type <span class="keyword">CONSTRAINT</span> constraint_name <span class="keyword">CHECK</span> (expression)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 表级 CHECK 约束</span></span><br><span class="line"><span class="keyword">CONSTRAINT</span> constraint_name <span class="keyword">CHECK</span> (expression)</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> students (</span><br><span class="line">    student_id SERIAL <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    age <span class="type">INT</span> <span class="keyword">CHECK</span> (age <span class="operator">&gt;=</span> <span class="number">18</span> <span class="keyword">AND</span> age <span class="operator">&lt;=</span> <span class="number">100</span>),</span><br><span class="line">    grade <span class="type">CHAR</span>(<span class="number">1</span>) <span class="keyword">CHECK</span> (grade <span class="keyword">IN</span> (<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;F&#x27;</span>)),</span><br><span class="line">    gpa <span class="type">DECIMAL</span>(<span class="number">3</span>, <span class="number">2</span>) <span class="keyword">CHECK</span> (gpa <span class="keyword">BETWEEN</span> <span class="number">0.0</span> <span class="keyword">AND</span> <span class="number">4.0</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 尝试插入无效数据</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> students (name, age, grade, gpa)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;Alice&#x27;</span>, <span class="number">15</span>, <span class="string">&#x27;A&#x27;</span>, <span class="number">3.8</span>);</span><br><span class="line"><span class="comment">-- ERROR: new row for relation &quot;students&quot; violates check constraint</span></span><br><span class="line"><span class="comment">-- age 必须 &gt;= 18</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 插入有效数据</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> students (name, age, grade, gpa)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;Bob&#x27;</span>, <span class="number">20</span>, <span class="string">&#x27;B&#x27;</span>, <span class="number">3.5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 指定约束名称</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> bank_accounts (</span><br><span class="line">    account_id SERIAL <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    account_number <span class="type">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    balance <span class="type">DECIMAL</span>(<span class="number">15</span>, <span class="number">2</span>) <span class="keyword">CONSTRAINT</span> non_negative_balance <span class="keyword">CHECK</span> (balance <span class="operator">&gt;=</span> <span class="number">0</span>),</span><br><span class="line">    account_type <span class="type">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">CONSTRAINT</span> valid_account_type </span><br><span class="line">        <span class="keyword">CHECK</span> (account_type <span class="keyword">IN</span> (<span class="string">&#x27;checking&#x27;</span>, <span class="string">&#x27;savings&#x27;</span>, <span class="string">&#x27;business&#x27;</span>))</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 表级 CHECK 约束（多列）</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> events (</span><br><span class="line">    event_id SERIAL <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    event_name <span class="type">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    start_date <span class="type">DATE</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    end_date <span class="type">DATE</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    min_participants <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    max_participants <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> valid_date_range </span><br><span class="line">        <span class="keyword">CHECK</span> (end_date <span class="operator">&gt;=</span> start_date),</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> valid_participant_range </span><br><span class="line">        <span class="keyword">CHECK</span> (max_participants <span class="operator">&gt;=</span> min_participants <span class="keyword">AND</span> min_participants <span class="operator">&gt;</span> <span class="number">0</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><ul><li>可以引用同一行的多个列</li><li>NULL 值通过 CHECK 约束（除非同时有 NOT NULL 约束）</li><li>默认约束名称格式：<code>&#123;table&#125;_&#123;column&#125;_check</code></li></ul><hr><h3 id="56-UNIQUE-约束"><a href="#56-UNIQUE-约束" class="headerlink" title="56. UNIQUE 约束"></a>56. UNIQUE 约束</h3><ul><li><code>UNIQUE</code>约束确保存储在一个列或一组列中的值在表中的所有行中是唯一的。当添加<code>UNIQUE</code>约束时，PostgreSQL 会自动在该列或列组上创建唯一索引</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 列级 UNIQUE 约束</span></span><br><span class="line">column_name data_type <span class="keyword">UNIQUE</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 表级 UNIQUE 约束</span></span><br><span class="line"><span class="keyword">UNIQUE</span> (column_name)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 多列 UNIQUE 约束</span></span><br><span class="line"><span class="keyword">UNIQUE</span> (column1, column2, ...)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 指定约束名称</span></span><br><span class="line"><span class="keyword">CONSTRAINT</span> constraint_name <span class="keyword">UNIQUE</span> (column_name)</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建带 UNIQUE 约束的表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> users (</span><br><span class="line">    user_id SERIAL <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    username <span class="type">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">UNIQUE</span>,</span><br><span class="line">    email <span class="type">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">UNIQUE</span>,</span><br><span class="line">    phone <span class="type">VARCHAR</span>(<span class="number">20</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 插入数据</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> users (username, email, phone)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;alice&#x27;</span>, <span class="string">&#x27;alice@example.com&#x27;</span>, <span class="string">&#x27;123-456-7890&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 尝试插入重复的 email</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> users (username, email, phone)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;bob&#x27;</span>, <span class="string">&#x27;alice@example.com&#x27;</span>, <span class="string">&#x27;098-765-4321&#x27;</span>);</span><br><span class="line"><span class="comment">-- ERROR: duplicate key value violates unique constraint &quot;users_email_key&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 表级 UNIQUE 约束</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> employees (</span><br><span class="line">    employee_id SERIAL <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    first_name <span class="type">VARCHAR</span>(<span class="number">50</span>),</span><br><span class="line">    last_name <span class="type">VARCHAR</span>(<span class="number">50</span>),</span><br><span class="line">    email <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    <span class="keyword">UNIQUE</span> (email)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 多列 UNIQUE 约束</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> course_enrollments (</span><br><span class="line">    enrollment_id SERIAL <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    student_id <span class="type">INT</span>,</span><br><span class="line">    course_id <span class="type">INT</span>,</span><br><span class="line">    semester <span class="type">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">    <span class="keyword">UNIQUE</span> (student_id, course_id, semester)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 指定约束名称</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> products (</span><br><span class="line">    product_id SERIAL <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    product_code <span class="type">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">    barcode <span class="type">VARCHAR</span>(<span class="number">50</span>),</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> unique_product_code <span class="keyword">UNIQUE</span> (product_code),</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> unique_barcode <span class="keyword">UNIQUE</span> (barcode)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><ul><li>PostgreSQL 自动为<code>UNIQUE</code>约束创建唯一索引</li><li><code>UNIQUE</code>约束允许多个<code>NULL</code>值</li><li>多列<code>UNIQUE</code>约束要求列组合唯一</li><li>一个表可以有多个<code>UNIQUE</code>约束</li></ul><hr><h3 id="57-NOT-NULL-约束"><a href="#57-NOT-NULL-约束" class="headerlink" title="57. NOT NULL 约束"></a>57. NOT NULL 约束</h3><ul><li><code>NOT NULL</code>约束确保列的值不为空。在数据库中，NULL 代表未知或信息缺失，与空字符串或数字零不同</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建表时声明 NOT NULL</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> table_name(</span><br><span class="line">   column_name data_type <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">   ...</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 为现有列添加 NOT NULL</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">COLUMN</span> column_name <span class="keyword">SET</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除 NOT NULL 约束</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">COLUMN</span> column_name <span class="keyword">DROP</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>;</span><br></pre></td></tr></table></figure><ul><li>默认情况下，列可以保存 NULL</li><li>使用<code>IS NULL</code>或<code>IS NOT NULL</code>检查 NULL 值</li><li>切勿使用<code>=</code>来比较 NULL，因为<code>NULL = NULL</code>返回 NULL</li><li>一列可以有多个约束，顺序不重要</li><li><code>NOT NULL</code>约束等同于<code>CHECK(column IS NOT NULL)</code></li></ul><hr><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="58-BOOLEAN-布尔类型"><a href="#58-BOOLEAN-布尔类型" class="headerlink" title="58. BOOLEAN 布尔类型"></a>58. BOOLEAN 布尔类型</h3><ul><li>PostgreSQL 支持单一的布尔数据类型：<code>BOOLEAN</code>，它可以具有三个值：<code>true</code>、<code>false</code>和<code>NULL</code>。PostgreSQL 使用一个字节存储布尔值，<code>BOOLEAN</code>可以简写为<code>BOOL</code></li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 定义布尔列</span></span><br><span class="line">column_name <span class="type">BOOLEAN</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 或使用简写</span></span><br><span class="line">column_name BOOL</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 带默认值</span></span><br><span class="line">column_name <span class="type">BOOLEAN</span> <span class="keyword">DEFAULT</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><ul><li>PostgreSQL 使用一个字节存储布尔值</li><li><code>BOOLEAN</code>可以简写为<code>BOOL</code></li><li>布尔列可以有三个值：<code>true</code>、<code>false</code>、<code>NULL</code></li><li>前导或尾随空格不影响布尔值</li><li>除<code>true</code>和<code>false</code>外的常量值必须用单引号引起来</li><li>可以直接使用布尔列名作为条件（隐式为 true）</li></ul><hr><h3 id="59-字符类型-CHAR、VARCHAR-和-TEXT"><a href="#59-字符类型-CHAR、VARCHAR-和-TEXT" class="headerlink" title="59. 字符类型: CHAR、VARCHAR 和 TEXT"></a>59. 字符类型: CHAR、VARCHAR 和 TEXT</h3><ul><li>PostgreSQL 提供三种主要字符类型：<code>CHARACTER(n)</code>或<code>CHAR(n)</code>、<code>CHARACTER VARYING(n)</code>或<code>VARCHAR(n)</code>、和<code>TEXT</code></li></ul><table><thead><tr><th>类型</th><th>描述</th></tr></thead><tbody><tr><td><code>CHAR(n)</code></td><td>固定长度，空白填充</td></tr><tr><td><code>VARCHAR(n)</code></td><td>可变长度，有长度限制</td></tr><tr><td><code>TEXT</code> 或 <code>VARCHAR</code></td><td>可变长度，无限制</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建带字符类型的表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> character_tests (</span><br><span class="line">    id SERIAL <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    x <span class="type">CHAR</span>(<span class="number">1</span>),</span><br><span class="line">    y <span class="type">VARCHAR</span>(<span class="number">10</span>),</span><br><span class="line">    z TEXT</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 插入数据</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> character_tests (x, y, z)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="string">&#x27;Y&#x27;</span>, <span class="string">&#x27;varchar(n)&#x27;</span>, <span class="string">&#x27;This is a very long text for the PostgreSQL text column&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 尝试插入超长字符串</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> character_tests (x, y, z)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="string">&#x27;Yes&#x27;</span>, <span class="string">&#x27;This is a test&#x27;</span>, <span class="string">&#x27;text&#x27;</span>);</span><br><span class="line"><span class="comment">-- ERROR: value too long for type character(1)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> character_tests (x, y, z)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="string">&#x27;Y&#x27;</span>, <span class="string">&#x27;This is a test for varchar&#x27;</span>, <span class="string">&#x27;text&#x27;</span>);</span><br><span class="line"><span class="comment">-- ERROR: value too long for type character varying(10)</span></span><br></pre></td></tr></table></figure><ul><li>三种字符类型之间没有性能差异</li><li><code>CHAR(n)</code>和<code>VARCHAR(n)</code>最多存储<code>n</code>个字符</li><li><code>TEXT</code>可以存储无限长度的字符串</li><li><code>VARCHAR</code>不带长度限制时等同于<code>TEXT</code></li><li>大多数情况下应使用<code>TEXT</code>或<code>VARCHAR</code></li><li>需要检查长度时使用<code>VARCHAR(n)</code></li><li><code>CHAR</code>不带长度限制时等同于<code>CHAR(1)</code></li></ul><hr><h3 id="60-NUMERIC-数值类型"><a href="#60-NUMERIC-数值类型" class="headerlink" title="60. NUMERIC 数值类型"></a>60. NUMERIC 数值类型</h3><ul><li><code>NUMERIC</code>类型可以存储具有很多位数的数字。通常用于需要精确性的数字，例如货币金额或数量</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 指定精度和小数位数</span></span><br><span class="line"><span class="type">NUMERIC</span>(<span class="keyword">precision</span>, scale)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 只指定精度（小数位数为0）</span></span><br><span class="line"><span class="type">NUMERIC</span>(<span class="keyword">precision</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 不指定精度和小数位数</span></span><br><span class="line"><span class="type">NUMERIC</span></span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建带 NUMERIC 列的表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> products (</span><br><span class="line">    id SERIAL <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    price <span class="type">NUMERIC</span>(<span class="number">5</span>, <span class="number">2</span>)  <span class="comment">-- 最多5位数字，其中2位小数</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 插入数据（自动四舍五入）</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> products (name, price)</span><br><span class="line"><span class="keyword">VALUES</span> </span><br><span class="line">    (<span class="string">&#x27;Phone&#x27;</span>, <span class="number">500.215</span>),   <span class="comment">-- 四舍五入为 500.22</span></span><br><span class="line">    (<span class="string">&#x27;Tablet&#x27;</span>, <span class="number">500.214</span>);  <span class="comment">-- 四舍五入为 500.21</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> products;</span><br><span class="line"><span class="comment">-- | id | name   | price  |</span></span><br><span class="line"><span class="comment">-- |----|--------|--------|</span></span><br><span class="line"><span class="comment">-- | 1  | Phone  | 500.22 |</span></span><br><span class="line"><span class="comment">-- | 2  | Tablet | 500.21 |</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 插入超出精度的值会报错</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> products (name, price)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="string">&#x27;Phone&#x27;</span>, <span class="number">123456.21</span>);</span><br><span class="line"><span class="comment">-- ERROR: numeric field overflow</span></span><br></pre></td></tr></table></figure><ul><li><code>NUMERIC</code>和<code>DECIMAL</code>是等效的，都是 SQL 标准</li><li>最多可保存小数点前 131,072 位和小数点后 16,383 位</li><li>小数位数大于声明时会四舍五入</li><li>精度超出声明时会报错</li><li><code>NUMERIC</code>计算通常比整数、浮点数慢</li><li>不需要精确性时不应使用<code>NUMERIC</code></li><li><code>NaN</code>表示”非数字”，大于所有数字</li></ul><hr><h3 id="61-INTEGER-整数类型"><a href="#61-INTEGER-整数类型" class="headerlink" title="61. INTEGER 整数类型"></a>61. INTEGER 整数类型</h3><ul><li>PostgreSQL 提供三种整数类型：<code>SMALLINT</code>、<code>INTEGER</code>和<code>BIGINT</code>，用于存储不同范围的整数</li></ul><table><thead><tr><th>名称</th><th>存储大小</th><th>最小值</th><th>最大值</th></tr></thead><tbody><tr><td><code>SMALLINT</code></td><td>2 字节</td><td>-32,768</td><td>+32,767</td></tr><tr><td><code>INTEGER</code></td><td>4 字节</td><td>-2,147,483,648</td><td>+2,147,483,647</td></tr><tr><td><code>BIGINT</code></td><td>8 字节</td><td>-9,223,372,036,854,775,808</td><td>+9,223,372,036,854,775,807</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- SMALLINT 示例（适用于小范围数值）</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> books (</span><br><span class="line">    book_id SERIAL <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    title <span class="type">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    pages <span class="type">SMALLINT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">CHECK</span> (pages <span class="operator">&gt;</span> <span class="number">0</span>),</span><br><span class="line">    <span class="keyword">year</span> <span class="type">SMALLINT</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> books (title, pages, <span class="keyword">year</span>)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;PostgreSQL Guide&#x27;</span>, <span class="number">350</span>, <span class="number">2024</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- INTEGER 示例（最常用）</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> cities (</span><br><span class="line">    city_id SERIAL <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    city_name <span class="type">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    population <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">CHECK</span> (population <span class="operator">&gt;=</span> <span class="number">0</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> cities (city_name, population)</span><br><span class="line"><span class="keyword">VALUES</span> </span><br><span class="line">    (<span class="string">&#x27;New York&#x27;</span>, <span class="number">8336817</span>),</span><br><span class="line">    (<span class="string">&#x27;Los Angeles&#x27;</span>, <span class="number">3979576</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- BIGINT 示例（大数值）</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> analytics (</span><br><span class="line">    id SERIAL <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    page_views <span class="type">BIGINT</span>,</span><br><span class="line">    user_id <span class="type">INT</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> analytics (page_views, user_id)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="number">9223372036854775000</span>, <span class="number">1001</span>);</span><br></pre></td></tr></table></figure><ul><li>PostgreSQL 不提供无符号整数类型</li><li><code>INTEGER</code>是最常用的整数类型，提供最佳平衡</li><li><code>INT</code>是<code>INTEGER</code>的同义词</li><li>超出范围的值会导致错误</li><li><code>BIGINT</code>消耗更多存储空间并降低性能，应谨慎使用</li><li>选择合适的类型可以节省存储空间并提高性能</li></ul><hr><h3 id="62-DATE-日期类型"><a href="#62-DATE-日期类型" class="headerlink" title="62. DATE 日期类型"></a>62. DATE 日期类型</h3><ul><li>PostgreSQL 使用<code>DATE</code>数据类型存储日期值。PostgreSQL 使用 4 个字节来存储日期值，范围为 4713 BC 至 5874897 AD</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 定义 DATE 列</span></span><br><span class="line">column_name <span class="type">DATE</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 使用当前日期作为默认值</span></span><br><span class="line">column_name <span class="type">DATE</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_DATE</span></span><br></pre></td></tr></table></figure><blockquote><p>PostgreSQL 使用<code>yyyy-mm-dd</code>格式存储和插入日期值，例如 2000-12-31</p></blockquote><h4 id="日期函数"><a href="#日期函数" class="headerlink" title="日期函数"></a>日期函数</h4><p><strong>1) 获取当前日期</strong></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 方式1：使用 NOW() 并转换为日期</span></span><br><span class="line"><span class="keyword">SELECT</span> NOW()::<span class="type">DATE</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 方式2：使用 CURRENT_DATE</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">CURRENT_DATE</span>;</span><br><span class="line"><span class="comment">-- 2024-11-22</span></span><br></pre></td></tr></table></figure><p><strong>2) 格式化日期输出</strong></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- dd/mm/yyyy 格式</span></span><br><span class="line"><span class="keyword">SELECT</span> TO_CHAR(NOW()::<span class="type">DATE</span>, <span class="string">&#x27;dd/mm/yyyy&#x27;</span>);</span><br><span class="line"><span class="comment">-- 22/11/2024</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- Mon dd, yyyy 格式</span></span><br><span class="line"><span class="keyword">SELECT</span> TO_CHAR(NOW()::<span class="type">DATE</span>, <span class="string">&#x27;Mon dd, yyyy&#x27;</span>);</span><br><span class="line"><span class="comment">-- Nov 22, 2024</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- yyyy-mm-dd 格式</span></span><br><span class="line"><span class="keyword">SELECT</span> TO_CHAR(NOW()::<span class="type">DATE</span>, <span class="string">&#x27;yyyy-mm-dd&#x27;</span>);</span><br><span class="line"><span class="comment">-- 2024-11-22</span></span><br></pre></td></tr></table></figure><p><strong>3) 计算日期间隔</strong></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 计算员工工作天数</span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    first_name,</span><br><span class="line">    last_name,</span><br><span class="line">    NOW() <span class="operator">-</span> hire_date <span class="keyword">AS</span> service_days</span><br><span class="line"><span class="keyword">FROM</span> employees;</span><br><span class="line"><span class="comment">-- | first_name | last_name | service_days            |</span></span><br><span class="line"><span class="comment">-- |------------|-----------|-------------------------|</span></span><br><span class="line"><span class="comment">-- | Shannon    | Freeman   | 7266 days 08:25:30      |</span></span><br><span class="line"><span class="comment">-- | Sheila     | Wells     | 7997 days 08:25:30      |</span></span><br></pre></td></tr></table></figure><p><strong>4) 计算年龄</strong></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 计算员工当前年龄</span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    employee_id,</span><br><span class="line">    first_name,</span><br><span class="line">    last_name,</span><br><span class="line">    AGE(birth_date) <span class="keyword">AS</span> age</span><br><span class="line"><span class="keyword">FROM</span> employees;</span><br><span class="line"><span class="comment">-- | employee_id | first_name | age                     |</span></span><br><span class="line"><span class="comment">-- |-------------|------------|-------------------------|</span></span><br><span class="line"><span class="comment">-- | 1           | Shannon    | 44 years 10 mons 22 days|</span></span><br><span class="line"><span class="comment">-- | 2           | Sheila     | 46 years 9 mons 17 days |</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 计算特定日期时的年龄</span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    first_name,</span><br><span class="line">    last_name,</span><br><span class="line">    AGE(<span class="string">&#x27;2015-01-01&#x27;</span>, birth_date) <span class="keyword">AS</span> age_in_2015</span><br><span class="line"><span class="keyword">FROM</span> employees;</span><br></pre></td></tr></table></figure><p><strong>5) 提取日期部分</strong></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 提取年、月、日</span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    employee_id,</span><br><span class="line">    first_name,</span><br><span class="line">    <span class="built_in">EXTRACT</span>(<span class="keyword">YEAR</span> <span class="keyword">FROM</span> birth_date) <span class="keyword">AS</span> <span class="keyword">year</span>,</span><br><span class="line">    <span class="built_in">EXTRACT</span>(<span class="keyword">MONTH</span> <span class="keyword">FROM</span> birth_date) <span class="keyword">AS</span> <span class="keyword">month</span>,</span><br><span class="line">    <span class="built_in">EXTRACT</span>(<span class="keyword">DAY</span> <span class="keyword">FROM</span> birth_date) <span class="keyword">AS</span> <span class="keyword">day</span></span><br><span class="line"><span class="keyword">FROM</span> employees;</span><br><span class="line"><span class="comment">-- | employee_id | first_name | year | month | day |</span></span><br><span class="line"><span class="comment">-- |-------------|------------|------|-------|-----|</span></span><br><span class="line"><span class="comment">-- | 1           | Shannon    | 1980 | 1     | 1   |</span></span><br><span class="line"><span class="comment">-- | 2           | Sheila     | 1978 | 2     | 5   |</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 提取星期几（0=周日，6=周六）</span></span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    <span class="built_in">EXTRACT</span>(DOW <span class="keyword">FROM</span> <span class="built_in">CURRENT_DATE</span>) <span class="keyword">AS</span> day_of_week;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 提取一年中的第几天</span></span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    <span class="built_in">EXTRACT</span>(DOY <span class="keyword">FROM</span> <span class="built_in">CURRENT_DATE</span>) <span class="keyword">AS</span> day_of_year;</span><br></pre></td></tr></table></figure><ul><li>PostgreSQL 使用<code>yyyy-mm-dd</code>格式存储日期</li><li>使用<code>CURRENT_DATE</code>获取当前日期</li><li>使用<code>TO_CHAR()</code>格式化日期输出</li><li>使用<code>AGE()</code>计算年龄</li><li>使用<code>EXTRACT()</code>提取日期部分</li><li>日期减法返回间隔（interval）类型</li></ul><hr><h3 id="63-TIMESTAMP-时间戳"><a href="#63-TIMESTAMP-时间戳" class="headerlink" title="63. TIMESTAMP 时间戳"></a>63. TIMESTAMP 时间戳</h3><ul><li>PostgreSQL 提供两种时间戳数据类型：<code>TIMESTAMP</code>（不带时区）和<code>TIMESTAMPTZ</code>（带时区）</li></ul><table><thead><tr><th>类型</th><th>描述</th><th>存储大小</th></tr></thead><tbody><tr><td><code>TIMESTAMP</code></td><td>不带时区的时间戳</td><td>8 字节</td></tr><tr><td><code>TIMESTAMPTZ</code></td><td>带时区的时间戳</td><td>8 字节</td></tr></tbody></table><ul><li><code>TIMESTAMP</code> - 存储日期和时间，不包含时区信息</li><li><code>TIMESTAMPTZ</code> - 时区感知的日期和时间，以 UTC 存储</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建带时间戳列的表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> timestamp_demo (</span><br><span class="line">    ts <span class="type">TIMESTAMP</span>, </span><br><span class="line">    tstz TIMESTAMPTZ</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 设置时区</span></span><br><span class="line"><span class="keyword">SET</span> timezone <span class="operator">=</span> <span class="string">&#x27;America/Los_Angeles&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看当前时区</span></span><br><span class="line"><span class="keyword">SHOW</span> TIMEZONE;</span><br><span class="line"><span class="comment">-- America/Los_Angeles</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 插入数据</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> timestamp_demo (ts, tstz)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="string">&#x27;2016-06-22 19:10:25-07&#x27;</span>, <span class="string">&#x27;2016-06-22 19:10:25-07&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询数据</span></span><br><span class="line"><span class="keyword">SELECT</span> ts, tstz <span class="keyword">FROM</span> timestamp_demo;</span><br><span class="line"><span class="comment">-- | ts                  | tstz                   |</span></span><br><span class="line"><span class="comment">-- |---------------------|------------------------|</span></span><br><span class="line"><span class="comment">-- | 2016-06-22 19:10:25 | 2016-06-22 19:10:25-07 |</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 修改时区</span></span><br><span class="line"><span class="keyword">SET</span> timezone <span class="operator">=</span> <span class="string">&#x27;America/New_York&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 再次查询</span></span><br><span class="line"><span class="keyword">SELECT</span> ts, tstz <span class="keyword">FROM</span> timestamp_demo;</span><br><span class="line"><span class="comment">-- | ts                  | tstz                   |</span></span><br><span class="line"><span class="comment">-- |---------------------|------------------------|</span></span><br><span class="line"><span class="comment">-- | 2016-06-22 19:10:25 | 2016-06-22 22:10:25-04 |</span></span><br><span class="line"><span class="comment">-- TIMESTAMP 不变，TIMESTAMPTZ 自动调整</span></span><br></pre></td></tr></table></figure><h4 id="时间戳函数"><a href="#时间戳函数" class="headerlink" title="时间戳函数"></a>时间戳函数</h4><p><strong>获取当前时间</strong></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 获取当前时间戳（带时区）</span></span><br><span class="line"><span class="keyword">SELECT</span> NOW();</span><br><span class="line"><span class="comment">-- 2024-11-22 20:44:52.134125-07</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 使用 CURRENT_TIMESTAMP</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">CURRENT_TIMESTAMP</span>;</span><br><span class="line"><span class="comment">-- 2024-11-22 20:44:52.134125-07</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 仅获取时间（带时区）</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">CURRENT_TIME</span>;</span><br><span class="line"><span class="comment">-- 20:49:04.566025-07</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 获取字符串格式的时间</span></span><br><span class="line"><span class="keyword">SELECT</span> TIMEOFDAY();</span><br><span class="line"><span class="comment">-- Wed Nov 22 20:51:12.632420 2024 PST</span></span><br></pre></td></tr></table></figure><p><strong>时区转换</strong></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查看当前时区</span></span><br><span class="line"><span class="keyword">SHOW</span> TIMEZONE;</span><br><span class="line"><span class="comment">-- America/Los_Angeles</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 转换到另一个时区</span></span><br><span class="line"><span class="keyword">SELECT</span> timezone(<span class="string">&#x27;America/New_York&#x27;</span>, <span class="string">&#x27;2016-06-01 00:00&#x27;</span>);</span><br><span class="line"><span class="comment">-- 2016-06-01 03:00:00</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 显式转换为 timestamptz</span></span><br><span class="line"><span class="keyword">SELECT</span> timezone(<span class="string">&#x27;America/New_York&#x27;</span>, <span class="string">&#x27;2016-06-01 00:00&#x27;</span>::TIMESTAMPTZ);</span><br></pre></td></tr></table></figure><ul><li><code>TIMESTAMPTZ</code>以 UTC 存储，查询时转换为当前时区</li><li>建议使用<code>TIMESTAMPTZ</code>存储时间戳数据</li><li><code>TIMESTAMP</code>不包含时区信息，更改时区不影响存储值</li><li>两种类型都使用 8 字节存储</li><li>PostgreSQL 不存储时区数据，只存储 UTC 时间</li></ul><hr><h3 id="64-INTERVAL-间隔类型"><a href="#64-INTERVAL-间隔类型" class="headerlink" title="64. INTERVAL 间隔类型"></a>64. INTERVAL 间隔类型</h3><ul><li>间隔数据类型允许您存储和操作一段时间（以年、月、日、小时、分钟、秒等为单位）</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="type">INTERVAL</span> <span class="string">&#x27;quantity unit [quantity unit...] [direction]&#x27;</span></span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 基本间隔值</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="type">INTERVAL</span> <span class="string">&#x27;2 months&#x27;</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="type">INTERVAL</span> <span class="string">&#x27;3 hours 20 minutes&#x27;</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="type">INTERVAL</span> <span class="string">&#x27;1 year 2 months 3 days&#x27;</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="type">INTERVAL</span> <span class="string">&#x27;2 weeks ago&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 使用间隔进行日期运算</span></span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    NOW(),</span><br><span class="line">    NOW() <span class="operator">-</span> <span class="type">INTERVAL</span> <span class="string">&#x27;1 year 3 hours 20 minutes&#x27;</span> <span class="keyword">AS</span> past_time;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 加减间隔</span></span><br><span class="line"><span class="keyword">SELECT</span> NOW() <span class="operator">+</span> <span class="type">INTERVAL</span> <span class="string">&#x27;1 day&#x27;</span>;</span><br><span class="line"><span class="keyword">SELECT</span> NOW() <span class="operator">-</span> <span class="type">INTERVAL</span> <span class="string">&#x27;2 hours&#x27;</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">CURRENT_DATE</span> <span class="operator">+</span> <span class="type">INTERVAL</span> <span class="string">&#x27;7 days&#x27;</span>;</span><br></pre></td></tr></table></figure><hr><h3 id="65-UUID-数据类型"><a href="#65-UUID-数据类型" class="headerlink" title="65. UUID 数据类型"></a>65. UUID 数据类型</h3><ul><li>UUID 代表通用唯一标识符（Universal Unique Identifier），是由算法生成的 128 位数值。UUID 值由连字符分隔的 32 位十六进制数字组成</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- UUID 格式示例</span></span><br><span class="line"><span class="number">40e6215</span>d<span class="operator">-</span>b5c6<span class="number">-4896</span><span class="number">-987</span>c<span class="operator">-</span>f30f3678f608</span><br><span class="line"><span class="number">6</span>ecd8c99<span class="number">-4036</span><span class="number">-403</span>d<span class="operator">-</span>bf84<span class="operator">-</span>cf8400f67836</span><br><span class="line"><span class="number">3</span>f333df6<span class="number">-90</span>a4<span class="number">-4</span>fda<span class="number">-8</span>dd3<span class="number">-9485</span>d27cee36</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 安装 uuid-ossp 模块</span></span><br><span class="line"><span class="keyword">CREATE</span> EXTENSION IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> &quot;uuid-ossp&quot;;</span><br></pre></td></tr></table></figure><h4 id="生成-UUID-值"><a href="#生成-UUID-值" class="headerlink" title="生成 UUID 值"></a>生成 UUID 值</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 基于 MAC 地址、时间戳和随机值生成</span></span><br><span class="line"><span class="keyword">SELECT</span> uuid_generate_v1();</span><br><span class="line"><span class="comment">-- 0e37df36-f698-11e6-8dd4-cb9ced3df976</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 基于随机数生成（推荐）</span></span><br><span class="line"><span class="keyword">SELECT</span> uuid_generate_v4();</span><br><span class="line"><span class="comment">-- a81bc81b-dead-4e5d-abff-90865d1e13b1</span></span><br><span class="line"></span><br><span class="line"><span class="operator">-</span> 创建带 UUID 主键的表</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> contacts (</span><br><span class="line">    contact_id UUID <span class="keyword">DEFAULT</span> uuid_generate_v4(),</span><br><span class="line">    first_name <span class="type">VARCHAR</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    last_name <span class="type">VARCHAR</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    email <span class="type">VARCHAR</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    phone <span class="type">VARCHAR</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (contact_id)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 插入数据（UUID 自动生成）</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> contacts (first_name, last_name, email, phone)</span><br><span class="line"><span class="keyword">VALUES</span></span><br><span class="line">    (<span class="string">&#x27;John&#x27;</span>, <span class="string">&#x27;Smith&#x27;</span>, <span class="string">&#x27;john.smith@example.com&#x27;</span>, <span class="string">&#x27;408-237-2345&#x27;</span>),</span><br><span class="line">    (<span class="string">&#x27;Jane&#x27;</span>, <span class="string">&#x27;Smith&#x27;</span>, <span class="string">&#x27;jane.smith@example.com&#x27;</span>, <span class="string">&#x27;408-237-2344&#x27;</span>),</span><br><span class="line">    (<span class="string">&#x27;Alex&#x27;</span>, <span class="string">&#x27;Smith&#x27;</span>, <span class="string">&#x27;alex.smith@example.com&#x27;</span>, <span class="string">&#x27;408-237-2343&#x27;</span>);</span><br></pre></td></tr></table></figure><ul><li>UUID 保证在分布式系统中的唯一性</li><li>UUID 比 SERIAL 占用更多存储空间（16 字节 vs 4&#x2F;8 字节）</li><li><code>uuid_generate_v4()</code> 基于随机数，最常用</li><li><code>uuid_generate_v1()</code> 基于 MAC 地址和时间戳</li><li>适合分布式系统、微服务架构</li><li>索引性能略低于整数类型</li></ul><hr><h3 id="66-UUID-v7"><a href="#66-UUID-v7" class="headerlink" title="66. UUID v7"></a>66. UUID v7</h3><ul><li>UUID v7 是最新的 UUID 标准（RFC 9562），基于时间戳生成，具有更好的排序性能和索引效率。</li></ul><blockquote><p><a href="https://github.com/dverite/postgres-uuidv7-sql">https://github.com/dverite/postgres-uuidv7-sql</a></p></blockquote><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 安装 pg_uuidv7 扩展（需要 PostgreSQL 13+）</span></span><br><span class="line"><span class="keyword">CREATE</span> EXTENSION IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> pg_uuidv7;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 生成 UUID v7</span></span><br><span class="line"><span class="keyword">SELECT</span> uuid_generate_v7();</span><br><span class="line"><span class="comment">-- 018c4e62-45a2-7000-8000-000000000001</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 批量生成</span></span><br><span class="line"><span class="keyword">SELECT</span> uuid_generate_v7() <span class="keyword">FROM</span> generate_series(<span class="number">1</span>, <span class="number">5</span>);</span><br></pre></td></tr></table></figure><ul><li>UUID v7 基于时间戳，提供更好的排序性能</li><li>索引效率优于 UUID v4（减少索引碎片）</li><li>适合需要时间排序的场景（日志、事件、交易）</li><li>需要安装 <code>pg_uuidv7</code> 扩展</li><li>仍然保证全局唯一性</li><li>比 SERIAL 更适合分布式系统</li></ul><hr><h3 id="67-JSON-数据类型"><a href="#67-JSON-数据类型" class="headerlink" title="67. JSON 数据类型"></a>67. JSON 数据类型</h3><ul><li>JSON（JavaScript Object Notation）是一种由键值对组成的开放标准格式。PostgreSQL 从 9.2 版本开始支持原生 JSON 数据类型</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 定义 JSON 列</span></span><br><span class="line">column_name JSON</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 或使用 JSONB（二进制 JSON，推荐）</span></span><br><span class="line">column_name JSONB</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建带 JSON 列的表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> orders (</span><br><span class="line">    id SERIAL <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    info JSON <span class="keyword">NOT</span> <span class="keyword">NULL</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 插入 JSON 数据</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> orders (info)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="string">&#x27;&#123;&quot;customer&quot;: &quot;John Doe&quot;, &quot;items&quot;: &#123;&quot;product&quot;: &quot;Beer&quot;, &quot;qty&quot;: 6&#125;&#125;&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> orders (info)</span><br><span class="line"><span class="keyword">VALUES</span></span><br><span class="line">    (<span class="string">&#x27;&#123;&quot;customer&quot;: &quot;Lily Bush&quot;, &quot;items&quot;: &#123;&quot;product&quot;: &quot;Diaper&quot;, &quot;qty&quot;: 24&#125;&#125;&#x27;</span>),</span><br><span class="line">    (<span class="string">&#x27;&#123;&quot;customer&quot;: &quot;Josh William&quot;, &quot;items&quot;: &#123;&quot;product&quot;: &quot;Toy Car&quot;, &quot;qty&quot;: 1&#125;&#125;&#x27;</span>),</span><br><span class="line">    (<span class="string">&#x27;&#123;&quot;customer&quot;: &quot;Mary Clark&quot;, &quot;items&quot;: &#123;&quot;product&quot;: &quot;Toy Train&quot;, &quot;qty&quot;: 2&#125;&#125;&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询 JSON 数据</span></span><br><span class="line"><span class="keyword">SELECT</span> info <span class="keyword">FROM</span> orders;</span><br></pre></td></tr></table></figure><h4 id="JSON-运算符"><a href="#JSON-运算符" class="headerlink" title="JSON 运算符"></a>JSON 运算符</h4><p><strong><code>-&gt;</code> 运算符：返回 JSON 对象字段</strong></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 获取客户信息（JSON 格式）</span></span><br><span class="line"><span class="keyword">SELECT</span> info <span class="operator">-</span><span class="operator">&gt;</span> <span class="string">&#x27;customer&#x27;</span> <span class="keyword">AS</span> customer</span><br><span class="line"><span class="keyword">FROM</span> orders;</span><br><span class="line"><span class="comment">-- | customer   |</span></span><br><span class="line"><span class="comment">-- |------------|</span></span><br><span class="line"><span class="comment">-- | &quot;John Doe&quot; |</span></span><br></pre></td></tr></table></figure><p><strong><code>-&gt;&gt;</code> 运算符：返回 JSON 对象字段（文本格式）</strong></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 获取客户信息（文本格式）</span></span><br><span class="line"><span class="keyword">SELECT</span> info <span class="operator">-</span><span class="operator">&gt;&gt;</span> <span class="string">&#x27;customer&#x27;</span> <span class="keyword">AS</span> customer</span><br><span class="line"><span class="keyword">FROM</span> orders;</span><br><span class="line"><span class="comment">-- | customer     |</span></span><br><span class="line"><span class="comment">-- |--------------|</span></span><br><span class="line"><span class="comment">-- | John Doe     |</span></span><br><span class="line"><span class="comment">-- | Lily Bush    |</span></span><br><span class="line"><span class="comment">-- | Josh William |</span></span><br></pre></td></tr></table></figure><h4 id="WHERE-子句中使用-JSON-运算符"><a href="#WHERE-子句中使用-JSON-运算符" class="headerlink" title="WHERE 子句中使用 JSON 运算符"></a>WHERE 子句中使用 JSON 运算符</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查找购买 Diaper 的客户</span></span><br><span class="line"><span class="keyword">SELECT</span> info <span class="operator">-</span><span class="operator">&gt;&gt;</span> <span class="string">&#x27;customer&#x27;</span> <span class="keyword">AS</span> customer</span><br><span class="line"><span class="keyword">FROM</span> orders</span><br><span class="line"><span class="keyword">WHERE</span> info <span class="operator">-</span><span class="operator">&gt;</span> <span class="string">&#x27;items&#x27;</span> <span class="operator">-</span><span class="operator">&gt;&gt;</span> <span class="string">&#x27;product&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;Diaper&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查找购买 2 个产品的客户</span></span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    info <span class="operator">-</span><span class="operator">&gt;&gt;</span> <span class="string">&#x27;customer&#x27;</span> <span class="keyword">AS</span> customer,</span><br><span class="line">    info <span class="operator">-</span><span class="operator">&gt;</span> <span class="string">&#x27;items&#x27;</span> <span class="operator">-</span><span class="operator">&gt;&gt;</span> <span class="string">&#x27;product&#x27;</span> <span class="keyword">AS</span> product</span><br><span class="line"><span class="keyword">FROM</span> orders</span><br><span class="line"><span class="keyword">WHERE</span> <span class="built_in">CAST</span>(info <span class="operator">-</span><span class="operator">&gt;</span> <span class="string">&#x27;items&#x27;</span> <span class="operator">-</span><span class="operator">&gt;&gt;</span> <span class="string">&#x27;qty&#x27;</span> <span class="keyword">AS</span> <span class="type">INTEGER</span>) <span class="operator">=</span> <span class="number">2</span>;</span><br></pre></td></tr></table></figure><h4 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 计算最小、最大、总和、平均数量</span></span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    <span class="built_in">MIN</span>(<span class="built_in">CAST</span>(info <span class="operator">-</span><span class="operator">&gt;</span> <span class="string">&#x27;items&#x27;</span> <span class="operator">-</span><span class="operator">&gt;&gt;</span> <span class="string">&#x27;qty&#x27;</span> <span class="keyword">AS</span> <span class="type">INTEGER</span>)) <span class="keyword">AS</span> min_qty,</span><br><span class="line">    <span class="built_in">MAX</span>(<span class="built_in">CAST</span>(info <span class="operator">-</span><span class="operator">&gt;</span> <span class="string">&#x27;items&#x27;</span> <span class="operator">-</span><span class="operator">&gt;&gt;</span> <span class="string">&#x27;qty&#x27;</span> <span class="keyword">AS</span> <span class="type">INTEGER</span>)) <span class="keyword">AS</span> max_qty,</span><br><span class="line">    <span class="built_in">SUM</span>(<span class="built_in">CAST</span>(info <span class="operator">-</span><span class="operator">&gt;</span> <span class="string">&#x27;items&#x27;</span> <span class="operator">-</span><span class="operator">&gt;&gt;</span> <span class="string">&#x27;qty&#x27;</span> <span class="keyword">AS</span> <span class="type">INTEGER</span>)) <span class="keyword">AS</span> total_qty,</span><br><span class="line">    <span class="built_in">AVG</span>(<span class="built_in">CAST</span>(info <span class="operator">-</span><span class="operator">&gt;</span> <span class="string">&#x27;items&#x27;</span> <span class="operator">-</span><span class="operator">&gt;&gt;</span> <span class="string">&#x27;qty&#x27;</span> <span class="keyword">AS</span> <span class="type">INTEGER</span>)) <span class="keyword">AS</span> avg_qty</span><br><span class="line"><span class="keyword">FROM</span> orders;</span><br><span class="line"><span class="comment">-- | min_qty | max_qty | total_qty | avg_qty |</span></span><br><span class="line"><span class="comment">-- |---------|---------|-----------|---------|</span></span><br><span class="line"><span class="comment">-- | 1       | 24      | 33        | 8.25    |</span></span><br></pre></td></tr></table></figure><h4 id="JSON-函数"><a href="#JSON-函数" class="headerlink" title="JSON 函数"></a>JSON 函数</h4><p><strong>json_each() - 展开 JSON 对象为键值对</strong></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> json_each(info)</span><br><span class="line"><span class="keyword">FROM</span> orders;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 获取文本格式的键值对</span></span><br><span class="line"><span class="keyword">SELECT</span> json_each_text(info)</span><br><span class="line"><span class="keyword">FROM</span> orders;</span><br></pre></td></tr></table></figure><p><strong>json_object_keys() - 获取 JSON 对象的键</strong></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 获取 items 对象的所有键</span></span><br><span class="line"><span class="keyword">SELECT</span> json_object_keys(info <span class="operator">-</span><span class="operator">&gt;</span> <span class="string">&#x27;items&#x27;</span>)</span><br><span class="line"><span class="keyword">FROM</span> orders;</span><br><span class="line"><span class="comment">-- | json_object_keys |</span></span><br><span class="line"><span class="comment">-- |------------------|</span></span><br><span class="line"><span class="comment">-- | product          |</span></span><br><span class="line"><span class="comment">-- | qty              |</span></span><br></pre></td></tr></table></figure><p><strong>json_typeof() - 获取 JSON 值的类型</strong></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 获取 items 的数据类型</span></span><br><span class="line"><span class="keyword">SELECT</span> json_typeof(info <span class="operator">-</span><span class="operator">&gt;</span> <span class="string">&#x27;items&#x27;</span>)</span><br><span class="line"><span class="keyword">FROM</span> orders;</span><br><span class="line"><span class="comment">-- | json_typeof |</span></span><br><span class="line"><span class="comment">-- |-------------|</span></span><br><span class="line"><span class="comment">-- | object      |</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 获取 qty 的数据类型</span></span><br><span class="line"><span class="keyword">SELECT</span> json_typeof(info <span class="operator">-</span><span class="operator">&gt;</span> <span class="string">&#x27;items&#x27;</span> <span class="operator">-</span><span class="operator">&gt;</span> <span class="string">&#x27;qty&#x27;</span>)</span><br><span class="line"><span class="keyword">FROM</span> orders;</span><br><span class="line"><span class="comment">-- | json_typeof |</span></span><br><span class="line"><span class="comment">-- |-------------|</span></span><br><span class="line"><span class="comment">-- | number      |</span></span><br></pre></td></tr></table></figure><h4 id="JSON-vs-JSONB"><a href="#JSON-vs-JSONB" class="headerlink" title="JSON vs JSONB"></a>JSON vs JSONB</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- JSON：存储文本格式，保留空格和顺序</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> data_json (</span><br><span class="line">    id SERIAL <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    data JSON</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- JSONB：存储二进制格式，支持索引，性能更好（推荐）</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> data_jsonb (</span><br><span class="line">    id SERIAL <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    data JSONB</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- JSONB 支持更多运算符</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="string">&#x27;&#123;&quot;a&quot;: 1, &quot;b&quot;: 2&#125;&#x27;</span>::JSONB @<span class="operator">&gt;</span> <span class="string">&#x27;&#123;&quot;a&quot;: 1&#125;&#x27;</span>::JSONB;  <span class="comment">-- true</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="string">&#x27;&#123;&quot;a&quot;: 1&#125;&#x27;</span>::JSONB <span class="operator">&lt;</span>@ <span class="string">&#x27;&#123;&quot;a&quot;: 1, &quot;b&quot;: 2&#125;&#x27;</span>::JSONB;  <span class="comment">-- true</span></span><br></pre></td></tr></table></figure><ul><li><code>JSON</code> 存储原始文本，<code>JSONB</code> 存储二进制格式（推荐使用 JSONB）</li><li><code>-&gt;</code> 返回 JSON 对象，<code>-&gt;&gt;</code> 返回文本</li><li>JSONB 支持索引，查询性能更好</li><li>使用 <code>CAST</code> 转换 JSON 值到其他数据类型</li><li>JSONB 支持更多运算符（<code>@&gt;</code>、<code>&lt;@</code>、<code>?</code> 等）</li></ul><hr><h2 id="条件表达式"><a href="#条件表达式" class="headerlink" title="条件表达式"></a>条件表达式</h2><h3 id="68-CASE-表达式"><a href="#68-CASE-表达式" class="headerlink" title="68. CASE 表达式"></a>68. CASE 表达式</h3><ul><li>PostgreSQL 的<code>CASE</code>表达式类似于其他编程语言中的 IF&#x2F;ELSE 语句，允许您向查询添加条件逻辑</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CASE</span> </span><br><span class="line">    <span class="keyword">WHEN</span> condition_1 <span class="keyword">THEN</span> result_1</span><br><span class="line">    <span class="keyword">WHEN</span> condition_2 <span class="keyword">THEN</span> result_2</span><br><span class="line">    [<span class="keyword">WHEN</span> ...]</span><br><span class="line">    [<span class="keyword">ELSE</span> else_result]</span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 员工薪资等级分类</span></span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    employee_id,</span><br><span class="line">    name,</span><br><span class="line">    salary,</span><br><span class="line">    <span class="keyword">CASE</span></span><br><span class="line">        <span class="keyword">WHEN</span> salary <span class="operator">&lt;</span> <span class="number">40000</span> <span class="keyword">THEN</span> <span class="string">&#x27;Low&#x27;</span></span><br><span class="line">        <span class="keyword">WHEN</span> salary <span class="operator">&gt;=</span> <span class="number">40000</span> <span class="keyword">AND</span> salary <span class="operator">&lt;</span> <span class="number">70000</span> <span class="keyword">THEN</span> <span class="string">&#x27;Medium&#x27;</span></span><br><span class="line">        <span class="keyword">WHEN</span> salary <span class="operator">&gt;=</span> <span class="number">70000</span> <span class="keyword">THEN</span> <span class="string">&#x27;High&#x27;</span></span><br><span class="line">    <span class="keyword">END</span> <span class="keyword">AS</span> salary_level</span><br><span class="line"><span class="keyword">FROM</span> employees;</span><br><span class="line"><span class="comment">-- | employee_id | name    | salary | salary_level |</span></span><br><span class="line"><span class="comment">-- |-------------|---------|--------|--------------|</span></span><br><span class="line"><span class="comment">-- | 1           | Alice   | 75000  | High         |</span></span><br><span class="line"><span class="comment">-- | 2           | Bob     | 55000  | Medium       |</span></span><br><span class="line"><span class="comment">-- | 3           | Charlie | 35000  | Low          |</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 订单状态描述</span></span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    order_id,</span><br><span class="line">    status,</span><br><span class="line">    <span class="keyword">CASE</span></span><br><span class="line">        <span class="keyword">WHEN</span> status <span class="operator">=</span> <span class="string">&#x27;pending&#x27;</span> <span class="keyword">THEN</span> <span class="string">&#x27;Order received&#x27;</span></span><br><span class="line">        <span class="keyword">WHEN</span> status <span class="operator">=</span> <span class="string">&#x27;processing&#x27;</span> <span class="keyword">THEN</span> <span class="string">&#x27;Being prepared&#x27;</span></span><br><span class="line">        <span class="keyword">WHEN</span> status <span class="operator">=</span> <span class="string">&#x27;shipped&#x27;</span> <span class="keyword">THEN</span> <span class="string">&#x27;On the way&#x27;</span></span><br><span class="line">        <span class="keyword">WHEN</span> status <span class="operator">=</span> <span class="string">&#x27;delivered&#x27;</span> <span class="keyword">THEN</span> <span class="string">&#x27;Completed&#x27;</span></span><br><span class="line">        <span class="keyword">ELSE</span> <span class="string">&#x27;Unknown status&#x27;</span></span><br><span class="line">    <span class="keyword">END</span> <span class="keyword">AS</span> status_description</span><br><span class="line"><span class="keyword">FROM</span> orders;</span><br></pre></td></tr></table></figure><ul><li><code>CASE</code>是一个表达式，可以在 SELECT、WHERE、GROUP BY、HAVING、ORDER BY 等子句中使用</li><li>通用 CASE 使用条件表达式，简单 CASE 使用值比较</li><li>如果省略<code>ELSE</code>子句，默认返回 NULL</li><li><code>CASE</code>表达式从上到下顺序评估，找到第一个匹配后立即返回</li><li>可以嵌套使用 CASE 表达式</li></ul><hr><h3 id="69-COALESCE-函数"><a href="#69-COALESCE-函数" class="headerlink" title="69. COALESCE 函数"></a>69. COALESCE 函数</h3><ul><li><code>COALESCE</code>函数返回参数列表中的第一个非空值。常用于处理和替换 NULL 值</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="built_in">COALESCE</span>(argument_1, argument_2, ...)</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 基本用法</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COALESCE</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="comment">-- 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COALESCE</span>(<span class="keyword">NULL</span>, <span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line"><span class="comment">-- 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COALESCE</span>(<span class="keyword">NULL</span>, <span class="keyword">NULL</span>, <span class="string">&#x27;default&#x27;</span>);</span><br><span class="line"><span class="comment">-- &#x27;default&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COALESCE</span>(<span class="keyword">NULL</span>, <span class="keyword">NULL</span>, <span class="keyword">NULL</span>);</span><br><span class="line"><span class="comment">-- NULL</span></span><br></pre></td></tr></table></figure><ul><li><code>COALESCE</code>函数与 SQL 标准的<code>NVL</code>（Oracle）或<code>IFNULL</code>（MySQL）功能相同</li><li>性能与<code>CASE</code>表达式相同，但更简洁</li><li>第一个非 NULL 参数后的参数不会被评估</li><li>所有参数应具有兼容的数据类型</li><li>比<code>CASE</code>表达式更易读和维护</li></ul><hr><h3 id="70-NULLIF-函数"><a href="#70-NULLIF-函数" class="headerlink" title="70. NULLIF 函数"></a>70. NULLIF 函数</h3><ul><li><code>NULLIF</code>函数比较两个参数，如果相等则返回 NULL，否则返回第一个参数。常用于处理特殊值和防止错误</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NULLIF</span>(argument_1, argument_2)</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 基本用法</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">NULLIF</span>(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="comment">-- NULL</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">NULLIF</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="comment">-- 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">NULLIF</span>(<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>);</span><br><span class="line"><span class="comment">-- &#x27;A&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">NULLIF</span>(<span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;&#x27;</span>);</span><br><span class="line"><span class="comment">-- NULL</span></span><br></pre></td></tr></table></figure><ul><li>常与 <code>COALESCE</code> 组合，防止除零和处理空字符串</li><li>比 <code>CASE</code> 简洁，但返回 NULL 需后续处理</li><li>两参数需类型兼容</li></ul><hr><h3 id="71-CAST-类型转换"><a href="#71-CAST-类型转换" class="headerlink" title="71. CAST 类型转换"></a>71. CAST 类型转换</h3><ul><li>PostgreSQL 的<code>CAST</code>运算符允许将一种数据类型的值转换为另一种数据类型</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- CAST 语法（SQL 标准）</span></span><br><span class="line"><span class="built_in">CAST</span>(expression <span class="keyword">AS</span> target_type)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- :: 运算符（PostgreSQL 特定）</span></span><br><span class="line">expression::target_type</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 字符串转整数</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">CAST</span>(<span class="string">&#x27;100&#x27;</span> <span class="keyword">AS</span> <span class="type">INTEGER</span>);</span><br><span class="line"><span class="comment">-- 100</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="string">&#x27;100&#x27;</span>::<span class="type">INTEGER</span>;</span><br><span class="line"><span class="comment">-- 100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 字符串转日期</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">CAST</span>(<span class="string">&#x27;2015-01-01&#x27;</span> <span class="keyword">AS</span> <span class="type">DATE</span>);</span><br><span class="line"><span class="comment">-- 2015-01-01</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="string">&#x27;01-OCT-2015&#x27;</span>::<span class="type">DATE</span>;</span><br><span class="line"><span class="comment">-- 2015-10-01</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 字符串转浮点数</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">CAST</span>(<span class="string">&#x27;10.2&#x27;</span> <span class="keyword">AS</span> <span class="type">DOUBLE PRECISION</span>);</span><br><span class="line"><span class="comment">-- 10.2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="string">&#x27;10.2&#x27;</span>::<span class="type">NUMERIC</span>;</span><br><span class="line"><span class="comment">-- 10.2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 字符串转布尔值</span></span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    <span class="built_in">CAST</span>(<span class="string">&#x27;true&#x27;</span> <span class="keyword">AS</span> <span class="type">BOOLEAN</span>),</span><br><span class="line">    <span class="built_in">CAST</span>(<span class="string">&#x27;false&#x27;</span> <span class="keyword">AS</span> <span class="type">BOOLEAN</span>),</span><br><span class="line">    <span class="built_in">CAST</span>(<span class="string">&#x27;T&#x27;</span> <span class="keyword">AS</span> <span class="type">BOOLEAN</span>),</span><br><span class="line">    <span class="built_in">CAST</span>(<span class="string">&#x27;F&#x27;</span> <span class="keyword">AS</span> <span class="type">BOOLEAN</span>);</span><br><span class="line"><span class="comment">-- | true | false | true | false |</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 字符串转时间戳</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="string">&#x27;2019-06-15 14:30:20&#x27;</span>::<span class="type">TIMESTAMP</span>;</span><br><span class="line"><span class="comment">-- 2019-06-15 14:30:20</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 字符串转间隔</span></span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    <span class="string">&#x27;15 minute&#x27;</span>::<span class="type">INTERVAL</span>,</span><br><span class="line">    <span class="string">&#x27;2 hour&#x27;</span>::<span class="type">INTERVAL</span>,</span><br><span class="line">    <span class="string">&#x27;1 day&#x27;</span>::<span class="type">INTERVAL</span>,</span><br><span class="line">    <span class="string">&#x27;2 week&#x27;</span>::<span class="type">INTERVAL</span>,</span><br><span class="line">    <span class="string">&#x27;3 month&#x27;</span>::<span class="type">INTERVAL</span>;</span><br></pre></td></tr></table></figure><ul><li><code>CAST</code>是 SQL 标准，<code>::</code>是 PostgreSQL 特定语法</li><li>无效转换会导致错误</li><li>转换可能导致精度损失（如 NUMERIC 转 INTEGER）</li><li>在列上使用<code>CAST</code>可能影响索引性能</li><li>使用<code>CASE</code>表达式处理可能失败的转换</li><li>某些类型需要特定格式（如<code>DOUBLE PRECISION</code>而非<code>DOUBLE</code>）</li></ul><hr><h2 id="处理-JSON"><a href="#处理-JSON" class="headerlink" title="处理 JSON"></a>处理 JSON</h2><h3 id="72-查询-JSON-数组"><a href="#72-查询-JSON-数组" class="headerlink" title="72. 查询 JSON 数组"></a>72. 查询 JSON 数组</h3><ul><li>PostgreSQL 提供多种函数将 JSON 列中嵌套的数组转换为表行，便于查询和处理</li><li><code>json_array_elements()</code> - 将 JSON 数组展开为行集</li><li><code>jsonb_array_elements()</code> - 将 JSONB 数组展开为行集（推荐）</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 展开简单数组</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> json_array_elements(<span class="string">&#x27;[1, 2, 3]&#x27;</span>) <span class="keyword">AS</span> elem;</span><br><span class="line"><span class="comment">-- | elem |</span></span><br><span class="line"><span class="comment">-- |------|</span></span><br><span class="line"><span class="comment">-- | 1    |</span></span><br><span class="line"><span class="comment">-- | 2    |</span></span><br><span class="line"><span class="comment">-- | 3    |</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 展开字符串数组</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> json_array_elements(<span class="string">&#x27;[&quot;apple&quot;, &quot;banana&quot;, &quot;orange&quot;]&#x27;</span>) <span class="keyword">AS</span> fruit;</span><br><span class="line"><span class="comment">-- | fruit    |</span></span><br><span class="line"><span class="comment">-- |----------|</span></span><br><span class="line"><span class="comment">-- | &quot;apple&quot;  |</span></span><br><span class="line"><span class="comment">-- | &quot;banana&quot; |</span></span><br><span class="line"><span class="comment">-- | &quot;orange&quot; |</span></span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建用户表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> users(</span><br><span class="line">    user_id SERIAL <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    username <span class="type">VARCHAR</span>(<span class="number">50</span>),</span><br><span class="line">    hobbies JSONB</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 插入数据</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> users(username, hobbies) </span><br><span class="line"><span class="keyword">VALUES</span> </span><br><span class="line">    (<span class="string">&#x27;alice&#x27;</span>, <span class="string">&#x27;[&quot;reading&quot;, &quot;coding&quot;, &quot;gaming&quot;]&#x27;</span>),</span><br><span class="line">    (<span class="string">&#x27;bob&#x27;</span>, <span class="string">&#x27;[&quot;music&quot;, &quot;sports&quot;]&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 展开爱好数组</span></span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    user_id,</span><br><span class="line">    username,</span><br><span class="line">    jsonb_array_elements_text(hobbies) <span class="keyword">AS</span> hobby</span><br><span class="line"><span class="keyword">FROM</span> users;</span><br><span class="line"><span class="comment">-- | user_id | username | hobby   |</span></span><br><span class="line"><span class="comment">-- |---------|----------|---------|</span></span><br><span class="line"><span class="comment">-- | 1       | alice    | reading |</span></span><br><span class="line"><span class="comment">-- | 1       | alice    | coding  |</span></span><br><span class="line"><span class="comment">-- | 1       | alice    | gaming  |</span></span><br><span class="line"><span class="comment">-- | 2       | bob      | music   |</span></span><br><span class="line"><span class="comment">-- | 2       | bob      | sports  |</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 使用 WITH ORDINALITY 获取位置</span></span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    username,</span><br><span class="line">    position,</span><br><span class="line">    hobby</span><br><span class="line"><span class="keyword">FROM</span> users,</span><br><span class="line">    jsonb_array_elements_text(hobbies) <span class="keyword">WITH</span> ORDINALITY <span class="keyword">AS</span> t(hobby, position);</span><br><span class="line"><span class="comment">-- | username | position | hobby   |</span></span><br><span class="line"><span class="comment">-- |----------|----------|---------|</span></span><br><span class="line"><span class="comment">-- | alice    | 1        | reading |</span></span><br><span class="line"><span class="comment">-- | alice    | 2        | coding  |</span></span><br><span class="line"><span class="comment">-- | alice    | 3        | gaming  |</span></span><br><span class="line"><span class="comment">-- | bob      | 1        | music   |</span></span><br><span class="line"><span class="comment">-- | bob      | 2        | sports  |</span></span><br></pre></td></tr></table></figure><ul><li><code>json_to_recordset()</code> - 将 JSON 对象数组转换为记录集</li><li><code>jsonb_to_recordset()</code> - 将 JSONB 对象数组转换为记录集</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 将 JSON 对象数组转换为记录集</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span></span><br><span class="line">    json_to_recordset(<span class="string">&#x27;[</span></span><br><span class="line"><span class="string">        &#123;&quot;id&quot;: 1, &quot;name&quot;: &quot;Alice&quot;, &quot;age&quot;: 28&#125;,</span></span><br><span class="line"><span class="string">        &#123;&quot;id&quot;: 2, &quot;name&quot;: &quot;Bob&quot;, &quot;age&quot;: 35&#125;</span></span><br><span class="line"><span class="string">    ]&#x27;</span>) <span class="keyword">AS</span> t(id <span class="type">INT</span>, name TEXT, age <span class="type">INT</span>);</span><br><span class="line"><span class="comment">-- | id | name  | age |</span></span><br><span class="line"><span class="comment">-- |----|-------|-----|</span></span><br><span class="line"><span class="comment">-- | 1  | Alice | 28  |</span></span><br><span class="line"><span class="comment">-- | 2  | Bob   | 35  |</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 使用 JSONB</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span></span><br><span class="line">    jsonb_to_recordset(<span class="string">&#x27;[</span></span><br><span class="line"><span class="string">        &#123;&quot;id&quot;: 1, &quot;name&quot;: &quot;Alice&quot;&#125;,</span></span><br><span class="line"><span class="string">        &#123;&quot;id&quot;: 2, &quot;name&quot;: &quot;Bob&quot;&#125;</span></span><br><span class="line"><span class="string">    ]&#x27;</span>) <span class="keyword">AS</span> t(id <span class="type">INT</span>, name TEXT);</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 订单表包含商品数组</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> orders (</span><br><span class="line">    order_id SERIAL <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    customer_name <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    items JSONB</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> orders (customer_name, items)</span><br><span class="line"><span class="keyword">VALUES</span> </span><br><span class="line">    (<span class="string">&#x27;John&#x27;</span>, <span class="string">&#x27;[</span></span><br><span class="line"><span class="string">        &#123;&quot;product&quot;: &quot;Laptop&quot;, &quot;price&quot;: 999.99, &quot;quantity&quot;: 1&#125;,</span></span><br><span class="line"><span class="string">        &#123;&quot;product&quot;: &quot;Mouse&quot;, &quot;price&quot;: 29.99, &quot;quantity&quot;: 2&#125;</span></span><br><span class="line"><span class="string">    ]&#x27;</span>),</span><br><span class="line">    (<span class="string">&#x27;Jane&#x27;</span>, <span class="string">&#x27;[</span></span><br><span class="line"><span class="string">        &#123;&quot;product&quot;: &quot;Monitor&quot;, &quot;price&quot;: 299.99, &quot;quantity&quot;: 1&#125;</span></span><br><span class="line"><span class="string">    ]&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询所有订单项</span></span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    o.order_id,</span><br><span class="line">    o.customer_name,</span><br><span class="line">    item<span class="operator">-</span><span class="operator">&gt;&gt;</span><span class="string">&#x27;product&#x27;</span> <span class="keyword">AS</span> product,</span><br><span class="line">    (item<span class="operator">-</span><span class="operator">&gt;&gt;</span><span class="string">&#x27;price&#x27;</span>)::<span class="type">NUMERIC</span> <span class="keyword">AS</span> price,</span><br><span class="line">    (item<span class="operator">-</span><span class="operator">&gt;&gt;</span><span class="string">&#x27;quantity&#x27;</span>)::<span class="type">INTEGER</span> <span class="keyword">AS</span> quantity</span><br><span class="line"><span class="keyword">FROM</span> orders o,</span><br><span class="line">    jsonb_array_elements(o.items) <span class="keyword">AS</span> item;</span><br><span class="line"><span class="comment">-- | order_id | customer_name | product | price  | quantity |</span></span><br><span class="line"><span class="comment">-- |----------|---------------|---------|--------|----------|</span></span><br><span class="line"><span class="comment">-- | 1        | John          | Laptop  | 999.99 | 1        |</span></span><br><span class="line"><span class="comment">-- | 1        | John          | Mouse   | 29.99  | 2        |</span></span><br><span class="line"><span class="comment">-- | 2        | Jane          | Monitor | 299.99 | 1        |</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 计算订单总额</span></span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    o.order_id,</span><br><span class="line">    o.customer_name,</span><br><span class="line">    <span class="built_in">SUM</span>((item<span class="operator">-</span><span class="operator">&gt;&gt;</span><span class="string">&#x27;price&#x27;</span>)::<span class="type">NUMERIC</span> <span class="operator">*</span> (item<span class="operator">-</span><span class="operator">&gt;&gt;</span><span class="string">&#x27;quantity&#x27;</span>)::<span class="type">INTEGER</span>) <span class="keyword">AS</span> total</span><br><span class="line"><span class="keyword">FROM</span> orders o,</span><br><span class="line">    jsonb_array_elements(o.items) <span class="keyword">AS</span> item</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> o.order_id, o.customer_name;</span><br><span class="line"><span class="comment">-- | order_id | customer_name | total   |</span></span><br><span class="line"><span class="comment">-- |----------|---------------|---------|</span></span><br><span class="line"><span class="comment">-- | 1        | John          | 1059.97 |</span></span><br><span class="line"><span class="comment">-- | 2        | Jane          | 299.99  |</span></span><br></pre></td></tr></table></figure><ul><li><code>jsonb_array_elements()</code>比<code>json_array_elements()</code>性能更好（推荐）</li><li>使用<code>WITH ORDINALITY</code>可以获取数组元素的位置（从 1 开始）</li><li><code>json_to_recordset()</code>需要显式指定列名和类型</li><li>展开数组会产生笛卡尔积，注意性能影响</li><li>使用<code>-&gt;</code>获取 JSON 对象，<code>-&gt;&gt;</code>获取文本值</li></ul><hr><h3 id="73-修改-JSON-数组"><a href="#73-修改-JSON-数组" class="headerlink" title="73. 修改 JSON 数组"></a>73. 修改 JSON 数组</h3><ul><li>PostgreSQL 提供多种方法来修改 JSON 列中嵌套的数组，包括添加、删除和更新元素</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 添加元素</span></span><br><span class="line"><span class="keyword">UPDATE</span> table_name</span><br><span class="line"><span class="keyword">SET</span> json_column <span class="operator">=</span> jsonb_set(</span><br><span class="line">    json_column, </span><br><span class="line">    <span class="string">&#x27;&#123;array_key&#125;&#x27;</span>,</span><br><span class="line">    json_column<span class="operator">-</span><span class="operator">&gt;</span><span class="string">&#x27;array_key&#x27;</span> <span class="operator">||</span> <span class="string">&#x27;[&quot;new_value&quot;]&#x27;</span>::jsonb</span><br><span class="line">)</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">condition</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除元素</span></span><br><span class="line"><span class="keyword">UPDATE</span> table_name</span><br><span class="line"><span class="keyword">SET</span> json_column <span class="operator">=</span> jsonb_set(</span><br><span class="line">    json_column,</span><br><span class="line">    <span class="string">&#x27;&#123;array_key&#125;&#x27;</span>,</span><br><span class="line">    (<span class="keyword">SELECT</span> jsonb_agg(elem)</span><br><span class="line">     <span class="keyword">FROM</span> jsonb_array_elements(json_column<span class="operator">-</span><span class="operator">&gt;</span><span class="string">&#x27;array_key&#x27;</span>) elem</span><br><span class="line">     <span class="keyword">WHERE</span> elem <span class="operator">!=</span> <span class="string">&#x27;&quot;value_to_remove&quot;&#x27;</span>::jsonb)</span><br><span class="line">)</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">condition</span>;</span><br></pre></td></tr></table></figure><h4 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建用户表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> users (</span><br><span class="line">    id SERIAL <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    username TEXT <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    meta_data JSONB <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#123;&#125;&#x27;</span>::jsonb</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 插入数据</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> users (username, meta_data)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;johndoe&#x27;</span>, <span class="string">&#x27;&#123;&quot;roles&quot;: [&quot;hr&quot;, &quot;marketing&quot;, &quot;sales&quot;]&#125;&#x27;</span>::jsonb);</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users;</span><br><span class="line"><span class="comment">-- | id | username | meta_data                               |</span></span><br><span class="line"><span class="comment">-- |----|----------|-----------------------------------------|</span></span><br><span class="line"><span class="comment">-- | 1  | johndoe  | &#123;&quot;roles&quot;: [&quot;hr&quot;, &quot;marketing&quot;, &quot;sales&quot;]&#125; |</span></span><br></pre></td></tr></table></figure><h4 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 删除特定角色</span></span><br><span class="line"><span class="keyword">UPDATE</span> users</span><br><span class="line"><span class="keyword">SET</span> meta_data <span class="operator">=</span> jsonb_set(</span><br><span class="line">    meta_data,</span><br><span class="line">    <span class="string">&#x27;&#123;roles&#125;&#x27;</span>,</span><br><span class="line">    (<span class="keyword">SELECT</span> jsonb_agg(elem)</span><br><span class="line">     <span class="keyword">FROM</span> jsonb_array_elements(meta_data<span class="operator">-</span><span class="operator">&gt;</span><span class="string">&#x27;roles&#x27;</span>) elem</span><br><span class="line">     <span class="keyword">WHERE</span> elem <span class="operator">!=</span> <span class="string">&#x27;&quot;marketing&quot;&#x27;</span>::jsonb)</span><br><span class="line">)</span><br><span class="line"><span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users;</span><br><span class="line"><span class="comment">-- | id | username | meta_data                           |</span></span><br><span class="line"><span class="comment">-- |----|----------|-------------------------------------|</span></span><br><span class="line"><span class="comment">-- | 1  | johndoe  | &#123;&quot;roles&quot;: [&quot;hr&quot;, &quot;sales&quot;, &quot;development&quot;]&#125; |</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除多个元素</span></span><br><span class="line"><span class="keyword">UPDATE</span> users</span><br><span class="line"><span class="keyword">SET</span> meta_data <span class="operator">=</span> jsonb_set(</span><br><span class="line">    meta_data,</span><br><span class="line">    <span class="string">&#x27;&#123;roles&#125;&#x27;</span>,</span><br><span class="line">    (<span class="keyword">SELECT</span> jsonb_agg(elem)</span><br><span class="line">     <span class="keyword">FROM</span> jsonb_array_elements(meta_data<span class="operator">-</span><span class="operator">&gt;</span><span class="string">&#x27;roles&#x27;</span>) elem</span><br><span class="line">     <span class="keyword">WHERE</span> elem <span class="keyword">NOT</span> <span class="keyword">IN</span> (<span class="string">&#x27;&quot;hr&quot;&#x27;</span>::jsonb, <span class="string">&#x27;&quot;sales&quot;&#x27;</span>::jsonb))</span><br><span class="line">)</span><br><span class="line"><span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><h4 id="替换特定位置的元素"><a href="#替换特定位置的元素" class="headerlink" title="替换特定位置的元素"></a>替换特定位置的元素</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 替换第一个元素（索引从0开始）</span></span><br><span class="line"><span class="keyword">UPDATE</span> users</span><br><span class="line"><span class="keyword">SET</span> meta_data <span class="operator">=</span> jsonb_set(</span><br><span class="line">    meta_data, </span><br><span class="line">    <span class="string">&#x27;&#123;roles,0&#125;&#x27;</span>, </span><br><span class="line">    <span class="string">&#x27;&quot;admin&quot;&#x27;</span>::jsonb</span><br><span class="line">)</span><br><span class="line"><span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 替换第二个元素</span></span><br><span class="line"><span class="keyword">UPDATE</span> users</span><br><span class="line"><span class="keyword">SET</span> meta_data <span class="operator">=</span> jsonb_set(</span><br><span class="line">    meta_data, </span><br><span class="line">    <span class="string">&#x27;&#123;roles,1&#125;&#x27;</span>, </span><br><span class="line">    <span class="string">&#x27;&quot;manager&quot;&#x27;</span>::jsonb</span><br><span class="line">)</span><br><span class="line"><span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><ul><li><code>||</code> 连接数组，<code>jsonb_agg()</code> 聚合行为数组</li><li><code>?</code> 检查键&#x2F;元素存在性，索引从 0 开始</li><li>修改替换整个数组（非原地），用 <code>COALESCE</code> 处理空值</li></ul><hr><h3 id="74-提取-JSON-数据"><a href="#74-提取-JSON-数据" class="headerlink" title="74. 提取 JSON 数据"></a>74. 提取 JSON 数据</h3><ul><li>PostgreSQL 提供<code>-&gt;</code>和<code>-&gt;&gt;</code>运算符从 JSON 数组中提取元素，或从 JSON 对象中提取键的值</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 从数组中提取元素（返回 JSONB）</span></span><br><span class="line">json_array <span class="operator">-</span><span class="operator">&gt;</span> n</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 从数组中提取元素（返回文本）</span></span><br><span class="line">json_array <span class="operator">-</span><span class="operator">&gt;&gt;</span> n</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 从对象中提取值（返回 JSONB）</span></span><br><span class="line">json_object <span class="operator">-</span><span class="operator">&gt;</span> <span class="string">&#x27;key&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 从对象中提取值（返回文本）</span></span><br><span class="line">json_object <span class="operator">-</span><span class="operator">&gt;&gt;</span> <span class="string">&#x27;key&#x27;</span></span><br></pre></td></tr></table></figure><ul><li><code>n</code> - 数组索引，从 0 开始，负数从末尾开始（-1 是最后一个）</li><li><code>-&gt;</code> 返回 JSONB 值</li><li><code>-&gt;&gt;</code> 返回文本字符串</li></ul><h4 id="从数组中提取元素"><a href="#从数组中提取元素" class="headerlink" title="从数组中提取元素"></a>从数组中提取元素</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建员工表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> employees(</span><br><span class="line">    id SERIAL <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    phones JSONB <span class="keyword">NOT</span> <span class="keyword">NULL</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 插入数据</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employees (name, phones)</span><br><span class="line"><span class="keyword">VALUES</span></span><br><span class="line">    (<span class="string">&#x27;John Doe&#x27;</span>, <span class="string">&#x27;[&quot;(408) 555-1111&quot;, &quot;(408) 555-2222&quot;, &quot;(408) 555-3333&quot;]&#x27;</span>),</span><br><span class="line">    (<span class="string">&#x27;Jane Smith&#x27;</span>, <span class="string">&#x27;[&quot;(408) 666-1111&quot;, &quot;(408) 666-2222&quot;, &quot;(408) 666-3333&quot;]&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 提取第一个电话（JSONB 格式）</span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    name,</span><br><span class="line">    phones <span class="operator">-</span><span class="operator">&gt;</span> <span class="number">0</span> <span class="keyword">AS</span> phone</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">&#x27;John Doe&#x27;</span>;</span><br><span class="line"><span class="comment">-- | name     | phone            |</span></span><br><span class="line"><span class="comment">-- |----------|------------------|</span></span><br><span class="line"><span class="comment">-- | John Doe | &quot;(408) 555-1111&quot; |</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 提取第一个电话（文本格式）</span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    name,</span><br><span class="line">    phones <span class="operator">-</span><span class="operator">&gt;&gt;</span> <span class="number">0</span> <span class="keyword">AS</span> phone</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">&#x27;John Doe&#x27;</span>;</span><br><span class="line"><span class="comment">-- | name     | phone          |</span></span><br><span class="line"><span class="comment">-- |----------|----------------|</span></span><br><span class="line"><span class="comment">-- | John Doe | (408) 555-1111 |</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 提取最后一个电话</span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    name,</span><br><span class="line">    phones <span class="operator">-</span><span class="operator">&gt;&gt;</span> <span class="number">-1</span> <span class="keyword">AS</span> phone</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">&#x27;Jane Smith&#x27;</span>;</span><br><span class="line"><span class="comment">-- | name       | phone          |</span></span><br><span class="line"><span class="comment">-- |------------|----------------|</span></span><br><span class="line"><span class="comment">-- | Jane Smith | (408) 666-3333 |</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 提取不存在的元素（返回 NULL）</span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    name,</span><br><span class="line">    phones <span class="operator">-</span><span class="operator">&gt;</span> <span class="number">5</span> <span class="keyword">AS</span> phone</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">&#x27;John Doe&#x27;</span>;</span><br><span class="line"><span class="comment">-- | name     | phone |</span></span><br><span class="line"><span class="comment">-- |----------|-------|</span></span><br><span class="line"><span class="comment">-- | John Doe | null  |</span></span><br></pre></td></tr></table></figure><h4 id="从对象中提取值"><a href="#从对象中提取值" class="headerlink" title="从对象中提取值"></a>从对象中提取值</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建请求表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> requests(</span><br><span class="line">    id SERIAL <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    employee_id <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    request_date <span class="type">DATE</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    data JSONB <span class="keyword">NOT</span> <span class="keyword">NULL</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 插入数据</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> requests (employee_id, request_date, data)</span><br><span class="line"><span class="keyword">VALUES</span></span><br><span class="line">    (<span class="number">1</span>, <span class="string">&#x27;2024-02-23&#x27;</span>, <span class="string">&#x27;&#123;</span></span><br><span class="line"><span class="string">        &quot;current_position&quot;: &quot;Software Engineer&quot;,</span></span><br><span class="line"><span class="string">        &quot;new_position&quot;: &quot;Senior Software Engineer&quot;,</span></span><br><span class="line"><span class="string">        &quot;effective_date&quot;: &quot;2024-03-01&quot;</span></span><br><span class="line"><span class="string">    &#125;&#x27;</span>),</span><br><span class="line">    (<span class="number">2</span>, <span class="string">&#x27;2024-02-24&#x27;</span>, <span class="string">&#x27;&#123;</span></span><br><span class="line"><span class="string">        &quot;current_position&quot;: &quot;Data Analyst&quot;,</span></span><br><span class="line"><span class="string">        &quot;new_position&quot;: &quot;Senior Data Analyst&quot;,</span></span><br><span class="line"><span class="string">        &quot;effective_date&quot;: &quot;2024-03-15&quot;</span></span><br><span class="line"><span class="string">    &#125;&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 提取当前职位（JSONB 格式）</span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    data <span class="operator">-</span><span class="operator">&gt;</span> <span class="string">&#x27;current_position&#x27;</span> <span class="keyword">AS</span> current_position</span><br><span class="line"><span class="keyword">FROM</span> requests</span><br><span class="line"><span class="keyword">WHERE</span> employee_id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="comment">-- | current_position    |</span></span><br><span class="line"><span class="comment">-- |---------------------|</span></span><br><span class="line"><span class="comment">-- | &quot;Software Engineer&quot; |</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 提取当前职位（文本格式）</span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    data <span class="operator">-</span><span class="operator">&gt;&gt;</span> <span class="string">&#x27;current_position&#x27;</span> <span class="keyword">AS</span> current_position</span><br><span class="line"><span class="keyword">FROM</span> requests</span><br><span class="line"><span class="keyword">WHERE</span> employee_id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="comment">-- | current_position  |</span></span><br><span class="line"><span class="comment">-- |-------------------|</span></span><br><span class="line"><span class="comment">-- | Software Engineer |</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 提取多个键</span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    employee_id,</span><br><span class="line">    data <span class="operator">-</span><span class="operator">&gt;&gt;</span> <span class="string">&#x27;current_position&#x27;</span> <span class="keyword">AS</span> current_position,</span><br><span class="line">    data <span class="operator">-</span><span class="operator">&gt;&gt;</span> <span class="string">&#x27;new_position&#x27;</span> <span class="keyword">AS</span> new_position,</span><br><span class="line">    data <span class="operator">-</span><span class="operator">&gt;&gt;</span> <span class="string">&#x27;effective_date&#x27;</span> <span class="keyword">AS</span> effective_date</span><br><span class="line"><span class="keyword">FROM</span> requests;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 提取不存在的键（返回 NULL）</span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    data <span class="operator">-</span><span class="operator">&gt;&gt;</span> <span class="string">&#x27;salary&#x27;</span> <span class="keyword">AS</span> salary</span><br><span class="line"><span class="keyword">FROM</span> requests</span><br><span class="line"><span class="keyword">WHERE</span> employee_id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="comment">-- | salary |</span></span><br><span class="line"><span class="comment">-- |--------|</span></span><br><span class="line"><span class="comment">-- | null   |</span></span><br></pre></td></tr></table></figure><h4 id="嵌套提取"><a href="#嵌套提取" class="headerlink" title="嵌套提取"></a>嵌套提取</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建用户表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> users(</span><br><span class="line">    user_id SERIAL <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    profile JSONB</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> users (profile)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;&#123;</span></span><br><span class="line"><span class="string">    &quot;name&quot;: &quot;Alice&quot;,</span></span><br><span class="line"><span class="string">    &quot;contact&quot;: &#123;</span></span><br><span class="line"><span class="string">        &quot;email&quot;: &quot;alice@example.com&quot;,</span></span><br><span class="line"><span class="string">        &quot;phone&quot;: &quot;123-456-7890&quot;</span></span><br><span class="line"><span class="string">    &#125;,</span></span><br><span class="line"><span class="string">    &quot;skills&quot;: [&quot;Python&quot;, &quot;SQL&quot;, &quot;Docker&quot;]</span></span><br><span class="line"><span class="string">&#125;&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 提取嵌套对象的值</span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    profile <span class="operator">-</span><span class="operator">&gt;</span> <span class="string">&#x27;contact&#x27;</span> <span class="operator">-</span><span class="operator">&gt;&gt;</span> <span class="string">&#x27;email&#x27;</span> <span class="keyword">AS</span> email</span><br><span class="line"><span class="keyword">FROM</span> users;</span><br><span class="line"><span class="comment">-- | email              |</span></span><br><span class="line"><span class="comment">-- |--------------------|</span></span><br><span class="line"><span class="comment">-- | alice@example.com  |</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 提取嵌套数组的元素</span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    profile <span class="operator">-</span><span class="operator">&gt;</span> <span class="string">&#x27;skills&#x27;</span> <span class="operator">-</span><span class="operator">&gt;&gt;</span> <span class="number">0</span> <span class="keyword">AS</span> first_skill</span><br><span class="line"><span class="keyword">FROM</span> users;</span><br><span class="line"><span class="comment">-- | first_skill |</span></span><br><span class="line"><span class="comment">-- |-------------|</span></span><br><span class="line"><span class="comment">-- | Python      |</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 链式提取</span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    profile <span class="operator">-</span><span class="operator">&gt;&gt;</span> <span class="string">&#x27;name&#x27;</span> <span class="keyword">AS</span> name,</span><br><span class="line">    profile <span class="operator">-</span><span class="operator">&gt;</span> <span class="string">&#x27;contact&#x27;</span> <span class="operator">-</span><span class="operator">&gt;&gt;</span> <span class="string">&#x27;email&#x27;</span> <span class="keyword">AS</span> email,</span><br><span class="line">    profile <span class="operator">-</span><span class="operator">&gt;</span> <span class="string">&#x27;contact&#x27;</span> <span class="operator">-</span><span class="operator">&gt;&gt;</span> <span class="string">&#x27;phone&#x27;</span> <span class="keyword">AS</span> phone,</span><br><span class="line">    profile <span class="operator">-</span><span class="operator">&gt;</span> <span class="string">&#x27;skills&#x27;</span> <span class="operator">-</span><span class="operator">&gt;&gt;</span> <span class="number">0</span> <span class="keyword">AS</span> primary_skill</span><br><span class="line"><span class="keyword">FROM</span> users;</span><br></pre></td></tr></table></figure><h4 id="在-WHERE-子句中使用"><a href="#在-WHERE-子句中使用" class="headerlink" title="在 WHERE 子句中使用"></a>在 WHERE 子句中使用</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查找特定职位的请求</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> requests</span><br><span class="line"><span class="keyword">WHERE</span> data <span class="operator">-</span><span class="operator">&gt;&gt;</span> <span class="string">&#x27;current_position&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;Software Engineer&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查找有效日期在特定范围内的请求</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> requests</span><br><span class="line"><span class="keyword">WHERE</span> (data <span class="operator">-</span><span class="operator">&gt;&gt;</span> <span class="string">&#x27;effective_date&#x27;</span>)::<span class="type">DATE</span> <span class="operator">&gt;=</span> <span class="string">&#x27;2024-03-01&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查找特定电话号码的员工</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> phones <span class="operator">-</span><span class="operator">&gt;&gt;</span> <span class="number">0</span> <span class="operator">=</span> <span class="string">&#x27;(408) 555-1111&#x27;</span>;</span><br></pre></td></tr></table></figure><ul><li><code>-&gt;</code> 返回 JSONB，<code>-&gt;&gt;</code> 返回文本</li><li>数组索引从 0 开始，负数从末尾开始（-1 为最后）</li><li>不存在的键&#x2F;索引返回 NULL，支持链式提取嵌套值</li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PostgreSQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GraphQL 学习笔记</title>
      <link href="/posts/69cd31bf.html"/>
      <url>/posts/69cd31bf.html</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p>参考文章: <a href="https://chenyitian.gitbooks.io/graphql/content/introduction.html">https://chenyitian.gitbooks.io/graphql/content/introduction.html</a><br>参考网站: <a href="https://www.howtographql.com/basics/0-introduction/">https://www.howtographql.com/basics/0-introduction/</a></p></blockquote><hr><h3 id="GraphQL基础"><a href="#GraphQL基础" class="headerlink" title="GraphQL基础"></a><code>GraphQL</code>基础</h3><h4 id="1-什么是GraphQL"><a href="#1-什么是GraphQL" class="headerlink" title="1. 什么是GraphQL"></a>1. 什么是<code>GraphQL</code></h4><p><code>GraphQL</code>是一种用于<code>API</code>的查询语言，同时也是一种运行在服务端的执行引擎。它使用基于类型系统的模式定义和验证查询结构（类型系统由你的数据定义）。<code>GraphQL</code>不依赖任何特定数据库或存储引擎，而是通过现有代码和数据来支持查询</p><h5 id="为什么使用GraphQL"><a href="#为什么使用GraphQL" class="headerlink" title="为什么使用GraphQL"></a><p style='font-size: 14px'>为什么使用<code>GraphQL</code></p></h5><ul><li>灵活的数据获取: 客户端可以请求确切的数据结构，避免数据过多或不足的问题</li><li>单一端点: 所有查询通过一个端点完成，简化了客户端与服务端的交互</li><li>强类型系统: 定义<code>API</code>时使用强类型，可以捕获开发错误，增强工具支持（如自动生成文档和代码）</li><li>实时更新: 通过订阅（<code>subscriptions</code>），支持实时数据更新，客户端在数据变化时能自动接收更新</li></ul><h5 id="与REST的对比"><a href="#与REST的对比" class="headerlink" title="与REST的对比"></a><p style='font-size: 14px'>与<code>REST</code>的对比</p></h5><p><strong>优点</strong></p><ul><li>避免多次请求: 例如获取用户和其文章，<code>REST</code>需要<code>GET /users/1</code>和<code>GET /users/1/posts</code>两次请求，<code>GraphQL</code>只需一次查询同时获取用户和文章数据</li><li>精确的数据获取: 客户端明确指定需要的字段 (如只要<code>name</code>和<code>age</code>，不要<code>email</code>)，避免多余数据传输，特别适用于移动端或弱网环境</li></ul><p><strong>缺点</strong></p><ul><li>查询解析复杂: 服务器需要解析客户端自定义的查询结构、验证类型、执行深度检查，比<code>REST</code>固定端点的处理逻辑更复杂</li><li>缓存困难: <code>REST</code>使用<code>URL</code>作为缓存键 (如<code>GET /users/1</code>)，而<code>GraphQL</code>所有请求都是<code>POST /graphql</code>，查询内容在请求体中，无法利用标准<code>HTTP</code>缓存，需要使用 Apollo Client 等工具自行实现缓存策略</li><li>学习曲线: 需要掌握 Schema 设计、类型系统、Resolver 实现、N+1 查询问题等新概念，比<code>REST</code>的学习成本更高</li></ul><hr><h4 id="2-字段Fields"><a href="#2-字段Fields" class="headerlink" title="2. 字段Fields"></a>2. 字段<code>Fields</code></h4><p>在<code>GraphQL</code>中，字段 (<code>fields</code>) 是定义在类型 (<code>type</code>) 上的属性，表示类型包含的数据内容。字段有以下特点</p><ul><li>每个字段都有名称和返回类型，类型可以是标量（如<code>String</code>、<code>Int</code>）、对象、枚举、列表等</li><li>字段可以接受参数，用于传递附加信息或过滤数据</li></ul><h5 id="字段的基本定义"><a href="#字段的基本定义" class="headerlink" title="字段的基本定义"></a><p style='font-size: 14px'>字段的基本定义</p></h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type User &#123;</span><br><span class="line">  id: ID!</span><br><span class="line">  name: String!</span><br><span class="line">  age: Int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Query &#123;</span><br><span class="line">  user(id: ID!): User</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>User</code>类型: 定义用户数据结构，包含<code>id</code>、<code>name</code>、<code>age</code>三个字段，其中<code>!</code>表示字段为必需（非空）</li><li><code>Query</code>类型: 定义查询操作<code>user</code>，通过必需参数<code>id</code>查询并返回对应的<code>User</code>对象</li></ul><h5 id="客户端查询示例"><a href="#客户端查询示例" class="headerlink" title="客户端查询示例"></a><p style='font-size: 14px'>客户端查询示例</p></h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">query &#123;</span><br><span class="line">  user(id: &quot;1&quot;) &#123;</span><br><span class="line">    id</span><br><span class="line">    name</span><br><span class="line">    age</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>客户端传入参数<code>id: &quot;1&quot;</code>，请求该用户的<code>id</code>、<code>name</code>和<code>age</code>字段</li><li>服务器返回对应用户的数据</li></ul><h5 id="什么是Schema"><a href="#什么是Schema" class="headerlink" title="什么是Schema"></a><p style='font-size: 14px'>什么是<code>Schema</code></p></h5><ul><li><code>Schema</code>是<code>GraphQL</code>的核心概念，用于描述<code>API</code>的结构。它定义了客户端可以查询的所有类型和操作</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 定义用户类型</span><br><span class="line">type User &#123;</span><br><span class="line">  id: ID!</span><br><span class="line">  name: String!</span><br><span class="line">  age: Int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 定义查询操作</span><br><span class="line">type Query &#123;</span><br><span class="line">  user(id: ID!): User</span><br><span class="line">  users: [User]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 定义变更操作</span><br><span class="line">type Mutation &#123;</span><br><span class="line">  createUser(name: String!, age: Int!): User</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># Schema 将所有类型组合起来</span><br><span class="line">schema &#123;</span><br><span class="line">  query: Query</span><br><span class="line">  mutation: Mutation</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>Schema</code>的组成部分<ul><li>类型定义<code>Type</code>: 定义数据结构，如<code>User</code>类型包含<code>id</code>、<code>name</code>、<code>age</code>字段</li><li>根类型<code>Root Types</code>: <code>Query</code>(查询)、<code>Mutation</code>(变更)、<code>Subscription</code>(订阅)</li><li><code>schema</code>声明: 指定哪些类型作为入口点（通常可以省略，默认使用<code>Query</code>、<code>Mutation</code>、<code>Subscription</code>）</li></ul></li></ul><h5 id="解析器Resolver"><a href="#解析器Resolver" class="headerlink" title="解析器Resolver"></a><p style='font-size: 14px'>解析器<code>Resolver</code></p></h5><ul><li>解析器定义了如何获取<code>Schema</code>中每个字段的实际数据。当客户端请求某个字段时，<code>GraphQL</code>会调用对应的解析器</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 模拟数据源（实际项目中通常来自数据库）</span></span><br><span class="line"><span class="keyword">const</span> users = [</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="string">&#x27;1&#x27;</span>, <span class="attr">name</span>: <span class="string">&#x27;Alice&#x27;</span>, <span class="attr">age</span>: <span class="number">30</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="string">&#x27;2&#x27;</span>, <span class="attr">name</span>: <span class="string">&#x27;Bob&#x27;</span>, <span class="attr">age</span>: <span class="number">25</span> &#125;,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义解析器</span></span><br><span class="line"><span class="keyword">const</span> resolvers = &#123;</span><br><span class="line">  <span class="title class_">Query</span>: &#123;</span><br><span class="line">    <span class="attr">user</span>: <span class="function">(<span class="params">parent, args, context, info</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> users.<span class="title function_">find</span>(<span class="function"><span class="params">user</span> =&gt;</span> user.<span class="property">id</span> === args.<span class="property">id</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">users</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> users;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>解析器函数接收 4 个参数<ul><li><code>parent</code>: 上一级解析器的返回值（嵌套查询时使用）</li><li><code>args</code>: 客户端传入的参数对象（如<code>&#123; id: &quot;1&quot; &#125;</code>）</li><li><code>context</code>: 所有解析器共享的上下文对象（如数据库连接、用户认证信息）</li><li><code>info</code>: 当前查询的元数据信息（字段名、路径等）</li></ul></li></ul><hr><h4 id="3-参数Arguments"><a href="#3-参数Arguments" class="headerlink" title="3. 参数Arguments"></a>3. 参数<code>Arguments</code></h4><ul><li>在<code>GraphQL</code>中，参数 (<code>Arguments</code>) 用于向字段或操作（如查询<code>Query</code>和变更<code>Mutation</code>）传递输入数据。参数允许客户端在请求中提供额外信息，用于筛选、过滤或指定要操作的数据</li></ul><h5 id="参数的定义"><a href="#参数的定义" class="headerlink" title="参数的定义"></a><p style='font-size: 14px'>参数的定义</p></h5><ul><li>参数可以定义在<code>GraphQL schema</code>中的字段上，分为必需参数（使用<code>!</code>符号）和可选参数（无<code>!</code>符号）</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type User &#123;</span><br><span class="line">  id: ID!</span><br><span class="line">  name: String!</span><br><span class="line">  age: Int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Query &#123;</span><br><span class="line">  user(id: ID!): User</span><br><span class="line">  users(age: Int): [User]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>代码说明<ul><li><code>user(id: ID!)</code>: <code>id</code>是必需参数，必须提供才能查询</li><li><code>users(age: Int)</code>: <code>age</code>是可选参数，可以用于筛选特定年龄的用户</li><li><code>[User]</code>: 方括号表示返回值是用户列表</li></ul></li></ul><h5 id="解析器中的参数"><a href="#解析器中的参数" class="headerlink" title="解析器中的参数"></a><p style='font-size: 14px'>解析器中的参数</p></h5><ul><li>在解析器 (<code>Resolver</code>) 中，参数通过<code>args</code>对象传递，可以使用这些参数来筛选或操作数据</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> resolvers = &#123;</span><br><span class="line">  <span class="title class_">Query</span>: &#123;</span><br><span class="line">    <span class="attr">user</span>: <span class="function">(<span class="params">parent, args, context, info</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">getUserById</span>(args.<span class="property">id</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">users</span>: <span class="function">(<span class="params">parent, args, context, info</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (args.<span class="property">age</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">getUsersByAge</span>(args.<span class="property">age</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">getAllUsers</span>();</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>参数使用说明<ul><li><code>args.id</code> &#x2F; <code>args.age</code>: 客户端请求中传递的参数</li><li><code>user</code>查询: 通过<code>id</code>获取单个用户</li><li><code>users</code>查询: 根据<code>age</code>筛选用户列表，未提供<code>age</code>时返回所有用户</li></ul></li></ul><h5 id="客户端查询"><a href="#客户端查询" class="headerlink" title="客户端查询"></a><p style='font-size: 14px'>客户端查询</p></h5><ul><li>客户端可以通过查询请求传递参数</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">query &#123;</span><br><span class="line">  user(id: &quot;1&quot;) &#123;</span><br><span class="line">    id</span><br><span class="line">    name</span><br><span class="line">    age</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  users(age: 30) &#123;</span><br><span class="line">    id</span><br><span class="line">    name</span><br><span class="line">    age</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>查询说明<ul><li><code>user(id: &quot;1&quot;)</code>: 请求<code>id</code>为<code>&quot;1&quot;</code>的单个用户</li><li><code>users(age: 30)</code>: 请求所有<code>age</code>为<code>30</code>的用户列表</li></ul></li></ul><h5 id="Mutation中的参数"><a href="#Mutation中的参数" class="headerlink" title="Mutation中的参数"></a><p style='font-size: 14px'><code>Mutation</code>中的参数</p></h5><ul><li><p>参数在变更操作中用于提供执行所需的输入数据（如创建用户）</p></li><li><p>示例代码（按执行顺序: Schema -&gt; Resolver -&gt; 客户端请求）</p></li></ul><figure class="highlight text"><table><tr><td class="code"><pre><span class="line"># Schema -----------------</span><br><span class="line">type Mutation &#123;</span><br><span class="line">  createUser(name: String!, age: Int): User</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type User &#123;</span><br><span class="line">  id: ID!</span><br><span class="line">  name: String!</span><br><span class="line">  age: Int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># Resolver (JavaScript) ---</span><br><span class="line">const resolvers = &#123;</span><br><span class="line">  Mutation: &#123;</span><br><span class="line">    createUser: (parent, args, context, info) =&gt; &#123;</span><br><span class="line">      const newUser = &#123;</span><br><span class="line">        id: generateUniqueId(),</span><br><span class="line">        name: args.name,</span><br><span class="line">        age: args.age,</span><br><span class="line">      &#125;;</span><br><span class="line">      saveUserToDatabase(newUser);</span><br><span class="line">      return newUser;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"># Client Request ----------</span><br><span class="line">mutation &#123;</span><br><span class="line">  createUser(name: &quot;Alice&quot;, age: 30) &#123;</span><br><span class="line">    id</span><br><span class="line">    name</span><br><span class="line">    age</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>执行流程说明<ul><li>客户端传递<code>name</code>和可选<code>age</code>参数到<code>createUser</code></li><li>解析器生成包含唯一<code>id</code>的新用户对象</li><li>保存用户数据到持久化存储</li><li>返回新增用户的完整数据（<code>id</code>、<code>name</code>、<code>age</code>）</li></ul></li></ul><hr><h3 id="GraphQL核心功能"><a href="#GraphQL核心功能" class="headerlink" title="GraphQL核心功能"></a><code>GraphQL</code>核心功能</h3><h4 id="4-别名Aliases"><a href="#4-别名Aliases" class="headerlink" title="4. 别名Aliases"></a>4. 别名<code>Aliases</code></h4><ul><li><p>别名 (<code>Aliases</code>) 用于在响应中重命名字段，解决同字段多次请求的冲突并调整返回结构</p></li><li><p>使用场景</p><ul><li>避免命名冲突: 多次查询同一字段但参数不同</li><li>自定义响应结构: 让返回键名更贴近业务语义</li></ul></li></ul><h5 id="避免命名冲突"><a href="#避免命名冲突" class="headerlink" title="避免命名冲突"></a><p style='font-size: 14px'>避免命名冲突</p></h5><ul><li>为每次对同一字段的不同参数请求添加不同别名，避免响应中键名重复</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">query &#123;</span><br><span class="line">  user1: user(id: &quot;1&quot;) &#123;</span><br><span class="line">    id</span><br><span class="line">    name</span><br><span class="line">    age</span><br><span class="line">  &#125;</span><br><span class="line">  user2: user(id: &quot;2&quot;) &#123;</span><br><span class="line">    id</span><br><span class="line">    name</span><br><span class="line">    age</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>示例说明<ul><li><code>user1: user(id: &quot;1&quot;)</code>: 使用别名<code>user1</code>标识第一条<code>user</code>查询</li><li><code>user2: user(id: &quot;2&quot;)</code>: 使用别名<code>user2</code>标识第二条<code>user</code>查询</li><li>服务端仍调用同一个<code>user</code>解析器两次，客户端通过不同键名接收结果，无命名冲突</li></ul></li></ul><h5 id="定义响应格式"><a href="#定义响应格式" class="headerlink" title="定义响应格式"></a><p style='font-size: 14px'>定义响应格式</p></h5><ul><li>别名可以改变返回数据中的字段名称，使其更符合业务需求或提高可读性</li></ul><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;user1&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Alice&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;age&quot;</span><span class="punctuation">:</span> <span class="number">30</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;user2&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Bob&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;age&quot;</span><span class="punctuation">:</span> <span class="number">25</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><ul><li><code>user1</code>和<code>user2</code>成为响应数据中的字段名称，分别包含两个不同用户的信息</li></ul><hr><h4 id="5-片段Fragments"><a href="#5-片段Fragments" class="headerlink" title="5. 片段Fragments"></a>5. 片段<code>Fragments</code></h4><ul><li>片段用于复用一组字段选择，避免在多个查询&#x2F;变更&#x2F;订阅中重复书写相同字段，提升可读性与维护性</li><li>使用价值<ul><li>减少重复: 一处定义，多处引用</li><li>保持一致: 保证不同查询返回字段结构一致</li><li>易于修改: 修改片段即可同步更新所有使用位置</li></ul></li></ul><h5 id="片段的语法"><a href="#片段的语法" class="headerlink" title="片段的语法"></a><p style='font-size: 14px'>片段的语法</p></h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fragment FragmentName on TypeName &#123;</span><br><span class="line">  field1</span><br><span class="line">  field2</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>语法说明<ul><li><code>FragmentName</code>: 片段名称，后续通过<code>...FragmentName</code>引用</li><li><code>on TypeName</code>: 指定该片段绑定的类型（只能在该类型或其实现处使用）</li><li>片段体: 需要复用的字段集合</li></ul></li></ul><h5 id="片段的使用示例"><a href="#片段的使用示例" class="headerlink" title="片段的使用示例"></a><p style='font-size: 14px'>片段的使用示例</p></h5><ul><li>场景: 多次查询<code>User</code>不同实例但需要相同字段集合</li><li>示例代码（片段定义 -&gt; 查询使用 -&gt; 返回结果）</li></ul><figure class="highlight text"><table><tr><td class="code"><pre><span class="line"># Fragment Definition -----------------</span><br><span class="line">fragment UserFields on User &#123;</span><br><span class="line">  id</span><br><span class="line">  name</span><br><span class="line">  age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># Query Using Fragment ----------------</span><br><span class="line">query &#123;</span><br><span class="line">  user1: user(id: &quot;1&quot;) &#123;</span><br><span class="line">    ...UserFields</span><br><span class="line">  &#125;</span><br><span class="line">  user2: user(id: &quot;2&quot;) &#123;</span><br><span class="line">    ...UserFields</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># Result JSON -------------------------</span><br><span class="line">&#123;</span><br><span class="line">  &quot;data&quot;: &#123;</span><br><span class="line">    &quot;user1&quot;: &#123;</span><br><span class="line">      &quot;id&quot;: &quot;1&quot;,</span><br><span class="line">      &quot;name&quot;: &quot;Alice&quot;,</span><br><span class="line">      &quot;age&quot;: 30</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;user2&quot;: &#123;</span><br><span class="line">      &quot;id&quot;: &quot;2&quot;,</span><br><span class="line">      &quot;name&quot;: &quot;Bob&quot;,</span><br><span class="line">      &quot;age&quot;: 25</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="嵌套片段"><a href="#嵌套片段" class="headerlink" title="嵌套片段"></a><p style='font-size: 14px'>嵌套片段</p></h5><ul><li>通过在一个片段内部引用另一个片段，实现复杂对象字段的分层复用</li><li>适用场景: 对象包含子对象，需要分别维护子对象字段集合</li><li>示例代码（片段定义 -&gt; 查询使用 -&gt; 返回结果）</li></ul><figure class="highlight text"><table><tr><td class="code"><pre><span class="line"># Fragment Definitions -----------------</span><br><span class="line">fragment AddressFields on Address &#123;</span><br><span class="line">  street</span><br><span class="line">  city</span><br><span class="line">  country</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fragment UserFields on User &#123;</span><br><span class="line">  id</span><br><span class="line">  name</span><br><span class="line">  age</span><br><span class="line">  address &#123;</span><br><span class="line">    ...AddressFields</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># Query Using Nested Fragment ----------</span><br><span class="line">query &#123;</span><br><span class="line">  user(id: &quot;1&quot;) &#123;</span><br><span class="line">    ...UserFields</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># Result JSON --------------------------</span><br><span class="line">&#123;</span><br><span class="line">  &quot;data&quot;: &#123;</span><br><span class="line">    &quot;user&quot;: &#123;</span><br><span class="line">      &quot;id&quot;: &quot;1&quot;,</span><br><span class="line">      &quot;name&quot;: &quot;Alice&quot;,</span><br><span class="line">      &quot;age&quot;: 30,</span><br><span class="line">      &quot;address&quot;: &#123;</span><br><span class="line">        &quot;street&quot;: &quot;123 Main St&quot;,</span><br><span class="line">        &quot;city&quot;: &quot;New York&quot;,</span><br><span class="line">        &quot;country&quot;: &quot;USA&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="内联片段"><a href="#内联片段" class="headerlink" title="内联片段"></a><p style='font-size: 14px'>内联片段</p></h5><ul><li>用途: 针对接口或联合类型中不同具体实现返回不同字段集合</li><li>使用场景<ul><li>接口&#x2F;联合类型多态数据</li><li>需要根据实际类型选择附加字段</li></ul></li><li>语法: <code>... on TypeName &#123; fields &#125;</code></li><li>示例代码（语法 -&gt; Schema -&gt; 查询使用 -&gt; 返回结果）</li></ul><figure class="highlight text"><table><tr><td class="code"><pre><span class="line"># Inline Fragment Syntax ---------------</span><br><span class="line">... on TypeName &#123;</span><br><span class="line">  field1</span><br><span class="line">  field2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># Schema --------------------------------</span><br><span class="line">interface Person &#123;</span><br><span class="line">  id: ID!</span><br><span class="line">  name: String!</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Employee implements Person &#123;</span><br><span class="line">  id: ID!</span><br><span class="line">  name: String!</span><br><span class="line">  salary: Int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Customer implements Person &#123;</span><br><span class="line">  id: ID!</span><br><span class="line">  name: String!</span><br><span class="line">  purchaseHistory: [String]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Query &#123;</span><br><span class="line">  persons: [Person]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># Query Using Inline Fragments ---------</span><br><span class="line">query &#123;</span><br><span class="line">  persons &#123;</span><br><span class="line">    id</span><br><span class="line">    name</span><br><span class="line">    ... on Employee &#123;</span><br><span class="line">      salary</span><br><span class="line">    &#125;</span><br><span class="line">    ... on Customer &#123;</span><br><span class="line">      purchaseHistory</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># Result JSON --------------------------</span><br><span class="line">&#123;</span><br><span class="line">  &quot;data&quot;: &#123;</span><br><span class="line">    &quot;persons&quot;: [</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;id&quot;: &quot;1&quot;,</span><br><span class="line">        &quot;name&quot;: &quot;Alice&quot;,</span><br><span class="line">        &quot;salary&quot;: 50000</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;id&quot;: &quot;2&quot;,</span><br><span class="line">        &quot;name&quot;: &quot;Bob&quot;,</span><br><span class="line">        &quot;purchaseHistory&quot;: [&quot;item1&quot;, &quot;item2&quot;]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="6-操作名称"><a href="#6-操作名称" class="headerlink" title="6. 操作名称"></a>6. 操作名称</h4><p>在<code>GraphQL</code>中，操作名称 (<code>Operation Name</code>) 是一个可选的标识，用于明确标注特定的查询 (<code>Query</code>)、变更 (<code>Mutation</code>) 或订阅 (<code>Subscription</code>) 操作的名称。它有助于提高可读性、调试效率，以及在某些工具中实现特定功能</p><h5 id="操作名称特点"><a href="#操作名称特点" class="headerlink" title="操作名称特点"></a><p style='font-size: 14px'>操作名称特点</p></h5><ul><li>操作名称的位置<ul><li>紧跟在操作类型（如<code>query</code>、<code>mutation</code>或<code>subscription</code>）之后</li></ul></li><li>命名规则<ul><li>名称只能包含字母、数字和下划线<code>(_)</code></li><li>名称不能以数字开头</li></ul></li><li>用途<ul><li>提供查询的上下文，明确查询意图</li><li>在调试、日志记录和工具（如<code>Apollo Client</code>）中，用于识别特定的操作</li><li>当一个请求中包含多个操作时，必须使用操作名称</li></ul></li></ul><h5 id="操作名称示例"><a href="#操作名称示例" class="headerlink" title="操作名称示例"></a><p style='font-size: 14px'>操作名称示例</p></h5><ul><li>查询示例: <code>GetUser</code>是操作名称，用于标识此查询操作</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">query GetUser &#123;</span><br><span class="line">  user(id: &quot;1&quot;) &#123;</span><br><span class="line">    id</span><br><span class="line">    name</span><br><span class="line">    age</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>变更示例: <code>CreateUser</code>是操作名称，表明此变更的目的为创建用户</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mutation CreateUser &#123;</span><br><span class="line">  createUser(name: &quot;Alice&quot;, age: 30) &#123;</span><br><span class="line">    id</span><br><span class="line">    name</span><br><span class="line">    age</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>多操作示例: 当一个请求中包含多个操作时，必须使用操作名称进行区分</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">query GetUser &#123;</span><br><span class="line">  user(id: &quot;1&quot;) &#123;</span><br><span class="line">    id</span><br><span class="line">    name</span><br><span class="line">    age</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mutation UpdateUser &#123;</span><br><span class="line">  updateUser(id: &quot;1&quot;, name: &quot;Alice&quot;) &#123;</span><br><span class="line">    id</span><br><span class="line">    name</span><br><span class="line">    age</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>匿名操作: 如果操作名称被省略，该操作称为匿名操作, 但在一个请求中不能包含多个匿名操作，因为没有操作名称用于区分</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">query &#123;</span><br><span class="line">  user(id: &quot;1&quot;) &#123;</span><br><span class="line">    id</span><br><span class="line">    name</span><br><span class="line">    age</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="7-操作类型"><a href="#7-操作类型" class="headerlink" title="7. 操作类型"></a>7. 操作类型</h4><p>在<code>GraphQL</code>中，操作类型 (<code>Operation Type</code>) 是指客户端可以在<code>API</code>请求中执行的三种操作: 查询 (<code>Query</code>)、变更 (<code>Mutation</code>) 和 订阅 (<code>Subscription</code>)。每种操作类型对应不同的用途，分别用于读取数据、修改数据和监听实时数据更新</p><h5 id="操作类型介绍"><a href="#操作类型介绍" class="headerlink" title="操作类型介绍"></a><p style='font-size: 14px'>操作类型介绍</p></h5><ul><li>查询 <code>Query</code><ul><li>用途: 用于读取和获取数据</li><li>特点: 不会对服务器数据产生任何修改，仅返回请求的数据 (类似于<code>REST API</code>的<code>GET</code>请求)</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">query &#123;</span><br><span class="line">  user(id: &quot;1&quot;) &#123;</span><br><span class="line">    id</span><br><span class="line">    name</span><br><span class="line">    age</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;!-- 查询 user 数据，根据参数 id: &quot;1&quot; 获取特定用户的信息 --&gt;</span><br><span class="line">&lt;!-- 返回的字段包括 id、name 和 age --&gt;</span><br></pre></td></tr></table></figure><ul><li>变更 <code>Mutation</code><ul><li>用途: 用于修改服务器上的数据，包括创建、更新或删除操作</li><li>特点: 与查询不同，变更操作会改变服务器的数据状态 (类似于<code>REST API</code>的<code>POST</code>、<code>PUT</code>、<code>PATCH</code>和 <code>DELETE</code>请求)</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mutation &#123;</span><br><span class="line">  createUser(name: &quot;Alice&quot;, age: 30) &#123;</span><br><span class="line">    id</span><br><span class="line">    name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;!-- 调用 createUser 变更操作，创建一个新用户 --&gt;</span><br><span class="line">&lt;!-- 参数 name 和 age 提供新用户的基本信息 --&gt;</span><br><span class="line">&lt;!-- 返回结果包括新用户的 id 和 name --&gt;</span><br></pre></td></tr></table></figure><ul><li>订阅 <code>Subscription</code><ul><li>用途: 用于监听服务器上的事件，并在事件发生时实时接收更新</li><li>特点: 用于实时数据更新场景，如实时聊天、股票行情等。订阅操作会保持一个持久的连接（通常使用<code>WebSocket</code>），当事件发生时，服务器会主动推送更新给客户端</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">subscription &#123;</span><br><span class="line">  userAdded &#123;</span><br><span class="line">    id</span><br><span class="line">    name</span><br><span class="line">    age</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;!-- 订阅 userAdded 事件，当有新用户被添加时，服务器会推送更新数据 --&gt;</span><br><span class="line">&lt;!-- 返回结果包含新用户的 id、name 和 age --&gt;</span><br></pre></td></tr></table></figure><h5 id="三种操作类型的比较"><a href="#三种操作类型的比较" class="headerlink" title="三种操作类型的比较"></a><p style='font-size: 14px'>三种操作类型的比较</p></h5><table><thead><tr><th><strong>操作类型</strong></th><th><strong>用途</strong></th><th><strong>是否修改数据</strong></th><th><strong>使用场景</strong></th></tr></thead><tbody><tr><td><strong>查询</strong></td><td>读取和获取数据</td><td>否</td><td>获取用户、产品列表、详情页数据</td></tr><tr><td><strong>变更</strong></td><td>修改服务器数据</td><td>是</td><td>创建、更新、删除资源</td></tr><tr><td><strong>订阅</strong></td><td>监听事件并实时接收数据更新</td><td>否</td><td>实时聊天、通知、数据流</td></tr></tbody></table><hr><h4 id="8-查询Query"><a href="#8-查询Query" class="headerlink" title="8. 查询Query"></a>8. 查询<code>Query</code></h4><p>查询 (<code>Query</code>) 是<code>GraphQL</code>中的一种操作类型，用于从服务器获取数据。它与传统<code>REST API</code>的<code>GET</code>请求类似，但在灵活性和强大性方面超越了后者</p><h5 id="查询的定义"><a href="#查询的定义" class="headerlink" title="查询的定义"></a><p style='font-size: 14px'>查询的定义</p></h5><ul><li>在<code>GraphQL</code>中，查询类型通常在<code>schema</code>中定义为<code>Query</code>类型。<code>Query</code>类型描述了所有可执行的查询操作</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type Query &#123;</span><br><span class="line">  user(id: ID!): User</span><br><span class="line">  users: [User]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type User &#123;</span><br><span class="line">  id: ID!</span><br><span class="line">  name: String!</span><br><span class="line">  age: Int</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="查询解析器Resolver"><a href="#查询解析器Resolver" class="headerlink" title="查询解析器Resolver"></a><p style='font-size: 14px'>查询解析器<code>Resolver</code></p></h5><ul><li>解析器负责实现字段的具体逻辑，定义如何获取数据。以下是查询解析器的示例</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> users = [</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="string">&#x27;1&#x27;</span>, <span class="attr">name</span>: <span class="string">&#x27;Alice&#x27;</span>, <span class="attr">age</span>: <span class="number">30</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="string">&#x27;2&#x27;</span>, <span class="attr">name</span>: <span class="string">&#x27;Bob&#x27;</span>, <span class="attr">age</span>: <span class="number">25</span> &#125;,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> resolvers = &#123;</span><br><span class="line">  <span class="title class_">Query</span>: &#123;</span><br><span class="line">    <span class="attr">user</span>: <span class="function">(<span class="params">parent, args, context, info</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> users.<span class="title function_">find</span>(<span class="function"><span class="params">user</span> =&gt;</span> user.<span class="property">id</span> === args.<span class="property">id</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">users</span>: <span class="function">() =&gt;</span> users,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><code>user</code>: 根据传入的<code>id</code>参数，从<code>users</code>列表中查找并返回对应用户</li><li><code>users</code>: 直接返回所有用户</li></ul><h5 id="查询的特点"><a href="#查询的特点" class="headerlink" title="查询的特点"></a><p style='font-size: 14px'>查询的特点</p></h5><ul><li>精确的数据获取: 客户端可以指定所需字段，避免传输多余数据</li><li>示例代码（精确字段查询 -&gt; 多资源单请求 -&gt; 各自结果）</li></ul><figure class="highlight text"><table><tr><td class="code"><pre><span class="line"># Query (Precise Fields) ---------------</span><br><span class="line">query &#123;</span><br><span class="line">  user(id: &quot;1&quot;) &#123;</span><br><span class="line">    name</span><br><span class="line">    age</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># Result JSON (Precise Fields) ---------</span><br><span class="line">&#123;</span><br><span class="line">  &quot;data&quot;: &#123;</span><br><span class="line">    &quot;user&quot;: &#123;</span><br><span class="line">      &quot;name&quot;: &quot;Alice&quot;,</span><br><span class="line">      &quot;age&quot;: 30</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># Query (Multiple Resources Single Request)</span><br><span class="line">query &#123;</span><br><span class="line">  user(id: &quot;1&quot;) &#123;</span><br><span class="line">    id</span><br><span class="line">    name</span><br><span class="line">  &#125;</span><br><span class="line">  users &#123;</span><br><span class="line">    id</span><br><span class="line">    name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># Result JSON (Multiple Resources) -----</span><br><span class="line">&#123;</span><br><span class="line">  &quot;data&quot;: &#123;</span><br><span class="line">    &quot;user&quot;: &#123;</span><br><span class="line">      &quot;id&quot;: &quot;1&quot;,</span><br><span class="line">      &quot;name&quot;: &quot;Alice&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;users&quot;: [</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;id&quot;: &quot;1&quot;,</span><br><span class="line">        &quot;name&quot;: &quot;Alice&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;id&quot;: &quot;2&quot;,</span><br><span class="line">        &quot;name&quot;: &quot;Bob&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="9-变更Mutations"><a href="#9-变更Mutations" class="headerlink" title="9. 变更Mutations"></a>9. 变更<code>Mutations</code></h4><p>变更 (<code>Mutations</code>) 是<code>GraphQL</code>中的一种操作类型，专门用于对服务器端的数据进行修改操作。与查询 (<code>Query</code>) 仅用于读取数据不同，变更支持创建、更新或删除数据。每个变更操作都可以定义所需的输入参数和返回结果的结构</p><h5 id="变更的定义"><a href="#变更的定义" class="headerlink" title="变更的定义"></a><p style='font-size: 14px'>变更的定义</p></h5><ul><li>在<code>GraphQL</code>的<code>schema</code>中，变更类型通常定义在<code>Mutation</code>类型中，用来描述所有支持的数据修改操作</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type Mutation &#123;</span><br><span class="line">  createUser(name: String!, age: Int!): User</span><br><span class="line">  updateUser(id: ID!, name: String, age: Int): User</span><br><span class="line">  deleteUser(id: ID!): Boolean</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type User &#123;</span><br><span class="line">  id: ID!</span><br><span class="line">  name: String!</span><br><span class="line">  age: Int</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>createUser</code>: 接收<code>name</code>和<code>age</code>参数，返回新创建的<code>User</code>对象</li><li><code>updateUser</code>: 接收<code>id</code>（必需）、<code>name</code>和<code>age</code>参数，用于更新用户信息，返回更新后的<code>User</code></li><li><code>deleteUser</code>: 接收<code>id</code>参数，用于删除指定用户，返回布尔值表示操作是否成功</li></ul><h5 id="变更的解析器"><a href="#变更的解析器" class="headerlink" title="变更的解析器"></a><p style='font-size: 14px'>变更的解析器</p></h5><ul><li>解析器定义了如何执行变更操作，通常与数据库或其他数据存储交互</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; <span class="attr">v4</span>: uuidv4 &#125; = <span class="built_in">require</span>(<span class="string">&#x27;uuid&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> users = [</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="string">&#x27;1&#x27;</span>, <span class="attr">name</span>: <span class="string">&#x27;Alice&#x27;</span>, <span class="attr">age</span>: <span class="number">30</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="string">&#x27;2&#x27;</span>, <span class="attr">name</span>: <span class="string">&#x27;Bob&#x27;</span>, <span class="attr">age</span>: <span class="number">25</span> &#125;,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> resolvers = &#123;</span><br><span class="line">  <span class="title class_">Mutation</span>: &#123;</span><br><span class="line">    <span class="attr">createUser</span>: <span class="function">(<span class="params">parent, args, context, info</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> newUser = &#123;</span><br><span class="line">        <span class="attr">id</span>: <span class="title function_">uuidv4</span>(), <span class="comment">// 生成唯一 ID</span></span><br><span class="line">        <span class="attr">name</span>: args.<span class="property">name</span>,</span><br><span class="line">        <span class="attr">age</span>: args.<span class="property">age</span>,</span><br><span class="line">      &#125;;</span><br><span class="line">      users.<span class="title function_">push</span>(newUser); <span class="comment">// 添加到用户列表</span></span><br><span class="line">      <span class="keyword">return</span> newUser;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">updateUser</span>: <span class="function">(<span class="params">parent, args, context, info</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> user = users.<span class="title function_">find</span>(<span class="function"><span class="params">user</span> =&gt;</span> user.<span class="property">id</span> === args.<span class="property">id</span>);</span><br><span class="line">      <span class="keyword">if</span> (!user) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;User not found&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (args.<span class="property">name</span> !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">        user.<span class="property">name</span> = args.<span class="property">name</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (args.<span class="property">age</span> !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">        user.<span class="property">age</span> = args.<span class="property">age</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> user;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">deleteUser</span>: <span class="function">(<span class="params">parent, args, context, info</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> userIndex = users.<span class="title function_">findIndex</span>(<span class="function"><span class="params">user</span> =&gt;</span> user.<span class="property">id</span> === args.<span class="property">id</span>);</span><br><span class="line">      <span class="keyword">if</span> (userIndex === -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;User not found&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      users.<span class="title function_">splice</span>(userIndex, <span class="number">1</span>); <span class="comment">// 从列表中移除用户</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="变更的使用"><a href="#变更的使用" class="headerlink" title="变更的使用"></a><p style='font-size: 14px'>变更的使用</p></h5><p>客户端可以通过以下查询发送变更请求</p><ul><li>示例代码（创建用户 -&gt; 更新用户 -&gt; 删除用户 -&gt; 各自结果）</li></ul><figure class="highlight text"><table><tr><td class="code"><pre><span class="line"># Create User Mutation -----------------</span><br><span class="line">mutation &#123;</span><br><span class="line">  createUser(name: &quot;Alice&quot;, age: 30) &#123;</span><br><span class="line">    id</span><br><span class="line">    name</span><br><span class="line">    age</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># Result JSON (Create) -----------------</span><br><span class="line">&#123;</span><br><span class="line">  &quot;data&quot;: &#123;</span><br><span class="line">    &quot;createUser&quot;: &#123;</span><br><span class="line">      &quot;id&quot;: &quot;c81e728d-59f2-4d16-9f02-fcad84756789&quot;,</span><br><span class="line">      &quot;name&quot;: &quot;Alice&quot;,</span><br><span class="line">      &quot;age&quot;: 30</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># Update User Mutation -----------------</span><br><span class="line">mutation &#123;</span><br><span class="line">  updateUser(id: &quot;1&quot;, name: &quot;Alice Updated&quot;) &#123;</span><br><span class="line">    id</span><br><span class="line">    name</span><br><span class="line">    age</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># Result JSON (Update) -----------------</span><br><span class="line">&#123;</span><br><span class="line">  &quot;data&quot;: &#123;</span><br><span class="line">    &quot;updateUser&quot;: &#123;</span><br><span class="line">      &quot;id&quot;: &quot;1&quot;,</span><br><span class="line">      &quot;name&quot;: &quot;Alice Updated&quot;,</span><br><span class="line">      &quot;age&quot;: 30</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># Delete User Mutation -----------------</span><br><span class="line">mutation &#123;</span><br><span class="line">  deleteUser(id: &quot;2&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># Result JSON (Delete) -----------------</span><br><span class="line">&#123;</span><br><span class="line">  &quot;data&quot;: &#123;</span><br><span class="line">    &quot;deleteUser&quot;: true</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="10-订阅Subscription"><a href="#10-订阅Subscription" class="headerlink" title="10. 订阅Subscription"></a>10. 订阅<code>Subscription</code></h4><p>订阅 (<code>Subscription</code>) 是<code>GraphQL</code>中的一种操作类型，允许客户端订阅服务器上的事件，并在事件发生时实时接收更新数据。这种机制特别适合实时更新场景，如聊天消息、通知、股票价格等</p><h5 id="订阅的工作原理"><a href="#订阅的工作原理" class="headerlink" title="订阅的工作原理"></a><p style='font-size: 14px'>订阅的工作原理</p></h5><ul><li>建立订阅连接: 客户端发送订阅请求到服务器，指定要订阅的事件或数据</li><li>保持连接: 服务器与客户端之间通过<code>WebSocket</code>或其他双向通信协议维持持久连接</li><li>事件触发: 当服务器端的事件发生变化（如新增或更新数据）时，触发对应的订阅逻辑</li><li>数据推送: 服务器将更新的数据通过连接推送到订阅的客户端</li></ul><h5 id="订阅示例"><a href="#订阅示例" class="headerlink" title="订阅示例"></a><p style='font-size: 14px'>订阅示例</p></h5><ul><li><code>Schema</code>定义</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type User &#123;</span><br><span class="line">  id: ID!</span><br><span class="line">  name: String!</span><br><span class="line">  age: Int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Subscription &#123;</span><br><span class="line">  userAdded: User</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Mutation &#123;</span><br><span class="line">  createUser(name: String!, age: Int!): User</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>Resolvers</code>实现</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; <span class="title class_">PubSub</span> &#125; = <span class="built_in">require</span>(<span class="string">&#x27;graphql-subscriptions&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> pubsub = <span class="keyword">new</span> <span class="title class_">PubSub</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> resolvers = &#123;</span><br><span class="line">  <span class="title class_">Subscription</span>: &#123;</span><br><span class="line">    <span class="attr">userAdded</span>: &#123;</span><br><span class="line">      <span class="comment">// 定义订阅器，监听 USER_ADDED 事件</span></span><br><span class="line">      <span class="attr">subscribe</span>: <span class="function">() =&gt;</span> pubsub.<span class="title function_">asyncIterator</span>([<span class="string">&#x27;USER_ADDED&#x27;</span>]),</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title class_">Mutation</span>: &#123;</span><br><span class="line">    <span class="attr">createUser</span>: <span class="function">(<span class="params">parent, args, context, info</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> newUser = &#123;</span><br><span class="line">        <span class="attr">id</span>: <span class="title function_">generateUniqueId</span>(),</span><br><span class="line">        <span class="attr">name</span>: args.<span class="property">name</span>,</span><br><span class="line">        <span class="attr">age</span>: args.<span class="property">age</span>,</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 保存用户数据（模拟数据库操作）</span></span><br><span class="line">      <span class="title function_">saveUserToDatabase</span>(newUser);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 触发 USER_ADDED 事件</span></span><br><span class="line">      pubsub.<span class="title function_">publish</span>(<span class="string">&#x27;USER_ADDED&#x27;</span>, &#123; <span class="attr">userAdded</span>: newUser &#125;);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> newUser;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>客户端订阅示例</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">subscription &#123;</span><br><span class="line">  userAdded &#123;</span><br><span class="line">    id</span><br><span class="line">    name</span><br><span class="line">    age</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>当有新用户通过<code>createUser</code>变更操作添加时，服务器会触发<code>userAdded</code>事件，客户端将接收到用户信息</li></ul><h5 id="Apollo-Client订阅"><a href="#Apollo-Client订阅" class="headerlink" title="Apollo Client订阅"></a><p style='font-size: 14px'><code>Apollo Client</code>订阅</p></h5><ul><li>配置<code>Apollo Client</code>: 创建一个支持查询、变更和订阅的客户端</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">ApolloClient</span>, <span class="title class_">InMemoryCache</span>, split &#125; <span class="keyword">from</span> <span class="string">&#x27;@apollo/client&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">WebSocketLink</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;@apollo/client/link/ws&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">HttpLink</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;@apollo/client&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; getMainDefinition &#125; <span class="keyword">from</span> <span class="string">&#x27;@apollo/client/utilities&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置 HTTP 链接用于查询和变更</span></span><br><span class="line"><span class="keyword">const</span> httpLink = <span class="keyword">new</span> <span class="title class_">HttpLink</span>(&#123; <span class="attr">uri</span>: <span class="string">&#x27;http://localhost:4000/graphql&#x27;</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置 WebSocket 链接用于订阅</span></span><br><span class="line"><span class="keyword">const</span> wsLink = <span class="keyword">new</span> <span class="title class_">WebSocketLink</span>(&#123;</span><br><span class="line">  <span class="attr">uri</span>: <span class="string">&#x27;ws://localhost:4000/graphql&#x27;</span>,</span><br><span class="line">  <span class="attr">options</span>: &#123;</span><br><span class="line">    <span class="attr">reconnect</span>: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 split 根据操作类型分别选择链接</span></span><br><span class="line"><span class="keyword">const</span> splitLink = <span class="title function_">split</span>(</span><br><span class="line">  <span class="function">(<span class="params">&#123; query &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> definition = <span class="title function_">getMainDefinition</span>(query);</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      definition.<span class="property">kind</span> === <span class="string">&#x27;OperationDefinition&#x27;</span> &amp;&amp;</span><br><span class="line">      definition.<span class="property">operation</span> === <span class="string">&#x27;subscription&#x27;</span></span><br><span class="line">    );</span><br><span class="line">  &#125;,</span><br><span class="line">  wsLink,</span><br><span class="line">  httpLink,</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 Apollo 客户端</span></span><br><span class="line"><span class="keyword">const</span> client = <span class="keyword">new</span> <span class="title class_">ApolloClient</span>(&#123;</span><br><span class="line">  <span class="attr">link</span>: splitLink,</span><br><span class="line">  <span class="attr">cache</span>: <span class="keyword">new</span> <span class="title class_">InMemoryCache</span>(),</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li>订阅操作: 使用<code>Apollo Client</code>的<code>useSubscription Hook</code>实现订阅</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; gql, useSubscription &#125; <span class="keyword">from</span> <span class="string">&#x27;@apollo/client&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">USER_ADDED_SUBSCRIPTION</span> = gql<span class="string">`</span></span><br><span class="line"><span class="string">  subscription OnUserAdded &#123;</span></span><br><span class="line"><span class="string">    userAdded &#123;</span></span><br><span class="line"><span class="string">      id</span></span><br><span class="line"><span class="string">      name</span></span><br><span class="line"><span class="string">      age</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">`</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">UserList</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; data, loading, error &#125; = <span class="title function_">useSubscription</span>(<span class="variable constant_">USER_ADDED_SUBSCRIPTION</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (loading) <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Loading...<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>;</span><br><span class="line">  <span class="keyword">if</span> (error) <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Error: &#123;error.message&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h2</span>&gt;</span>New User Added:<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>ID: &#123;data.userAdded.id&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>Name: &#123;data.userAdded.name&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>Age: &#123;data.userAdded.age&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">UserList</span>;</span><br></pre></td></tr></table></figure><ul><li>总而言之，<code>GraphQL</code>的<code>Subscription</code>依赖于<code>WebSocket</code>来实现。<code>WebSocket</code>提供了双向持久连接的能力，使得服务器能够在事件发生时立即向客户端推送数据，而<code>Subscription</code>则定义了这些事件和数据的结构。因此，<code>Subscription</code>不是替代<code>WebSocket</code>，而是利用<code>WebSocket</code>来实现特定的功能和需求</li></ul><hr><h3 id="GraphQL进阶"><a href="#GraphQL进阶" class="headerlink" title="GraphQL进阶"></a><code>GraphQL</code>进阶</h3><h4 id="11-变量-Variables"><a href="#11-变量-Variables" class="headerlink" title="11. 变量 Variables"></a>11. 变量 Variables</h4><p>在<code>GraphQL</code>中，变量 (<code>Variables</code>) 是一种机制，用于动态传递参数到查询 (<code>Query</code>)、变更 (<code>Mutation</code>) 或订阅 (<code>Subscription</code>) 中。通过使用变量，可以使查询更加灵活、可重用，并且避免将用户输入直接嵌入到查询字符串中，从而提升安全性和可读性</p><h5 id="变量的定义与使用"><a href="#变量的定义与使用" class="headerlink" title="变量的定义与使用"></a><p style='font-size: 14px'>变量的定义与使用</p></h5><ul><li>查询中的变量: 变量需要在查询语句中定义，并在执行查询时传入实际的值</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">query GetUser($id: ID!) &#123;</span><br><span class="line">  user(id: $id) &#123;</span><br><span class="line">    id</span><br><span class="line">    name</span><br><span class="line">    age</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;!-- $id 是一个变量，表示用户的 ID --&gt;</span><br><span class="line">&lt;!-- 变量的类型为 ID!，! 表示这是一个必需字段 --&gt;</span><br></pre></td></tr></table></figure><ul><li>变量在<code>React</code>中的使用: 使用<code>Apollo Client</code>的<code>useQuery Hook</code>动态传递变量值</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; gql, useQuery &#125; <span class="keyword">from</span> <span class="string">&#x27;@apollo/client&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义查询和变量</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">GET_USER</span> = gql<span class="string">`</span></span><br><span class="line"><span class="string">  query GetUser($id: ID!) &#123;</span></span><br><span class="line"><span class="string">    user(id: $id) &#123;</span></span><br><span class="line"><span class="string">      id</span></span><br><span class="line"><span class="string">      name</span></span><br><span class="line"><span class="string">      age</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">`</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">User</span>(<span class="params">&#123; userId &#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; loading, error, data &#125; = <span class="title function_">useQuery</span>(<span class="variable constant_">GET_USER</span>, &#123;</span><br><span class="line">    <span class="attr">variables</span>: &#123; <span class="attr">id</span>: userId &#125;, <span class="comment">// 动态传递变量值</span></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (loading) <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Loading...<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>;</span><br><span class="line">  <span class="keyword">if</span> (error) <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Error: &#123;error.message&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h2</span>&gt;</span>User Details<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>ID: &#123;data.user.id&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>Name: &#123;data.user.name&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>Age: &#123;data.user.age&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">User</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 变量`$id`的值由组件的`props`动态传递</span></span><br><span class="line"><span class="comment">// 查询使用`useQuery Hook`，并通过`variables`选项传递实际的变量值</span></span><br></pre></td></tr></table></figure><ul><li>变更中的变量: 在变更操作中，变量同样可以动态传递参数</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mutation CreateUser($name: String!, $age: Int!) &#123;</span><br><span class="line">  createUser(name: $name, age: $age) &#123;</span><br><span class="line">    id</span><br><span class="line">    name</span><br><span class="line">    age</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>Apollo Client</code>示例</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; gql, useMutation &#125; <span class="keyword">from</span> <span class="string">&#x27;@apollo/client&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">CREATE_USER</span> = gql<span class="string">`</span></span><br><span class="line"><span class="string">  mutation CreateUser($name: String!, $age: Int!) &#123;</span></span><br><span class="line"><span class="string">    createUser(name: $name, age: $age) &#123;</span></span><br><span class="line"><span class="string">      id</span></span><br><span class="line"><span class="string">      name</span></span><br><span class="line"><span class="string">      age</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">`</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">CreateUserForm</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [createUser, &#123; data, loading, error &#125;] = <span class="title function_">useMutation</span>(<span class="variable constant_">CREATE_USER</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">handleSubmit</span> = <span class="keyword">async</span> (<span class="params">e</span>) =&gt; &#123;</span><br><span class="line">    e.<span class="title function_">preventDefault</span>();</span><br><span class="line">    <span class="keyword">const</span> name = e.<span class="property">target</span>.<span class="property">name</span>.<span class="property">value</span>;</span><br><span class="line">    <span class="keyword">const</span> age = <span class="built_in">parseInt</span>(e.<span class="property">target</span>.<span class="property">age</span>.<span class="property">value</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">createUser</span>(&#123; <span class="attr">variables</span>: &#123; name, age &#125; &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (loading) <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Submitting...<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>;</span><br><span class="line">  <span class="keyword">if</span> (error) <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Error: &#123;error.message&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">form</span> <span class="attr">onSubmit</span>=<span class="string">&#123;handleSubmit&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;Name&quot;</span> <span class="attr">required</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;Age&quot;</span> <span class="attr">type</span>=<span class="string">&quot;number&quot;</span> <span class="attr">required</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span>Create User<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;data &amp;&amp; <span class="tag">&lt;<span class="name">p</span>&gt;</span>Created User: &#123;data.createUser.name&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span>&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">CreateUserForm</span>;</span><br></pre></td></tr></table></figure><hr><h4 id="12-指令-Directives"><a href="#12-指令-Directives" class="headerlink" title="12. 指令 Directives"></a>12. 指令 Directives</h4><p>指令 (<code>Directives</code>) 是<code>GraphQL</code>中的一种强大功能，用于动态影响查询、变更 (<code>Mutation</code>) 或订阅 (<code>Subscription</code>) 的执行行为。指令可以应用于字段、片段等，帮助客户端或服务器灵活调整查询结果的生成逻辑。例如，可以根据条件决定是否包含某字段或动态修改返回结果</p><h5 id="内置指令"><a href="#内置指令" class="headerlink" title="内置指令"></a><p style='font-size: 14px'>内置指令</p></h5><p><code>GraphQL</code>规范中定义了两个常用的内置指令: <code>@include</code>和<code>@skip</code></p><ul><li><code>@include</code>: 条件包含<ul><li>用于根据条件动态包含字段或片段</li><li>接受一个名为<code>if</code>的参数，该参数的值为布尔类型</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">query GetUser($withAge: Boolean!) &#123;</span><br><span class="line">  user(id: &quot;1&quot;) &#123;</span><br><span class="line">    id</span><br><span class="line">    name</span><br><span class="line">    age @include(if: $withAge)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;!-- 如果变量 $withAge 为 true，则返回结果中包含 age 字段 --&gt;</span><br><span class="line">&lt;!-- 如果 $withAge 为 false，则排除 age 字段 --&gt;</span><br></pre></td></tr></table></figure><ul><li><code>@skip</code>: 条件跳过<ul><li>用于根据条件跳过字段或片段</li><li>同样接受一个名为<code>if</code>的布尔参数</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">query GetUser($withoutAge: Boolean!) &#123;</span><br><span class="line">  user(id: &quot;1&quot;) &#123;</span><br><span class="line">    id</span><br><span class="line">    name</span><br><span class="line">    age @skip(if: $withoutAge)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;!-- 如果变量 $withoutAge 为 true，则跳过 age 字段 --&gt;</span><br><span class="line">&lt;!-- 如果 $withoutAge 为 false，则包含 age 字段 --&gt;</span><br></pre></td></tr></table></figure><h5 id="自定义指令"><a href="#自定义指令" class="headerlink" title="自定义指令"></a><p style='font-size: 14px'>自定义指令</p></h5><p>除了内置指令，<code>GraphQL</code>还支持自定义指令。这些指令可以用于更复杂的场景，比如数据验证、字段格式化等。自定义指令需要在<code>schema</code>中声明，并提供对应的实现逻辑</p><ul><li>自定义指令声明</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">directive @upper on FIELD_DEFINITION</span><br><span class="line"></span><br><span class="line">type Query &#123;</span><br><span class="line">  greeting: String @upper</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;!-- @upper 是一个自定义指令，应用在字段定义上 --&gt;</span><br><span class="line">&lt;!-- on FIELD_DEFINITION 指定了该指令适用于字段定义 --&gt;</span><br></pre></td></tr></table></figure><ul><li>自定义指令的实现: 使用<code>graphql-tools</code>创建一个<code>@upper</code>指令，将字符串字段的返回值转换为大写</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; <span class="title class_">SchemaDirectiveVisitor</span> &#125; = <span class="built_in">require</span>(<span class="string">&#x27;graphql-tools&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; defaultFieldResolver &#125; = <span class="built_in">require</span>(<span class="string">&#x27;graphql&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UpperCaseDirective</span> <span class="keyword">extends</span> <span class="title class_ inherited__">SchemaDirectiveVisitor</span> &#123;</span><br><span class="line">  <span class="title function_">visitFieldDefinition</span>(<span class="params">field</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; resolve = defaultFieldResolver &#125; = field;</span><br><span class="line"></span><br><span class="line">    field.<span class="property">resolve</span> = <span class="keyword">async</span> <span class="keyword">function</span> (<span class="params">...args</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> result = <span class="keyword">await</span> resolve.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args);</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> result === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> result.<span class="title function_">toUpperCase</span>();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="title class_">UpperCaseDirective</span>;</span><br></pre></td></tr></table></figure><ul><li>整合指令到<code>Schema</code>: 自定义指令<code>@upper</code>应用于<code>greeting</code>字段，返回的值将自动转换为大写</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; gql &#125; = <span class="built_in">require</span>(<span class="string">&#x27;apollo-server&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">UpperCaseDirective</span> = <span class="built_in">require</span>(<span class="string">&#x27;./UpperCaseDirective&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> typeDefs = gql<span class="string">`</span></span><br><span class="line"><span class="string">  directive @upper on FIELD_DEFINITION</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  type Query &#123;</span></span><br><span class="line"><span class="string">    greeting: String @upper</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">`</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> resolvers = &#123;</span><br><span class="line">  <span class="title class_">Query</span>: &#123;</span><br><span class="line">    <span class="attr">greeting</span>: <span class="function">() =&gt;</span> <span class="string">&quot;hello world&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; makeExecutableSchema &#125; = <span class="built_in">require</span>(<span class="string">&#x27;graphql-tools&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> schema = <span class="title function_">makeExecutableSchema</span>(&#123;</span><br><span class="line">  typeDefs,</span><br><span class="line">  resolvers,</span><br><span class="line">  <span class="attr">schemaDirectives</span>: &#123;</span><br><span class="line">    <span class="attr">upper</span>: <span class="title class_">UpperCaseDirective</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = schema;</span><br></pre></td></tr></table></figure><ul><li>客户端使用示例</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">query &#123;</span><br><span class="line">  greeting</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;greeting&quot;</span><span class="punctuation">:</span> <span class="string">&quot;HELLO WORLD&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GraphQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GCP Cloud Digital Leader</title>
      <link href="/posts/88b435e5.html"/>
      <url>/posts/88b435e5.html</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p>官网: <a href="https://cloud.google.com/learn/certification/cloud-digital-leader">https://cloud.google.com/learn/certification/cloud-digital-leader</a></p></blockquote><hr><h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><h3 id="1-Regions-and-Zones"><a href="#1-Regions-and-Zones" class="headerlink" title="1. Regions and Zones"></a>1. Regions and Zones</h3><h4 id="Regions-and-Zones"><a href="#Regions-and-Zones" class="headerlink" title="Regions and Zones"></a>Regions and Zones</h4><ul><li>Google 在全球提供 20+ 个区域 (Regions)</li><li>优势:<ul><li>高可用性 (High Availability)</li><li>低延迟 (Low Latency)</li><li>全球覆盖 (Global Footprint)</li><li>满足政府监管要求 (Government Regulation)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img234835.png"></p><ul><li>每个 Region 包含三个或更多 Zone (可用区)</li><li>Zone 的优势: 提高可用性和容错能力</li><li>考试提示: 多 Zone 部署 → 提高容错和可用性</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img235111.png"></p><hr><h3 id="2-Compute"><a href="#2-Compute" class="headerlink" title="2. Compute"></a>2. Compute</h3><h4 id="Compute-Engine"><a href="#Compute-Engine" class="headerlink" title="Compute Engine"></a>Compute Engine</h4><ul><li><code>Compute Engine (GCE)</code>: 预配和管理虚拟机 (VMs)</li><li>核心功能:<ul><li>创建和管理 VM 实例生命周期</li><li>负载均衡 (Load Balancing) 和自动扩展 (Auto Scaling)</li><li>附加存储, 管理网络连接和配置</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img160151.png"></p><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img160329.png"></p><hr><h4 id="VM-Setup"><a href="#VM-Setup" class="headerlink" title="VM Setup"></a>VM Setup</h4><ul><li><strong>Startup Script</strong>: 引导脚本<ul><li>VM 实例启动时安装 OS 补丁或软件</li><li>适用场景: 临时配置, 测试环境</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img204439.png"></p><ul><li><strong>Instance Templates</strong>: 指定 VM 实例详细信息的模板<ul><li>用于创建 VM 实例和托管实例组 (Managed Instance Groups)</li><li>无法更新, 需要删除后重新创建</li><li>考试提示: Instance Templates 不可修改</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img161137.png"></p><ul><li><strong>Custom Image</strong>: 推荐方式 (比 Startup Script 更好)<ul><li>预装 OS 补丁和软件</li><li>启动速度更快, 配置更一致</li><li>考试提示: 生产环境推荐 Custom Image</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img161427.png"></p><hr><h4 id="Use-Discount"><a href="#Use-Discount" class="headerlink" title="Use Discount"></a>Use Discount</h4><ul><li><strong>Sustained Use Discounts</strong> (持续使用折扣):<ul><li>在计费月内运行 VM 实例达到一定比例时自动获得折扣</li><li>无需预留, 自动应用</li><li>折扣幅度: 使用越多, 折扣越大</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img161648.png"></p><ul><li><strong>Committed Use Discounts</strong> (承诺使用折扣):<ul><li>1 年或 3 年预留, 适用于可预测的工作负载</li><li>折扣幅度更大 (最高 57%)</li><li>需要承诺使用, 适合稳定工作负载</li><li>考试提示: 可预测工作负载 → Committed Use Discounts</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img93550.png"></p><hr><h4 id="Preemptible-VM"><a href="#Preemptible-VM" class="headerlink" title="Preemptible VM"></a>Preemptible VM</h4><ul><li><strong>Preemptible VM</strong>: 短期低成本计算实例 (最多便宜 80%)</li><li><strong>最长存活时间: 24 小时</strong> (会被自动终止)</li><li>适用场景:<ul><li>非关键时间的工作负载</li><li>容错能力强的应用 (批处理, 数据分析)</li><li>无状态应用</li></ul></li><li>考试提示: 成本敏感 + 容错 → Preemptible VM; 24 小时限制</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img40072.png"></p><hr><h4 id="Spot-VM"><a href="#Spot-VM" class="headerlink" title="Spot VM"></a>Spot VM</h4><ul><li><strong>Spot VM</strong>: Preemptible VM 的最新版本</li><li><strong>无最长运行时间限制</strong> (与 Preemptible VM 的 24 小时限制不同)</li><li>同样提供最多 80% 折扣</li><li>随时可能被终止, 但没有时间上限</li><li>适用场景: 与 Preemptible VM 类似, 但更灵活</li><li>考试提示: Spot VM 无 24 小时限制, Preemptible VM 有 24 小时限制</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img29088.png"></p><hr><h4 id="Sole-Tenant-Nodes"><a href="#Sole-Tenant-Nodes" class="headerlink" title="Sole Tenant Nodes"></a>Sole Tenant Nodes</h4><ul><li><strong>Sole Tenant Nodes</strong>: 单租户节点 (类似 AWS Dedicated Host)</li><li>在专用于单个客户的硬件上运行虚拟化实例</li><li>适用场景:<ul><li>合规性要求 (物理隔离)</li><li>自带许可证 (BYOL - Bring Your Own License)</li><li>性能敏感的工作负载</li></ul></li><li>与共享硬件对比: 更高成本, 更强隔离性</li><li>考试提示: 许可证要求 + 物理隔离 → Sole Tenant Nodes</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img79164.png"></p><hr><h4 id="Custom-Machine-Types"><a href="#Custom-Machine-Types" class="headerlink" title="Custom Machine Types"></a>Custom Machine Types</h4><ul><li><strong>Custom Machine Types</strong>: 自定义机器类型</li><li>可自定义资源:<ul><li>CPU (vCPUs 数量)</li><li>内存 (Memory)</li><li>GPU (可选)</li></ul></li><li>适用场景: 预定义机器类型不满足需求时</li><li>成本优化: 只为实际需要的资源付费</li><li>考试提示: 特殊资源需求 → Custom Machine Types</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img34118.png"></p><hr><h4 id="VM-costs"><a href="#VM-costs" class="headerlink" title="VM costs"></a>VM costs</h4><ul><li>使用 GCE 运行 VM 的两大主要成本:<ul><li><strong>Infrastructure Cost</strong>: VM 基础设施成本 (CPU, 内存, 磁盘)</li><li><strong>Licensing Cost</strong>: 操作系统许可成本</li></ul></li><li>成本优化策略:<ul><li>使用 Sustained Use Discounts (自动应用)</li><li>使用 Committed Use Discounts (1-3 年承诺)</li><li>选择合适的机器类型</li><li>使用 Preemptible&#x2F;Spot VM (非关键工作负载)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img96529.png"></p><hr><h4 id="Instance-Groups"><a href="#Instance-Groups" class="headerlink" title="Instance Groups"></a>Instance Groups</h4><ul><li><strong>Instance Group</strong>: 作为单一实体管理的 VM 实例组</li><li><strong>两种类型</strong>:<ul><li><strong>Managed</strong>: 使用模板创建的相同 VM (推荐)</li><li><strong>Unmanaged</strong>: 同一组中 VM 配置不同 (不推荐)</li></ul></li><li><strong>位置选择</strong>:<ul><li>Zonal: 单个 Zone (更简单)</li><li>Regional: 跨多个 Zone (更高可用性)</li></ul></li><li>考试提示: Regional Instance Groups → 更高可用性</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img100636.png"></p><hr><h4 id="Managed-Instance-Groups"><a href="#Managed-Instance-Groups" class="headerlink" title="Managed Instance Groups"></a>Managed Instance Groups</h4><ul><li><strong>Managed Instance Groups (MIG)</strong>: 维护特定数量的实例</li><li><strong>关键功能</strong>:<ul><li><strong>自我修复 (Self Healing)</strong>: 使用健康检查检测应用故障, 自动替换失败实例</li><li><strong>自动扩展 (Auto Scaling)</strong>: 根据负载增减实例</li><li><strong>负载均衡 (Load Balancing)</strong>: 添加负载均衡器分配流量</li><li><strong>滚动更新</strong>: 零停机部署新版本</li></ul></li><li>适用场景: 无状态应用, 需要高可用性和自动扩展</li><li>考试提示: 需要自动扩展 + 自我修复 → Managed Instance Groups</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img101512.png"></p><hr><h4 id="Cloud-Load-balancing"><a href="#Cloud-Load-balancing" class="headerlink" title="Cloud Load balancing"></a>Cloud Load balancing</h4><ul><li><strong>Cloud Load Balancing</strong>: 在一个或多个区域的 VM 实例之间分配流量</li><li><strong>特点</strong>:<ul><li>全球负载均衡 (支持跨区域)</li><li>高可用性和容错能力</li><li>自动扩展</li><li>集成健康检查</li></ul></li><li><strong>负载均衡器类型</strong>:<ul><li>HTTP(S) Load Balancing: 全球 HTTP&#x2F;HTTPS 流量</li><li>TCP&#x2F;UDP Load Balancing: 区域或全球 TCP&#x2F;UDP 流量</li><li>Internal Load Balancing: VPC 内部流量</li></ul></li><li>考试提示: 跨区域流量分配 → Cloud Load Balancing</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img211502.png"></p><hr><h4 id="Bare-Metal-Solution"><a href="#Bare-Metal-Solution" class="headerlink" title="Bare Metal Solution"></a>Bare Metal Solution</h4><ul><li><strong>Bare Metal Solution</strong>: 在 Google Cloud 提供的专用硬件上运行特殊工作负载</li><li><strong>核心优势</strong>:<ul><li>利用现有软件许可证 (BYOL)</li><li>无需修改配置即可迁移</li><li>物理服务器级别的隔离和性能</li></ul></li><li>适用场景:<ul><li>需要物理硬件的应用 (Oracle 数据库, SAP HANA)</li><li>严格的许可证要求</li><li>超低延迟需求</li></ul></li><li>与虚拟机对比: 更高性能, 更高成本, 物理隔离</li><li>考试提示: 专用硬件 + BYOL → Bare Metal Solution</li></ul><hr><h3 id="3-Managed-Services"><a href="#3-Managed-Services" class="headerlink" title="3. Managed Services"></a>3. Managed Services</h3><h4 id="IAAS-Infrastructure-as-a-Service"><a href="#IAAS-Infrastructure-as-a-Service" class="headerlink" title="IAAS (Infrastructure as a Service)"></a>IAAS (Infrastructure as a Service)</h4><ul><li><strong>IaaS</strong>: 仅使用云提供商的基础设施</li><li>用户负责: 操作系统, 中间件, 运行时, 应用程序, 数据</li><li>云提供商负责: 虚拟化, 服务器, 存储, 网络</li><li>示例: 使用 VM 部署应用程序或数据库</li><li>GCP 服务: Compute Engine</li><li>考试提示: 需要完全控制 OS → IaaS</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img214516.png"></p><hr><h4 id="PAAS-Platform-as-a-Service"><a href="#PAAS-Platform-as-a-Service" class="headerlink" title="PAAS (Platform as a Service)"></a>PAAS (Platform as a Service)</h4><ul><li><strong>PaaS</strong>: 使用云提供商提供的平台</li><li>用户负责: 配置和应用程序代码</li><li>云提供商负责: 操作系统, 中间件, 运行时, 基础设施</li><li>优势: 简化部署, 自动扩展, 无需管理服务器</li><li>GCP 服务: App Engine</li><li>考试提示: 专注应用开发 → PaaS</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img214802.png"></p><hr><h4 id="SAAS-Software-as-a-Service"><a href="#SAAS-Software-as-a-Service" class="headerlink" title="SAAS (Software as a Service)"></a>SAAS (Software as a Service)</h4><ul><li><strong>SaaS</strong>: 集中托管的软件 (大多在云上)</li><li>最小化管理级别</li><li>按订阅收费 (Pay-as-you-go)</li><li>用户负责: 内容, 访问策略, 使用</li><li>云提供商负责: 应用程序, 数据, 运行时, 中间件, OS, 基础设施</li><li>示例: Gmail, Google Workspace, Salesforce</li><li>考试提示: 完全托管的应用 → SaaS</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img301129.png"></p><hr><h4 id="Containers"><a href="#Containers" class="headerlink" title="Containers"></a>Containers</h4><ul><li><strong>容器</strong>: 确保微服务有统一的部署方式</li><li>为每个微服务创建 Docker 镜像, 包含:<ul><li>应用运行时 (Application Runtime)</li><li>应用代码和依赖 (Application code and Dependencies)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img228435PM.png"></p><ul><li><strong>容器优势</strong>:<ul><li>轻量级 (无 Guest OS)</li><li>容器隔离</li><li>云中立 (在任何基础设施上运行相同)</li><li>快速启动</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img228438.png"></p><ul><li><strong>容器编排</strong> (Container Orchestration, 基于 Kubernetes):<ul><li>自动扩展 (Auto Scaling)</li><li>负载均衡 (Load Balancing)</li><li>自我修复 (Self Healing)</li><li>快速部署 (Fast Deployment)</li></ul></li><li>GCP 服务: Google Kubernetes Engine (GKE)</li><li>考试提示: 容器编排 → Kubernetes&#x2F;GKE</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img228442.png"></p><hr><h4 id="Serverless"><a href="#Serverless" class="headerlink" title="Serverless"></a>Serverless</h4><ul><li><strong>Serverless</strong>: 专注代码, 云托管服务处理其他所有事务</li><li>按使用付费 (Pay for use)</li><li>优势:<ul><li>无需管理服务器</li><li>自动扩展</li><li>高可用性</li><li>降低运营成本</li></ul></li><li>GCP 服务: Cloud Functions, Cloud Run, App Engine</li><li>考试提示: 无服务器管理 + 事件驱动 → Serverless</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img301125.png"></p><hr><h4 id="Shared-Responsibility-Model"><a href="#Shared-Responsibility-Model" class="headerlink" title="Shared Responsibility Model"></a>Shared Responsibility Model</h4><ul><li><strong>共同责任模型</strong>: 云安全是共同责任</li><li><strong>责任划分</strong>:<ul><li><strong>SaaS</strong>: 内容 + 访问策略 + 使用</li><li><strong>PaaS</strong>: SaaS + 部署 + Web 应用安全</li><li><strong>IaaS</strong>: PaaS + 运维 + 网络安全 + Guest OS</li></ul></li><li><strong>Google Cloud 始终负责</strong>: 硬件, 网络, 审计日志</li><li>考试提示: 用户责任随服务模型递增 (IaaS &gt; PaaS &gt; SaaS)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img301149.png"></p><hr><h4 id="GCP-Service-Category"><a href="#GCP-Service-Category" class="headerlink" title="GCP Service Category"></a>GCP Service Category</h4><ul><li><strong>服务分类</strong>:<ul><li>Compute Engine: <strong>IaaS</strong> (提供自定义 OS)</li><li>Google Kubernetes Engine: <strong>CaaS</strong> (Container as a Service)</li><li>App Engine: <strong>PaaS</strong></li><li>Cloud Functions: <strong>FaaS</strong> (Function as a Service)</li><li>Cloud Run: <strong>CaaS</strong> (快速运行单个容器)</li></ul></li><li>考试提示: <ul><li>需要控制 OS → Compute Engine (IaaS)</li><li>容器编排 → GKE (CaaS)</li><li>应用平台 → App Engine (PaaS)</li><li>事件驱动函数 → Cloud Functions (FaaS)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img301158.png"></p><hr><h3 id="4-Managed-Compute-Service-in-GCP"><a href="#4-Managed-Compute-Service-in-GCP" class="headerlink" title="4. Managed Compute Service in GCP"></a>4. Managed Compute Service in GCP</h3><h4 id="App-Engine"><a href="#App-Engine" class="headerlink" title="App Engine"></a>App Engine</h4><ul><li><strong>App Engine</strong>: GCP 最简单的 PaaS 应用部署平台, 自动负载均衡&#x2F;自动扩展&#x2F;版本管理&#x2F;流量分割, 无使用费按预配资源付费</li><li><strong>关键限制</strong>: 不提供 VM 基础设施的细粒度控制</li><li><strong>Compute Engine vs App Engine</strong>: Compute Engine &#x3D; IaaS (更多责任&#x2F;更高灵活性); App Engine &#x3D; PaaS Serverless (更少责任&#x2F;更低灵活性)</li><li>考试提示: 快速部署 Web 应用 → App Engine; 需要完全控制 OS → Compute Engine</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img301220.png"></p><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img301222.png"></p><hr><h4 id="App-Engine-Environments"><a href="#App-Engine-Environments" class="headerlink" title="App Engine Environments"></a>App Engine Environments</h4><ul><li><strong>Standard Environment</strong> (标准环境): 特定语言沙箱运行 (Python&#x2F;Java&#x2F;Node.js&#x2F;PHP&#x2F;Ruby&#x2F;Go), 支持扩展到 0 实例, 启动快</li><li><strong>Flexible Environment</strong> (灵活环境): Docker 容器运行, 支持任何运行时, <strong>至少 1 个实例运行 (无法扩展到 0)</strong>, 启动较慢</li><li>考试提示: 扩展到 0 → Standard; 自定义运行时 → Flexible; <strong>Flexible 无法扩展到 0</strong></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img301229.png"></p><hr><h4 id="Google-Kubernetes-Engine-GKE"><a href="#Google-Kubernetes-Engine-GKE" class="headerlink" title="Google Kubernetes Engine (GKE)"></a>Google Kubernetes Engine (GKE)</h4><ul><li><strong>GKE</strong>: 托管的 Kubernetes 服务, Auto-repair (自动修复节点) + Auto-upgrade (自动升级 K8S) + Pod&#x2F;Cluster 自动扩展</li><li><strong>两种模式</strong>: Standard (用户管理&#x2F;更多控制) vs Autopilot (GKE 完全管理&#x2F;更少运维)</li><li>考试提示: 容器编排 → GKE; 完全托管零运维 → Autopilot</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img301247.png"></p><hr><h4 id="Cloud-Functions-GCF"><a href="#Cloud-Functions-GCF" class="headerlink" title="Cloud Functions (GCF)"></a>Cloud Functions (GCF)</h4><ul><li><strong>Cloud Functions</strong>: Serverless 事件驱动函数, 按使用付费, 无需管理服务器&#x2F;扩展&#x2F;可用性</li><li><strong>时间限制</strong>: 默认 1 分钟, <strong>最长 60 分钟 (3600 秒)</strong></li><li><strong>适用场景</strong>: 文件上传处理, 数据库更改触发, API 后端, 轻量级数据处理</li><li>考试提示: 事件驱动函数 → Cloud Functions; <strong>最长执行时间 60 分钟</strong></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img301310.png"></p><hr><h4 id="Cloud-Run-amp-Anthos"><a href="#Cloud-Run-amp-Anthos" class="headerlink" title="Cloud Run &amp; Anthos"></a>Cloud Run &amp; Anthos</h4><ul><li><strong>Cloud Run</strong>: 完全托管 Serverless 容器平台, 自动扩展 (包括扩展到 0), 按请求付费, 支持任何语言&#x2F;库</li><li><strong>Cloud Run for Anthos</strong>: 部署到本地或 Anthos 集群, 混合云和多云支持</li><li>考试提示: 快速运行单个容器 → Cloud Run; 混合云容器 → Cloud Run for Anthos</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img301319.png"></p><hr><h4 id="Compute-Service-in-GCP"><a href="#Compute-Service-in-GCP" class="headerlink" title="Compute Service in GCP"></a>Compute Service in GCP</h4><ul><li><strong>GCP 计算服务总结</strong><ul><li>虚拟机 → <strong>Compute Engine</strong></li><li>相似 VM 组 → <strong>Managed Instance Group</strong></li><li>负载分配 → <strong>Cloud Load Balancing</strong></li><li>Web 应用 PaaS → <strong>App Engine</strong></li><li>单个容器 Serverless → <strong>Cloud Run</strong></li><li>容器编排 → <strong>GKE</strong></li><li>事件驱动函数 → <strong>Cloud Functions</strong></li><li>多云&#x2F;本地 K8S → <strong>Anthos</strong></li></ul></li><li>考试提示: VM 控制 → Compute Engine; PaaS → App Engine; 容器编排 → GKE; 快速容器 → Cloud Run; 函数 → Cloud Functions; 混合云 → Anthos</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img301324.png"></p><hr><h3 id="5-Storage"><a href="#5-Storage" class="headerlink" title="5. Storage"></a>5. Storage</h3><h4 id="Block-Storage-amp-File-Storage"><a href="#Block-Storage-amp-File-Storage" class="headerlink" title="Block Storage &amp; File Storage"></a>Block Storage &amp; File Storage</h4><ul><li><strong>Persistent Disk</strong>: 网络块存储, Zonal&#x2F;Regional 可选, VM 删除后数据保留, 支持快照&#x2F;加密</li><li><strong>Local SSDs</strong>: 本地临时块存储, 物理连接 VM, 极高性能 (IOPS&#x2F;吞吐量), <strong>VM 删除后数据丢失</strong></li><li><strong>Filestore</strong>: 托管 NFS 文件服务器, 多 VM 同时访问, 适用于媒体渲染&#x2F;共享文件系统&#x2F;应用迁移</li><li>考试提示: 持久数据 → Persistent Disk; 极高性能临时 → Local SSDs; 共享文件 → Filestore</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/image/221039.png"></p><hr><h4 id="Cloud-Storage"><a href="#Cloud-Storage" class="headerlink" title="Cloud Storage"></a>Cloud Storage</h4><ul><li><strong>Cloud Storage</strong>: GCP 对象存储服务, 键值对存储大型对象, REST API 访问, 支持所有文件类型, 无限扩展&#x2F;高可用&#x2F;全球分布&#x2F;低延迟</li><li><strong>对象存储 vs 块存储</strong>: 对象 &#x3D; 完整文件 (照片&#x2F;视频&#x2F;备份); 块 &#x3D; 数据块 (VM 磁盘)</li><li><strong>适用场景</strong>: 静态网站托管, 媒体文件存储分发, 备份归档, 数据湖存储</li><li>考试提示: 非结构化数据 + 全球访问 → Cloud Storage</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/image/221435.png"></p><hr><h4 id="Storage-Classes"><a href="#Storage-Classes" class="headerlink" title="Storage Classes"></a>Storage Classes</h4><ul><li><strong>四种存储类别</strong> (根据访问频率优化成本)<ul><li><strong>Standard</strong>: 频繁访问, 无最短存储时间, 最高存储成本&#x2F;无访问费用</li><li><strong>Nearline</strong>: 每月访问一次, <strong>30 天</strong>最短存储时间, 较低存储成本&#x2F;访问需付费</li><li><strong>Coldline</strong>: 每季度访问一次, <strong>90 天</strong>最短存储时间, 更低存储成本&#x2F;更高访问费用</li><li><strong>Archive</strong>: 每年访问少于一次, <strong>365 天</strong>最短存储时间, 最低存储成本&#x2F;最高访问费用</li></ul></li><li>考试提示: 访问频率越低 → 存储成本越低&#x2F;访问费用越高; <strong>最短存储时间内删除仍需支付完整时间费用</strong></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img302211.png"></p><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img302214.png"></p><hr><h4 id="Object-Lifecycle-Management"><a href="#Object-Lifecycle-Management" class="headerlink" title="Object Lifecycle Management"></a>Object Lifecycle Management</h4><ul><li><strong>Object Lifecycle Management</strong>: 自动在存储类别之间转换对象以节省成本</li><li><strong>条件配置</strong>: Age (天数) &#x2F; CreatedBefore (日期) &#x2F; IsLive (最新版本) &#x2F; MatchesStorageClass &#x2F; NumberOfNewerVersions, 多个条件需同时满足</li><li><strong>操作类型</strong>: SetStorageClass (Standard → Nearline → Coldline → Archive 单向转换) &#x2F; Deletion (删除对象)</li><li><strong>典型场景</strong>: 日志文件 30 天后 → Nearline, 90 天后 → Coldline, 365 天后删除</li><li>考试提示: 自动成本优化 → Object Lifecycle Management; 可组合多个条件; <strong>单向转换</strong></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img302224.png"><br><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img3022226.png"></p><hr><h4 id="Transferring-Data-to-Cloud-Storage"><a href="#Transferring-Data-to-Cloud-Storage" class="headerlink" title="Transferring Data to Cloud Storage"></a>Transferring Data to Cloud Storage</h4><ul><li><strong>Online Transfer</strong>: gsutil&#x2F;Cloud Storage API, <strong>&lt; 1 TB</strong>, 通过互联网, 仅网络出口费用</li><li><strong>Storage Transfer Service</strong>: PB 级在线传输, <strong>1-20 TB</strong>, 从其他云 (AWS S3&#x2F;Azure Blob) 或私有数据中心, 支持计划&#x2F;增量传输</li><li><strong>Transfer Appliance</strong>: 物理设备传输, <strong>&gt; 20 TB 或传输时间 &gt; 1 周</strong>, 离线传输避免网络瓶颈</li><li>考试提示: &lt; 1 TB → Online Transfer; 1-20 TB → Storage Transfer Service; &gt; 20 TB 或网络慢 → Transfer Appliance; <strong>从其他云迁移 → Storage Transfer Service</strong></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img302228.png"></p><hr><h4 id="Storage-Services-Summary"><a href="#Storage-Services-Summary" class="headerlink" title="Storage Services Summary"></a>Storage Services Summary</h4><ul><li><strong>共享媒体&#x2F;大文件协作</strong> → <strong>Filestore</strong> (NFS 文件共享, 多 VM 访问)</li><li><strong>全球分发非结构化数据</strong> → <strong>Cloud Storage</strong> (成本效益&#x2F;无限扩展&#x2F;全球分布)</li><li><strong>自动转换存储类别降低成本</strong> → <strong>Object Lifecycle Management</strong> (基于访问频率优化)</li><li><strong>大规模数据迁移</strong> → <strong>Transfer Appliance</strong> (物理传输更快可靠)</li><li>考试提示: 文件共享 → Filestore; 对象存储 → Cloud Storage; 成本优化 → Lifecycle Management; &gt; 20 TB 迁移 → Transfer Appliance</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img302235.png"></p><hr><h3 id="6-Database-Fundamentals"><a href="#6-Database-Fundamentals" class="headerlink" title="6. Database Fundamentals"></a>6. Database Fundamentals</h3><h4 id="Cloud-SQL-amp-Cloud-Spanner-OLTP"><a href="#Cloud-SQL-amp-Cloud-Spanner-OLTP" class="headerlink" title="Cloud SQL &amp; Cloud Spanner (OLTP)"></a><code>Cloud SQL</code> &amp; <code>Cloud Spanner</code> (OLTP)</h4><ul><li><p><strong>事务型数据库 (OLTP)</strong>: 支持大量用户进行大量小型事务操作</p><ul><li>常用数据库: MySQL, Oracle, SQL Server</li></ul></li><li><p><strong>GCP 托管服务</strong></p><ul><li><code>Cloud SQL</code>: 区域级关系数据库，支持 PostgreSQL, MySQL, SQL Server</li><li><code>Cloud Spanner</code>: 全球级关系数据库，支持无限扩展 (PB 级) 和 99.999% 可用性，通过水平扩展实现</li><li>Cloud Spanner 跨区域实时复制数据</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img30224.png"></p><hr><h4 id="BigQuery-OLAP"><a href="#BigQuery-OLAP" class="headerlink" title="BigQuery (OLAP)"></a><code>BigQuery</code> (OLAP)</h4><ul><li><p><strong>分析型数据库 (OLAP)</strong>: 允许用户分析 PB 级数据</p><ul><li>适用场景: 报表应用、数据仓库、商业智能、分析系统</li></ul></li><li><p><strong>GCP 托管服务</strong></p><ul><li><code>BigQuery</code>: PB 级分布式数据仓库</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img302253.png"></p><hr><h4 id="OLAP-vs-OLTP"><a href="#OLAP-vs-OLTP" class="headerlink" title="OLAP vs OLTP"></a><code>OLAP</code> vs <code>OLTP</code></h4><ul><li><strong>OLAP 和 OLTP 数据结构相似，但存储方式不同</strong></li><li><strong>OLTP 数据库</strong>使用<code>行存储</code> (Row Storage)<ul><li>高效处理小型事务</li></ul></li><li><strong>OLAP 数据库</strong>使用<code>列存储</code> (Columnar Storage)<ul><li>高压缩率，分布式存储，单个查询可跨多个节点执行</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img302258.png"></p><hr><h4 id="Cloud-Firestore-vs-BigTable-NOSQL"><a href="#Cloud-Firestore-vs-BigTable-NOSQL" class="headerlink" title="Cloud Firestore vs BigTable (NOSQL)"></a><code>Cloud Firestore</code> vs <code>BigTable</code> (NOSQL)</h4><ul><li><strong>NoSQL 数据库</strong>: 牺牲”强一致性和 SQL 特性”以获得”可扩展性和高性能”</li><li>NoSQL &#x3D; Not Only SQL (不仅仅是 SQL)</li><li><strong>GCP 托管服务</strong>: <code>Cloud Firestore (Datastore)</code> &amp; <code>BigTable</code></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img302303.png"></p><ul><li><p><code>Cloud Datastore</code>: 托管的 Serverless NoSQL 文档数据库</p><ul><li>专为移动端和 Web 应用的<code>事务型</code>操作设计</li></ul></li><li><p><code>BigTable</code>: 托管的可扩展 NoSQL 宽列数据库</p><ul><li>适用于<code>大规模分析</code> (&gt; 10 TB) 和运营工作负载 (非 Serverless)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img302305.png"></p><hr><h4 id="Memory-Store-In-memory-Databases"><a href="#Memory-Store-In-memory-Databases" class="headerlink" title="Memory Store (In-memory Databases)"></a><code>Memory Store</code> (In-memory Databases)</h4><ul><li><strong>内存数据库</strong>: 从内存读取数据远快于从磁盘读取 (如 Redis)</li><li><strong>GCP 托管服务</strong>: <code>Memory Store</code></li><li><strong>使用场景</strong>: 缓存、会话管理、游戏排行榜、地理空间应用</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img302315.png"></p><hr><h4 id="Database-in-GCP"><a href="#Database-in-GCP" class="headerlink" title="Database in GCP"></a>Database in GCP</h4><ul><li><p><strong>关系型 OLTP 数据库</strong>: <code>Cloud SQL</code>, <code>Cloud Spanner</code></p><ul><li>预定义 Schema，强事务能力，行存储</li></ul></li><li><p><strong>关系型 OLAP 数据库</strong>: <code>BigQuery</code></p><ul><li>列存储，预定义 Schema，数据仓库和大数据工作负载</li></ul></li><li><p><strong>NoSQL 数据库</strong>: <code>Cloud Firestore (Datastore)</code>, <code>BigTable</code></p><ul><li>需要快速演进结构的应用 (Schema-less)</li></ul></li><li><p><strong>内存数据库&#x2F;缓存</strong>: <code>Memory Store</code></p><ul><li>需要微秒级响应的应用</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img302320.png"></p><hr><h3 id="7-IAM"><a href="#7-IAM" class="headerlink" title="7. IAM"></a>7. IAM</h3><h4 id="Cloud-IAM"><a href="#Cloud-IAM" class="headerlink" title="Cloud IAM"></a>Cloud IAM</h4><ul><li><strong>Cloud IAM</strong> (Identity and Access Management): GCP 用户身份识别和访问控制</li><li><strong>核心功能</strong>: 控制谁 (Who) 对哪些资源 (What) 执行哪些操作 (Action), 细粒度权限管理</li><li><strong>IAM 三要素</strong>: Members (成员) + Roles (角色) + Resources (资源)</li><li>考试提示: IAM 控制”谁”可以做”什么”</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img214925.png"></p><hr><h4 id="IAM-Example"><a href="#IAM-Example" class="headerlink" title="IAM Example"></a>IAM Example</h4><ul><li><strong>实际场景</strong>: 授予同事管理特定 Cloud Storage bucket 的权限</li><li><strong>操作步骤</strong>: 选择角色 (如 Storage Object Admin) → 创建 Policy 绑定成员和角色 → 应用到资源</li><li><strong>Roles (角色)</strong>: 权限集合, 通过 Policy 分配给成员</li><li>考试提示: 角色 &#x3D; 权限集合; Policy &#x3D; 绑定关系</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img225829.png"></p><hr><h4 id="IAM-Roles"><a href="#IAM-Roles" class="headerlink" title="IAM Roles"></a>IAM Roles</h4><ul><li><p><strong>Basic Roles</strong> (基本角色): Owner (完全控制) &#x2F; Editor (修改资源) &#x2F; Viewer (只读), 粗粒度, 不推荐生产环境</p></li><li><p><strong>Predefined Roles</strong> (预定义角色): Google 预定义的细粒度角色, 针对特定服务优化, 推荐使用</p></li><li><p><strong>Custom Roles</strong> (自定义角色): 用户自定义权限组合, 满足特殊需求</p></li><li><p>考试提示: 生产环境 → Predefined Roles; Basic Roles 权限过大不安全; 特殊需求 → Custom Roles</p></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img223152.png"></p><hr><h4 id="IAM-Policy"><a href="#IAM-Policy" class="headerlink" title="IAM Policy"></a>IAM Policy</h4><ul><li><strong>IAM Policy</strong>: 通过 JSON 文档分配角色, 包含 bindings (Members + Roles)</li><li><strong>Policy 特性</strong>: 可附加到资源 (Project&#x2F;Folder&#x2F;Organization), 支持继承, 可包含条件</li><li><strong>最佳实践</strong>: 使用组而非个人用户, 定期审查权限, 遵循最小权限原则</li><li>考试提示: Policy &#x3D; Members + Roles 的绑定关系</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img192908.png"><br><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img193029.png"></p><hr><h3 id="8-Encryption"><a href="#8-Encryption" class="headerlink" title="8. Encryption"></a>8. Encryption</h3><h4 id="Data-Lifecycle-States"><a href="#Data-Lifecycle-States" class="headerlink" title="Data Lifecycle States"></a>Data Lifecycle States</h4><ul><li><p><strong>Data at rest</strong> (静态数据): 存储在设备&#x2F;备份中, 风险是物理访问和未授权读取</p></li><li><p><strong>Data in motion</strong> (传输中数据): 通过网络传输, 风险是中间人攻击和网络窃听</p></li><li><p><strong>Data in use</strong> (使用中数据): 内存&#x2F;CPU 缓存中处理, 风险是内存转储和进程访问</p></li><li><p>考试提示: 三种数据状态都需要不同的加密保护策略</p></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img213355.png"></p><hr><h4 id="Encryption"><a href="#Encryption" class="headerlink" title="Encryption"></a>Encryption</h4><ul><li><strong>Symmetric Key Encryption</strong> (对称密钥加密): 相同密钥加密&#x2F;解密, 速度快适合大数据, 但密钥分发困难 (AES, DES)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img213908.png"></p><ul><li><p><strong>Asymmetric Key Encryption</strong> (非对称密钥加密): 公钥加密私钥解密, 密钥分发安全支持数字签名, 但速度慢 (RSA, ECC)</p></li><li><p>考试提示: 对称加密 → 速度快适合大数据; 非对称加密 → 安全性高适合密钥交换</p></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img213915.png"></p><hr><h4 id="Cloud-KMS"><a href="#Cloud-KMS" class="headerlink" title="Cloud KMS"></a>Cloud KMS</h4><ul><li><p><strong>Cloud KMS</strong> (Key Management Service): 创建和管理加密密钥 (对称&#x2F;非对称)</p></li><li><p><strong>核心功能</strong>: 集中管理密钥, 自动密钥轮换, 审计使用情况, 与 GCP 服务集成</p></li><li><p><strong>密钥层级</strong>: Key Ring (逻辑分组) → Key (密钥本身) → Key Version (支持轮换)</p></li><li><p><strong>加密选项</strong></p><ul><li><strong>GMEK</strong>: Google 自动管理 (默认加密)</li><li><strong>CMEK</strong>: 客户通过 Cloud KMS 管理 (需要控制密钥)</li><li><strong>CSEK</strong>: 客户完全自行管理 (完全自主控制)</li></ul></li><li><p>考试提示: 需要控制密钥 → CMEK; 完全自行管理 → CSEK; 默认加密 → GMEK</p></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img214128.png"></p><hr><h3 id="9-Organizing-GCP-Resources"><a href="#9-Organizing-GCP-Resources" class="headerlink" title="9. Organizing GCP Resources"></a>9. Organizing GCP Resources</h3><h4 id="Resource-Hierarchy"><a href="#Resource-Hierarchy" class="headerlink" title="Resource Hierarchy"></a>Resource Hierarchy</h4><ul><li><strong>GCP 资源层级结构</strong>: <code>Organization &gt; Folder &gt; Project &gt; Resources</code></li><li><strong>Organization</strong> (组织): 最顶层, 代表整个公司, 统一管理和权限控制</li><li><strong>Folder</strong> (文件夹): 组织资源的逻辑分组 (部门&#x2F;环境)</li><li><strong>Project</strong> (项目): 资源的基本组织单位, 所有资源必须在其中创建</li><li><strong>Resources</strong> (资源): 具体的 GCP 服务 (VM, Storage 等)</li><li><strong>关键特性</strong>: IAM 权限继承 - 子资源自动继承父资源权限</li><li>考试提示: 层级结构实现统一管理; 权限从上到下继承</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/image/205244.png"></p><hr><h4 id="Billing-Accounts"><a href="#Billing-Accounts" class="headerlink" title="Billing Accounts"></a>Billing Accounts</h4><ul><li><strong>Billing Account</strong> (计费账户): 创建 GCP 资源的强制要求</li><li><strong>核心功能</strong>: 跟踪费用, 关联多个 Project, 支持预算控制</li><li><strong>Cloud Billing Budget</strong>: 设置预算阈值, 配置警报 (50%&#x2F;90%&#x2F;100%), 避免意外超支</li><li><strong>关键区别</strong>: 一个 Billing Account 可关联多个 Project, 统一付费</li><li>考试提示: 创建资源必须有 Billing Account; Budget Alerts 控制成本</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img215548.png"></p><hr><h4 id="IAM-Best-Practices"><a href="#IAM-Best-Practices" class="headerlink" title="IAM Best Practices"></a>IAM Best Practices</h4><ul><li><p><strong>IAM 最佳实践</strong>: 确保 GCP 环境安全和合规</p></li><li><p><strong>Principle of Least Privilege</strong> (最小权限原则): 仅授予完成工作所需的最小权限, 避免使用 Owner 角色</p></li><li><p><strong>Separation of Duties</strong> (职责分离): 敏感操作至少 2 人参与, 避免单点权限风险</p></li><li><p><strong>Constant Monitoring</strong> (持续监控): 使用 Cloud Audit Logs 审计策略变更, 检测异常权限</p></li><li><p>考试提示: 最小权限 + 职责分离 + 持续监控 &#x3D; IAM 安全三要素</p></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img215956.png"></p><hr><h4 id="Public-Private-Hybrid-Cloud"><a href="#Public-Private-Hybrid-Cloud" class="headerlink" title="Public, Private, Hybrid Cloud"></a>Public, Private, Hybrid Cloud</h4><ul><li><p><strong>Public Cloud</strong> (公有云): 资源托管在云提供商数据中心, 按需付费, 无需自建基础设施</p></li><li><p><strong>Private Cloud</strong> (私有云): 资源在企业自有数据中心, 完全控制, 高成本高合规性</p></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img220218.png"></p><ul><li><p><strong>Hybrid Cloud</strong> (混合云): 公有云 + 私有云组合, 敏感数据本地 + 其他服务上云</p></li><li><p><strong>Multi Cloud</strong> (多云): 同时使用多个云提供商 (GCP + AWS + Azure), 避免供应商锁定</p></li><li><p><strong>关键区别</strong>: Hybrid &#x3D; 本地 + 单一云; Multi &#x3D; 多个云提供商</p></li><li><p>考试提示: Hybrid Cloud &#x3D; 公有 + 私有; Multi Cloud &#x3D; 多个提供商</p></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img220429.png"></p><hr><h4 id="Cloud-VPN"><a href="#Cloud-VPN" class="headerlink" title="Cloud VPN"></a>Cloud VPN</h4><ul><li><strong>Cloud VPN</strong>: 通过 IPsec 加密隧道连接本地网络与 GCP VPC</li><li><strong>核心特性</strong>: 经过公共互联网, 成本低, 带宽受限 (&lt; 3 Gbps)</li><li><strong>关键限制</strong>: 依赖公共互联网 - 可能有延迟和不稳定性</li><li>考试提示: 低成本低带宽 → Cloud VPN; 不想经过互联网 → Cloud Interconnect</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img221047.png"></p><hr><h4 id="Cloud-Interconnect"><a href="#Cloud-Interconnect" class="headerlink" title="Cloud Interconnect"></a>Cloud Interconnect</h4><ul><li><strong>Cloud Interconnect</strong>: 本地与 GCP 之间的高速物理专线, 不经过公共互联网</li><li><strong>Dedicated Interconnect</strong>: 直连 Google 网络 (10&#x2F;100 Gbps)</li><li><strong>Partner Interconnect</strong>: 通过服务提供商连接 (50 Mbps - 10 Gbps)</li><li><strong>关键优势</strong>: 高带宽, 低延迟, 私有连接, 更稳定</li><li><strong>与 VPN 对比</strong>: Interconnect &#x3D; 高成本高性能私有; VPN &#x3D; 低成本低性能公共</li><li>考试提示: 高带宽&#x2F;低延迟&#x2F;私有连接 → Cloud Interconnect</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img221231.png"></p><hr><h4 id="Private-Google-Access"><a href="#Private-Google-Access" class="headerlink" title="Private Google Access"></a>Private Google Access</h4><ul><li><strong>Private Google Access</strong>: 允许无外部 IP 的实例访问 Google API 和服务</li><li><strong>核心功能</strong>: 使用私有 IP 访问 Cloud Storage&#x2F;BigQuery 等, 流量不经过公共互联网</li><li><strong>配置方式</strong>: 在 VPC 子网级别启用, 应用于整个子网</li><li>考试提示: 无外部 IP 访问 Google 服务 → Private Google Access</li></ul><hr><h4 id="Network-Service-Tier"><a href="#Network-Service-Tier" class="headerlink" title="Network Service Tier"></a>Network Service Tier</h4><ul><li><p><strong>Standard Tier</strong> (标准层级): 使用公共互联网路由, 区域级网络, 低成本</p></li><li><p><strong>Premium Tier</strong> (高级层级): 使用 Google 全球私有网络, 低延迟高性能, 高成本</p></li><li><p><strong>关键区别</strong>: Standard &#x3D; 公共互联网路由; Premium &#x3D; Google 骨干网路由</p></li><li><p>考试提示: 成本优先 → Standard; 性能优先&#x2F;全球业务 → Premium</p></li></ul><hr><h4 id="Organization-Policy-Service"><a href="#Organization-Policy-Service" class="headerlink" title="Organization Policy Service"></a>Organization Policy Service</h4><ul><li><p><strong>Organization Policy Service</strong>: 对 Organization 所有资源实施集中约束和限制</p></li><li><p><strong>核心功能</strong>: 在 Organization 级别配置统一策略, 限制资源创建 (如禁止外部 IP, 限制区域)</p></li><li><p><strong>配置要求</strong>: Organization Policy Administrator 角色, 在 Organization 级别设置</p></li><li><p><strong>与 IAM 的关键区别</strong>: IAM 控制 “谁” (Who), Organization Policy 控制 “什么” (What)</p></li><li><p>考试提示: 集中约束控制 → Organization Policy; IAM &#x3D; WHO, Policy &#x3D; WHAT</p></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img222036.png"></p><hr><h4 id="Corporate-Directory-Federation"><a href="#Corporate-Directory-Federation" class="headerlink" title="Corporate Directory Federation"></a>Corporate Directory Federation</h4><ul><li><p><strong>Corporate Directory Federation</strong>: 将企业 Active Directory 与 GCP 集成, 实现单点登录 (SSO)</p></li><li><p><strong>核心功能</strong>: 联合 Cloud Identity&#x2F;Google Workspace 与外部 IdP (AD, Azure AD), 自动同步用户</p></li><li><p><strong>关键优势</strong>: 无需为 GCP 单独创建账户; 员工离职在 AD 中禁用即失去 GCP 访问权限</p></li><li><p>考试提示: 企业 AD 集成 → Corporate Directory Federation</p></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img222636.png"></p><hr><h4 id="Identity-Aware-Proxy-IAP"><a href="#Identity-Aware-Proxy-IAP" class="headerlink" title="Identity Aware Proxy (IAP)"></a>Identity Aware Proxy (IAP)</h4><ul><li><p><strong>Identity-Aware Proxy (IAP)</strong>: 基于身份控制应用访问, 无需 VPN</p></li><li><p><strong>核心功能</strong>: 在应用前提供安全访问层, 验证用户身份后授权访问后端应用</p></li><li><p><strong>关键优势</strong>: 零信任模型, 无需配置 VPN 或防火墙, 集成 Cloud IAM</p></li><li><p>考试提示: 保护应用访问 + 无需 VPN → IAP</p></li></ul><hr><h4 id="Identity-Platform"><a href="#Identity-Platform" class="headerlink" title="Identity Platform"></a>Identity Platform</h4><ul><li><p><strong>Identity Platform</strong>: 客户身份和访问管理 (CIAM), 处理客户用户的身份验证和授权</p></li><li><p><strong>核心功能</strong>: 用户注册&#x2F;登录&#x2F;密码重置, 支持多种身份提供商 (Google, Facebook, GitHub)</p></li><li><p><strong>与 Cloud IAM 的关键区别</strong>: Cloud IAM → 员工&#x2F;内部资源; Identity Platform → 客户&#x2F;外部用户</p></li><li><p>考试提示: Cloud IAM &#x3D; 内部; Identity Platform &#x3D; 客户&#x2F;外部</p></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img222236.png"></p><hr><h3 id="10-DevOps"><a href="#10-DevOps" class="headerlink" title="10. DevOps"></a>10. DevOps</h3><h4 id="CI-CD-Tools"><a href="#CI-CD-Tools" class="headerlink" title="CI, CD Tools"></a>CI, CD Tools</h4><ul><li><strong>Cloud Source Repositories</strong>: 私有 Git 仓库, 代码托管</li><li><strong>Container Registry</strong>: 存储 Docker 镜像</li><li><strong>Cloud Build</strong>: 构建可部署工件, 自动化 CI&#x2F;CD</li><li>考试提示: Cloud Build → CI&#x2F;CD 自动化</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/image/224404.png"></p><hr><h4 id="Cloud-Build"><a href="#Cloud-Build" class="headerlink" title="Cloud Build"></a>Cloud Build</h4><ul><li><strong>Cloud Build</strong>: 完全托管的 CI&#x2F;CD 平台</li><li>自动化构建、测试、部署应用程序</li><li>支持多种语言, 与 GitHub&#x2F;Bitbucket 集成</li><li>考试提示: 自动化 CI&#x2F;CD → Cloud Build</li></ul><hr><h4 id="Cloud-Deployment-Manager"><a href="#Cloud-Deployment-Manager" class="headerlink" title="Cloud Deployment Manager"></a>Cloud Deployment Manager</h4><ul><li><strong>Cloud Deployment Manager</strong>: 使用模板自动化部署 GCP 资源</li><li>使用 YAML&#x2F;Python 定义基础设施 (Infrastructure as Code)</li><li><strong>重要</strong>: 不用于构建和测试, 只部署基础设施</li><li>考试提示: IaC 部署 → Deployment Manager; 构建 → Cloud Build</li></ul><hr><h4 id="Container-Registry-and-Artifact-Registry"><a href="#Container-Registry-and-Artifact-Registry" class="headerlink" title="Container Registry and Artifact Registry"></a>Container Registry and Artifact Registry</h4><ul><li><strong>Container Registry</strong>: 仅支持容器镜像</li><li><strong>Artifact Registry</strong>: 支持容器 + 其他工件 (Maven, npm, Python 等)</li><li>新项目推荐 Artifact Registry</li><li>考试提示: 仅容器 → Container Registry; 容器 + 其他 → Artifact Registry</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/image/224539.png"></p><hr><h4 id="Infrastructure-as-Code"><a href="#Infrastructure-as-Code" class="headerlink" title="Infrastructure as Code"></a>Infrastructure as Code</h4><ul><li><strong>IaC</strong>: 用代码管理基础设施</li><li><strong>核心优势</strong>: 可重复 + 版本控制 + 自动化</li><li><strong>GCP 服务</strong>: <code>Deployment Manager</code></li><li>考试提示: IaC → Deployment Manager</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img326721.png"></p><hr><h4 id="Cloud-Operations-amp-Insights"><a href="#Cloud-Operations-amp-Insights" class="headerlink" title="Cloud Operations &amp; Insights"></a>Cloud Operations &amp; Insights</h4><ul><li><strong>Cloud Monitoring</strong>: 监控指标和警报</li><li><strong>Cloud Logging</strong>: 集中式日志</li><li><strong>Cloud Audit Logs</strong>: 审计日志</li><li><strong>Error Reporting</strong>: 实时异常监控</li><li><strong>Cloud Debugger</strong>: 生产环境实时调试</li><li><strong>Cloud Trace</strong>: 分布式追踪</li><li><strong>Cloud Profiler</strong>: 性能分析</li><li>考试提示: 监控 → Monitoring; 日志 → Logging; 调试 → Debugger; 追踪 → Trace</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img326823.png"></p><hr><h4 id="Site-Reliability-Engineering-SRE"><a href="#Site-Reliability-Engineering-SRE" class="headerlink" title="Site Reliability Engineering (SRE)"></a>Site Reliability Engineering (SRE)</h4><ul><li><strong>SRE</strong>: 通过软件工程实践确保系统可靠性</li><li><strong>核心原则</strong>: SLO 驱动 + 自动化 + 最小化繁重工作 + 共享责任</li><li>考试提示: SRE → 可靠性工程</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img326826.png"></p><hr><h4 id="SRE-Key-Metrics"><a href="#SRE-Key-Metrics" class="headerlink" title="SRE - Key Metrics"></a>SRE - Key Metrics</h4><ul><li><strong>SLI</strong> (服务级别指标): 量化度量 (可用性, 延迟, 吞吐量等)</li><li><strong>SLO</strong> (服务级别目标): SLI + 目标值 (内部目标)</li><li><strong>SLA</strong> (服务级别协议): SLO + 违约后果 (对外合同)</li><li><strong>Error Budget</strong> (错误预算): 100% - SLO</li><li>考试提示: SLI &#x3D; 度量; SLO &#x3D; 内部目标; SLA &#x3D; 外部合同; Error Budget &#x3D; 允许失败</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img326829.png"></p><hr><h4 id="SRE-Best-Practices"><a href="#SRE-Best-Practices" class="headerlink" title="SRE - Best Practices"></a>SRE - Best Practices</h4><ul><li><strong>Load Shedding</strong>: 拒绝部分请求保护系统</li><li><strong>Reduced Quality of Service</strong>: 降级服务</li><li><strong>Avoiding Cascading Failures</strong>: 熔断器 + 超时重试</li><li><strong>Penetration Testing</strong>: 渗透测试</li><li><strong>Load Testing</strong>: 负载测试 (JMeter, Gatling 等)</li><li><strong>Resilience Testing</strong>: 弹性测试 (混沌工程)</li><li>考试提示: 过载 → Load Shedding; 级联故障 → 熔断器</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img326832.png"><br><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img326333.png"><br><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img326834.png"></p><hr><h4 id="Single-Sign-On-SSO"><a href="#Single-Sign-On-SSO" class="headerlink" title="Single Sign-On (SSO)"></a>Single Sign-On (SSO)</h4><ul><li><strong>SSO</strong>: 一组凭据访问多个应用</li><li>员工 AD 账户禁用时自动失去所有 GCP 访问权限</li><li>考试提示: SSO + AD → 离职自动失去访问</li></ul><hr><h4 id="Google-Cloud-Directory-Sync"><a href="#Google-Cloud-Directory-Sync" class="headerlink" title="Google Cloud Directory Sync"></a>Google Cloud Directory Sync</h4><ul><li><strong>GCDS</strong>: 同步 LDAP&#x2F;AD 目录到 Google Cloud</li><li>单向同步: LDAP → Google Cloud</li><li><strong>GCDS vs SSO</strong>: GCDS 同步用户信息, SSO 处理身份验证</li><li>考试提示: LDAP 同步 → GCDS; 身份验证 → SSO</li></ul><hr><h3 id="11-Pub-x2F-Sub"><a href="#11-Pub-x2F-Sub" class="headerlink" title="11. Pub&#x2F;Sub"></a>11. Pub&#x2F;Sub</h3><h4 id="Synchronous-vs-Asynchronous-Communication"><a href="#Synchronous-vs-Asynchronous-Communication" class="headerlink" title="Synchronous vs Asynchronous Communication"></a>Synchronous vs Asynchronous Communication</h4><ul><li><strong>Synchronous Communication</strong> (同步通信)<ul><li>应用直接调用日志服务</li><li>问题: 如果日志服务宕机怎么办?</li><li>耦合度高, 依赖性强</li><li>服务故障会影响调用方</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img329122.png"></p><ul><li><strong>Asynchronous Communication</strong> (异步通信)<ul><li>创建主题 (Topic), 应用发送日志消息到主题</li><li>日志服务准备好时再处理消息</li><li>解耦发送方和接收方</li><li>提高系统可靠性和弹性</li></ul></li><li>考试提示: 解耦服务 → 异步通信; 异步消息 → Pub&#x2F;Sub</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img329123.png"></p><hr><h4 id="Pub-x2F-Sub"><a href="#Pub-x2F-Sub" class="headerlink" title="Pub&#x2F;Sub"></a>Pub&#x2F;Sub</h4><ul><li><strong>Pub&#x2F;Sub</strong>: 可靠、可扩展、完全托管的异步消息服务</li><li><strong>核心功能</strong><ul><li>高可用和高扩展解决方案的支柱</li><li>流式分析管道的事件摄取和分发</li><li>至少一次消息传递保证</li><li>全球分布式架构</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img329125.png"></p><ul><li><p><strong>Pub&#x2F;Sub 组件</strong></p><ul><li><strong>Publisher</strong> (发布者): 消息发送方</li><li><strong>Subscriber</strong> (订阅者): 消息接收方<ul><li><strong>Pull</strong> (拉取): 订阅者准备好时主动拉取消息</li><li><strong>Push</strong> (推送): 消息自动推送到订阅者</li></ul></li><li><strong>Topic</strong> (主题): 消息发布的通道</li><li><strong>Subscription</strong> (订阅): 接收消息的端点</li></ul></li><li><p><strong>使用场景</strong></p><ul><li>微服务解耦</li><li>事件驱动架构</li><li>流数据处理</li><li>任务队列</li></ul></li><li><p>考试提示: 异步消息 → Pub&#x2F;Sub; 解耦服务 → Pub&#x2F;Sub; Pull vs Push</p></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img329127.png"></p><hr><h4 id="Cloud-Dataflow"><a href="#Cloud-Dataflow" class="headerlink" title="Cloud Dataflow"></a>Cloud Dataflow</h4><ul><li><p><strong>Cloud Dataflow</strong>: Serverless 流式和批量数据处理服务</p></li><li><p><strong>基于 Apache Beam</strong> (开源统一编程模型)</p></li><li><p><strong>核心功能</strong></p><ul><li>统一的流式和批处理</li><li>自动扩展和资源管理</li><li>与 GCP 服务深度集成</li><li>实时数据转换和聚合</li></ul></li><li><p><strong>常见数据流</strong></p><ul><li><strong>流式处理</strong>: Pub&#x2F;Sub → Dataflow → BigQuery</li><li><strong>流式文件</strong>: Pub&#x2F;Sub → Dataflow → Cloud Storage</li><li><strong>批处理</strong>: Cloud Storage → Dataflow → Bigtable&#x2F;Cloud Spanner&#x2F;Datastore&#x2F;BigQuery</li></ul></li><li><p><strong>使用场景</strong></p><ul><li>ETL (Extract, Transform, Load) 数据管道</li><li>实时数据分析</li><li>数据清洗和转换</li><li>流式数据聚合</li></ul></li><li><p>考试提示: ETL 管道 → Dataflow; 流式 + 批处理 → Dataflow; Apache Beam</p></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img329132.png"></p><hr><h3 id="12-Data-Architectures-in-GCP"><a href="#12-Data-Architectures-in-GCP" class="headerlink" title="12. Data Architectures in GCP"></a>12. Data Architectures in GCP</h3><h4 id="Loose-Coupling-with-Pub-x2F-Sub"><a href="#Loose-Coupling-with-Pub-x2F-Sub" class="headerlink" title="Loose Coupling with Pub&#x2F;Sub"></a>Loose Coupling with Pub&#x2F;Sub</h4><ul><li><strong>解耦架构</strong>: 使用 Pub&#x2F;Sub 解耦发布者和订阅者, 独立扩展</li><li><strong>关键优势</strong>: 服务故障不影响其他组件, 支持多个订阅者, 提高弹性</li><li>考试提示: 解耦服务 → Pub&#x2F;Sub</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img329137.png"></p><hr><h4 id="Data-Formats"><a href="#Data-Formats" class="headerlink" title="Data Formats"></a>Data Formats</h4><ul><li><strong>Structured</strong> (结构化): 表格&#x2F;行&#x2F;列 → <code>Cloud SQL</code>, <code>Cloud Spanner</code>, <code>BigQuery</code></li><li><strong>Semi Structured</strong> (半结构化): 灵活 Schema → <code>Cloud Firestore/Datastore</code></li><li><strong>Unstructured</strong> (非结构化): 视频&#x2F;音频&#x2F;图片&#x2F;文本 → <code>Cloud Storage</code></li><li>考试提示: 结构化 → 关系数据库; 非结构化 → Cloud Storage</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img329124.png"></p><hr><h4 id="Cloud-Dataproc"><a href="#Cloud-Dataproc" class="headerlink" title="Cloud Dataproc"></a>Cloud Dataproc</h4><ul><li><strong>Cloud Dataproc</strong>: 托管的 Spark 和 Hadoop 服务, 用于复杂批处理</li><li><strong>关键特性</strong>: 快速创建集群, 按使用付费, 支持现有 Hadoop&#x2F;Spark 作业</li><li>考试提示: Spark&#x2F;Hadoop → Dataproc; Serverless ETL → Dataflow</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img329211.png"></p><hr><h4 id="Big-Data-Flow-Batch-Ingest"><a href="#Big-Data-Flow-Batch-Ingest" class="headerlink" title="Big Data Flow - Batch Ingest"></a>Big Data Flow - Batch Ingest</h4><ul><li><strong>批量数据摄取</strong>: ETL 加载数据到 BigQuery</li><li><strong>Dataprep</strong>: 清理和准备数据 (可视化数据准备)</li><li><strong>Dataflow</strong>: 创建数据管道和 ETL (Serverless)</li><li><strong>Dataproc</strong>: 复杂处理 (Spark&#x2F;Hadoop)</li><li>考试提示: 可视化清理 → Dataprep; ETL 管道 → Dataflow; Spark → Dataproc</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img329213.png"></p><hr><h4 id="Streaming-Data"><a href="#Streaming-Data" class="headerlink" title="Streaming Data"></a>Streaming Data</h4><ul><li><strong>流式数据处理</strong>: Pub&#x2F;Sub (接收消息) → Dataflow (分析&#x2F;聚合&#x2F;过滤)</li><li><strong>存储选择</strong>: 预定义时序查询 → Bigtable; 复杂即席分析 → BigQuery</li><li>考试提示: 流式处理 → Pub&#x2F;Sub + Dataflow; 时序 → Bigtable; 即席分析 → BigQuery</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img329215.png"></p><hr><h4 id="IoT"><a href="#IoT" class="headerlink" title="IoT"></a>IoT</h4><ul><li><strong>IoT 数据流</strong>: IoT Core (设备管理) → Pub&#x2F;Sub (消息缓冲) → Dataflow (数据处理)</li><li><strong>存储和分析</strong><ul><li>移动&#x2F;Web 应用访问 → Datastore</li><li>预定义时序查询 → Bigtable</li><li>复杂即席分析 → BigQuery</li></ul></li><li>考试提示: IoT 设备 → IoT Core; 缓冲 → Pub&#x2F;Sub; ETL → Dataflow</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img329216.png"></p><hr><h4 id="Data-Lake"><a href="#Data-Lake" class="headerlink" title="Data Lake"></a>Data Lake</h4><ul><li><strong>Data Lake</strong> (数据湖): 数据存储 + 管理 + 分析的统一平台</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img329228.png"></p><ul><li><strong>存储</strong>: Cloud Storage (低成本 + 高可用 + 灵活处理)</li><li><strong>数据摄取</strong>: 流式 → Pub&#x2F;Sub + Dataflow; 批量 → Transfer Service&#x2F;Appliance&#x2F;gsutil</li><li><strong>处理和分析</strong>: SQL 查询 → BigQuery; Hive → Dataproc</li><li><strong>数据探索</strong>: 清理转换 → Dataprep; 数据科学 → Cloud Datalab (TensorFlow&#x2F;NumPy)</li><li>考试提示: 数据湖存储 → Cloud Storage; 分析 → BigQuery</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img329220.png"></p><hr><h4 id="Data-Governance"><a href="#Data-Governance" class="headerlink" title="Data Governance"></a>Data Governance</h4><ul><li><strong>Data Governance</strong> (数据治理): 确保数据质量和安全</li><li><strong>核心问题</strong>: 坏数据 → 错误决策; 数据泄露 → 声誉损失</li><li>考试提示: 数据质量和安全 → Data Governance</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img329222.png"></p><hr><h4 id="Dataplex"><a href="#Dataplex" class="headerlink" title="Dataplex"></a>Dataplex</h4><ul><li><strong>Dataplex</strong>: 统一数据管理平台 (Data Mesh), 可视化所有数据资产</li><li><strong>核心功能</strong>: 集中管理数据湖、数据仓库等所有数据资产</li><li>考试提示: 统一数据管理 → Dataplex</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img329224.png"></p><hr><h3 id="13-API-Management-in-GCP"><a href="#13-API-Management-in-GCP" class="headerlink" title="13. API Management in GCP"></a>13. API Management in GCP</h3><h4 id="API-Management"><a href="#API-Management" class="headerlink" title="API Management"></a>API Management</h4><ul><li><strong>Apigee API Management</strong>: 全功能 API 管理平台, 企业级解决方案</li><li><strong>Cloud Endpoints</strong>: 基础 API 管理, 适用于 GCP 后端</li><li><strong>API Gateway</strong>: 更新更简单的 API 管理, 适用于 GCP 后端</li><li><strong>关键区别</strong>: Apigee &#x3D; 企业级全功能; Endpoints&#x2F;Gateway &#x3D; 轻量级 GCP 后端</li><li>考试提示: 企业级 API 管理 → Apigee; GCP 后端 → Endpoints&#x2F;Gateway</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img329226.png"></p><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img329229.png"></p><hr><h3 id="14-Trust-and-Security-with-GCP"><a href="#14-Trust-and-Security-with-GCP" class="headerlink" title="14. Trust and Security with GCP"></a>14. Trust and Security with GCP</h3><h4 id="Cloud-Security"><a href="#Cloud-Security" class="headerlink" title="Cloud Security"></a>Cloud Security</h4><ul><li><strong>云安全五要素</strong><ul><li><strong>Control</strong> (控制): 决定谁可以访问</li><li><strong>Compliance</strong> (合规): 遵循法律法规</li><li><strong>Confidentiality</strong> (机密性): 保护信息私密</li><li><strong>Integrity</strong> (完整性): 确保数据准确</li><li><strong>Availability</strong> (可用性): 确保应用和数据始终可用</li></ul></li><li>考试提示: 云安全 &#x3D; Control + Compliance + Confidentiality + Integrity + Availability</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img329315.png"></p><hr><h4 id="Enhanced-Security-with-2SV"><a href="#Enhanced-Security-with-2SV" class="headerlink" title="Enhanced Security with 2SV"></a>Enhanced Security with 2SV</h4><ul><li><strong>2SV</strong> (两步验证): 添加第二步验证用户身份, 提高账户安全性</li><li><strong>最佳实践</strong>: 对 Google Cloud 账户强制启用 2SV</li><li>考试提示: 账户安全 → 2SV 强制启用</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img329317.png"></p><hr><h4 id="Security-Command-Center"><a href="#Security-Command-Center" class="headerlink" title="Security Command Center"></a>Security Command Center</h4><ul><li><strong>Security Command Center (SCC)</strong>: 提供 GCP 资源安全状态的全面视图</li><li><strong>核心功能</strong>: 检测和响应威胁, 报告安全发现, 确保合规性</li><li><strong>关键优势</strong>: 跨多个项目的集中式安全监控和洞察</li><li>考试提示: 集中式安全监控 → Security Command Center</li></ul><hr><h4 id="Google-Cloud-Armor"><a href="#Google-Cloud-Armor" class="headerlink" title="Google Cloud Armor"></a>Google Cloud Armor</h4><ul><li><strong>Google Cloud Armor</strong>: 保护 Web 应用免受 DDoS 攻击和 Web 威胁</li><li><strong>核心功能</strong>: IP 黑白名单, 速率限制, 应用层流量监控</li><li>考试提示: DDoS 防护 + Web 应用安全 → Cloud Armor</li></ul><hr><h4 id="Cloud-Data-Loss-Prevention"><a href="#Cloud-Data-Loss-Prevention" class="headerlink" title="Cloud Data Loss Prevention"></a>Cloud Data Loss Prevention</h4><ul><li><strong>Cloud Data Loss Prevention (DLP)</strong>: 识别、分类和保护敏感信息 (包括 PII)</li><li><strong>核心功能</strong>: 发现敏感数据, 分类数据, 屏蔽敏感信息</li><li>考试提示: PII 保护 + 敏感数据 → Cloud DLP</li></ul><hr><h4 id="GCP-Security-Offerings"><a href="#GCP-Security-Offerings" class="headerlink" title="GCP Security Offerings"></a>GCP Security Offerings</h4><ul><li><strong>KMS</strong>: 创建和管理加密密钥 (对称&#x2F;非对称), 控制密钥使用</li><li><strong>Secret Manager</strong>: 安全管理数据库密码和 API 密钥</li><li><strong>Cloud Data Loss Prevention</strong>: 发现、分类、屏蔽敏感数据</li><li><strong>Cloud Armor</strong>: 保护生产应用免受 DDoS 和 Web 攻击</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img329326.png"></p><ul><li><p><strong>Web Security Scanner</strong>: 运行安全测试识别漏洞</p></li><li><p><strong>Binary Authorization</strong>: 确保仅部署受信任的容器镜像</p></li><li><p><strong>Container Threat Detection</strong>: 检测容器运行时攻击</p></li><li><p><strong>Security Command Center</strong>: 获取 GCP 安全的集中视图</p></li><li><p>考试提示</p><ul><li>密钥管理 → KMS</li><li>密码管理 → Secret Manager</li><li>PII 保护 → DLP</li><li>DDoS 防护 → Cloud Armor</li><li>集中安全 → Security Command Center</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img329328.png"></p><hr><h4 id="Zero-Trust-Security-Model"><a href="#Zero-Trust-Security-Model" class="headerlink" title="Zero Trust Security Model"></a>Zero Trust Security Model</h4><ul><li>Zero Trust - “No person or device should be trusted by default, even if they are already inside an organization’s network”</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img329329.png"></p><hr><h3 id="15-ML-in-GCP"><a href="#15-ML-in-GCP" class="headerlink" title="15. ML in GCP"></a>15. ML in GCP</h3><h4 id="ML-in-GCP-Pre-Trained"><a href="#ML-in-GCP-Pre-Trained" class="headerlink" title="ML in GCP - Pre-Trained"></a>ML in GCP - Pre-Trained</h4><ul><li><strong>预训练 API</strong> (无需训练模型, 直接使用)<ul><li><strong>Speech-to-Text API</strong>: 语音转文本</li><li><strong>Text-to-Speech API</strong>: 文本转语音</li><li><strong>Translation API</strong>: 翻译 100+ 种语言</li><li><strong>Natural Language API</strong>: 从非结构化文本中提取洞察</li><li><strong>Cloud Vision API</strong>: 通用图像识别</li></ul></li><li>考试提示: 通用场景无需训练 → 预训练 API</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img329333.png"></p><hr><h4 id="ML-in-GCP-Custom-Models"><a href="#ML-in-GCP-Custom-Models" class="headerlink" title="ML in GCP - Custom Models"></a>ML in GCP - Custom Models</h4><ul><li><p><strong>AutoML</strong>: 用最少的 ML 专业知识构建自定义模型</p><ul><li><strong>AutoML Vision</strong>: 基于图像构建自定义模型 (专用图像识别场景)</li><li><strong>AutoML Video Intelligence</strong>: 为视频添加标签</li><li><strong>AutoML Tables</strong>: 在结构化数据上自动构建模型</li></ul></li><li><p><strong>BigQuery ML</strong>: 使用 SQL 查询构建 ML 模型</p></li><li><p><strong>Vertex AI</strong>: 更快构建和部署 ML 模型 (完整的 MLOps 平台)</p></li><li><p>考试提示</p><ul><li>专用图像识别 → AutoML Vision</li><li>结构化数据 → AutoML Tables</li><li>SQL 构建模型 → BigQuery ML</li><li>完整 MLOps → Vertex AI</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img329325.png"></p><hr><h3 id="16-Cloud-Native"><a href="#16-Cloud-Native" class="headerlink" title="16. Cloud Native"></a>16. Cloud Native</h3><h4 id="Cloud-Native-Pillars"><a href="#Cloud-Native-Pillars" class="headerlink" title="Cloud Native Pillars"></a>Cloud Native Pillars</h4><ul><li><strong>四大支柱</strong><ul><li><strong>Microservices</strong> (微服务): 快速修复问题和交付新功能</li><li><strong>Containers</strong> (容器): 可移植和轻量级</li><li><strong>Container Orchestration</strong> (容器编排): Kubernetes (GKE) - 自动扩展&#x2F;负载均衡&#x2F;自我修复&#x2F;零停机部署</li><li><strong>DevOps</strong>: 增强流程自动化 (CI&#x2F;CD, IaC)</li></ul></li><li>考试提示: 云原生 &#x3D; 微服务 + 容器 + Kubernetes + DevOps</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img329342.png"></p><hr><h4 id="Container-Compute-Examples"><a href="#Container-Compute-Examples" class="headerlink" title="Container Compute Examples"></a>Container Compute Examples</h4><ul><li><strong>Cloud Run</strong>: 开发和部署高度可扩展的容器化应用 (Serverless)</li><li><strong>Google Kubernetes Engine (GKE)</strong>: 在 Kubernetes 上编排容器化微服务</li><li><strong>Anthos</strong>: 管理多云和本地 Kubernetes 集群</li><li>考试提示: Serverless 容器 → Cloud Run; 容器编排 → GKE; 多云 → Anthos</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img329344.png"></p><hr><h4 id="Serverless-Examples"><a href="#Serverless-Examples" class="headerlink" title="Serverless Examples"></a>Serverless Examples</h4><ul><li><strong>Serverless 服务示例</strong><ul><li><strong>Cloud Functions</strong>: 事件驱动应用的 Serverless 计算</li><li><strong>Cloud Run</strong>: 无需编排运行隔离容器</li><li><strong>Cloud Firestore</strong>: 快速演进结构的应用 (无 Schema)</li><li><strong>Cloud Dataflow</strong>: 使用 Apache Beam 的 Serverless 流式和批处理</li><li><strong>Cloud Pub&#x2F;Sub</strong>: 云端实时消息, 按消息数量付费</li><li><strong>BigQuery</strong>: 关系型 OLAP, 数据仓库和大数据工作负载</li></ul></li><li>考试提示: Serverless &#x3D; 无需管理服务器, 按使用付费</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img329346.png"></p><hr><h3 id="17-Cost-Management-in-GCP"><a href="#17-Cost-Management-in-GCP" class="headerlink" title="17. Cost Management in GCP"></a>17. Cost Management in GCP</h3><h4 id="CapEx-vs-OpEx"><a href="#CapEx-vs-OpEx" class="headerlink" title="CapEx vs OpEx"></a>CapEx vs OpEx</h4><ul><li><strong>CapEx</strong> (资本支出): 购买基础设施的费用 (一次性大额投资)</li><li><strong>OpEx</strong> (运营支出): 使用服务或产品的费用 (持续按使用付费)</li><li><strong>关键区别</strong>: CapEx &#x3D; 买; OpEx &#x3D; 租</li><li>考试提示: 云计算 &#x3D; OpEx 模型</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img329400.png"></p><hr><h4 id="Pricing-Calculator"><a href="#Pricing-Calculator" class="headerlink" title="Pricing Calculator"></a>Pricing Calculator</h4><ul><li><strong>Pricing Calculator</strong> (定价计算器): 估算 Google Cloud 解决方案的成本</li><li><strong>核心功能</strong>: 选择服务, 配置资源, 获取成本估算</li><li>考试提示: 成本估算 → Pricing Calculator</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img329402.png"></p><hr><h4 id="GCP-Cost-Management"><a href="#GCP-Cost-Management" class="headerlink" title="GCP Cost Management"></a>GCP Cost Management</h4><ul><li><strong>Cost Management</strong> (成本管理): 监控、控制和优化成本的工具</li><li><strong>核心工具</strong>: Billing dashboards (计费仪表板), Resource labels (资源标签), Budget Alerts (预算警报)</li><li>考试提示: 成本监控和优化 → Cost Management</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img329404.png"></p><hr><h4 id="Billing-Dashboards"><a href="#Billing-Dashboards" class="headerlink" title="Billing Dashboards"></a>Billing Dashboards</h4><ul><li><strong>Billing Dashboards</strong> (计费仪表板): 提供云支出的全面概览</li><li><strong>核心功能</strong>: 可视化成本趋势, 按服务&#x2F;项目分析支出</li><li>考试提示: 可视化成本 → Billing Dashboards</li></ul><hr><h4 id="Resource-Labels"><a href="#Resource-Labels" class="headerlink" title="Resource Labels"></a>Resource Labels</h4><ul><li><strong>Resource Labels</strong> (资源标签): 使用键值对标记云资源</li><li><strong>核心功能</strong>: 过滤和组织成本数据, 按部门&#x2F;项目&#x2F;环境分组</li><li>考试提示: 成本分组和过滤 → Resource Labels</li></ul><hr><h3 id="18-GCP-Review"><a href="#18-GCP-Review" class="headerlink" title="18. GCP Review"></a>18. GCP Review</h3><h4 id="Basic-Compute-Services"><a href="#Basic-Compute-Services" class="headerlink" title="Basic Compute Services"></a>Basic Compute Services</h4><ul><li><strong>Compute Engine</strong>: 需要控制 OS 或运行自定义软件时使用 VM</li><li><strong>Preemptible VMs</strong>: 非时间关键工作负载的短期 VM (最多便宜 80%)</li><li><strong>Sole-tenant Nodes</strong>: 专用物理服务器 (物理隔离, BYOL)</li><li><strong>VMware Engine</strong>: 在 GCP 上运行 VMware 工作负载</li><li><strong>Managed Instance Groups</strong>: 创建多个相同的 Compute Engine VM</li><li><strong>Cloud Load Balancing</strong>: 在多个实例之间平衡负载</li><li>考试提示: VM 控制 → Compute Engine; 短期低成本 → Preemptible; 物理隔离 → Sole-tenant</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img182332.png"></p><hr><h4 id="Firebase"><a href="#Firebase" class="headerlink" title="Firebase"></a>Firebase</h4><ul><li><strong>Firebase</strong>: 构建 Web 和移动应用的综合云平台</li><li><strong>核心功能</strong>: 后端即服务 (BaaS), 无需管理服务器和基础设施</li><li><strong>关键优势</strong>: 处理动态内容和用户交互, 实时数据库, 身份验证</li><li>考试提示: 移动&#x2F;Web 应用开发 → Firebase</li></ul><hr><h4 id="Managed-Compute-Services"><a href="#Managed-Compute-Services" class="headerlink" title="Managed Compute Services"></a>Managed Compute Services</h4><ul><li><strong>App Engine</strong>: PaaS, 快速部署 Web 应用和 RESTful API</li><li><strong>Cloud Run</strong>: 无需编排运行隔离容器 (Serverless)</li><li><strong>Kubernetes Engine (GKE)</strong>: 托管的 Kubernetes 服务, 提供容器编排</li><li><strong>Cloud Functions</strong>: 事件驱动应用的 Serverless 计算</li><li><strong>Anthos</strong>: 管理多云和本地 Kubernetes 集群</li><li><strong>Firebase</strong>: Google 移动平台, 构建 iOS&#x2F;Android&#x2F;Web&#x2F;C++&#x2F;Unity 应用</li><li>考试提示: PaaS → App Engine; 容器编排 → GKE; 事件驱动 → Cloud Functions; 多云 → Anthos</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img182553.png"></p><hr><h4 id="Storage"><a href="#Storage" class="headerlink" title="Storage"></a>Storage</h4><ul><li><strong>Persistent Disk</strong>: VM 的块存储 (持久性, VM 删除后保留)</li><li><strong>Local SSD</strong>: VM 的本地临时块存储 (极高性能, VM 删除后丢失)</li><li><strong>Cloud Filestore</strong>: 云端文件共享 (NFS)</li><li><strong>Cloud Storage</strong>: 云端对象存储 (非结构化数据, 全球分布)</li><li>考试提示: 持久块 → Persistent Disk; 临时高性能 → Local SSD; 文件共享 → Filestore; 对象 → Cloud Storage</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img182703.png"></p><hr><h4 id="Databases"><a href="#Databases" class="headerlink" title="Databases"></a>Databases</h4><ul><li><strong>Cloud SQL</strong>: 区域级关系型 OLTP 数据库 (MySQL, PostgreSQL, SQL Server)</li><li><strong>Cloud Spanner</strong>: 全球级关系型 OLTP 数据库, 无限扩展 + 99.999% 可用性 (水平扩展)</li><li><strong>Cloud Firestore</strong>: 快速演进结构的应用 (无 Schema, Serverless NoSQL)</li><li><strong>Cloud Bigtable</strong>: 大型数据库 (10 TB - PB 级), 流式 (IoT)&#x2F;分析&#x2F;运营工作负载 (非 Serverless)</li><li><strong>Cloud Memorystore</strong>: 内存数据库&#x2F;缓存, 需要微秒级响应的应用</li><li>考试提示: 区域 OLTP → Cloud SQL; 全球 OLTP → Spanner; NoSQL 文档 → Firestore; NoSQL 宽列 → Bigtable; 缓存 → Memorystore</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img182848.png"></p><hr><h4 id="Streams-Analytics-Big-Data"><a href="#Streams-Analytics-Big-Data" class="headerlink" title="Streams, Analytics, Big Data"></a>Streams, Analytics, Big Data</h4><ul><li><strong>Cloud Pub&#x2F;Sub</strong>: 云端实时消息传递</li><li><strong>BigQuery</strong>: 关系型 OLAP 数据库, 数据仓库和大数据工作负载</li><li><strong>BigQuery ML</strong>: 使用 BigQuery 数据简化机器学习</li><li><strong>Cloud Dataflow</strong>: 使用 Apache Beam 的 Serverless 流式和批处理</li><li><strong>Cloud Dataproc</strong>: 托管的 Spark 和 Hadoop 服务 (非 Serverless)</li><li><strong>Cloud Data Fusion</strong>: 可视化管理数据管道</li><li><strong>Data Studio</strong>: 可视化数据</li><li><strong>Looker</strong>: 企业商业智能</li><li>考试提示: 消息 → Pub&#x2F;Sub; 数据仓库 → BigQuery; Serverless ETL → Dataflow; Spark → Dataproc</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img185343.png"></p><hr><h4 id="Migration"><a href="#Migration" class="headerlink" title="Migration"></a>Migration</h4><ul><li><strong>Database Migration Service</strong>: 迁移到 Cloud SQL</li><li><strong>Storage Transfer Service</strong>: 在线传输到 Cloud Storage</li><li><strong>Transfer Appliance</strong>: 使用设备进行物理传输</li><li><strong>Migrate for Compute Engine</strong>: 迁移 VM 和 VM 存储到 GCE</li><li><strong>Migrate for Anthos</strong>: 将 VM 迁移到 GKE 容器</li><li><strong>BigQuery Data Transfer Service</strong>: 迁移分析数据</li><li>考试提示: 数据库迁移 → Database Migration Service; 大规模数据 → Transfer Appliance; VM 迁移 → Migrate for Compute Engine</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img185525.png"></p>]]></content>
      
      
      <categories>
          
          <category> Certification </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GCP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS 学习笔记</title>
      <link href="/posts/eb0c992c.html"/>
      <url>/posts/eb0c992c.html</url>
      
        <content type="html"><![CDATA[<h3 id="CSS选择器"><a href="#CSS选择器" class="headerlink" title="CSS选择器"></a><code>CSS</code>选择器</h3><h4 id="基础选择器"><a href="#基础选择器" class="headerlink" title="基础选择器"></a>基础选择器</h4><ul><li>标签选择器: <code>h1</code></li><li>类选择器: <code>.checked</code></li><li><code>ID</code>选择器: <code>#picker</code></li><li>通配选择器: <code>*</code></li></ul><h4 id="属性选择器"><a href="#属性选择器" class="headerlink" title="属性选择器"></a>属性选择器</h4><blockquote><p>可以看看这篇文章: <a href="https://juejin.cn/post/6844903870171201549">https://juejin.cn/post/6844903870171201549</a></p></blockquote><ul><li><code>[attr]</code>: 选择包含某个属性的所有元素，而不关心属性值</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;Enter your name&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-tag">input</span><span class="selector-attr">[placeholder]</span> &#123; <span class="attribute">border</span>: <span class="number">2px</span> solid blue; &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 选中所有带有 placeholder 属性的 input 元素（第一个 input） --&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>[attr=val]</code>: 选择属性值完全等于指定值的所有元素</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;Enter your name&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;email&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-tag">input</span><span class="selector-attr">[type=<span class="string">&quot;password&quot;</span>]</span> &#123; <span class="attribute">background-color</span>: lightgray; &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 仅选中 type=&quot;password&quot; 的 input 元素 --&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>[attr*=val]</code>: 选择属性值中<ins>包含</ins>指定值的所有元素</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://google.com&quot;</span>&gt;</span>Google<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://github.com&quot;</span>&gt;</span>GitHub<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;mailto:support@example.com&quot;</span>&gt;</span>Email Support<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-tag">a</span><span class="selector-attr">[href*=<span class="string">&quot;google&quot;</span>]</span> &#123; <span class="attribute">color</span>: red; &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 选中 href 属性中包含 &quot;google&quot; 的 &lt;a&gt; 元素 --&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>[attr^=val]</code>: 选择属性值以指定字符串<ins>开头</ins>的所有元素</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://google.com&quot;</span>&gt;</span>Google<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://github.com&quot;</span>&gt;</span>GitHub<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://example.com&quot;</span>&gt;</span>Example<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-tag">a</span><span class="selector-attr">[href^=<span class="string">&quot;https&quot;</span>]</span> &#123; <span class="attribute">text-decoration</span>: underline; &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 选中 href 属性以 &quot;https&quot; 开头的 &lt;a&gt; 元素（Google 和 GitHub） --&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>[attr$=val]</code>: 选择属性值以指定字符串<ins>结尾</ins>的所有元素</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;index.html&quot;</span>&gt;</span>Home<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;about.html&quot;</span>&gt;</span>About<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;style.css&quot;</span>&gt;</span>Stylesheet<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-tag">a</span><span class="selector-attr">[href$=<span class="string">&quot;.html&quot;</span>]</span> &#123; <span class="attribute">color</span>: green; &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 选中 href 属性以 &quot;.html&quot; 结尾的 &lt;a&gt; 元素（Home 和 About） --&gt;</span></span><br></pre></td></tr></table></figure><h4 id="组合选择器"><a href="#组合选择器" class="headerlink" title="组合选择器"></a>组合选择器</h4><ul><li>相邻兄弟选择器: <code>A + B</code>, 选择<code>A</code>元素后紧跟的第一个<code>B</code>元素</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span>Box 1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span>Box 2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;text&quot;</span>&gt;</span>Text 1<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;text&quot;</span>&gt;</span>Text 2<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.box</span> + <span class="selector-class">.text</span> &#123; <span class="attribute">color</span>: red; &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 仅会选中紧挨着 .box 的第一个 .text（也就是 Text 1） --&gt;</span></span><br></pre></td></tr></table></figure><ul><li>普通兄弟选择器: <code>A ~ B</code>, 选择<code>A</code>元素后所有的<code>B</code>元素</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span>Box 1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;text&quot;</span>&gt;</span>Text 1<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;text&quot;</span>&gt;</span>Text 2<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span>Box 2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;text&quot;</span>&gt;</span>Text 3<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.box</span> ~ <span class="selector-class">.text</span> &#123; <span class="attribute">color</span>: blue; &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 选中 .box 后所有同一父级下的 .text 元素（Text 1 和 Text 2） --&gt;</span></span><br></pre></td></tr></table></figure><ul><li>子选择器: <code>A &gt; B</code>: 选择<code>A</code>的直接子元素<code>B</code></li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span>Box 1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;inner&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span>Box 2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.container</span> &gt; <span class="selector-class">.box</span> &#123; <span class="attribute">background-color</span>: yellow; &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 仅会选中 .container 的直接子元素 .box（Box 1），不包括嵌套的 Box 2 --&gt;</span></span><br></pre></td></tr></table></figure><ul><li>后代选择器: <code>A B</code>: 选择<code>A</code>元素内的所有<code>B</code>元素, 不论层级深度</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span>Box 1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;inner&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span>Box 2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.container</span> <span class="selector-class">.box</span> &#123; <span class="attribute">border</span>: <span class="number">1px</span> solid black; &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 会选中 .container 内的所有 .box 元素，包括 Box 1 和 Box 2 --&gt;</span></span><br></pre></td></tr></table></figure><h4 id="伪类"><a href="#伪类" class="headerlink" title="伪类"></a>伪类</h4><h5 id="条件伪类"><a href="#条件伪类" class="headerlink" title="条件伪类"></a><p style='font-size: 14px'>条件伪类</p></h5><ul><li><code>:lang()</code>: 基于元素语言来匹配页面元素</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span>Hello, world!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">lang</span>=<span class="string">&quot;fr&quot;</span>&gt;</span>Bonjour, le monde!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">lang</span>=<span class="string">&quot;zh&quot;</span>&gt;</span>你好，世界！<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-tag">p</span><span class="selector-pseudo">:lang</span>(en) &#123; <span class="attribute">color</span>: blue; &#125;</span></span><br><span class="line"><span class="language-css">  <span class="selector-tag">p</span><span class="selector-pseudo">:lang</span>(zh) &#123; <span class="attribute">color</span>: red; &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- lang=&quot;en&quot; 的段落文字变蓝, lang=&quot;zh&quot; 的段落文字变红 --&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>:dir()</code>: 匹配特定文字书写方向的元素</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">dir</span>=<span class="string">&quot;ltr&quot;</span>&gt;</span>Left to Right text.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">dir</span>=<span class="string">&quot;rtl&quot;</span>&gt;</span>من اليمين إلى اليسار.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-tag">p</span><span class="selector-pseudo">:dir</span>(ltr) &#123; <span class="attribute">background-color</span>: lightblue; &#125;</span></span><br><span class="line"><span class="language-css">  <span class="selector-tag">p</span><span class="selector-pseudo">:dir</span>(rtl) &#123; <span class="attribute">background-color</span>: lightgreen; &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 从左到右（ltr）的段落背景变蓝, 从右到左（rtl）的段落背景变绿 --&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>:has()</code>: 选择包含某个特定子元素的父元素</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;child&quot;</span>&gt;</span>This is a child paragraph.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>No child paragraph here.<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-tag">div</span><span class="selector-pseudo">:has</span>(<span class="selector-class">.child</span>) &#123; <span class="attribute">border</span>: <span class="number">2px</span> solid red; &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 包含类名为 child 的段落 &lt;p&gt; 的 &lt;div&gt; 会有红色边框 --&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>:is()</code>: 选择与列表中任意选择器匹配的元素</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Heading 1<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>Heading 2<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>Heading 3<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-pseudo">:is</span>(<span class="selector-tag">h1</span>, <span class="selector-tag">h2</span>) &#123; <span class="attribute">font-style</span>: italic; &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- h1 和 h2 元素的文字将变为斜体，而 h3 不受影响 --&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>:not()</code>: 选择不符合某些条件的元素</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span>Box 1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span>Container<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span>Box 2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-tag">div</span><span class="selector-pseudo">:not</span>(<span class="selector-class">.box</span>) &#123; <span class="attribute">background-color</span>: lightgray; &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 类名不是 box 的 &lt;div&gt;（即 Container）背景将变为浅灰色 --&gt;</span></span><br></pre></td></tr></table></figure><h5 id="行为伪类"><a href="#行为伪类" class="headerlink" title="行为伪类"></a><p style='font-size: 14px'>行为伪类</p></h5><ul><li><code>:active</code>: 当用户<ins>点击并按住</ins>一个元素时，该伪类会生效。一般用于按钮或链接</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span>&gt;</span>Click Me<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>Active Link<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-tag">button</span><span class="selector-pseudo">:active</span> &#123; <span class="attribute">background-color</span>: darkblue; <span class="attribute">color</span>: white;&#125;</span></span><br><span class="line"><span class="language-css">  <span class="selector-tag">a</span><span class="selector-pseudo">:active</span> &#123; <span class="attribute">color</span>: red; &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 按住按钮时，背景颜色变为深蓝，文字变为白色 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 点击并按住链接时，文字颜色变为红色 --&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>:hover</code>: 当用户将鼠标指针悬停在一个元素上时，该伪类会生效</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;hover-box&quot;</span>&gt;</span>Hover over me!<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>Hover Link<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.hover-box</span><span class="selector-pseudo">:hover</span> &#123; <span class="attribute">background-color</span>: lightgreen; <span class="attribute">cursor</span>: pointer; &#125;</span></span><br><span class="line"><span class="language-css">  <span class="selector-tag">a</span><span class="selector-pseudo">:hover</span> &#123; <span class="attribute">text-decoration</span>: underline; <span class="attribute">color</span>: orange; &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 鼠标悬停在 .hover-box 上时，背景变为浅绿色，鼠标变为手型 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 鼠标悬停在链接上时，文字加下划线，颜色变为橙色 --&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>::selection</code>: 当用户选中<ins>文本</ins>时，该伪类会生效。可以用于自定义文本选择时的样式（如背景颜色、文字颜色）</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">    This is a paragraph of text. Select some text to see the effect.</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-pseudo">::selection</span> &#123; <span class="attribute">background-color</span>: yellow; <span class="attribute">color</span>: black; &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 选中段落文本时，背景变为黄色，文字变为黑色 --&gt;</span></span><br></pre></td></tr></table></figure><h5 id="状态伪类"><a href="#状态伪类" class="headerlink" title="状态伪类"></a><p style='font-size: 14px'>状态伪类</p></h5><ul><li><code>:target</code>: 匹配当前<code>URL</code>锚点（<code>#</code>）对应的元素</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#section1&quot;</span>&gt;</span>Go to Section 1<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#section2&quot;</span>&gt;</span>Go to Section 2<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;section1&quot;</span>&gt;</span>Section 1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;section2&quot;</span>&gt;</span>Section 2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-id">#section1</span><span class="selector-pseudo">:target</span> &#123; <span class="attribute">background-color</span>: lightblue; &#125;</span></span><br><span class="line"><span class="language-css">  <span class="selector-id">#section2</span><span class="selector-pseudo">:target</span> &#123; <span class="attribute">background-color</span>: lightgreen; &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 点击链接 Go to Section 1，#section1 背景变为浅蓝色 --&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>:link</code>: 选择未访问的链接</li><li><code>:visited</code>: 选择已访问的链接</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://example.com&quot;</span>&gt;</span>Unvisited Link<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://google.com&quot;</span>&gt;</span>Visited Link<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-tag">a</span><span class="selector-pseudo">:link</span> &#123; <span class="attribute">color</span>: blue; &#125;</span></span><br><span class="line"><span class="language-css">  <span class="selector-tag">a</span><span class="selector-pseudo">:visited</span> &#123; <span class="attribute">color</span>: purple; &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 未访问的链接文字颜色为蓝色, 已访问的链接文字颜色为紫色 --&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>:focus</code>: 匹配当前聚焦的表单元素</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;Enter your name&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-tag">input</span><span class="selector-pseudo">:focus</span> &#123; <span class="attribute">border</span>: <span class="number">2px</span> solid green; <span class="attribute">outline</span>: none; &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 输入框聚焦时边框变为绿色 --&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>:required</code>: 匹配表单中被标记为必填的元素</li><li><code>:optional</code>: 匹配表单中未标记为必填的元素</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">required</span> <span class="attr">placeholder</span>=<span class="string">&quot;Required Field&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;Optional Field&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-tag">input</span><span class="selector-pseudo">:required</span> &#123; <span class="attribute">border</span>: <span class="number">2px</span> solid red; &#125;</span></span><br><span class="line"><span class="language-css">  <span class="selector-tag">input</span><span class="selector-pseudo">:optional</span> &#123; <span class="attribute">border</span>: <span class="number">2px</span> solid gray; &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 必填字段边框为红色, 可选字段边框为灰色 --&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>:valid</code>: 匹配输入值合法的表单元素</li><li><code>:invalid</code>: 匹配输入值不合法的表单元素</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;email&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;Enter your email&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-tag">input</span><span class="selector-pseudo">:valid</span> &#123; <span class="attribute">border</span>: <span class="number">2px</span> solid green; &#125;</span></span><br><span class="line"><span class="language-css">  <span class="selector-tag">input</span><span class="selector-pseudo">:invalid</span> &#123; <span class="attribute">border</span>: <span class="number">2px</span> solid red; &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 输入合法邮箱时，边框变绿, 输入不合法邮箱时，边框变红 --&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>:in-range</code>: 匹配输入值在设定范围内的元素</li><li><code>:out-of-range</code>: 匹配输入值在设定范围外的元素</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;number&quot;</span> <span class="attr">min</span>=<span class="string">&quot;10&quot;</span> <span class="attr">max</span>=<span class="string">&quot;100&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;Enter a number&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-tag">input</span><span class="selector-pseudo">:in-range</span> &#123; <span class="attribute">background-color</span>: lightgreen; &#125;</span></span><br><span class="line"><span class="language-css">  <span class="selector-tag">input</span><span class="selector-pseudo">:out-of-range</span> &#123; <span class="attribute">background-color</span>: lightcoral; &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 输入 10 到 100 之间的数字，背景变绿, 输入范围外的数字，背景变红 --&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>:checked</code>: 匹配选中的复选框或单选按钮</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">checked</span>&gt;</span> Checked<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span>&gt;</span> Not Checked<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-tag">input</span><span class="selector-pseudo">:checked</span> &#123; <span class="attribute">outline</span>: <span class="number">2px</span> solid blue; &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 选中的复选框有蓝色边框 --&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>:enabled</code>: 匹配启用的表单元素</li><li><code>:disabled</code>: 匹配禁用的表单元素</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">disabled</span> <span class="attr">placeholder</span>=<span class="string">&quot;Disabled&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;Enabled&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-tag">input</span><span class="selector-pseudo">:enabled</span> &#123; <span class="attribute">background-color</span>: white; &#125;</span></span><br><span class="line"><span class="language-css">  <span class="selector-tag">input</span><span class="selector-pseudo">:disabled</span> &#123; <span class="attribute">background-color</span>: lightgray; &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 启用的输入框背景为白色, 禁用的输入框背景为浅灰色 --&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>:read-only</code>: 匹配只读表单元素</li><li><code>:read-write</code>: 匹配可编辑表单元素</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">readonly</span> <span class="attr">value</span>=<span class="string">&quot;Read-only Field&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Editable Field&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-tag">input</span><span class="selector-pseudo">:read-only</span> &#123; <span class="attribute">color</span>: gray; &#125;</span></span><br><span class="line"><span class="language-css">  <span class="selector-tag">input</span><span class="selector-pseudo">:read-write</span> &#123; <span class="attribute">color</span>: black; &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 只读输入框文字为灰色, 可编辑输入框文字为黑色 --&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>:blank</code>: 匹配没有输入值的表单元素</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;Leave me blank&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-tag">input</span><span class="selector-pseudo">:blank</span> &#123; <span class="attribute">border</span>: <span class="number">2px</span> dashed orange; &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 未填写的输入框边框为橙色虚线 --&gt;</span></span><br></pre></td></tr></table></figure><h5 id="结构伪类"><a href="#结构伪类" class="headerlink" title="结构伪类"></a><p style='font-size: 14px'>结构伪类</p></h5><ul><li><code>:root</code>: 选择文档的根元素, 在<code>HTML</code>中一般是<code>&lt;html&gt;</code>标签</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello, World!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-pseudo">:root</span> &#123; <span class="attribute">font-size</span>: <span class="number">16px</span>; <span class="attr">--main-color</span>: blue; &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 设置根元素的字体大小和 CSS 自定义属性（变量） --&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>:empty</code>: 匹配没有子元素（包括文本节点）的元素</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box2&quot;</span>&gt;</span>Content<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-tag">div</span><span class="selector-pseudo">:empty</span> &#123; <span class="attribute">background-color</span>: lightgray; &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 没有内容的 &lt;div class=&quot;box1&quot;&gt; 背景变为浅灰色 --&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>:first-letter</code>: 选择元素的首字母，用于文本样式的特殊处理</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>This is a paragraph.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-tag">p</span><span class="selector-pseudo">:first</span>-letter &#123; <span class="attribute">font-size</span>: <span class="number">2em</span>; <span class="attribute">color</span>: red; &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 段落首字母 “T” 字体变大且颜色变红 --&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>:first-line</code>: 选择元素的首行内容，常用于段落样式的特殊处理</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>This is a long paragraph to demonstrate first-line styling in CSS.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-tag">p</span><span class="selector-pseudo">:first</span>-line &#123; <span class="attribute">font-weight</span>: bold; <span class="attribute">color</span>: blue; &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 段落的第一行文字加粗且变蓝 --&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>:nth-child(n)</code>: 匹配父元素中第<code>n</code>个子元素（从第一个开始计数）</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-tag">li</span><span class="selector-pseudo">:nth-child</span>(<span class="number">2</span>) &#123; <span class="attribute">color</span>: red; &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 第二个 &lt;li&gt; 的文字颜色变为红色 --&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>:nth-last-child(n)</code>: 匹配父元素中倒数第<code>n</code>个子元素</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-tag">li</span><span class="selector-pseudo">:nth-last-child</span>(<span class="number">1</span>) &#123; <span class="attribute">color</span>: green; &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 最后一个 &lt;li&gt; 的文字颜色变为绿色 --&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>:first-child</code>: 匹配父元素中的第一个子元素</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-tag">li</span><span class="selector-pseudo">:first</span>-child &#123; <span class="attribute">font-style</span>: italic; &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 第一个 &lt;li&gt; 的文字变为斜体 --&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>:last-child</code>: 匹配父元素中的最后一个子元素</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-tag">li</span><span class="selector-pseudo">:last-child</span> &#123; <span class="attribute">font-weight</span>: bold; &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 最后一个 &lt;li&gt; 的文字加粗 --&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>:only-child</code>: 匹配父元素中仅有的子元素</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;single&quot;</span>&gt;</span>I am the only child!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Child 1<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Child 2<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-tag">p</span><span class="selector-pseudo">:only-child</span> &#123; <span class="attribute">color</span>: purple; &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 仅有一个子元素的 &lt;p&gt;（I am the only child!）文字颜色变为紫色 --&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>:nth-of-type(n)</code>: 匹配同类型标签中的第<code>n</code>个</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Paragraph 1<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Paragraph 2<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>Span 1<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Paragraph 3<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-tag">p</span><span class="selector-pseudo">:nth-of-type</span>(<span class="number">2</span>) &#123; <span class="attribute">color</span>: orange; &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 第二个 &lt;p&gt;（Paragraph 2）文字颜色变为橙色 --&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>:nth-last-of-type(n)</code>: 匹配同类型标签中的倒数第<code>n</code>个</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Paragraph 1<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Paragraph 2<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Paragraph 3<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-tag">p</span><span class="selector-pseudo">:nth-last-of-type</span>(<span class="number">1</span>) &#123; <span class="attribute">color</span>: brown; &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 倒数第一个 &lt;p&gt;（Paragraph 3）文字颜色变为棕色 --&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>:first-of-type</code>: 匹配同类型标签中的第一个</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>First Paragraph<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Second Paragraph<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-tag">p</span><span class="selector-pseudo">:first</span>-of-type &#123; <span class="attribute">text-decoration</span>: underline; &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 第一个 &lt;p&gt; 的文字加下划线 --&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>:last-of-type</code>: 匹配同类型标签中的最后一个</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>First Paragraph<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Last Paragraph<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-tag">p</span><span class="selector-pseudo">:last-of-type</span> &#123; <span class="attribute">color</span>: teal; &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 最后一个 &lt;p&gt; 的文字颜色变为青色 --&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>:only-of-type</code>: 匹配父元素中仅有的某种类型的标签</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Unique Paragraph<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>Not Unique<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Another Paragraph<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-tag">p</span><span class="selector-pseudo">:only-of-type</span> &#123; <span class="attribute">background-color</span>: yellow; &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 父元素中仅有的 &lt;p&gt;（Unique Paragraph）背景变为黄色 --&gt;</span></span><br></pre></td></tr></table></figure><h5 id="伪元素"><a href="#伪元素" class="headerlink" title="伪元素"></a><p style='font-size: 14px'>伪元素</p></h5><ul><li><code>::before</code>: 在在元素内容<ins>之前</ins>插入内容<ul><li><code>::before</code>是一个伪元素，必须与<code>content</code>属性一起使用，否则不会生效</li></ul></li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;example&quot;</span>&gt;</span>This is a paragraph.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.example</span><span class="selector-pseudo">::before</span> &#123; <span class="attribute">content</span>: <span class="string">&quot;★ &quot;</span>; <span class="attribute">color</span>: gold; <span class="attribute">font-size</span>: <span class="number">1.5em</span>; &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 在段落内容之前插入一个金色的星星符号 --&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>::after</code>: 在元素内容<ins>之后</ins>插入内容<ul><li>和<code>::before</code>类似，必须与<code>content</code>属性一起使用</li></ul></li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;example&quot;</span>&gt;</span>This is a paragraph.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.example</span><span class="selector-pseudo">::after</span> &#123; <span class="attribute">content</span>: <span class="string">&quot; ✎&quot;</span>; <span class="attribute">color</span>: gray; <span class="attribute">font-size</span>: <span class="number">1.2em</span>; &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 在段落内容之后插入一个灰色的铅笔符号 --&gt;</span></span><br></pre></td></tr></table></figure><hr><h3 id="CSS优先级"><a href="#CSS优先级" class="headerlink" title="CSS优先级"></a><code>CSS</code>优先级</h3><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img4b226c55b87c426c840d2c70d51d3511%7Etplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.awebp"></p><p>优先级就是分配给指定的<code>CSS</code>声明的一个权重, 它由匹配的选择器中的每一种选择器类型的数值决定。可以把权重分成如下几个等级, 数值越大的权重越高</p><ul><li><code>10000</code>: <code>!important</code></li><li><code>01000</code>: 内联样式 (<code>inline style</code>)</li><li><code>00100</code>: <code>ID</code>选择器</li><li><code>00010</code>: 类选择器、伪类选择器、属性选择器</li><li><code>00001</code>: 元素选择器、伪元素选择器</li><li><code>00000</code>: 通配选择器、后代选择器、兄弟选择器</li></ul><p>可以看到内联样式（通过元素中<code>style</code>属性定义的样式）的优先级大于任何选择器。而给属性值加上<code>!important</code>又可以把优先级提至最高，就是因为它的优先级最高，所以需要谨慎使用它</p><hr><h3 id="CSS层叠性"><a href="#CSS层叠性" class="headerlink" title="CSS层叠性"></a><code>CSS</code>层叠性</h3><p>层叠样式表（<code>CSS</code>）中的“层叠”是其核心特性之一，它指的是当多个<code>CSS</code>声明可以作用于同一个<code>HTML</code>元素时，如何确定最终生效的样式。这是通过一套明确的算法来完成的，用于合并来自多个来源的属性值</p><ul><li>针对不同源的样式，将按照如下的顺序进行层叠，越往下优先级越高<ul><li>用户代理样式表: 浏览器自带的默认样式，如果我们不设置任何样式，浏览器会使用这些规则。例如，默认的段落<code>&lt;p&gt;</code>有一些上下边距</li><li>作者样式表: 开发者定义的样式，通常是我们编写的<code>CSS</code>文件或内联样式。这些样式会覆盖浏览器的默认样式</li><li>作者样式表中的<code>!important</code>声明: 如果开发者在样式中添加了<code>!important</code>，那么它的优先级最高，哪怕有其他规则覆盖，它也会生效</li></ul></li></ul><p>理解层叠性的时候需要结合<code>CSS</code>选择器的优先级以及继承性来理解。比如针对同一个选择器，定义在后面的声明会覆盖前面的, 作者定义的样式会比默认继承的样式优先级更高</p><hr><h3 id="规则"><a href="#规则" class="headerlink" title="@规则"></a><code>@</code>规则</h3><p><code>@</code>规则是一种特殊的<code>CSS</code>语句，用于在样式表中定义一些全局配置或条件规则，而不仅仅是常规的样式规则。以下是<code>CSS</code>中常用的<code>@</code>规则</p><ul><li><code>@namespace</code>: 用于定义<code>XML</code>命名空间（适用于特定的<code>XML</code>文件样式需求）</li></ul><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@namespace</span> svg <span class="string">&quot;http://www.w3.org/2000/svg&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 仅对 SVG 元素应用样式 */</span></span><br><span class="line">svg|circle &#123;</span><br><span class="line">    fill: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 作用：定义 svg 命名空间，并对 &lt;circle&gt; 元素应用样式 */</span></span><br></pre></td></tr></table></figure><ul><li><code>@media</code>: 用于为不同设备或屏幕条件设置样式</li></ul><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@media</span> (<span class="attribute">max-width</span>: <span class="number">600px</span>) &#123;</span><br><span class="line">    <span class="selector-tag">body</span> &#123;</span><br><span class="line">        <span class="attribute">background-color</span>: lightblue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@media</span> print &#123;</span><br><span class="line">    <span class="selector-tag">body</span> &#123;</span><br><span class="line">        <span class="attribute">font-size</span>: <span class="number">12px</span>;</span><br><span class="line">        <span class="attribute">color</span>: black;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 如果屏幕宽度小于或等于 600px，背景变为浅蓝色 */</span></span><br><span class="line"><span class="comment">/* 打印时，字体变小并使用黑色 */</span></span><br></pre></td></tr></table></figure><ul><li><code>@page</code>: 用于设置打印页面的布局（如页边距）</li></ul><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@page</span> &#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">1in</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@page</span> :first &#123;</span><br><span class="line">    <span class="attribute">margin-top</span>: <span class="number">2in</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设置默认打印页面的页边距为 1 英寸 */</span></span><br><span class="line"><span class="comment">/* 第一页的上边距增加到 2 英寸 */</span></span><br></pre></td></tr></table></figure><ul><li><code>@font-face</code>: 定义和加载自定义字体</li></ul><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@font-face</span> &#123;</span><br><span class="line">    <span class="attribute">font-family</span>: <span class="string">&quot;CustomFont&quot;</span>;</span><br><span class="line">    <span class="attribute">src</span>: <span class="built_in">url</span>(<span class="string">&quot;customfont.woff2&quot;</span>) <span class="built_in">format</span>(<span class="string">&quot;woff2&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">font-family</span>: <span class="string">&quot;CustomFont&quot;</span>, sans-serif;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 从外部加载名为 CustomFont 的字体并应用到页面 */</span></span><br></pre></td></tr></table></figure><ul><li><code>@keyframes</code>: 定义动画的关键帧</li></ul><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@keyframes</span> slide-in &#123;</span><br><span class="line">    <span class="selector-tag">from</span> &#123;</span><br><span class="line">        <span class="attribute">transform</span>: <span class="built_in">translateX</span>(-<span class="number">100%</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-tag">to</span> &#123;</span><br><span class="line">        <span class="attribute">transform</span>: <span class="built_in">translateX</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">animation</span>: slide-in <span class="number">1s</span> ease-out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 定义一个从左侧滑入的动画，并将其应用到 &lt;div&gt; 元素上 */</span></span><br></pre></td></tr></table></figure><ul><li><code>@import</code>: 用于导入外部<code>CSS</code>文件, 与<code>&lt;link&gt;</code>的区别如下<ul><li><code>&lt;link&gt;</code>是<code>HTML</code>标签，可导入<code>CSS</code>、图片、脚本等资源。<code>@import</code>是<code>CSS</code>规则，仅能导入<code>CSS</code>文件</li><li><code>&lt;link&gt;</code>会在页面加载时同时加载<code>CSS</code>。<code>@import</code>会等页面加载完成后再加载<code>CSS</code> (所以<code>@import</code>字体会在网页加载结束后才会被应用)</li></ul></li></ul><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@import</span> url(<span class="string">&quot;styles.css&quot;</span>);</span><br></pre></td></tr></table></figure><ul><li><code>@supports</code>: 用于检测浏览器是否支持某些<code>CSS</code>特性，从而有条件地应用样式。可以使用<code>not</code>、<code>and</code>、<code>or</code>逻辑操作符</li></ul><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 默认样式 */</span></span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: white;</span><br><span class="line">    <span class="attribute">color</span>: black;</span><br><span class="line">    <span class="attribute">transition</span>: all <span class="number">0.3s</span> ease;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 如果支持 color-scheme，则设置支持深色模式 */</span></span><br><span class="line"><span class="keyword">@supports</span> (<span class="attribute">color-scheme</span>: dark) &#123;</span><br><span class="line">    <span class="selector-tag">body</span> &#123;</span><br><span class="line">        <span class="attribute">color</span>-scheme: dark;</span><br><span class="line">        <span class="attribute">background-color</span>: <span class="built_in">var</span>(--background, black);</span><br><span class="line">        <span class="attribute">color</span>: <span class="built_in">var</span>(--text, white);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 如果用户偏好减少动画 */</span></span><br><span class="line"><span class="keyword">@supports</span> (<span class="attribute">prefers-reduced-motion</span>: reduce) &#123;</span><br><span class="line">    * &#123;</span><br><span class="line">        <span class="attribute">transition</span>: none;</span><br><span class="line">        <span class="attribute">animation</span>: none;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 如果浏览器支持 color-scheme，页面会启用深色模式的默认样式或定义的变量 */</span></span><br><span class="line"><span class="comment">/* 如果用户设置了减少动画偏好（通过系统设置），页面会禁用所有过渡和动画效果 */</span></span><br><span class="line"><span class="comment">/* 如果两者都不支持，则使用默认样式（浅色背景，黑色文字，带有过渡效果） */</span></span><br></pre></td></tr></table></figure><hr><h3 id="CSS继承性"><a href="#CSS继承性" class="headerlink" title="CSS继承性"></a><code>CSS</code>继承性</h3><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/imgf8bd1604b143463eb121c1f46d71c652%7Etplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.awebp"></p><p>继承性是<code>CSS</code>中的一个重要特性，指的是子元素可以继承父元素某些 属性计算后的值。例如，<code>html</code>元素的文本颜色默认是黑色，页面中的所有子元素会继承这个颜色属性，除非显式指定其他颜色。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: orange;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">h1</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: inherit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="继承的作用"><a href="#继承的作用" class="headerlink" title="继承的作用"></a>继承的作用</h4><ul><li>继承性可以减少样式代码的冗余，提高代码的可维护性<ul><li>如果<code>CSS</code>不支持继承，那么我们需要为每个文本标签都单独设置颜色或字体，导致样式代码冗长，文件体积变大，维护成本增加</li></ul></li></ul><h4 id="继承的默认行为"><a href="#继承的默认行为" class="headerlink" title="继承的默认行为"></a>继承的默认行为</h4><p><code>CSS</code>属性很多，但并不是所有的属性默认都是能继承父元素对应属性的，那哪些属性存在默认继承的行为呢？一定是那些不会影响到页面布局的属性，可以分为如下几类</p><ul><li>字体相关: <code>font-family</code>、<code>font-style</code>、<code>font-size</code>、<code>font-weight</code>等</li><li>文本相关: <code>text-align</code>、<code>text-indent</code>、<code>text-decoration</code>、<code>text-shadow</code>、<code>letter-spacing</code>、<code>word-spacing</code>、<code>white-space</code>、<code>line-height</code>、<code>color</code>等</li><li>列表相关: <code>list-style</code>、<code>list-style-image</code>、<code>list-style-type</code>、<code>list-style-position</code>等</li><li>其他属性: <code>visibility</code>、<code>cursor</code>等</li></ul><h4 id="显式控制继承行为"><a href="#显式控制继承行为" class="headerlink" title="显式控制继承行为"></a>显式控制继承行为</h4><p>对于其他默认不继承的属性也可以通过以下几个属性值来控制继承行为</p><ul><li><code>inherit</code>: 强制继承父元素对应属性的计算值</li></ul><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">    <span class="attribute">border</span>: inherit;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* p 的边框样式将继承自父元素 */</span></span><br></pre></td></tr></table></figure><ul><li><code>initial</code>: 将属性恢复为<code>CSS</code>的默认值</li></ul><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: initial;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* p 的颜色将恢复为默认值（如黑色 #000） */</span></span><br></pre></td></tr></table></figure><ul><li><code>unset</code><ul><li>如果属性默认可以继承，则效果等同于<code>inherit</code></li><li>如果属性默认不继承，则效果等同于<code>initial</code></li></ul></li></ul><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: unset;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="CSS文档流"><a href="#CSS文档流" class="headerlink" title="CSS文档流"></a><code>CSS</code>文档流</h3><p>在<code>CSS</code>的世界中，文档流是内容按照从左到右、从上到下的顺序排列和显示的一种默认布局方式。通常情况下，页面会被分割成一行一行的显示，每行可能包含多个元素。从视觉效果来看，文档流呈现为从上到下、从左到右的排列方式。这种布局也被称为<ins>流式布局</ins>，类似水流般灵活，可以自适应所在的容器</p><h4 id="什么是文档流"><a href="#什么是文档流" class="headerlink" title="什么是文档流"></a>什么是文档流</h4><ul><li>在没有额外样式（如<code>position</code>或<code>float</code>）的情况下，<code>HTML</code>元素会按照文档流的默认规则进行排列</li><li>块级元素: 占据一整行，从上到下垂直排列，例如 <code>&lt;div&gt;</code>、<code>&lt;p&gt;</code>等</li><li>行内元素: 按从左到右的顺序水平排列，例如 <code>&lt;span&gt;</code>、<code>&lt;a&gt;</code>、<code>&lt;strong&gt;</code>等</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>块级元素 1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>块级元素 2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>行内元素 1<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>行内元素 2<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">块级元素 1</span><br><span class="line">块级元素 2</span><br><span class="line">行内元素 1 行内元素 2</span><br></pre></td></tr></table></figure><h4 id="脱离文档流"><a href="#脱离文档流" class="headerlink" title="脱离文档流"></a>脱离文档流</h4><p>脱离文档流指的是将某个元素从正常文档流中移除后，其他元素将忽略该元素的存在，并填补其原先占据的空间。脱流的元素不会影响父容器的高度计算，即<ins>脱流元素不占据空间</ins></p><ul><li>有以下两种常见方式可以使元素脱离文档流</li></ul><h5 id="浮动float"><a href="#浮动float" class="headerlink" title="浮动float"></a><p style='font-size: 14px'>浮动<code>float</code></p></h5><p>浮动（<code>float</code>）属性最初在<code>CSS</code>中被引入是为了实现文字环绕图片的效果</p><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img46494deb72014dedbcaa64689d28bada%7Etplv-73owjymdk6-jj-mark-v1_0_0_0_0_5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5LmL6YGT5YmN56uv_q75.webp"></p><p>如果没有<code>float</code>，<code>img</code>默认是<code>inline</code>元素，那么文字图片的显示就会像这样</p><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/imgbed297a2758f4cca969dce9630c17c53%7Etplv-73owjymdk6-jj-mark-v1_0_0_0_0_5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5LmL6YGT5YmN56uv_q75.webp"></p><ul><li>使用<code>float</code>会让元素脱离正常文档流，移动到父容器的左&#x2F;右侧</li><li>后续的块级元素不会受到浮动元素的影响，但其他浮动或行内元素会受影响</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;float: left;&quot;</span>&gt;</span>浮动元素<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>普通元素<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 浮动元素在左侧，普通元素从浮动元素的下方开始排列 --&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>现代的<code>CSS</code>布局技术如<code>Flexbox</code>和<code>Grid</code>已经几乎完全取代了浮动布局，但在某些特定情况下，浮动仍然有其用武之地，比如文字环绕图片和简单的左对齐或右对齐</p></blockquote><h5 id="定位position"><a href="#定位position" class="headerlink" title=" 定位position"></a><p style='font-size: 14px'> 定位<code>position</code></p></h5><p>绝对定位 (<code>absolute</code>)</p><ul><li>使用<code>position: absolute;</code>脱离文档流</li><li>元素的位置由最近的非静态父容器决定，空出的位置会被后续节点填补</li></ul><p>固定定位 (<code>fixed</code>)</p><ul><li>使用<code>position: fixed;</code>脱离文档流</li><li>元素的位置固定在视口的某处，不受滚动影响</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;position: absolute; top: 50px; left: 100px;&quot;</span>&gt;</span>绝对定位元素<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>这是一段普通文本，将填补绝对定位元素的位置。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AWS DVA-C02</title>
      <link href="/posts/31e3742d.html"/>
      <url>/posts/31e3742d.html</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>官网: <a href="https://aws.amazon.com/certification/certified-developer-associate/">https://aws.amazon.com/certification/certified-developer-associate/</a></p><hr><h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><h3 id="1-AWS-Cloud-Overview"><a href="#1-AWS-Cloud-Overview" class="headerlink" title="1. AWS Cloud Overview"></a>1. AWS Cloud Overview</h3><h4 id="AWS-Regions"><a href="#AWS-Regions" class="headerlink" title="AWS Regions"></a>AWS Regions</h4><ul><li>Region 是数据中心集群</li><li>特点<ul><li>地理位置独立</li><li>每个 Region 有多个可用区 (AZ)</li><li>某些服务和资源限定在 Region 内</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img231130.png"></p><ul><li>跨 Region 复用 SSH 密钥<ul><li>从私钥生成公钥</li><li>将公钥导入到每个 Region</li></ul></li></ul><hr><h4 id="AWS-Availability-Zone"><a href="#AWS-Availability-Zone" class="headerlink" title="AWS Availability Zone"></a>AWS Availability Zone</h4><ul><li>每个 Region 包含 3-6 个可用区 (AZ)</li><li>特点<ul><li>物理位置分离，独立供电和网络</li><li>通过高速专用网络连接</li><li>提供故障隔离和高可用性</li></ul></li><li>用途: 部署多 AZ 架构实现容错</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img140727.png"></p><hr><h4 id="AWS-Edge-Locations"><a href="#AWS-Edge-Locations" class="headerlink" title="AWS Edge Locations"></a>AWS Edge Locations</h4><ul><li>向用户低延迟分发内容 (离用户越近，速度越快)</li><li>特点<ul><li>数量远多于 Region (全球 400+ 个)</li><li>缓存内容，减少源服务器负载</li></ul></li><li>主要服务<ul><li>CloudFront (CDN)</li><li>Route 53 (DNS)</li><li>AWS Global Accelerator</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img140903.png"></p><hr><h3 id="2-IAM"><a href="#2-IAM" class="headerlink" title="2. IAM"></a>2. IAM</h3><h4 id="AWS-IAM"><a href="#AWS-IAM" class="headerlink" title="AWS IAM"></a>AWS IAM</h4><ul><li>Root Account - 默认创建, 拥有完全权限, 不要共享</li><li>Users - 组织内的个人用户</li><li>Groups - 只包含 Users, 不包含其他 Groups (User 可属于多个 Group)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img145736.png"></p><ul><li>AWS 需要至少 5 周生成预算预测 (budget forecasts)</li><li>User 默认无法访问 Billing and Cost Management 控制台, 需授权</li></ul><hr><h4 id="IAM-Permissions"><a href="#IAM-Permissions" class="headerlink" title="IAM Permissions"></a>IAM Permissions</h4><ul><li>定义 User 或 Group 的访问权限</li><li>最小权限原则 (Least Privilege Principle) - 只授予必需的最小权限</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img160124.png"></p><ul><li>安全最佳实践<ul><li>不要创建 IAM User 并传递凭证给应用</li><li>不要在应用中嵌入凭证</li><li>使用 IAM Role 替代</li></ul></li></ul><hr><h4 id="IAM-Policies"><a href="#IAM-Policies" class="headerlink" title="IAM Policies"></a>IAM Policies</h4><ul><li>Policy Statement 必须包含: Effect, Principal, Action, Resource</li><li>策略类型<ul><li>Managed Policy - AWS 或客户管理, 可复用</li><li>Inline Policy - 直接附加到单个用户、组或角色</li></ul></li><li>IAM 支持的唯一基于资源的策略: Trust Policy (信任策略)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img175653.png"></p><ul><li>IAM 策略定义操作权限, 与执行方法无关</li></ul><hr><h4 id="IAM-MFA"><a href="#IAM-MFA" class="headerlink" title="IAM MFA"></a>IAM MFA</h4><ul><li>保护 Root Account 和 IAM Users</li><li>MFA 选项<ul><li>Virtual MFA Device - 手机应用 (Google Authenticator, Authy)</li><li>U2F Security Key - 物理 USB 设备 (YubiKey)</li><li>Hardware MFA Device - 硬件令牌</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img180624.png"></p><hr><h4 id="IAM-CLI-amp-SDK"><a href="#IAM-CLI-amp-SDK" class="headerlink" title="IAM CLI &amp; SDK"></a>IAM CLI &amp; SDK</h4><ul><li>AWS 访问方式<ul><li>AWS Management Console - 网页控制台</li><li>AWS CLI - 命令行工具</li><li>AWS SDK - 编程接口 (多种语言)</li></ul></li><li>CLI 使用示例<ul><li>设置 EBS 卷属性: <code>--delete-on-termination=false</code></li><li>批量操作和自动化脚本</li></ul></li><li>考试提示: 遇到脚本或自动化问题, 优先选择 CLI</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img193342.png"></p><hr><h4 id="IAM-Roles"><a href="#IAM-Roles" class="headerlink" title="IAM Roles"></a>IAM Roles</h4><ul><li>定义一组权限供 AWS 服务使用, 提供临时凭证, 无需长期密钥</li><li>常见角色<ul><li>EC2 Instance Role - EC2 访问其他服务</li><li>Lambda Function Role - Lambda 执行权限</li><li>Cross-Account Role - 跨账户访问</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img203306.png"></p><ul><li>优势<ul><li>自动轮换凭证</li><li>安全性高于硬编码密钥</li><li>遵循最小权限原则</li></ul></li></ul><hr><h4 id="IAM-Security-Tools"><a href="#IAM-Security-Tools" class="headerlink" title="IAM Security Tools"></a>IAM Security Tools</h4><ul><li>IAM Credentials Report (账户级别)<ul><li>列出所有用户及其凭证状态</li><li>用于审计和合规性检查</li></ul></li><li>IAM Access Advisor (用户级别)<ul><li>显示用户授权的服务和最后访问时间</li><li>用于识别未使用的权限, 实现最小权限</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img203553.png"></p><hr><h3 id="3-EC2-Fundamentals"><a href="#3-EC2-Fundamentals" class="headerlink" title="3. EC2 Fundamentals"></a>3. EC2 Fundamentals</h3><h4 id="AWS-EC2"><a href="#AWS-EC2" class="headerlink" title="AWS EC2"></a>AWS EC2</h4><ul><li>EC2 &#x3D; Elastic Compute Cloud &#x3D; IaaS</li><li>绑定到特定可用区 (AZ)</li><li>Instance Metadata<ul><li>访问元数据: <code>http://169.254.169.254/latest/meta-data/</code></li><li>获取公有 IP: <code>http://169.254.169.254/latest/meta-data/public-ipv4</code></li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img214749.png"></p><ul><li>User Data<ul><li>实例启动时自动执行的脚本</li><li>默认仅在首次启动时运行</li><li>以 root 用户权限执行</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img214956.png"></p><ul><li>监控和优化<ul><li>启用详细监控: <code>aws ec2 monitor-instances --instance-ids &#123;id&#125;</code></li><li>降低 CPU 使用率方案 (SSL 卸载): 在 ALB 上配置 SSL&#x2F;TLS 证书 (通过 ACM) → 创建 HTTPS 监听器并启用 SSL 终止 → 减轻 EC2 实例的 SSL 处理负担</li></ul></li></ul><hr><h4 id="EC2-Instance-Type"><a href="#EC2-Instance-Type" class="headerlink" title="EC2 Instance Type"></a>EC2 Instance Type</h4><ul><li>7 种实例类型, 常用 4 种</li><li>General Purpose (通用型)<ul><li>计算、内存、网络资源平衡</li><li>适用于 Web 服务器、小型数据库</li></ul></li><li>Compute Optimized (计算优化型)<ul><li>高性能处理器</li><li>适用于批处理、视频编码、HPC、机器学习</li></ul></li><li>Memory Optimized (内存优化型)<ul><li>大内存, 内存中处理数据</li><li>适用于缓存、实时大数据分析、内存数据库</li></ul></li><li>Storage Optimized (存储优化型)<ul><li>高速本地存储读写</li><li>适用于 OLTP、数据仓库、分布式文件系统</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img220941.png"></p><hr><h4 id="EC2-Security-Groups"><a href="#EC2-Security-Groups" class="headerlink" title="EC2 Security Groups"></a>EC2 Security Groups</h4><ul><li>控制 EC2 实例的入站和出站流量 (类似虚拟防火墙)</li><li>只包含允许规则 (默认拒绝所有)</li><li>状态化: 允许的入站流量自动允许出站响应</li><li>绑定到 Region&#x2F;VPC</li><li>Inbound Rule 来源类型<ul><li>IP 地址 (单个 IP)</li><li>CIDR 块 (IP 范围)</li><li>另一个 Security Group (引用)</li></ul></li><li>故障排查提示: EC2 连接问题优先检查 Security Group</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img222531.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img223020.png"></p><hr><h4 id="EC2-Instance-Purchasing-Options"><a href="#EC2-Instance-Purchasing-Options" class="headerlink" title="EC2 Instance Purchasing Options"></a>EC2 Instance Purchasing Options</h4><ul><li>On-Demand Instances<ul><li>按秒计费, 无长期承诺</li><li>适用于短期、不可预测的工作负载</li></ul></li><li>Reserved Instances (1-3 年)<ul><li>Standard RI - 最高 72% 折扣, 固定实例类型</li><li>Convertible RI - 最高 66% 折扣, 可更改实例类型</li><li>范围: Regional (无容量预留) &#x2F; Zonal (有容量预留)</li></ul></li><li>Savings Plans (1-3 年)<ul><li>承诺使用量, 最高 72% 折扣</li><li>超出承诺部分按 On-Demand 计费</li><li>Compute Savings Plan - 66% 折扣, 适用于 Lambda 和 Fargate</li></ul></li><li>Spot Instances<ul><li>最高 90% 折扣, 最便宜</li><li>可能被随时中断, 适合容错工作负载</li></ul></li><li>Dedicated Hosts<ul><li>完全独占物理服务器, 最贵</li><li>可控制实例放置, 满足合规要求</li></ul></li><li>Dedicated Instances<ul><li>独立硬件运行, 但不锁定到特定服务器</li></ul></li><li>Capacity Reservations<ul><li>预留特定 AZ 的容量</li><li>适用于短时间需要保证容量的场景</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img224149.png"></p><hr><h3 id="4-EC2-Instance-Storage"><a href="#4-EC2-Instance-Storage" class="headerlink" title="4. EC2 Instance Storage"></a>4. EC2 Instance Storage</h3><h4 id="AWS-EBS"><a href="#AWS-EBS" class="headerlink" title="AWS EBS"></a>AWS EBS</h4><ul><li>块级存储 (Block-level storage), 类似网络硬盘</li><li>绑定到特定 AZ, 无法跨 AZ 使用</li><li>需要预配置容量 (Provisioned Capacity)</li><li>可以从一个 EC2 实例卸载并挂载到另一个实例</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img191440.png"></p><ul><li>Delete on Termination 属性<ul><li>根卷 (Root Volume) 默认在实例终止时删除</li><li>其他 EBS 卷默认在实例终止时保留</li><li>可通过 AWS Console 或 AWS CLI 控制此行为</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img002840.png"></p><ul><li>EBS 加密<ul><li>默认加密是 Region 级别设置, 启用后无法对该 Region 的单个卷或快照禁用</li><li>从加密快照恢复的卷或加密快照的副本始终保持加密状态</li></ul></li></ul><hr><h4 id="EBS-Snapshots"><a href="#EBS-Snapshots" class="headerlink" title="EBS Snapshots"></a>EBS Snapshots</h4><ul><li>EBS 卷备份, 可以跨 AZ 或 Region 使用快照</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img195715.png"></p><ul><li>Snapshot Archive - 成本降低 75%, 恢复时间 24-72 小时</li><li>Recycle Bin - 设置规则保留已删除的快照, 支持恢复</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img195833.png"></p><hr><h4 id="AWS-AMI"><a href="#AWS-AMI" class="headerlink" title="AWS AMI"></a>AWS AMI</h4><ul><li>AMI (Amazon Machine Image) - EC2 实例的自定义镜像, 可以更快速地启动和配置 EC2 实例</li><li>构建在特定 Region 中, 可以跨 Region 复制</li><li>跨 Region 复制时会在目标 Region 自动创建 snapshot</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img200249.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img200341.png"></p><hr><h4 id="EC2-Instance-Store"><a href="#EC2-Instance-Store" class="headerlink" title="EC2 Instance Store"></a>EC2 Instance Store</h4><ul><li>物理硬盘 (Physical drive), 块级临时存储</li><li>高随机 I&#x2F;O 性能</li><li>适合缓存、临时数据、缓冲区等低成本场景</li><li>实例停止或终止时数据丢失 (Ephemeral)</li><li>数据不会持久化, 无法在实例间复用</li><li>典型使用场景: 临时数据处理、高性能缓存</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img203146.png"></p><hr><h4 id="EBS-Volume-Types"><a href="#EBS-Volume-Types" class="headerlink" title="EBS Volume Types"></a>EBS Volume Types</h4><ul><li>General Purpose SSD (gp2&#x2F;gp3) - 性价比高, 平衡性能<ul><li>gp3 最大 IOPS 16,000</li><li>适用于大多数工作负载</li></ul></li><li>Provisioned IOPS SSD (io1&#x2F;io2) - 高性能, 支持 Multi-Attach<ul><li>低延迟, 高吞吐量</li><li>IOPS 更高但成本也更高</li><li>适用于关键业务应用和数据库</li></ul></li><li>Hard Disk Drives (HDD)<ul><li>Throughput Optimized (st1) - 大数据, 数据仓库</li><li>Cold HDD (sc1) - 不频繁访问的数据</li><li>不能用作 EC2 启动卷</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img203437.png"></p><hr><h4 id="EBS-Multi-Attach"><a href="#EBS-Multi-Attach" class="headerlink" title="EBS Multi-Attach"></a>EBS Multi-Attach</h4><ul><li>将同一个 EBS 卷挂载到同一 AZ 中的多个 EC2 实例</li><li>仅支持 io1&#x2F;io2 系列 (Provisioned IOPS SSD)</li><li>适用场景: 集群应用, 高可用性应用</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img203956.png"></p><hr><h4 id="EBS-RAID"><a href="#EBS-RAID" class="headerlink" title="EBS RAID"></a>EBS RAID</h4><ul><li>RAID 0 (性能优先)<ul><li>I&#x2F;O 性能比容错更重要时使用</li><li>通过条带化提高性能</li><li>无冗余, 任何磁盘故障导致数据丢失</li></ul></li><li>RAID 1 (容错优先)<ul><li>容错比 I&#x2F;O 性能更重要时使用</li><li>数据镜像, 提供冗余</li><li>可用容量减半</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/imgpt6-q37-i1.jpg"></p><hr><h4 id="AWS-EFS"><a href="#AWS-EFS" class="headerlink" title="AWS EFS"></a>AWS EFS</h4><ul><li>NFS (网络文件系统), 可挂载到多个 EC2 实例</li><li>自动扩展, 高可用, 无需容量规划</li><li>可跨 AZ, Region, VPC 访问</li><li>使用 VPC Security Group 或 IAM Policy 控制访问</li><li>仅支持 Linux 实例 (POSIX 兼容), 不支持 Windows</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img233415.png"></p><ul><li>Performance Mode (创建时设置)<ul><li>General Purpose - 默认模式, 低延迟 (适用于 Web 服务器)</li><li>Max I&#x2F;O - 高延迟但高吞吐量, 高并行 (适用于大数据, 媒体处理)</li></ul></li><li>Throughput Mode<ul><li>Bursting - 吞吐量随存储量增长</li><li>Provisioned - 设置固定吞吐量上限 (适用于大量文件迁移)</li><li>Elastic - 根据工作负载自动扩展</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img233732.png"></p><ul><li>存储类别<ul><li>Standard - 频繁访问</li><li>Infrequent Access (EFS-IA) - 成本优化, 不频繁访问的文件</li></ul></li><li>存储方案对比<ul><li>EBS - 高 IOPS, 单实例挂载, 性能最快</li><li>EFS - 共享文件系统, 可跨 AZ, 自动扩展</li><li>S3 - 对象存储, 成本最低</li></ul></li></ul><hr><h3 id="5-ELB-amp-ASG"><a href="#5-ELB-amp-ASG" class="headerlink" title="5. ELB &amp; ASG"></a>5. ELB &amp; ASG</h3><h4 id="Scalability-amp-High-Availability"><a href="#Scalability-amp-High-Availability" class="headerlink" title="Scalability &amp; High Availability"></a>Scalability &amp; High Availability</h4><ul><li>Vertical Scaling (垂直扩展) - 增加实例大小, 例如从 t2.micro 升级到 t2.large</li><li>Horizontal Scaling (水平扩展) - 增加实例数量, 例如从 1 个实例扩展到 10 个实例</li><li>High Availability (高可用性) - 在至少 2 个 AZ 中运行应用, 实现容灾和故障转移</li><li>常见的高可用 + 高扩展架构: ALB + ECS, API Gateway + Lambda</li></ul><hr><h4 id="AWS-ELB"><a href="#AWS-ELB" class="headerlink" title="AWS ELB"></a>AWS ELB</h4><ul><li>将流量分发到多个 EC2 实例, 跨 AZ 实现高可用</li><li>自动处理下游实例故障, 通过健康检查 (Health Check) 监控实例状态</li><li>架构设计: ELB 部署在 public subnet, ASG 部署在 private subnet, 分离公共流量和私有流量</li><li>限制: 无法跨 Region 分发流量, 使用端口范围 1024-65535</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img141400.png"></p><ul><li>三种类型<ul><li>Application Load Balancer (ALB) - HTTP&#x2F;HTTPS, Layer 7, 提供静态 DNS</li><li>Network Load Balancer (NLB) - TCP&#x2F;UDP, Layer 4, 提供静态 DNS 和静态 IP</li><li>Gateway Load Balancer (GWLB) - 安全检查, Layer 3</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img090125.png"></p><ul><li>流量不均衡的常见原因: 特定容量类型的实例在 AZ 间分布不均, 或启用了粘性会话 (Sticky Sessions)</li></ul><hr><h4 id="Application-Load-Balancer-ALB"><a href="#Application-Load-Balancer-ALB" class="headerlink" title="Application Load Balancer (ALB)"></a>Application Load Balancer (ALB)</h4><ul><li>Layer 7 负载均衡, 支持 HTTP&#x2F;HTTPS 和 WebSocket</li><li>多种路由规则<ul><li>基于路径 (<code>/home</code>, <code>/api</code>)</li><li>基于查询字符串 (<code>?platform=mobile</code>)</li><li>基于主机名 (<code>api.example.com</code>)</li><li>基于 HTTP 头部</li><li>基于客户端 IP</li></ul></li><li>自动添加 <code>X-Forwarded-For</code> 头部包含客户端真实 IP</li><li>可配置 HTTP 到 HTTPS 重定向</li><li>不支持静态 IP (仅 NLB 支持静态 IP)</li><li>Access Logs 可用于分析请求延迟和 IP 地址</li><li>Target 类型: EC2 实例 (Instance)、IP 地址 (不支持公网 IP)、Lambda 函数</li><li>错误排查: HTTP 503 错误表示未注册任何目标</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img192523.png"></p><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img142631.png"></p><hr><h4 id="Network-Load-Balancer-NLB"><a href="#Network-Load-Balancer-NLB" class="headerlink" title="Network Load Balancer (NLB)"></a>Network Load Balancer (NLB)</h4><ul><li>Layer 4 负载均衡, 支持 TCP&#x2F;UDP</li><li>超低延迟和高吞吐量, 适用于银行交易、游戏服务器等高性能需求场景</li><li>每个 AZ 一个静态 IP, 支持分配 Elastic IP</li><li>支持 HTTP、TCP、HTTPS 健康检查</li><li>Target 路由方式<ul><li>使用实例 ID - 流量路由到主网络接口的主私有 IP</li><li>使用 IP - 直接路由到指定 IP</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img144359.png"></p><hr><h4 id="Gateway-Load-Balancer-GWLB"><a href="#Gateway-Load-Balancer-GWLB" class="headerlink" title="Gateway Load Balancer (GWLB)"></a>Gateway Load Balancer (GWLB)</h4><ul><li>Layer 3 负载均衡 (网络层)</li><li>部署和管理第三方虚拟设备 (防火墙、IDS&#x2F;IPS、深度包检测)</li><li>对多个 VPC 流量进行内联检查</li><li>使用 GENEVE 协议, 端口 6081</li><li>简化和扩展安全设备部署</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img223042.png"></p><hr><h4 id="Sticky-Sessions-Session-Affinity"><a href="#Sticky-Sessions-Session-Affinity" class="headerlink" title="Sticky Sessions (Session Affinity)"></a>Sticky Sessions (Session Affinity)</h4><ul><li>同一客户端始终路由到同一后端实例, 保持会话数据 (例如用户登录状态)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img223425.png"></p><ul><li>Cookie 类型<ul><li>Application-based Cookies - 应用自定义 Cookie (不能使用保留名称: AWSALB, AWSALBAPP, AWSALBTG)</li><li>Duration-based Cookies - 负载均衡器生成的 Cookie (ALB 使用 AWSALB, CLB 使用 AWSELB)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img223604.png"></p><hr><h4 id="Cross-Zone-Load-Balancing"><a href="#Cross-Zone-Load-Balancing" class="headerlink" title="Cross Zone Load Balancing"></a>Cross Zone Load Balancing</h4><ul><li>在所有 AZ 的所有实例间均匀分配流量</li><li>启用时每个实例接收相同流量, 未启用时流量在 AZ 级别均分后再在 AZ 内部均分</li><li>默认设置: ALB 默认启用, NLB 和 GWLB 默认禁用</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img230059.png"></p><hr><h4 id="SSL-Certificates"><a href="#SSL-Certificates" class="headerlink" title="SSL Certificates"></a>SSL Certificates</h4><ul><li>加密客户端与负载均衡器之间的流量 (HTTPS)</li><li>证书管理服务<ul><li>AWS Certificate Manager (ACM) - 推荐使用</li><li>IAM - 也支持存储和部署证书</li></ul></li><li>SNI (Server Name Indication)<ul><li>在一个 Web 服务器上加载多个 SSL 证书</li><li>适用于需要管理多个 SSL&#x2F;TLS 证书的场景</li><li>仅 ALB 和 NLB 支持 (CLB 不支持)</li><li>允许在同一监听器上暴露多个 HTTPS 应用, 每个应用有自己的证书</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img230614.png"></p><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img230910.png"></p><hr><h4 id="Deregistration-Delay-Connection-Draining"><a href="#Deregistration-Delay-Connection-Draining" class="headerlink" title="Deregistration Delay (Connection Draining)"></a>Deregistration Delay (Connection Draining)</h4><ul><li>等待正在进行的连接完成后再注销实例</li><li>允许负载均衡器完成发送到正在注销或不健康实例的请求, 防止用户请求中断</li><li>默认时间 300 秒 (可配置 0-3600 秒)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img231418.png"></p><hr><h4 id="AWS-ASG"><a href="#AWS-ASG" class="headerlink" title="AWS ASG"></a>AWS ASG</h4><ul><li>根据需求自动扩展或缩减 EC2 实例数量 (服务本身免费)</li><li>设置最小&#x2F;最大实例数量, 配合 ELB 使用实现高可用和负载均衡</li><li>在单个 Region 内跨多个 AZ 扩展, 无法跨 Region</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img232350.png"></p><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img232615.png"></p><ul><li>实例终止策略<ul><li>不健康实例 - 先终止不健康实例, 再创建新实例</li><li>AZ 不平衡 - 先启动新实例, 再终止旧实例</li><li>同 AZ 内 - 优先终止最早启动的实例</li></ul></li><li>Launch Template vs Launch Configuration<ul><li>Launch Template (推荐) - 支持版本控制, 支持多种实例类型 (Spot, On-Demand 混合)</li><li>Launch Configuration (旧版) - 不可修改, 需要重新创建</li><li>更新方式: 创建新版本的 Launch Template, ASG 使用新版本</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img232823.png"></p><ul><li>扩展策略<ul><li>Target Tracking - 维持目标指标 (如 CPU 使用率 50%)</li><li>Simple&#x2F;Step Scaling - 基于 CloudWatch 告警</li><li>Scheduled Scaling - 基于时间计划 (节日前扩展等)</li><li>Predictive Scaling - 基于历史数据预测</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img232959.png"></p><ul><li>Scaling Cooldown (冷却期) - 扩展活动后进入冷却期 (默认 300 秒), 防止频繁扩展导致成本增加</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img025149.png"></p><ul><li>ASG 不终止实例的情况<ul><li>实例健康检查宽限期未过期</li><li>实例处于 Impaired 状态</li><li>ELB 健康检查失败但 EC2 健康检查类型未更改</li></ul></li><li>故障排查: 如果 ASG 未替换不健康实例, 需要将健康检查类型从 EC2 改为 ELB</li></ul><hr><h4 id="Scaling-Policies"><a href="#Scaling-Policies" class="headerlink" title="Scaling Policies"></a>Scaling Policies</h4><ul><li>Target Tracking Scaling - 维持目标指标 (例如 CPU 使用率保持 50%, SQS 队列长度保持 1000), 自动创建和管理 CloudWatch 告警</li><li>Simple&#x2F;Step Scaling - 基于 CloudWatch 告警触发<ul><li>Simple - 单一扩展动作</li><li>Step - 根据告警严重程度分级扩展</li></ul></li><li>Scheduled Actions - 基于时间计划扩展 (例如感恩节、黑五等可预测流量高峰)</li><li>Predictive Scaling - 基于历史数据预测负载并提前扩展, 使用机器学习分析历史模式</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img233532.png"></p><ul><li>任何扩展策略都不会超过 ASG 设置的 maximum capacity</li></ul><hr><h4 id="ASG-Instance-Refresh"><a href="#ASG-Instance-Refresh" class="headerlink" title="ASG Instance Refresh"></a>ASG Instance Refresh</h4><ul><li>更新 Launch Template 后自动重新创建所有 EC2 实例</li><li>逐步替换实例保证可用性, 可设置最小健康百分比 (默认 90%) 和预热时间 (Warm-up time)</li><li>使用场景: 部署新 AMI, 更新用户数据, 更改实例类型</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img212220.png"></p><hr><h3 id="6-AWS-Fundamentals"><a href="#6-AWS-Fundamentals" class="headerlink" title="6. AWS Fundamentals"></a>6. AWS Fundamentals</h3><h4 id="AWS-RDS"><a href="#AWS-RDS" class="headerlink" title="AWS RDS"></a>AWS RDS</h4><ul><li>托管的关系型数据库服务, 支持 MySQL、PostgreSQL、MariaDB、Oracle、MS SQL Server、Aurora</li><li>对比自建 EC2 数据库的优势<ul><li>自动完成配置、操作系统补丁和备份</li><li>存储容量自动扩展</li><li>支持 Read Replicas (最多 15 个) 提升读性能</li><li>支持 Multi-AZ 部署实现高可用</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img161720.png"></p><ul><li>Read Replicas (读副本)<ul><li>提高读取性能 (不是存储扩展, 也不是高可用方案)</li><li>适用于报表、分析等读密集型工作负载</li><li>支持跨 Region 部署, 可作为灾难恢复备份</li><li>主库加密时副本也会自动加密</li><li>成本比主库更高</li></ul></li><li>Multi-AZ (多可用区) - 提供高可用性<ul><li>主实例数据同步复制到不同 AZ 的备用实例</li><li>故障时自动切换到备用实例</li><li>更新流程: 先更新备用实例 → 提升为主实例 → 更新原主实例 → 原主实例变为新备用 (过程中会短暂停机)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img161952.png"></p><ul><li>Storage Auto Scaling - 适用于工作负载不可预测的应用, 自动扩展存储容量</li><li>IAM Database Authentication - 使用 IAM 角色访问数据库, 无需密码, 使用令牌</li><li>灾难恢复策略: 在不同 Region 创建 Read Replica, 并在 Read Replica 上启用 Multi-AZ</li><li>迁移到 Aurora: 从 RDS Read Replica 迁移到 Aurora Read Replica, 最小变更, 适用于 Read Replica 场景</li></ul><hr><h4 id="Read-Replicas-vs-Multi-AZ"><a href="#Read-Replicas-vs-Multi-AZ" class="headerlink" title="Read Replicas vs. Multi AZ"></a>Read Replicas vs. Multi AZ</h4><ul><li>Read Replicas (读副本) - 提升可扩展性和读取性能<ul><li>异步复制 (Async Replication) 数据</li><li>可部署在同 AZ、跨 AZ 或跨 Region</li><li>同 Region 复制免费, 跨 Region 收费</li><li>无法从未加密的主库创建加密副本</li><li>典型场景: 生产库处理日常业务, 副本处理报表和分析工作</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img173522.png"></p><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img173820.png"></p><ul><li>Multi-AZ (多可用区) - 实现高可用性和灾难恢复<ul><li>同步复制 (Sync Replication) 数据</li><li>仅支持同 Region 不同 AZ</li><li>主库故障时 CNAME 自动更新指向备用实例</li><li>应用层无需更改 SQL 连接字符串</li><li>不用于读取扩展, 备用实例不接受读请求</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img174148.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img174357.png"></p><hr><h4 id="AWS-Aurora"><a href="#AWS-Aurora" class="headerlink" title="AWS Aurora"></a>AWS Aurora</h4><ul><li>兼容性: PostgreSQL 和 MySQL</li><li>特性<ul><li>存储自动扩展 (无需管理)</li><li>性能比 RDS 快 5 倍 (MySQL) 或 3 倍 (PostgreSQL)</li><li>无备用数据库概念, Aurora Replica 作为故障转移目标</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img183915.png"></p><ul><li>高可用性与读扩展<ul><li>架构: 1 个主实例 (写), 最多 15 个副本 (读), 共 16 个实例</li><li>故障转移: 副本层级 (Tier) 越高, 优先提升为主实例</li><li>网络请求激增: 使用 Aurora Read Replica</li></ul></li><li>Aurora Serverless<ul><li>自动扩展计算容量</li><li>适用场景: 不可预测或间歇性工作负载</li><li>按需付费, 无需管理容量</li></ul></li><li>Aurora Database Cloning<ul><li>快速创建数据库副本</li><li>使用写时复制 (Copy-on-write) 协议</li><li>适用场景: 测试环境, 开发环境</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img184105.png"></p><hr><h4 id="RDS-Security"><a href="#RDS-Security" class="headerlink" title="RDS Security"></a>RDS Security</h4><ul><li>静态加密 (At-rest Encryption)<ul><li>使用 AWS KMS 加密数据库和备份</li><li>必须在创建时启用</li><li>无法加密现有未加密的数据库</li></ul></li><li>传输加密 (In-flight Encryption)<ul><li>使用 TLS&#x2F;SSL 证书</li><li>强制客户端使用 SSL 连接</li></ul></li><li>IAM Authentication<ul><li>使用 IAM 角色连接数据库</li><li>无需密码, 使用认证令牌</li><li>令牌有效期 15 分钟</li><li>支持 MySQL 和 PostgreSQL</li></ul></li><li>Security Groups<ul><li>控制网络访问</li><li>定义允许的 IP 和端口</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img133048.png"></p><hr><h4 id="RDS-Proxy"><a href="#RDS-Proxy" class="headerlink" title="RDS Proxy"></a>RDS Proxy</h4><ul><li>功能: 数据库连接代理<ul><li>连接池和复用, 减少数据库打开的连接数</li><li>提高数据库效率, 降低数据库压力</li><li>故障转移时间减少 66%</li><li>强制使用 IAM 身份验证</li></ul></li><li>特性<ul><li>Serverless, 自动扩展</li><li>高可用 (Multi-AZ)</li><li>仅 VPC 内访问 (非公开访问, 重要)</li></ul></li><li>适用场景<ul><li>Lambda 函数连接数据库 (避免连接数耗尽)</li><li>连接数高的应用</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img184531.png"></p><hr><h4 id="AWS-ElastiCache"><a href="#AWS-ElastiCache" class="headerlink" title="AWS ElastiCache"></a>AWS ElastiCache</h4><ul><li>托管的内存数据库服务: Redis 或 Memcached<ul><li>解决数据库高频读取问题</li><li>高性能、低延迟</li><li>减轻数据库读密集型工作负载</li><li>帮助应用无状态化</li></ul></li><li>限制<ul><li>不支持关系型数据库功能</li><li>不支持 SQL 查询</li><li>不用于 S3 缓存 (S3 使用 CloudFront)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img184841.png"></p><ul><li>使用场景 1: 数据库缓存<ul><li>先查询 ElastiCache</li><li>未命中则从 RDS 读取并存入缓存</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img185024.png"></p><ul><li>使用场景 2: 用户会话存储<ul><li>将会话数据写入 ElastiCache</li><li>其他实例可共享会话, 保持用户登录状态</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img185153.png"></p><ul><li>Redis vs Memcached<ul><li>Redis<ul><li>支持 Read Replicas (集群模式禁用时最多 5 个)</li><li>高可用 (Multi-AZ)</li><li>持久化: 备份和恢复</li><li>数据类型丰富: 列表、集合、排序集合等</li><li>单线程</li></ul></li><li>Memcached<ul><li>无高可用</li><li>无持久化, 有数据丢失风险</li><li>数据类型简单</li><li>支持多线程</li></ul></li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img185310.png"></p><ul><li>Redis Cluster 限制<ul><li>所有节点必须在同一 Region</li><li>集群模式启用时, 无法手动提升副本为主节点</li></ul></li></ul><hr><h4 id="ElastiCache-Strategies"><a href="#ElastiCache-Strategies" class="headerlink" title="ElastiCache Strategies"></a>ElastiCache Strategies</h4><ul><li>Lazy Loading (延迟加载 &#x2F; Cache-Aside)<ul><li>机制: 仅在请求时加载数据到缓存</li><li>优点: 只缓存请求的数据, 节省内存</li><li>缺点<ul><li>缓存未命中时需要 3 次往返 (读缓存 → 读数据库 → 写缓存)</li><li>可能存在过期数据</li></ul></li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img200816.png"></p><ul><li>Write Through (写入式)<ul><li>机制: 写入数据库时同时写入缓存</li><li>优点: 缓存数据始终最新, 读延迟低</li><li>缺点<ul><li>写入需要 2 次调用, 写延迟高</li><li>数据库中新增或更新前缓存中没有数据</li><li>可能缓存大量不常用数据</li></ul></li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img201308.png"></p><ul><li>Cache Eviction (缓存淘汰) 和 TTL<ul><li>Cache Eviction: 缓存达到上限时的数据清理策略<ul><li>LRU (Least Recently Used): 删除最少使用的数据</li><li>LFU (Least Frequently Used): 删除使用频率最低的数据</li></ul></li><li>TTL (Time-to-Live): 设置数据过期时间<ul><li>防止数据过期</li><li>平衡数据新鲜度和缓存效率</li><li>建议: 根据应用需求设置合适的 TTL</li></ul></li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img201512.png"></p><hr><h4 id="MemoryDB-for-Redis"><a href="#MemoryDB-for-Redis" class="headerlink" title="MemoryDB for Redis"></a>MemoryDB for Redis</h4><ul><li>Redis 兼容的持久化内存数据库服务</li><li>特性<ul><li>持久化内存数据存储</li><li>Multi-AZ 事务日志</li><li>微秒级读延迟, 个位数毫秒写延迟</li></ul></li><li>与 ElastiCache for Redis 的区别<ul><li>MemoryDB: 持久化, 可作为主数据库</li><li>ElastiCache: 缓存, 数据可能丢失</li></ul></li><li>使用场景: 需要持久化的高性能数据库 (Web&#x2F;移动应用, 游戏排行榜等)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img201727.png"></p><hr><h3 id="7-Route-53"><a href="#7-Route-53" class="headerlink" title="7. Route 53"></a>7. Route 53</h3><h4 id="What’s-DNS"><a href="#What’s-DNS" class="headerlink" title="What’s DNS"></a>What’s DNS</h4><ul><li>DNS (Domain Name System) 将域名解析为 IP 地址 (如 <code>www.google.com</code> → <code>172.217.18.36</code>)</li><li>分层结构 - 根域名服务器 → 顶级域名服务器 → 权威域名服务器</li><li>缓存提高解析速度, 减少查询次数</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img213136.png"></p><hr><h4 id="AWS-Route-53"><a href="#AWS-Route-53" class="headerlink" title="AWS Route 53"></a>AWS Route 53</h4><ul><li>AWS 托管 DNS 服务 - 高可用、可扩展, 支持域名注册和 DNS 记录更新</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img213527.png"></p><ul><li>DNS 记录组成 - 域名 (Domain Name), 记录类型 (Record Type), 值 (Value), 路由策略 (Routing Policy), TTL (Time To Live)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img213613.png"></p><ul><li>记录类型<ul><li>A - 域名映射到 IPv4 地址</li><li>AAAA - 域名映射到 IPv6 地址</li><li>CNAME - 域名映射到另一个域名 (不能用于根域名)</li><li>NS - 托管区域的名称服务器</li><li>MX - 邮件服务器</li><li>TXT - 文本记录 (验证、SPF 等)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img213753.png"></p><ul><li><strong>Hosted Zones</strong> (托管区域)<ul><li>Public Hosted Zones - 公共域名, 互联网可访问</li><li>Private Hosted Zones - 私有域名, 仅 VPC 内访问, - VPC 必须启用 DNS hostnames 和 DNS resolution</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img234126.png"></p><ul><li>第三方域名注册商集成 (如 GoDaddy) - 在 Route 53 创建 Public Hosted Zone, 在第三方注册商更新 NS 记录指向 Route 53</li><li><strong>Health Check</strong> (健康检查) - 监控终端节点健康状态, 与路由策略集成实现故障转移, - ELB 故障时切换到备用资源</li></ul><hr><h4 id="Route-53-TTL"><a href="#Route-53-TTL" class="headerlink" title="Route 53 TTL"></a>Route 53 TTL</h4><ul><li>TTL (Time To Live) - DNS 记录的缓存时间, 定义客户端缓存 DNS 解析结果的时长</li><li><ul><li>后端更新不会立即生效, 需等待 TTL 过期</li></ul></li><li>高 TTL (如 24 小时) - 减少 Route 53 查询成本但更新生效慢</li><li>低 TTL (如 60 秒) - 更新生效快但查询成本高</li><li>修改记录前先降低 TTL, 等待生效后再修改</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img232659.png"></p><hr><h4 id="CNAME-vs-Alias"><a href="#CNAME-vs-Alias" class="headerlink" title="CNAME vs Alias"></a>CNAME vs Alias</h4><ul><li><strong>CNAME</strong> (Canonical Name) - 将一个域名指向另一个域名, 不能用于根域名 (如 example.com), 需要付费查询</li><li><strong>Alias</strong> (别名记录)<ul><li>将域名指向 AWS 资源</li><li><ul><li>可用于根域名, 免费查询, 自动识别 AWS 资源 IP 变化</li></ul></li><li>支持目标 - ELB, CloudFront, S3, API Gateway, Elastic Beanstalk 等</li><li>限制不支持 EC2 DNS 名称</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img233313.png"></p><hr><h4 id="Health-Checks"><a href="#Health-Checks" class="headerlink" title="Health Checks"></a>Health Checks</h4><ul><li><ul><li>仅适用于公共资源</li></ul></li><li><ul><li>检查类型</li><li><strong>Endpoint Health Checks</strong> - 监控端点健康状态 (HTTP, HTTPS, TCP), 默认每 30 秒检查一次 (可设置为 10 秒但费用更高), 18% 以上检查者报告健康则判定为健康</li><li><strong>Calculated Health Checks</strong> - 组合多个健康检查, 支持 OR, AND, NOT 逻辑, 可监控最多 256 个子健康检查</li><li><strong>CloudWatch Alarm Health Checks</strong> - 基于 CloudWatch 指标, 适用于私有资源监控</li></ul></li><li>与路由策略集成实现自动故障转移</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img000106.png"></p><hr><h4 id="Routing-Policy-Simple"><a href="#Routing-Policy-Simple" class="headerlink" title="Routing Policy (Simple)"></a>Routing Policy (Simple)</h4><ul><li>共 7 种路由策略 - Simple, Weighted, Latency, Failover, Geolocation, Geoproximity, Multi-Value</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img234623.png"></p><ul><li><strong>Simple</strong> (简单路由) - 将流量路由到单个资源, 可返回多个值 (客户端随机选择), 不支持健康检查, 用于单个资源或不需要流量控制的简单场景</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img234350.png"></p><hr><h4 id="Routing-Policy-Weighted"><a href="#Routing-Policy-Weighted" class="headerlink" title="Routing Policy (Weighted)"></a>Routing Policy (Weighted)</h4><ul><li><strong>Weighted</strong> (加权路由) - 按百分比控制流量分配到各个资源</li><li>计算 - 权重 &#x3D; 特定记录权重 &#x2F; 所有记录权重总和</li><li>支持健康检查 (不健康的资源不接收流量)</li><li>使用场景 - A&#x2F;B 测试, 跨区域负载均衡, 金丝雀发布 (逐步迁移流量)</li><li>设置权重为 0 停止向该资源发送流量</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img234856.png"></p><hr><h4 id="Routing-Policy-Latency"><a href="#Routing-Policy-Latency" class="headerlink" title="Routing Policy (Latency)"></a>Routing Policy (Latency)</h4><ul><li><strong>Latency</strong> (延迟路由) - 将用户重定向到延迟最低的资源</li><li>延迟基准 - 用户与 AWS Region 之间的网络延迟</li><li>支持健康检查 (自动切换到次优延迟资源)</li><li>使用场景 - 全球分布的应用, 需要最佳用户体验的服务, 跨区域部署的应用</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img235654.png"></p><hr><h4 id="Routing-Policy-Failover"><a href="#Routing-Policy-Failover" class="headerlink" title="Routing Policy (Failover)"></a>Routing Policy (Failover)</h4><ul><li><strong>Failover</strong> (故障转移路由) - 主实例 (Primary) + 备用实例 (Secondary)</li><li>主实例不健康时自动切换到备用实例</li><li><ul><li>仅支持 Active-Passive 模式, 不支持 Active-Active</li></ul></li><li>必须配置健康检查监控主实例</li><li>使用场景 - 灾难恢复, 维护窗口切换, 主备站点架构</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img150940.png"></p><hr><h4 id="Routing-Policy-Geolocation"><a href="#Routing-Policy-Geolocation" class="headerlink" title="Routing Policy (Geolocation)"></a>Routing Policy (Geolocation)</h4><ul><li><strong>Geolocation</strong> (地理位置路由) - 基于用户地理位置路由流量</li><li>位置粒度 - 洲 &gt; 国家 &gt; 州 (美国)</li><li><ul><li>必须创建”默认”记录处理未匹配的位置</li></ul></li><li>支持健康检查 (位置不健康时使用下一优先级位置)</li><li>使用场景 - 网站本地化 (不同国家显示不同语言), 内容分发限制 (版权地域限制), 负载均衡基于用户位置</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img151650.png"></p><hr><h4 id="Routing-Policy-Geoproximity"><a href="#Routing-Policy-Geoproximity" class="headerlink" title="Routing Policy (Geoproximity)"></a>Routing Policy (Geoproximity)</h4><ul><li><strong>Geoproximity</strong> (地理邻近路由) - 基于用户和资源的地理位置路由流量</li><li><ul><li><strong>Bias</strong> (偏移值)</li><li>范围 -99 到 99</li><li>正值 - 扩大地理区域, 吸引更多流量</li><li>负值 - 缩小地理区域, 减少流量</li></ul></li><li>资源位置可设为 AWS Region 或自定义经纬度坐标</li><li>使用场景 - 精细控制区域流量分配, 逐步迁移用户到新区域, 平衡跨区域负载</li><li>必须使用 Route 53 Traffic Flow</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img152310.png"></p><hr><h4 id="Routing-Policy-Traffic-Flow"><a href="#Routing-Policy-Traffic-Flow" class="headerlink" title="Routing Policy (Traffic Flow)"></a>Routing Policy (Traffic Flow)</h4><ul><li><strong>Traffic Flow</strong> - 可视化编辑器管理复杂路由决策树</li><li>图形化界面创建路由策略, 支持多种路由策略组合 (Geoproximity, Latency, Weighted 等)</li><li>配置可保存为 Traffic Flow Policy, 策略可应用到不同的 Hosted Zone (重用), 支持策略版本管理</li><li>使用场景 - 复杂的全球流量路由, 需要组合多种路由策略, 多环境部署 (开发、测试、生产)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img224018.png"></p><hr><h4 id="Routing-Policy-IP-Based"><a href="#Routing-Policy-IP-Based" class="headerlink" title="Routing Policy (IP-Based)"></a>Routing Policy (IP-Based)</h4><ul><li><strong>IP-Based</strong> (IP 路由) - 基于客户端 IP 地址路由流量</li><li>定义 CIDR 块列表和对应的位置&#x2F;端点, 匹配最具体的 CIDR 块</li><li>使用场景 - 根据 ISP 优化性能, 按 IP 范围限制访问, 企业内部流量路由 (特定办公室到特定资源), 成本优化 (不同 IP 段使用不同端点)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img153711.png"></p><hr><h4 id="Routing-Policy-Multi-Value"><a href="#Routing-Policy-Multi-Value" class="headerlink" title="Routing Policy (Multi-Value)"></a>Routing Policy (Multi-Value)</h4><ul><li><strong>Multi-Value</strong> (多值路由) - 返回多个健康资源的 IP 地址 (最多 8 个), 客户端随机选择一个返回的 IP</li><li>支持健康检查 (仅返回健康资源)</li><li>与 Simple 路由的区别 - Multi-Value 支持健康检查</li><li><ul><li>不能替代 ELB (没有负载均衡功能, 没有会话保持)</li></ul></li><li>使用场景 - 客户端侧负载均衡, 提高可用性</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img153842.png"></p><hr><h3 id="8-VPC-Fundamentals"><a href="#8-VPC-Fundamentals" class="headerlink" title="8. VPC Fundamentals"></a>8. VPC Fundamentals</h3><h4 id="AWS-VPC"><a href="#AWS-VPC" class="headerlink" title="AWS VPC"></a>AWS VPC</h4><ul><li>VPC (Virtual Private Cloud) - 虚拟私有云, 每个 AWS 账户都有一个默认 VPC, 逻辑隔离的网络环境</li><li><ul><li>CIDR 配置 - CIDR 块不能重叠, 最大 &#x2F;16 (65,536 个 IP), 最小 &#x2F;28 (16 个 IP)</li></ul></li><li>自定义域名需要启用 <code>enableDnsHostnames</code> 和 <code>enableDnsSupport</code></li><li><ul><li><strong>Shared Service VPC</strong> - 集中式服务 VPC, 其他 VPC 通过 VPC Peering 或 Transit Gateway 访问共享服务, 用于共享 Active Directory、监控服务等</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img201530.png"></p><ul><li><ul><li>EC2 实例租赁属性 (Tenancy) - Default (共享硬件), Dedicated Instance (专用实例独占硬件但不绑定物理服务器), Dedicated Host (专用主机绑定物理服务器), 可以在 Dedicated Instance 和 Dedicated Host 之间切换</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img042420.png"></p><hr><h4 id="VPC-Subnet"><a href="#VPC-Subnet" class="headerlink" title="VPC Subnet"></a>VPC Subnet</h4><ul><li>在 VPC 内划分网络 - Public Subnet (可通过 Internet Gateway 访问互联网), Private Subnet (无法直接访问互联网)</li><li><ul><li>AWS 保留 IP - 每个子网保留 5 个 IP 地址 (前 4 个 + 最后 1 个)</li><li>示例 10.0.0.0&#x2F;24 - 10.0.0.0 (网络地址), 10.0.0.1 (VPC 路由器), 10.0.0.2 (DNS 服务器), 10.0.0.3 (AWS 保留供将来使用), 10.0.0.255 (网络广播地址)</li></ul></li><li><ul><li>路由表关联 - 每个子网必须关联一个路由表, 未显式关联时使用主路由表</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img013421.png"></p><hr><h4 id="Internet-Gateway-IGW-amp-Route-Table"><a href="#Internet-Gateway-IGW-amp-Route-Table" class="headerlink" title="Internet Gateway (IGW) &amp; Route Table"></a>Internet Gateway (IGW) &amp; Route Table</h4><ul><li><strong>Internet Gateway (IGW)</strong> - - 允许 VPC 中的资源连接互联网, 水平扩展、冗余、高可用, 提供 NAT 功能, 每个 VPC 只能关联一个 IGW</li><li><ul><li>使用要求 - 必须配置路由表将 0.0.0.0&#x2F;0 指向 IGW, 资源必须有公网 IP 或 Elastic IP, 安全组必须允许互联网流量</li></ul></li><li><ul><li>不能直接用于 Private Subnet, Private Subnet 需要通过 NAT Gateway&#x2F;Instance</li></ul></li><li><ul><li>IGW vs NAT - IGW (VPC 级别, 用于 Public Subnet), NAT (Subnet 级别, 用于 Private Subnet 访问互联网)</li></ul></li><li>故障排查 - 首先检查路由表配置, 检查安全组和 NACL 规则, 确认实例有公网 IP</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img202043.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img193121.png"></p><hr><h4 id="NAT-Gateway-NATGW"><a href="#NAT-Gateway-NATGW" class="headerlink" title="NAT Gateway (NATGW)"></a>NAT Gateway (NATGW)</h4><ul><li>NAT Gateway - AWS 托管的 NAT 服务, 允许 Private Subnet 中的实例访问互联网, 协议 IPv4 (IPv6 使用 Egress-only Internet Gateway), 使用 Elastic IP</li><li><ul><li>部署要求 - 必须部署在 Public Subnet 中, 需要 Internet Gateway (IGW), Private Subnet 路由表指向 NATGW</li></ul></li><li>单 AZ 内高可用 (自动冗余), - 跨 AZ 需要在每个 AZ 部署独立的 NATGW, 每个 AZ 一个 NATGW 提供容错能力</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img233648.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img203654.png"></p><ul><li><ul><li>NAT Gateway vs Internet Gateway - NATGW (Subnet 级别, Private Subnet 访问互联网), IGW (VPC 级别, Public Subnet 双向互联网访问)</li></ul></li></ul><hr><h4 id="NACL-amp-Security-Groups"><a href="#NACL-amp-Security-Groups" class="headerlink" title="NACL &amp; Security Groups"></a>NACL &amp; Security Groups</h4><ul><li>流量控制层级 - NACL (Subnet 级别无状态 Stateless, 入站和出站流量分别检查), Security Group (实例级别有状态 Stateful, 入站允许则出站自动允许)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img204310.png"></p><ul><li><strong>Network Access Control List (NACL)</strong> - 控制进出子网的流量 (如阻止特定 IP), 一个子网关联一个 NACL</li><li><ul><li>默认 NACL 允许所有入站和出站流量</li></ul></li><li><ul><li>自定义 NACL 默认拒绝所有入站和出站流量</li></ul></li><li>规则优先级 - 规则编号越小优先级越高, 按顺序匹配匹配后停止, 建议编号间隔 (如 100, 200, 300) 便于插入新规则</li><li>使用场景 - 封禁特定 IP, 子网级别的访问控制</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img204553.png"></p><hr><h4 id="VPC-Flow-Logs"><a href="#VPC-Flow-Logs" class="headerlink" title="VPC Flow Logs"></a>VPC Flow Logs</h4><ul><li>捕获网络接口的 IP 流量信息, 监控和排查网络连接问题, 分析网络流量模式, 检测异常流量和安全威胁</li><li>日志级别 - VPC (捕获整个 VPC 的流量), Subnet (捕获子网内所有接口的流量), ENI (捕获特定网络接口的流量)</li><li>目标 - CloudWatch Logs, S3 (成本更低), Kinesis Data Firehose</li><li>使用场景 - 排查安全组或 NACL 规则问题, 识别被拒绝的连接, 分析流量趋势, 合规性审计</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img231819.png"></p><hr><h4 id="VPC-Peering"><a href="#VPC-Peering" class="headerlink" title="VPC Peering"></a>VPC Peering</h4><ul><li>VPC Peering - 通过 AWS 网络私密连接两个 VPC, - 适用于少量 VPC 互连, 不支持传递性 (A-B, B-C 不代表 A-C 连通), 每对 VPC 需要单独的 Peering 连接</li><li>限制 - CIDR 块不能重叠, 不支持边缘到边缘路由</li><li>跨账户&#x2F;跨区域 - 支持不同 AWS 账户之间的 VPC Peering, 支持不同 Region 之间的 VPC Peering</li><li><ul><li>配置要求 - 两侧 VPC 都需要更新路由表, 安全组可引用对端 VPC 的安全组</li></ul></li><li>故障排查 - 首先检查双方路由表配置, 检查安全组和 NACL 规则</li><li>使用场景 - 2-3 个 VPC 互连, 跨账户资源共享</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img205313.png"></p><hr><h4 id="VPC-Sharing"><a href="#VPC-Sharing" class="headerlink" title="VPC Sharing"></a>VPC Sharing</h4><ul><li>VPC Sharing - 允许多个 AWS 账户在共享的集中管理 VPC 中创建资源, - 关键词 Centrally Managed</li><li>工作方式 - VPC 所有者 (Owner) 共享一个或多个子网给参与者, 参与者 (Participant) 可在共享子网中创建资源 (EC2, RDS 等)</li><li>所有者保留 VPC 和子网的所有权和控制权, 参与者只能在共享子网中创建、管理、删除自己的资源, 共享子网中的资源可以互相通信</li><li>优势 - 减少 VPC 数量简化网络架构, 集中管理网络配置 (路由表、NACL 等), 降低成本 (共享 NAT Gateway 等)</li><li>使用场景 - 大型组织内多账户资源共享, 集中式网络管理</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img824817.png"></p><hr><h4 id="VPC-Endpoints-AWS-PrivateLink"><a href="#VPC-Endpoints-AWS-PrivateLink" class="headerlink" title="VPC Endpoints (AWS PrivateLink)"></a>VPC Endpoints (AWS PrivateLink)</h4><ul><li><ul><li>VPC Endpoints - 通过私有网络访问 AWS 服务, 流量不经过公网保持在 AWS 网络内, 提高安全性降低延迟, 无需 Internet Gateway、NAT Gateway 或 VPN</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img205719.png"></p><ul><li>两种类型<ul><li><strong>Interface Endpoint</strong> (接口端点) - 使用 AWS PrivateLink 技术, 在子网中创建 ENI (弹性网络接口), 支持大部分 AWS 服务 (EC2, SNS, SQS, CloudWatch 等), 收费按小时和数据传输量计费, 需要配置安全组</li><li><ul><li><strong>Gateway Endpoint</strong> (网关端点) - 仅支持 S3 和 DynamoDB (考试重点), 作为路由表中的目标, 免费, 不使用 ENI, 不需要配置安全组</li></ul></li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img205939.png"></p><ul><li>使用场景 - Private Subnet 访问 S3&#x2F;DynamoDB 使用 Gateway Endpoint, Private Subnet 访问其他 AWS 服务使用 Interface Endpoint, 满足合规要求避免流量经过公网</li></ul><hr><h4 id="Site-to-Site-VPN-VPN-Connection"><a href="#Site-to-Site-VPN-VPN-Connection" class="headerlink" title="Site-to-Site VPN (VPN Connection)"></a>Site-to-Site VPN (VPN Connection)</h4><ul><li><ul><li>Site-to-Site VPN - 通过公网连接 AWS 和企业数据中心, 连接方向 On-Premise ↔ AWS VPC, 传输方式通过公共互联网, 提供加密的网络连接</li></ul></li><li>组件 - Virtual Private Gateway (VGW) AWS 侧的 VPN 集中器附加到 VPC, Customer Gateway (CGW) 企业数据中心侧的设备或软件</li><li>特性 - 快速部署 (几分钟内完成), 成本低, 加密传输</li><li>限制 - 依赖公网带宽和延迟不稳定, 不提供低延迟和高吞吐量 (对比 Direct Connect)</li><li>使用场景 - 临时连接需求, 低流量应用, 成本敏感的场景, Direct Connect 的备份连接</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img232320.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img232649.png"></p><hr><h4 id="Direct-Connect-DX"><a href="#Direct-Connect-DX" class="headerlink" title="Direct Connect (DX)"></a>Direct Connect (DX)</h4><ul><li><ul><li>Direct Connect - 从本地网络到 AWS 的专用私有连接, 连接方式通过专线不经过公网, 关键词 Private, Dedicated, Low Latency, High Throughput</li></ul></li><li>组件 - 需要 Virtual Private Gateway (VGW), 在 AWS Direct Connect Location 建立物理连接</li><li>特性 - 低延迟高吞吐量 (对比 Site-to-Site VPN), 带宽稳定网络性能一致, 可访问公共资源 (S3) 和私有资源 (EC2), - 流量完全私有不涉及公网</li><li><ul><li>限制 - 不提供加密 (需要加密可结合 AWS VPN 使用), 设置时间长 (不是快速解决方案), 成本较高</li></ul></li><li>备份方案 - Site-to-Site VPN (这两个服务类似)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img233024.png"></p><ul><li>连接类型 - Dedicated Connections (专用连接 1 Gbps, 10 Gbps, 100 Gbps), Hosted Connections (托管连接 50 Mbps 到 10 Gbps)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img004140.png"></p><ul><li><strong>Direct Connect Gateway</strong> - 连接多个不同 Region 的 VPC, 单一 DX 连接访问多个 VPC</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img233531.png"></p><ul><li><strong>PrivateLink vs Direct Connect</strong><ul><li>PrivateLink - VPC 与 AWS 服务之间的私有连接, 范围 AWS 内部 (VPC ↔ AWS 服务), 不经过公网</li><li>Direct Connect - 本地数据中心与 AWS 的专用连接, 范围 On-Premise ↔ AWS, 超高速数据传输低延迟, 不经过公网提高安全性</li></ul></li></ul><hr><h3 id="9-S3"><a href="#9-S3" class="headerlink" title="9. S3"></a>9. S3</h3><h4 id="AWS-S3"><a href="#AWS-S3" class="headerlink" title="AWS S3"></a>AWS S3</h4><ul><li><strong>S3 Buckets</strong> - 存储对象 (文件) 的容器, Bucket 名称必须全球唯一, 在 Region 级别定义 (S3 是全球服务但 Bucket 是区域性的)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img171839.png"></p><ul><li><strong>Objects</strong> (对象) - 由 Key (完整路径) 标识, 最大对象大小 5 TB, 单次上传最大 5 GB</li><li><ul><li>超过 5 GB 必须使用 Multi-Part Upload</li></ul></li><li>加速上传使用 S3 Transfer Acceleration</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img172025.png"></p><ul><li>Serverless 自动扩展, - 始终返回对象的最新版本</li><li>无法加密 Metadata</li><li>S3 Sync 使用 CopyObject API 在 S3 Bucket 间复制对象</li><li><ul><li><strong>对象所有权</strong> (S3 Object Ownership)</li><li>默认上传对象的 AWS 账户拥有对象 (即使 Bucket 属于其他账户)</li><li>可通过 Bucket 设置控制新上传对象的所有权</li><li>要获取对象访问日志, 对象所有者必须是 Bucket 所有者</li></ul></li><li>数据一致性模型 - 删除对象后立即读取不返回数据 (已删除), 删除 Bucket 后立即列出所有 Bucket 时已删除的 Bucket 可能仍显示</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/imglifecycle-transitions-v2.png"></p><ul><li>访问控制 - Bucket Policies, IAM Policies, Access Control Lists (ACLs), Query String Authentication (预签名 URL)</li><li>常见场景<ul><li><ul><li>静态内容托管使用 S3 + CloudFront</li></ul></li><li><ul><li>图片上传处理使用 S3 Event Notification (不是 EventBridge)</li></ul></li><li>传输性能优化使用 Bucket Prefix 分区</li></ul></li><li>S3 不是数据库, 不提供数据库功能</li></ul><hr><h4 id="S3-Bucket-Policy"><a href="#S3-Bucket-Policy" class="headerlink" title="S3 Bucket Policy"></a>S3 Bucket Policy</h4><ul><li><strong>User-Based</strong> (基于用户) - - IAM Policies 控制特定 IAM 用户&#x2F;角色可以调用哪些 S3 API</li><li><strong>Resource-Based</strong> (基于资源) - Bucket Policies (Bucket 级别访问规则), Object ACLs (对象级别), Bucket ACLs (Bucket 级别, 不常用)</li><li>IAM 权限与 Bucket Policy 的并集决定最终访问权限, 显式 DENY 优先于所有 ALLOW</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img173050.png"></p><ul><li><strong>S3 Bucket Policy</strong> (JSON 格式) - Resources (指定 Bucket 和 Object ARN), Effect (Allow 或 Deny), Actions (允许或拒绝的 S3 API 操作), Principal (应用策略的账户或用户), Condition (可选条件限制)</li><li>常见使用场景 - 授予公共访问权限, 跨账户访问, 强制加密上传, 限制 IP 地址访问</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img173325.png"></p><hr><h4 id="S3-Website"><a href="#S3-Website" class="headerlink" title="S3 Website"></a>S3 Website</h4><ul><li>S3 静态网站托管 - 托管静态网站 (HTML, CSS, JavaScript), 必须启用公共读取访问权限</li><li>网站 URL 格式 - <code>http://bucket-name.s3-website-Region.amazonaws.com</code> (dash) 或 <code>http://bucket-name.s3-website.Region.amazonaws.com</code> (dot)</li><li>配置 - 索引文档 index.html, 错误文档 error.html (可选)</li><li>使用场景 - 静态网站托管, 配合 CloudFront 提供 HTTPS 和全球加速, 单页应用 (SPA) 托管</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img043622.png"></p><hr><h4 id="S3-Versioning"><a href="#S3-Versioning" class="headerlink" title="S3 Versioning"></a>S3 Versioning</h4><ul><li>版本控制 Bucket 级别设置 (默认状态未启用)</li><li>版本状态 - Unversioned (未版本化默认), Enabled (已启用), Suspended (已暂停)</li><li><ul><li>启用后无法返回未版本化状态只能暂停, 应用于 Bucket 中的所有对象无法指定文件夹, 每次修改生成新版本 ID</li></ul></li><li>优势 - 防止意外删除 (删除添加删除标记可恢复), 支持回滚到之前版本, 建议启用版本控制</li><li>删除行为 - 删除对象添加删除标记不真正删除, 删除删除标记恢复对象, 永久删除需删除特定版本 ID</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img174246.png"></p><hr><h4 id="S3-Replication-CRR-amp-SRR"><a href="#S3-Replication-CRR-amp-SRR" class="headerlink" title="S3 Replication (CRR &amp; SRR)"></a>S3 Replication (CRR &amp; SRR)</h4><ul><li><strong>CRR</strong> (Cross-Region Replication) - 跨区域复制, 用于合规要求、降低延迟、跨区域备份</li><li><strong>SRR</strong> (Same-Region Replication) - 同区域复制, 用于日志聚合、测试&#x2F;开发环境、数据副本</li><li><ul><li>前提条件 - 源和目标 Bucket 必须启用版本控制, 必须授予 S3 IAM 权限, Bucket 可以在不同 AWS 账户</li></ul></li><li>异步复制, 仅复制新对象 (启用复制后上传的对象), 现有对象需要使用 S3 Batch Replication</li><li><ul><li>不支持链式复制 (无传递性)</li><li>示例 - A→B, B→C, A 的对象不会复制到 C</li><li>需要 A→B 和 A→C 两个独立复制配置</li><li>不复制删除标记 (可配置), 不复制生命周期操作</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img174840.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img175004.png"></p><hr><h4 id="S3-Storage-Classes"><a href="#S3-Storage-Classes" class="headerlink" title="S3 Storage Classes"></a>S3 Storage Classes</h4><ul><li>7 种存储类别 - Standard + 2 个 IA + 3 个 Glacier + Intelligent-Tiering</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img175742.png"></p><ul><li><strong>S3 Standard - General Purpose</strong> - 频繁访问的数据, 低延迟高吞吐量, 可用性 99.99%, 用于大数据分析、移动应用、内容分发</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img175932.png"></p><ul><li><strong>S3 Infrequent Access (IA)</strong> - - 不频繁访问但需要快速检索的数据, 比 Standard 低但有检索费用<ul><li><strong>Standard-IA</strong> - 多 AZ 高可用, 可用性 99.9%, 最小存储期限 30 天, 用于灾难恢复、备份</li><li><strong>One Zone-IA</strong> - 单 AZ 比 Standard-IA 低 20%, 可用性 99.5%, - 不适合高可用场景 (AZ 故障会导致数据不可用), 最小存储期限 30 天, 用于次要备份、可重新创建的数据</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img180147.png"></p><ul><li><strong>S3 Glacier</strong> (归档存储) - 长期归档和备份, 定价 &#x3D; 存储费用 + 检索费用<ul><li><strong>Glacier Instant Retrieval</strong> - 毫秒级检索, Glacier 中成本最高, 最小存储期限 90 天, 用于季度访问的归档数据</li><li><strong>Glacier Flexible Retrieval</strong> - 检索模式 Expedited (1-5 分钟), Standard (3-5 小时), Bulk (5-12 小时最便宜), 最小存储期限 90 天, 用于备份、不需要即时访问的数据</li><li><strong>Glacier Deep Archive</strong> - 最低成本存储类别, 检索 Standard (12 小时), Bulk (48 小时), 最小存储期限 180 天, 用于长期保留 (7-10 年)、合规归档</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img180642.png"></p><ul><li><strong>S3 Intelligent-Tiering</strong> - 根据访问模式自动在访问层之间移动对象, 无检索费用但有小额监控费用</li><li>访问层 - Frequent Access (默认), Infrequent Access (30 天未访问), Archive Instant Access (90 天未访问), Archive Access (可选 90-730 天未访问), Deep Archive Access (可选 180-730 天未访问)</li><li>适用于访问模式不可预测或变化的数据</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img180806.png"></p><hr><h3 id="10-AWS-CLI-SDK-IAM-Roles-amp-Policies"><a href="#10-AWS-CLI-SDK-IAM-Roles-amp-Policies" class="headerlink" title="10. AWS CLI, SDK, IAM Roles &amp; Policies"></a>10. AWS CLI, SDK, IAM Roles &amp; Policies</h3><h4 id="EC2-Instance-Metadata-IMDS"><a href="#EC2-Instance-Metadata-IMDS" class="headerlink" title="EC2 Instance Metadata (IMDS)"></a>EC2 Instance Metadata (IMDS)</h4><ul><li>Instance Metadata 允许 EC2 实例获取自身信息, 无需 IAM 角色</li><li>AWS CLI 使用 Instance Metadata 获取临时凭证, 获取实例信息 (主机名, 公网 IP, 安全组等)</li><li>Metadata 是 EC2 实例的信息 (无法获取 IAM Policy), Userdata 是 EC2 实例的启动脚本</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img150522.png"></p><ul><li><strong>IMDSv1</strong> (不推荐) - 直接 HTTP GET 请求 <code>http://169.254.169.254/latest/meta-data</code>, 安全性较低</li><li><strong>IMDSv2</strong> (推荐, 更安全) - 两步流程: 先获取会话令牌 (PUT 请求), 再使用令牌访问元数据 (GET 请求), 防止 SSRF 攻击, 可强制仅使用 IMDSv2</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img150716.png"></p><hr><h4 id="MFA-with-CLI"><a href="#MFA-with-CLI" class="headerlink" title="MFA with CLI"></a>MFA with CLI</h4><ul><li>CLI 使用 MFA 必须创建临时会话</li><li>调用 STS GetSessionToken API, 提供 MFA 设备的序列号和令牌代码</li><li>返回临时凭证 (Access Key, Secret Key, Session Token), 有效期默认 12 小时 (可配置 15 分钟到 36 小时)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img151057.png"></p><ul><li>使用 <code>aws --dry-run</code> 测试 IAM 权限, 不实际执行操作仅验证权限</li></ul><hr><h4 id="AWS-SDK"><a href="#AWS-SDK" class="headerlink" title="AWS SDK"></a>AWS SDK</h4><ul><li>AWS SDK (Software Development Kit) 在应用代码中直接调用 AWS 服务</li><li>支持语言 - Python (Boto3), Java, JavaScript (Node.js), .NET, PHP, Ruby, Go, C++ 等</li><li>凭证配置优先级<ol><li>代码中的凭证 (不推荐, 安全风险)</li><li>环境变量 (<code>AWS_ACCESS_KEY_ID</code>, <code>AWS_SECRET_ACCESS_KEY</code>)</li><li>CLI 凭证文件 (<code>~/.aws/credentials</code>)</li><li>EC2 实例配置文件 (IAM Role, 推荐)</li></ol></li><li><ul><li>未配置时默认使用 <code>us-east-1</code>, 建议显式配置 Region</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img151356.png"></p><hr><h4 id="AWS-Limits-Quotas"><a href="#AWS-Limits-Quotas" class="headerlink" title="AWS Limits (Quotas)"></a>AWS Limits (Quotas)</h4><ul><li><strong>API Rate Limits</strong> (API 速率限制)<ul><li>间歇性错误 - 使用指数退避 (Exponential Backoff) 重试, AWS SDK 内置此机制</li><li>持续性错误 - 请求提高 API 限流阈值, 通过 AWS Support 提交申请</li></ul></li><li><strong>Service Quotas</strong> (服务配额) - 提交工单申请提高服务限制, 使用 Service Quotas API 编程方式请求增加配额</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img151813.png"></p><ul><li><ul><li><strong>Exponential Backoff</strong> (指数退避)</li><li>收到 <code>ThrottlingException</code> 间歇性错误时触发</li><li>工作原理 - 第一次重试等待 1 秒, 第二次 2 秒, 第三次 4 秒, 依此类推指数增长</li><li>AWS SDK 自动实现</li><li>仅对 5xx 错误重试 (服务器错误), 不对 4xx 错误重试 (客户端错误如权限问题)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img152100.png"></p><hr><h4 id="AWS-CLI-Credentials-Provider-Chain"><a href="#AWS-CLI-Credentials-Provider-Chain" class="headerlink" title="AWS CLI Credentials Provider Chain"></a>AWS CLI Credentials Provider Chain</h4><ul><li><ul><li>CLI 凭证查找顺序</li></ul><ol><li>命令行选项 (<code>--region</code>, <code>--output</code>, <code>--profile</code>)</li><li>环境变量 (<code>AWS_ACCESS_KEY_ID</code>, <code>AWS_SECRET_ACCESS_KEY</code>, <code>AWS_SESSION_TOKEN</code>)</li><li>CLI 凭证文件 (<code>~/.aws/credentials</code> Linux&#x2F;Mac, <code>%UserProfile%\.aws\credentials</code> Windows)</li><li>CLI 配置文件 (<code>~/.aws/config</code>)</li><li>容器凭证 (ECS 任务的 IAM 角色)</li><li>EC2 实例配置文件凭证 (EC2 实例的 IAM 角色)</li></ol></li><li>最佳实践 - 生产环境使用 IAM 角色 (EC2 或 ECS), 开发环境使用命名配置文件, 避免硬编码凭证</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img152316.png"></p><hr><h4 id="AWS-Sigv4"><a href="#AWS-Sigv4" class="headerlink" title="AWS Sigv4"></a>AWS Sigv4</h4><ul><li>AWS Signature Version 4 - AWS 请求签名身份验证方法, 确保请求的安全性和完整性, 防止请求被篡改或重放</li><li>两种签名方式<ul><li><strong>HTTP Header</strong> (推荐) - 签名放在 <code>Authorization</code> 头部, 用于大多数 AWS API 调用</li><li><strong>Query String</strong> (预签名 URL) - 签名放在 <code>X-Amz-Signature</code> 查询参数, 用于临时授权访问 (如 S3 预签名 URL), 可设置过期时间</li></ul></li><li>签名过程 - 创建规范请求 (Canonical Request) → 创建待签名字符串 (String to Sign) → 计算签名 (Calculate Signature) → 将签名添加到请求</li><li>使用场景 - 所有 AWS API 调用, S3 预签名 URL (临时共享文件), CloudFront 签名 URL&#x2F;Cookie</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img153415.png"></p><hr><h3 id="11-Advanced-S3"><a href="#11-Advanced-S3" class="headerlink" title="11. Advanced S3"></a>11. Advanced S3</h3><h4 id="S3-Lifecycle-Rules"><a href="#S3-Lifecycle-Rules" class="headerlink" title="S3 Lifecycle Rules"></a>S3 Lifecycle Rules</h4><ul><li>在存储类别之间自动转移对象或删除对象, 基于对象年龄或前缀自动执行, 降低存储成本</li><li><ul><li>规则类型</li><li><strong>Transition Actions</strong> (转移操作) - 将对象转移到另一个存储类别 (如 30 天后转到 Standard-IA, 90 天后转到 Glacier)</li><li><strong>Expiration Actions</strong> (过期操作) - 在指定时间后删除对象, 删除旧版本对象, 删除不完整的分段上传</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img235516.png"></p><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img235639.png"></p><ul><li>转移限制 - 从 Standard 到 Standard-IA 最少 30 天, 从 Standard-IA 到 Glacier 最少 30 天, 对象最小大小 128 KB</li><li>常见场景<ul><li>日志文件 - 30 天后转到 IA, 1 年后转到 Glacier</li><li>临时文件 - 7 天后自动删除</li><li>合规归档 - 保留 7 年后删除</li><li><ul><li>Snowball 导入数据后自动转到 Glacier</li></ul></li></ul></li><li><strong>S3 Analytics</strong> (存储类别分析) - 分析访问模式建议最佳转移时间, 仅支持 Standard 和 Standard-IA, 生成报告需要 24-48 小时</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img000151.png"></p><hr><h4 id="S3-Event-Notifications"><a href="#S3-Event-Notifications" class="headerlink" title="S3 Event Notifications"></a>S3 Event Notifications</h4><ul><li>自动响应 S3 中的特定事件 (对象创建、删除、恢复、复制等), 近实时通知 (通常几秒内)</li><li><ul><li>支持的目标服务 - SNS, SQS, Lambda Functions, EventBridge (高级事件路由)</li></ul></li><li>必须配置 IAM 权限, 目标服务的资源策略必须允许 S3 访问</li><li>事件类型 - <code>s3:ObjectCreated:*</code>, <code>s3:ObjectRemoved:*</code>, <code>s3:ObjectRestore:*</code>, <code>s3:Replication:*</code></li><li>常见场景<ul><li>图片上传后生成缩略图 (Lambda)</li><li>日志文件上传后分析处理 (SQS + 处理程序)</li><li>重要文件变更通知 (SNS + Email)</li></ul></li><li><ul><li>S3 Event Notifications vs EventBridge</li><li>S3 Event Notifications - 简单 S3 事件处理, 直接集成 (推荐)</li><li>EventBridge - 高级事件路由, 多目标, 事件筛选, 归档</li></ul></li><li>同时写入同一未版本化对象可能只发送一个事件通知, 启用版本控制可确保每次写入都有事件</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img000725.png"></p><hr><h4 id="S3-Performance"><a href="#S3-Performance" class="headerlink" title="S3 Performance"></a>S3 Performance</h4><ul><li><p><strong>Multi-Part Upload</strong> (分段上传)</p><ul><li>推荐 &gt; 100 MB, 必须 &gt; 5 GB</li><li>并行上传分段提高速度, 失败后可重试单个分段</li><li>最多 10,000 个分段, 每个 5 MB - 5 GB</li></ul></li><li><p><strong>S3 Transfer Acceleration</strong> (传输加速)</p><ul><li>通过 AWS Edge Location 加速上传, 适用于远距离传输 (跨大洲)</li><li>可与 Multi-Part Upload 结合使用</li><li>使用专用端点 <code>bucket-name.s3-accelerate.amazonaws.com</code></li><li><ul><li>无法用于 Bucket 间复制对象</li></ul></li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img001645.png"></p><ul><li><ul><li><strong>S3 Byte-Range Fetches</strong> (字节范围获取)</li><li>并行化 GET 请求提高下载速度</li><li>仅检索部分数据 (如文件头部), 故障时可重试特定字节范围</li><li>使用场景 - 加速大文件下载 (并行), 部分文件检索 (如前 50 字节获取元数据), 提高容错能力</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img001828.png"></p><ul><li>请求速率优化 - 3,500 PUT&#x2F;COPY&#x2F;POST&#x2F;DELETE 请求&#x2F;秒&#x2F;前缀, 5,500 GET&#x2F;HEAD 请求&#x2F;秒&#x2F;前缀, 使用多个前缀分散负载</li></ul><hr><h4 id="S3-Select-amp-Glacier-Select"><a href="#S3-Select-amp-Glacier-Select" class="headerlink" title="S3 Select &amp; Glacier Select"></a>S3 Select &amp; Glacier Select</h4><ul><li>使用 SQL 表达式进行服务器端过滤, 仅检索所需数据子集, 在 S3 端完成过滤减少网络传输</li><li>优势 - 减少网络传输量 (最多 80%), 降低客户端 CPU 成本, 提高查询性能 (最多 400%)</li><li>支持格式 - CSV, JSON, Parquet, 压缩文件 (GZIP, BZIP2)</li><li>SQL 功能 - SELECT, WHERE 子句, 简单聚合 (COUNT, SUM, AVG), LIMIT 限制返回行数</li><li>常见场景 - 日志文件分析 (仅提取错误日志), 大型 CSV 文件查询 (仅提取特定列), JSON 数据筛选</li><li><strong>Glacier Select</strong> - 与 S3 Select 功能相同, 用于 Glacier 归档数据查询, 先恢复再查询</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img002050.png"></p><hr><h4 id="S3-Object-Tags-amp-Metadata"><a href="#S3-Object-Tags-amp-Metadata" class="headerlink" title="S3 Object Tags &amp; Metadata"></a>S3 Object Tags &amp; Metadata</h4><ul><li><strong>S3 Object Metadata</strong> (对象元数据)<ul><li>系统元数据 - S3 自动生成 (Content-Type, Last-Modified 等)</li><li>用户定义元数据 - 必须以 <code>x-amz-meta-</code> 开头, 键值对形式, 上传时设置之后不可修改, 用于存储应用相关信息</li></ul></li><li><strong>S3 Object Tags</strong> (对象标签)<ul><li>键值对形式 (最多 10 个标签&#x2F;对象), 可在对象创建后添加或修改</li><li>用途 - 细粒度权限控制 (IAM 策略), 生命周期规则筛选, 成本分配和分析, 对象分类管理</li></ul></li><li><ul><li>无法通过元数据或标签搜索对象, 需要搜索功能使用 S3 Inventory 或 Athena</li></ul></li><li>Metadata 用于描述性信息且上传时固定, Tags 用于分类和管理且可动态修改</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img194215.png"></p><hr><h3 id="12-S3-Security"><a href="#12-S3-Security" class="headerlink" title="12. S3 Security"></a>12. S3 Security</h3><h4 id="S3-Encryption"><a href="#S3-Encryption" class="headerlink" title="S3 Encryption"></a>S3 Encryption</h4><ul><li>Server-Side Encryption (SSE) - S3 端加密</li><li>Client-Side Encryption (CSE) - 客户端加密</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img223133.png"></p><ul><li><strong>SSE-S3</strong> (S3 托管密钥, 默认)<ul><li>新 Bucket 和对象默认启用</li><li>AES-256 加密算法, 每个对象使用唯一密钥</li><li>AWS 管理密钥, 免费</li><li>请求头 <code>x-amz-server-side-encryption: AES256</code></li><li><ul><li>不支持自动密钥轮换 (需要 SSE-KMS)</li></ul></li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img223242.png"></p><ul><li><strong>SSE-KMS</strong> (KMS 托管密钥)<ul><li>用户控制密钥 (AWS KMS), 可审计密钥使用 (CloudTrail)</li><li>支持自动密钥轮换</li><li>请求头 <code>x-amz-server-side-encryption: aws:kms</code></li><li>收费 (KMS API 调用), 受 KMS 配额限制 (上传&#x2F;下载计入配额)</li><li>适合需要密钥审计、轮换、细粒度控制的场景</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img223417.png"></p><ul><li><strong>SSE-C</strong> (客户提供密钥)<ul><li>用户自己管理密钥</li><li><ul><li>AWS 不存储密钥, 必须使用 HTTPS</li></ul></li><li>每次请求必须提供密钥, S3 拒绝所有 HTTP 请求</li><li>适合有自己的密钥但希望在 AWS 端加密的场景</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img223602.png"></p><ul><li><strong>Client-Side Encryption</strong> (客户端加密)<ul><li>用户完全管理密钥和加密周期</li><li>数据在发送到 AWS 前已加密, AWS 接收和存储加密数据</li><li>适合最高安全要求, 完全控制加密过程</li><li>工具 - AWS Encryption SDK, S3 Encryption Client</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img223715.png"></p><ul><li><strong>Encryption in Transit</strong> (传输加密, SSL&#x2F;TLS)<ul><li>HTTPS (推荐), HTTP (可用但不推荐)</li><li>强制 HTTPS - Bucket Policy 使用 <code>aws:SecureTransport</code> 条件</li><li>SSE-C 必须使用 HTTPS</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img223811.png"></p><hr><h4 id="S3-CORS"><a href="#S3-CORS" class="headerlink" title="S3 CORS"></a>S3 CORS</h4><ul><li>CORS (Cross-Origin Resource Sharing) - 跨域资源共享, 浏览器安全机制</li><li>允许一个域的 Web 应用访问另一个域的资源</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img224630.png"></p><ul><li><ul><li>客户端向 S3 Bucket 发起跨域请求时, 必须在 S3 Bucket 配置正确的 CORS 头部</li></ul></li><li>配置元素<ul><li><code>AllowedOrigins</code> - 允许的源域 (<code>https://example.com</code> 或 <code>*</code>)</li><li><code>AllowedMethods</code> - 允许的 HTTP 方法 (GET, PUT, POST, DELETE, HEAD)</li><li><code>AllowedHeaders</code> - 允许的请求头</li><li><code>ExposeHeaders</code> - 暴露给客户端的响应头</li><li><code>MaxAgeSeconds</code> - 预检请求的缓存时间</li></ul></li><li>工作流程 - 浏览器发送 OPTIONS 预检请求 → S3 返回 CORS 头部 → 浏览器允许实际请求 → S3 返回资源</li><li>常见场景 - 静态网站从不同域的 S3 Bucket 加载资源, 跨域 AJAX 请求, SPA 访问 API</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img224951.png"></p><hr><h4 id="S3-MFA-Delete"><a href="#S3-MFA-Delete" class="headerlink" title="S3 MFA Delete"></a>S3 MFA Delete</h4><ul><li>删除对象或版本前需要 MFA 身份验证, 防止意外删除重要数据</li><li><ul><li>必须先启用版本控制 (Versioning)</li></ul></li><li>需要 MFA 的操作 - 永久删除对象版本, 暂停 Bucket 版本控制</li><li>不需要 MFA 的操作 - 启用版本控制, 列出已删除版本</li><li><ul><li>只有 Bucket 所有者 (根账户) 可以启用&#x2F;禁用, 必须使用 CLI (无法通过控制台配置)</li></ul></li><li>适合合规要求、关键数据保护、防止误操作</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img225415.png"></p><hr><h4 id="S3-Access-Logs"><a href="#S3-Access-Logs" class="headerlink" title="S3 Access Logs"></a>S3 Access Logs</h4><ul><li>所有对 S3 的请求都会被记录到另一个 S3 存储桶中</li><li>日志包含详细信息: 访问者、时间、操作、状态码等</li><li>日志可能需要几小时才能送达目标存储桶</li><li>目标存储桶必须在同一区域</li><li>不要将日志存储到被监控的同一存储桶（会导致无限日志循环）</li><li>可用于审计、安全分析、故障排查</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img230251.png"></p><hr><h4 id="S3-Pre-signed-URL"><a href="#S3-Pre-signed-URL" class="headerlink" title="S3 Pre-signed URL"></a>S3 Pre-signed URL</h4><ul><li>临时授权 URL，允许用户在有限时间内访问私有 S3 对象</li><li>使用生成者的权限进行访问（继承 IAM 用户或角色的权限）</li><li>有效期: S3 Console 生成最多 12 小时，AWS CLI 最多 168 小时（7 天）</li><li>常见用途<ul><li>允许用户下载高级内容（付费用户临时访问）</li><li>允许用户临时上传文件到指定位置</li><li>动态生成下载链接给不断变化的用户列表</li></ul></li><li>生成方式: AWS Console、AWS CLI、SDK</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img230702.png"></p><hr><h4 id="S3-Access-Points"><a href="#S3-Access-Points" class="headerlink" title="S3 Access Points"></a>S3 Access Points</h4><ul><li>简化 S3 存储桶的安全管理，为不同用户&#x2F;应用提供独立访问入口</li><li>每个 Access Point 有自己的<ul><li>DNS 名称（唯一访问端点）</li><li>Access Point Policy（独立的访问策略）</li></ul></li><li>可以针对特定前缀或用户组创建专用 Access Point</li><li>支持 VPC Origin: 限制只能从指定 VPC 访问</li><li>优势: 避免复杂的存储桶策略，每个访问点独立管理权限</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img231500.png"></p><hr><h4 id="S3-Object-Lambda"><a href="#S3-Object-Lambda" class="headerlink" title="S3 Object Lambda"></a>S3 Object Lambda</h4><ul><li>使用 Lambda 函数在对象返回给调用者之前动态转换数据</li><li>需要配置: S3 Access Point + S3 Object Lambda Access Point</li><li>常见用途</li><li>移除敏感信息 (PII - Personally Identifiable Information)</li><li>图片处理: 添加水印、调整大小、格式转换</li><li>数据格式转换: XML 转 JSON、数据增强</li><li>根据调用者权限返回不同内容（数据过滤、编辑）</li><li>优势: 无需创建多个数据副本，实时动态处理</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img231810.png"></p><hr><h3 id="13-CloudFront"><a href="#13-CloudFront" class="headerlink" title="13. CloudFront"></a>13. CloudFront</h3><h4 id="AWS-CloudFront"><a href="#AWS-CloudFront" class="headerlink" title="AWS CloudFront"></a>AWS CloudFront</h4><ul><li>全球内容分发网络 (CDN)，支持静态和动态内容分发</li><li>内容缓存在边缘节点，提升读取性能和用户体验</li><li>集成 AWS Shield 提供 DDoS 防护</li><li>支持基于内容类型的路由，支持主备源站实现高可用和故障转移</li><li><strong>源站类型 (Origins)</strong><ul><li>S3 存储桶: 需配置 OAC (Origin Access Control)<ul><li>S3 + CloudFront 题目必考 OAC</li></ul></li><li>自定义源站 (Custom Origin): 任何 HTTP 端点（ALB、EC2、外部网站等）</li></ul></li><li><strong>加密</strong><ul><li>CloudFront 加密需求选择 Field-Level Encryption（不是 KMS）</li><li>Field-Level Encryption: 允许用户安全上传敏感信息到 Web 服务器</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img232701.png"></p><ul><li><strong>CloudFront vs S3 Cross Region Replication</strong><ul><li>CloudFront<ul><li>全球边缘网络（216+ 个边缘节点）</li><li>内容有 TTL（通常 1 天）</li><li>适用于必须全球可用的静态内容</li></ul></li><li>S3 Cross Region Replication (CRR)<ul><li>必须为每个目标区域单独设置</li><li>近实时更新，无缓存</li><li>适用于少数区域的动态内容，低延迟读取</li></ul></li><li>题目提到 S3 + 高可用 + 低延迟 &#x3D; S3 CRR</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img233016.png"></p><ul><li><strong>性能优化</strong><ul><li>Proxy 方法（PUT、POST、PATCH、DELETE）和动态内容会跳过区域边缘缓存</li><li>直接转发到源站，不缓存</li></ul></li><li><strong>安全控制</strong><ul><li>WAF 集成: 阻止恶意 IP</li><li>OAI (Origin Access Identity)<ul><li>保护 CloudFront 与 S3 之间的通信</li><li>确保 S3 只能通过 CloudFront 访问</li></ul></li><li>Signed URLs &#x2F; Signed Cookies: 限制文档访问（付费订阅、高级内容）</li><li>可强制要求客户端使用 HTTPS</li></ul></li><li><strong>Origin Groups（高可用配置）</strong><ul><li>所有新请求始终路由到主源站（即使之前故障转移到备用源站）</li><li>仅对 GET、HEAD、OPTIONS 方法进行故障转移（POST、PUT 等写入方法不会故障转移）</li></ul></li></ul><hr><h4 id="CloudFront-Caching"><a href="#CloudFront-Caching" class="headerlink" title="CloudFront Caching"></a>CloudFront Caching</h4><ul><li>缓存位于每个 CloudFront 边缘节点</li><li>CloudFront 使用 Cache Key 识别缓存中的每个对象</li><li>如果 CloudFront 处理语言配置出问题，使用 <code>Query String Forwarding and Caching</code></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img144432.png"></p><ul><li><strong>Cache Key</strong><ul><li>默认组成: Hostname + 资源 URL 路径</li><li>可通过 CloudFront Cache Policy 添加其他元素到 Cache Key</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img144654.png"></p><ul><li><strong>Cache Policy</strong><ul><li>可以使用 HTTP Headers、Cookies、Query Strings 作为 Cache Key 的一部分</li><li>控制哪些请求参数会影响缓存命中率</li><li>包含在 Cache Key 中的元素会转发到源站</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img444857.png"></p><ul><li><strong>Origin Request Policy</strong><ul><li>指定要转发到源站但不包含在 Cache Key 中的值</li><li>用于源站需要但不影响缓存的参数（如身份验证头）</li><li>不影响缓存命中率，但会传递给源站</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img145256.png"></p><hr><h4 id="CloudFront-Cache-Invalidation"><a href="#CloudFront-Cache-Invalidation" class="headerlink" title="CloudFront Cache Invalidation"></a>CloudFront Cache Invalidation</h4><ul><li>让 CloudFront 跳过 TTL 立即更新<ul><li>比如你更新了后端, 但是 CloudFront 不会立即更新, 需要 CloudFront Invalidation 来跳过 TTL 来立即更新</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img234007.png"></p><hr><h4 id="CloudFront-Cache-Behaviors"><a href="#CloudFront-Cache-Behaviors" class="headerlink" title="CloudFront Cache Behaviors"></a>CloudFront Cache Behaviors</h4><ul><li>根据不同的 URL 结构做不同的 Cache Behaviors</li><li>Maximize cache hits by separating staic and dynamic distributions</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img150007.png"></p><hr><h4 id="CloudFront-Geo-Restriction"><a href="#CloudFront-Geo-Restriction" class="headerlink" title="CloudFront Geo Restriction"></a>CloudFront Geo Restriction</h4><ul><li>Allowlist &amp; Blocklist (针对 IP, 国家进行访问限制)<ul><li>CloudFront Geo Restriction 没办法和 VPC 一起使用</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img233638.png"></p><hr><h4 id="CloudFront-Signed-URL-x2F-Cookies"><a href="#CloudFront-Signed-URL-x2F-Cookies" class="headerlink" title="CloudFront Signed URL &#x2F; Cookies"></a>CloudFront Signed URL &#x2F; Cookies</h4><ul><li>类似 S3 Pre-Signed URL<ul><li>Signed URL: access to individual files (单个文件)</li><li>Signed Cookies: access to multiple files (多个文件)</li></ul></li><li>Recommend to use Trusted Key Group than CloudFront Key Pair</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img484256.png"></p><ul><li>CloudFront Signed URL vs. S3 Pre-Signed URL<ul><li>Access CloudFront 的就是 CloudFront Signed URL</li><li>Access S3 的就是 S3 Pre-Signed URL</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img184528.png"></p><ul><li>与 CloudFront signer 有关的 2 个知识点<ul><li>When create a signer, the public key is CloudFront and private key is used to sign a portion of URL</li><li>When use the root user to manage CloudFront key pairs, you can only have up to two active CloudFront key pairs per AWS account</li></ul></li><li>CloudFront Key Pair 只能由 root user 来创建</li></ul><hr><h4 id="CloudFront-Advanced-Concepts"><a href="#CloudFront-Advanced-Concepts" class="headerlink" title="CloudFront Advanced Concepts"></a>CloudFront Advanced Concepts</h4><ul><li>Price Classes (一共 3 种)<ul><li>Price Class All: all regions - best performance</li><li>Price Class 200: most regions, but excludes the most expensive regions</li><li>Price Class 100: only the least expensive regions</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img185111.png"></p><ul><li>CloudFront - Origin Groups<ul><li>Increase high-availability and do failover</li><li>Origin Group: one primary and one secondary origin</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img185430.png"></p><ul><li>CloudFront - Field Level Encryption<ul><li>Protect user sensitive information through application stack</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img185545.png"></p><hr><h4 id="CloudFront-Real-Time-Logs"><a href="#CloudFront-Real-Time-Logs" class="headerlink" title="CloudFront Real Time Logs"></a>CloudFront Real Time Logs</h4><ul><li>Get real-time requests received by CloudFront sent to Kinesis Data Stream</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img195222.png"></p><hr><h4 id="AWS-Global-Accelerator"><a href="#AWS-Global-Accelerator" class="headerlink" title="AWS Global Accelerator"></a>AWS Global Accelerator</h4><ul><li>利用 AWS internal network to route application<ul><li>Provide 2 global static anycast IPs</li><li>Improve availability and performance of the applications (globally)</li></ul></li><li>Global Accelerator improves performance for applications over TCP or UDP</li><li>Global Accelerator has automatic failover</li><li>Global Accelerator is more expensive as it adds an extra layer of infrastructure (对比 CloudFront 不是一个 cost-effective 的选择)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img234527.png"></p><ul><li>AWS Global Accelerator vs CloudFront<ul><li>CloudFront: Content is served at edge, 比如图片和视频 (cacheable), Dynamic content such as API acceleration &amp; dynamic site delivery</li><li>Global Accelerator: 适合 TCP 或者 UDP, 比如游戏和 IoT (static IP)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img000939.png"></p><blockquote><p>AWS Global Accelerator is a network service that can provide a global traffic management solution. By creating a standard accelerator in AWS Global Accelerator, you can guide user traffic to the endpoint closest to them, thereby improving the performance and availability of the application.</p></blockquote><hr><h3 id="14-ECS-ECR-amp-Fargate"><a href="#14-ECS-ECR-amp-Fargate" class="headerlink" title="14. ECS, ECR &amp; Fargate"></a>14. ECS, ECR &amp; Fargate</h3><h4 id="AWS-ECS"><a href="#AWS-ECS" class="headerlink" title="AWS ECS"></a>AWS ECS</h4><ul><li>Elastic Container Service - 在 AWS 上管理 Docker 容器</li><li>两种 Launch Type<ul><li>EC2 Launch Type - 需要预配置, 需要 ECS Agent</li><li>Fargate Launch Type - Serverless, 无需预配置</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img212508.png"></p><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img212546.png"></p><ul><li>IAM Roles for ECS<ul><li>EC2 Instance Profile - 仅针对 EC2 Launch Type, 由 ECS agent 使用</li><li>ECS Task Role - 每个 Task 都有自己的 Role</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img212709.png"></p><ul><li>可以与 Load Balancer (ALB&#x2F;NLB) 配合使用</li><li>可以与 EFS 配合使用 (Fargate + EFS &#x3D; Serverless 文件管理)</li><li>如果 terminate ECS 出现 synchronization issue, ECS 当前状态一定是 <code>STOPPED</code></li><li>如果 ECS cluster launch 出问题, 先检查 <code>ecs.config</code> 配置</li><li>可以用 awslogs log driver 将 ECS 日志发送到 CloudWatch, Fargate 类型还需要在 task definition 中添加 <code>logConfiguration</code> 参数</li><li>计费方式: EC2 Launch Type 按 EC2 实例和 EBS 卷计费, Fargate Launch Type 按容器请求的 vCPU 和内存资源计费</li></ul><hr><h4 id="ECS-Auto-Scaling"><a href="#ECS-Auto-Scaling" class="headerlink" title="ECS Auto Scaling"></a>ECS Auto Scaling</h4><ul><li>自动增加&#x2F;减少 ECS 任务数量<ul><li>Target Scaling - 基于 CloudWatch 指标的目标值扩展</li><li>Step Scaling - 基于 CloudWatch 告警扩展</li><li>Scheduled Scaling - 基于特定时间扩展</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img222247.png"></p><ul><li>Auto Scaling EC2 Instances<ul><li>通过添加底层 EC2 实例来适应 ECS Service 扩展</li><li>使用 Auto Scaling Group Scaling 或 ECS Cluster Capacity Provider</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img205104.png"></p><hr><h4 id="ECS-Rolling-Updates"><a href="#ECS-Rolling-Updates" class="headerlink" title="ECS Rolling Updates"></a>ECS Rolling Updates</h4><ul><li>控制从 v1 更新到 v2 时可以启动和停止的任务数量</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img205259.png"></p><hr><h4 id="ECS-Task-Definitions"><a href="#ECS-Task-Definitions" class="headerlink" title="ECS Task Definitions"></a>ECS Task Definitions</h4><ul><li>Task definitions 是 JSON 格式的元数据, 告诉 ECS 如何运行 Docker 容器</li><li>环境变量来源: 硬编码、SSM Parameter Store、Secrets Manager、S3</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img210902.png"></p><ul><li>ECS Load Balancing - EC2 Launch Type<ul><li>如果在 task definition 中仅定义容器端口, 会获得动态主机端口映射</li><li>必须允许 EC2 实例的 Security Group 接受来自 ALB Security Group 的任何端口</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img211103.png"></p><ul><li>ECS Load Balancing - Fargate<ul><li>每个任务有唯一的私有 IP, 只需定义容器端口</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img211211.png"></p><ul><li>ECS Data Volumes (Bind Mounts)<ul><li>在同一 Task Definition 中的多个容器间共享数据</li><li>同时支持 EC2 和 Fargate</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img211542.png"></p><hr><h4 id="ECS-Task-Placements"><a href="#ECS-Task-Placements" class="headerlink" title="ECS Task Placements"></a>ECS Task Placements</h4><ul><li>针对 EC2 Launch Type, 决定在哪里放置 EC2 (考虑 CPU、Memory 等)</li><li>ECS Task Placement Strategies 可以混合使用 (Binpack, Random 和 Spread)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img212801.png"></p><ul><li>ECS Task Placement Strategies - Binpack<ul><li>基于最少可用 CPU 或内存放置任务</li><li>最小化使用的实例数量 (节省成本)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img213429.png"></p><ul><li>ECS Task Placement Strategies - Random<ul><li>随机放置任务</li><li>启用随机主机端口: 设置 host <code>port = 0</code> 或留空, 允许同类型的多个容器在同一 EC2 容器实例上启动</li><li>如果第一个 container 运行成功但第二个失败, 通常是 host port 配置问题</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img213517.png"></p><ul><li>ECS Task Placement Strategies - Spread<ul><li>基于指定值均匀分布任务</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img213603.png"></p><ul><li>ECS Task Placement Constraints<ul><li><code>distinctInstance</code> - 将每个任务放置在不同的容器实例上</li><li><code>memberOf</code> - 将任务放置在满足表达式的实例上</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img213754.png"></p><hr><h4 id="AWS-ECR"><a href="#AWS-ECR" class="headerlink" title="AWS ECR"></a>AWS ECR</h4><ul><li>Elastic Container Registry (ECR) - 在 AWS 上存储和管理 Docker 镜像</li><li>注意区分: ECR 管理 Docker Image, 不是 Docker Container</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img222836.png"></p><ul><li>使用 CLI 拉取和推送镜像到 ECR 的命令<ul><li>登录命令: <code>$(aws ecr get-login --no-include-email)</code></li><li>拉取镜像: <code>docker pull 1234567890.dkr.ecr.eu-west-1.amazonaws.com/demo:latest</code></li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img214106.png"></p><hr><h4 id="AWS-CoPilot"><a href="#AWS-CoPilot" class="headerlink" title="AWS CoPilot"></a>AWS CoPilot</h4><ul><li>CLI 工具, 用于构建、发布和运维生产就绪的容器化应用 (production-ready containerized apps)</li><li>支持在 AppRunner、ECS 和 Fargate 上运行应用</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img214226.png"></p><hr><h4 id="AWS-EKS"><a href="#AWS-EKS" class="headerlink" title="AWS EKS"></a>AWS EKS</h4><ul><li>Elastic Kubernetes Service - 在 AWS 上管理 Kubernetes 集群</li><li>支持两种部署模式: EC2 和 Fargate (与 ECS 相同)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img223132.png"></p><ul><li>EKS Data Volumes<ul><li>需要 StorageClass manifest</li><li>利用 Container Storage Interface (CSI) compliant driver</li><li>支持的存储类型: EBS、EFS、FSx for Lustre</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img223503.png"></p><hr><h3 id="15-Elastic-Beanstalk"><a href="#15-Elastic-Beanstalk" class="headerlink" title="15. Elastic Beanstalk"></a>15. Elastic Beanstalk</h3><h4 id="AWS-Elastic-Beanstalk"><a href="#AWS-Elastic-Beanstalk" class="headerlink" title="AWS Elastic Beanstalk"></a>AWS Elastic Beanstalk</h4><ul><li>Elastic Beanstalk 是以开发者为中心的 AWS 应用部署服务</li><li>自动处理容量配置 (capacity provisioning)、负载均衡 (load balancing)、自动扩展 (scaling)、应用健康监控等</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img150326.png"></p><ul><li>Web Server Tier vs. Worker Tier<ul><li>Web Server Tier - 处理 HTTP 请求, 运行 Web 应用</li><li>Worker Tier - 处理后台任务, 从 SQS 队列消费消息, 可配合 SNS 使用</li></ul></li><li>Worker 或 Web environment 需要 <code>cron.yaml</code> 文件来定义定时任务</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img210711.png"></p><ul><li>部署模式选择<ul><li>Single Instance Mode - 单实例模式, 成本最低, 适合开发&#x2F;测试环境</li><li>High Availability Mode - 高可用模式, 多实例 + Load Balancer, 适合生产环境</li></ul></li><li>不支持的运行时 (如 Rust) 可以使用 Docker image 来运行</li><li>部署失败处理: Elastic Beanstalk 会用最近一次成功部署的应用版本替换失败的实例 (replace the failed instances with instances running in the application version from the most recent successful deployment)</li><li>配置 HTTPS: 在 <code>.ebextensions</code> 文件夹中创建配置文件来管理 Load Balancer 的 SSL 证书</li><li>跨账户迁移 Beanstalk 环境<ul><li>创建 saved configuration 并下载到本地</li><li>修改账户相关参数</li><li>上传到另一个账户的 S3 bucket</li><li>在 Elastic Beanstalk 控制台从 ‘Saved Configurations’ 创建应用</li></ul></li></ul><hr><h4 id="Beanstalk-Deployment-Modes"><a href="#Beanstalk-Deployment-Modes" class="headerlink" title="Beanstalk Deployment Modes"></a>Beanstalk Deployment Modes</h4><ul><li>Beanstalk 提供 6 种部署模式, 各有不同的特点和适用场景</li><li>Immutable 和 Traffic Splitting 可能会导致 EC2 burst balance 丢失</li><li>Rolling 和 Rolling with additional batches 都会导致可用性降低 (reduced availability)</li><li>避免停机时间 (avoid downtime) 的最佳选择: Blue&#x2F;Green Deployment</li></ul><p><strong>All at once (全量更新)</strong></p><ul><li>最快的部署方式, 但会有停机时间 (downtime)</li><li>直接更新所有实例, 适合开发环境</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img151200.png"></p><p><strong>Rolling (滚动更新)</strong></p><ul><li>分批更新实例 (update a few instances at a time - bucket)</li><li>逐批移动到下一组 (move onto the next bucket)</li><li>部署期间应用容量降低, 运行多个版本</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img151311.png"></p><p><strong>Rolling with additional batches (额外批次滚动更新)</strong></p><ul><li>类似 Rolling, 但会先启动新实例来保持容量</li><li>旧版本应用仍然可用 (old application still available)</li><li>有额外的实例成本, 但保持了完整容量</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img151443.png"></p><p><strong>Immutable (不可变部署)</strong></p><ul><li>在新的 ASG 中启动新实例, 部署新版本</li><li>所有实例健康后进行交换 (swap all instances when everything is healthy)</li><li>支持快速回滚 (quick rollback)</li><li>如果需要保持完整应用容量且最小化失败部署的影响 (maintain at least the full capacity and minimal impact of failed deployment), 选择 Immutable</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img151738.png"></p><p><strong>Blue&#x2F;Green (蓝绿部署)</strong></p><ul><li>创建一个全新的环境 (create a new environment)</li><li>准备就绪后切换流量 (switch over when ready)</li><li>零停机时间, 易于回滚</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img151838.png"></p><p><strong>Traffic Splitting (流量分割)</strong></p><ul><li>金丝雀测试 (Canary testing)</li><li>将一小部分流量发送到新部署 (send a small % of traffic to new deployment)</li><li>逐步验证新版本的稳定性</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img151935.png"></p><hr><h4 id="Beanstalk-Lifecycle-Policy"><a href="#Beanstalk-Lifecycle-Policy" class="headerlink" title="Beanstalk Lifecycle Policy"></a>Beanstalk Lifecycle Policy</h4><ul><li>Elastic Beanstalk 最多存储 1000 个应用版本</li><li>使用 lifecycle policy 自动淘汰旧版本应用 (phase out old application versions, 重要)</li><li>可基于版本总数或版本年龄删除旧版本, 当前使用的版本不会被删除</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img152423.png"></p><hr><h4 id="Beanstalk-Extensions"><a href="#Beanstalk-Extensions" class="headerlink" title="Beanstalk Extensions"></a>Beanstalk Extensions</h4><ul><li>部署到 Elastic Beanstalk 的 zip 文件包含代码和配置文件</li><li>配置文件必须放在根目录的 <code>.ebextensions/</code> 文件夹下, 文件后缀为 <code>.config</code> (YAML 或 JSON 格式)</li><li>可配置内容: option settings, Linux&#x2F;Windows 服务器配置, 自定义资源 (RDS, ElastiCache, DynamoDB 等)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img155315.png"></p><hr><h4 id="Beanstalk-with-CloudFormation"><a href="#Beanstalk-with-CloudFormation" class="headerlink" title="Beanstalk with CloudFormation"></a>Beanstalk with CloudFormation</h4><ul><li>Elastic Beanstalk 底层依赖 CloudFormation 来配置基础设施</li><li>CloudFormation 用于自动化部署其他 AWS 服务 (EC2, RDS, Load Balancer 等)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img161346.png"></p><hr><h4 id="Beanstalk-Cloning"><a href="#Beanstalk-Cloning" class="headerlink" title="Beanstalk Cloning"></a>Beanstalk Cloning</h4><ul><li>克隆现有环境, 创建具有完全相同配置的新环境</li><li>适用于部署应用的测试版本 (test version), 或创建生产环境的副本进行实验</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img161531.png"></p><hr><h3 id="16-AWS-CloudFormation"><a href="#16-AWS-CloudFormation" class="headerlink" title="16. AWS CloudFormation"></a>16. AWS CloudFormation</h3><h4 id="AWS-CloudFormation"><a href="#AWS-CloudFormation" class="headerlink" title="AWS CloudFormation"></a>AWS CloudFormation</h4><ul><li>声明式方式定义 AWS 基础设施 (Infrastructure as Code, IaC)</li><li>描述需要的资源 (如 EC2, S3, RDS), CloudFormation 自动创建和配置</li><li>CloudFormation 是 IaaS (Infrastructure as a Service), 可以使用网上现有的模板</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img003448.png"></p><ul><li>Templates 必须上传到 S3 并在 CloudFormation 中引用</li><li>更新 template 需要重新上传新版本 → 流程: 本地更新 template → 上传到 S3 → 在 CloudFormation console 应用</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img193232.png"></p><ul><li>部署 CloudFormation Templates 的两种方式<ul><li>Manual - 在 Application Composer 或代码编辑器中手动编辑</li><li>Automated - 通过 YAML 文件自动化部署</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img193404.png"></p><ul><li>依赖 CloudFormation 来 provision resources 的服务: Elastic Beanstalk 和 SAM</li><li>上传 Lambda 和 CloudFormation template 使用命令: <code>cloudformation package</code> 和 <code>cloudformation deploy</code></li><li>在 CloudFormation 中声明 Lambda function<ul><li>无第三方依赖时可以在 <code>AWS::Lambda::Function</code> block 中直接内联代码 (inline code)</li><li>有第三方依赖时将代码打包成 zip 上传到 S3, 然后在 <code>AWS::Lambda::Function</code> block 中引用 S3 对象</li></ul></li></ul><hr><h4 id="CloudFormation-Resources"><a href="#CloudFormation-Resources" class="headerlink" title="CloudFormation Resources"></a>CloudFormation Resources</h4><ul><li>Resources 代表将要创建和配置的不同 AWS 组件</li><li>CloudFormation 自动处理资源的创建顺序和依赖关系, 无需手动定义创建顺序</li><li>Resources 是 CloudFormation template 中唯一必需的部分 (mandatory)</li><li>资源类型命名格式: <code>service-provider::service-name::data-type-name</code> (如 <code>AWS::EC2::Instance</code>)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img194109.png"></p><hr><h4 id="CloudFormation-Parameters"><a href="#CloudFormation-Parameters" class="headerlink" title="CloudFormation Parameters"></a>CloudFormation Parameters</h4><ul><li>Parameters 用于向 CloudFormation template 提供输入值</li><li>可以复用同一个 template 而无需重新上传, 只需更改参数值</li><li>常见 Parameter 类型: <code>AWS::EC2::KeyPair::KeyName</code>, <code>CommaDelimitedList</code>, <code>String</code>, <code>Number</code> 等</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img194424.png"></p><ul><li>重要的 Parameters 设置<ul><li><code>AllowedValues</code> - 限制用户可选的值 (如实例类型只能选 t2.micro, t2.small, t2.medium)</li><li><code>NoEcho</code> - 隐藏敏感信息 (如密码) 避免在日志和控制台中显示</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img194757.png"></p><ul><li>Pseudo Parameters (伪参数)<ul><li>默认启用可随时使用, 无需定义</li><li>常用伪参数: <code>AWS::AccountId</code>, <code>AWS::Region</code>, <code>AWS::StackId</code>, <code>AWS::StackName</code>, <code>AWS::NotificationARNs</code>, <code>AWS::NoValue</code></li><li>使用场景: 动态引用账户 ID、区域等信息, 使 template 更通用</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img223040.png"></p><hr><h4 id="CloudFormation-Mappings"><a href="#CloudFormation-Mappings" class="headerlink" title="CloudFormation Mappings"></a>CloudFormation Mappings</h4><ul><li>Mappings 是 CloudFormation template 中的固定变量 (硬编码的键值对)</li><li>用于根据不同条件返回不同值, 如区分环境 (dev vs prod)、区域 (us-east-1 vs eu-west-1)、AMI ID 等</li><li>使用 <code>Fn::FindInMap</code> 函数访问 Mapping 中的值</li><li>适用于预定义的、可预测的值, 动态值使用 Parameters</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img212000.png"></p><hr><h4 id="CloudFormation-Outputs-amp-Exports"><a href="#CloudFormation-Outputs-amp-Exports" class="headerlink" title="CloudFormation Outputs &amp; Exports"></a>CloudFormation Outputs &amp; Exports</h4><ul><li>Outputs 声明可选的输出值, 允许其他 stack 导入和使用这些值</li><li>工作流程: Stack A 通过 <code>Export</code> 导出值 → Stack B 通过 <code>Fn::ImportValue</code> 导入和引用该值</li><li>Exported output name 在同一 Region 内必须唯一</li><li><code>Export</code> 用于导出值给其他 stacks, <code>ImportValue</code> 用于从其他 stack 引用值</li><li>使用场景: 跨 stack 共享资源 (如 VPC ID, Security Group ID, Load Balancer DNS 等)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img212344.png"></p><ul><li>删除限制: 必须先删除所有导入该值的 stack, 才能删除或修改导出该值的 stack</li><li>示例: Stack B 和 C 引用 Stack A 的输出值, 则必须先删除 Stack B 和 C, 最后删除 Stack A</li></ul><hr><h4 id="CloudFormation-Conditions"><a href="#CloudFormation-Conditions" class="headerlink" title="CloudFormation Conditions"></a>CloudFormation Conditions</h4><ul><li>Conditions 根据条件控制资源或输出的创建</li><li>常见条件类型: 环境 (dev vs prod)、AWS Region、Parameter 值</li><li>可以与 Conditions 关联的部分: Resources, Conditions (条件嵌套), Outputs</li><li>常用条件函数: <code>Fn::And</code>, <code>Fn::Equals</code>, <code>Fn::If</code>, <code>Fn::Not</code>, <code>Fn::Or</code></li><li>CloudFormation template 中无效的 section 是 <code>Dependencies</code> (正确的是 <code>DependsOn</code> 属性)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img212731.png"></p><hr><h4 id="CloudFormation-Intrinsic-Functions"><a href="#CloudFormation-Intrinsic-Functions" class="headerlink" title="CloudFormation Intrinsic Functions"></a>CloudFormation Intrinsic Functions</h4><ul><li><code>Fn::Ref</code> (简写 <code>!Ref</code>) - 引用 Parameters 或 Resources<ul><li>引用 Parameter 返回参数值, 引用 Resource 返回资源物理 ID</li><li>只能在 Parameter 或 Resource 部分使用</li><li>示例: <code>!Ref MyBucket</code> 返回 bucket 名称</li></ul></li><li><code>Fn::GetAtt</code> (简写 <code>!GetAtt</code>) - 获取资源的属性值<ul><li>不同资源类型有不同可用属性</li><li>示例: <code>!GetAtt EC2Instance.PublicIp</code> 获取 EC2 公网 IP</li></ul></li><li><code>Fn::FindInMap</code> (简写 <code>!FindInMap</code>) - 从 Mappings 中查找值<ul><li>接受 3 个参数: MapName, TopLevelKey, SecondLevelKey</li><li>示例: <code>!FindInMap [RegionMap, !Ref &quot;AWS::Region&quot;, AMI]</code></li></ul></li><li><code>Fn::ImportValue</code> (简写 <code>!ImportValue</code>) - 导入其他 stack 的 Outputs 值<ul><li>实现跨 stack 资源共享</li><li>示例: <code>!ImportValue NetworkStackVPCID</code></li></ul></li><li><code>Fn::Join</code> - 连接字符串数组<ul><li>第一个参数是分隔符, 第二个参数是字符串列表</li><li>示例: <code>!Join [&quot;-&quot;, [a, b, c]]</code> 返回 “a-b-c”</li></ul></li><li><code>Fn::Sub</code> - 字符串变量替换<ul><li>将 <code>$&#123;&#125;</code> 包裹的变量替换为实际值</li><li>示例: <code>!Sub &quot;arn:aws:s3:::$&#123;BucketName&#125;/*&quot;</code></li></ul></li><li><code>Fn::Base64</code> - Base64 编码<ul><li>常用于 EC2 User Data</li><li>示例: <code>!Base64 &quot;#!/bin/bash\necho Hello&quot;</code></li></ul></li><li>Condition Functions - 条件控制函数<ul><li><code>Fn::And</code>, <code>Fn::Equals</code>, <code>Fn::If</code>, <code>Fn::Not</code>, <code>Fn::Or</code></li><li>用于根据条件创建或配置资源</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img214211.png"></p><hr><h4 id="CloudFormation-Rollbacks"><a href="#CloudFormation-Rollbacks" class="headerlink" title="CloudFormation Rollbacks"></a>CloudFormation Rollbacks</h4><ul><li>Stack Creation Fails - 创建失败时自动回滚<ul><li>默认删除所有已创建的资源</li><li>可使用 <code>--disable-rollback</code> 保留资源用于调试</li></ul></li><li>Stack Update Fails - 更新失败时回滚到上一个工作状态<ul><li>保留原有资源配置, 撤销失败的更改</li><li>自动恢复到已知的稳定状态</li></ul></li><li>Rollback 失败 - 回滚过程也可能失败<ul><li>stack 进入 <code>UPDATE_ROLLBACK_FAILED</code> 状态</li><li>原因: 资源依赖问题, 权限不足, 外部资源被手动删除</li><li>解决方法: 使用 <code>ContinueUpdateRollback</code> API 继续回滚, 或删除 stack 重建</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img215108.png"></p><hr><h4 id="CloudFormation-Service-Role"><a href="#CloudFormation-Service-Role" class="headerlink" title="CloudFormation Service Role"></a>CloudFormation Service Role</h4><ul><li>IAM role 允许 CloudFormation 代表用户创建&#x2F;更新&#x2F;删除 stack 资源</li><li>用户通过 Service Role 授权 CloudFormation 操作资源, 无需直接给用户资源权限, 实现最小权限原则</li><li>用户必须有 <code>iam:PassRole</code> 权限才能将 role 传递给 CloudFormation</li><li>应用场景: 限制开发者权限, 只允许通过 CloudFormation 管理特定资源, 不允许直接在 console 手动操作</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img215347.png"></p><hr><h4 id="CloudFormation-DeletionPolicy"><a href="#CloudFormation-DeletionPolicy" class="headerlink" title="CloudFormation DeletionPolicy"></a>CloudFormation DeletionPolicy</h4><p>控制 CloudFormation template 删除或资源从 template 中移除时的行为</p><ul><li><code>DeletionPolicy = Delete</code> - 默认策略, stack 删除时同时删除资源<ul><li>S3 Bucket 非空时删除失败</li><li>适用于临时资源、测试环境</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img220014.png"></p><ul><li><code>DeletionPolicy = Retain</code> - 保留资源, stack 删除时资源不被删除<ul><li>用于保护关键数据资源 (如生产数据库、重要 S3 bucket)</li><li>资源脱离 CloudFormation 管理变为独立资源</li><li>适用场景: 数据库迁移、资源转移到其他 stack</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img220147.png"></p><ul><li><code>DeletionPolicy = Snapshot</code> - 删除资源前创建最终快照备份<ul><li>支持的资源: EBS Volume, RDS, Redshift, Neptune, DocumentDB</li><li>删除资源但保留快照, 可用于数据恢复</li><li>适用场景: 需要数据备份的资源清理</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img220302.png"></p><hr><h4 id="CloudFormation-Stack-Policy"><a href="#CloudFormation-Stack-Policy" class="headerlink" title="CloudFormation Stack Policy"></a>CloudFormation Stack Policy</h4><ul><li>JSON 文档定义 stack 更新时允许的操作</li><li>防止关键资源被意外修改或删除</li><li>设置后默认拒绝所有更新, 必须显式允许</li><li>无法删除只能更新, 可使用临时 policy 覆盖</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img220535.png"></p><hr><h4 id="CloudFormation-Termination-Protection"><a href="#CloudFormation-Termination-Protection" class="headerlink" title="CloudFormation Termination Protection"></a>CloudFormation Termination Protection</h4><ul><li>防止 CloudFormation Stack 被意外删除</li><li>启用 <code>TerminationProtection</code> 后必须先禁用才能删除 stack</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img220655.png"></p><hr><h4 id="CloudFormation-Custom-Resources"><a href="#CloudFormation-Custom-Resources" class="headerlink" title="CloudFormation Custom Resources"></a>CloudFormation Custom Resources</h4><ul><li>用于定义 CloudFormation 不支持的资源或执行自定义逻辑</li><li>Template 中使用 <code>Custom::MyCustomResourceTypeName</code> 定义</li><li>工作原理: CloudFormation 发送请求到 Lambda&#x2F;SNS → Lambda 执行自定义操作 → 返回 SUCCESS&#x2F;FAILED 响应</li><li>典型应用场景<ul><li>清空 S3 bucket 后再删除 (解决非空 bucket 无法删除问题, 重要)</li><li>调用第三方 API 创建外部资源</li><li>初始化数据库 schema 或导入初始数据</li><li>执行复杂的资源配置逻辑</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img221103.png"></p><hr><h4 id="CloudFormation-StackSets"><a href="#CloudFormation-StackSets" class="headerlink" title="CloudFormation StackSets"></a>CloudFormation StackSets</h4><ul><li>跨多个 AWS 账户和 Region 创建、更新、删除 stacks</li><li>只有 Administrator 账户可以创建 StackSets, target 账户接收部署</li><li>更新 StackSet 时所有关联的 stack instances 自动更新</li><li>部署配置选项<ul><li>并发控制: 指定同时部署的账户&#x2F;Region 数量</li><li>失败容忍度: 设置可容忍的失败数量或百分比</li><li>部署顺序: 按 Region 优先或按账户优先</li></ul></li><li>典型应用场景: 多账户统一安全基线配置, 跨 Region 部署相同应用架构, 组织级别的合规策略部署</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img221509.png"></p><hr><h3 id="17-SQS-SNS-Kinesis"><a href="#17-SQS-SNS-Kinesis" class="headerlink" title="17. SQS, SNS, Kinesis"></a>17. SQS, SNS, Kinesis</h3><h4 id="AWS-SQS"><a href="#AWS-SQS" class="headerlink" title="AWS SQS"></a>AWS SQS</h4><ul><li>解耦应用组件, 支持多对多通信模型 (视频处理队列、订单处理等场景)</li><li>自动扩展: 无限吞吐量, 无限消息数量</li><li>消息保留时间 4 天 (默认), 最长 14 天; 单条消息最大 256 KB</li><li>一次最多检索 10 条消息</li><li>Standard SQS 支持作为 S3 Event Notification 目标; FIFO SQS 不支持</li><li>并行处理场景选择 SQS; 解耦微服务 (无第三方集成需求) 选择 SQS</li><li>高吞吐量的请求-响应消息模式选择 Temporary Queue</li><li>长时间运行的工作流选择 Dedicated Worker Environment</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img231916.png"></p><ul><li>Producing Messages<ul><li>消息持久化保存在 SQS 中直到被 consumer 删除</li><li>支持延迟投递 (<code>DelaySeconds</code>), FIFO 支持去重 (<code>MessageDeduplicationId</code>)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img232217.png"></p><ul><li>Consuming Messages<ul><li>支持多个 consumer 并行处理消息</li><li>Consumer 必须在处理后调用 <code>DeleteMessage</code> 删除消息</li><li>未删除的消息在 Visibility Timeout 后会重新回到队列</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img232414.png"></p><ul><li>Priority Queue 实现: 创建两个 Standard Queue (高优先级 &#x2F; 普通优先级), EC2 instances 优先轮询高优先级队列</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/imgpt6-q32-i1.jpg"></p><ul><li><code>CreateQueue</code> API 关键配置<ul><li><code>VisibilityTimeout</code> 默认 30 秒</li><li>创建后无法更改队列类型 (Standard vs FIFO)</li></ul></li><li>监控: 使用 <code>ApproximateNumberOfMessagesVisible</code> 指标, 配合 backlog per instance metric 和 Target Tracking Scaling Policy 调整 worker 数量</li></ul><hr><h4 id="SQS-Message-Visibility-Timeout"><a href="#SQS-Message-Visibility-Timeout" class="headerlink" title="SQS Message Visibility Timeout"></a>SQS Message Visibility Timeout</h4><ul><li>Consumer 拉取消息后, 该消息在 Visibility Timeout 期间对其他 consumer 不可见</li><li>默认 30 秒, 范围 0 秒 - 12 小时</li><li><strong>Timeout 过长</strong>: Consumer 崩溃后, 消息被锁定, 重新处理需要等待较长时间</li><li><strong>Timeout 过短</strong>: Consumer 未完成处理, 消息提前回到队列, 导致重复消费 (考试重点)</li><li>使用 <code>ChangeMessageVisibility</code> API 动态调整单条消息的 Visibility Timeout</li><li>考试场景通常关注: Visibility Timeout 过短 → 重复消息 → 增加 timeout 或使用 <code>ChangeMessageVisibility</code></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img020440.png"></p><hr><h4 id="SQS-Dead-Letter-Queues-DLQ"><a href="#SQS-Dead-Letter-Queues-DLQ" class="headerlink" title="SQS Dead Letter Queues (DLQ)"></a>SQS Dead Letter Queues (DLQ)</h4><ul><li>消息在 Visibility Timeout 后回到队列, 但某些消息可能本身无法处理 (格式错误、依赖服务不可用等)</li><li>DLQ 用于隔离反复失败的消息, 避免无限重试阻塞队列</li><li>设置 <code>MaximumReceives</code> 阈值: 消息重新进入队列次数超过阈值后自动转移到 DLQ</li><li>DLQ 适合用于调试和分析失败原因</li><li>FIFO 队列的 DLQ 必须也是 FIFO 队列; Standard 队列的 DLQ 必须是 Standard 队列</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img164418.png"></p><ul><li>DLQ - Redrive to Source<ul><li>从 DLQ 中读取失败消息, 分析问题原因</li><li>修复代码后, 使用 Redrive 功能将消息从 DLQ 重新发送回源队列进行处理</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img164607.png"></p><hr><h4 id="SQS-Delay-Queues"><a href="#SQS-Delay-Queues" class="headerlink" title="SQS Delay Queues"></a>SQS Delay Queues</h4><ul><li>延迟消息投递最长 15 分钟, 使用 <code>DelaySeconds</code> 参数设置</li><li>Consumer 在延迟时间到达前无法看到消息</li><li>适用场景: 需要延迟处理的任务 (如订单取消前的等待期)</li><li>可在队列级别设置默认延迟, 也可在消息级别单独设置</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img164931.png"></p><hr><h4 id="SQS-Long-Polling"><a href="#SQS-Long-Polling" class="headerlink" title="SQS Long Polling"></a>SQS Long Polling</h4><ul><li>Consumer 调用 <code>ReceiveMessage</code> 时等待消息到达, 而不是立即返回空响应</li><li>减少 API 调用次数, 降低延迟和成本</li><li>等待时间 1-20 秒 (通过 <code>WaitTimeSeconds</code> 设置), 0 秒为 Short Polling</li><li>Long Polling 不能解决重复消息问题, 仍需依赖 Visibility Timeout 机制</li><li>可在队列级别或单次请求级别设置</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img003255.png"></p><hr><h4 id="SQS-Extended-Client"><a href="#SQS-Extended-Client" class="headerlink" title="SQS Extended Client"></a>SQS Extended Client</h4><ul><li>处理大于 256 KB 的消息 (最大支持 2 GB)</li><li>使用 AWS SDK for Java Extended Client Library</li><li>原理: 大消息存储在 S3, SQS 中只保留 S3 对象引用</li><li>Consumer 使用 Extended Client 自动从 S3 下载完整消息</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img165310.png"></p><hr><h4 id="SQS-FIFO-Queues"><a href="#SQS-FIFO-Queues" class="headerlink" title="SQS FIFO Queues"></a>SQS FIFO Queues</h4><ul><li>严格保证消息顺序, 队列名必须以 <code>.fifo</code> 结尾</li><li>默认吞吐量: 300 消息&#x2F;秒 (无批处理) 或 3000 消息&#x2F;秒 (使用批处理)</li><li>无 <code>MessageGroupID</code>: 所有消息串行处理, 只能有 1 个 consumer</li><li>有 <code>MessageGroupID</code>: 同一 Group 内消息有序, 不同 Group 可并行, 支持多个 consumer</li><li>SNS FIFO + SQS FIFO 可实现端到端有序消息传递</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img003507.png"></p><ul><li>将 Standard Queue 转为 FIFO Queue<ul><li>删除现有 Standard Queue, 重新创建 FIFO Queue (无法直接转换)</li><li>确保队列名以 <code>.fifo</code> 结尾</li><li>确认吞吐量需求不超过 FIFO 限制 (3000 消息&#x2F;秒)</li></ul></li></ul><hr><h4 id="SQS-FIFO-Queues-Advanced"><a href="#SQS-FIFO-Queues-Advanced" class="headerlink" title="SQS FIFO Queues Advanced"></a>SQS FIFO Queues Advanced</h4><ul><li>De-duplication (去重)<ul><li>使用 <code>MessageDeduplicationID</code> 识别重复消息</li><li>5 分钟内发送相同 ID 的消息会被拒绝</li><li>或启用 <code>ContentBasedDeduplication</code>, 基于消息体 SHA-256 哈希自动去重</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img170023.png"></p><ul><li>Message Grouping (消息分组)<ul><li>使用 <code>MessageGroupID</code> 对消息分组</li><li>同一 Group 内的消息严格有序, 只能由一个 consumer 顺序处理</li><li>不同 Group 的消息可并行处理, 支持多个 consumer 提高吞吐量</li><li>所有消息使用相同 <code>MessageGroupID</code> → 整个队列串行处理, 只能 1 个 consumer</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img170254.png"></p><hr><h4 id="AWS-SNS"><a href="#AWS-SNS" class="headerlink" title="AWS SNS"></a>AWS SNS</h4><ul><li>Pub&#x2F;Sub 模型, 一条消息发送给多个订阅者 (一对多)</li><li>Publisher 发送消息到 Topic, 所有订阅该 Topic 的 Subscriber 都会收到</li><li>Subscriber 类型: SQS, Lambda, Kinesis Data Firehose, HTTP&#x2F;HTTPS, Email, SMS, Mobile Push</li><li>支持 Message Filtering: 订阅者可基于消息属性过滤, 只接收感兴趣的消息</li><li>单个 Topic 最多 12,500,000 个订阅, 每个账户最多 100,000 个 Topic</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img010634.png"></p><hr><h4 id="Fan-Out-Pattern"><a href="#Fan-Out-Pattern" class="headerlink" title="Fan Out Pattern"></a>Fan Out Pattern</h4><ul><li>SNS + SQS 组合: SNS Topic 发布一次消息, 多个 SQS 队列订阅并接收</li><li>完全解耦, 无数据丢失; 每个 SQS 队列可独立消费, 互不影响</li><li>支持 Message Filtering: 不同 SQS 订阅者可设置不同过滤策略, 只接收符合条件的消息</li><li>Kinesis Data Streams 也支持 Fan Out: 通过 Enhanced Fan-Out 每个 Consumer 获得专用 2MB&#x2F;s 吞吐量</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img011026.png"></p><hr><h4 id="AWS-Kinesis"><a href="#AWS-Kinesis" class="headerlink" title="AWS Kinesis"></a>AWS Kinesis</h4><ul><li>实时数据流处理平台, 用于采集、处理、存储流式数据</li><li><strong>Kinesis Data Streams</strong>: 实时数据流的采集、存储和处理; 支持自定义消费者应用</li><li><strong>Kinesis Data Firehose</strong>: 将数据流加载到 AWS 数据存储 (S3, Redshift, OpenSearch, HTTP endpoints); 近实时, 自动扩展</li><li><strong>Kinesis Data Analytics</strong>: 使用 SQL 或 Apache Flink 实时分析数据流</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img150053.png"></p><blockquote><p>Kinesis Agent 无法直接写入已配置为从 Kinesis Data Streams 接收数据的 Firehose delivery stream</p></blockquote><ul><li>Kinesis Agent: 独立的 Java 应用, 简化从服务器收集日志并发送到 Kinesis Data Streams 的过程</li></ul><hr><h4 id="Kinesis-Data-Streams"><a href="#Kinesis-Data-Streams" class="headerlink" title="Kinesis Data Streams"></a>Kinesis Data Streams</h4><ul><li>实时数据流采集和存储, 支持数据重放 (Replay) 和重新处理</li><li>数据保留期 24 小时 (默认) - 365 天; 数据写入后不可删除, 只能等待过期</li><li>适用场景: 实时日志分析、点击流数据、金融交易、IoT 传感器数据</li><li>Consumer 类型: Lambda, Kinesis Data Firehose, Kinesis Data Analytics, 自定义应用 (KCL)</li><li>每秒可从多个 Producer 采集数 GB 数据</li><li>考试提示: Kinesis Data Streams + SQL 查询 → 使用 Kinesis Data Analytics</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img014850.png"></p><ul><li>相同 Partition Key 的数据进入同一 Shard, 保证顺序性</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img151123.png"></p><ul><li>Capacity Mode<ul><li><strong>Provisioned Mode</strong>: 手动指定 Shard 数量; 每个 Shard 1MB&#x2F;s 写入, 2MB&#x2F;s 读取; 按 Shard 小时计费</li><li><strong>On-Demand Mode</strong>: 自动扩展, 无需管理容量; 默认 4MB&#x2F;s 或 4000 records&#x2F;s; 按数据吞吐量计费</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img151507.png"></p><hr><h4 id="Kinesis-Producers"><a href="#Kinesis-Producers" class="headerlink" title="Kinesis Producers"></a>Kinesis Producers</h4><ul><li>将数据记录写入 Kinesis Data Streams</li><li>Producer 类型<ul><li><strong>AWS SDK</strong>: 直接调用 <code>PutRecord</code> &#x2F; <code>PutRecords</code> API; 适合低吞吐量场景</li><li><strong>Kinesis Producer Library (KPL)</strong>: 高性能 C++&#x2F;Java 库, 支持批处理、压缩、聚合; 适合高吞吐量</li><li><strong>Kinesis Agent</strong>: 预构建应用, 从日志文件持续采集数据到 Kinesis</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img172002.png"></p><ul><li>使用 Hash 函数对 Partition Key 计算, 决定数据进入哪个 Shard</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img172126.png"></p><ul><li><code>ProvisionedThroughputExceededException</code> 异常处理<ul><li>原因: 写入速度超过 Shard 容量 (1MB&#x2F;s 或 1000 records&#x2F;s per shard)</li><li><strong>解决方案 1</strong>: 使用高度分散的 Partition Key, 避免热点 Shard</li><li><strong>解决方案 2</strong>: 实现指数退避重试机制</li><li><strong>解决方案 3</strong>: 增加 Shard 数量 (通过 UpdateShardCount 或 On-Demand Mode)</li><li><strong>解决方案 4</strong>: 减少请求频率或单条记录大小</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img172335.png"></p><hr><h4 id="Kinesis-Consumers"><a href="#Kinesis-Consumers" class="headerlink" title="Kinesis Consumers"></a>Kinesis Consumers</h4><ul><li>从 Kinesis Data Streams 读取并处理数据记录</li><li>Consumer 类型: Lambda, Kinesis Data Analytics, Kinesis Data Firehose, 自定义应用 (KCL)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img190504.png"></p><ul><li>Kinesis Consumers - 自定义 Consumer<ul><li><strong>Shared (Classic) Fan-Out</strong>: Pull 模式, 所有 Consumer 共享每个 Shard 的 2MB&#x2F;s 读取; 适合少量 Consumer, 成本低</li><li><strong>Enhanced Fan-Out</strong>: Push 模式, 每个 Consumer 获得专用 2MB&#x2F;s 读取; 适合多 Consumer 并发, 延迟更低 (~70ms), 成本高</li><li>Enhanced Fan-Out 可显著提升读取吞吐量, 避免 Consumer 之间竞争</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img202712.png"></p><ul><li>Kinesis Consumers - AWS Lambda<ul><li>支持 Classic 和 Enhanced Fan-Out 两种模式</li><li>批量读取记录, 可配置批量大小和批处理时间窗口</li><li>Lambda 自动轮询 Kinesis, 处理失败时自动重试</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img203145.png"></p><hr><h4 id="Kinesis-Client-Library-KCL"><a href="#Kinesis-Client-Library-KCL" class="headerlink" title="Kinesis Client Library (KCL)"></a>Kinesis Client Library (KCL)</h4><ul><li>Java&#x2F;Python&#x2F;Node.js&#x2F;Ruby 库, 简化从 Kinesis Data Streams 读取和处理数据</li><li>每个 Shard 只能由一个 KCL instance 读取, KCL 自动分配 Shard 给不同的 Worker</li><li>进度通过 Checkpoint 保存到 DynamoDB (需要 IAM 权限访问 DynamoDB)</li><li>支持负载均衡: KCL instances 数量可以少于或等于 Shard 数量, 自动分配工作负载</li><li>适合构建复杂的自定义 Consumer 应用</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img205645.png"></p><hr><h4 id="Kinesis-Operations"><a href="#Kinesis-Operations" class="headerlink" title="Kinesis Operations"></a>Kinesis Operations</h4><ul><li><strong>Shard Splitting</strong> (拆分分片)<ul><li>用于处理热点 Shard (Hot Shard), 将一个高流量 Shard 拆分为两个</li><li>增加 Stream 容量, 提升吞吐量</li><li>旧 Shard 关闭后数据仍可读取直到过期</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img205913.png"></p><ul><li><strong>Merging Shards</strong> (合并分片)<ul><li>将两个低流量 Shard 合并为一个</li><li>减少 Stream 容量, 降低成本</li><li>旧 Shard 关闭但数据保留至过期</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img210015.png"></p><hr><h4 id="Kinesis-Data-Firehose"><a href="#Kinesis-Data-Firehose" class="headerlink" title="Kinesis Data Firehose"></a>Kinesis Data Firehose</h4><ul><li>全托管服务, 将流式数据加载到数据存储和分析工具</li><li>Serverless, 自动扩展, 无需管理基础设施</li><li>支持数据转换 (Lambda 函数), 格式转换 (JSON → Parquet&#x2F;ORC), 压缩</li><li><strong>Near Real-Time</strong> 交付: 最小延迟 60 秒或当缓冲区达到 1MB (非实时, 考试需注意区分)</li><li>单一目标: 一个 Delivery Stream 只能写入一个目标 (S3, Redshift, OpenSearch, HTTP endpoint, Datadog 等)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img015040.png"></p><ul><li>支持的目标<ul><li>AWS: S3, Redshift (通过 S3 COPY), OpenSearch</li><li>第三方: Datadog, Splunk, New Relic, MongoDB</li><li>自定义: HTTP Endpoint</li><li><strong>不支持 DynamoDB</strong></li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img151812.png"></p><ul><li>Kinesis Data Streams vs Firehose<ul><li><strong>Data Streams</strong>: 实时 (200ms 延迟), 需要编写自定义 Consumer 代码, 数据保留 1-365 天, 支持 Replay</li><li><strong>Firehose</strong>: 近实时 (60s+ 延迟), 全托管无需编码, 无数据存储, 不支持 Replay, 直接写入目标</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img152247.png"></p><hr><h4 id="Kinesis-Data-Analytics"><a href="#Kinesis-Data-Analytics" class="headerlink" title="Kinesis Data Analytics"></a>Kinesis Data Analytics</h4><ul><li>对 Kinesis Data Streams 或 Firehose 中的流式数据进行实时分析</li><li>全托管, 自动扩展, Serverless</li><li>支持两种分析引擎<ul><li><strong>SQL 应用</strong>: 使用标准 SQL 查询实时数据流, 适合简单聚合、过滤、转换</li><li><strong>Apache Flink 应用</strong>: 使用 Java&#x2F;Scala&#x2F;Python 编写复杂流处理逻辑, 支持高级分析和机器学习</li></ul></li><li>输入源: Kinesis Data Streams, Kinesis Data Firehose</li><li>输出目标: Kinesis Data Streams, Kinesis Data Firehose, Lambda, S3</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img225813.png"></p><ul><li>Amazon Managed Service for Apache Flink<ul><li>使用 Apache Flink 处理和分析流式数据</li><li>适合复杂的实时 ETL, 事件驱动应用, 实时机器学习推理</li><li>自动管理集群, 快照和检查点, 支持精确一次 (Exactly-Once) 处理</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img225906.png"></p><hr><h4 id="Data-Ordering-for-Kinesis-vs-SQS"><a href="#Data-Ordering-for-Kinesis-vs-SQS" class="headerlink" title="Data Ordering for Kinesis vs SQS"></a>Data Ordering for Kinesis vs SQS</h4><ul><li><strong>Kinesis Data Streams 数据排序</strong><ul><li>相同 Partition Key 的数据始终路由到同一 Shard, 保证顺序</li><li>适用场景: 大规模数据流, 需要多个 Consumer 并行消费不同 Shard</li><li>每个 Shard 内严格有序, 不同 Shard 之间无序</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img154939.png"></p><ul><li><strong>SQS 数据排序</strong><ul><li>仅 SQS FIFO 队列支持排序, 使用 <code>MessageGroupID</code> 分组</li><li>相同 <code>MessageGroupID</code> 的消息严格有序, 不同 Group 可并行</li><li>适用场景: 需要动态数量的 Consumer, 无需 Shard 管理</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img210807.png"></p><hr><h3 id="18-AWS-Mointoring-amp-Audit"><a href="#18-AWS-Mointoring-amp-Audit" class="headerlink" title="18. AWS Mointoring &amp; Audit"></a>18. AWS Mointoring &amp; Audit</h3><h4 id="CloudWatch-Metrics"><a href="#CloudWatch-Metrics" class="headerlink" title="CloudWatch Metrics"></a>CloudWatch Metrics</h4><ul><li>收集、存储和可视化 AWS 资源及应用程序的性能指标</li><li>AWS 服务自动发布指标 (如 EC2 CPU, EBS IOPS, S3 请求数等)</li><li>使用 <code>PutMetricData</code> API 推送自定义指标到 CloudWatch</li><li>第三方 API 或应用程序监控必须使用 Custom Metrics</li><li>指标保留: 1 分钟数据点保留 15 天, 5 分钟数据点保留 63 天, 1 小时数据点保留 455 天</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img010357.png"></p><ul><li>CloudWatch - EC2 Detailed Monitoring<ul><li>默认监控: 5 分钟间隔, 免费</li><li>Detailed Monitoring: 1 分钟间隔, 额外收费; 适合需要快速响应的 Auto Scaling</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img033959.png"></p><hr><h4 id="CloudWatch-Custom-Metrics"><a href="#CloudWatch-Custom-Metrics" class="headerlink" title="CloudWatch Custom Metrics"></a>CloudWatch Custom Metrics</h4><ul><li>自定义指标用于监控 AWS 原生不支持的数据 (如应用级别指标, 内存使用率等)</li><li>使用 <code>PutMetricData</code> API 发送自定义指标</li><li>标准分辨率: 1 分钟; 高分辨率: 最低 1 秒 (需在 API 调用中指定 <code>StorageResolution</code>)</li><li>可接受过去 2 周和未来 2 小时内的数据点 (用于补发或时钟偏移场景)</li><li>支持添加 Dimensions (维度) 用于筛选和聚合</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img010630.png"></p><hr><h4 id="CloudWatch-Logs"><a href="#CloudWatch-Logs" class="headerlink" title="CloudWatch Logs"></a>CloudWatch Logs</h4><ul><li>集中存储和管理来自 AWS 服务和应用程序的日志</li><li>日志组织结构: Log Groups (日志组) → Log Streams (日志流)</li><li>日志保留策略在 Log Group 级别设置, 默认永久保留; 可设置 1 天 - 10 年</li><li>可导出到 S3 (批量归档), Kinesis Data Streams&#x2F;Firehose (实时流), Lambda (实时处理), OpenSearch (搜索分析)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img010815.png"></p><ul><li>CloudWatch Logs Insights<ul><li>强大的查询引擎, 使用类 SQL 语法搜索和分析日志</li><li>支持聚合、过滤、统计、可视化</li><li>按扫描的数据量计费</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img150531.png"></p><ul><li>CloudWatch Logs Subscriptions<ul><li>实时获取 CloudWatch Logs 中的日志事件进行处理和分析</li><li><strong>Subscription Filter</strong>: 过滤哪些日志事件传递到目标 (支持正则表达式)</li><li>目标: Kinesis Data Streams, Kinesis Data Firehose, Lambda</li><li><strong>Cross-Account Subscription</strong>: 跨账户发送日志到其他 AWS 账户的资源</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img150643.png"></p><hr><h4 id="CloudWatch-Agent"><a href="#CloudWatch-Agent" class="headerlink" title="CloudWatch Agent"></a>CloudWatch Agent</h4><ul><li><strong>CloudWatch Logs Agent</strong> (旧版): 仅支持发送日志到 CloudWatch Logs</li><li><strong>CloudWatch Unified Agent</strong> (推荐): 收集系统级指标和日志<ul><li>支持收集 EC2 和 On-Premises 服务器的 CPU, RAM, Disk, Netstat, Process 等指标</li><li>同时收集日志并发送到 CloudWatch Logs</li><li>配置通过 SSM Parameter Store 或本地文件管理</li></ul></li><li>可安装在 On-Premises 服务器上, 实现混合云监控</li><li>需要 IAM 角色&#x2F;权限允许 Agent 发送数据到 CloudWatch</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img151251.png"></p><hr><h4 id="CloudWatch-Logs-Metric-Filter"><a href="#CloudWatch-Logs-Metric-Filter" class="headerlink" title="CloudWatch Logs Metric Filter"></a>CloudWatch Logs Metric Filter</h4><ul><li>从日志数据中提取自定义指标, 监控特定事件和模式</li><li>使用模式匹配 (如正则表达式) 从日志中提取数值并转换为 CloudWatch Metric</li><li>常见用途: 统计错误次数, 监控特定 API 调用频率, 提取响应时间</li><li><strong>注意</strong>: Metric Filter 只处理创建后的日志事件, 不会回溯历史日志</li><li>提取的指标可用于 CloudWatch Alarms 触发告警</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img011918.png"></p><hr><h4 id="CloudWatch-Alarms"><a href="#CloudWatch-Alarms" class="headerlink" title="CloudWatch Alarms"></a>CloudWatch Alarms</h4><ul><li>基于任何 CloudWatch Metric 触发通知或自动化操作</li><li>Alarm States: OK (正常), ALARM (告警), INSUFFICIENT_DATA (数据不足)</li><li>触发目标: SNS Topic (通知), EC2 Actions (停止&#x2F;终止&#x2F;重启&#x2F;恢复), Auto Scaling Actions</li><li>评估周期: 标准指标最快 1 分钟, 高分辨率自定义指标最快 10 秒</li><li>支持多种统计方法: Average, Sum, Min, Max, Percentile</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img012137.png"></p><ul><li>Composite Alarms<ul><li>监控多个其他 Alarm 的状态, 使用 AND&#x2F;OR 逻辑组合</li><li>减少告警噪音: 仅当多个条件同时满足时触发</li><li>适合复杂的监控场景 (如应用的多层健康检查)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img151615.png"></p><ul><li>可使用 <code>set-alarm-state</code> CLI 手动测试 Alarm 行为, 无需等待真实告警触发, 节省成本</li></ul><hr><h4 id="CloudWatch-Synthetics"><a href="#CloudWatch-Synthetics" class="headerlink" title="CloudWatch Synthetics"></a>CloudWatch Synthetics</h4><ul><li>可配置的脚本 (Canary), 用于主动监控 API, URL, 网站可用性和性能</li><li>使用 Headless Chrome 浏览器模拟用户行为</li><li>脚本语言: Node.js (JavaScript) 或 Python</li><li>运行频率: 一次性或定期 (最频繁每 1 分钟)</li><li>自动捕获截图, HAR 文件, CloudWatch Metrics 和 Logs</li><li>适用场景: 端到端用户流程测试, 链接检查, API 可用性监控</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img012521.png"></p><hr><h4 id="AWS-EventBridge"><a href="#AWS-EventBridge" class="headerlink" title="AWS EventBridge"></a>AWS EventBridge</h4><ul><li>事件驱动架构的核心服务, 连接 AWS 服务, SaaS 应用和自定义应用</li><li><strong>Schedule</strong>: 定时触发 (Cron 表达式或 Rate 表达式), 替代 CloudWatch Events</li><li><strong>Event Pattern</strong>: 响应 AWS 服务事件 (如 EC2 状态变化, S3 上传) 或第三方 SaaS 应用事件</li><li>考试提示: 题目提到第三方应用集成 → 选择 EventBridge</li><li>目标: Lambda, SQS, SNS, Kinesis, Step Functions, ECS Task, 等</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img185605.png"></p><ul><li>Event Bus<ul><li><strong>Default Event Bus</strong>: 接收 AWS 服务事件</li><li><strong>Custom Event Bus</strong>: 接收自定义应用或第三方 SaaS 事件</li><li><strong>Partner Event Bus</strong>: 接收 SaaS 合作伙伴事件 (如 Datadog, Zendesk)</li><li>支持 Archive 和 Replay 事件, 适合调试和灾难恢复</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img190403.png"></p><ul><li>Schema Registry<ul><li>自动发现和记录 Event Bus 中的事件结构</li><li>为事件生成代码绑定 (Java, Python, TypeScript), 简化开发</li><li>支持版本管理和 Schema 演进</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img190004.png"></p><ul><li>Resource-based Policy<ul><li>管理特定 Event Bus 的权限 (允许&#x2F;拒绝跨账户访问)</li><li>用于跨账户事件聚合或多区域事件路由</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img190215.png"></p><hr><h4 id="AWS-X-Ray"><a href="#AWS-X-Ray" class="headerlink" title="AWS X-Ray"></a>AWS X-Ray</h4><ul><li>分布式跟踪系统, 用于分析和调试微服务架构的性能问题</li><li><strong>自动化跟踪分析</strong>: 识别性能瓶颈, 延迟热点, 错误根因</li><li><strong>服务地图可视化</strong>: 显示服务依赖关系和调用流程</li><li>支持跨账户跟踪和可视化</li><li>考试提示: 检查微服务 5XX 错误或性能问题 → 选择 X-Ray (而非 CloudTrail)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img020641.png"></p><ul><li>如何启用 X-Ray<ul><li><strong>方法 1</strong>: 在代码中导入 AWS X-Ray SDK, 对请求进行插桩 (Instrumentation)</li><li><strong>方法 2</strong>: 安装 X-Ray Daemon (EC2&#x2F;On-Premises) 或启用 AWS 集成 (Lambda&#x2F;Elastic Beanstalk)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img021009.png"></p><ul><li>X-Ray 故障排查<ul><li><strong>EC2</strong>: 确保 IAM Role 有 <code>AWSXRayDaemonWriteAccess</code> 权限 + 实例运行 X-Ray Daemon</li><li><strong>Lambda</strong>: IAM Role 附加 <code>AWSXRayWriteOnlyAccess</code> + 启用 Active Tracing</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img021323.png"></p><ul><li>ECS &#x2F; Fargate 上运行 X-Ray Daemon<ul><li>将 X-Ray Daemon 作为 Sidecar 容器部署</li><li>为 X-Ray 容器提供正确的 IAM Task Role</li><li>使用环境变量 <code>AWS_XRAY_DAEMON_ADDRESS</code> 配置应用连接到 Daemon</li></ul></li></ul><hr><h4 id="X-Ray-Advanced"><a href="#X-Ray-Advanced" class="headerlink" title="X-Ray Advanced"></a>X-Ray Advanced</h4><ul><li><strong>Instrumentation</strong> (插桩)<ul><li>在应用代码中测量性能并写入跟踪信息</li><li>SDK 自动记录传入&#x2F;传出请求, 数据库调用, HTTP 调用, 队列消息等</li><li>手动插桩可添加自定义 Subsegments 和 Annotations</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img021538.png"></p><ul><li>X-Ray 核心概念<ul><li><strong>Sampling (采样)</strong>: 控制记录的请求数量, 降低成本; 默认每秒第一个请求 + 额外请求的 5%</li><li><strong>Annotations (注释)</strong>: 键值对, 可索引和过滤; 用于自定义筛选条件 (如 <code>user_id</code>, <code>game_id</code>)</li><li><strong>Metadata (元数据)</strong>: 键值对, 不可索引; 用于存储附加信息</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img021924.png"></p><ul><li>X-Ray Sampling Rules<ul><li>控制记录数据的数量, 平衡成本和可见性</li><li>默认规则: 每秒第一个请求 (Reservoir) + 额外请求的 5% (Rate)</li><li>可自定义规则: 基于服务名称, HTTP 方法, URL 路径等条件设置不同采样率</li><li>考试重点: 每秒第一个请求 + 额外请求 5%</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img022256.png"></p><hr><h4 id="X-Ray-APIs"><a href="#X-Ray-APIs" class="headerlink" title="X-Ray APIs"></a>X-Ray APIs</h4><ul><li><strong>X-Ray Write APIs</strong> (写入跟踪数据)<ul><li><code>PutTraceSegments</code>: 上传 Segment 文档到 X-Ray</li><li><code>PutTelemetryRecords</code>: X-Ray Daemon 使用, 上传遥测数据 (SegmentsSentCount, BacklogSize 等)</li><li><code>GetSamplingRules</code>: 获取所有采样规则 (Daemon 定期调用以更新采样策略)</li><li><code>GetSamplingTargets</code>: 获取采样目标 (用于动态调整采样率)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img022650.png"></p><ul><li><strong>X-Ray Read APIs</strong> (查询跟踪数据, 全部以 <code>Get</code> 或 <code>Batch</code> 开头)<ul><li><code>GetServiceGraph</code>: 获取服务依赖关系图</li><li><code>BatchGetTraces</code>: 根据 Trace ID 列表批量获取完整跟踪数据</li><li><code>GetTraceSummaries</code>: 获取时间范围内的 Trace ID 和摘要信息 (可基于 Annotations 过滤)</li><li><code>GetTraceGraph</code>: 获取一个或多个 Trace ID 的服务调用图</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img022934.png"></p><hr><h4 id="X-Ray-with-Elastic-Beanstalk"><a href="#X-Ray-with-Elastic-Beanstalk" class="headerlink" title="X-Ray with Elastic Beanstalk"></a>X-Ray with Elastic Beanstalk</h4><ul><li>Elastic Beanstalk 原生支持 X-Ray 集成</li><li>启用方式<ul><li><strong>方法 1</strong>: Beanstalk Console 中启用 X-Ray Daemon</li><li><strong>方法 2</strong>: 在 <code>.ebextensions/xray-daemon.config</code> 配置文件中启用</li></ul></li><li>自动为应用配置 IAM 权限 (<code>AWSXRayDaemonWriteAccess</code>)</li><li>应用代码中导入 X-Ray SDK 并进行插桩</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img023148.png"></p><hr><h4 id="AWS-Distro-for-OpenTelemetry"><a href="#AWS-Distro-for-OpenTelemetry" class="headerlink" title="AWS Distro for OpenTelemetry"></a>AWS Distro for OpenTelemetry</h4><ul><li>AWS 支持的开源项目 OpenTelemetry 发行版</li><li>提供统一的可观测性数据采集 (Traces, Metrics, Logs)</li><li>支持多种后端: X-Ray, CloudWatch, Prometheus, 第三方工具</li><li>与 X-Ray SDK 相比, 更开放, 避免供应商锁定</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img023636.png"></p><hr><h4 id="AWS-CloudTrail"><a href="#AWS-CloudTrail" class="headerlink" title="AWS CloudTrail"></a>AWS CloudTrail</h4><ul><li>审计和合规服务, 记录 AWS 账户中的所有 API 调用和相关活动</li><li>全局服务, 覆盖所有区域; 资源被误删或配置变更时首选工具</li><li>可与 EventBridge 集成, 实时拦截和响应特定 API 调用</li><li>日志可发送到 S3 (长期存储), CloudWatch Logs (实时监控和告警)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img023929.png"></p><ul><li>CloudTrail Events 类型<ul><li><strong>Management Events</strong>: 资源管理操作 (创建&#x2F;删除 EC2, 创建 VPC 等), 默认记录</li><li><strong>Data Events</strong>: 数据层面操作 (S3 对象级别活动, Lambda 函数调用), 默认不记录, 高频</li><li><strong>Insights Events</strong>: 检测异常活动 (如突发 API 调用激增), 需手动启用</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img023847.png"></p><ul><li>CloudTrail Insights<ul><li>自动检测账户中的异常活动 (如 API 调用率突增, 异常权限变更)</li><li>使用机器学习分析基线行为, 生成 Insights 事件</li><li>发送到 S3, CloudWatch Events, 用于安全响应</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img192157.png"></p><ul><li>CloudTrail Event Retention<ul><li>默认保留 90 天, 之后自动删除</li><li>长期保留: 将日志发送到 S3 bucket, 使用 Athena 查询分析历史日志</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img163847.png"></p><hr><h3 id="19-Lambda"><a href="#19-Lambda" class="headerlink" title="19. Lambda"></a>19. Lambda</h3><h4 id="AWS-Lambda"><a href="#AWS-Lambda" class="headerlink" title="AWS Lambda"></a>AWS Lambda</h4><ul><li>Serverless 计算服务, 运行代码无需管理服务器</li><li>执行时间限制: 最长 15 分钟; 按需运行, 自动扩展</li><li>触发方式: 事件驱动 (S3, DynamoDB, SQS 等) 或定时任务 (EventBridge CRON)</li><li>Account Limits<ul><li>并发执行数: 1000 (默认, 可申请提升)</li><li>环境变量: 单个变量最大 4 KB, 总大小无限制</li><li>部署包: 50 MB (zip 直接上传), 250 MB (解压后), 无限制 (通过 S3)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img162057.png"></p><ul><li>可连接 VPC 内的 Private Subnets, 访问 RDS, ElastiCache 等私有资源</li><li>提升 CPU 性能: 增加内存分配 (CPU 与内存成比例), 考试常见考点</li><li>加速冷启动: 使用 Provisioned Concurrency (预热实例); API Gateway Caching 仅减少调用次数</li></ul><hr><h4 id="Lambda-Synchronous-Invocations"><a href="#Lambda-Synchronous-Invocations" class="headerlink" title="Lambda Synchronous Invocations"></a>Lambda Synchronous Invocations</h4><ul><li><strong>同步调用</strong>: 调用者等待 Lambda 执行完成并返回结果</li><li>触发源: CLI, SDK, API Gateway, Application Load Balancer</li><li>特点<ul><li>结果立即返回 (成功或错误)</li><li>错误处理由客户端负责 (需实现重试逻辑)</li><li>调用者阻塞直到函数返回或超时</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img164039.png"></p><hr><h4 id="Lambda-with-ALB"><a href="#Lambda-with-ALB" class="headerlink" title="Lambda with ALB"></a>Lambda with ALB</h4><ul><li>通过 ALB 将 Lambda 函数暴露为 HTTP(S) 端点</li><li>Lambda 必须注册到 ALB 的 Target Group</li><li>ALB 将 HTTP 请求转换为 Lambda 事件, Lambda 响应转换为 HTTP 响应</li><li>适用场景: 无需 API Gateway 的简单 HTTP 服务, 与现有 ALB 集成</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img163555.png"></p><ul><li>ALB Multi-Header Values<ul><li>ALB 支持多值 HTTP Headers 和 Query String Parameters</li><li>以数组形式传递给 Lambda (需在 Target Group 启用 <code>lambda.multi_value_headers.enabled</code>)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img163757.png"></p><hr><h4 id="Lambda-Asynchronous-Invocations"><a href="#Lambda-Asynchronous-Invocations" class="headerlink" title="Lambda Asynchronous Invocations"></a>Lambda Asynchronous Invocations</h4><ul><li><strong>异步调用</strong>: 调用者不等待 Lambda 执行结果, 立即返回</li><li>触发源: S3, SNS, CloudWatch Events, EventBridge, SES</li><li>特点<ul><li>事件放入 Lambda 内部 Event Queue, Lambda 从队列读取并处理</li><li>失败自动重试: 最多 3 次 (首次 + 2 次重试), 重试间隔 1 分钟 → 2 分钟</li><li>可配置 DLQ (Dead Letter Queue, SQS 或 SNS) 处理失败事件</li><li>可配置 Destination (成功&#x2F;失败事件发送到 SQS, SNS, Lambda, EventBridge)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img164249.png"></p><hr><h4 id="Lambda-Event-Source-Mapping"><a href="#Lambda-Event-Source-Mapping" class="headerlink" title="Lambda Event Source Mapping"></a>Lambda Event Source Mapping</h4><ul><li>用于从流式数据源或队列中批量读取数据并调用 Lambda</li><li>支持的数据源: Kinesis Data Streams, DynamoDB Streams, SQS (Standard &amp; FIFO)</li><li>Lambda <strong>同步调用</strong> (不支持异步触发源如 SNS)</li><li>Event Source Mapping 由 Lambda 服务管理, 自动轮询数据源</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img165403.png"></p><ul><li>Streams &amp; Lambda (Kinesis &amp; DynamoDB)<ul><li>Event Source Mapping 为每个 Shard 创建一个迭代器, 按顺序处理记录</li><li>低流量: 使用 Batch Window (等待时间) 累积批量记录</li><li>高流量: 单个 Shard 可并行处理多个批次 (最多 10 个并发批次)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img165631.png"></p><ul><li>Streams &amp; Lambda 错误处理<ul><li>默认: 函数返回错误时, 整个批次重新处理直到成功或记录过期</li><li>配置: 可设置 <code>BisectBatchOnFunctionError</code> (失败时拆分批次), <code>MaximumRetryAttempts</code>, <code>MaximumRecordAgeInSeconds</code></li><li>失败记录可发送到 Destination (SQS, SNS)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img165758.png"></p><ul><li>Queue &amp; Lambda (SQS &amp; SQS FIFO)<ul><li>Event Source Mapping 使用 Long Polling 轮询 SQS</li><li>Standard Queue: 最多 1000 个并发 Lambda 实例</li><li>FIFO Queue: Lambda 扩展到活动 Message Group 数量 (相同 Group 串行处理)</li><li>删除消息: Lambda 成功处理后自动从队列删除; 失败则消息回到队列 (基于 Visibility Timeout)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img165931.png"></p><hr><h4 id="Lambda-Event-and-Context-Objects"><a href="#Lambda-Event-and-Context-Objects" class="headerlink" title="Lambda Event and Context Objects"></a>Lambda Event and Context Objects</h4><ul><li>Lambda 函数入口 <code>lambda_handler(event, context)</code> 的两个参数</li><li><strong><code>event</code></strong>: JSON 文档, 包含触发 Lambda 的数据<ul><li>内容取决于触发源 (S3 事件, API Gateway 请求, SQS 消息等)</li></ul></li><li><strong><code>context</code></strong>: 提供运行时信息<ul><li><code>context.aws_request_id</code>: 请求 ID</li><li><code>context.function_name</code>, <code>context.memory_limit_in_mb</code>, <code>context.log_group_name</code></li><li><code>context.get_remaining_time_in_millis()</code>: 剩余执行时间</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img170535.png"></p><hr><h4 id="Lambda-Destinations"><a href="#Lambda-Destinations" class="headerlink" title="Lambda Destinations"></a>Lambda Destinations</h4><ul><li>配置 Lambda 执行结果的目标, 替代 DLQ 并提供更多功能</li><li><strong>异步调用</strong>: 为成功和失败事件分别定义目标 (SQS, SNS, Lambda, EventBridge)</li><li><strong>Event Source Mapping</strong>: 为丢弃的事件批次定义目标 (处理失败后的记录)</li><li>推荐使用 Destinations 而非 DLQ: 支持成功事件, 更详细的上下文信息</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img170912.png"></p><hr><h4 id="Lambda-Permissions"><a href="#Lambda-Permissions" class="headerlink" title="Lambda Permissions"></a>Lambda Permissions</h4><ul><li><strong>Lambda Execution Role</strong> (IAM Role)<ul><li>授予 Lambda 访问其他 AWS 服务的权限 (如 S3, DynamoDB, CloudWatch Logs)</li><li>考试重点: 大部分 Lambda 权限问题与 Execution Role 相关</li><li>最佳实践: 每个函数使用独立的 Execution Role, 遵循最小权限原则</li><li>常用托管策略: <code>AWSLambdaBasicExecutionRole</code> (CloudWatch Logs), <code>AWSLambdaVPCAccessExecutionRole</code> (VPC 访问)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img171158.png"></p><ul><li><strong>Lambda Resource-Based Policies</strong><ul><li>控制谁可以调用 Lambda 函数 (其他 AWS 账户, AWS 服务)</li><li>与 Execution Role 不同: Execution Role 控制 Lambda 访问外部资源, Resource Policy 控制外部访问 Lambda</li><li>常用场景: 允许 S3, API Gateway, EventBridge 调用 Lambda, 跨账户访问</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img171329.png"></p><hr><h4 id="Lambda-Environment-Variables"><a href="#Lambda-Environment-Variables" class="headerlink" title="Lambda Environment Variables"></a>Lambda Environment Variables</h4><ul><li>键值对形式, 注入动态配置到 Lambda 函数 (无需修改代码)</li><li>适用场景: 数据库连接字符串, API 端点, 功能开关</li><li>安全存储敏感数据: 使用 KMS 加密环境变量 (如 API Keys, Secrets)</li><li>限制: 单个变量最大 4 KB, 所有变量总大小最大 4 KB</li><li>注意: 短期 Token 或频繁变化的密钥不适合环境变量, 应使用 Secrets Manager 或 Parameter Store</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img173203.png"></p><hr><h4 id="Lambda-Logging-amp-Monitoring"><a href="#Lambda-Logging-amp-Monitoring" class="headerlink" title="Lambda Logging &amp; Monitoring"></a>Lambda Logging &amp; Monitoring</h4><ul><li><strong>日志</strong>: Lambda 执行日志自动存储到 CloudWatch Logs (需 Execution Role 有写权限)</li><li><strong>指标</strong>: CloudWatch Metrics 自动收集 Lambda 指标<ul><li>Invocations (调用次数), Duration (执行时间), Errors (错误次数), Throttles (限流次数)</li><li>ConcurrentExecutions (并发执行数), DeadLetterErrors (DLQ 错误)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img173409.png"></p><ul><li>Lambda Tracing with X-Ray<ul><li>在 Lambda 配置中启用 Active Tracing</li><li>自动记录 AWS SDK 调用, HTTP 请求, 数据库查询</li><li>需 Execution Role 有 <code>AWSXRayWriteOnlyAccess</code> 权限</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img173520.png"></p><hr><h4 id="CloudFront-Functions-amp-Lambda-Edge"><a href="#CloudFront-Functions-amp-Lambda-Edge" class="headerlink" title="CloudFront Functions &amp; Lambda@Edge"></a>CloudFront Functions &amp; Lambda@Edge</h4><ul><li>在 CloudFront 边缘位置运行代码, 实现低延迟自定义逻辑</li><li>两种选择: CloudFront Functions (轻量级), Lambda@Edge (功能强大)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img173715.png"></p><ul><li><strong>CloudFront Functions</strong><ul><li>超大规模, 低延迟场景 (百万级请求&#x2F;秒)</li><li>仅支持 Viewer Request 和 Viewer Response</li><li>运行时: JavaScript, 执行时间 &lt; 1 ms, 内存 2 MB</li><li>适用: URL 重写, Header 修改, 简单认证, Cache Key 规范化</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img173900.png"></p><ul><li><strong>Lambda@Edge</strong><ul><li>中等规模 (千级请求&#x2F;秒)</li><li>支持所有 CloudFront 事件: Viewer Request, Origin Request, Origin Response, Viewer Response</li><li>运行时: Node.js, Python; 执行时间最长 5-10 秒, 内存最大 10 GB</li><li>适用: 复杂逻辑, 访问外部资源 (如 S3, DynamoDB), 动态内容生成</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img214545.png"></p><hr><h4 id="Lambda-in-VPC"><a href="#Lambda-in-VPC" class="headerlink" title="Lambda in VPC"></a>Lambda in VPC</h4><ul><li>默认 Lambda 运行在 AWS 管理的 VPC, 无法访问用户 VPC 内的资源 (如 RDS, ElastiCache)</li><li>配置 Lambda in VPC: 指定 VPC ID, Subnets, Security Groups</li><li>Lambda 在每个 Subnet 创建 ENI (Elastic Network Interface), 通过 ENI 访问 VPC 资源</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img174359.png"></p><ul><li>Lambda in VPC - Internet Access<ul><li>VPC 内的 Lambda 默认无互联网访问</li><li><strong>错误做法</strong>: 部署在 Public Subnet (Lambda 无公网 IP, 无法访问互联网)</li><li><strong>正确做法 1</strong>: 部署在 Private Subnet + NAT Gateway&#x2F;Instance</li><li><strong>正确做法 2</strong>: 使用 VPC Endpoints 访问 AWS 服务 (S3, DynamoDB 等), 无需 NAT</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img174704.png"></p><hr><h4 id="Lambda-Function-Performance"><a href="#Lambda-Function-Performance" class="headerlink" title="Lambda Function Performance"></a>Lambda Function Performance</h4><ul><li><strong>内存配置 (RAM)</strong><ul><li>范围 128 MB - 10240 MB (10 GB), 以 1 MB 递增</li><li>CPU 与内存成正比: 增加内存同时提升 CPU 性能</li><li>CPU 密集型任务: 增加内存是提升性能的主要方法</li></ul></li><li><strong>超时配置 (Timeout)</strong><ul><li>默认 3 秒, 最长 900 秒 (15 分钟)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img174946.png"></p><ul><li><strong>Lambda Execution Context</strong><ul><li>临时运行环境, 初始化外部依赖 (数据库连接, SDK 客户端等)</li><li>在多次调用间可重用, 加速后续调用 (避免冷启动)</li><li>包含 <code>/tmp</code> 目录: 默认 512 MB, 最大 10240 MB (10 GB)</li><li><code>/tmp</code> 适用: 临时文件存储, 缓存数据, 大文件处理</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img175158.png"></p><ul><li><strong>最佳实践: 在 Handler 外部初始化</strong><ul><li>数据库连接, SDK 客户端在 handler 函数外部初始化</li><li>Execution Context 重用时避免重复初始化, 减少延迟</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img175513.png"></p><hr><h4 id="Lambda-Layers"><a href="#Lambda-Layers" class="headerlink" title="Lambda Layers"></a>Lambda Layers</h4><ul><li>创建可重用的代码库和依赖包, 多个 Lambda 函数共享</li><li>用途: 自定义运行时, 共享库 (如 NumPy, Pandas), 公共代码模块</li><li>单个函数最多 5 个 Layers, 总解压大小不超过 250 MB</li><li>减少部署包大小, 分离代码和依赖, 便于版本管理</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img192245.png"></p><hr><h4 id="Lambda-File-Systems-Mounting"><a href="#Lambda-File-Systems-Mounting" class="headerlink" title="Lambda File Systems Mounting"></a>Lambda File Systems Mounting</h4><ul><li>Lambda 可挂载 EFS 文件系统 (需 Lambda in VPC)</li><li>适用场景: 大文件处理 (超过 <code>/tmp</code> 限制), 跨函数共享数据, 持久化存储</li><li>配置: 使用 EFS Access Points, 指定挂载路径 (如 <code>/mnt/efs</code>)</li><li>性能: EFS 提供低延迟持久化存储, 支持并发访问</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img192513.png"></p><hr><h4 id="Lambda-Concurrency"><a href="#Lambda-Concurrency" class="headerlink" title="Lambda Concurrency"></a>Lambda Concurrency</h4><ul><li><strong>并发执行数</strong>: 同时处理的请求数量</li><li><strong>Account Limit</strong>: 默认 1000 (区域级别), 可通过工单提升</li><li><strong>Reserved Concurrency</strong>: 为特定函数保留并发数, 防止其他函数占用; 超出限制触发 <code>Throttle</code> 错误</li><li><strong>Unreserved Concurrency</strong>: 账户剩余并发数, 所有未设置 Reserved Concurrency 的函数共享</li><li>异步调用 Throttle 处理: 事件返回内部队列, 自动重试 (最多 6 小时)</li><li>同步调用 Throttle 处理: 返回 429 错误, 客户端需实现重试</li><li>考试提示: 超出并发限制 → 配置 Reserved Concurrency</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img193032.png"></p><ul><li><strong>Cold Start &amp; Provisioned Concurrency</strong><ul><li><strong>Cold Start</strong>: 新实例首次请求需初始化环境 (下载代码, 初始化运行时), 延迟 100ms - 数秒</li><li><strong>Provisioned Concurrency</strong>: 预先初始化指定数量的实例, 保持热状态</li><li>适用场景: 延迟敏感应用, 流量高峰期 (如促销活动), 可配置 Auto Scaling 按计划调整</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img224130.png"></p><hr><h4 id="Lambda-External-Dependencies"><a href="#Lambda-External-Dependencies" class="headerlink" title="Lambda External Dependencies"></a>Lambda External Dependencies</h4><ul><li>Lambda 函数依赖外部库 (如 NumPy, Pandas, SDK) 时, 需要打包到部署包</li><li>步骤<ol><li>本地安装依赖: <code>pip install -t . &lt;package&gt;</code></li><li>与函数代码一起打包为 <code>.zip</code> 文件</li><li>上传到 Lambda (直接上传或通过 S3)</li></ol></li><li>注意: 函数代码和依赖必须在同一个 <code>.zip</code> 文件中, 保持正确的目录结构</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img224459.png"></p><hr><h4 id="Lambda-Container-Image"><a href="#Lambda-Container-Image" class="headerlink" title="Lambda Container Image"></a>Lambda Container Image</h4><ul><li>使用容器镜像部署 Lambda 函数 (支持 Docker 工作流)</li><li>适用场景: 复杂依赖, 大型依赖 (镜像最大 10 GB), 自定义运行时</li><li>要求: 容器镜像必须实现 Lambda Runtime API</li><li>限制: 不支持多架构容器镜像 (如同时支持 x86 和 ARM)</li><li>镜像存储在 Amazon ECR (Elastic Container Registry)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img000324.png"></p><hr><h4 id="Lambda-Versions-and-Aliases"><a href="#Lambda-Versions-and-Aliases" class="headerlink" title="Lambda Versions and Aliases"></a>Lambda Versions and Aliases</h4><ul><li><strong>Lambda Versions</strong><ul><li><code>$LATEST</code>: 可编辑的工作版本</li><li><strong>发布版本</strong>: 不可变的快照, 有独立 ARN, 递增版本号 (v1, v2, v3…)</li><li>每个版本有独立配置和代码</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img000644.png"></p><ul><li><strong>Lambda Aliases</strong><ul><li>指向特定版本的指针 (如 <code>dev</code> → v1, <code>prod</code> → v2)</li><li>支持流量加权: 金丝雀部署, 按百分比分配流量到不同版本</li><li>限制: Alias 不能指向另一个 Alias</li><li>好处: 客户端使用稳定的 Alias ARN, 无需更改代码即可切换版本</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img000912.png"></p><hr><h4 id="Lambda-with-CodeDeploy"><a href="#Lambda-with-CodeDeploy" class="headerlink" title="Lambda with CodeDeploy"></a>Lambda with CodeDeploy</h4><ul><li>CodeDeploy 自动化 Lambda Alias 的流量切换, 支持安全部署</li><li>部署策略<ul><li><strong>Linear</strong>: 线性增长, 每 N 分钟增加固定百分比流量 (如 <code>Linear10PercentEvery10Minutes</code>)</li><li><strong>Canary</strong>: 先测试少量流量, 成功后切换全部 (如 <code>Canary10Percent5Minutes</code>: 10% 测试 5 分钟, 然后 100%)</li><li><strong>AllAtOnce</strong>: 立即切换全部流量</li></ul></li><li>支持自动回滚: CloudWatch Alarms 触发时回滚到旧版本</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img001338.png"></p><hr><h4 id="Lambda-Function-URL"><a href="#Lambda-Function-URL" class="headerlink" title="Lambda Function URL"></a>Lambda Function URL</h4><ul><li>为 Lambda 函数提供专用的 HTTPS 端点, 无需 API Gateway</li><li>URL 格式: <code>https://&lt;url-id&gt;.lambda-url.&lt;region&gt;.on.aws</code></li><li>支持 CORS 配置, IAM 或公开访问控制</li><li>适用场景: 简单的 HTTP 端点, Webhook, 无需 API Gateway 高级功能 (限流, API Key 等)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img001532.png"></p><hr><h4 id="Lambda-with-CodeGuru"><a href="#Lambda-with-CodeGuru" class="headerlink" title="Lambda with CodeGuru"></a>Lambda with CodeGuru</h4><ul><li>CodeGuru Profiler 分析 Lambda 函数运行时性能</li><li>自动为 Lambda 函数创建 Profiler Group</li><li>识别性能瓶颈 (CPU 密集代码, 内存泄漏, 低效算法)</li><li>提供优化建议和成本节省机会</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img001843.png"></p><hr><h3 id="20-DynamoDB"><a href="#20-DynamoDB" class="headerlink" title="20. DynamoDB"></a>20. DynamoDB</h3><h4 id="AWS-DynamoDB"><a href="#AWS-DynamoDB" class="headerlink" title="AWS DynamoDB"></a>AWS DynamoDB</h4><ul><li>全托管 NoSQL 数据库, 跨多个 AZ 自动复制, 自动扩展, 无需预配服务器</li><li><strong>Table Class</strong><ul><li><strong>Standard</strong>: 默认, 适合频繁访问的数据</li><li><strong>Infrequent Access (IA)</strong>: 降低存储成本, 适合不常访问的数据</li></ul></li><li><strong>加密</strong>: 默认使用 AWS Owned Key 加密, 可选 AWS Managed Key 或 Customer Managed Key</li><li><strong>权限控制</strong>: 不支持 Resource-based Policy, 必须使用 IAM Role + AssumeRole (跨账户访问)</li><li>考试提示<ul><li>DynamoDB + Email 处理 → DynamoDB Streams</li><li>不可预测的流量 → On-Demand Capacity Mode</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img012414.png"></p><ul><li><strong>Primary Key</strong> (创建时必须定义, 不可更改)<ul><li><strong>Partition Key (HASH)</strong>: 单一主键, 每个 Item 的 Partition Key 必须唯一</li><li><strong>Partition Key + Sort Key (HASH + RANGE)</strong>: 复合主键, 组合必须唯一; Partition Key 相同时, Sort Key 可用于排序和范围查询</li></ul></li><li><strong>Item 大小限制</strong>: 最大 400 KB (包括属性名和值)<ul><li>不适合存储图片、文件等大对象; 应存储在 S3, DynamoDB 保存 S3 对象引用</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img012627.png"></p><ul><li><strong>Backup 方法</strong><ul><li><strong>On-Demand Backup</strong>: 手动创建完整备份到 S3</li><li><strong>Point-in-Time Recovery (PITR)</strong>: 持续备份, 恢复到过去 35 天内任意秒级时间点</li><li>注意: Backup 存储在 S3, 但无法直接访问 S3 Buckets, 只能通过 DynamoDB 恢复</li></ul></li><li><strong>只读访问</strong>: 使用 IAM 托管策略 <code>AmazonDynamoDBReadOnlyAccess</code></li><li><strong>降低延迟方法</strong><ul><li>使用 <strong>Global Tables</strong> (多区域复制), 适合全球分布的用户</li><li>使用 <strong>Eventually Consistent Reads</strong> 替代 Strongly Consistent Reads (延迟更低, 成本更低)</li></ul></li></ul><hr><h4 id="DynamoDB-WCU-amp-RCU"><a href="#DynamoDB-WCU-amp-RCU" class="headerlink" title="DynamoDB WCU &amp; RCU"></a>DynamoDB WCU &amp; RCU</h4><ul><li><strong>Read&#x2F;Write Capacity Mode</strong><ul><li><strong>Provisioned Mode</strong> (默认): 手动设置 RCU 和 WCU, 支持 Auto Scaling; 适合可预测的流量</li><li><strong>On-Demand Mode</strong>: 按实际使用量付费, 自动扩展; 适合不可预测或间歇性流量</li></ul></li><li>RCU 和 WCU 独立配置, 可单独调整</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img014420.png"></p><ul><li><strong>Provisioned Mode</strong><ul><li><strong>RCU (Read Capacity Units)</strong>: 读取吞吐量</li><li><strong>WCU (Write Capacity Units)</strong>: 写入吞吐量</li><li><strong>Burst Capacity</strong>: 短时间内可超出预配容量 (使用未消耗的容量积累)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img014716.png"></p><ul><li><strong>Write Capacity Units (WCU) 计算</strong><ul><li><strong>1 WCU</strong> &#x3D; 每秒 1 次写入, Item 大小最多 1 KB</li><li>Item 大小向上取整到 1 KB 的倍数</li><li>公式: <code>总写入次数/秒 × (Item 大小 KB / 1 KB 向上取整)</code></li><li>例子: 每秒 6 次写入, Item 大小 4.5 KB → <code>6 × 5 = 30 WCU</code></li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img014951.png"></p><ul><li><strong>Strongly Consistent Read vs. Eventually Consistent Read</strong><ul><li><strong>Eventually Consistent Read</strong> (默认): 可能读到旧数据 (复制延迟), 消耗 RCU 较少</li><li><strong>Strongly Consistent Read</strong>: 保证读到最新数据, 消耗 RCU 2 倍</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img015146.png"></p><ul><li><strong>Read Capacity Units (RCU) 计算</strong><ul><li><strong>1 RCU</strong> &#x3D; 每秒 1 次 Strongly Consistent Read 或 2 次 Eventually Consistent Read, Item 大小最多 4 KB</li><li>Item 大小向上取整到 4 KB 的倍数</li><li><strong>Strongly Consistent Read</strong>: <code>总读取次数/秒 × (Item 大小 KB / 4 KB 向上取整)</code></li><li><strong>Eventually Consistent Read</strong>: <code>总读取次数/秒 / 2 × (Item 大小 KB / 4 KB 向上取整)</code></li><li>例子 1: 每秒 10 次 Strongly Consistent Read, Item 4 KB → <code>10 × 1 = 10 RCU</code></li><li>例子 2: 每秒 16 次 Eventually Consistent Read, Item 12 KB → <code>(16 / 2) × 3 = 24 RCU</code></li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img015532.png"></p><ul><li><strong>DynamoDB Partitions Internal</strong><ul><li>数据存储在分区中, Partition Key 决定数据所在分区</li><li>WCU 和 RCU 均匀分布到所有分区</li><li>分区数量由数据大小和预配容量决定</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img015726.png"></p><ul><li><strong>DynamoDB Throttling</strong><ul><li>超出预配 RCU 或 WCU → <code>ProvisionedThroughputExceededException</code></li><li>原因: Hot Keys (某个 Partition Key 访问过多), Hot Partitions, 超大 Item</li><li>解决方案<ul><li>使用 Exponential Backoff 重试</li><li>分散 Partition Key (避免集中访问)</li><li>增加 RCU&#x2F;WCU 或使用 On-Demand Mode</li><li>使用 DynamoDB Accelerator (DAX) 缓存</li></ul></li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img015936.png"></p><ul><li><strong>On-Demand Mode</strong><ul><li>读&#x2F;写自动扩展, 无需预配容量</li><li><strong>RRU (Read Request Units)</strong>: 等同于 RCU 计算方式</li><li><strong>WRU (Write Request Units)</strong>: 等同于 WCU 计算方式</li><li>按实际请求数量计费, 适合流量不可预测的应用</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img020318.png"></p><hr><h4 id="DynamoDB-Basic-Operations"><a href="#DynamoDB-Basic-Operations" class="headerlink" title="DynamoDB Basic Operations"></a>DynamoDB Basic Operations</h4><ul><li><strong>Writing Data</strong><ul><li><code>PutItem</code>: 创建新 Item 或完全替换已有 Item (覆盖所有属性)</li><li><code>UpdateItem</code>: 更新已有 Item 的属性, 或创建新 Item (如果不存在); 只修改指定属性, 保留其他属性</li><li><code>Conditional Writes</code>: 仅在满足条件时执行写入&#x2F;更新&#x2F;删除 (如 <code>attribute_exists</code>, <code>attribute_not_exists</code>)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img020700.png"></p><ul><li><strong>Reading Data</strong><ul><li><code>GetItem</code>: 根据 Primary Key 读取单个 Item</li><li><code>Query</code>: 基于 Partition Key (必须) + Sort Key (可选) 查询; 支持 <code>KeyConditionExpression</code>, <code>FilterExpression</code>; 高效, 返回结果有序</li><li><code>Scan</code>: 扫描整个表并过滤数据; 低效, 消耗大量 RCU; 支持并行扫描 (Parallel Scan) 提升速度</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img020844.png"></p><ul><li><strong>Deleting Data</strong><ul><li><code>DeleteItem</code>: 删除单个 Item (根据 Primary Key)</li><li><code>DeleteTable</code>: 删除整个表及所有 Item</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img021027.png"></p><ul><li><strong>Batch Operations</strong><ul><li><code>BatchWriteItem</code>: 批量写入&#x2F;删除最多 25 个 Item, 减少 API 调用次数和延迟</li><li><code>BatchGetItem</code>: 批量读取最多 100 个 Item (最多 16 MB)</li><li>批量操作部分失败时返回未处理项, 需客户端重试</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img021208.png"></p><ul><li><strong>Table Cleanup 方法</strong><ul><li><strong>方法 1</strong>: <code>Scan</code> + <code>DeleteItem</code> (逐个删除, 慢且消耗 RCU&#x2F;WCU)</li><li><strong>方法 2</strong>: <code>DeleteTable</code> + <code>CreateTable</code> (快速清空, 重新创建表)</li></ul></li><li><strong>Copying a Table 方法</strong><ul><li><strong>方法 1</strong>: AWS Data Pipeline (托管 ETL, 适合大规模数据迁移)</li><li><strong>方法 2</strong>: Backup + Restore (适合跨区域复制)</li><li><strong>方法 3</strong>: <code>Scan</code> + <code>PutItem</code>&#x2F;<code>BatchWriteItem</code> (自定义脚本, 灵活但慢)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img033405.png"></p><hr><h4 id="DynamoDB-Conditional-Writes"><a href="#DynamoDB-Conditional-Writes" class="headerlink" title="DynamoDB Conditional Writes"></a>DynamoDB Conditional Writes</h4><ul><li>支持条件写入的操作: <code>PutItem</code>, <code>UpdateItem</code>, <code>DeleteItem</code>, <code>BatchWriteItem</code></li><li>通过条件表达式 (Conditional Expression) 控制哪些 Item 可被修改</li><li>仅当条件为 true 时执行写入; 条件失败则拒绝操作并返回错误</li><li>常用条件函数:<ul><li><code>attribute_exists(partition_key)</code> - 检查 Item 是否存在</li><li><code>attribute_not_exists(partition_key)</code> - 检查 Item 是否不存在</li><li><code>attribute_type</code> - 检查属性类型</li><li><code>begins_with</code> - 检查属性值前缀</li><li>比较运算符: <code>=</code>, <code>&lt;&gt;</code>, <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code></li><li>逻辑运算符: <code>AND</code>, <code>OR</code>, <code>NOT</code></li></ul></li><li>使用场景:<ul><li>乐观锁定 (Optimistic Locking): 仅在版本号匹配时更新</li><li>防止覆盖: 仅在 Item 不存在时创建</li><li>原子计数器: 仅在值满足条件时增减</li><li>数据完整性: 确保更新符合业务规则</li></ul></li><li>条件写入不消耗额外 WCU, 但失败的写入仍消耗 WCU</li><li>条件表达式是实现乐观锁定的推荐方式</li><li>条件失败返回 <code>ConditionalCheckFailedException</code></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img022327.png"></p><hr><h4 id="DynamoDB-Indexes"><a href="#DynamoDB-Indexes" class="headerlink" title="DynamoDB Indexes"></a>DynamoDB Indexes</h4><ul><li><strong>Local Secondary Index (LSI)</strong><ul><li>为表提供备用 Sort Key (Partition Key 保持不变)</li><li>必须在创建表时定义, 之后无法添加或删除</li><li>使用主表的 WCU 和 RCU, 无需单独配置容量</li><li>Attribute Projections (属性投影):<ul><li><code>KEYS_ONLY</code> - 仅包含索引键和主键</li><li><code>INCLUDE</code> - 包含指定的额外属性</li><li><code>ALL</code> - 包含基表的所有属性</li></ul></li><li>每个表最多 5 个 LSI</li><li>所有 LSI 和基表 Item 的总大小不能超过 10 KB</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img025528.png"></p><ul><li><strong>Global Secondary Index (GSI)</strong><ul><li>提供备用 Primary Key (可以是不同的 Partition Key 和 Sort Key)</li><li>可以在创建表后添加、修改或删除</li><li>必须为索引单独配置 RCU 和 WCU</li><li>最终一致性 (Eventually Consistent), 数据更新可能有延迟</li><li>Attribute Projections: 与 LSI 相同的三种选项</li><li>每个表最多 20 个 GSI</li><li>可以跨不同属性查询数据</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img025824.png"></p><ul><li><strong>Indexes and Throttling</strong><ul><li><strong>GSI</strong>: 如果 GSI 上的写入被节流, 主表也会被节流</li><li>GSI 的 WCU 不足会影响主表的写入性能</li><li>需要仔细规划 GSI 的容量以避免影响主表</li><li><strong>LSI</strong>: 使用主表的 WCU 和 RCU, 不会单独导致节流</li><li>LSI 的读写操作计入主表的容量单位</li></ul></li><li><strong>LSI vs GSI 关键区别</strong>:<ul><li>LSI 必须在创建表时定义, GSI 可以后续添加</li><li>LSI 共享主表容量, GSI 需要独立容量</li><li>LSI 支持强一致性读取 (Strongly Consistent Reads), GSI 只支持最终一致性</li></ul></li><li>考试提示: GSI 节流会导致主表节流 (常见考题)</li><li>需要强一致性读取时使用 LSI; 需要灵活查询不同属性时使用 GSI</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img025950.png"></p><hr><h4 id="DynamoDB-PartiQL"><a href="#DynamoDB-PartiQL" class="headerlink" title="DynamoDB PartiQL"></a>DynamoDB PartiQL</h4><ul><li>使用类 SQL 语法操作 DynamoDB 表</li><li>支持 <code>SELECT</code>, <code>INSERT</code>, <code>UPDATE</code>, <code>DELETE</code> 语句</li><li>适合熟悉 SQL 的开发者, 降低学习曲线</li><li>仍受 DynamoDB 限制 (如必须指定 Partition Key)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img030113.png"></p><hr><h4 id="DynamoDB-Optimistic-Locking"><a href="#DynamoDB-Optimistic-Locking" class="headerlink" title="DynamoDB Optimistic Locking"></a>DynamoDB Optimistic Locking</h4><ul><li>乐观锁定策略: 确保 Item 在更新或删除前未被修改</li><li>通过 Conditional Writes 实现 (检查版本号或时间戳属性)</li><li>并发控制模型 (Concurrency Model): 适合低冲突场景</li><li>工作原理: 读取时记录版本号, 写入时检查版本号是否匹配; 不匹配则拒绝操作</li><li>考试提示: DynamoDB Optimistic Locking 使用 Conditional Writes 实现</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img030304.png"></p><hr><h4 id="DynamoDB-DAX"><a href="#DynamoDB-DAX" class="headerlink" title="DynamoDB DAX"></a>DynamoDB DAX</h4><ul><li>DynamoDB Accelerator (DAX): 完全托管的内存缓存, 专为 DynamoDB 设计</li><li>通过缓存解决读取拥塞问题, 延迟降至微秒级 (microseconds)</li><li>仅提升读取性能 (read performance), 不提升写入性能</li><li>不支持 SQL 查询缓存 (DAX 不是 relational 数据库)</li><li>与应用程序无缝集成, 无需修改代码逻辑 (使用 DAX SDK)</li><li>考试提示: 需要缓存 DynamoDB 读取 → DAX (不是 ElastiCache)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img233440.png"></p><hr><h4 id="DynamoDB-Stream"><a href="#DynamoDB-Stream" class="headerlink" title="DynamoDB Stream"></a>DynamoDB Stream</h4><ul><li>DynamoDB Streams: 记录表中 Item 级别修改的有序流 (ordered stream)</li><li>支持的目标: Lambda 函数, Kinesis Data Streams (注意: 不支持 SQS)</li><li>用途: 实时处理数据变更 (如发送通知邮件, 数据同步, 审计日志)</li><li>可以触发 Lambda 函数自动响应数据变更</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img030626.png"></p><ul><li>DynamoDB Streams 由分片 (shards) 组成, 类似 Kinesis Data Streams</li><li>启用 Stream 后, 仅记录新的变更 (不会回溯已有数据)</li><li>记录保留 24 小时, 之后自动删除</li><li>可选的流视图类型 (Stream View Type):<ul><li><code>KEYS_ONLY</code> - 仅包含主键</li><li><code>NEW_IMAGE</code> - 修改后的完整 Item</li><li><code>OLD_IMAGE</code> - 修改前的完整 Item</li><li><code>NEW_AND_OLD_IMAGES</code> - 修改前后的完整 Item</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img030940.png"></p><hr><h4 id="DynamoDB-TTL"><a href="#DynamoDB-TTL" class="headerlink" title="DynamoDB TTL"></a>DynamoDB TTL</h4><ul><li>Time to Live (TTL): 根据过期时间戳自动删除 Item</li><li>适用场景: 自动清理过期数据 (如会话记录, 临时数据, 事件日志)</li><li>过期 Item 在到期后 48 小时内删除 (非实时删除)</li><li>TTL 删除不消耗 WCU (免费操作)</li><li>删除的 Item 会出现在 DynamoDB Streams 中 (可用于审计或归档)</li><li>需要指定一个数字类型的属性作为 TTL 属性, 值为 Unix 时间戳 (秒)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img031135.png"></p><hr><h4 id="DynamoDB-CLI"><a href="#DynamoDB-CLI" class="headerlink" title="DynamoDB CLI"></a>DynamoDB CLI</h4><ul><li><code>--projection-expression</code>: 选择要检索的属性子集 (subset of attributes)</li><li><code>--filter-expression</code>: 过滤 Item 以检索 Item 子集 (subset of items)</li><li><code>--max-items</code> &amp; <code>--starting-token</code>: 限制返回的 Item 数量, 支持分页</li><li><code>--page-size</code>: 控制每次 API 请求的 Item 数量 (不影响返回的总 Item 数)</li><li>考试提示: 问题涉及”选择特定属性” → 使用 <code>--projection-expression</code></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img031324.png"></p><hr><h4 id="DynamoDB-Transactions"><a href="#DynamoDB-Transactions" class="headerlink" title="DynamoDB Transactions"></a>DynamoDB Transactions</h4><ul><li>事务操作: 跨一个或多个表协调多个 Item 的操作</li><li>提供 ACID 保证 (Atomicity 原子性, Consistency 一致性, Isolation 隔离性, Durability 持久性)</li><li>适用场景: 金融交易, 游戏计分, 订单处理等需要强一致性的场景</li><li>两种操作:<ul><li><code>TransactGetItems</code> - 事务读取 (最多 100 个 Item)</li><li><code>TransactWriteItems</code> - 事务写入 (最多 100 个 Item)</li></ul></li><li>消耗 2 倍的 WCU 和 RCU (事务成本是普通操作的 2 倍)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img031646.png"></p><ul><li><strong>DynamoDB Transactions 容量计算</strong><ul><li>事务写入: 3 次写入, Item 大小 5 KB → <code>3 × (5/1 向上取整) × 2 = 3 × 5 × 2 = 30 WCU</code></li><li>事务读取: 5 次读取, Item 大小 5 KB → <code>5 × (5/4 向上取整) × 2 = 5 × 2 × 2 = 20 RCU</code></li><li>注意: 事务操作先按普通操作计算 WCU&#x2F;RCU, 再乘以 2</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img032052.png"></p><hr><h4 id="DynamoDB-Session-State"><a href="#DynamoDB-Session-State" class="headerlink" title="DynamoDB Session State"></a>DynamoDB Session State</h4><ul><li>使用 DynamoDB 存储会话状态 (Session State)</li><li>适合无服务器架构, 自动扩展, 持久化存储</li><li>与 ElastiCache 对比:<ul><li>ElastiCache: 内存缓存, 延迟更低, 但需要管理集群</li><li>DynamoDB: Serverless, 完全托管, 持久化存储</li><li>两者都是 key&#x2F;value 存储</li></ul></li><li>考试提示: Serverless + 会话状态 → DynamoDB; 极低延迟 + 会话状态 → ElastiCache</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img032422.png"></p><hr><h4 id="DynamoDB-Write-Sharding"><a href="#DynamoDB-Write-Sharding" class="headerlink" title="DynamoDB Write Sharding"></a>DynamoDB Write Sharding</h4><ul><li>写分片策略: 通过更均匀地分布 Item 到各分区来提升性能</li><li>解决 Hot Partition 问题 (某个分区访问量过高导致节流)</li><li>实现方式: 在 Partition Key 值后添加随机后缀 (如 <code>user123_1</code>, <code>user123_2</code>)</li><li>优点: 写入分散到多个分区, 避免单个分区过载</li><li>缺点: 查询时需要查询所有后缀的分区 (增加查询复杂度)</li><li>适用场景: 写入密集型应用, 特定 Partition Key 访问量极高的场景</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img032640.png"></p><hr><h4 id="DynamoDB-Other-Features"><a href="#DynamoDB-Other-Features" class="headerlink" title="DynamoDB Other Features"></a>DynamoDB Other Features</h4><ul><li><strong>Backup and Restore</strong><ul><li>Point-in-Time Recovery (PITR): 类似 RDS, 可恢复到过去 35 天内任意时间点</li><li>On-Demand Backup: 手动创建完整备份, 长期保留</li></ul></li><li><strong>Global Tables</strong><ul><li>多区域复制 (Multi-region replication), 完全托管</li><li>双向复制, 任意区域可读写</li><li>适用场景: 全球分布的应用, 灾难恢复, 低延迟访问</li><li>要求: 必须启用 DynamoDB Streams</li></ul></li><li><strong>DynamoDB Local</strong><ul><li>本地开发和测试工具, 无需访问互联网或 AWS 账户</li><li>模拟 DynamoDB 功能, 降低开发成本</li><li>注意: 不支持所有 DynamoDB 功能 (如 TTL, 全局表)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img033717.png"></p><ul><li><strong>DynamoDB Fine-Grained Access Control (细粒度访问控制)</strong><ul><li>使用 IAM 策略的 Condition 限制用户对特定 Item 或属性的访问</li><li>基于 Leading Key (前导键) 限制访问: 用户只能访问与自己 ID 匹配的 Item</li><li>示例: 条件 <code>dynamodb:LeadingKeys</code> 限制用户只能访问自己的数据</li><li>适用场景: 多租户应用, SaaS 平台, 用户隔离</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img033855.png"></p><hr><h3 id="21-API-Gateway"><a href="#21-API-Gateway" class="headerlink" title="21. API Gateway"></a>21. API Gateway</h3><h4 id="AWS-API-Gateway"><a href="#AWS-API-Gateway" class="headerlink" title="AWS API Gateway"></a>AWS API Gateway</h4><ul><li>托管服务: 创建、发布和管理 REST API 和 WebSocket API</li><li>调用 Lambda 函数, 暴露 REST API (无状态客户端-服务器通信)</li><li>Lambda + API Gateway: 无需管理基础设施, 完全 Serverless</li><li>限流保护 (Throttling): 防止 API 被过多请求压垮</li><li><strong>API Gateway Caching</strong><ul><li>缓存 API 响应, 减少后端调用次数, 降低延迟</li><li>缓存 TTL: 0 秒到 3600 秒 (默认 300 秒)</li><li>按 Stage 级别配置缓存</li><li>考试提示: 降低 API 延迟 → API Gateway Caching</li></ul></li><li><strong>身份验证方式</strong><ul><li>Cognito User Pools: 用户身份验证和管理</li><li>IAM Permissions (Sigv4): 适合 AWS 内部服务调用</li><li>Lambda Authorizer (Custom Authorizer): 自定义身份验证逻辑</li><li>注意: API Gateway 不支持 STS 直接集成</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img164125.png"></p><ul><li><strong>API Gateway Endpoint Types</strong><ul><li><strong>Edge-Optimized (默认)</strong>: 通过 CloudFront Edge Locations 分发, 适合全球客户端; API Gateway 部署在一个区域</li><li><strong>Regional</strong>: 仅在当前区域部署, 适合同区域客户端; 可以手动配置 CloudFront</li><li><strong>Private</strong>: 仅可从 VPC 内通过 ENI (Elastic Network Interface) 访问, 适合内部 API</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img164338.png"></p><hr><h4 id="API-Gateway-Stages"><a href="#API-Gateway-Stages" class="headerlink" title="API Gateway Stages"></a>API Gateway Stages</h4><ul><li>API Gateway 修改不会立即生效, 需要”部署 (Deployment)”才能应用更改</li><li><strong>Stage (阶段)</strong>: API 的不同版本环境 (如 dev, test, prod)</li><li>每个 Stage 有独立的配置: 缓存设置, 限流设置, 日志级别等</li><li>Stage URL 格式: <code>https://&#123;api-id&#125;.execute-api.&#123;region&#125;.amazonaws.com/&#123;stage&#125;</code></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img173311.png"></p><ul><li><strong>API Gateway Stage Variables</strong><ul><li>Stage Variables: 类似环境变量, 每个 Stage 可以有不同的值</li><li>使用场景: <ul><li>指向不同的 Lambda 函数或 Lambda Alias (如 dev → v1, prod → v2)</li><li>配置不同的后端 HTTP 端点</li><li>传递特定配置参数到集成</li></ul></li><li>从 test 提升到 prod: 直接更新 Stage Variable 指向新的 Lambda Alias, 无需修改代码</li><li>考试提示: 需要在不同环境使用不同后端 → Stage Variables</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img190149.png"></p><hr><h4 id="API-Gateway-Canary-Deployment"><a href="#API-Gateway-Canary-Deployment" class="headerlink" title="API Gateway Canary Deployment"></a>API Gateway Canary Deployment</h4><ul><li>金丝雀部署: 逐步发布新版本, 先小规模测试, 再全面推广的策略</li><li>配置流量百分比: 选择 Canary 通道接收的流量比例 (0% - 50%)</li><li>工作原理: 新版本部署到 Canary, 分配部分流量进行测试; 验证通过后提升为主版本</li><li>可配置 Canary Stage Variables 和 Canary 缓存设置</li><li>优点: 降低发布风险, 快速回滚, 实时监控新版本性能</li><li>考试提示: 需要安全地测试新 API 版本 → Canary Deployment</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img190857.png"></p><hr><h4 id="API-Gateway-Integration-Types"><a href="#API-Gateway-Integration-Types" class="headerlink" title="API Gateway Integration Types"></a>API Gateway Integration Types</h4><ul><li><p><strong><code>MOCK</code></strong></p><ul><li>API Gateway 直接返回响应, 不发送请求到后端</li><li>用途: 测试 API 结构, 返回静态响应, 无需后端服务</li></ul></li><li><p><strong><code>HTTP / AWS</code> (Non-Proxy)</strong></p><ul><li>需要配置集成请求和集成响应</li><li>使用 Mapping Templates 设置请求&#x2F;响应的数据映射</li><li>完全控制请求和响应的转换</li><li>适用场景: 需要修改请求&#x2F;响应格式, 与 AWS 服务集成 (如 DynamoDB, S3)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img191239.png"></p><ul><li><strong><code>AWS_PROXY</code> (Lambda Proxy)</strong><ul><li>客户端请求直接传递给 Lambda 函数作为输入</li><li>不使用 Mapping Templates, Headers, Query String 和 Body 作为参数传递</li><li>Lambda 返回格式必须符合 API Gateway 要求 (包含 <code>statusCode</code>, <code>body</code> 等)</li><li>优点: 简化配置, Lambda 处理所有逻辑</li><li>考试提示: 简化 Lambda 集成 → AWS_PROXY</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img191413.png"></p><ul><li><strong><code>HTTP_PROXY</code></strong><ul><li>HTTP 请求直接传递到后端, 不进行任何转换</li><li>不使用 Mapping Templates</li><li>后端必须能够处理原始 HTTP 请求</li><li>适用场景: 代理现有的 HTTP 端点</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img191520.png"></p><hr><h4 id="API-Gateway-Mapping-Templates"><a href="#API-Gateway-Mapping-Templates" class="headerlink" title="API Gateway Mapping Templates"></a>API Gateway Mapping Templates</h4><ul><li>Mapping Templates: 使用 VTL (Velocity Template Language) 修改请求和响应</li><li>用途:<ul><li>修改 Query String 参数</li><li>修改 Body 内容 (转换 JSON 格式, 过滤字段)</li><li>添加或删除 Headers</li><li>屏蔽输出数据中的敏感字段</li></ul></li><li>适用于 <code>HTTP / AWS</code> (Non-Proxy) 集成类型</li><li>常见场景: 将 REST API 请求转换为 SOAP, 过滤响应中的敏感信息</li><li>考试提示: 需要转换请求&#x2F;响应格式 → Mapping Templates</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img191718.png"></p><hr><h4 id="API-Gateway-OpenAPI"><a href="#API-Gateway-OpenAPI" class="headerlink" title="API Gateway OpenAPI"></a>API Gateway OpenAPI</h4><ul><li>OpenAPI (Swagger): 定义 REST API 的标准规范, 将 API 定义为代码</li><li>可以导入 OpenAPI 3.0 定义来创建 API Gateway</li><li>可以导出现有 API 为 OpenAPI 定义</li><li>使用扩展 (x-amazon-apigateway-) 定义 API Gateway 特定功能</li><li><strong>Request Validation (请求验证)</strong>:<ul><li>在请求到达后端之前验证请求参数和 Body</li><li>减少不必要的后端调用, 降低成本和延迟</li><li>验证失败返回 400 错误</li><li>可验证: Query String, Headers, Request Body (基于 JSON Schema)</li></ul></li><li>考试提示: 减少无效请求到后端 → Request Validation</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img201259.png"></p><hr><h4 id="API-Gateway-Caching"><a href="#API-Gateway-Caching" class="headerlink" title="API Gateway Caching"></a>API Gateway Caching</h4><ul><li>缓存减少对后端的调用次数, 降低延迟和成本</li><li>缓存按 Stage 级别定义, 每个 Stage 有独立的缓存配置</li><li>默认 TTL: 300 秒, 最大 TTL: 3600 秒 (1 小时)</li><li>缓存容量: 0.5 GB 到 237 GB</li><li>客户端可以使用 Header <code>Cache-Control: max-age=0</code> 使缓存失效 (需要适当的 IAM 授权)</li><li>可以为每个方法 (Method) 覆盖缓存设置</li><li>考试提示: 降低 API 延迟和后端负载 → API Gateway Caching</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img201709.png"></p><hr><h4 id="API-Gateway-Usage-Plans-amp-API-Keys"><a href="#API-Gateway-Usage-Plans-amp-API-Keys" class="headerlink" title="API Gateway Usage Plans &amp; API Keys"></a>API Gateway Usage Plans &amp; API Keys</h4><ul><li>将 API 作为产品提供给客户 (如 SaaS 服务)</li><li><strong>Usage Plan (使用计划)</strong>: 定义谁可以访问, 访问频率和限额<ul><li>Throttle (限流): 每秒请求数限制 (Burst 和 Rate)</li><li>Quota (配额): 每天&#x2F;周&#x2F;月的请求总数限制</li><li>关联到特定的 API Stage</li></ul></li><li><strong>API Keys</strong>: 用于识别客户端, 与 Usage Plan 配合控制访问<ul><li>注意: API Keys 不是安全机制, 仅用于使用跟踪和限流</li><li>应与其他身份验证方式 (IAM, Cognito, Lambda Authorizer) 配合使用</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img202109.png"></p><ul><li><strong>配置 Usage Plan 的步骤</strong>:<ol><li>创建 API 并配置方法要求 API Key</li><li>将 API 部署到 Stage</li><li>生成或导入 API Keys, 分发给应用开发者</li><li>创建 Usage Plan, 设置限流和配额</li><li>将 API Stage 和 API Keys 关联到 Usage Plan</li></ol></li><li>考试提示: 向客户提供付费 API → Usage Plans &amp; API Keys</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img202324.png"></p><hr><h4 id="API-Gateway-Monitoring"><a href="#API-Gateway-Monitoring" class="headerlink" title="API Gateway Monitoring"></a>API Gateway Monitoring</h4><ul><li>CloudWatch 指标 (Metrics):<ul><li><code>CacheHitCount</code> &amp; <code>CacheMissCount</code>: 缓存效率, 缓存命中率</li><li><code>Count</code>: API 请求总数</li><li><code>IntegrationLatency</code>: API Gateway 到后端的请求和响应时间</li><li><code>Latency</code>: 完整的请求响应时间 (包括 API Gateway 开销)</li><li><code>4XXError</code>: 客户端错误 (如 400 Bad Request, 403 Forbidden, 404 Not Found)</li><li><code>5XXError</code>: 服务器错误 (如 502 Bad Gateway, 504 Gateway Timeout)</li></ul></li><li>常见错误码:<ul><li><code>400</code>: Bad Request - 请求格式错误</li><li><code>403</code>: Forbidden - WAF 过滤或授权失败</li><li><code>429</code>: Too Many Requests - 超出限流配置</li><li><code>502</code>: Bad Gateway - 后端返回无效响应</li><li><code>503</code>: Service Unavailable - 服务不可用</li><li><code>504</code>: Integration Timeout - 后端响应超时 (默认 29 秒)</li></ul></li><li>考试提示: 诊断 timeout 问题 → 查看 <code>IntegrationLatency</code> 和 <code>Latency</code></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img202658.png"></p><hr><h4 id="API-Gateway-CORS"><a href="#API-Gateway-CORS" class="headerlink" title="API Gateway CORS"></a>API Gateway CORS</h4><ul><li>CORS (Cross-Origin Resource Sharing): 跨域资源共享</li><li>当 API 接收来自不同域名的调用时, 必须启用 CORS</li><li>CORS 配置 Headers:<ul><li><code>Access-Control-Allow-Origin</code>: 允许的来源域名 (如 <code>*</code> 或特定域名)</li><li><code>Access-Control-Allow-Methods</code>: 允许的 HTTP 方法 (如 GET, POST, PUT)</li><li><code>Access-Control-Allow-Headers</code>: 允许的 Headers</li></ul></li><li>CORS 也可以限制特定域名访问 API, 提升安全性</li><li>考试提示: 浏览器报 CORS 错误 → 启用 CORS 配置</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img202855.png"></p><hr><h4 id="API-Gateway-Security"><a href="#API-Gateway-Security" class="headerlink" title="API Gateway Security"></a>API Gateway Security</h4><ul><li><strong>IAM Permissions (适合 AWS 账户内部访问)</strong><ul><li>身份验证 (Authentication): IAM</li><li>授权 (Authorization): IAM Policy</li><li>创建 IAM Policy 并附加到 User 或 Role</li><li>请求必须使用 Sig v4 签名</li><li>跨账户访问: 使用 Resource Policies</li><li>适用场景: AWS 服务之间调用, EC2&#x2F;Lambda 内部调用</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img203055.png"></p><ul><li><strong>Cognito User Pools (适合管理自己的用户池)</strong><ul><li>身份验证: Cognito User Pools</li><li>授权: API Gateway Methods</li><li>API Gateway 自动验证来自 Cognito 的身份令牌</li><li>无需编写自定义授权代码</li><li>适用场景: 移动&#x2F;Web 应用的用户管理, 社交登录集成</li><li>考试提示: 管理用户身份 + API 访问 → Cognito User Pools</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img203446.png"></p><ul><li><strong>Lambda Authorizer (适合第三方 Token 或自定义授权)</strong><ul><li>身份验证: External (第三方身份提供商)</li><li>授权: Lambda 函数</li><li>支持 Token-based (JWT, OAuth) 或 Request-based 授权</li><li>Lambda 函数返回 IAM Policy, 决定是否允许请求</li><li>可以使用请求参数 (Headers, Query String) 确定调用者身份</li><li>结果可以缓存, 减少 Lambda 调用次数</li><li>适用场景: 第三方 OAuth, 自定义授权逻辑, 复杂业务规则</li><li>考试提示: 第三方 Token 或自定义授权 → Lambda Authorizer</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img203612.png"></p><hr><h4 id="API-Gateway-WebSocket-API"><a href="#API-Gateway-WebSocket-API" class="headerlink" title="API Gateway WebSocket API"></a>API Gateway WebSocket API</h4><ul><li>WebSocket API: 用于实时应用 (如聊天, 交易平台, 协作工具, 游戏)</li><li>WebSocket 是双向通信协议 (Two-way communication), 服务器可以主动推送数据给客户端</li><li>连接 URL 格式: <code>wss://[unique-id].execute-api.[region].amazonaws.com/[stage-name]</code></li><li>连接是有状态的 (Stateful), 保持长连接</li><li>API Gateway 维护连接 ID, 用于向特定客户端发送消息</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img204056.png"></p><ul><li><strong>WebSocket API Routing (路由)</strong><ul><li>使用 Route Selection Expression 从 JSON 消息中选择字段进行路由</li><li>默认表达式: <code>$request.body.action</code></li><li>特殊路由:<ul><li><code>$connect</code>: 客户端连接时触发</li><li><code>$disconnect</code>: 客户端断开时触发</li><li><code>$default</code>: 未匹配到其他路由时触发</li></ul></li><li>自定义路由: 根据消息内容路由到不同的后端 (Lambda 函数, HTTP 端点)</li><li>示例: <code>&#123;&quot;action&quot;: &quot;sendMessage&quot;&#125;</code> 路由到 <code>sendMessage</code> 路由</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img204735.png"></p><hr><h3 id="22-AWS-CICD"><a href="#22-AWS-CICD" class="headerlink" title="22. AWS CICD"></a>22. AWS CICD</h3><h4 id="AWS-CodeCommit"><a href="#AWS-CodeCommit" class="headerlink" title="AWS CodeCommit"></a>AWS CodeCommit</h4><ul><li>版本控制工具: 帮助理解代码的变更历史</li><li>私有 Git 仓库 (类似私有 GitHub), 完全托管, 无需管理服务器</li><li>支持标准 Git 操作 (clone, push, pull, branch, merge)</li><li>身份验证方式:<ul><li>Git Credentials: IAM 生成的 HTTPS 用户名和密码</li><li>SSH Keys: 上传公钥到 IAM</li><li>AWS Access Keys: 使用 AWS CLI credential helper</li></ul></li><li>数据加密: 传输中 (in transit) 和静态 (at rest) 均加密</li><li>考试提示: 使用 HTTPS 迁移仓库到 CodeCommit → 使用 IAM 生成的 Git Credentials</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img213239.png"></p><hr><h4 id="AWS-CodePipeline"><a href="#AWS-CodePipeline" class="headerlink" title="AWS CodePipeline"></a>AWS CodePipeline</h4><ul><li>完全托管的 CI&#x2F;CD 编排服务, 自动化构建、测试和部署流程</li><li>编排整个发布流程 (Source → Build → Test → Deploy)</li><li>考试提示: 看到”orchestrate CI&#x2F;CD” → CodePipeline</li><li>可以为整个流程创建一个 Pipeline, 并添加手动批准步骤 (Manual Approval)</li><li>Pipeline 由多个 Stage 组成, 每个 Stage 可以包含多个 Action</li><li>支持集成: CodeCommit, GitHub, S3, CodeBuild, CodeDeploy, Lambda, ECS, Elastic Beanstalk</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img215659.png"></p><ul><li><strong>Artifacts (构建产物)</strong>:<ul><li>每个 Stage 可以生成 Artifacts</li><li>Artifacts 存储在 S3 Bucket 中</li><li>自动传递到下一个 Stage 作为输入</li><li>示例: Build Stage 生成的 JAR 文件传递给 Deploy Stage</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img215817.png"></p><hr><h4 id="AWS-CodeBuild"><a href="#AWS-CodeBuild" class="headerlink" title="AWS CodeBuild"></a>AWS CodeBuild</h4><ul><li>完全托管的持续集成服务 (Continuous Integration), 用于编译代码、运行测试、生成软件包</li><li>托管的 Jenkins 替代品, 无需管理构建服务器</li><li><strong>构建指令 (Build Instructions)</strong>:<ul><li><code>buildspec.yml</code> 文件: 必须位于代码根目录, 定义构建步骤</li><li>也可以在 Console 中手动插入构建命令</li></ul></li><li>部署前自动测试应用程序 (考试提示: 需要测试 → CodeBuild)</li><li>自动扩展 (Auto Scaling): 并行运行构建, 无需担心扩展问题</li><li>本地调试: 可以使用 CodeBuild Agent 在本地运行 CodeBuild</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img220508.png"></p><ul><li><strong>buildspec.yml 关键点</strong>:<ul><li>必须位于代码根目录</li><li>定义构建阶段: <code>install</code>, <code>pre_build</code>, <code>build</code>, <code>post_build</code></li><li>指定构建产物 (artifacts) 和缓存 (cache)</li></ul></li><li>使用 KMS Key 加密构建产物 (build artifacts)</li><li>使用 Timeouts 防止构建过程过长 (默认 1 小时, 最长 8 小时)</li><li>在构建阶段打包依赖项到源代码中</li><li>考试提示: 构建产物加密 → KMS Key; 防止长时间构建 → Timeouts</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img220651.png"></p><hr><h4 id="AWS-CodeDeploy"><a href="#AWS-CodeDeploy" class="headerlink" title="AWS CodeDeploy"></a>AWS CodeDeploy</h4><ul><li>自动化部署服务, 将应用代码部署到各种计算环境 (EC2, Lambda, ECS, On-premises)</li><li><strong>自动回滚 (Automatic Rollback)</strong>:<ul><li>部署失败时自动回滚</li><li>重新部署最后一个正常版本, 生成新的 Deployment ID</li></ul></li><li><strong>appspec.yml 文件</strong>: 定义部署方式 (部署步骤, 脚本, 生命周期事件)</li><li>考试提示: 归档应用版本数量 → 使用 CodeDeploy Agent</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img220850.png"></p><ul><li><strong>CodeDeploy - EC2 &#x2F; On-premises Platform (需要 Agent)</strong><ul><li>支持两种部署类型:<ul><li><code>In-Place Deployment</code>: 在现有实例上停止应用, 部署新版本, 启动应用</li><li><code>Blue/Green Deployment</code>: 创建新实例, 部署新版本, 将流量从旧实例切换到新实例</li></ul></li><li>必须在目标实例上运行 CodeDeploy Agent</li><li><strong>生命周期事件顺序 (Lifecycle Events)</strong>:<br><code>ApplicationStop</code> → <code>DownloadBundle</code> → <code>BeforeInstall</code> → <code>Install</code> → <code>AfterInstall</code> → <code>ApplicationStart</code> → <code>ValidateService</code></li><li><strong>四种部署速度</strong>:<ul><li><code>AllAtOnce</code>: 同时部署到所有实例 (最快, 但有停机时间)</li><li><code>HalfAtATime</code>: 每次部署到一半实例</li><li><code>OneAtATime</code>: 每次部署到一个实例 (最慢, 但最安全)</li><li><code>Custom</code>: 自定义百分比</li></ul></li><li>考试提示: EC2 部署 → In-Place 或 Blue&#x2F;Green; Blue&#x2F;Green 可以重新路由流量</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img221100.png"></p><ul><li><strong>CodeDeploy - Lambda Platform</strong><ul><li>自动化 Lambda Aliases 的流量切换</li><li>支持金丝雀部署 (Canary), 线性部署 (Linear), 全部切换 (AllAtOnce)</li><li>与 SAM 框架集成</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img221326.png"></p><ul><li><strong>CodeDeploy - ECS Platform</strong><ul><li>自动部署新的 ECS Task Definition</li><li>支持 Blue&#x2F;Green 部署, 逐步切换流量</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img221501.png"></p><ul><li><strong>CodeDeploy Deployment Groups</strong>:<ul><li>将应用部署到不同时间的不同 EC2 实例</li><li>按标签 (Tags) 或 Auto Scaling Group 分组实例</li><li>每个 Deployment Group 可以有不同的部署配置</li></ul></li></ul><hr><h4 id="AWS-CodeStar-CodeCatalyst"><a href="#AWS-CodeStar-CodeCatalyst" class="headerlink" title="AWS CodeStar (CodeCatalyst)"></a>AWS CodeStar (CodeCatalyst)</h4><ul><li>快速创建 CI&#x2F;CD 就绪的项目模板</li><li>支持的计算平台: EC2, Lambda, Elastic Beanstalk</li><li>统一仪表板 (Dashboard) 查看所有组件 (代码, 构建, 部署, 问题跟踪)</li><li>自动配置 CodeCommit, CodeBuild, CodeDeploy, CodePipeline</li><li>集成问题跟踪工具 (如 Jira)</li><li>考试提示: 统一查看 CI&#x2F;CD 组件 → CodeStar Dashboard</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img224413.png"></p><hr><h4 id="AWS-CodeArtifact"><a href="#AWS-CodeArtifact" class="headerlink" title="AWS CodeArtifact"></a>AWS CodeArtifact</h4><ul><li>安全且经济高效的软件包管理服务 (类似私有 npm, Maven, PyPI)</li><li>存储和共享软件依赖项 (如 npm 包, Maven 依赖, Python 包)</li><li>开发者和 CodeBuild 可以直接从 CodeArtifact 检索依赖项</li><li>支持公共仓库代理 (如 npm, Maven Central), 缓存常用包</li><li>减少外部依赖风险, 提升构建速度</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img221957.png"></p><ul><li><strong>CodeArtifact Resource Policy</strong><ul><li>资源策略 (Resource Policy): 允许其他 AWS 账户访问 CodeArtifact</li><li>跨账户共享软件包</li><li>示例: 允许组织内其他账户读取特定 CodeArtifact 仓库</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img222141.png"></p><hr><h4 id="AWS-CodeGuru"><a href="#AWS-CodeGuru" class="headerlink" title="AWS CodeGuru"></a>AWS CodeGuru</h4><ul><li>基于机器学习的代码审查和性能优化服务</li><li><strong>CodeGuru Reviewer</strong>:<ul><li>自动化代码审查, 静态代码分析</li><li>检测代码缺陷, 安全漏洞, 性能问题</li><li>提供改进建议 (如资源泄漏, 线程安全问题)</li><li>适用阶段: 开发阶段 (Development)</li></ul></li><li><strong>CodeGuru Profiler</strong>:<ul><li>分析应用运行时性能</li><li>识别性能瓶颈 (如 CPU 密集代码, 内存泄漏)</li><li>提供成本优化建议</li><li>适用阶段: 生产环境 (Production)</li></ul></li><li>考试提示: 代码审查 → CodeGuru Reviewer; 性能优化 → CodeGuru Profiler</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img222415.png"></p><hr><h4 id="AWS-Cloud9"><a href="#AWS-Cloud9" class="headerlink" title="AWS Cloud9"></a>AWS Cloud9</h4><ul><li>云端 IDE (Integrated Development Environment)</li><li>类似 VSCode, 直接在浏览器中编写、运行和调试代码</li><li>内置终端, 支持直接访问 AWS 服务</li><li>协作功能: 多人实时编辑同一代码</li><li>适用场景: 无需本地开发环境, 远程协作开发</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img222601.png"></p><hr><h3 id="23-AWS-Serverless-Application-Model-SAM"><a href="#23-AWS-Serverless-Application-Model-SAM" class="headerlink" title="23. AWS Serverless Application Model (SAM)"></a>23. AWS Serverless Application Model (SAM)</h3><h4 id="AWS-SAM"><a href="#AWS-SAM" class="headerlink" title="AWS SAM"></a>AWS SAM</h4><ul><li>SAM (Serverless Application Model): 用于开发和部署无服务器应用的框架</li><li>简化 Lambda, API Gateway, DynamoDB 等 Serverless 资源的定义和部署</li><li>SAM 模板最终转换为 CloudFormation 模板进行部署</li><li><strong>AWS Serverless Application Repository (SAR)</strong>:<ul><li>共享和发现预构建的无服务器应用</li><li>可以与其他 AWS 账户或公开共享 SAM 应用</li><li>考试提示: 查找预构建无服务器应用 → SAR</li></ul></li><li><strong>部署流程</strong>:<ol><li>本地开发 SAM 模板 (template.yaml)</li><li>打包并上传到 S3 (<code>sam package</code> 或 <code>sam build</code>)</li><li>部署到 AWS (<code>sam deploy</code>)</li></ol></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img153636.png"></p><ul><li><strong>SAM Recipe (模板配置)</strong>:<ul><li><strong>Transform Header</strong> (必需): <code>Transform: AWS::Serverless-2016-10-31</code></li><li>该 Header 将 SAM 模板转换为 CloudFormation 模板</li><li><strong>支持的资源类型</strong>:<ul><li><code>AWS::Serverless::Function</code> - Lambda 函数</li><li><code>AWS::Serverless::Api</code> - API Gateway</li><li><code>AWS::Serverless::SimpleTable</code> - DynamoDB 表</li></ul></li><li><strong>部署命令</strong>: <code>sam deploy</code> (将打包后的模板上传到 AWS)</li><li>考试提示: SAM 模板必需 Transform Header</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img155435.png"></p><ul><li><strong>SAM Accelerate (<code>sam sync</code>)</strong>:<ul><li>快速同步本地更改到 AWS, 减少部署延迟</li><li>跳过 CloudFormation 完整部署流程, 直接更新资源</li><li>适用于开发和测试阶段, 加快迭代速度</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img154010.png"></p><hr><h4 id="SAM-Policy-Templates"><a href="#SAM-Policy-Templates" class="headerlink" title="SAM Policy Templates"></a>SAM Policy Templates</h4><ul><li>预定义的权限模板列表, 简化 Lambda 函数的 IAM 权限配置</li><li>常用模板:<ul><li><code>S3ReadPolicy</code>: 只读访问 S3 对象</li><li><code>SQSPollerPolicy</code>: 允许轮询 SQS 队列</li><li><code>DynamoDBCrudPolicy</code>: DynamoDB 的 Create, Read, Update, Delete 权限</li><li><code>SQSWritePolicy</code>: 写入 SQS 队列</li><li><code>SNSPublishMessagePolicy</code>: 发布消息到 SNS</li></ul></li><li>在 SAM 模板中直接引用, 无需手动编写 IAM 策略</li><li>考试提示: 简化 Lambda 权限配置 → SAM Policy Templates</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img154539.png"></p><hr><h4 id="SAM-Local-Capabilities"><a href="#SAM-Local-Capabilities" class="headerlink" title="SAM Local Capabilities"></a>SAM Local Capabilities</h4><ul><li>SAM Local: 在本地模拟、测试和调试无服务器应用</li><li>支持本地运行 Lambda 函数和 API Gateway 端点</li><li>需要 SAM CLI 和 AWS Toolkits</li><li><strong>本地启动 Lambda 函数</strong>:<ul><li><code>sam local invoke</code> - 本地调用 Lambda 函数</li><li><code>sam local start-lambda</code> - 启动本地 Lambda 端点</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img154914.png"></p><ul><li><strong>本地启动 API Gateway 端点</strong>:<ul><li><code>sam local start-api</code> - 启动本地 API Gateway</li><li>在 <code>http://localhost:3000</code> 测试 API</li></ul></li><li><strong>生成 AWS 事件</strong>:<ul><li><code>sam local generate-event</code> - 生成测试事件 (如 S3, SQS, DynamoDB Streams)</li><li>用于本地测试 Lambda 函数对不同事件的响应</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img155003.png"></p><hr><h3 id="24-Cloud-Development-Kit-CDK"><a href="#24-Cloud-Development-Kit-CDK" class="headerlink" title="24. Cloud Development Kit (CDK)"></a>24. Cloud Development Kit (CDK)</h3><h4 id="AWS-Cloud-Development-Kit"><a href="#AWS-Cloud-Development-Kit" class="headerlink" title="AWS Cloud Development Kit"></a>AWS Cloud Development Kit</h4><ul><li>CDK: 使用熟悉的编程语言 (TypeScript, Python, Java, C#, Go) 定义云基础设施</li><li>Infrastructure as Code (IaC): 使用编程语言而非 JSON&#x2F;YAML</li><li>可以同时部署基础设施和应用运行时代码</li><li>CDK 代码最终编译为 CloudFormation 模板进行部署</li><li>优势: 使用熟悉的 IDE, 代码补全, 类型检查, 逻辑控制 (循环, 条件)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img160250.png"></p><ul><li><strong>CDK vs SAM</strong> (两者都使用 CloudFormation)<ul><li><strong>SAM</strong>:<ul><li>专注于 Serverless 应用 (Lambda, API Gateway, DynamoDB)</li><li>使用 JSON 或 YAML 格式</li><li>简化 Serverless 资源定义</li></ul></li><li><strong>CDK</strong>:<ul><li>支持所有 AWS 服务 (EC2, S3, VPC, RDS 等)</li><li>使用编程语言 (TypeScript, Python, Java, C#, Go)</li><li>更灵活, 可构建复杂基础设施</li></ul></li></ul></li><li>CDK 提供 App Templates (应用模板), CloudFormation 不提供</li><li>考试提示: 使用编程语言定义基础设施 → CDK; 仅 Serverless → SAM</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img160532.png"></p><hr><h3 id="25-Cognito"><a href="#25-Cognito" class="headerlink" title="25. Cognito"></a>25. Cognito</h3><h4 id="AWS-Cognito"><a href="#AWS-Cognito" class="headerlink" title="AWS Cognito"></a>AWS Cognito</h4><ul><li>用户身份和访问管理服务, 提供用户注册、登录和访问控制功能</li><li>两个主要组件:<ul><li><strong>Cognito User Pools (CUP)</strong>: 用户身份验证 (Authentication), 用户目录</li><li><strong>Cognito Identity Pools (CIP)</strong>: 授权 (Authorization), 提供临时 AWS 凭证</li></ul></li><li><strong>CUP + CIP &#x3D; 完整的身份验证和授权解决方案</strong><ul><li>CUP: 验证用户身份, 颁发 JWT Token</li><li>CIP: 使用 CUP 或其他身份提供商, 颁发临时 AWS 凭证访问 AWS 资源</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img181012.png"></p><ul><li><strong>Cognito Sync</strong>: 跨设备同步应用相关的用户数据 (已被 AppSync 取代)</li></ul><hr><h4 id="Cognito-User-Pools-CUP"><a href="#Cognito-User-Pools-CUP" class="headerlink" title="Cognito User Pools (CUP)"></a>Cognito User Pools (CUP)</h4><ul><li>用户目录和身份验证服务, 管理用户注册、登录、密码重置</li><li>集成对象:<ul><li>API Gateway: 验证 API 请求</li><li>Application Load Balancer (ALB): 保护 Web 应用</li><li>注意: 与 ALB 集成, 不是 CloudFront</li></ul></li><li>成功登录后返回 JWT Token (JSON Web Token)<ul><li>ID Token: 用户身份信息</li><li>Access Token: 访问用户池 API</li><li>Refresh Token: 刷新 ID 和 Access Token</li></ul></li><li><strong>Adaptive Authentication (自适应身份验证)</strong>:<ul><li>基于风险评估的安全措施</li><li>检测可疑登录 (如异常位置, 设备)</li><li>可疑登录时阻止或要求 MFA (多因素身份验证)</li></ul></li><li>支持社交登录 (Google, Facebook, Amazon) 和 SAML 身份提供商</li><li>考试提示: 用户身份验证 + API Gateway&#x2F;ALB → Cognito User Pools</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img181142.png"></p><hr><h4 id="Cognito-Identity-Pools-CIP"><a href="#Cognito-Identity-Pools-CIP" class="headerlink" title="Cognito Identity Pools (CIP)"></a>Cognito Identity Pools (CIP)</h4><ul><li>为用户提供临时 AWS 凭证, 直接访问 AWS 服务 (如 S3, DynamoDB)</li><li>支持的身份提供商:<ul><li>Cognito User Pools</li><li>社交登录 (Google, Facebook, Amazon)</li><li>SAML 身份提供商</li><li>自定义身份提供商</li></ul></li><li>为认证用户和未认证用户 (Guest) 分配不同的 IAM 角色</li><li><strong>用户特定文件访问控制</strong>:<ul><li>使用 IAM Policy 变量 <code>$&#123;cognito-identity.amazonaws.com:sub&#125;</code> 限制用户访问</li><li>示例: 限制用户只能访问 S3 中自己的文件夹</li><li>考试提示: 用户特定文件上传&#x2F;下载 → IAM Policy with Cognito Identity Prefix</li></ul></li><li>临时凭证通过 STS AssumeRoleWithWebIdentity 获取</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img20555%EF%BC%95.png"></p><hr><h3 id="26-Step-Functions-amp-AppSync"><a href="#26-Step-Functions-amp-AppSync" class="headerlink" title="26. Step Functions &amp; AppSync"></a>26. Step Functions &amp; AppSync</h3><h4 id="AWS-Step-Functions"><a href="#AWS-Step-Functions" class="headerlink" title="AWS Step Functions"></a>AWS Step Functions</h4><ul><li>可视化工作流服务, 协调和编排分布式应用和微服务</li><li>使用 JSON 定义状态机 (State Machine), 可视化执行流程</li><li><strong>两种工作流类型</strong>:<ul><li><strong>Standard Workflow</strong>:<ul><li>长时间运行 (最长 1 年)</li><li>持久化 (Durable), 可审计 (Auditable)</li><li>精确执行一次 (Exactly-once execution)</li><li>适用场景: 订单处理, 数据管道, 复杂业务流程</li></ul></li><li><strong>Express Workflow</strong>:<ul><li>短时间运行 (最长 5 分钟)</li><li>高事件速率 (每秒 100,000+ 事件)</li><li>至少执行一次 (At-least-once execution)</li><li>两种模式: Synchronous (同步) 和 Asynchronous (异步)</li><li>适用场景: IoT 数据处理, 实时流处理, 移动后端</li></ul></li></ul></li><li><strong>Task States</strong>: 执行工作单元 (如调用 Lambda, 发布 SNS, 启动 ECS Task)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img215042.png"></p><ul><li><strong>Parallel State</strong>: 并行执行多个分支, 等待所有分支完成后继续</li><li>常用状态类型:<ul><li><code>Task</code>: 执行工作</li><li><code>Choice</code>: 条件分支</li><li><code>Wait</code>: 等待指定时间</li><li><code>Parallel</code>: 并行执行</li><li><code>Map</code>: 迭代处理数组</li><li><code>Pass</code>: 传递输入到输出</li><li><code>Succeed</code> &#x2F; <code>Fail</code>: 成功或失败终止</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img215355.png"></p><hr><h4 id="Step-Functions-Error-Handling"><a href="#Step-Functions-Error-Handling" class="headerlink" title="Step Functions Error Handling"></a>Step Functions Error Handling</h4><ul><li>任何状态都可能遇到运行时错误 (如 Lambda 超时, 权限不足, 资源不可用)</li><li>使用 <code>Retry</code> 和 <code>Catch</code> 在状态机中处理错误, 而非在应用代码中</li><li><strong>Retry (重试)</strong>:<ul><li>指定错误类型 (ErrorEquals)</li><li>重试间隔 (IntervalSeconds)</li><li>最大重试次数 (MaxAttempts)</li><li>退避倍率 (BackoffRate)</li></ul></li><li><strong>Catch (捕获)</strong>:<ul><li>捕获特定错误类型</li><li>跳转到指定状态 (Next)</li><li>可以记录错误或发送通知</li></ul></li><li>常见错误类型: <code>States.ALL</code>, <code>States.Timeout</code>, <code>States.TaskFailed</code>, <code>Lambda.ServiceException</code></li><li>考试提示: 工作流错误处理 → Step Functions Retry&#x2F;Catch</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img215654.png"></p><hr><h4 id="Step-Functions-Wait-for-Task-Token"><a href="#Step-Functions-Wait-for-Task-Token" class="headerlink" title="Step Functions Wait for Task Token"></a>Step Functions Wait for Task Token</h4><ul><li>暂停 Step Functions 执行, 直到收到 Task Token (回调模式)</li><li>在 Resource 字段追加 <code>.waitForTaskToken</code></li><li>使用场景:<ul><li>等待人工审批</li><li>等待外部系统响应</li><li>集成第三方服务</li></ul></li><li>Task Token 通过 <code>SendTaskSuccess</code> 或 <code>SendTaskFailure</code> API 返回</li><li>超时时间可配置 (HeartbeatSeconds, TimeoutSeconds)</li><li>考试提示: 需要外部系统回调 → Wait for Task Token</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img220013.png"></p><hr><h4 id="Step-Functions-Activity-Tasks"><a href="#Step-Functions-Activity-Tasks" class="headerlink" title="Step Functions Activity Tasks"></a>Step Functions Activity Tasks</h4><ul><li>Activity Task: 由 Activity Worker 执行的任务</li><li>Activity Worker 可以运行在任何地方 (EC2, Lambda, On-premises, 容器)</li><li>工作流程:<ol><li>Activity Worker 轮询 Step Functions 获取任务 (<code>GetActivityTask</code> API)</li><li>Worker 执行任务</li><li>Worker 返回结果 (<code>SendTaskSuccess</code> 或 <code>SendTaskFailure</code>)</li></ol></li><li>适用场景: 需要在 AWS 外部执行任务, 自定义处理逻辑</li><li>与 Lambda 集成的区别: Activity Worker 需要主动轮询, Lambda 由 Step Functions 调用</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img220441.png"></p><hr><h4 id="AWS-AppSync"><a href="#AWS-AppSync" class="headerlink" title="AWS AppSync"></a>AWS AppSync</h4><ul><li>托管的 GraphQL 服务, 简化 API 开发</li><li>使用 GraphQL 查询语言, 客户端指定需要的数据</li><li>支持实时数据同步:<ul><li>WebSocket: 实时订阅数据变更</li><li>MQTT on WebSocket: 轻量级实时通信</li></ul></li><li>数据源集成: DynamoDB, Lambda, RDS, HTTP APIs, OpenSearch</li><li>自动生成 GraphQL Schema 和 Resolvers</li><li>离线数据同步: 移动应用离线时缓存数据, 联网后自动同步</li><li>适用场景: 移动&#x2F;Web 应用, 实时协作应用, 聊天应用</li><li>考试提示: GraphQL + 实时数据 → AppSync</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img221024.png"></p><hr><h4 id="AWS-Amplify"><a href="#AWS-Amplify" class="headerlink" title="AWS Amplify"></a>AWS Amplify</h4><ul><li>用于创建移动和 Web 应用的完整开发平台 (类似 Google Firebase)</li><li>提供前端和后端服务集成:<ul><li><strong>Authentication (身份验证)</strong>: 集成 AWS Cognito, 提供用户注册、登录、MFA</li><li><strong>Datastore (数据存储)</strong>: 集成 AppSync 和 DynamoDB, 提供实时数据同步和离线支持</li><li><strong>Storage (存储)</strong>: 集成 S3, 提供文件上传下载</li><li><strong>API (GraphQL&#x2F;REST)</strong>: 集成 AppSync 和 API Gateway</li><li><strong>Functions (云函数)</strong>: 集成 Lambda</li><li><strong>Hosting (托管)</strong>: CI&#x2F;CD 部署, 自动构建和发布前端应用</li></ul></li><li>支持框架: React, Angular, Vue, Next.js, React Native, Flutter</li><li>Amplify Studio: 可视化开发环境, 拖拽创建 UI 和数据模型</li><li>Amplify CLI: 命令行工具, 快速配置后端资源</li><li>适用场景: 快速构建全栈应用, Serverless 移动&#x2F;Web 应用</li><li>考试提示: 快速构建移动&#x2F;Web 应用 → Amplify</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img22%EF%BC%96024.png"></p><hr><h3 id="27-Advanced-Identity"><a href="#27-Advanced-Identity" class="headerlink" title="27. Advanced Identity"></a>27. Advanced Identity</h3><h4 id="AWS-STS"><a href="#AWS-STS" class="headerlink" title="AWS STS"></a>AWS STS</h4><ul><li>STS (Security Token Service): 生成临时安全凭证访问 AWS 资源</li><li>授予有限且临时的访问权限 (默认 1 小时, 最长 12 小时)</li><li>主要 API:<ul><li><code>AssumeRole</code>: 跨账户访问或临时提升权限</li><li><code>AssumeRoleWithWebIdentity</code>: 使用 Web 身份提供商 (Google, Facebook) 登录</li><li><code>AssumeRoleWithSAML</code>: 使用 SAML 2.0 身份提供商</li><li><code>GetSessionToken</code>: 为 IAM 用户或 root 用户生成临时凭证 (需要 MFA)</li><li><code>GetFederationToken</code>: 为联合用户生成临时凭证</li></ul></li><li><strong>DecodeAuthorizationMessage</strong>:<ul><li>解码授权失败消息, 获取详细错误信息</li><li>考试提示: 看到 <code>decode-authorization-message</code> → STS API</li></ul></li><li>临时凭证有效期: 15 分钟到 12 小时 (默认 1 小时), 过期后需重新获取</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img230636.png"></p><hr><h4 id="Advanced-IAM"><a href="#Advanced-IAM" class="headerlink" title="Advanced IAM"></a>Advanced IAM</h4><ul><li><strong>策略评估逻辑 (Policy Evaluation Logic)</strong>:<ol><li>默认: Deny (隐式拒绝)</li><li>检查所有策略中是否有明确的 Deny → 有则直接 Deny</li><li>检查是否有 Allow → 有则 Allow</li><li>否则 Deny (隐式拒绝)</li></ol><ul><li>考试提示: Deny 优先级最高, 明确 Deny 无法被 Allow 覆盖</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img231838.png"></p><ul><li><strong>IAM Policies &amp; S3 Bucket Policies</strong>:<ul><li>同时评估 IAM Policy 和 S3 Bucket Policy</li><li>只要任一策略中有 Deny, 最终结果就是 Deny</li><li>需要 IAM 和 S3 策略都没有 Deny 且至少一个有 Allow, 才能访问</li><li>考试提示: 跨账户访问 S3 → IAM 和 Bucket Policy 都需要 Allow</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img232221.png"></p><ul><li><strong>动态策略 (Dynamic Policies)</strong>:<ul><li>使用策略变量为特定用户定制 IAM 策略</li><li>常用变量:<ul><li><code>$&#123;aws:username&#125;</code> - IAM 用户名</li><li><code>$&#123;aws:userid&#125;</code> - IAM 用户 ID</li><li><code>$&#123;aws:PrincipalTag/tag-key&#125;</code> - Principal 标签值</li><li><code>$&#123;aws:CurrentTime&#125;</code> - 当前时间</li></ul></li><li>示例: 限制用户只能访问 S3 中自己的文件夹 <code>home/$&#123;aws:username&#125;/*</code></li><li>考试提示: 用户特定权限 → 动态策略变量</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img232539.png"></p><hr><h4 id="IAM-Access-Analyzer"><a href="#IAM-Access-Analyzer" class="headerlink" title="IAM Access Analyzer"></a>IAM Access Analyzer</h4><ul><li>简化检查未使用的访问权限, 指导实现最小权限原则</li><li>功能:<ul><li>识别未使用的 IAM Roles, 用户, 访问密钥</li><li>删除不必要的权限, 降低安全风险</li><li>发现对资源和数据的意外访问 (如公开的 S3 Bucket, 跨账户访问)</li><li>持续监控并生成报告</li></ul></li><li>基于区域分析器 (Zone of Trust): 定义可信边界, 检测外部访问</li><li>考试提示: 移除未使用的 IAM 权限 → IAM Access Analyzer; 减少安全风险 → Access Analyzer</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img012837.png"></p><hr><h4 id="AWS-Directory-Services-AD"><a href="#AWS-Directory-Services-AD" class="headerlink" title="AWS Directory Services (AD)"></a>AWS Directory Services (AD)</h4><ul><li>托管的 Microsoft Active Directory 服务, 简化身份验证和资源管理</li><li><strong>三种类型</strong>:<ul><li><strong>AWS Managed Microsoft AD</strong>:<ul><li>在 AWS 中运行完整的 Microsoft AD</li><li>支持 MFA, 信任关系 (与本地 AD 双向信任)</li><li>适用场景: 需要完整 AD 功能, 云中 Windows 工作负载</li><li>考试提示: AD 在 AWS, 需要完整 AD 功能 → AWS Managed Microsoft AD</li></ul></li><li><strong>AD Connector</strong>:<ul><li>代理服务, 重定向到本地 AD (AD 保留在本地)</li><li>支持 MFA, 不存储用户凭证</li><li>适用场景: 保留本地 AD, AWS 资源使用本地 AD 身份验证</li><li>考试提示: AD 在本地, AWS 连接本地 AD → AD Connector</li></ul></li><li><strong>Simple AD</strong>:<ul><li>AWS 托管的轻量级 AD 兼容目录</li><li>不支持 MFA, 信任关系</li><li>适用场景: 小型 AD 需求, 低成本</li></ul></li></ul></li><li>集成: EC2 实例加入域, 支持 SSO, RDS SQL Server 身份验证</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img232910.png"></p><hr><h3 id="28-AWS-Security-amp-Encryption"><a href="#28-AWS-Security-amp-Encryption" class="headerlink" title="28. AWS Security &amp; Encryption"></a>28. AWS Security &amp; Encryption</h3><h4 id="Encryption-101"><a href="#Encryption-101" class="headerlink" title="Encryption 101"></a>Encryption 101</h4><ul><li><strong>传输中加密 (Encryption in Flight &#x2F; in Transit)</strong>:<ul><li>数据在发送前加密, 接收后解密</li><li>使用 SSL&#x2F;TLS 协议 (HTTPS)</li><li>防止中间人攻击 (Man-in-the-Middle Attack)</li></ul></li><li><strong>服务端加密 (Server-Side Encryption &#x2F; SSE)</strong>:<ul><li>数据在服务器端加密和解密</li><li>客户端发送明文数据, 服务器加密后存储</li><li>示例: S3 Server-Side Encryption</li></ul></li><li><strong>客户端加密 (Client-Side Encryption &#x2F; CSE)</strong>:<ul><li>数据在客户端加密, 服务器从不解密</li><li>服务器仅存储加密数据</li><li>客户端负责密钥管理</li><li>示例: S3 Client-Side Encryption</li></ul></li></ul><blockquote><p><strong>强制 S3 对象使用 SSL 请求</strong>: 使用 IAM Policy 条件 <code>aws:SecureTransport: true</code></p></blockquote><hr><h4 id="AWS-KMS"><a href="#AWS-KMS" class="headerlink" title="AWS KMS"></a>AWS KMS</h4><ul><li>KMS (Key Management Service): 托管的加密密钥服务</li><li>听到 AWS 服务的”加密” (encryption) → 大概率是 KMS</li><li>AWS 托管加密密钥: 适用于 EBS, S3, RDS, SSM 等 (无需手动创建)</li><li>KMS Keys 按区域 (Region) 隔离, 每个区域独立管理</li><li>自动密钥轮换 (Automatic Key Rotation): 每年轮换一次 (仅限 Customer Managed Keys)</li><li>KMS 不适合保存 Secret (如数据库密码), Secret 应使用 Secrets Manager</li><li>考试提示: 加密 ≠ Secret; KMS 用于加密, Secrets Manager 用于密钥管理</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img175137.png"></p><ul><li><p><strong>KMS Keys 类型 (3 种)</strong>:</p><ul><li><strong>AWS Owned Keys</strong>: AWS 拥有, 用于多个账户, 用户无法查看或管理</li><li><strong>AWS Managed Keys</strong>: AWS 管理, 用户可查看但不能管理, 免费</li><li><strong>Customer Managed Keys (CMK)</strong>: 用户创建和管理, 可设置策略和轮换, 按使用量收费</li></ul></li><li><p>KMS 存储 CMK, 接收客户端数据, 加密后返回密文</p></li><li><p><strong>密钥形式 (2 种)</strong>:</p><ul><li><strong>Symmetric (对称密钥)</strong>: 单一密钥, 加密和解密使用同一密钥, AWS 服务默认使用</li><li><strong>Asymmetric (非对称密钥)</strong>: 公钥 + 私钥对, 公钥加密, 私钥解密, 用于签名验证</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img171058.png"></p><ul><li><strong>KMS Key Policies (密钥策略)</strong>:<ul><li>类似 S3 Bucket Policies, 控制谁可以访问和使用 KMS Key</li><li>Default KMS Key Policy: 允许账户 root 用户完全访问</li><li>Custom KMS Key Policy: 定义特定用户&#x2F;角色的访问权限, 支持跨账户访问</li><li>考试提示: 跨账户访问 KMS Key → Custom KMS Key Policy</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img175606.png"></p><blockquote><p><strong>删除 KMS Key</strong>: 具有破坏性和危险性, AWS KMS 强制执行等待期 (Pending Deletion State, 7-30 天), 期间可以取消删除</p></blockquote><hr><h4 id="KMS-Envelope-Encryption"><a href="#KMS-Envelope-Encryption" class="headerlink" title="KMS Envelope Encryption"></a>KMS Envelope Encryption</h4><ul><li>KMS <code>Encrypt</code> API 限制: 最多加密 4 KB 数据</li><li>加密大于 4 KB 的数据 → 使用信封加密 (Envelope Encryption)</li><li><strong>工作原理</strong>:<ol><li>调用 <code>GenerateDataKey</code> API 生成数据加密密钥 (DEK)</li><li>KMS 返回明文 DEK 和加密的 DEK</li><li>使用明文 DEK 加密大文件 (客户端)</li><li>删除明文 DEK, 存储加密的 DEK 和加密文件</li><li>解密时: 调用 <code>Decrypt</code> API 解密 DEK, 再使用 DEK 解密文件</li></ol></li><li>信封加密将数据密钥引用为代码中的文件</li><li>考试提示: 加密大于 4 KB 数据 → Envelope Encryption</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img175943.png"></p><ul><li><strong>KMS Symmetric API 总结</strong>:<ul><li><code>Encrypt</code>: 加密最多 4 KB 数据</li><li><code>Decrypt</code>: 解密最多 4 KB 数据</li><li><code>GenerateDataKey</code>: 生成唯一的对称数据加密密钥 (DEK), 返回明文和密文</li><li><code>GenerateDataKeyWithoutPlaintext</code>: 生成 DEK 供以后使用, 仅返回密文</li><li><code>ReEncrypt</code>: 使用新的 KMS Key 重新加密数据, 无需先解密</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img180803.png"></p><hr><h4 id="KMS-Limits"><a href="#KMS-Limits" class="headerlink" title="KMS Limits"></a>KMS Limits</h4><ul><li>KMS 请求配额 (Request Quotas): 按区域和 API 限制</li><li>超出配额 → 收到 <code>ThrottlingException</code></li><li>配额示例: 每秒 5,500 - 30,000 次请求 (根据区域和 API 类型)</li><li>解决方案:<ul><li>使用数据加密密钥 (DEK) 在客户端加密, 减少 KMS API 调用</li><li>使用指数退避 (Exponential Backoff) 重试</li><li>通过 API 或 AWS Support 请求配额增加</li></ul></li><li>考试提示: KMS API 限流 → ThrottlingException; 减少 KMS 调用 → 使用 DEK 缓存</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img184019.png"></p><hr><h4 id="AWS-CloudHSM"><a href="#AWS-CloudHSM" class="headerlink" title="AWS CloudHSM"></a>AWS CloudHSM</h4><ul><li>托管的硬件安全模块 (Hardware Security Module) 服务</li><li>用户完全管理加密密钥 (AWS 无法访问密钥)</li><li>符合 FIPS 140-2 Level 3 安全标准</li><li>支持对称和非对称加密</li><li>部署在 VPC 中, 通过 ENI 访问</li><li>高可用性: 跨多个 AZ 部署</li><li>与 KMS 对比:<ul><li>KMS: AWS 管理密钥, 多租户, 更简单</li><li>CloudHSM: 用户管理密钥, 单租户, 更高安全性</li></ul></li><li>适用场景: 需要符合严格合规要求, 需要完全控制密钥</li><li>考试提示: 需要完全控制密钥 → CloudHSM</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img184859.png"></p><hr><h4 id="SSM-Parameter-Store"><a href="#SSM-Parameter-Store" class="headerlink" title="SSM Parameter Store"></a>SSM Parameter Store</h4><ul><li>安全的存储服务, 管理配置数据和密钥 (密码, 数据库字符串, License keys 等)</li><li>用途广泛: URLs, AMI IDs, License Keys, 配置参数 (比 Secrets Manager 更广)</li><li><strong>没有自动密钥轮换</strong> (与 Secrets Manager 的关键区别)</li><li><strong>内置版本跟踪</strong>: 每次编辑都会记录, 可回溯历史版本</li><li>三种参数类型:<ul><li>String: 普通字符串</li><li>StringList: 逗号分隔的字符串列表</li><li>SecureString: 使用 KMS 加密的敏感数据</li></ul></li><li>两个层级:<ul><li>Standard: 免费, 最多 10,000 个参数, 参数值最大 4 KB</li><li>Advanced: 收费, 最多 100,000 个参数, 参数值最大 8 KB, 支持参数策略</li></ul></li><li>集成: CloudFormation, EC2, Lambda, CodeBuild</li><li>考试提示: 配置管理 + 无需自动轮换 → SSM Parameter Store</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img173611.png"></p><hr><h4 id="AWS-Secrets-Manager"><a href="#AWS-Secrets-Manager" class="headerlink" title="AWS Secrets Manager"></a>AWS Secrets Manager</h4><ul><li>专门存储敏感信息 (数据库凭证, API Keys) 的托管服务</li><li><strong>与 RDS &amp; Aurora 深度集成</strong>: 自动轮换数据库凭证</li><li><strong>自动密钥轮换</strong>: 默认 90 天 (可自定义)</li><li>与 SSM Parameter Store 对比:<ul><li>Secrets Manager: 专注于密钥, 支持自动轮换, 更贵</li><li>SSM Parameter Store: 通用配置, 无自动轮换, 更便宜</li></ul></li><li>与 KMS 对比:<ul><li>KMS: 用于加密数据</li><li>Secrets Manager: 用于存储和管理密钥</li></ul></li><li>Lambda 轮换函数: 自动调用 Lambda 更新密钥</li><li>考试提示: 数据库凭证 + 自动轮换 → Secrets Manager; Secrets Manager 轮换 90 天, KMS 轮换 1 年</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img185726.png"></p><ul><li><strong>Multi-Region Secrets</strong>:<ul><li>跨多个 AWS 区域复制 Secrets</li><li>用于灾难恢复 (Disaster Recovery)</li><li>主 Secret 更新时自动同步到副本区域</li><li>类似 Multi-Region KMS Keys</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img174258.png"></p><hr><h4 id="CloudWatch-Logs-Encryption"><a href="#CloudWatch-Logs-Encryption" class="headerlink" title="CloudWatch Logs Encryption"></a>CloudWatch Logs Encryption</h4><ul><li>使用 KMS Keys 加密 CloudWatch Logs</li><li>加密在日志组 (Log Group) 级别启用, 关联 CMK</li><li><strong>两种配置方式</strong>:<ul><li><code>associate-kms-key</code>: 日志组已存在时使用 (考试重点)</li><li><code>create-log-group</code>: 创建新日志组时指定 KMS Key</li></ul></li><li>默认情况下 CloudWatch Logs 未加密</li><li>考试提示: 已存在的 CloudWatch Logs 加密 → associate-kms-key</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img190545.png"></p><hr><h4 id="AWS-Nitro-Enclaves"><a href="#AWS-Nitro-Enclaves" class="headerlink" title="AWS Nitro Enclaves"></a>AWS Nitro Enclaves</h4><ul><li>在隔离的计算环境中处理高度敏感数据</li><li>基于 Nitro Hypervisor, 提供 CPU 和内存隔离</li><li>无持久化存储, 无外部网络, 无交互式访问</li><li>使用加密证明 (Cryptographic Attestation) 验证 Enclave</li><li>适用场景: 处理个人身份信息 (PII), 医疗数据, 财务数据, 加密密钥处理</li><li>与主 EC2 实例通过本地安全通道通信</li><li>考试提示: 隔离环境处理敏感数据 → Nitro Enclaves</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img190809.png"></p><hr><h3 id="29-Other-AWS-Services"><a href="#29-Other-AWS-Services" class="headerlink" title="29. Other AWS Services"></a>29. Other AWS Services</h3><h4 id="AWS-SES-Simple-Email-Service"><a href="#AWS-SES-Simple-Email-Service" class="headerlink" title="AWS SES (Simple Email Service)"></a>AWS SES (Simple Email Service)</h4><ul><li>托管服务, 安全发送电子邮件</li><li>适用场景:<ul><li>营销邮件 (Marketing emails)</li><li>事务性邮件 (Transactional emails, 如订单确认)</li><li>批量邮件发送</li></ul></li><li>集成: Lambda, SNS, S3 (接收邮件)</li><li>支持 SMTP 接口和 API 调用</li><li>考试提示: 发送邮件 → SES</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img004334.png"></p><hr><h4 id="AWS-OpenSearch"><a href="#AWS-OpenSearch" class="headerlink" title="AWS OpenSearch"></a>AWS OpenSearch</h4><ul><li>托管的搜索和分析引擎 (原名 ElasticSearch)</li><li>支持全文搜索, 部分匹配 (Partial Matches), 任意字段搜索</li><li>适用场景:<ul><li>日志分析和可视化 (搭配 Kibana)</li><li>应用程序搜索 (搜索产品, 文档)</li><li>实时数据分析</li></ul></li><li>与 Athena 对比:<ul><li>OpenSearch: 实时搜索, 全文检索</li><li>Athena: 批量查询, SQL 分析 S3 数据</li></ul></li><li>考试提示: 全文搜索 + 部分匹配 → OpenSearch</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img192053.png"></p><hr><h4 id="AWS-Athena"><a href="#AWS-Athena" class="headerlink" title="AWS Athena"></a>AWS Athena</h4><ul><li>无服务器查询服务, 使用标准 SQL 分析 S3 数据</li><li><strong>无法实时分析数据</strong> (批量查询, 非流式处理)</li><li>按扫描数据量收费 → 使用列式格式 (Parquet, ORC) 节省成本</li><li>适用场景:<ul><li>处理日志 (CloudTrail, VPC Flow Logs, ALB Logs)</li><li>即席分析 (Ad-hoc analysis)</li><li>交互式查询 (Interactive queries)</li></ul></li><li>与其他服务对比:<ul><li>Athena: S3 数据 SQL 查询, 批量处理</li><li>OpenSearch: 实时搜索, 全文检索</li><li>Kinesis Data Analytics: 实时流数据 SQL 分析</li></ul></li><li>考试提示: S3 数据 + SQL 查询 → Athena; 实时分析 → 不用 Athena</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img192218.png"></p><ul><li><strong>Federated Query</strong>:<ul><li>跨数据源 SQL 查询 (AWS 或 On-Premise)</li><li>使用 Data Source Connectors (Lambda 函数)</li><li>支持: RDS, Aurora, Redshift, DynamoDB, On-Premise 数据库</li><li>查询结果可存储回 S3</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img200427.png"></p><hr><h4 id="AWS-MSK"><a href="#AWS-MSK" class="headerlink" title="AWS MSK"></a>AWS MSK</h4><ul><li>托管的 Apache Kafka 服务 (Managed Streaming for Apache Kafka)</li><li>支持 Serverless 模式和 Provisioned 模式</li><li>Kinesis 的替代方案, 处理流式数据 (Streaming Data)</li><li>与 Kinesis 对比:<ul><li>MSK: 完全兼容 Apache Kafka, 更灵活, 需要管理集群</li><li>Kinesis: AWS 原生, 更简单, 完全托管</li></ul></li><li>适用场景:<ul><li>已使用 Apache Kafka 的应用迁移到 AWS</li><li>需要 Kafka 生态系统工具 (Kafka Connect, Kafka Streams)</li><li>高吞吐量实时数据处理</li></ul></li><li>考试提示: Apache Kafka 迁移 → MSK; 简单流处理 → Kinesis</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img230056.png"></p><hr><h4 id="AWS-Certificate-Manager-ACM"><a href="#AWS-Certificate-Manager-ACM" class="headerlink" title="AWS Certificate Manager (ACM)"></a>AWS Certificate Manager (ACM)</h4><ul><li>托管 SSL&#x2F;TLS 证书服务, 保护网站和应用通信</li><li><strong>自动续订证书</strong> (仅限 ACM 颁发的证书)</li><li><strong>第三方证书无法自动续订</strong> (需手动导入和管理)</li><li>集成: ELB, CloudFront, API Gateway</li><li>免费使用 (公共证书)</li><li><strong>使用 EventBridge 监控证书过期</strong>:<ul><li>创建 EventBridge 规则监听 ACM 证书到期事件</li><li>触发 SNS 通知管理员</li><li>适用于第三方导入证书</li></ul></li><li>考试提示: SSL&#x2F;TLS 证书管理 → ACM; 第三方证书 → 无自动续订; 证书到期提醒 → EventBridge + SNS</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img174451.png"></p><hr><h4 id="AWS-Macie"><a href="#AWS-Macie" class="headerlink" title="AWS Macie"></a>AWS Macie</h4><ul><li>使用机器学习 (ML) 保护 S3 中的敏感数据</li><li>自动发现和分类敏感数据:<ul><li>个人身份信息 (PII): 姓名, 地址, 信用卡号</li><li>财务数据, 医疗数据, 知识产权</li></ul></li><li>生成安全发现 (Findings) 并发送到 EventBridge</li><li>集成: EventBridge → Lambda&#x2F;SNS (自动化响应)</li><li>适用场景: 合规性审计, 数据泄露防护, 敏感数据发现</li><li>考试提示: S3 敏感数据发现 → Macie; PII 保护 → Macie</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img192617.png"></p><hr><h4 id="AWS-AppConfig"><a href="#AWS-AppConfig" class="headerlink" title="AWS AppConfig"></a>AWS AppConfig</h4><ul><li>托管服务, 配置, 验证和部署动态配置</li><li>适用场景:<ul><li>应用程序功能开关 (Feature flags)</li><li>配置参数动态更新 (无需重启应用)</li><li>逐步推出配置更改 (Gradual rollout)</li></ul></li><li><strong>关键功能</strong>:<ul><li>配置验证: 部署前验证配置正确性</li><li>部署策略: 线性, 指数, 全量部署</li><li>回滚: 自动检测错误并回滚</li></ul></li><li>与 SSM Parameter Store 对比:<ul><li>AppConfig: 动态配置, 验证, 部署策略, 回滚</li><li>SSM Parameter Store: 静态配置存储, 版本跟踪</li></ul></li><li>集成: Lambda, ECS, EKS, EC2</li><li>考试提示: 动态配置 + 验证 + 部署策略 → AppConfig</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img192722.png"></p>]]></content>
      
      
      <categories>
          
          <category> Certification </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AWS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AWS SAA-C03</title>
      <link href="/posts/fa4ed4d8.html"/>
      <url>/posts/fa4ed4d8.html</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>官网: <a href="https://aws.amazon.com/certification/certified-solutions-architect-associate/">https://aws.amazon.com/certification/certified-solutions-architect-associate/</a></p><hr><h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><h3 id="1-AWS-Cloud-Overview"><a href="#1-AWS-Cloud-Overview" class="headerlink" title="1. AWS Cloud Overview"></a>1. AWS Cloud Overview</h3><h4 id="AWS-Regions"><a href="#AWS-Regions" class="headerlink" title="AWS Regions"></a>AWS Regions</h4><ul><li>A Region is a cluster of data centers 区域是数据中心集群<ul><li>Compliance(合规性) - 数据驻留和法规要求。</li><li>Proximity(距离) - 靠近用户,降低延迟。</li><li>Available Services(可用服务) - 并非所有服务在所有区域都可用。</li><li>Pricing(定价) - 不同区域价格可能不同。</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img231130.png"></p><hr><h4 id="AWS-Availability-Zone-AZ"><a href="#AWS-Availability-Zone-AZ" class="headerlink" title="AWS Availability Zone (AZ)"></a>AWS Availability Zone (AZ)</h4><ul><li>一个Region包含3-6个物理隔离的AZ,每个AZ有独立的电源、网络和连接。</li><li>跨账户协调AZ - 必须使用AZ ID(如use1-az1),因为AZ名称(如us-east-1a)在不同账户中映射到不同的物理位置。<ul><li>账户A的us-west-2a和账户B的us-west-2a可能是不同的物理AZ。</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img140727.png"></p><hr><h4 id="AWS-Edge-Locations"><a href="#AWS-Edge-Locations" class="headerlink" title="AWS Edge Locations"></a>AWS Edge Locations</h4><ul><li>在全球多个位置部署,用于内容分发和缓存。</li><li>离用户越近,交付速度越快,降低延迟。</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img140903.png"></p><hr><h3 id="2-IAM"><a href="#2-IAM" class="headerlink" title="2. IAM"></a>2. IAM</h3><h4 id="AWS-IAM"><a href="#AWS-IAM" class="headerlink" title="AWS IAM"></a>AWS IAM</h4><ul><li>Root Account(根账户) - 默认创建,拥有完全权限,不要与他人共享。</li><li>Users(用户) - 组织内的个人,可以属于多个组。</li><li>Groups(组) - 只能包含用户,不能包含其他组。</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img145736.png"></p><hr><h4 id="IAM-Permissions"><a href="#IAM-Permissions" class="headerlink" title="IAM Permissions"></a>IAM Permissions</h4><ul><li>定义用户或组的访问权限</li><li>最小权限原则(Least Privilege Principle) - 只授予完成任务所需的最小权限,避免过度授权。</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img160124.png"></p><hr><h4 id="IAM-Polices"><a href="#IAM-Polices" class="headerlink" title="IAM Polices"></a>IAM Polices</h4><ul><li><p>定义操作权限,与执行方法无关。</p></li><li><p>策略结构 - Statements 必须包含:</p><ul><li>Effect - Allow 或 Deny</li><li>Principal - 谁可以访问</li><li>Action - 允许或拒绝的操作</li><li>Resource - 作用于哪些资源</li></ul></li><li><p>Inline Policy (内联策略) - 直接分配给单个用户、组或角色的策略。</p></li></ul><p>注意: IAM 唯一支持的基于资源的策略是信任策略 (Trust Policy)。</p><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img175653.png"></p><hr><h4 id="IAM-MFA"><a href="#IAM-MFA" class="headerlink" title="IAM MFA"></a>IAM MFA</h4><ul><li>Protect Root Accounts and IAM Users 保护 Root 账户和 IAM 用户</li><li>MFA options:<ul><li>Virtual MFA Device (虚拟 MFA 设备) - 使用手机应用 (如 Google Authenticator、Authy)</li><li>U2F Security Key (U2F 安全密钥) - 物理 USB 设备 (如 YubiKey)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img180624.png"></p><hr><h4 id="IAM-CLI-amp-SDK"><a href="#IAM-CLI-amp-SDK" class="headerlink" title="IAM CLI &amp; SDK"></a>IAM CLI &amp; SDK</h4><p>访问 AWS 的三种方式</p><ul><li>AWS Management Console (控制台) - 网页界面</li><li>AWS CLI (命令行) - 终端命令行工具</li><li>AWS SDK (软件开发工具包) - 编程接口</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img193342.png"></p><ul><li>AWS CLI, AWS SDK 由 Access Keys 保护</li><li>考试技巧: 如果题目要求使用命令行设置属性 (如 DeleteOnTermination)、或不确定答案时,选择 CLI 选项。</li></ul><hr><h4 id="IAM-Roles"><a href="#IAM-Roles" class="headerlink" title="IAM Roles"></a>IAM Roles</h4><ul><li>授权 AWS 服务去做某些事 (比如 EB 需要 EC2 Role 和 Service Role)</li><li>常见的 Role<ul><li>EC2 Instance Role - 允许 EC2 实例访问其他 AWS 服务</li><li>Lambda Function Role - 授予 Lambda 函数执行权限</li><li>Service Role - 如 Elastic Beanstalk 需要 EC2 Role 和 Service Role</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img203306.png"></p><hr><h4 id="IAM-Security-Tools"><a href="#IAM-Security-Tools" class="headerlink" title="IAM Security Tools"></a>IAM Security Tools</h4><ul><li>IAM Credentials Report (凭证报告) - 账户级别报告,列出所有用户及其凭证状态 (密码、访问密钥、MFA 等)。</li><li>IAM Access Advisor (访问顾问) - 用户级别工具,显示用户被授予的服务权限和最后访问时间。</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img203553.png"></p><hr><h4 id="IAM-Extra"><a href="#IAM-Extra" class="headerlink" title="IAM Extra"></a>IAM Extra</h4><ul><li>Trust Policy (信任策略) - IAM 唯一的基于资源的策略,定义哪些主体可以担任该角色。</li><li>AWS Organizations SCP (服务控制策略) - 针对 Organization 的策略,指定组织或 OU 的最大权限,限制成员账户能做什么。</li><li>Access Control List (ACL, 访问控制列表) - 管理其他账户的主体对资源的访问权限,控制跨账户访问。</li><li>Permissions Boundary (权限边界) - 设置 IAM 实体 (用户或角色) 通过身份策略可以获得的最大权限上限。</li></ul><hr><h3 id="3-EC2-Fundamentals"><a href="#3-EC2-Fundamentals" class="headerlink" title="3. EC2 Fundamentals"></a>3. EC2 Fundamentals</h3><h4 id="AWS-EC2-Elastic-Compute-Cloud"><a href="#AWS-EC2-Elastic-Compute-Cloud" class="headerlink" title="AWS EC2 (Elastic Compute Cloud)"></a>AWS EC2 (Elastic Compute Cloud)</h4><ul><li>属于 Infrastructure as a Service (IaaS),绑定到特定 AZ。</li><li>User Data (用户数据) - EC2 启动时自动运行的脚本 (如安装 Apache)。<ul><li>默认只在首次启动时运行</li><li>默认以 root 用户权限执行</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img214749.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img214956.png"></p><ul><li>SSH 连接 - 使用 EC2 实例的公网 IP 地址连接。</li><li>Instance Metadata (实例元数据) - 通过特殊 IP 获取实例信息:<ul><li><a href="http://169.254.169.254/latest/meta-data/public-ipv4">http://169.254.169.254/latest/meta-data/public-ipv4</a> - 获取公网 IP</li><li>记住 169 这个数字</li></ul></li></ul><hr><h4 id="EC2-Instance-Type"><a href="#EC2-Instance-Type" class="headerlink" title="EC2 Instance Type"></a>EC2 Instance Type</h4><ul><li><p>一共 7 种 EC2 Instance Type, 但 4 种用的最多</p><ul><li>General Purpose, Compute Optimized, Memory Optimized, Storage Optimized</li></ul></li><li><p>General Purpose (通用型) - 平衡的计算、内存和网络资源,适合 Web 服务器、代码仓库。</p></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img221846.png"></p><ul><li>Compute Optimized (计算优化型) - 高性能处理器,适合批处理 (Batch)、媒体转码、高性能计算 (HPC)、科学建模。</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img221936.png"></p><ul><li>Memory Optimized (内存优化型) - 大内存处理,适合内存数据库、分布式缓存、实时大数据分析。</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img222020.png"></p><ul><li>Storage Optimized (存储优化型) - 本地存储的高速读写,适合 OLTP 系统、NoSQL 数据库、数据仓库。</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img222129.png"></p><hr><h4 id="EC2-Security-Groups"><a href="#EC2-Security-Groups" class="headerlink" title="EC2 Security Groups"></a>EC2 Security Groups</h4><ul><li>Control how traffic is allowed into or out of EC2 instance (控制 EC2 实例的入站和出站流量,类似防火墙)<ul><li>Can be attached to multiple instances (可以附加到多个实例,可复用)</li><li>Locked down to Region &#x2F; VPC 锁定到特定 Region &#x2F; VPC</li></ul></li><li>默认拒绝所有入站流量,允许所有出站流量</li><li>Inbound Rule (入站规则) 来源可以是: IP address (IP 地址), CIDR block (CIDR 块) , Security Group (安全组)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img222531.png"></p><hr><h4 id="EC2-Instance-Purchasing-Options"><a href="#EC2-Instance-Purchasing-Options" class="headerlink" title="EC2 Instance Purchasing Options"></a>EC2 Instance Purchasing Options</h4><ul><li>On-Demand Instances (按需实例) - 按秒计费,适合短期紧急使用,无需承诺。</li><li>Reserved Instances (预留实例) - 1-3 年,最高 72% 折扣,在 AZ 中预留容量。<ul><li>Standard RI - 固定实例类型,折扣随年限增加</li><li>Convertible RI - 可更改实例类型,66% 折扣</li></ul></li><li>Savings Plans (储蓄计划) - 1-3 年,承诺使用量,最高 72% 折扣,超出承诺按 On-Demand 计费。<ul><li>Compute Savings Plan - 66% 折扣,支持 Lambda 和 Fargate</li></ul></li><li>Spot Instances (竞价实例) - 最便宜,90% 折扣,但可能随时被中断,适合容错工作负载。</li><li>Dedicated Host (专用主机) - 最贵,完全控制物理服务器和实例放置,满足合规要求。</li><li>Dedicated Instance (专用实例) - 硬件专用但不完全锁定给你,与其他账户隔离。</li><li>Capacity Reservation (容量预留) - 在 AZ 中预留容量,适合每天只需几小时 EC2 的场景。</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img224149.png"></p><hr><h4 id="EC2-Spot-Instance"><a href="#EC2-Spot-Instance" class="headerlink" title="EC2 Spot Instance"></a>EC2 Spot Instance</h4><p>使用 AWS 闲置容量的低价实例</p><ul><li>取消规则<ul><li>只能在 open、active 或 disabled 状态下取消 Spot 请求</li><li>必须先取消请求,再终止实例 (Cancel ≠ Terminate)</li></ul></li><li>请求类型<ul><li>One-time (一次性) - 满足后请求自动关闭</li><li>Persistent (持久性) - 实例中断后自动重新请求</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img225943.png"></p><ul><li>Spot Fleets (竞价集群) - 自动请求最低价格的 Spot 实例,可混合 Spot + On-Demand。<ul><li>自动获取最便宜的 Spot 实例</li><li>维持目标容量,保证一定数量的实例运行</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img230258.png"></p><hr><h3 id="4-EC2-SAA-Level"><a href="#4-EC2-SAA-Level" class="headerlink" title="4. EC2 SAA Level"></a>4. EC2 SAA Level</h3><h4 id="Elastic-IP"><a href="#Elastic-IP" class="headerlink" title="Elastic IP"></a>Elastic IP</h4><p>IP 地址类型</p><ul><li>Public IP (公网 IP) - 全网唯一,EC2 重启后会改变</li><li>Private IP (私网 IP) - 私有网络内唯一,重启后不变</li><li>Elastic IP (弹性 IP) - 固定的公网 IP,绑定到账户,重启后不变</li></ul><p>为什么需要 Elastic IP</p><ul><li>EC2 的公网 IP 会在停止&#x2F;重启后改变</li><li>Elastic IP 可以快速重新映射到另一个实例</li><li>使用 Private IP 在私有网络内通信可以节省成本</li></ul><p>注意: 未使用的 Elastic IP 会产生费用,建议使用负载均衡器或 DNS 代替。</p><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img165706.png"></p><hr><h4 id="EC2-Placement-Groups"><a href="#EC2-Placement-Groups" class="headerlink" title="EC2 Placement Groups"></a>EC2 Placement Groups</h4><ul><li>控制实例在物理硬件上的分布策略。</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img170342.png"></p><p>Cluster (集群) - 单个 AZ 内低延迟高吞吐,适合 HPC (高性能计算)。</p><ul><li>优点:网速快,低延迟</li><li>缺点:AZ 故障时所有实例都受影响</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img170525.png"></p><p>Spread (分散) - 高可用性,关键应用,实例分布在不同物理硬件。</p><ul><li>优点:风险小,硬件故障隔离</li><li>缺点:每个 AZ 最多 7 个实例</li><li>适合少量关键实例需要相互隔离的场景</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img170652.png"></p><p>Partition (分区) - 在 AZ 内将实例分散到多个分区,每个分区有独立硬件。</p><ul><li>每个 AZ 最多 7 个分区</li><li>每个分区可有多个实例,总数可达 100+</li><li>可跨多个 AZ</li><li>优点:风险小,限制低</li><li>适合大数据应用 (Hadoop、Cassandra、Kafka)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img170936.png"></p><hr><h4 id="Elatic-Network-Interfaces-ENI-弹性网络接口"><a href="#Elatic-Network-Interfaces-ENI-弹性网络接口" class="headerlink" title="Elatic Network Interfaces (ENI, 弹性网络接口)"></a>Elatic Network Interfaces (ENI, 弹性网络接口)</h4><ul><li>VPC 中的虚拟网卡</li><li>可以附加到 EC2 实例,提供网络连接</li><li>绑定到特定 AZ,不能跨 AZ 使用</li><li>可以在实例间移动,实现故障转移</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img182407.png"></p><hr><h4 id="EC2-Hibernate"><a href="#EC2-Hibernate" class="headerlink" title="EC2 Hibernate"></a>EC2 Hibernate</h4><ul><li>EC2 Hibernate: 加速 EC2 实例启动</li><li>将内存 (RAM) 状态保存到 EBS 卷, 再次启动时从保存的状态恢复,而不是重新启动</li><li>要求: Root Volume 必须是 EBS 卷</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img183846.png"></p><hr><h3 id="5-EC2-Instance-Storage"><a href="#5-EC2-Instance-Storage" class="headerlink" title="5. EC2 Instance Storage"></a>5. EC2 Instance Storage</h3><h4 id="AWS-EBS-Elastic-Block-Store"><a href="#AWS-EBS-Elastic-Block-Store" class="headerlink" title="AWS EBS (Elastic Block Store)"></a>AWS EBS (Elastic Block Store)</h4><ul><li>类似网络硬盘,可以附加到 EC2 实例</li><li>绑定到特定 AZ,不能跨 AZ 使用</li><li>可移植性: 可以从一个 EC2 实例卸载,附加到同 AZ 内另一个实例</li><li>Root Volume (根卷) - 默认在实例终止时删除</li><li>Other EBS Volumes (其他卷) - 默认在实例终止时不删除</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img191440.png"></p><hr><h4 id="EBS-Snapshots"><a href="#EBS-Snapshots" class="headerlink" title="EBS Snapshots"></a>EBS Snapshots</h4><ul><li>Make a backup of EBS volume (备份 EBS)</li><li>可以将这个 snapshot 用在其他 AZ 或者 Region 上</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img195715.png"></p><ul><li>EBS Snapchot Archive: 便宜 75%</li><li>Recycle Bin: Setup rules to retain deleted snapshots (可以 recover)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img195833.png"></p><hr><h4 id="AWS-AMI-Amazon-Machine-Image"><a href="#AWS-AMI-Amazon-Machine-Image" class="headerlink" title="AWS AMI (Amazon Machine Image)"></a>AWS AMI (Amazon Machine Image)</h4><ul><li>预配置的 EC2 实例模板</li><li>为特定 Region 构建, 可以跨 Region 复制</li><li>当 AMI 从 Region A 复制到 Region B 时,会自动在 Region B 创建快照 (Snapshot)。</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img200249.png"></p><hr><h4 id="EC2-Instance-Store"><a href="#EC2-Instance-Store" class="headerlink" title="EC2 Instance Store"></a>EC2 Instance Store</h4><ul><li>Block-level storage, 物理硬盘 (Physical drive, temporary storage)</li><li>High random I&#x2F;O performance, good for cache &amp; buffer at low cost (重要)</li><li>EC2 Instance Store lose when stopped (Ephemeral, 数据在 Instance Store 关闭时消失)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img203146.png"></p><ul><li>不能从一个实例卸载并附加到另一个实例</li><li>从实例创建 AMI 时,Instance Store 上的数据不会被保留</li><li>实例重启数据保留,但停止或故障数据丢失</li></ul><blockquote><p>适合需要高性能临时存储的场景,不适合持久化数据。</p></blockquote><hr><h4 id="EBS-Volume-Types"><a href="#EBS-Volume-Types" class="headerlink" title="EBS Volume Types"></a>EBS Volume Types</h4><p>General Purpose SSD (gp2 &#x2F; gp3) - 通用型,性价比高。</p><ul><li>平衡的价格和性能</li><li>适合大多数工作负载</li></ul><p>Provisioned IOPS SSD (io1 &#x2F; io2) - 高性能 SSD。</p><ul><li>比 gp 贵,但 IOPS 更高</li><li>支持 Multi-Attach (多个 EC2 同时挂载)</li><li>适合关键业务应用和数据库</li></ul><p>Hard Disk Drives (HDD) - 机械硬盘,吞吐量优化。</p><ul><li>st1 (Throughput Optimized) - 数据密集型工作负载</li><li>sc1 (Cold HDD) - 访问频率低的数据</li><li>不能用作 EC2 启动卷</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img203437.png"></p><blockquote><p>所有类型都不超过 300,000 IOPS。</p></blockquote><hr><h4 id="EBS-Multi-Attach"><a href="#EBS-Multi-Attach" class="headerlink" title="EBS Multi-Attach"></a>EBS Multi-Attach</h4><ul><li>将同一个 EBS 卷同时挂载到多个 EC2 实例<ul><li>只支持同一个 AZ 内的实例</li><li>仅适用于 io1 &#x2F; io2 家族 (Provisioned IOPS SSD)</li></ul></li><li>实现高可用性集群应用, 多个实例需要同时访问相同数据</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img203956.png"></p><hr><h4 id="EBS-Encryption"><a href="#EBS-Encryption" class="headerlink" title="EBS Encryption"></a>EBS Encryption</h4><ul><li>全链路加密保护<ul><li>静态数据加密 (Data at rest)</li><li>传输中数据加密 (Data in flight)</li><li>快照加密 (Snapshot)</li><li>从加密快照创建的卷也自动加密</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img204137.png"></p><p>加密未加密卷的步骤</p><ul><li>为未加密卷创建快照 (Snapshot)</li><li>加密该快照 (复制快照时启用加密)</li><li>从加密快照创建新的 EBS 卷</li><li>将新的加密卷附加到原实例</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img204208.png"></p><blockquote><p>使用 AWS KMS 密钥管理,对性能影响minimal。</p></blockquote><hr><h4 id="EBS-RAID-磁盘阵列"><a href="#EBS-RAID-磁盘阵列" class="headerlink" title="EBS RAID (磁盘阵列)"></a>EBS RAID (磁盘阵列)</h4><blockquote><p>组合多个 EBS 卷以提升性能或容错</p></blockquote><p>RAID 0 (条带化) - 优先考虑 I&#x2F;O 性能。</p><ul><li>将数据分散到多个卷,提高吞吐量和 IOPS</li><li>无冗余,一个卷故障则全部数据丢失</li><li>适合需要高性能但不关键的数据</li></ul><p>RAID 1 (镜像) - 优先考虑容错能力 (fault tolerance)。</p><ul><li>数据在多个卷上镜像复制</li><li>提供冗余,一个卷故障不影响数据</li><li>性能提升有限,但可靠性高</li><li>适合关键数据保护</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/imgpt6-q37-i1.jpg"></p><blockquote><p>选择取决于优先级:性能选 RAID 0,可靠性选 RAID 1。Retry</p></blockquote><hr><h4 id="AWS-EFS-Elastic-File-System"><a href="#AWS-EFS-Elastic-File-System" class="headerlink" title="AWS EFS (Elastic File System)"></a>AWS EFS (Elastic File System)</h4><ul><li>托管的 NFS 网络文件系统<ul><li>可挂载到多个 EC2 实例,支持并发访问</li><li>自动扩展容量,无需容量规划</li><li>可跨 AZ、Region 和 VPC 访问 (重要)</li><li>使用 VPC Security Group 或 IAM Policy 控制访问</li></ul></li><li>EFS-IA (Infrequent Access) - 低成本存储层,适合不常访问的数据,支持 POSIX。</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img233415.png"></p><ul><li>NFS 有 2 种 Performance Mode<ul><li>General Purpose - 默认,低延迟 (Web 服务器)</li><li>Max I&#x2F;O - 高延迟但高吞吐量和并行性 (Big Data、媒体处理)</li></ul></li><li>NFS 有 3 种 Throughput Mode (重要)<ul><li>Bursting - 突发模式,快速但有限制</li><li>Provisioned - 设置固定吞吐量上限 (大量文件迁移时使用)</li><li>Elastic - 根据工作负载自动扩展</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img233732.png"></p><blockquote><p>成本对比 (100GB 文件): EBS &gt; EFS &gt; S3 (价格从高到低)</p></blockquote><hr><h3 id="6-ELB-amp-ASG"><a href="#6-ELB-amp-ASG" class="headerlink" title="6. ELB &amp; ASG"></a>6. ELB &amp; ASG</h3><h4 id="Scalability-amp-High-Availability"><a href="#Scalability-amp-High-Availability" class="headerlink" title="Scalability &amp; High Availability"></a>Scalability &amp; High Availability</h4><ul><li>Vertical (竖直) Scale: Increase the size of the Instance (但是有 hardware limit)</li><li>Horizontal (水平) Scale: Increase the number of the Instance</li><li>High Availability: Rrunning application in at least 2 AZ (Disaster recovery, DR, 重要)</li></ul><hr><h4 id="AWS-ELB-Elastic-Load-Balancer"><a href="#AWS-ELB-Elastic-Load-Balancer" class="headerlink" title="AWS ELB (Elastic Load Balancer)"></a>AWS ELB (Elastic Load Balancer)</h4><ul><li>负载均衡器,分发流量到多个 EC2 实例。</li><li>跨 AZ 实现高可用性,处理下游实例故障。Health Check 检测实例健康状态 (ASG 用 EC2 based,ALB 用 ALB based)。</li><li>ELB 部署在 public subnet,ASG 部署在 private subnet。ELB 不能跨 Region 分发流量。</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img141400.png"></p><p>三种类型</p><ul><li>ALB (Application Load Balancer) - HTTP&#x2F;HTTPS,Layer 7,提供静态 DNS</li><li>NLB (Network Load Balancer) - TCP&#x2F;UDP,Layer 4,提供静态 DNS 和静态 IP,超高性能</li><li>GWLB (Gateway Load Balancer) - Layer 3,用于安全设备 (防火墙、IDS&#x2F;IPS,要特别注意)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img090125.png"></p><hr><h4 id="Application-Load-Balancer-ALB"><a href="#Application-Load-Balancer-ALB" class="headerlink" title="Application Load Balancer (ALB)"></a>Application Load Balancer (ALB)</h4><ul><li>Layer 7 负载均衡器,处理 HTTP&#x2F;HTTPS 流量。</li><li>路由功能: 基于 Path (&#x2F;home)、Hostname、Query String (?platform&#x3D;mobile)、Headers 或 Client IP 路由到不同目标组。<ul><li>添加 “X-Forwarded-For” header 包含客户端真实 IP</li><li>可配置 HTTP 到 HTTPS 的自动重定向 (重要)</li><li>无法分配 Elastic IP</li></ul></li><li>Target Groups (目标组): EC2 实例、ECS 任务、Lambda 函数、IP 地址。</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img192523.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img142631.png"></p><blockquote><p>通过 listener rule 实现流量重定向和路由策略。</p></blockquote><hr><h4 id="Network-Load-Balancer-NLB"><a href="#Network-Load-Balancer-NLB" class="headerlink" title="Network Load Balancer (NLB)"></a>Network Load Balancer (NLB)</h4><ul><li>Layer 4 负载均衡器,处理 TCP&#x2F;UDP 流量。</li><li>性能特点: 速度极快,处理大量请求,最适合低延迟和高吞吐量场景 (如银行、游戏应用)。</li><li>静态 IP 支持: 每个 AZ 一个静态 IP,或可使用 Elastic IP (这是 NLB 独有特性)。</li><li>Health Checks: 支持 HTTP、TCP 和 HTTPS 健康检查。</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img144359.png"></p><blockquote><p>路由规则: 如果使用实例 ID 指定目标,流量会路由到实例主网络接口的主私有 IP 地址。</p></blockquote><hr><h4 id="Gateway-Load-Balancer-GWLB"><a href="#Gateway-Load-Balancer-GWLB" class="headerlink" title="Gateway Load Balancer (GWLB)"></a>Gateway Load Balancer (GWLB)</h4><ul><li>Layer 3 负载均衡器,专门用于安全和第三方网络设备。</li><li>用途: 在多个 spoke VPC 中以简化和可扩展的方式执行流量的内联检查 (inline inspection)。部署第三方安全设备如防火墙、IDS&#x2F;IPS、深度包检测系统。</li><li>协议: 使用 GENEVE 协议,端口 6081。</li><li>实现透明网络流量检查,所有流量先经过安全设备处理后再转发到目标。</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img223042.png"></p><hr><h4 id="Sticky-Sessions-Session-Affinity"><a href="#Sticky-Sessions-Session-Affinity" class="headerlink" title="Sticky Sessions (Session Affinity)"></a>Sticky Sessions (Session Affinity)</h4><ul><li>同一客户端始终路由到负载均衡器后的同一实例。</li><li>用途: 确保用户不会丢失会话数据 (如登录状态、购物车信息)。</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img223425.png"></p><p>Cookie 类型</p><ul><li>Application-based Cookies (应用 Cookie) - 自定义 Cookie 名称,不能使用 AWSALB、AWSALBAPP、AWSALBTG 这些保留名称。</li><li>Duration-based Cookies (基于持续时间的 Cookie) - ALB 使用 AWSALB,CLB 使用 AWSELB。</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img223604.png"></p><blockquote><p>通过 Cookie 实现会话保持,但可能导致后端实例负载不均衡。</p></blockquote><hr><h4 id="Cross-Zone-Load-Balancing"><a href="#Cross-Zone-Load-Balancing" class="headerlink" title="Cross Zone Load Balancing"></a>Cross Zone Load Balancing</h4><ul><li>ELB 在所有 AZ 的所有已注册实例之间均匀分配流量。<ul><li>启用时: 所有实例收到的流量完全相同,无论在哪个 AZ。</li><li>未启用时: 流量先在 AZ 之间平均分配,然后在每个 AZ 内部的实例间平均分配,可能导致实例负载不均。</li></ul></li><li>ALB 默认启用,NLB 默认禁用。</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img230059.png"></p><hr><h4 id="SSL-Certificates"><a href="#SSL-Certificates" class="headerlink" title="SSL Certificates"></a>SSL Certificates</h4><ul><li>允许客户端和负载均衡器之间的流量加密传输 (HTTPS)。</li><li>使用 ACM (AWS Certificate Manager) 管理 SSL 证书。</li><li>SNI (Server Name Indication) - 在一个 Web 服务器上加载多个 SSL 证书。<ul><li>如果题目涉及管理多个 SSL 或 TLS 证书,选择 SNI。</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img230614.png"></p><ul><li>ALB 和 NLB 都支持 SNI,CLB 不支持。通过 SNI 可以在单个负载均衡器上托管多个域名的 HTTPS 应用。</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img230910.png"></p><hr><h4 id="Connection-Draining"><a href="#Connection-Draining" class="headerlink" title="Connection Draining"></a>Connection Draining</h4><ul><li>等待现有连接完成后再注销实例。</li><li>当实例取消注册或变为不健康状态时,负载均衡器停止向该实例发送新请求,但允许已有的进行中请求完成。</li><li>确保用户请求不会中断,优雅地移除实例。可配置超时时间 (1-3600 秒,默认 300 秒)。</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img231418.png"></p><hr><h4 id="AWS-ASG-Auto-Scaling-Group"><a href="#AWS-ASG-Auto-Scaling-Group" class="headerlink" title="AWS ASG (Auto Scaling Group)"></a>AWS ASG (Auto Scaling Group)</h4><ul><li>自动扩展组,根据需求自动调整 EC2 实例数量,服务免费。</li><li>核心功能: 与 ELB 配合,基于服务器压力自动 scale out&#x2F;in。保证最少 (min) 和最多 (max) 实例数量。在 Region 内根据可用 AZ 进行扩展。</li><li>实例管理: 当实例 unhealthy 时,ASG 会终止并替换该实例。在单个 AZ 内,优先终止最早启动的实例。</li><li>终止策略<ul><li>不均衡情况 - 先启动新实例,再终止旧实例</li><li>不健康情况 - 先终止不健康实例,再创建新实例</li></ul></li><li>Scheduled Action: 如果需要在特定时间 (如节日前) 扩展,使用 ASG scheduled action。</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img232350.png"></p><ul><li><p>Launch Template vs Launch Configuration:</p><ul><li>Launch Template - 定义生成什么类型的实例 (Spot、On-Demand 等),支持版本控制</li><li>Launch Configuration - 定义实例配置信息 (AMI、Security Group 等),不可修改</li></ul></li><li><p>更新 Launch Template: 需要创建新版本,无需删除旧版本。</p></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img232823.png"></p><ul><li>ASG 不 terminate Instance 的情况<ul><li>The health check grace period for the instance has not expired 健康检查宽限期未过期</li><li>The instance maybe in Impaired status 实例处于 Impaired 状态</li><li>The instance has failed the Elastic Load Balancing (ELB) health check status 实例未通过 ELB 健康检查</li></ul></li></ul><hr><h4 id="Scaling-Policies"><a href="#Scaling-Policies" class="headerlink" title="Scaling Policies"></a>Scaling Policies</h4><blockquote><p>ASG 自动调整实例数量的规则。</p></blockquote><p>Dynamic Scaling (动态扩展)</p><ul><li>Target Tracking Scaling - 根据目标指标自动调整,如保持 CPU 使用率在 50%,或根据 SQS 队列长度扩展。</li><li>Simple&#x2F;Step Scaling - 与 CloudWatch Alarm 关联,当告警触发时按步骤增加或减少实例。</li><li>Scheduled Actions - 基于时间表扩展,如在感恩节或黑色星期五提前增加容量。</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img233532.png"></p><p>Predictive Scaling (预测性扩展) </p><ul><li>使用机器学习预测未来负载,提前安排扩展计划,适合有规律的流量模式。</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img233711.png"></p><hr><h3 id="7-AWS-Fundamentals"><a href="#7-AWS-Fundamentals" class="headerlink" title="7. AWS Fundamentals"></a>7. AWS Fundamentals</h3><h4 id="AWS-RDS-Amazon-Relational-Database-Service"><a href="#AWS-RDS-Amazon-Relational-Database-Service" class="headerlink" title="AWS RDS (Amazon Relational Database Service)"></a>AWS RDS (Amazon Relational Database Service)</h4><ul><li>使用 RDS 的优势 (对比在 EC2 上自建数据库)<ul><li>自动配置、自动扩展、自动备份</li><li>支持 Read Replicas (最多 15 个) 和 Multi-AZ</li></ul></li><li>RDS Reserved Instances - 类似 EC2 RI,提供成本优惠。</li><li>RDS Read Replica (只读副本) - 提高读取性能,不是扩展存储容量。<ul><li>主数据库加密时,副本也自动加密</li><li>适合报表、分析等读密集型工作负载</li><li>不提供高可用性 (Multi-AZ 才是)</li><li>Cross-Region Read Replica - 灾难发生时可作为数据库备份</li></ul></li><li>RDS Multi-AZ (多可用区) - 提供高可用性<ul><li>同步复制数据到不同 AZ 的备用实例</li><li>主库故障时自动切换到备用库</li><li>更新时主库和备用库一起更新 (会有短暂停机)</li></ul></li><li>支持的数据库引擎: MySQL、PostgreSQL、MariaDB、Oracle、MS SQL Server、Amazon Aurora。</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img161720.png"></p><ul><li>Storage Auto Scaling (存储自动扩展)<ul><li>适合工作负载不可预测的应用。</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img161952.png"></p><ul><li>灾难恢复策略<ul><li>在不同 Region 创建 Read Replica,并在该副本上启用 Multi-AZ</li></ul></li><li>IAM Database Authentication - 可以使用 IAM 凭证访问 RDS。</li><li>迁移路径: 可以从 RDS Read Replica 迁移到 Aurora Read Replica,最小化变更。</li></ul><hr><h4 id="Read-Replicas-vs-Multi-AZ"><a href="#Read-Replicas-vs-Multi-AZ" class="headerlink" title="Read Replicas vs. Multi AZ"></a>Read Replicas vs. Multi AZ</h4><ul><li>Read Replicas (只读副本) - 提升可扩展性和读取性能。<ul><li>异步复制 (Async Replication)</li><li>可在同一 AZ、跨 AZ 或跨 Region 部署</li><li>同 Region 内复制免费,跨 Region 复制收费</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img173522.png"></p><ul><li>用途:生产数据库处理日常操作,Read Replica 处理数据分析和报表</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img173820.png"></p><ul><li>Multi-AZ (多可用区) - 提供高可用性和灾难恢复。<ul><li>同步复制 (Sync Replication)</li><li>主数据库故障时,RDS 自动将 CNAME 更新指向备用数据库</li><li>应用无需修改连接字符串,自动故障转移</li><li>不用于扩展读取性能,仅用于容错</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img174148.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img174357.png"></p><blockquote><p>关键区别: Read Replicas 侧重性能,Multi-AZ 侧重可用性。</p></blockquote><hr><h4 id="RDS-Custom"><a href="#RDS-Custom" class="headerlink" title="RDS Custom"></a>RDS Custom</h4><ul><li>可以访问底层数据库和操作系统。</li><li>仅支持 Oracle 和 Microsoft SQL Server。</li><li>适合需要自定义配置、安装补丁或特殊软件的场景,同时保留 RDS 的部分托管优势。</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img174702.png"></p><hr><h4 id="AWS-Aurora"><a href="#AWS-Aurora" class="headerlink" title="AWS Aurora"></a>AWS Aurora</h4><ul><li>AWS 专有的高性能关系型数据库。<ul><li>支持 PostgreSQL 和 MySQL 兼容</li><li>无需管理存储,自动扩展</li><li>通常比 RDS 快 5 倍 (MySQL) 或 3 倍 (PostgreSQL)</li></ul></li><li>Aurora Serverless - 自动启动、关闭和扩展容量,适合间歇性、不可预测的工作负载。</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img183915.png"></p><ul><li>高可用性和读取扩展 (Aurora Read Replica)<ul><li>1 个主实例 (写入) + 最多 15 个只读副本 &#x3D; 共 16 个实例</li><li>Aurora 没有 standby database,Aurora Replica 可作为故障转移目标</li><li>Replica 按 Tier (优先级) 排序,故障时优先级高的被提升为主实例</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img184105.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img184221.png"></p><p>考试要点</p><ul><li>网络请求激增 → 选择 Aurora Replica</li><li>Aurora Auto-Scaling → 选择 Aurora Serverless</li><li>测试数据库 (Test Database) → 选择 Aurora Database Cloning (快速克隆,成本低)</li></ul><hr><h4 id="Aurora-Advanced"><a href="#Aurora-Advanced" class="headerlink" title="Aurora Advanced"></a>Aurora Advanced</h4><ul><li>Aurora Replicas Auto Scaling (副本自动扩展) <ul><li>类似 EC2 Auto Scaling,根据负载自动增减副本数量。</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img184516.png"></p><ul><li>Aurora Custom Endpoints (自定义端点) <ul><li>为特定副本子集创建端点,可在特定副本上运行数据分析,避免影响生产工作负载。</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img184559.png"></p><ul><li>Aurora Serverless (无服务器) - 自动实例化数据库和自动扩展容量 (重要)。<ul><li>适合间歇性、不可预测或开发测试工作负载</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img184700.png"></p><ul><li>Aurora Global (全球数据库) - 跨 Region 复制延迟小于 1 秒。<ul><li>保证至少有一个副本可用 (重要)</li><li>提供快速的本地读取和低延迟</li><li>适合全球分布式应用</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img184847.png"></p><ul><li>Aurora Machine Learning <ul><li>集成 SageMaker 和 Comprehend,直接在数据库中进行 ML 预测。</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img184942.png"></p><ul><li>Aurora Database Cloning (数据库克隆) - 快速创建数据库副本。<ul><li>比 snapshot &amp; restore 快得多</li><li>使用写时复制 (copy-on-write) 协议,节省存储</li><li>创建测试数据库时选择此方案</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img185556.png"></p><hr><h4 id="Backup-amp-Monitoring"><a href="#Backup-amp-Monitoring" class="headerlink" title="Backup &amp; Monitoring"></a>Backup &amp; Monitoring</h4><ul><li>RDS Backups (两种备份方式)<ul><li>Automated Backups (自动备份) - 每天自动备份,可设置保留期</li><li>Manual DB Snapshots (手动快照) - 用户手动触发,永久保留直到手动删除</li></ul></li><li>省钱技巧: 使用完数据库后创建 snapshot,然后终止数据库。需要时从 snapshot 恢复,避免持续运行成本。</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img185223.png"></p><ul><li>Aurora Backups (与 RDS 相同)<ul><li>Automated Backups - 每天自动备份</li><li>Manual DB Snapshots - 手动备份</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img185353.png"></p><ul><li>RDS &amp; Aurora Restore Options (恢复选项)<ul><li>基本方式 - 从 snapshot 恢复</li><li>从本地迁移 - 创建本地数据库备份,上传到 S3,从 S3 恢复到 RDS&#x2F;Aurora</li></ul></li><li>恢复会创建新的数据库实例,不会覆盖原有实例</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img185459.png"></p><hr><h4 id="RDS-Security"><a href="#RDS-Security" class="headerlink" title="RDS Security"></a>RDS Security</h4><ul><li>At-rest Encryption (静态加密) - 使用 AWS KMS (Key Management Service) 加密存储数据<ul><li>主数据库加密后,备份、快照和副本也自动加密</li></ul></li><li>In-flight Encryption (传输加密) - 使用 AWS TLS Certificates 加密传输中的数据。<ul><li>客户端和数据库之间的连接加密</li></ul></li><li>IAM Authentication (IAM 身份验证) - 使用 IAM 角色连接数据库,无需密码。<ul><li>更安全,集中管理访问权限</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img133048.png"></p><hr><h4 id="RDS-Proxy"><a href="#RDS-Proxy" class="headerlink" title="RDS Proxy"></a>RDS Proxy</h4><ul><li>在应用和 RDS&#x2F;Aurora 之间建立代理层</li><li>缓解数据库压力,最小化打开的连接数</li><li>允许应用共享和池化数据库连接,提高数据库效率</li><li>减少 RDS &amp; Aurora 故障转移时间最多 66%</li><li>无需修改代码 (重要)</li><li>Serverless,自动扩展, 高可用性 (Multi-AZ)</li><li>不可公开访问,必须通过 VPC 访问</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img184531.png"></p><hr><h4 id="AWS-ElastiCache"><a href="#AWS-ElastiCache" class="headerlink" title="AWS ElastiCache"></a>AWS ElastiCache</h4><ul><li>管理 Redis 或 Memcached, 解决数据库高频读取问题 (重要)</li><li>内存数据库,高性能低延迟,适合计算密集型场景</li><li>减轻数据库读密集型工作负载的压力</li><li>帮助应用实现无状态架构</li><li>处理 S3 的是 CloudFront,不是 ElastiCache。</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img184841.png"></p><ul><li>DB Cache (数据库缓存) <ul><li>从 ElastiCache 获取数据,未命中时从 RDS 读取并存入缓存。</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img185024.png"></p><ul><li>User Session (用户会话) <ul><li>将会话数据写入 ElastiCache,用户在不同实例间保持登录状态。</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img185153.png"></p><p>Redis vs. Memcached</p><ul><li><p>Redis - 持久化、高可用性 (非常重要)</p><ul><li>支持 Read Replicas</li><li>支持 Multi-AZ (高可用)</li><li>支持备份和恢复</li><li>单线程,但功能丰富</li></ul></li><li><p>Memcached - 简单、高性能</p><ul><li>不支持高可用性</li><li>无备份功能</li><li>有数据丢失风险</li><li>支持 Multi-threading (多线程)</li><li>适合简单缓存场景</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img185310.png"></p><hr><h4 id="ElastiCache-SAA"><a href="#ElastiCache-SAA" class="headerlink" title="ElastiCache SAA"></a>ElastiCache SAA</h4><p>身份验证</p><ul><li>ElastiCache for Redis 支持 IAM Authentication</li><li>Memcached 支持 SASL-based authentication</li><li>注意: IAM Database Authentication 不支持 Oracle</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img200638.png"></p><p>ElastiCache 使用模式</p><ul><li>Lazy Loading (延迟加载) - 需要时才加载到缓存,缓存未命中时从数据库读取</li><li>Write Through (写入穿透) - 写入数据库时同时写入缓存</li><li>Session Store (会话存储) - 存储用户会话数据</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img200822.png"></p><ul><li>ElastiCache 使用场景<ul><li>Gaming Leaderboards (游戏排行榜) - 使用 Redis Sorted Sets (重要)</li><li>Session Data Management (会话数据管理) - 管理和存储用户会话,实现无状态应用</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img200907.png"></p><hr><h3 id="8-Route-53"><a href="#8-Route-53" class="headerlink" title="8. Route 53"></a>8. Route 53</h3><h4 id="AWS-Route-53"><a href="#AWS-Route-53" class="headerlink" title="AWS Route 53"></a>AWS Route 53</h4><p> AWS 托管的 DNS (域名系统) 服务</p><ul><li>用户可以更新 DNS 记录 (高可用、可扩展)</li><li>也是域名注册商 (Domain Registrar)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img213527.png"></p><ul><li>Route 53 Records (记录组成)<ul><li>Domain Name (域名), Record Type (记录类型), Value (值), Routing Policy (路由策略), TTL (生存时间)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img213613.png"></p><ul><li>Route 53 Record Types (记录类型)<ul><li>A - 映射到 IPv4 地址</li><li>AAAA - 映射到 IPv6 地址</li><li>CNAME - 将主机名映射到另一个主机名</li><li>NS - 托管区域的名称服务器</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img213753.png"></p><ul><li>Route 53 Hosted Zones (托管区域)<ul><li>Public Hosted Zones (公共托管区域) - 公共域名,互联网可访问s</li><li>Private Hosted Zones (私有托管区域) - 私有域名,仅 VPC 内可访问</li></ul></li></ul><blockquote><p>注意: 私有托管区域需要启用 VPC 的 DNS hostnames 和 DNS resolution 设置。</p></blockquote><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img234126.png"></p><hr><h4 id="Route-53-TTL"><a href="#Route-53-TTL" class="headerlink" title="Route 53 TTL"></a>Route 53 TTL</h4><ul><li>TTL: 指定 DNS 记录在客户端缓存中保留的时间长度。<ul><li>TTL 越高,客户端缓存时间越长,减少对 Route 53 的查询,降低成本</li><li>TTL 越低,DNS 记录更新更快生效,但增加 DNS 查询次数</li></ul></li><li>重要: 后端更新 DNS 记录不代表缓存立即更新,需要等待 TTL 过期后客户端才会获取新值。</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img232659.png"></p><hr><h4 id="CNAME-vs-Alias"><a href="#CNAME-vs-Alias" class="headerlink" title="CNAME vs Alias"></a>CNAME vs Alias</h4><ul><li>CNAME (规范名称记录) - 将主机名指向另一个主机名。<ul><li>从 acme.example.com 到 zenith.example.org 或者 example.com 到 example.net</li></ul></li><li>Alias (别名记录) - 将主机名指向 AWS 资源。<ul><li>从 covid19survey.com 到 <a href="http://www.covid19survey.com/">www.covid19survey.com</a></li><li>从 app.mydomain.com 到 app.amazonaws.com</li></ul></li><li>使用建议: 指向 AWS 资源时优先使用 Alias,更简单且免费。</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img233313.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img233425.png"></p><hr><h4 id="Health-Checks"><a href="#Health-Checks" class="headerlink" title="Health Checks"></a>Health Checks</h4><ul><li>重要限制: Health Checks 仅适用于公共资源,无法直接检查私有资源。</li><li>Health Check 检测类型<ul><li>Endpoints (端点) - 监控应用、服务器或其他 AWS 资源的健康状态</li><li>Calculated Health Checks (计算健康检查) - 监控其他 Health Checks 的状态,组合多个检查结果</li><li>CloudWatch Alarms (CloudWatch 告警) - 基于 CloudWatch 指标状态进行健康检查</li></ul></li><li>用途: 与 Route 53 路由策略配合,实现故障转移和负载均衡。</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img000106.png"></p><hr><h4 id="Routing-Policy-Simple"><a href="#Routing-Policy-Simple" class="headerlink" title="Routing Policy (Simple)"></a>Routing Policy (Simple)</h4><ul><li>定义 Route 53 如何响应 DNS 查询, 共有 7 种路由策略</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img234623.png"></p><ul><li>Simple (简单路由) - 将流量路由到单个资源<ul><li>最基础的路由策略</li><li>可以指定多个值 (多个 IP 地址)</li><li>如果返回多个值,客户端随机选择一个</li><li>不支持健康检查</li></ul></li><li>使用场景: 单一资源或不需要健康检查的简单配置。</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img234350.png"></p><hr><h4 id="Routing-Policy-Weighted"><a href="#Routing-Policy-Weighted" class="headerlink" title="Routing Policy (Weighted)"></a>Routing Policy (Weighted)</h4><ul><li>加权路由策略 - 按百分比控制流量分配。<ul><li>为每个资源分配权重,控制发送到各资源的请求百分比</li><li>权重计算:资源权重 &#x2F; 所有权重总和 &#x3D; 流量百分比</li><li>支持健康检查,不健康的资源不接收流量</li><li>权重可设为 0 来停止发送流量到某资源</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img234856.png"></p><hr><h4 id="Routing-Policy-Latency"><a href="#Routing-Policy-Latency" class="headerlink" title="Routing Policy (Latency)"></a>Routing Policy (Latency)</h4><ul><li>延迟路由策略 - 将流量路由到延迟最低的资源。<ul><li>根据用户和 AWS Region 之间的网络延迟进行路由</li><li>自动将用户重定向到延迟最低的资源</li><li>支持健康检查</li></ul></li><li>工作原理: Route 53 测量用户到各 AWS Region 的延迟,选择延迟最低的资源响应。</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img235654.png"></p><hr><h4 id="Routing-Policy-Failover"><a href="#Routing-Policy-Failover" class="headerlink" title="Routing Policy (Failover)"></a>Routing Policy (Failover)</h4><ul><li>故障转移路由策略 - 主备切换机制 (重要)。<ul><li>配置一个 Primary (主) 实例和一个 Secondary (备用) 实例</li><li>正常情况下流量发送到 Primary 实例</li><li>Primary 实例不健康时,自动切换到 Secondary 实例</li><li>必须配置健康检查</li></ul></li><li>考题提到 failover 时,选择 active-passive failover routing policy</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img150940.png"></p><hr><h4 id="Routing-Policy-Geolocation"><a href="#Routing-Policy-Geolocation" class="headerlink" title="Routing Policy (Geolocation)"></a>Routing Policy (Geolocation)</h4><ul><li>地理位置路由策略 - 基于用户地理位置路由。<ul><li>根据用户的地理位置 (国家、大陆、州) 路由流量</li><li>需要创建一个 “Default” 记录,处理未匹配的位置</li><li>支持健康检查</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img151650.png"></p><hr><h4 id="Routing-Policy-Geoproximity"><a href="#Routing-Policy-Geoproximity" class="headerlink" title="Routing Policy (Geoproximity)"></a>Routing Policy (Geoproximity)</h4><ul><li>地理邻近路由策略 - 基于地理位置路由,并可调整流量偏向。<ul><li>根据用户和资源的地理位置路由流量</li><li>支持 bias (偏向值) 调整流量分配 (重要)</li><li>必须使用 Route 53 Traffic Flow 功能</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img152310.png"></p><hr><h4 id="Routing-Policy-IP-Based"><a href="#Routing-Policy-IP-Based" class="headerlink" title="Routing Policy (IP-Based)"></a>Routing Policy (IP-Based)</h4><ul><li>基于 IP 的路由策略 - 根据客户端 IP 地址路由。<ul><li>定义客户端 IP 地址的 CIDR 块列表</li><li>根据客户端 IP 范围将流量路由到特定资源</li><li>支持健康检查</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img153711.png"></p><hr><h4 id="Routing-Policy-Multi-Value"><a href="#Routing-Policy-Multi-Value" class="headerlink" title="Routing Policy (Multi-Value)"></a>Routing Policy (Multi-Value)</h4><ul><li>多值路由策略 - 将流量路由到多个资源。<ul><li>返回多个健康资源的 IP 地址 (最多 8 个)</li><li>支持健康检查,只返回健康资源</li><li>客户端选择其中一个 IP 地址使用</li><li>类似 Simple 路由,但支持健康检查</li></ul></li><li>重要: 不是 ELB 的替代品,只是提供简单的客户端负载分配。</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img153842.png"></p><hr><h3 id="9-Beanstalk"><a href="#9-Beanstalk" class="headerlink" title="9. Beanstalk"></a>9. Beanstalk</h3><h4 id="Instantiate-App"><a href="#Instantiate-App" class="headerlink" title="Instantiate App"></a>Instantiate App</h4><ul><li>EC2 Instance (EC2 实例)<ul><li>Golden AMI (黄金镜像) - 预先安装所有应用和依赖,直接启动 EC2 实例,启动最快</li><li>User Data (用户数据) - 用于动态配置 (记住是 dynamic),启动时执行脚本</li></ul></li><li>RDS Database (RDS 数据库)<ul><li>从 Snapshot 恢复, 数据和架构 (Schema) 已就绪,快速恢复</li></ul></li><li>EBS Volume (EBS 卷)<ul><li>从 Snapshot 恢复, 快速获得预配置的存储卷</li></ul></li><li>最佳实践: Golden AMI + User Data 结合使用,静态配置用 AMI,动态配置用 User Data。</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img173401.png"></p><hr><h4 id="Elastic-Beanstalk"><a href="#Elastic-Beanstalk" class="headerlink" title="Elastic Beanstalk"></a>Elastic Beanstalk</h4><ul><li>应用部署和管理的 PaaS 服务</li><li>核心理念: 开发者只需负责代码,其他一切 (容量配置、负载均衡、扩展、监控) 都由 AWS 自动管理。</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img210323.png"></p><ul><li>Web Server Tier vs. Worker Tier<ul><li>Web Server Tier (Web 服务器层): 处理 HTTP&#x2F;HTTPS 请求, 面向用户的 Web 应用, 使用 ELB + Auto Scaling</li><li>Worker Tier (工作层): 处理后台任务和异步操作, 从 SQS 队列读取消息处理, 不直接响应 HTTP 请求</li></ul></li><li>架构: 两层可以配合使用,Web Server Tier 接收请求,Worker Tier 处理耗时任务。</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img210711.png"></p><hr><h3 id="10-AWS-S3"><a href="#10-AWS-S3" class="headerlink" title="10. AWS S3"></a>10. AWS S3</h3><h4 id="AWS-S3-Simple-Storage-Service"><a href="#AWS-S3-Simple-Storage-Service" class="headerlink" title="AWS S3 (Simple Storage Service)"></a>AWS S3 (Simple Storage Service)</h4><p>S3 Buckets (存储桶)</p><ul><li>S3 服务是全球性的,但 Bucket 是区域性的</li><li>在 “buckets” 中存储对象 (文件)</li><li>Bucket 名称必须全球唯一</li><li>Bucket 在区域级别定义</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img171839.png"></p><p>Objects (对象)</p><ul><li>每个对象有一个 key (键),即完整路径 (prefix + object name)</li><li>最大对象大小 5TB</li><li>单次上传限制 5GB,超过需使用 Multi-Part Upload</li><li>也可使用 S3 Transfer Acceleration 加速上传</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img172025.png"></p><p>S3 重要特性</p><ul><li>S3 总是返回对象的最新版本 (重要)</li><li>S3 无法加密 metadata</li><li>S3 是 serverless 服务</li><li>S3 sync 命令 - 使用 CopyObject API 在 S3 buckets 间复制对象</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/imglifecycle-transitions-v2.png"></p><p>重要考试要点</p><ul><li>处理静态内容 → S3 + CloudFront (重要)</li><li>S3 图片上传场景 → 选择 S3 Event Notification,不是 EventBridge (重要)</li><li>S3 传输性能问题 → 给 S3 bucket 添加 prefix (前缀)</li><li>S3 不是数据库,与数据库功能不相关</li></ul><blockquote><p>对象所有权: 默认情况下,S3 对象归上传它的 AWS 账户所有,即使 bucket 属于另一个账户 (重要)</p></blockquote><ul><li>S3 网站托管 URL 格式<ul><li>Dash Region: <a href="http://bucket-name.s3-website-region.amazonaws.com/">http://bucket-name.s3-website-Region.amazonaws.com</a></li><li>Dot Region: <a href="http://bucket-name.s3-website.region.amazonaws.com/">http://bucket-name.s3-website.Region.amazonaws.com</a></li></ul></li></ul><hr><h4 id="S3-Bucket-Policy"><a href="#S3-Bucket-Policy" class="headerlink" title="S3 Bucket Policy"></a>S3 Bucket Policy</h4><ul><li>User-Based Security (基于用户的安全)<ul><li>IAM Policies (IAM 策略) - 控制 IAM 用户可以调用哪些 API (重要)</li></ul></li><li>Resource-Based Security (基于资源的安全)<ul><li>Bucket Policies (存储桶策略) - Bucket 级别的访问规则,如设置对象公开访问 (重要)</li><li>Object ACL (对象访问控制列表) - 对象级别的访问控制,较少使用</li><li>Bucket ACL (存储桶访问控制列表) - Bucket 级别的访问控制,较少使用</li></ul></li><li>Encryption: 使用加密密钥加密 S3 中的对象</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img173050.png"></p><ul><li>S3 Bucket Policies 结构 (JSON 格式)<ul><li>Resources (资源) - 指定 buckets 和 objects</li><li>Effect (效果) - Allow (允许) &#x2F; Deny (拒绝)</li><li>Actions (操作) - 允许或拒绝的 API 操作</li><li>Principal (主体) - 应用策略的账户或用户</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img173325.png"></p><hr><h4 id="S3-Versioning"><a href="#S3-Versioning" class="headerlink" title="S3 Versioning"></a>S3 Versioning</h4><ul><li>在 Bucket 级别启用, 默认状态为 null (未启用), 启用后为每个对象保存所有版本</li><li>最佳实践: 版本控制是最佳实践 (重要)<ul><li>可以回滚到之前的版本</li><li>防止误删除对象 (accidental deletion)</li><li>删除操作只是添加删除标记,不真正删除对象</li><li>可以恢复被删除的对象</li></ul></li><li>重要限制: 一旦启用版本控制,Bucket 无法恢复到未版本化状态 (重要)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img174246.png"></p><p>版本管理</p><ul><li>每次上传相同 key 的对象会创建新版本</li><li>可以永久删除特定版本</li><li>存储成本增加,因为保留所有版本</li></ul><hr><h4 id="S3-Replication-CRR-amp-SRR"><a href="#S3-Replication-CRR-amp-SRR" class="headerlink" title="S3 Replication (CRR &amp; SRR)"></a>S3 Replication (CRR &amp; SRR)</h4><ul><li>CRR (Cross-Region Replication) - 跨区域复制<ul><li>将对象复制到不同 Region 的 Bucket</li><li>用途:合规性要求、降低访问延迟、灾难恢复</li></ul></li><li>SRR (Same-Region Replication) - 同区域复制<ul><li>将对象复制到同一 Region 的不同 Bucket</li><li>用途:创建测试环境、日志聚合、生产和测试账户间复制</li></ul></li></ul><p>启用要求</p><ul><li>必须启用版本控制 (源和目标 Bucket 都要)</li><li>复制是异步的</li><li>必须授予 S3 适当的 IAM 权限</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img174840.png"></p><p>复制限制</p><ul><li>只复制新对象 - 启用复制后上传的对象才会被复制。<ul><li>现有对象需要使用 S3 Batch Replication 进行复制<br>-不支持链式复制 (No Chaining)</li><li>Bucket A → B → C 不会自动复制 A 的内容到 C</li><li>需要分别设置 A → B 和 A → C 的复制规则</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img175004.png"></p><hr><h4 id="S3-Storage-Classes"><a href="#S3-Storage-Classes" class="headerlink" title="S3 Storage Classes"></a>S3 Storage Classes</h4><ul><li>共 7 种存储类别: 1 个 General + 2 个 IA + 3 个 Glacier + 1 个 Intelligent</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img175742.png"></p><ul><li>S3 Standard - General Purpose (标准通用型)<ul><li>用于频繁访问的数据</li><li>最常见的存储类别</li><li>高持久性、高可用性、低延迟</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img175932.png"></p><p>S3 Infrequent Access (IA) - 不频繁访问: 适合访问频率低,但需要时必须快速访问的数据</p><ul><li>Standard-IA (标准不频繁访问)<ul><li>多 AZ 存储,高可用性</li><li>成本低于 Standard</li><li>最少存储 30 天</li></ul></li><li>One Zone-IA (单区域不频繁访问)<ul><li>单 AZ 存储,成本更低</li><li>不适合高可用性需求 (因为 AZ 可能故障)</li><li>从 Standard 转到 One Zone-IA 最少需要 30 天</li><li>如果要求 “访问始终可用”,不能选 One Zone-IA,因为 AZ 可能 down</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img180147.png"></p><p>S3 Glacier Storage Classes (Glacier 存储类别) - 归档专用: 低成本归档和备份存储,定价 &#x3D; 存储费用 + 检索费用</p><ul><li>S3 Glacier Instant Retrieval (即时检索)<ul><li>Glacier 中最快但也最贵</li><li>毫秒级检索</li><li>最少存储 90 天</li></ul></li><li>S3 Glacier Flexible Retrieval (灵活检索)<ul><li>三种检索模式<ul><li>Expedited (加急) - 1-5 分钟</li><li>Standard (标准) - 3-5 小时</li><li>Bulk (批量) - 5-12 小时</li></ul></li><li>最少存储 90 天</li></ul></li><li>S3 Glacier Deep Archive (深度归档)<ul><li>存储时间最久,成本最低</li><li>两种检索模式<ul><li>Standard (标准) - 12 小时</li><li>Bulk (批量) - 48 小时</li></ul></li><li>最少存储 180 天</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img180642.png"></p><ul><li>S3 Intelligent-Tiering (智能分层)<ul><li>根据使用情况自动在访问层之间移动对象</li><li>自动将对象移到不同的存储类别,无需手动管理</li><li>无检索费用</li><li>Intelligent-Tiering 在 Standard 和 Standard-IA 之间自动转换</li><li>不能从低层级向高层级转移</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img180806.png"></p><hr><h3 id="11-AWS-S3-Advance"><a href="#11-AWS-S3-Advance" class="headerlink" title="11. AWS S3 Advance"></a>11. AWS S3 Advance</h3><h4 id="S3-Lifecycle-Rules"><a href="#S3-Lifecycle-Rules" class="headerlink" title="S3 Lifecycle Rules"></a>S3 Lifecycle Rules</h4><ul><li>自动管理对象在不同存储类别间的转换<ul><li>在存储类别之间转换对象 (如从 Standard-IA 到 Glacier)</li><li>转换需要 Lifecycle Rules (重要)</li><li>例如:从 Snowball 导入到 S3 后转到 Glacier 需要 Lifecycle Rule</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img235516.png"></p><p>两种操作类型</p><ul><li>Transition Actions (转换操作): 配置对象转换到另一个存储类别 - 创建 60 天后转到 Standard-IA</li><li>Expiration Actions (过期操作): 配置对象在一段时间后过期 (自动删除) - 365 天后删除旧版本对象</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img235639.png"></p><ul><li>S3 Analytics (S3 分析)<ul><li>帮助决定何时将对象转换到合适的存储类别</li><li>不支持 One Zone-IA 和 Glacier</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img000151.png"></p><hr><h4 id="S3-Requester-Pays"><a href="#S3-Requester-Pays" class="headerlink" title="S3 Requester Pays"></a>S3 Requester Pays</h4><ul><li>由请求者而非存储桶拥有者支付请求费用<ul><li>请求者支付数据传输和请求费用</li><li>存储桶拥有者只支付存储费用</li><li>请求者必须是 AWS 用户 (经过身份验证)</li></ul></li><li>注意: 启用后,所有请求必须包含 x-amz-request-payer 头部。</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img000532.png"></p><hr><h4 id="S3-Event-Notifications"><a href="#S3-Event-Notifications" class="headerlink" title="S3 Event Notifications"></a>S3 Event Notifications</h4><ul><li>自动响应 S3 中发生的特定事件。<ul><li>对 S3 事件自动做出反应 (如对象创建、删除、恢复等)</li><li>例如:图片上传后自动触发处理</li><li>需要配置适当的 IAM 权限</li></ul></li><li>支持的目标 (Destination)<ul><li>SNS (Simple Notification Service) - 发送通知</li><li>SQS (Simple Queue Service) - 消息队列</li><li>Lambda Function - 执行函数</li></ul></li><li>考试要点: 大部分与 S3 事件相关的场景选择 S3 Event Notifications,而不是 EventBridge</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img000725.png"></p><hr><h4 id="S3-Performance"><a href="#S3-Performance" class="headerlink" title="S3 Performance"></a>S3 Performance</h4><p>For Upload (上传优化) - (重要)</p><ul><li>Multi-Part Upload (多部分上传)<ul><li>文件大于 5GB 时必须使用</li><li>文件大于 100MB 推荐使用</li><li>并行上传多个部分,提高速度</li><li>失败时只需重传失败的部分</li></ul></li><li>S3 Transfer Acceleration (传输加速)<ul><li>将文件传输到 AWS Edge Location,再通过 AWS 内部网络传到目标 S3</li><li>加速远距离上传和下载</li><li>可以与 Multi-Part Upload 一起使用</li><li>S3TA 可加速 S3 的上传和下载</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img001645.png"></p><p>For Download (下载优化)</p><ul><li>S3 Byte-Range Fetches (字节范围获取)<ul><li>并行化 GET 请求</li><li>只检索部分数据 (重要)</li><li>请求失败时只需重试特定字节范围</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img001828.png"></p><hr><h4 id="S3-Select-amp-Glacier-Select"><a href="#S3-Select-amp-Glacier-Select" class="headerlink" title="S3 Select &amp; Glacier Select"></a>S3 Select &amp; Glacier Select</h4><ul><li>使用简单的 SQL 语句在服务器端过滤数据</li><li>只检索需要的数据,而不是下载整个对象</li><li>400% Faster, 80% Cheaper (性能优化)</li></ul><blockquote><p>对比: 不使用 S3 Select 需要下载完整文件再过滤,浪费带宽和时间。</p></blockquote><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img002050.png"></p><hr><h4 id="S3-Batch-Operations"><a href="#S3-Batch-Operations" class="headerlink" title="S3 Batch Operations"></a>S3 Batch Operations</h4><ul><li>对现有 S3 对象执行批量操作<ul><li>对大量 S3 对象执行批量操作</li><li>一次性处理数十亿个对象</li></ul></li><li>常见操作: 批量加密未加密的对象, 批量复制对象到另一个 bucket</li><li>使用场景: 大规模数据迁移、合规性更新、批量处理。</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img022334.png"></p><hr><h3 id="12-AWS-S3-Security"><a href="#12-AWS-S3-Security" class="headerlink" title="12. AWS S3 Security"></a>12. AWS S3 Security</h3><h4 id="S3-Encryption"><a href="#S3-Encryption" class="headerlink" title="S3 Encryption"></a>S3 Encryption</h4><ul><li>共 4 种加密方法<ul><li>SSE-S3 - 免费</li><li>SSE-KMS - 收费</li><li>SSE-C</li><li>Client-Side Encryption</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img223133.png"></p><p>Server-Side Encryption (服务器端加密)</p><ul><li>SSE-S3 (S3 托管密钥)<ul><li>新 buckets 和对象默认启用</li><li>AWS 管理加密密钥</li><li>每个对象使用唯一密钥加密</li><li>使用 AES-256 加密标准</li><li>Header: x-amz-server-side-encryption: AES256</li><li>SSE-S3 没有自动密钥轮换,需要 SSE-KMS (重要)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img223242.png"></p><ul><li>SSE-KMS (KMS 托管密钥)<ul><li>用户控制密钥并可在 CloudTrail 中审计密钥使用情况</li><li>可以管理密钥轮换</li><li>提供额外的安全层</li><li>Header: x-amz-server-side-encryption: aws:kms</li><li>有 API 调用限制 (可能影响高吞吐量应用)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img223417.png"></p><ul><li>SSE-C (客户提供密钥)<ul><li>用户自己管理加密密钥</li><li>AWS 不存储密钥</li><li>必须使用 HTTPS</li><li>每次请求必须提供密钥</li><li>适用场景:用户需要使用自己的密钥,但希望在 AWS 端进行加密</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img223602.png"></p><ul><li>Client-Side Encryption (客户端加密)<ul><li>用户完全管理密钥和加密周期</li><li>数据在发送到 AWS 之前已加密</li><li>AWS 只存储加密后的数据</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img223715.png"></p><ul><li>Encryption in Transit (传输加密) - SSL&#x2F;TLS<ul><li>使用 HTTPS 端点加密传输中的数据</li><li>可使用 Bucket Policy 中的 aws:SecureTransport 条件强制使用 HTTPS</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img223811.png"></p><hr><h4 id="S3-CORS"><a href="#S3-CORS" class="headerlink" title="S3 CORS"></a>S3 CORS</h4><ul><li>CORS (Cross-Origin Resource Sharing)<ul><li>允许一个域的 Web 应用访问另一个域的资源</li><li>浏览器安全机制,防止恶意跨域请求</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img224630.png"></p><ul><li>S3 CORS 工作原理<ul><li>当客户端对 S3 bucket 发起跨域请求时,需要配置正确的 CORS 头部</li><li>必须在目标 S3 bucket 上启用 CORS 配置</li></ul></li><li>CORS 配置选项<ul><li>可以允许特定源 (origin)</li><li>可以使用 * 允许所有源</li><li>指定允许的 HTTP 方法 (GET, PUT, POST 等)</li><li>指定允许的头部</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img224951.png"></p><hr><h4 id="S3-MFA-Delete"><a href="#S3-MFA-Delete" class="headerlink" title="S3 MFA Delete"></a>S3 MFA Delete</h4><ul><li>MFA Delete: 防止意外删除的额外安全层<ul><li>防止不小心删除文件</li><li>用户需要先验证身份才能删除对象 (重要)</li><li>必须启用版本控制 (Versioning)</li><li>只能通过 AWS CLI 配置,无法通过控制台</li></ul></li><li>重要限制: 只有 bucket owner (root 账户) 可以启用&#x2F;禁用 MFA Delete (重要)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img225415.png"></p><hr><h4 id="S3-Access-Logs"><a href="#S3-Access-Logs" class="headerlink" title="S3 Access Logs"></a>S3 Access Logs</h4><ul><li>对 S3 的任何请求都会被记录到另一个 S3 bucket</li><li>详细记录访问信息:请求者、bucket 名称、请求时间、操作类型、响应状态等</li><li>使用场景: 数据分析 - 分析访问模式和使用情况</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img230251.png"></p><hr><h4 id="S3-Pre-signed-URLs"><a href="#S3-Pre-signed-URLs" class="headerlink" title="S3 Pre-signed URLs"></a>S3 Pre-signed URLs</h4><ul><li>生成带有过期时间的临时 URL</li><li>允许未经身份验证的用户临时访问私有 S3 对象</li><li>URL 过期后自动失效</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img230702.png"></p><hr><h4 id="Glacier-Vault-Lock-amp-S3-Object-Lock"><a href="#Glacier-Vault-Lock-amp-S3-Object-Lock" class="headerlink" title="Glacier Vault Lock &amp; S3 Object Lock"></a>Glacier Vault Lock &amp; S3 Object Lock</h4><ul><li>S3 Glacier Vault Lock<ul><li>采用 WORM (Write Once Read Many) 模型</li><li>信息一旦写入就无法修改或删除</li><li>对象完全不可删除和修改</li></ul></li><li>存储敏感数据, 使用 Vault Lock Policy 管理访问, 锁定后策略无法更改, 即使是 AWS 也无法修改</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img230941.png"></p><ul><li>S3 Object Lock<ul><li>必须启用版本控制 (Versioning) (重要)</li><li>阻止对象版本在一段时间内被删除</li><li>两个 Retention mode (重要)<ul><li>Compliance: 所有人都无法删除,包括 root 用户</li><li>Governance: 有特定权限的用户可以删除</li></ul></li><li>Legal Hold: 防止对象版本被修改或删除, 只有移除 Legal Hold 才能删除对象</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img231203.png"></p><hr><h4 id="S3-Access-Points"><a href="#S3-Access-Points" class="headerlink" title="S3 Access Points"></a>S3 Access Points</h4><ul><li>简化 S3 bucket 的安全管理</li><li>为不同用户群体创建独立的访问入口<ul><li>Finance 团队只能访问 &#x2F;finance 前缀的对象</li><li>Analytics 团队只能访问 &#x2F;analytics 前缀的对象</li></ul></li><li>每个 Access Point 有独立的权限策略</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img231500.png"></p><hr><h4 id="S3-Object-Lambda"><a href="#S3-Object-Lambda" class="headerlink" title="S3 Object Lambda"></a>S3 Object Lambda</h4><ul><li>在检索对象之前使用 Lambda 函数转换数据。<ul><li>使用 AWS Lambda 在对象到达调用者之前修改对象</li><li>动态转换数据,无需创建多个副本</li><li>保持原始数据不变</li></ul></li><li>需要 S3 Access Point, 需要 S3 Object Lambda Access Point, Lambda 函数执行转换逻辑</li><li>使用场景: 给图片添加水印</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img231810.png"></p><hr><h3 id="13-CloudFront-amp-AWS-Global-Accelerator"><a href="#13-CloudFront-amp-AWS-Global-Accelerator" class="headerlink" title="13. CloudFront &amp; AWS Global Accelerator"></a>13. CloudFront &amp; AWS Global Accelerator</h3><h4 id="AWS-CloudFront"><a href="#AWS-CloudFront" class="headerlink" title="AWS CloudFront"></a>AWS CloudFront</h4><ul><li>Content Delivery Network (CDN) - 可以服务静态和动态内容<ul><li>提升读取性能,内容缓存在边缘节点</li><li>全球分布的边缘位置网络</li></ul></li><li>安全特性<ul><li>防止 DDoS 攻击 (配合 AWS Shield)</li><li>可指定 primary &amp; secondary origins 实现高可用和故障转移</li></ul></li><li>CloudFront Origins (源)<ul><li>S3 Bucket - 使用 OAC (Origin Access Control) 保护 (重要,涉及 S3 问题时必选)</li><li>Custom Origin (HTTP) - 自定义 HTTP 端点 (如 ALB、EC2、任何 HTTP 后端)</li></ul></li><li>加密选项: CloudFront 需要加密时,选择 Field-Level Encryption (字段级加密),不是 KMS<ul><li>Field-level Encryption 允许用户安全上传敏感信息到 Web 服务器</li><li>在边缘节点加密特定字段</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img232701.png"></p><p>CloudFront vs. S3 Cross Region Replication (CRR)</p><ul><li>CloudFront<ul><li>使用全球边缘网络</li><li>有 TTL (缓存过期时间)</li><li>适合静态内容</li><li>内容缓存在边缘节点</li></ul></li><li>S3 Cross Region Replication<ul><li>每个 Region 都要单独设置</li><li>没有 TTL</li><li>适合动态内容</li><li>近实时更新,只读</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img233016.png"></p><p>其他重要特性</p><ul><li>Price Classes (价格等级):<ul><li>不同地区价格不同</li><li>可用于降低成本</li></ul></li><li>性能优化<ul><li>CloudFront 允许 Proxy methods 和 Dynamic content 跳过 regional edge cache</li><li>提高动态内容传输速度</li></ul></li><li>访问控制<ul><li>WAF - 阻止 IP 地址</li><li>OAI (Origin Access Identity) - 保护 S3 源 (重要)<ul><li>也可用于 CloudFront 和 S3 之间的安全通信</li></ul></li><li>CloudFront Signed URLs - 限制对文档的访问 (如订阅内容)</li><li>CloudFront Signed Cookies - 限制多个文件的访问</li></ul></li><li>HTTPS 强制<ul><li>可配置 CloudFront 要求客户端必须使用 HTTPS, 提高传输安全性</li></ul></li></ul><hr><h4 id="CloudFront-Geo-Restriction"><a href="#CloudFront-Geo-Restriction" class="headerlink" title="CloudFront Geo Restriction"></a>CloudFront Geo Restriction</h4><ul><li>根据用户的地理位置限制内容访问</li><li>基于国家&#x2F;地区进行访问控制</li><li>两种模式<ul><li>Allowlist (白名单) - 只允许特定国家&#x2F;地区访问</li><li>Blocklist (黑名单) - 阻止特定国家&#x2F;地区访问</li></ul></li><li>重要限制: CloudFront Geo Restriction 无法与 VPC 一起使用</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img233638.png"></p><hr><h4 id="CloudFront-Cache-Invalidation"><a href="#CloudFront-Cache-Invalidation" class="headerlink" title="CloudFront Cache Invalidation"></a>CloudFront Cache Invalidation</h4><ul><li>让 CloudFront 跳过 TTL,立即更新缓存<ul><li>比如你更新了后端, 但是 CloudFront 不会立即更新, 需要 CloudFront Invalidation 来跳过 TTL 来立即更新</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img234007.png"></p><hr><h4 id="AWS-Global-Accelerator"><a href="#AWS-Global-Accelerator" class="headerlink" title="AWS Global Accelerator"></a>AWS Global Accelerator</h4><ul><li>利用 AWS 内部网络优化全球应用性能。<ul><li>提供 2 个全球静态 Anycast IP 地址 (重要)</li><li>提高应用的全球可用性和性能, 支持自动故障转移</li></ul></li><li>改善基于 TCP 或 UDP 的应用性能</li><li>流量通过 AWS 骨干网传输,减少延迟</li><li>自动健康检查和故障转移</li><li>成本较高,因为增加了额外的基础设施层 (对比 CloudFront 不是 cost-effective 的选择)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img234527.png"></p><p>AWS Global Accelerator vs. CloudFront</p><ul><li><p>CloudFront (CDN)</p><ul><li>内容在边缘节点缓存</li><li>适合可缓存内容 (图片、视频)</li><li>也支持动态内容 (API 加速、动态网站交付)</li><li>有 TTL 和缓存机制</li></ul></li><li><p>Global Accelerator (网络加速)</p><ul><li>适合 TCP 或 UDP 协议</li><li>适合非 HTTP 用例 (游戏、IoT、VoIP)</li><li>提供静态 IP 地址</li><li>无缓存,实时路由</li></ul></li><li><p>静态内容&#x2F;HTTP → CloudFront</p></li><li><p>游戏&#x2F;IoT&#x2F;需要静态 IP → Global Accelerator</p></li><li><p>成本敏感 → CloudFront</p></li><li><p>需要固定 IP 地址 → Global Accelerator</p></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img000939.png"></p><hr><h3 id="14-AWS-Storage-Extra"><a href="#14-AWS-Storage-Extra" class="headerlink" title="14. AWS Storage Extra"></a>14. AWS Storage Extra</h3><h4 id="AWS-Snow-Family"><a href="#AWS-Snow-Family" class="headerlink" title="AWS Snow Family"></a>AWS Snow Family</h4><ul><li>整个 Snow Family 都是物理硬件设备</li><li>两大用途:数据迁移 (进出 AWS) 和 边缘计算 (在边缘处理数据)<ul><li>Snowcone: 体积最小,便携性强, 适合带到特殊环境, 8TB HDD 或 14TB SSD</li><li>Snowball Edge: 推荐处理 10-100 TB 数据, 两种类型<ul><li>Storage Optimized (存储优化) - 80TB 可用存储</li><li>Compute Optimized (计算优化) - 支持 storage clustering (存储集群),42TB 可用存储,更强的计算能力</li><li>公式记忆: Terabytes + low costs + limited time &#x3D; AWS Snowball devices</li></ul></li><li>Snowmobile: 不算在 Edge Computing 里, 推荐处理 10 PB 以上数据</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img200544.png"></p><ul><li>Edge Location: 比如海上或者矿洞里, 没有网络的情况下<ul><li>所以需要 Edge Computing 和 Snow Family</li></ul></li><li>管理工具: AWS OpsHub - 用来管理 AWS Snow Family 设备的图形化界面。</li><li>Snowball to Glacier<ul><li>必须使用 S3 Lifecycle Policy</li><li>Snowball 兼容 S3,但不能直接写入 Glacier</li><li>工作流程: Snowball → S3 → (Lifecycle Policy) → Glacier</li><li>这里的 Glacier 指整个 Glacier Family (包括 Glacier Instant Retrieval、Glacier Flexible Retrieval、Glacier Deep Archive)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img201918.png"></p><hr><h4 id="AWS-FSx"><a href="#AWS-FSx" class="headerlink" title="AWS FSx"></a>AWS FSx</h4><ul><li>AWS 上的第三方高性能文件系统<ul><li>FSx for Windows File Server: Windows 原生文件系统, 支持 SMB 协议和 Windows NTFS</li><li>FSx for Lustre (Linux): 高性能并行文件系统, 适合 HPC (高性能计算), 可以与 S3 集成, 支持处理”热数据”(并行分布式处理)和”冷数据”(存储在 S3)</li><li>FSx for NetApp ONTAP: 企业级文件系统, 支持 NFS、SMB、iSCSI 协议, 兼容 Linux、Windows、macOS</li><li>FSx for OpenZFS: OpenZFS 文件系统</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img202205.png"></p><ul><li>FSx for Lustre - 两种部署选项<ul><li>Scratch File System (临时文件系统): 临时存储, 数据不复制, 成本最低</li><li>Persistent File System (持久文件系统): 长期存储, 数据在同一 AZ 内复制 (重要), 高可用性</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img202555.png"></p><ul><li>FSx for Windows: Windows 应用、企业文件共享</li><li>FSx for Lustre: 机器学习、HPC、视频处理、基因组学</li><li>FSx for NetApp ONTAP: 混合云、企业应用</li><li>FSx for OpenZFS: 数据密集型应用</li></ul><hr><h4 id="AWS-Storage-Gateway"><a href="#AWS-Storage-Gateway" class="headerlink" title="AWS Storage Gateway"></a>AWS Storage Gateway</h4><ul><li>本地和云存储之间的桥梁<ul><li>混合云 (Hybrid Cloud) 解决方案 (重要)</li><li>连接本地数据中心和 AWS 云存储</li><li>保留从本地访问 AWS 数据的能力</li></ul></li><li>提到 NFS 的就是 File Gateway, 问 S3 大部分都是 File Gateway</li><li>重要区分<ul><li>DataSync - 用来迁移&#x2F;移动数据 (一次性或定期同步)</li><li>File Gateway - 用来维持持续访问能力 (重要)</li><li>File Gateway - 文件存储</li><li>Volume Gateway - 块存储 (重要)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img203211.png"></p><p>4 种 Gateway 类型 (Storage Gateway 是泛指下面这 4 个 Gateway 的总称)</p><ul><li><p>S3 File Gateway</p><ul><li>从本地访问 S3 Buckets</li><li>支持 NFS 和 SMB 协议</li><li>文件存储 (File Storage)</li><li>使用场景:文件共享、备份、归档</li></ul></li><li><p>FSx File Gateway</p><ul><li>从本地访问 Amazon FSx for Windows File Server</li><li>支持 SMB 协议和 NTFS</li><li>为 Windows 文件系统提供低延迟访问</li></ul></li><li><p>Volume Gateway</p><ul><li>从本地访问 S3 和 EBS</li><li>支持 iSCSI 协议</li><li>块存储 (Block Storage) (重要)</li><li>两种模式<ul><li>Cached Volumes (缓存卷): 主数据存储在 S3, 本地缓存最近访问的数据</li><li>Stored Volumes (存储卷): 整个数据集保存在本地, 定期备份到 S3 (快照)</li></ul></li></ul></li><li><p>Tape Gateway (磁带网关)</p><ul><li>从本地访问存档在 AWS Glacier 的虚拟磁带</li><li>替代物理磁带备份</li><li>如果问题里提到 Tape, 就是 Tape Gateway</li></ul></li></ul><hr><h4 id="AWS-Transfer-Family"><a href="#AWS-Transfer-Family" class="headerlink" title="AWS Transfer Family"></a>AWS Transfer Family</h4><ul><li>使用 FTP 协议传输文件到&#x2F;从 S3 或 EFS<ul><li>提供托管的文件传输服务</li><li>将文件传输到 S3 或 EFS</li><li>无需管理基础设施</li></ul></li><li>支持的三种协议 (重要)<ul><li>FTP (File Transfer Protocol) - 未加密</li><li>FTPS (File Transfer Protocol over SSL) - 使用 SSL&#x2F;TLS 加密</li><li>SFTP (SSH File Transfer Protocol) - 使用 SSH 加密</li></ul></li><li>考试要点: 如果问到关于 FTP 或 SFTP 的问题,选择 AWS Transfer Family</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img203933.png"></p><hr><h4 id="AWS-DataSync"><a href="#AWS-DataSync" class="headerlink" title="AWS DataSync"></a>AWS DataSync</h4><ul><li>自动化数据传输和同步服务<ul><li>可以从本地或 AWS 传输大量数据 (双向)</li><li>简化、自动化和加速数据复制</li><li>在本地存储系统和 AWS 存储服务之间,以及 AWS 存储服务之间传输数据</li></ul></li><li>传输路径<ul><li>本地到 AWS: 本地 → S3、EFS、FSx, 需要安装 DataSync Agent</li><li>AWS 到 AWS: S3 ↔ EFS ↔ FSx 等之间, 不需要 Agent</li></ul></li><li>关键特性<ul><li>定期复制任务: 可以设置计划任务 (如每周五复制一次)</li><li>保留元数据 (重要): 文件权限和元数据都会被保留, POSIX 权限</li></ul></li><li>重要区分<ul><li>DataSync - 用来迁移&#x2F;移动数据 (一次性或定期)</li><li>File Gateway - 用来维持持续访问能力</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img204155.png"></p><ul><li>DataSync - 批量数据传输,定期同步</li><li>Storage Gateway - 持续混合云访问</li><li>Snow Family - PB 级离线数据传输</li><li>Transfer Family - FTP&#x2F;SFTP 协议文件传输</li></ul><hr><h3 id="15-SQS-SNS-Kinesis-Active-MQ"><a href="#15-SQS-SNS-Kinesis-Active-MQ" class="headerlink" title="15. SQS, SNS, Kinesis, Active MQ"></a>15. SQS, SNS, Kinesis, Active MQ</h3><h4 id="AWS-SQS"><a href="#AWS-SQS" class="headerlink" title="AWS SQS"></a>AWS SQS</h4><ul><li>完全托管的消息队列服务<ul><li>用来解耦应用程序 (如视频处理,属于多对多模型)</li><li>自动扩展 (无限吞吐量、无限消息数、可重试)</li><li>遇到 decouple microservices (但没有第三方要求) 就选 SQS</li><li>遇到 parallel 处理选 SQS 而不是 SNS</li></ul></li><li>重要特性<ul><li>Standard SQS 允许 S3 作为 event notification destination, FIFO 不行</li><li>可以有多个 consumer 并行处理消息</li><li>Consumer 处理完消息后删除</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img235912.png"></p><ul><li>特殊场景<ul><li>遇到 SQS 消息处理失败 → 选择 DLQ (死信队列) 解决 (重要)</li><li>遇到需要处理高吞吐量 request-response 消息模式 → 选择 temporary queue (重要)</li><li>遇到需要延迟新消息交付 → 选择 delay queue</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img000504.png"></p><ul><li>SQS Message Visibility Timeout (重要)<ul><li>Visibility Timeout 过高: Consumer 崩溃后重新处理需要很长时间</li><li>Visibility Timeout 过低: 会导致重复处理 (duplicate)</li><li>防止读取重复要增加 Timeout (重要)</li><li>使用 ChangeMessageVisibility API 动态增加超时</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img020440.png"></p><ul><li>SQS 优先级处理<ul><li>创建两个 SQS standard 队列</li><li>设置 EC2 实例优先轮询高优先级队列</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/imgpt6-q32-i1.jpg"></p><ul><li>转换为 FIFO Queue<ul><li>删除现有 SQS 重新创建为 FIFO</li><li>确保名称以 .fifo 结尾</li><li>确保吞吐量不超过 3000 消息&#x2F;秒</li></ul></li></ul><hr><h4 id="SQS-Long-Polling"><a href="#SQS-Long-Polling" class="headerlink" title="SQS Long Polling"></a>SQS Long Polling</h4><ul><li>减少延迟和 API 调用次数<ul><li>减少 API 请求次数, 提升性能</li><li>最小化 SQS 使用成本 (省钱)</li><li>降低延迟</li></ul></li><li>工作原理<ul><li>Consumer 请求消息时等待一段时间 (最长 20 秒)</li><li>如果队列中有消息立即返回</li><li>如果队列为空, 等待直到消息到达或超时</li></ul></li><li>重要限制: Long Polling 不能处理 SQS 重复消息问题, 防止重复还是要用 Visibility Timeout</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img003255.png"></p><hr><h4 id="SQS-FIFO-Queue"><a href="#SQS-FIFO-Queue" class="headerlink" title="SQS FIFO Queue"></a>SQS FIFO Queue</h4><ul><li>先进先出队列, 保证消息顺序<ul><li>按顺序传递消息 (SNS 也可以做到)</li><li>默认支持最多 300 消息&#x2F;秒</li><li>高吞吐量模式: 最多 3000 消息&#x2F;秒</li><li>确保消息只被处理一次 (无重复)</li></ul></li><li>Consumer 并发处理<ul><li>没有 GroupID: 只能有 1 个 consumer 顺序处理</li><li>有 GroupID: 可以有多个 consumer 并行处理不同组</li></ul></li><li>Message Group ID<ul><li>同一 Group ID 的消息按顺序处理</li><li>不同 Group ID 的消息可以并行处理</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img003507.png"></p><hr><h4 id="AWS-SNS"><a href="#AWS-SNS" class="headerlink" title="AWS SNS"></a>AWS SNS</h4><ul><li>发布&#x2F;订阅消息服务<ul><li>发送一条消息到多个接收者 (如给用户发 email)</li><li>Publisher &amp; Subscriber 模型 (属于一对多模型)</li><li>完全托管的推送通知服务</li><li>Subscriber 类型: SQS, Lambda, Kinesis Data Firehose, HTTPS endpoints</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img010634.png"></p><hr><h4 id="Fan-Out-Pattern"><a href="#Fan-Out-Pattern" class="headerlink" title="Fan Out Pattern"></a>Fan Out Pattern</h4><ul><li>SNS 到多个 SQS 的消息分发模式<ul><li>在 SNS 推送一次消息</li><li>所有订阅的 SQS 队列接收消息</li><li>SNS 传递消息给多个 SQS 来接收</li></ul></li><li>核心优势<ul><li>完全解耦 (Fully decoupled)</li><li>无数据丢失 (No data loss)</li><li>可以进行消息过滤 (Message Filtering)</li></ul></li><li>消息过滤<ul><li>根据不同的 Filter Policy 过滤消息</li><li>每个 SQS 队列可以设置不同的订阅过滤策略</li></ul></li><li>Kinesis Fan Out<ul><li>Kinesis 也可以使用 Fan Out Pattern, 使用 Shard 实现</li><li>Enhanced Fan-Out: 每个消费者独立的吞吐量</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img011026.png"></p><hr><h4 id="AWS-Kinesis"><a href="#AWS-Kinesis" class="headerlink" title="AWS Kinesis"></a>AWS Kinesis</h4><ul><li>实时流数据处理服务<ul><li>实时摄取、处理和缓冲流数据</li><li>处理大规模实时数据流</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img150053.png"></p><p>Kinesis 服务</p><ul><li><p>Kinesis Data Streams</p><ul><li>捕获、处理和存储数据流</li><li>实时数据流处理</li><li>数据保留 1-365 天</li><li>需要手动管理容量 (Shards)</li></ul></li><li><p>Kinesis Data Firehose</p><ul><li>将数据流加载到 AWS 数据存储</li><li>目标: S3、Redshift、OpenSearch、第三方服务</li><li>完全托管, 自动扩展</li><li>近实时传输 (60 秒延迟或 1 MB 数据)</li></ul></li><li><p>当 Kinesis Data Streams 作为数据源写入 Kinesis Data Firehose 时不需要 agent</p></li><li><p>Kinesis Agent 不能写入已将 Kinesis Data Streams 设置为源的 Kinesis Firehose</p></li></ul><hr><h4 id="Kinesis-Data-Streams"><a href="#Kinesis-Data-Streams" class="headerlink" title="Kinesis Data Streams"></a>Kinesis Data Streams</h4><ul><li>实时数据流捕获和处理服务<ul><li>可以重新处理和重放流数据 (Replay, 处理数据, 重要)</li><li>处理实时数据流, 如点击流、交易数据、媒体 (金融数据)</li><li>每秒从多个来源连续收集数 GB 的数据</li></ul></li><li>Consumer 类型: Lambda, Kinesis Firehose, Kinesis Data Analytics</li><li>重要特性<ul><li>数据写入后不能删除 (Immutability)</li><li>数据保留 1-365 天</li><li>实时处理延迟约 200ms</li></ul></li><li>考试要点: 如果问到 Kinesis Data Stream 加上 SQL, 答案里一定有 Kinesis Data Analytics</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img014850.png"></p><ul><li>数据分区<ul><li>相同 partition key 的数据进入同一个 shard</li><li>保证同一 partition 内的数据有序</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img151123.png"></p><p>Capacity Mode (容量模式)</p><ul><li><p>Provisioned Mode (预配置模式)</p><ul><li>手动选择 shard 数量</li><li>手动扩展</li><li>可预测成本</li></ul></li><li><p>On-Demand Mode (按需模式)</p><ul><li>无需预配置或管理容量</li><li>自动扩展</li><li>按实际使用付费</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img151507.png"></p><ul><li>性能问题解决: 遇到 ProvisionedThroughputExceededException 问题 → 选择 batch messages 解决</li></ul><hr><h4 id="Kinesis-Data-Firehose"><a href="#Kinesis-Data-Firehose" class="headerlink" title="Kinesis Data Firehose"></a>Kinesis Data Firehose</h4><ul><li>将流数据加载到数据存储和分析工具<ul><li>提供将数据流传输到数据存储或数据分析工具的功能</li><li>托管服务, 自动扩展, Serverless</li><li>支持数据转换 (Lambda)</li></ul></li><li>目标存储 (Firehose 的对象): S3, Redshift, OpenSearch, 第三方服务 (Splunk, Datadog 等)</li><li>重要特性<ul><li>Near Real-Time (近实时) - 60 秒延迟或 1 MB 数据</li><li>只支持一个 consumer (将数据转储到单个数据仓库)</li><li>Serverless, 专门处理日志数据</li><li>无数据存储, 不支持重放</li></ul></li><li>考试注意: 不要被 Near Real-Time 误导, 要根据题目需求选择 Data Streams 或 Data Firehose</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img015040.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img151812.png"></p><p>Kinesis Data Streams vs. Firehose</p><ul><li><p>Data Streams</p><ul><li>需要编写自定义代码</li><li>实时 (Real-time, ~200ms)</li><li>有数据存储 (1-365 天)</li><li>支持重放 (Replay)</li><li>多个消费者</li></ul></li><li><p>Firehose</p><ul><li>完全托管 (Fully managed)</li><li>近实时 (Near real-time, 60 秒)</li><li>无数据存储</li><li>不支持重放</li><li>单个目标</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img152247.png"></p><hr><h4 id="Data-ordering-for-Kinesis"><a href="#Data-ordering-for-Kinesis" class="headerlink" title="Data ordering for Kinesis"></a>Data ordering for Kinesis</h4><ul><li>Kinesis 的数据顺序保证机制<ul><li>相同的 key (Partition Key) 总是进入同一个 shard</li><li>同一 shard 内的数据保证有序</li><li>不同 shard 之间的数据无顺序保证</li></ul></li><li>与 SQS 对比<ul><li>SQS: 只有 FIFO 队列支持顺序, 但吞吐量有限 (300 或 3000 消息&#x2F;秒)</li><li>Kinesis: 支持大量 consumer 并行处理, 同时保证同一 partition 内的顺序</li></ul></li><li>Kinesis 更适合需要大规模并行处理且保持部分顺序的场景</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img154939.png"></p><hr><h4 id="AWS-MQ"><a href="#AWS-MQ" class="headerlink" title="AWS MQ"></a>AWS MQ</h4><ul><li>托管的消息代理服务<ul><li>管理第三方消息代理 (Message Broker) 软件</li><li>支持开源消息代理协议</li></ul></li><li>支持的消息代理<ul><li>RabbitMQ</li><li>ActiveMQ</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img170638.png"></p><hr><h3 id="16-Containers-on-AWS"><a href="#16-Containers-on-AWS" class="headerlink" title="16. Containers on AWS"></a>16. Containers on AWS</h3><h4 id="AWS-ECS"><a href="#AWS-ECS" class="headerlink" title="AWS ECS"></a>AWS ECS</h4><ul><li>在 AWS 上管理 Docker 容器, 两种 Launch Type</li><li>EC2 Launch Type<ul><li>需要预配置 (Provision) EC2 实例</li><li>需要 ECS Agent (重点)</li><li>你管理底层 EC2 实例</li><li>更多控制权, 但需要管理基础设施</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img212508.png"></p><ul><li>Fargate Launch Type<ul><li>Serverless, 无需预配置 (重点)</li><li>AWS 管理底层基础设施</li><li>只需定义容器资源需求</li><li>更简单, 无需管理服务器</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img212546.png"></p><p>IAM Roles for ECS (重要, 是 IAM)</p><ul><li>EC2 Instance Profile<ul><li>只针对 EC2 Launch Type</li><li>赋予 EC2 实例权限</li><li>用于 ECS Agent 与 ECS 服务通信</li></ul></li><li>ECS Task Role<ul><li>每个 Task 都有自己的 Role</li><li>赋予容器内应用权限</li><li>访问 AWS 资源 (如 S3, DynamoDB)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img212709.png"></p><ul><li>集成功能<ul><li>ECS 可以与 Load Balancer 集成 (ALB&#x2F;NLB)</li><li>ECS 可以与 EFS 集成 (持久化存储)</li><li>Fargate + EFS &#x3D; Serverless 文件管理</li></ul></li><li>计费方式<ul><li>EC2 Launch Type: 基于 EC2 实例和 EBS 卷计费</li><li>Fargate Launch Type: 基于 vCPU 和内存资源计费</li></ul></li></ul><hr><h4 id="ECS-Auto-Scaling"><a href="#ECS-Auto-Scaling" class="headerlink" title="ECS Auto Scaling"></a>ECS Auto Scaling</h4><ul><li>自动增加&#x2F;减少 ECS 任务数量, 三种扩展策略</li><li>Target Scaling (目标跟踪扩展)<ul><li>基于 CloudWatch 指标的目标值扩展</li><li>例如: 保持 CPU 使用率在 70%</li><li>自动调整任务数量以维持目标值</li></ul></li><li>Step Scaling (步进扩展)<ul><li>基于 CloudWatch Alarm 扩展</li><li>根据告警阈值添加&#x2F;删除特定数量的任务</li><li>例如: CPU &gt; 80% 添加 2 个任务</li></ul></li><li>Scheduled Scaling (计划扩展)<ul><li>基于特定时间扩展 (重要)</li><li>预测性扩展, 在特定时间增加&#x2F;减少容量</li><li>例如: 工作日早上 9 点增加任务</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img222247.png"></p><hr><h4 id="AWS-ECR"><a href="#AWS-ECR" class="headerlink" title="AWS ECR"></a>AWS ECR</h4><ul><li>管理 Docker 镜像, 不是 Docker 容器<ul><li>在 AWS 上存储和管理 Docker 镜像</li><li>完全托管的 Docker 容器注册表</li><li>与 ECS 和 EKS 无缝集成</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img222836.png"></p><hr><h4 id="AWS-EKS"><a href="#AWS-EKS" class="headerlink" title="AWS EKS"></a>AWS EKS</h4><ul><li>在 AWS 上管理 Kubernetes 集群</li><li>部署模式<ul><li>支持两种部署模式: EC2 和 Fargate (和 ECS 一样)</li><li>完全托管的 Kubernetes 服务</li><li>兼容标准 Kubernetes 工具</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img223132.png"></p><ul><li>EKS Data Volumes (需要 StorageClass)<ul><li>使用 Container Storage Interface (CSI) 驱动</li><li>支持的存储类型: EBS (块存储), EFS (文件系统), FSx (高性能文件系统)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img223503.png"></p><p>EKS Node Type (三种节点类型)</p><ul><li><p>Managed Node Groups (托管节点组)</p><ul><li>针对 EC2 Instance</li><li>AWS 自动管理节点生命周期</li><li>自动更新和修补</li></ul></li><li><p>Self-Managed Nodes (自管理节点)</p><ul><li>自己创建和管理 EC2 实例</li><li>完全控制节点配置</li><li>更多灵活性但需要更多管理</li></ul></li><li><p>AWS Fargate</p><ul><li>不需要管理节点</li><li>Serverless</li><li>按 Pod 资源计费</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img022321.png"></p><hr><h4 id="AWS-App-Runner"><a href="#AWS-App-Runner" class="headerlink" title="AWS App Runner"></a>AWS App Runner</h4><ul><li>部署 Web 应用和 API (Build 和 Deploy)<ul><li>完全托管服务</li><li>不需要基础设施经验 (不需要 AWS 经验)</li><li>自动构建和部署</li><li>Serverless</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img223649.png"></p><hr><h3 id="17-Serverless"><a href="#17-Serverless" class="headerlink" title="17. Serverless"></a>17. Serverless</h3><h4 id="AWS-Lambda"><a href="#AWS-Lambda" class="headerlink" title="AWS Lambda"></a>AWS Lambda</h4><ul><li>虚拟函数, Serverless, 时间受限 (短期执行, 最长 15 分钟)<ul><li>按需运行, 自动扩展</li><li>无需管理服务器</li><li>按实际使用时间计费 (毫秒级)</li></ul></li><li>触发方式<ul><li>Event-Driven (事件驱动) - S3 事件, DynamoDB 流, API Gateway 等</li><li>CRON Job (定时任务) - 使用 EventBridge 定期触发 Lambda (如每小时)</li></ul></li><li>配额限制<ul><li>Lambda 有 account quota (账户配额限制)</li><li>需要联系 AWS 提高上限</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img212846.png"></p><p>Lambda Limits (限制)</p><ul><li>Execution (执行限制)<ul><li>Memory: 128 MB - 10 GB</li><li>Execution Time: 最长 15 分钟</li></ul></li><li>Deployment (部署限制)<ul><li>压缩后部署包大小: 50 MB</li><li>解压后大小: 250 MB</li><li>容器镜像大小: 10 GB</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img213554.png"></p><blockquote><p>VPC 访问重要说明: 默认情况下, Lambda 函数运行在 AWS 拥有的 VPC 中, 可以访问公共互联网和公共 AWS API。一旦 Lambda 启用 VPC, 需要通过公共子网中的 NAT Gateway 才能访问公共资源。</p></blockquote><hr><h4 id="Lambda-SnapStart"><a href="#Lambda-SnapStart" class="headerlink" title="Lambda SnapStart"></a>Lambda SnapStart</h4><ul><li>提升 Lambda 函数冷启动性能<ul><li>针对 Java 11 及以上版本</li><li>函数从预初始化状态调用</li><li>大幅减少冷启动时间</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img213945.png"></p><hr><h4 id="CloudFront-Functions-amp-Lambda-Edge"><a href="#CloudFront-Functions-amp-Lambda-Edge" class="headerlink" title="CloudFront Functions &amp; Lambda@Edge"></a>CloudFront Functions &amp; Lambda@Edge</h4><ul><li>在边缘位置执行逻辑 (Edge Function, Serverless), 两种方法</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img214215.png"></p><ul><li>CloudFront Functions (JavaScript)<ul><li>CloudFront 原生功能</li><li>执行时间短 (亚毫秒级)</li><li>轻量级函数</li><li>只能在 Viewer Request 和 Viewer Response 阶段执行</li><li>更便宜</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img214350.png"></p><ul><li>Lambda@Edge (Node.js 或 Python)<ul><li>执行时间更长 (最长几秒)</li><li>更复杂的处理</li><li>可在所有 4 个阶段执行: Viewer Request, Origin Request, Origin Response, Viewer Response</li><li>支持网络访问和文件系统访问</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img214545.png"></p><ul><li>CloudFront Functions vs. Lambda@Edge<ul><li>CloudFront Functions: 简单轻量操作, 如 URL 重写、头修改</li><li>Lambda@Edge: 复杂处理, 如访问外部服务、数据库查询</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img214716.png"></p><hr><h4 id="Lambda-in-VPC"><a href="#Lambda-in-VPC" class="headerlink" title="Lambda in VPC"></a>Lambda in VPC</h4><ul><li>Lambda 访问 VPC 资源</li><li>默认情况<ul><li>Lambda 运行在 AWS 拥有的 VPC 中</li><li>可以访问公共互联网和公共 AWS API</li><li>无法访问用户的私有 VPC 资源</li></ul></li><li>Lambda in VPC 配置<ul><li>将 Lambda 部署到用户的 VPC 中</li><li>可以访问 VPC 内的私有资源 (如 RDS, ElastiCache)</li><li>需要指定 VPC, 子网和安全组</li><li>需要 NAT Gateway 才能访问公共互联网</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img214940.png"></p><hr><h4 id="RDS-with-Lambda"><a href="#RDS-with-Lambda" class="headerlink" title="RDS with Lambda"></a>RDS with Lambda</h4><ul><li>从数据库实例调用 Lambda 函数</li><li>支持的数据库: RDS for PostgreSQL, Aurora for MySQL (需要配置适当的权限)</li><li>工作原理<ul><li>数据库可以直接触发 Lambda 函数</li><li>在数据库内部事件时调用 Lambda</li><li>实现数据库驱动的自动化</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img215442.png"></p><hr><h4 id="AWS-DynamoDB"><a href="#AWS-DynamoDB" class="headerlink" title="AWS DynamoDB"></a>AWS DynamoDB</h4><ul><li>NoSQL 数据库, 跨多个 AZ 复制, 自动扩展, 无需预配置<ul><li>完全托管的 NoSQL 数据库</li><li>高可用性, 跨多个 AZ 复制</li><li>毫秒级延迟</li><li>无需预配置服务器</li></ul></li><li>两种 Class: Standard (标准) &amp; Infrequent Access (IA, 不频繁访问)</li><li>考试要点<ul><li>问到 DynamoDB 且处理 Email → 选择 DynamoDB Stream</li><li>问到关于 Stream → 考虑 DynamoDB Stream</li><li>问到 DynamoDB 且处理 unpredictable (不可预测) 数据 → 选择 On-Demand table</li><li>默认情况下, DynamoDB 表使用 AWS owned key 加密</li><li>不要用数据库存储图片</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img224558.png"></p><ul><li>Read&#x2F;Write Capacity Mode: RCU 和 WCU 没有关联 (可以只增加 RCU 不增加 WCU)</li><li>Provisioned Mode (预配置模式)<ul><li>自己定义需要多少 RCU (读取容量单位) 和 WCU (写入容量单位)</li><li>可预测的流量</li><li>成本更低</li><li>可以配置 Auto Scaling</li></ul></li><li>On-Demand Mode (按需模式)<ul><li>自动扩展 RCU 和 WCU</li><li>不可预测的流量</li><li>更贵</li><li>无需容量规划</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img225117.png"></p><ul><li>Point-In-Time Recovery (PITR, 时间点恢复, 重要)<ul><li>启用 PITR 后, DynamoDB 自动备份表数据</li><li>每秒粒度的备份</li><li>可以恢复到过去 35 天内的任意时刻</li><li>保护数据免受意外删除或写入</li></ul></li></ul><hr><h4 id="DynamoDB-Advance"><a href="#DynamoDB-Advance" class="headerlink" title="DynamoDB Advance"></a>DynamoDB Advance</h4><ul><li>DynamoDB Accelerator (DAX)<ul><li>处理 cache, 但 DAX 不是 relational 的</li><li>通过缓存解决读取拥塞问题</li><li>微秒级延迟</li><li>不支持 SQL query caching</li><li>提高 DynamoDB 的 read 性能, 不是 write (重要)</li><li>完全托管的内存缓存</li><li>与 DynamoDB 完全兼容</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img233440.png"></p><ul><li>DynamoDB Stream Processing (流处理)<ul><li>表中项目级修改的有序流</li><li>用来处理 Stream</li><li>可以调用 Lambda 函数 (如发送邮件)</li><li>捕获数据变更 (INSERT, UPDATE, DELETE)</li><li>24 小时数据保留</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img233610.png"></p><ul><li>DynamoDB Global Tables (全球表, 重要)<ul><li>使 DynamoDB 表在多个 Region 以低延迟访问</li><li>前提: 需要先启用 DynamoDB Stream</li><li>多区域, 多主复制</li><li>自动跨区域复制</li><li>提供灾难恢复能力</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img233729.png"></p><ul><li>DynamoDB Time To Live (TTL, 生存时间, 重要)<ul><li>在过期时间戳后自动删除项目</li><li>定时删除 DynamoDB 里的 item</li><li>无需额外成本</li><li>后台自动清理过期数据</li><li>减少存储成本</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img233830.png"></p><hr><h4 id="AWS-API-Gateway"><a href="#AWS-API-Gateway" class="headerlink" title="AWS API Gateway"></a>AWS API Gateway</h4><ul><li>创建、发布和管理 API 的托管服务<ul><li>调用 Lambda 函数</li><li>暴露 REST API (无状态客户端-服务器通信)</li><li>Lambda + API Gateway &#x3D; 无需管理基础设施</li><li>Serverless 架构的关键组件</li></ul></li><li>API 保护<ul><li>防止 API 被过多请求压垮 (防抖, 节流)</li><li>支持请求限流和配额管理</li></ul></li><li>API Gateway Caching (缓存)<ul><li>可以改善延迟 (improve latency)</li><li>减少对后端的调用次数</li><li>降低成本和提升性能</li><li>记住: Read Replica 是要额外付费的</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img234222.png"></p><p>API Gateway Endpoint Types (端点类型)</p><ul><li><p>Edge-Optimized (边缘优化, 默认)</p><ul><li>适合全球客户端</li><li>API Gateway 位于一个 Region</li><li>通过 CloudFront 边缘位置路由请求</li><li>降低全球用户延迟</li></ul></li><li><p>Regional (区域性)</p><ul><li>适合同一 Region 的客户端</li><li>不使用 CloudFront</li><li>可以手动配置 CloudFront</li></ul></li><li><p>Private (私有)</p><ul><li>针对 VPC 内部访问</li><li>只能从 VPC 内访问</li><li>使用 VPC Endpoint</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img174118.png"></p><hr><h4 id="AWS-Step-Functions"><a href="#AWS-Step-Functions" class="headerlink" title="AWS Step Functions"></a>AWS Step Functions</h4><ul><li>构建 Serverless 可视化工作流来编排 Lambda 函数<ul><li>搭建 Serverless 可视化 Workflow (重要)</li><li>协调多个 AWS 服务</li><li>无需编写复杂的编排代码</li><li>可视化设计和监控</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img234352.png"></p><hr><h4 id="AWS-Cognito"><a href="#AWS-Cognito" class="headerlink" title="AWS Cognito"></a>AWS Cognito</h4><ul><li>为用户提供身份以与 Web 或移动应用交互, 两个核心组件</li><li>Cognito User Pools (用户池)<ul><li>负责用户登录, 内置用户管理功能</li><li>用户注册、登录、密码重置</li><li>支持 MFA</li><li>支持社交登录 (Google, Facebook 等)</li></ul></li><li>Cognito Identity Pools (身份池)<ul><li>提供临时 AWS credentials</li><li>允许用户访问 AWS 服务 (如 S3, DynamoDB)</li><li>支持匿名访客访问</li></ul></li><li>重要考试要点: ALB + Cognito User Pool 才是做身份验证 (Auth) 的, 不是 CloudFront</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img234512.png"></p><hr><h3 id="18-Database-Summary"><a href="#18-Database-Summary" class="headerlink" title="18. Database Summary"></a>18. Database Summary</h3><h4 id="AWS-RDS"><a href="#AWS-RDS" class="headerlink" title="AWS RDS"></a>AWS RDS</h4><ul><li>AWS RDS (Relational Database Service) - 托管关系型数据库服务</li><li>支持的数据库引擎: PostgreSQL, MySQL, Oracle, SQL Server, MariaDB, Amazon Aurora</li><li>核心特性<ul><li>需要预配置 (Provisioned)</li><li>支持 Auto Scaling (存储自动扩展)</li><li>自动备份</li></ul></li><li>高级功能<ul><li>Read Replica (只读副本) - 提升读取性能</li><li>Multi-AZ (多可用区) - 提供高可用性和故障转移</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img151151.png"></p><hr><h4 id="AWS-Aurora-1"><a href="#AWS-Aurora-1" class="headerlink" title="AWS Aurora"></a>AWS Aurora</h4><ul><li>AWS Aurora - AWS 专有的高性能关系型数据库</li><li>支持的数据库引擎: PostgreSQL, MySQL</li><li>核心特性<ul><li>数据存储在 6 个副本, 跨 3 个 AZ</li><li>高可用性</li><li>自动扩展</li><li>比 MySQL 快 5 倍, 比 PostgreSQL 快 3 倍</li></ul></li><li>Aurora Serverless<ul><li>适合不可预测的工作负载 (unpredictable workloads)</li><li>自动启动、关闭和扩展容量</li><li>按实际使用付费</li></ul></li><li>Aurora Global (全球数据库)<ul><li>跨 Region 复制延迟小于 1 秒</li><li>保证至少有一个 Replica 可用</li><li>灾难恢复</li><li>全球低延迟访问</li></ul></li><li>Aurora Database Cloning (数据库克隆)<ul><li>快速访问 Aurora DB</li><li>使用写时复制技术</li><li>适合生成测试数据库</li><li>比 snapshot 和 restore 快得多</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img151441.png"></p><hr><h4 id="AWS-ElastiCache-1"><a href="#AWS-ElastiCache-1" class="headerlink" title="AWS ElastiCache"></a>AWS ElastiCache</h4><ul><li>AWS ElastiCache - 托管的内存数据存储服务</li><li>支持的引擎: Redis, Memcached, In-memory data store (回去看第七章)</li><li>核心特性<ul><li>内存缓存, 微秒级延迟</li><li>减少数据库负载</li><li>提升应用性能</li></ul></li><li>Redis 高级功能<ul><li>支持 Clustering (集群)</li><li>Multi-AZ (高可用性)</li><li>Read Replicas (Shard, 分片)</li><li>持久化</li><li>数据结构支持</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img151732.png"></p><hr><h4 id="AWS-DynamoDB-SM"><a href="#AWS-DynamoDB-SM" class="headerlink" title="AWS DynamoDB (SM)"></a>AWS DynamoDB (SM)</h4><ul><li>AWS DynamoDB - Serverless NoSQL 数据库</li><li>核心特点<ul><li>Serverless, 无需管理服务器</li><li>NoSQL 数据库</li><li>适合快速变化的 schemas (回去看第十七章)</li><li>毫秒级延迟</li><li>跨多个 AZ 复制</li></ul></li><li>Capacity Modes (容量模式)<ul><li>Provisioned Capacity (预配置容量) - 预测流量, 成本更低</li><li>On-Demand Capacity (按需容量) - 不可预测流量, 自动扩展</li></ul></li><li>DAX (DynamoDB Accelerator)<ul><li>读取缓存集群</li><li>微秒级读取延迟</li><li>完全托管的内存缓存</li><li>提升读取性能</li></ul></li><li>Event Processing (事件处理)<ul><li>DynamoDB Streams + Lambda - 实时处理数据变更</li><li>Kinesis Data Streams - 更大规模的流处理</li></ul></li><li>数据导入&#x2F;导出<ul><li>Export to S3 不使用 RCU - 导出不消耗读取容量</li><li>Import from S3 不使用 WCU - 导入不消耗写入容量</li><li>成本效益高的数据迁移</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img152140.png"></p><hr><h4 id="AWS-S3"><a href="#AWS-S3" class="headerlink" title="AWS S3"></a>AWS S3</h4><ul><li>AWS S3 (Simple Storage Service) - 对象存储服务</li><li>核心特点<ul><li>键&#x2F;值存储对象 (Key&#x2F;Value store)</li><li>适合文件体积大的存储 (回去看第十章)</li><li>无限存储容量</li><li>高持久性 (99.999999999%, 11 个 9)</li></ul></li><li>存储层级 (Tiers)<ul><li>Standard - 频繁访问</li><li>Intelligent-Tiering - 自动分层</li><li>Standard-IA - 不频繁访问</li><li>One Zone-IA - 单区域不频繁访问</li><li>Glacier - 归档</li><li>Glacier Deep Archive - 长期归档</li></ul></li><li>核心功能 (Features)<ul><li>Versioning (版本控制) - 保留对象的多个版本</li><li>Encryption (加密) - 静态和传输加密</li><li>Replication (复制) - CRR (跨区域) 和 SRR (同区域)</li><li>Lifecycle Policies (生命周期策略)</li><li>Event Notifications (事件通知)</li></ul></li><li>加密方式 (Encryption)<ul><li>SSE-S3 - S3 托管密钥, 免费, 默认</li><li>SSE-KMS - KMS 托管密钥, 可审计, 密钥轮换</li><li>SSE-C - 客户提供密钥, 客户完全控制</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img152526.png"></p><hr><h4 id="AWS-DocumentDB"><a href="#AWS-DocumentDB" class="headerlink" title="AWS DocumentDB"></a>AWS DocumentDB</h4><ul><li>托管的 MongoDB 兼容数据库</li><li>核心特点<ul><li>专为 MongoDB 设计 (只负责 MongoDB)</li><li>NoSQL 文档数据库</li></ul></li><li>特性<ul><li>跨 3 个 AZ 存储 6 个副本</li><li>自动扩展存储 (最多 64 TB)</li><li>每秒数百万请求</li><li>自动备份和时间点恢复</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img152629.png"></p><hr><h4 id="AWS-Neptune"><a href="#AWS-Neptune" class="headerlink" title="AWS Neptune"></a>AWS Neptune</h4><ul><li>图数据库服务<ul><li>适合社交网络 (Social Network)</li><li>完全托管, 高可用性</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img152726.png"></p><hr><h4 id="AWS-Keyspaces"><a href="#AWS-Keyspaces" class="headerlink" title="AWS Keyspaces"></a>AWS Keyspaces</h4><ul><li>托管的 Apache Cassandra 数据库服务</li><li>核心特点<ul><li>管理 Apache Cassandra (也是 NoSQL)</li><li>Serverless, 完全托管</li><li>兼容 Cassandra Query Language (CQL)</li></ul></li><li>使用场景: 存储 IoT 设备信息, 时间序列数据, 工业设备监控</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img153058.png"></p><hr><h4 id="AWS-QLDB"><a href="#AWS-QLDB" class="headerlink" title="AWS QLDB"></a>AWS QLDB</h4><ul><li>量子账本数据库<ul><li>Immutable (不可变, 无法删除)</li><li>用于记录金融交易</li><li>Serverless, 完全托管</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img153301.png"></p><hr><h4 id="AWS-Timestream"><a href="#AWS-Timestream" class="headerlink" title="AWS Timestream"></a>AWS Timestream</h4><ul><li>Serverless 时间序列数据库<ul><li>Serverless Time Series Database (时间序列数据库)</li><li>完全托管, 快速且可扩展</li><li>自动分层存储</li></ul></li><li>使用场景: IoT 应用, 实时分析</li><li>比传统关系型数据库快 1000 倍</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img153436.png"></p><hr><h3 id="19-Data-amp-Analytics"><a href="#19-Data-amp-Analytics" class="headerlink" title="19. Data &amp; Analytics"></a>19. Data &amp; Analytics</h3><h4 id="AWS-Athena"><a href="#AWS-Athena" class="headerlink" title="AWS Athena"></a>AWS Athena</h4><ul><li>交互式查询服务, 直接在 S3 中分析数据<ul><li>使用标准 SQL 直接分析 S3 数据</li><li>Serverless</li><li>按查询扫描的数据量付费</li><li>无需加载数据</li></ul></li><li>重要限制<ul><li>Athena 支持 SQL query 处理 S3 数据</li><li>Athena 无法实时分析数据 (重要)</li><li>适合临时查询和分析</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img200048.png"></p><ul><li>Performance Improvement (性能优化)<ul><li>使用列式数据格式节省成本</li><li>更少的数据扫描</li><li>推荐格式: Parquet, ORC</li><li>数据分区提升性能</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img200302.png"></p><ul><li>Federated Query (联合查询)<ul><li>允许跨 AWS 或本地存储的数据运行 SQL 查询</li><li>连接多个数据源</li><li>使用 Data Source Connectors</li><li>查询 RDS, DynamoDB, Redshift 等</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img200427.png"></p><hr><h4 id="AWS-Redshift"><a href="#AWS-Redshift" class="headerlink" title="AWS Redshift"></a>AWS Redshift</h4><ul><li>数据仓库服务<ul><li>基于 PostgreSQL, 但是是 OLAP (在线分析处理)</li><li>列式存储</li><li>MPP (大规模并行处理)</li><li>SQL 查询支持</li></ul></li><li>使用场景: 处理 BI (商业智能) 数据, 与 AWS QuickSight 或 Tableau 配合使用, PB 级数据规模 → Redshift (重要)</li><li>考试要点: 如果问到 Redshift 且和 S3 有关 → Redshift Spectrum (重要)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img201036.png"></p><ul><li>Snapshots &amp; DR (快照和灾难恢复)<ul><li>Redshift 有 “Multi-AZ” 模式支持集群</li><li>启用自动快照, 将 Redshift 集群快照复制到其他 AWS Region</li><li>时间点恢复</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img201212.png"></p><ul><li>Load Data into Redshift (加载数据到 Redshift)<ul><li>Kinesis Data Firehose - 流数据加载</li><li>S3 with Enhanced VPC Routing (注意) - 通过 VPC 从 S3 加载</li><li>EC2 Instance - JDBC&#x2F;ODBC 连接加载</li><li>AWS DMS (数据库迁移)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img230656.png"></p><ul><li>Redshift Spectrum (和 S3 有关)<ul><li>查询 S3 中的数据无需加载 (重要)</li><li>扩展查询到 S3 的 exabyte 级数据</li><li>无需 ETL, 按扫描数据量付费</li><li>使用现有 Redshift 集群的计算资源</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img201418.png"></p><hr><h4 id="AWS-OpenSearch"><a href="#AWS-OpenSearch" class="headerlink" title="AWS OpenSearch"></a>AWS OpenSearch</h4><ul><li>搜索和分析服务<ul><li>可以搜索任何字段, 甚至部分匹配</li><li>原名 ElasticSearch (专门做查询的)</li><li>全文搜索引擎, 实时数据分析</li></ul></li><li>特点<ul><li>可以实时处理和搜索日志</li><li>支持复杂查询</li><li>可视化仪表板 (OpenSearch Dashboards)</li><li>支持 Kibana 可视化</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img203117.png"></p><hr><h4 id="AWS-EMR-Elastic-MapReduce"><a href="#AWS-EMR-Elastic-MapReduce" class="headerlink" title="AWS EMR (Elastic MapReduce)"></a>AWS EMR (Elastic MapReduce)</h4><ul><li>大数据处理服务<ul><li>帮助创建 Hadoop 集群 (Big Data)</li><li>托管的大数据框架, 快速处理大量数据</li></ul></li><li>考试要点: 提到 Hadoop、Apache Spark 等 → 选 EMR</li><li>支持的框架: Hadoop, Apache Spark, Flink</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img203405.png"></p><ul><li>Node Types (节点类型)<ul><li>Master Node (主节点) - 管理集群, 协调任务</li><li>Core Node (核心节点) - 运行任务并存储数据 (HDFS)</li><li>Task Node (任务节点) - 只运行任务, 不存储数据 (可选)</li></ul></li><li>Purchasing Options (购买选项)<ul><li>On-Demand - 灵活, 按需付费</li><li>Reserved (1-3 年) - 成本节省, 长期工作负载</li><li>Spot Instances - 最便宜, 适合 Task Nodes</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img203545.png"></p><hr><h4 id="AWS-QuickSight"><a href="#AWS-QuickSight" class="headerlink" title="AWS QuickSight"></a>AWS QuickSight</h4><ul><li>Serverless 商业智能服务<ul><li>使用 ML 分析商业数据并创建 Dashboard</li></ul></li><li>使用 SPICE 引擎进行内存计算</li><li>快速查询性能, 自动扩展, 按会话付费</li><li>数据源: RDS, Aurora, Redshift, Athena, S3, On-premises 数据库</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img203724.png"></p><ul><li>Dashboard &amp; Analysis (仪表板和分析) <ul><li>可以选择性地与用户或组分享分析或仪表板</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img203954.png"></p><hr><h4 id="AWS-Glue"><a href="#AWS-Glue" class="headerlink" title="AWS Glue"></a>AWS Glue</h4><ul><li>托管的 ETL (提取、转换、加载) 服务<ul><li>帮助客户准备和加载数据进行分析</li><li>遇到处理 ETL → 选 Glue, 使用 Apache Spark</li><li>使用 AWS Glue 处理 S3 中的原始数据 (重要)</li></ul></li><li>数据源和目标: Amazon S3, VPC 中的数据存储, 本地 JDBC 数据存储, 提取、转换并加载数据回这些位置</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img224509.png"></p><ul><li>数据格式转换<ul><li>转换数据为 Apache Parquet 格式 (会考)</li><li>看到 Apache Parquet → 想到 Glue</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img224817.png"></p><ul><li>Glue 组件<ul><li>Glue Job Bookmarks (重要): 防止重新处理旧数据, 避免重复处理</li><li>Glue Elastic Views: 使用 SQL 跨多个数据存储组合和复制数据, 实时物化视图</li><li>Glue DataBrew: 清理和规范化数据, 可视化数据准备工具</li></ul></li></ul><hr><h4 id="AWS-Lake-Formation"><a href="#AWS-Lake-Formation" class="headerlink" title="AWS Lake Formation"></a>AWS Lake Formation</h4><ul><li>托管服务, 用于设置数据湖<ul><li>设置和管理数据湖 (Data Lake)</li><li>集中存储所有用于分析的数据</li><li>简化数据湖创建过程</li></ul></li><li>考试要点: 题目提到 Fine-grained Access Control (细粒度访问控制) for applications → 想到 Lake Formation</li><li>数据源: S3, RDS, 关系型和 NoSQL 数据库, 本地数据源</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img224948.png"></p><hr><h4 id="Kinesis-Data-Analytics"><a href="#Kinesis-Data-Analytics" class="headerlink" title="Kinesis Data Analytics"></a>Kinesis Data Analytics</h4><ul><li>实时流数据分析服务<ul><li>对 Kinesis Data Streams 和 Firehose 使用 SQL 进行实时分析 (重要)</li><li>完全托管, 自动扩展, Serverless</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img225813.png"></p><ul><li>两种模式<ul><li>Kinesis Data Analytics for SQL: 使用标准 SQL 查询流数据, 适合简单的流处理</li><li>Amazon Managed Service for Apache Flink: 使用 Java, Scala, Python 编写复杂流处理应用, 更强大的流处理能力</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img225906.png"></p><hr><h4 id="AWS-MSK-Managed-Streaming-for-Apache-Kafka"><a href="#AWS-MSK-Managed-Streaming-for-Apache-Kafka" class="headerlink" title="AWS MSK (Managed Streaming for Apache Kafka)"></a>AWS MSK (Managed Streaming for Apache Kafka)</h4><ul><li>托管的 Apache Kafka 服务<ul><li>管理 Apache Kafka (有 Serverless 选项)</li><li>Kinesis 的替代方案 (同样处理流数据), 但针对 Apache Kafka</li></ul></li><li>部署模式: Provisioned (预配置), Serverless (无服务器)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img230056.png"></p><ul><li>Kinesis Data Streams vs. AWS MSK<ul><li>Kinesis Data Streams: AWS 原生服务, 简单易用, 与 AWS 服务深度集成, 按 shard 计费, 数据保留 1-365 天, 1 MB 消息限制</li><li>AWS MSK: Apache Kafka 兼容, 开源生态系统, 适合现有 Kafka 应用迁移, 无消息大小限制, 更长数据保留期</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img230216.png"></p><ul><li>选择建议<ul><li>新项目且深度 AWS 集成 → Kinesis</li><li>现有 Kafka 应用或需要 Kafka 生态 → MSK</li></ul></li></ul><hr><h3 id="20-Machine-Learning"><a href="#20-Machine-Learning" class="headerlink" title="20. Machine Learning"></a>20. Machine Learning</h3><h4 id="AWS-Rekognition"><a href="#AWS-Rekognition" class="headerlink" title="AWS Rekognition"></a>AWS Rekognition</h4><ul><li>图像和视频分析服务<ul><li>使用 ML 在图像和视频中识别物体、人物、文本、场景</li><li>面部分析和面部搜索</li></ul></li><li>Content Moderation (内容审核, 重要): 检测不适当的内容</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img004131.png"></p><hr><h4 id="AWS-Transcribe"><a href="#AWS-Transcribe" class="headerlink" title="AWS Transcribe"></a>AWS Transcribe</h4><ul><li>语音转文字服务<ul><li>将语音转换为文本 (Transcribe 是转录的意思)</li><li>自动语音识别 (ASR), 支持多种语言</li></ul></li><li>PII 保护 (重要): 自动删除个人身份信息 (PII)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img004337.png"></p><hr><h4 id="AWS-Polly"><a href="#AWS-Polly" class="headerlink" title="AWS Polly"></a>AWS Polly</h4><ul><li>文字转语音服务<ul><li>将文本转换为语音, 支持多种语言和声音</li></ul></li><li>高级功能<ul><li>Pronunciation Lexicons (发音词典): 自定义单词发音</li><li>Speech Synthesis Markup Language (SSML): 强调特定单词</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img004547.png"></p><hr><h4 id="AWS-Translate"><a href="#AWS-Translate" class="headerlink" title="AWS Translate"></a>AWS Translate</h4><ul><li>语言翻译服务<ul><li>神经机器翻译, 支持多种语言互译</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img004816.png"></p><hr><h4 id="AWS-Lex-amp-Connect"><a href="#AWS-Lex-amp-Connect" class="headerlink" title="AWS Lex &amp; Connect"></a>AWS Lex &amp; Connect</h4><ul><li>对话和联络中心服务</li><li>AWS Lex<ul><li>构建聊天机器人 (所有和 chatbot 有关的都是 Lex)</li><li>与 Alexa 相同的技术</li><li>自动语音识别 (ASR), 自然语言理解 (NLU)</li></ul></li><li>AWS Connect<ul><li>构建云端联络中心, 虚拟呼叫中心, 接收和拨打电话</li><li>与 Lex 集成实现智能客服</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img004954.png"></p><hr><h4 id="AWS-Comprehend"><a href="#AWS-Comprehend" class="headerlink" title="AWS Comprehend"></a>AWS Comprehend</h4><ul><li>自然语言处理 (NLP) 服务<ul><li>Natural Language Processing (NLP)</li><li>文本分析, 情感分析, 关键短语提取, 语言检测</li></ul></li><li>Comprehend Medical (重要)<ul><li>用于临床文本 (医疗方面, 非常重要)</li><li>从非结构化医疗文本中提取信息</li><li>识别医疗实体 (药物、诊断、症状等)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img005107.png"></p><hr><h4 id="AWS-SageMaker"><a href="#AWS-SageMaker" class="headerlink" title="AWS SageMaker"></a>AWS SageMaker</h4><ul><li>机器学习平台<ul><li>构建机器学习模型</li><li>完全托管的 ML 服务</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img005342.png"></p><hr><h4 id="AWS-Forecast"><a href="#AWS-Forecast" class="headerlink" title="AWS Forecast"></a>AWS Forecast</h4><ul><li>时间序列预测服务<ul><li>使用 ML 提供高精度预测</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img012641.png"></p><hr><h4 id="AWS-Kendra"><a href="#AWS-Kendra" class="headerlink" title="AWS Kendra"></a>AWS Kendra</h4><ul><li>智能文档搜索服务<ul><li>托管的文档搜索服务</li><li>使用机器学习, 从文档中提取精准答案</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img012746.png"></p><hr><h4 id="AWS-Personalize"><a href="#AWS-Personalize" class="headerlink" title="AWS Personalize"></a>AWS Personalize</h4><ul><li>个性化推荐服务<ul><li>使用 ML 提供实时个性化推荐</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img012921.png"></p><hr><h4 id="AWS-Textract"><a href="#AWS-Textract" class="headerlink" title="AWS Textract"></a>AWS Textract</h4><ul><li>文档文本提取服务<ul><li>使用 ML 提取文本 (重要)</li><li>自动从文档中提取文本和数据</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img013008.png"></p><hr><h3 id="21-AWS-Mointoring-amp-Audit"><a href="#21-AWS-Mointoring-amp-Audit" class="headerlink" title="21. AWS Mointoring &amp; Audit"></a>21. AWS Mointoring &amp; Audit</h3><h4 id="CloudWatch-Metrics"><a href="#CloudWatch-Metrics" class="headerlink" title="CloudWatch Metrics"></a>CloudWatch Metrics</h4><ul><li>监控 AWS 服务的指标服务<ul><li>CloudWatch Metrics 帮助监控 AWS 中的每个服务</li><li>可以使用 CloudWatch Metrics 处理 CloudTrail logs 来监视异常活动</li><li>结合 CloudTrail 进行安全监控</li></ul></li><li>常见指标: EC2: CPU、网络、磁盘, RDS: 连接数、IOPS, Lambda: 调用次数、错误</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img150021.png"></p><ul><li>CloudWatch Metric Streams:<ul><li>近实时传输 CloudWatch Metrics (注意)</li><li>目标: Kinesis Data Firehose, S3, 第三方服务</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img150150.png"></p><hr><h4 id="CloudWatch-Logs"><a href="#CloudWatch-Logs" class="headerlink" title="CloudWatch Logs"></a>CloudWatch Logs</h4><ul><li>AWS 中存储应用日志的服务<ul><li>存储应用日志 (来源: S3, Kinesis, Lambda 等)</li><li>日志默认加密</li></ul></li><li>日志来源: EC2 实例, Lambda 函数, ECS&#x2F;EKS 容器, CloudTrail</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img150343.png"></p><ul><li>CloudWatch Logs Insights<ul><li>搜索和分析存储在 CloudWatch Logs 中的日志数据</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img150531.png"></p><ul><li>CloudWatch Logs Subscriptions (可以导出到 S3)<ul><li>从 CloudWatch Logs 获取实时日志事件进行处理和分析</li><li>目标: Kinesis Data Streams, Kinesis Data Firehose, Lambda</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img150643.png"></p><blockquote><p>重要特性: 可以配置 CloudWatch Logs log group 将接收的数据近实时流式传输到 Amazon OpenSearch Service 集群, 通过 CloudWatch Logs subscription</p></blockquote><hr><h4 id="CloudWatch-Agent"><a href="#CloudWatch-Agent" class="headerlink" title="CloudWatch Agent"></a>CloudWatch Agent</h4><ul><li>从 EC2 和本地服务器收集指标和日志<ul><li>重要前提: 默认情况下, EC2 不传递日志给 CloudWatch (重要)</li><li>需要安装 CloudWatch Agent 才能传递日志和自定义指标</li></ul></li><li>CloudWatch Logs Agent (旧版)<ul><li>只传递日志到 CloudWatch Logs</li></ul></li><li>CloudWatch Unified Agent (推荐)<ul><li>可以传递更多信息, 收集系统级指标: CPU, RAM, 磁盘, 网络等</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img151251.png"></p><hr><h4 id="CloudWatch-Alarms"><a href="#CloudWatch-Alarms" class="headerlink" title="CloudWatch Alarms"></a>CloudWatch Alarms</h4><ul><li>基于指标触发通知的告警服务<ul><li>CloudWatch Alarms 用于为任何指标触发通知 (使用 SNS 发送消息)</li><li>监控指标并采取行动</li></ul></li><li>告警目标 (Target)<ul><li>EC2 - 停止、终止、重启、恢复实例</li><li>ASG (Auto Scaling Group) - 触发扩展策略</li><li>SNS - 发送通知 (邮件、SMS 等)</li></ul></li><li>告警状态<ul><li>OK - 指标正常</li><li>ALARM - 超过阈值</li><li>INSUFFICIENT_DATA - 数据不足</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img151423.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img151514.png"></p><ul><li>Composite Alarms (复合告警)<ul><li>监视当前所有 Alarm 的状态</li><li>组合多个告警条件, 使用 AND&#x2F;OR 逻辑</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img151615.png"></p><hr><h4 id="AWS-EventBridge"><a href="#AWS-EventBridge" class="headerlink" title="AWS EventBridge"></a>AWS EventBridge</h4><ul><li>事件驱动架构的事件总线服务<ul><li>调度 CRON 作业 (定时重复任务, 事件驱动)</li><li>响应 SaaS 应用程序 (AWS 服务) 的事件</li><li>如果提到第三方应用程序 (3rd party application), 考虑 EventBridge</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img185605.png"></p><ul><li>基本上所有事件都要经过 EventBridge</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img185712.png"></p><ul><li>Event Bus (事件总线)<ul><li>Default Event Bus - AWS 服务事件</li><li>Partner Event Bus - 第三方 SaaS (如 Datadog, Zendesk)</li><li>Custom Event Bus - 自定义应用事件</li></ul></li><li>事件归档和重放<ul><li>可以归档事件 (Archive Events) 并且重放 (Replay)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img190403.png"></p><ul><li>Schema Registry (架构注册表)<ul><li>分析 Event Bus 中的事件并推断架构</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img190004.png"></p><ul><li>Resource-based Policy (基于资源的策略)<ul><li>管理特定 Event Bus 的权限 (允许&#x2F;拒绝)</li><li>跨账户事件共享</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img190215.png"></p><hr><h4 id="CloudWatch-Insights"><a href="#CloudWatch-Insights" class="headerlink" title="CloudWatch Insights"></a>CloudWatch Insights</h4><ul><li>一组针对特定场景的深度监控工具, 共有 4 种不同的 Insights</li><li>CloudWatch Container Insights (处理容器)<ul><li>收集、聚合、汇总容器的指标和日志</li><li>支持: ECS, EKS, Kubernetes, Fargate 等</li><li>容器级别监控</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img190651.png"></p><ul><li>CloudWatch Lambda Insights<ul><li>监控运行在 Lambda 上的 Serverless 应用</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img190750.png"></p><ul><li>CloudWatch Contributor Insights (注意, 可以查 IP)<ul><li>分析日志数据并显示贡献者数据 (用于系统性能)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img190854.png"></p><ul><li>CloudWatch Application Insights<ul><li>提供仪表板显示与 AWS 服务相关的潜在应用问题</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img191050.png"></p><ul><li>Container 问题 → Container Insights</li><li>Lambda 问题 → Lambda Insights</li><li>需要查看贡献者&#x2F;IP → Contributor Insights</li><li>应用整体健康 → Application Insights</li></ul><hr><h4 id="AWS-CloudTrail"><a href="#AWS-CloudTrail" class="headerlink" title="AWS CloudTrail"></a>AWS CloudTrail</h4><ul><li>AWS 账户的治理、合规和审计服务<ul><li>提供 AWS 账户的治理、合规和审计 (审计 events 和 API 调用)</li><li>记录事件历史或 API 调用</li><li>CloudTrail 是全球服务</li><li>如果资源被误删, 第一时间查看 CloudTrail</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img191802.png"></p><ul><li>CloudTrail Events (事件类型)<ul><li>Management Events (管理事件)<ul><li>在 AWS 账户资源上执行的操作, 创建、删除、修改资源</li></ul></li><li>Data Events (数据事件)<ul><li>S3 对象级活动 (GetObject, DeleteObject), Lambda 函数执行, DynamoDB 表操作</li></ul></li><li>CloudTrail Insights Events (洞察事件)<ul><li>检测异常活动 (安全), 使用 ML 识别不寻常的 API 使用</li></ul></li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img192042.png"></p><ul><li>CloudTrail Insights (重要)<ul><li>CloudTrail Insights 用于检测账户中的异常活动</li><li>检测场景: API 调用激增, 资源配置异常变化</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img192157.png"></p><ul><li>CloudTrail Event Retention (事件保留)<ul><li>将事件存储 90 天后保留到 S3</li><li>超过 90 天需要导出到 S3</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img192301.png"></p><hr><h4 id="AWS-Config"><a href="#AWS-Config" class="headerlink" title="AWS Config"></a>AWS Config</h4><ul><li>资源配置监控和合规性服务<ul><li>AWS Config 提供 AWS 资源配置的详细视图 (重要)</li><li>记录配置和随时间的变更 (记录 config 是否被修改)</li></ul></li><li>实用示例: 可以使用 Config 检查 ACM 证书是否临近过期</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img192656.png"></p><ul><li>Config Rules (配置规则)<ul><li>可以自定义 Rule 来检查资源合规性</li><li>也有 AWS managed rules (AWS 托管规则)</li></ul></li><li>常见 AWS 托管规则示例<ul><li>检查 S3 bucket 公开访问</li><li>检查 EC2 实例是否使用批准的 AMI</li><li>检查 EBS 卷是否加密</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img045705.png"></p><ul><li>Config Remediations (自动修复)<ul><li>自动修复 (remediation) 不合规资源, 使用 SSM Automation Documents</li><li>例如: 自动关闭不受限制的 SSH 访问</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img192951.png"></p><ul><li>Config Notifications (通知)<ul><li>使用 EventBridge 在 AWS 资源不合规时触发通知</li><li>集成 SNS, Lambda 等</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img193119.png"></p><ul><li>CloudTrail vs. Config<ul><li>CloudTrail: 谁在什么时候做了什么 (API 调用审计)</li><li>Config: 资源配置是什么, 如何变化 (配置管理)</li></ul></li></ul><hr><h3 id="22-IAM-Advanced"><a href="#22-IAM-Advanced" class="headerlink" title="22. IAM Advanced"></a>22. IAM Advanced</h3><h4 id="AWS-Organizations"><a href="#AWS-Organizations" class="headerlink" title="AWS Organizations"></a>AWS Organizations</h4><ul><li>管理多个 AWS 账户的全球服务<ul><li>管理多个 AWS 账户, 全球服务</li></ul></li><li>Consolidated Billing (合并账单, 重要)<ul><li>跨所有账户的合并账单</li><li>如果问到 Shield Advanced 相关的费用问题, 可能是没有设置 Consolidated Billing</li></ul></li><li>账户迁移: 要将账户转移到另一个 Organization, 必须先从原 Organization 中移除</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img235557.png"></p><ul><li>Service Control Policies (SCP, 限制用户)<ul><li>IAM 策略应用于 OU (组织单元) 或账户, 限制用户和角色</li><li>Blocklist (黑名单) 和 Allowlist (白名单) 模式</li><li>IAM Roles 针对服务, SCP 针对 Organization</li></ul></li><li>SCP 重要特性<ul><li>如果用户或角色的 IAM 权限策略授予了某个操作的访问权限, 但该操作被 SCP 不允许或明确拒绝, 则用户或角色无法执行该操作</li><li>SCP 影响成员账户中的所有用户和角色, 包括成员账户的 root 用户</li><li>SCP 不影响服务关联角色 (service-linked role)</li></ul></li><li>SCP vs. IAM<ul><li>SCP: 设置账户级别的最大权限边界</li><li>IAM: 授予具体权限</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img013921.png"></p><ul><li>IAM Permission Boundary (IAM 权限边界, 回去看第二章)<ul><li>权限边界是一种高级功能, 使用托管策略设置基于身份的策略可以授予 IAM 实体的最大权限</li><li>限制用户&#x2F;角色的最大权限</li></ul></li></ul><hr><h4 id="IAM-Conditions"><a href="#IAM-Conditions" class="headerlink" title="IAM Conditions"></a>IAM Conditions</h4><ul><li>IAM 策略中的条件语句<ul><li>在 IAM 策略中使用条件来精细控制权限</li><li>基于特定条件授予或拒绝访问</li></ul></li><li>重要区分: 要分清楚 bucket level permissions 和 object level permissions</li><li>Bucket Level Permissions<ul><li>针对整个 bucket 的操作</li><li>例如: s3:ListBucket, s3:CreateBucket, s3:DeleteBucket</li><li>资源格式: arn:aws:s3:::bucket-name</li></ul></li><li>Object Level Permissions (使用 &#x2F;*)<ul><li>针对 bucket 内对象的操作</li><li>例如: s3:GetObject, s3:PutObject, s3:DeleteObject</li><li>资源格式: arn:aws:s3:::bucket-name&#x2F;*</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img022652.png"></p><hr><h4 id="IAM-Roles-vs-Resource-Based-Policies"><a href="#IAM-Roles-vs-Resource-Based-Policies" class="headerlink" title="IAM Roles vs Resource Based Policies"></a>IAM Roles vs Resource Based Policies</h4><ul><li>两种不同的权限授予方式</li><li>IAM Role (角色)<ul><li>放弃原有权限, 承担角色分配的权限</li><li>临时切换身份</li><li>使用 AssumeRole</li></ul></li><li>Resource Based Policy (基于资源的策略)<ul><li>主体不需要放弃原有权限</li><li>保留原有身份和权限</li><li>直接访问资源</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img015940.png"></p><ul><li>EventBridge 示例<ul><li>支持 Resource Based Policy: Lambda, SNS, SQS, API Gateway</li><li>需要 IAM Roles: Kinesis Streams, Step Functions</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img023321.png"></p><hr><h4 id="Policy-Evaluation-Logic"><a href="#Policy-Evaluation-Logic" class="headerlink" title="Policy Evaluation Logic"></a>Policy Evaluation Logic</h4><ul><li>策略评估逻辑</li><li>IAM Permission Boundaries (IAM 权限边界)<ul><li>设置 IAM 实体可以获得的最大权限的功能</li><li>不授予权限, 只限制权限</li></ul></li><li>策略评估逻辑 (重要): 评估顺序 (先来后到)<ul><li>默认拒绝 (Implicit Deny)</li><li>显式拒绝 (Explicit Deny) - 最高优先级</li><li>允许 (Allow)</li></ul></li><li>关键原则: 先 Deny 就算后面 Allow 也没用</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img020209.png"></p><ul><li>示例答案: No, No, No<ul><li>如果有任何 Deny, 结果就是 Deny</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img161535.png"></p><hr><h4 id="IAM-Identity-Center"><a href="#IAM-Identity-Center" class="headerlink" title="IAM Identity Center"></a>IAM Identity Center</h4><ul><li>单点登录 (SSO) 服务<ul><li>一次登录访问所有资源 (SSO)</li><li>集中式身份管理</li></ul></li><li>支持的登录目标<ul><li>AWS Organizations 中的 AWS 账户</li><li>业务云应用 (如 Salesforce, Microsoft 365)</li><li>自定义 SAML 2.0 应用</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img020909.png"></p><p>Fine-grained Permissions and Assignments (细粒度权限和分配)</p><ul><li><p>Multi-Account Permissions (多账户权限)</p><ul><li>管理跨 AWS 账户的访问</li><li>集中管理多账户权限</li><li>权限集 (Permission Sets)</li><li>简化权限分配</li></ul></li><li><p>Application Assignments (应用分配)</p><ul><li>SSO 访问业务应用</li><li>预集成的 SaaS 应用</li><li>自定义 SAML 应用</li><li>统一访问体验</li></ul></li><li><p>Attribute-Based Access Control (ABAC, 基于属性的访问控制)</p><ul><li>基于用户属性 (标签) 的权限</li><li>使用标签控制访问</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img021246.png"></p><hr><h4 id="AWS-Directory-Services"><a href="#AWS-Directory-Services" class="headerlink" title="AWS Directory Services"></a>AWS Directory Services</h4><ul><li>在 AWS 中创建 Active Directory (AD, 目录服务) (重要), 三种类型</li><li>AWS Managed Microsoft AD<ul><li>在 AWS 中创建自己的 AD</li><li>完全托管的 Microsoft AD</li><li>支持多因素认证 (MFA)</li></ul></li><li>AD Connector<ul><li>代理重定向到本地 AD</li><li>不存储任何目录信息</li><li>充当网关&#x2F;代理</li></ul></li><li>Simple AD<ul><li>AWS 上兼容 AD 的托管目录</li><li>基于 Samba 4</li><li>低成本, 基本功能</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img021607.png"></p><ul><li>需要完整 Microsoft AD 功能 → AWS Managed Microsoft AD</li><li>已有本地 AD, 需要代理 → AD Connector</li><li>简单需求, 成本敏感 → Simple AD</li></ul><hr><h4 id="AWS-Control-Tower"><a href="#AWS-Control-Tower" class="headerlink" title="AWS Control Tower"></a>AWS Control Tower</h4><ul><li>设置和管理安全合规的多账户 AWS 环境 (重要)<ul><li>管理 AWS 多账户环境, 基于最佳实践 (Best Practice)</li></ul></li><li>Control Tower 使用 AWS Organizations 创建账户</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img021857.png"></p><p>Control Tower - Guardrails (护栏, 管理 Control Tower)</p><ul><li>Preventive Guardrail (预防性护栏)<ul><li>使用 SCP (服务控制策略)</li><li>主动阻止违规操作</li><li>例如: 限制所有账户的区域使用</li></ul></li><li>Detective Guardrail (检测性护栏)<ul><li>使用 AWS Config</li><li>检测不合规资源</li><li>例如: 识别未标记的资源</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img022019.png"></p><hr><h3 id="23-AWS-Security-amp-Encryption"><a href="#23-AWS-Security-amp-Encryption" class="headerlink" title="23. AWS Security &amp; Encryption"></a>23. AWS Security &amp; Encryption</h3><h4 id="AWS-KMS"><a href="#AWS-KMS" class="headerlink" title="AWS KMS"></a>AWS KMS</h4><ul><li>加密密钥管理服务<ul><li>听到 AWS 服务的 “encryption” 时, 很可能是 KMS</li><li>AWS 为我们管理加密密钥 (与大多数 AWS 服务集成)</li><li>集成服务: EBS, S3, RDS, SSM 等</li><li>KMS Keys 是区域级别的 (scoped per Region)</li><li>注意: KMS 并不适合保存 secret, 加密的东西不一定是 secret</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img170646.png"></p><p>Types of KMS Keys (3 种类型)</p><ul><li><p>AWS Owned Keys</p><ul><li>AWS 拥有和管理</li><li>免费</li><li>无法查看或管理</li><li>自动轮换</li></ul></li><li><p>AWS Managed Keys</p><ul><li>AWS 创建和管理</li><li>免费</li><li>可以查看策略</li><li>自动每年轮换</li><li>格式: aws&#x2F;service-name</li></ul></li><li><p>CMK (Customer Managed Keys, 客户托管密钥)</p><ul><li>完全控制</li><li>按使用付费</li><li>可自定义轮换策略</li><li>可删除</li></ul></li></ul><p>两种 Key 形式</p><ul><li><p>Symmetric (对称, 单密钥)</p><ul><li>单个加密密钥</li><li>加密和解密使用同一密钥</li><li>AWS 服务默认使用</li><li>密钥不会离开 KMS</li></ul></li><li><p>Asymmetric (非对称, 公钥和私钥)</p><ul><li>公钥和私钥对</li><li>公钥可下载</li><li>私钥不会离开 KMS</li><li>用于签名和验证</li></ul></li></ul><p>Automatic Key Rotation (自动密钥轮换)</p><ul><li>每 1 年自动轮换一次</li><li>仅适用于 Customer Managed Keys</li><li>AWS Managed Keys 自动每年轮换</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img171058.png"></p><p>KMS Key Policies (控制 KMS 密钥访问)</p><ul><li>Default KMS Key Policy<ul><li>整个 AWS 账户都可以访问</li><li>通过 IAM 策略控制访问</li></ul></li><li>Custom KMS Key Policy<ul><li>定义谁可以访问密钥</li><li>支持跨账户访问 (Cross Account Access)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img171356.png"></p><ul><li>密钥删除 (重要): 删除 AWS KMS 密钥是破坏性和潜在危险的操作。因此, AWS KMS 强制执行等待期 (Pending state)<ul><li>最短等待期: 7 天, 最长等待期: 30 天</li><li>在等待期内可以取消删除</li></ul></li></ul><hr><h4 id="KMS-Multi-Region-Keys"><a href="#KMS-Multi-Region-Keys" class="headerlink" title="KMS Multi-Region Keys"></a>KMS Multi-Region Keys</h4><ul><li>多区域 KMS 密钥<ul><li>在不同 AWS Region 拥有相同的 KMS 密钥</li><li>在一个 Region 加密, 在其他 Region 解密</li><li>独立管理但相互关联</li></ul></li><li>使用场景<ul><li>DynamoDB Global Tables - 跨区域加密数据</li><li>Global Aurora - 全球数据库加密</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img172433.png"></p><hr><h4 id="S3-Replication-with-Encryption"><a href="#S3-Replication-with-Encryption" class="headerlink" title="S3 Replication with Encryption"></a>S3 Replication with Encryption</h4><ul><li>S3 复制与加密<ul><li>默认复制行为: 未加密对象和使用 SSE-S3 加密的对象默认会被复制</li><li>SSE-KMS 加密对象复制: 使用 SSE-KMS 加密的对象需要更多选项配置. SSE-S3 在复制时会保持加密, 但 SSE-KMS 需要额外设置</li><li>SSE-KMS 复制所需配置: 指定目标 Region 的 KMS 密钥, 授予 S3 使用 KMS 密钥的权限</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img172816.png"></p><hr><h4 id="Encrypted-AMI-Sharing-Process"><a href="#Encrypted-AMI-Sharing-Process" class="headerlink" title="Encrypted AMI Sharing Process"></a>Encrypted AMI Sharing Process</h4><ul><li>共享加密 AMI 所需权限</li><li>需要 Launch Permission (启动权限)<ul><li>授予目标账户启动 AMI 的权限</li><li>修改 AMI 权限</li></ul></li><li>需要 Share KMS Keys (共享 KMS 密钥)<ul><li>修改 KMS 密钥策略</li><li>允许目标账户使用密钥</li></ul></li><li>需要 Permission to Decrypt (解密权限)<ul><li>目标账户的 IAM 角色&#x2F;用户需要解密权限</li><li>才能启动加密的 AMI</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img173020.png"></p><hr><h4 id="SSM-Parameter-Store"><a href="#SSM-Parameter-Store" class="headerlink" title="SSM Parameter Store"></a>SSM Parameter Store</h4><ul><li>Secure storage for configuration and secrets<ul><li>比起 Secrets Manager 有更广的用途, 比如 URLs, AMI IDs, License keys 等等</li></ul></li><li>Have built-in verion tracking (每次 edit secret 都会被记录)</li><li>SSM 没有 Automatic key rotation (重要)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img173611.png"></p><hr><h4 id="AWS-Secrets-Manager"><a href="#AWS-Secrets-Manager" class="headerlink" title="AWS Secrets Manager"></a>AWS Secrets Manager</h4><ul><li>配置和密钥的安全存储<ul><li>安全存储配置和密钥</li><li>比 Secrets Manager 用途更广泛</li><li>存储类型: 配置数据、URLs、AMI IDs、License keys、密码等</li><li>与 IAM 和 KMS 集成</li></ul></li><li>内置版本跟踪<ul><li>每次编辑 secret 都会被记录</li><li>保留历史版本, 可以回滚到之前版本</li></ul></li><li>重要限制: SSM Parameter Store 没有自动密钥轮换 (Automatic Key Rotation) (重要)<ul><li>需要手动更新密钥, 或使用 Lambda 自动化</li></ul></li><li>层级<ul><li>Standard - 免费, 最多 10,000 参数, 4KB 大小</li><li>Advanced - 收费, 最多 100,000 参数, 8KB 大小</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img174132.png"></p><ul><li>SSM Parameter Store vs. Secrets Manager<ul><li>Parameter Store: 更广泛的配置管理, 免费层, 无自动轮换</li><li>Secrets Manager: 专注密钥, 自动轮换, 更高级功能, 收费</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img174258.png"></p><hr><h4 id="AWS-Certificate-Manager-ACM"><a href="#AWS-Certificate-Manager-ACM" class="headerlink" title="AWS Certificate Manager (ACM)"></a>AWS Certificate Manager (ACM)</h4><ul><li>TLS 证书管理服务<ul><li>轻松配置、管理和部署 TLS 证书 (HTTPS)</li><li>免费的公共证书, 与 AWS 服务集成</li></ul></li><li>如果要给 Elastic Beanstalk 配置 HTTPS, 需要使用 ACM</li><li>重要限制: 如果是第三方 SSL 证书, 无法使用自动证书轮换 (automatic certificate rotation)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img174451.png"></p><ul><li>证书过期监控: 可以使用 EventBridge 检查 ACM 证书是否过期</li><li>证书类型  <ul><li>公共证书 - 免费, ACM 颁发</li><li>私有证书 - 使用 ACM Private CA, 收费</li><li>导入的证书 - 第三方证书</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img172923.png"></p><hr><h4 id="AWS-WAF"><a href="#AWS-WAF" class="headerlink" title="AWS WAF"></a>AWS WAF</h4><ul><li>Web 应用防火墙<ul><li>保护 Web 应用的第 7 层 (HTTP&#x2F;HTTPS)</li><li>防御常见 Web 攻击</li></ul></li><li>OSI 层级对比<ul><li>Layer 7 (应用层): HTTP&#x2F;HTTPS - WAF</li><li>Layer 4 (传输层): TCP&#x2F;UDP - Network Firewall</li><li>Layer 3 (网络层): IP - VPC, Security Groups</li></ul></li><li>阻止国家&#x2F;地区 (重要): 如果要阻止特定国家, 可以使用<ul><li>WAF Geo Match - 地理匹配</li><li>WAF IP Set Statement - IP 集合语句</li></ul></li><li>Rate-based Rules<ul><li>WAF 可以设置基于速率的规则</li><li>Shield 不支持速率限制</li><li>防止 DDoS 和暴力攻击</li><li>例如: 5 分钟内超过 2000 请求</li></ul></li><li>跨账户&#x2F;区域部署 (重要): 如果需要在不同账户或区域使用 WAF, 考虑 Firewall Manager</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img174857.png"></p><ul><li>Web ACL (Web 访问控制列表)<ul><li>过滤条件: IP 地址, HTTP Headers, 请求大小 (Size), 查询字符串, 地理位置</li><li>核心能力: WAF 可以阻止来自特定国家的访问</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img175006.png"></p><blockquote><p>AWS Firewall Manager 重要提示: 如果要跨账户使用 AWS WAF, 加速 WAF 配置, 自动保护新资源, 使用 Firewall Manager 配合 AWS WAF</p></blockquote><hr><h4 id="AWS-Shield"><a href="#AWS-Shield" class="headerlink" title="AWS Shield"></a>AWS Shield</h4><ul><li>DDoS 攻击防护服务<ul><li>防御 DDoS 攻击</li><li>WAF 也可以防 DDoS, 但考试遇到 DDoS 时选 Shield</li><li>自动检测和缓解攻击</li></ul></li><li>Shield Standard (免费)<ul><li>所有 AWS 客户自动获得</li><li>防御常见的 Layer 3&#x2F;4 攻击</li><li>SYN&#x2F;UDP Floods</li></ul></li><li>Shield Advanced (付费)<ul><li>高级 DDoS 防护</li><li>24&#x2F;7 DDoS 响应团队 (DRT)</li><li>DDoS 成本保护</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img175302.png"></p><ul><li>Shield vs. WAF:<ul><li>Shield: 专注 DDoS 防护, Layer 3&#x2F;4</li><li>WAF: 应用层防护, Layer 7, 更细粒度</li></ul></li></ul><hr><h4 id="AWS-Firewall-Manager"><a href="#AWS-Firewall-Manager" class="headerlink" title="AWS Firewall Manager"></a>AWS Firewall Manager</h4><ul><li>Manage security rules in all accounts of an AWS Organization<ul><li>比如 WAF rules, AWS Shield Advanced, Security Group for EC2 &amp; VPC 等等</li></ul></li><li>Rules are applied to new resources as they are created</li><li>如果需要在不同的 accout 或者 region 用 WAF, 考虑 Firewall Manager (重要)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img175531.png"></p><ul><li>WAF vs Firewall Manager vs Shield<ul><li>它们一起用来做大型安全保护 (WAF + Firewall Manager + Shield)</li><li>如果只是日常保护, 就用 WAF</li><li>如果遇到 DDoS 攻击, 考虑使用 Shield</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img175631.png"></p><hr><h4 id="AWS-GuardDuty"><a href="#AWS-GuardDuty" class="headerlink" title="AWS GuardDuty"></a>AWS GuardDuty</h4><ul><li>智能威胁检测服务<ul><li>使用机器学习 (ML) 智能发现威胁, 保护 AWS 账户</li><li>使用 ML 防止加密货币攻击</li><li>持续监控可疑活动</li></ul></li><li>输入数据源 (重要)<ul><li>CloudTrail Events - API 调用日志</li><li>VPC Flow Logs - 网络流量</li><li>DNS Logs - DNS 查询</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img175935.png"></p><hr><h4 id="AWS-Inspector"><a href="#AWS-Inspector" class="headerlink" title="AWS Inspector"></a>AWS Inspector</h4><ul><li>自动化安全评估服<ul><li>自动化安全评估 (Automated Security Assessments)</li><li>持续扫描漏洞</li><li>生成安全发现报告</li></ul></li><li>支持的资源类型<ul><li>EC2 Instance - 操作系统漏洞</li><li>Container Images (ECR) - 容器镜像漏洞</li><li>Lambda Functions - 函数代码和依赖漏洞</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img180110.png"></p><hr><h4 id="AWS-Macie"><a href="#AWS-Macie" class="headerlink" title="AWS Macie"></a>AWS Macie</h4><ul><li>使用机器学习保护敏感数据<ul><li>使用 ML 保护 AWS 中的敏感数据 (PII)</li><li>自动发现和分类敏感数据</li><li>持续监控 S3 存储桶</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img180224.png"></p><hr><h3 id="24-Networking-VPC"><a href="#24-Networking-VPC" class="headerlink" title="24. Networking VPC"></a>24. Networking VPC</h3><ul><li>CIDR (Classless Inter-Domain Routing) 组成<ul><li>CIDR &#x3D; 基础 IP + 子网掩码</li><li>格式: IP地址&#x2F;前缀长度</li></ul></li><li>CIDR 计算示例<ul><li>CIDR: 10.0.4.0&#x2F;28</li><li>&#x2F;28 代表 16 个 IP &#x3D; (2^(32-28) &#x3D; 2^4 &#x3D; 16)</li><li>8 的倍数大于 28 的只有 32</li><li>IP 范围: 10.0.4.0 到 10.0.4.15 (0-15 共 16 个 IP)</li></ul></li><li>计算公式<ul><li>可用 IP 数 &#x3D; 2^(32 - 前缀长度)</li><li>前缀长度越大, IP 数量越少</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img002822.png"></p><hr><h4 id="AWS-VPC"><a href="#AWS-VPC" class="headerlink" title="AWS VPC"></a>AWS VPC</h4><ul><li>虚拟私有云<ul><li>VPC: Virtual Private Cloud (虚拟私有云)</li><li>所有新 AWS 账户都有一个默认 VPC</li><li>隔离的虚拟网络环境</li></ul></li><li>CIDR 规则<ul><li>CIDR 不应重叠</li><li>AWS 最大 CIDR 大小: &#x2F;16</li><li>AWS 最小 CIDR 大小: &#x2F;28</li></ul></li><li>DNS 配置: 要让 VPC 使用自定义域名, 需要启用<ul><li>enableDnsHostnames - 启用 DNS 主机名</li><li>enableDnsSupport - 启用 DNS 解析</li></ul></li><li>Shared Service VPC (重要): 可以创建共享服务 VPC, 这样每个 VPC 都可以访问所需的服务</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img201530.png"></p><ul><li>EC2 Instance Tenancy (租赁属性, 重要): 每个启动到 VPC 的 Amazon EC2 实例都有一个 tenancy 属性<ul><li>Default - 共享硬件</li><li>Dedicated Instance - 专用硬件 (实例级别)</li><li>Dedicated Host - 专用主机 (物理服务器级别)</li></ul></li><li>重要特性: 可以在 Dedicated Instance 和 Dedicated Host 之间互相切换<ul><li>不能从 Default 切换到 Dedicated</li><li>可以从 Dedicated 切换到 Default (需停止实例)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img042420.png"></p><ul><li>VPC 组件<ul><li>Subnets (子网)</li><li>Route Tables (路由表)</li><li>Internet Gateway (互联网网关)</li><li>NAT Gateway (NAT 网关)</li><li>Security Groups (安全组)</li><li>Network ACLs (网络 ACL)</li></ul></li></ul><hr><h4 id="VPC-Subnet"><a href="#VPC-Subnet" class="headerlink" title="VPC Subnet"></a>VPC Subnet</h4><ul><li>VPC 子网<ul><li>Public Subnet (公有子网) - 可访问互联网</li><li>Private Subnet (私有子网) - 不可直接访问互联网</li></ul></li><li>AWS 保留 IP 地址 (重要): AWS 在每个子网中保留 5 个 IP 地址 (前 4 个 + 最后 1 个)<ul><li>保留的 IP (以 10.0.0.0&#x2F;24 为例)</li><li>前 4 个从 0 开始算, 即 0-3<ul><li>10.0.0.0 - 网络地址</li><li>10.0.0.1 - AWS VPC 路由器</li><li>10.0.0.2 - AWS DNS 服务器</li><li>10.0.0.3 - AWS 未来使用保留</li></ul></li><li>最后 1 个<ul><li>10.0.0.255 - 网络广播地址</li></ul></li></ul></li><li>容量规划示例: 如果需要处理 28 个主机<ul><li>28 (主机) + 5 (保留) &#x3D; 33 个 IP</li><li>需要至少 64 个 IP (&#x2F;26 &#x3D; 64 IPs)</li><li>或者: 两个子网各 &#x2F;27<ul><li>第一个子网: 28 + 5 &#x3D; 33, 需要 &#x2F;26</li><li>第二个子网: 26 + 5 &#x3D; 31, 需要 &#x2F;26</li><li>总共 64 IPs</li></ul></li></ul></li><li>子网与路由表 (重要): Subnet 总是与 Route Table 关联<ul><li>每个子网必须关联一个路由表</li><li>问关于 Subnet 的问题就和 Route Table 有关系</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img201819.png"></p><ul><li>Public vs. Private Subnet 区别<ul><li>Public Subnet: 路由表有到 Internet Gateway 的路由 (0.0.0.0&#x2F;0)</li><li>Private Subnet: 路由表没有到 Internet Gateway 的直接路由</li></ul></li></ul><hr><h4 id="Internet-Gateway-IGW-amp-Route-Table"><a href="#Internet-Gateway-IGW-amp-Route-Table" class="headerlink" title="Internet Gateway (IGW) &amp; Route Table"></a>Internet Gateway (IGW) &amp; Route Table</h4><ul><li>互联网网关和路由表</li><li>Internet Gateway (IGW) 核心功能<ul><li>允许 VPC 中的资源 (如 EC2 实例) 连接到互联网</li><li>IGW 需要 Route Table 配合 (重要)</li><li>一个 VPC 只能附加一个 IGW</li></ul></li><li>IGW 故障排查: 如果 IGW 出问题, 检查顺序<ul><li>首先检查 Route Table (因为 IGW 需要路由表)</li><li>检查 Security Group 是否允许流量通过</li><li>检查 Network ACL</li><li>确认实例有公网 IP</li></ul></li><li>Network Address Translation (NAT)<ul><li>处理 NAT 的就是 Internet Gateway</li><li>IGW 执行 1:1 NAT</li><li>将私有 IP 转换为公网 IP</li></ul></li><li>重要限制: Internet Gateway 无法直接在 private subnet 中使用 (重要)<ul><li>Private subnet 需要使用 NAT Gateway&#x2F;Instance</li><li>IGW 只能为 public subnet 提供互联网访问</li></ul></li><li>NAT vs. IGW 区别 (重要)<ul><li>NAT 针对 Subnet 层面 - 为私有子网提供出站互联网访问</li><li>IGW 针对 VPC 层面 - 为整个 VPC 提供双向互联网连接</li></ul></li><li>Route Table 配置<ul><li>Public Subnet: 添加路由 0.0.0.0&#x2F;0 → IGW</li><li>Private Subnet: 添加路由 0.0.0.0&#x2F;0 → NAT Gateway</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img202043.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img193121.png"></p><hr><h4 id="Bastion-Hosts"><a href="#Bastion-Hosts" class="headerlink" title="Bastion Hosts"></a>Bastion Hosts</h4><ul><li>堡垒主机&#x2F;跳板机<ul><li>使用 Bastion Host 通过 SSH 进入私有 EC2 实例</li><li>安全访问私有资源的跳板</li></ul></li><li>架构位置<ul><li>Bastion Host 位于公有子网</li><li>连接到私有子网</li><li>简单来说: Public Internet → Bastion Host → Private Subnet</li></ul></li><li>安全配置 (重要): Bastion Host 安全组必须限制互联网访问 (端口 22)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img202553.png"></p><blockquote><p>高可用架构: 创建公有 Network Load Balancer, 链接到由 Auto Scaling Group 管理的 Bastion Host EC2 实例</p></blockquote><hr><h4 id="NAT-Instances-Outdated"><a href="#NAT-Instances-Outdated" class="headerlink" title="NAT Instances (Outdated)"></a>NAT Instances (Outdated)</h4><ul><li>网络地址转换实例</li><li>NAT (Network Address Translation) 核心功能<ul><li>允许私有子网中的 EC2 实例连接到互联网</li><li>提供出站互联网访问, 不允许入站互联网连接</li></ul></li><li>重要提示: 现在都使用 NAT Gateway (NAT Gateway 是首选解决方案)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img202940.png"></p><hr><h4 id="NAT-Gateway-NATGW"><a href="#NAT-Gateway-NATGW" class="headerlink" title="NAT Gateway (NATGW)"></a>NAT Gateway (NATGW)</h4><ul><li>托管的 NAT 网关<ul><li>AWS 托管的 NAT 服务</li><li>AZ 特定 (每个 AZ 独立)</li><li>使用 Elastic IP</li><li>针对 IPv4 (IPv6 使用 Egress-only IGW)</li></ul></li><li>核心功能: 允许私有子网中的 EC2 实例连接到互联网</li><li>部署要求 (注意)<ul><li>需要 Internet Gateway (IGW)</li><li>NATGW 位于公有子网中</li><li>需要 Elastic IP 地址</li></ul></li><li>重要区分<ul><li>NAT 针对 Subnet 层面 - 为子网提供出站访问</li><li>IGW 针对 VPC 层面 - VPC 级别的互联网连接</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img203409.png"></p><p>高可用性配置</p><ul><li>单 AZ 弹性<ul><li>在单个 AZ 内具有弹性</li><li>自动故障转移</li><li>AWS 托管的高可用性</li></ul></li><li>多 AZ 容错 (重要)<ul><li>多 AZ 需要多个 NATGW</li><li>每个 AZ 都要一个 NATGW, 用于容错 (fault-tolerance)</li><li>避免跨 AZ 流量费用</li><li>单个 AZ 故障不影响其他 AZ</li></ul></li><li>架构最佳实践<ul><li>在每个 AZ 部署独立的 NATGW</li><li>每个私有子网路由到同 AZ 的 NATGW</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img203654.png"></p><hr><h4 id="NACL-amp-Security-Groups"><a href="#NACL-amp-Security-Groups" class="headerlink" title="NACL &amp; Security Groups"></a>NACL &amp; Security Groups</h4><ul><li>网络访问控制和安全组</li><li>流量检查顺序<ul><li>请求必须先通过 NACL 才能到达 Subnet (Subnet 级别)</li><li>NACL 是无状态的 (Stateless) - 入站和出站都要检测</li><li>请求必须通过 Security Group 才能到达 EC2 Instance (Instance 级别)</li><li>Security Group 是有状态的 (Stateful) - 入站允许 &#x3D; 出站自动允许</li></ul></li><li>核心记忆点: NACL 是 Subnet 级别 (Stateless), Security Group 是 Instance 级别 (Stateful)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img204310.png"></p><ul><li>Network Access Control List (NACL)<ul><li>控制进出子网的流量 (如阻止特定 IP)</li><li>第一道防线</li></ul></li><li>关联规则 (注意)<ul><li>每个子网一个 NACL</li><li>每个子网都有默认 NACL</li><li>默认 NACL 允许所有入站和出站流量</li></ul></li><li>NACL 规则特点<ul><li>规则有编号, 编号越低优先级越高</li><li>支持允许和拒绝规则</li></ul></li><li>规则编号示例<ul><li>100 - Allow HTTP (优先)</li><li>200 - Deny specific IP</li><li>(星号) - 默认拒绝所有</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img204553.png"></p><p>NACL vs. Security Group</p><ul><li><p>NACL</p><ul><li>Subnet 级别</li><li>Stateless (需要显式配置入站和出站)</li><li>支持允许和拒绝规则</li><li>按规则顺序处理</li><li>适合阻止特定 IP</li></ul></li><li><p>Security Group</p><ul><li>Instance 级别</li><li>Stateful (自动处理返回流量)</li><li>只支持允许规则</li><li>所有规则一起评估</li><li>适合允许特定流量</li></ul></li></ul><hr><h4 id="VPC-Peering-amp-Sharing"><a href="#VPC-Peering-amp-Sharing" class="headerlink" title="VPC Peering &amp; Sharing"></a>VPC Peering &amp; Sharing</h4><ul><li>VPC Peering (VPC 对等连接)<ul><li>使用 AWS 网络私密连接两个 VPC</li><li>只适合少量 VPC (重要)</li><li>一对一连接, 不支持传递性</li></ul></li><li>重要特点<ul><li>每一对 VPC 都需要单独的 VPC Peering</li><li>类似 S3 Replication (一对一配置)</li><li>VPC A ↔ VPC B, VPC B ↔ VPC C, 但 A 不能通过 B 访问 C</li></ul></li><li>跨账户&#x2F;区域支持<ul><li>可以在不同 AWS 账户之间创建 VPC Peering</li><li>可以在不同 Region 之间创建 VPC Peering</li></ul></li><li>配置要求 (重要)<ul><li>需要更新每个 VPC 子网的路由表以确保通信</li><li>出问题就检查 Route Table</li><li>CIDR 不能重叠</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img205313.png"></p><ul><li>VPC Sharing (VPC 共享, 重要)<ul><li>允许多个 AWS 账户在共享的、集中管理的 VPC 中创建资源 (如 EC2, RDS)</li><li>基于 AWS Resource Access Manager (RAM)</li></ul></li><li>关键特征<ul><li>遇到 “centrally managed” 就选 VPC Sharing</li><li>Owner 需要共享一个或多个子网 (注意)</li><li>Owner 管理 VPC 和子网</li></ul></li></ul><blockquote><p>VPC Peering: 跨账户&#x2F;区域连接, 少量 VPC<br>VPC Sharing: 组织内多账户, 集中管理, 大量资源</p></blockquote><hr><h4 id="VPC-Endpoints-AWS-PrivateLink"><a href="#VPC-Endpoints-AWS-PrivateLink" class="headerlink" title="VPC Endpoints (AWS PrivateLink)"></a>VPC Endpoints (AWS PrivateLink)</h4><ul><li>VPC 端点<ul><li>VPC Endpoints 允许在 VPC 内私密访问 AWS 服务 (重要)</li><li>使用私有网络连接 AWS 服务, 与本地 (On-Premise) 无关</li><li>不通过公网访问</li><li>降低延迟和成本</li></ul></li><li>考试重点<ul><li>Interface Endpoint 支持大部分 AWS 服务 (付费)</li><li>Gateway Endpoint 只支持 S3 和 DynamoDB (很容易考, 免费)</li></ul></li><li>重要提示: VPC Gateway Endpoint 专门处理 S3 和 DynamoDB (不要选择 NAT 或 IGW)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img205719.png"></p><ul><li>两种 Types of Endpoints (Interface &#x2F; Gateway)<ul><li>Interface Endpoints: Supports most AWS services (付费)<ul><li>使用 ENI (Elastic Network Interface)</li><li>有私有 IP 地址</li><li>需要配置 Security Group</li><li>按小时和数据处理量收费</li></ul></li><li>Gateway Endpoints: Must be used as a target in a route table (免费, 重要)<ul><li>Only support S3 and DynamoDB (只支持 S3 和 DynamoDB)</li><li>不使用 ENI</li><li>不需要 Security Group</li><li>在路由表中配置</li></ul></li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img205939.png"></p><hr><h4 id="VPC-Flow-Logs"><a href="#VPC-Flow-Logs" class="headerlink" title="VPC Flow Logs"></a>VPC Flow Logs</h4><ul><li>捕获网络接口 IP 流量信息 (Capture IP traffic information)<ul><li>用于监控和排查网络连接问题 (Monitor &amp; troubleshoot connectivity issues)</li></ul></li><li>启用层级: 可在 VPC, Subnet, ENI 三个层面启用</li><li>日志存储: 可发送到 S3, CloudWatch Logs, Kinesis Data Firehose</li><li>记录内容: source IP, destination IP, ports, protocol, action (ACCEPT&#x2F;REJECT)</li><li>用途: 网络安全审计、流量分析、故障排查</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img231819.png"></p><hr><h4 id="Site-to-Site-VPN-VPN-Connection"><a href="#Site-to-Site-VPN-VPN-Connection" class="headerlink" title="Site-to-Site VPN (VPN Connection)"></a>Site-to-Site VPN (VPN Connection)</h4><ul><li>通过公网连接 AWS VPC 和企业数据中心 (Connect AWS to Corporate Data Center over public internet)</li><li>组件要求:<ul><li>Virtual Private Gateway (VGW) - AWS 端的 VPN 网关</li><li>Customer Gateway (CGW) - 企业端的 VPN 网关</li></ul></li><li>提供加密的网络连接 (encrypted network connectivity)</li><li>与 Direct Connect 对比: 延迟更高,吞吐量较低,但成本更低</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img232320.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img232649.png"></p><hr><h4 id="VPN-CloudHub"><a href="#VPN-CloudHub" class="headerlink" title="VPN CloudHub"></a>VPN CloudHub</h4><ul><li>为多个 Site-to-Site VPN 连接提供安全通信 (Secure communication for multiple VPN connections)</li><li>使用场景:<ul><li>管理多个 Site-to-Site VPN 连接</li><li>作为备用连接,通过公网实现故障转移</li></ul></li><li>实现多个远程站点之间的互联通信</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img202141.png"></p><hr><h4 id="Direct-Connect-DX"><a href="#Direct-Connect-DX" class="headerlink" title="Direct Connect (DX)"></a>Direct Connect (DX)</h4><ul><li>提供专用私有连接从企业网络到 VPC (dedicated private connection, On-Premise to AWS)</li><li>特点:<ul><li>需要设置 VGW, 备份方案选择 Site-to-Site VPN</li><li>相比 Site-to-Site VPN: 低延迟、高吞吐量</li><li>不支持加密, 需加密可结合 AWS VPN 使用</li><li>部署时间长, 不适合快速解决方案</li></ul></li><li>完全私有网络, 不涉及公网 (All private, 考试重点)</li><li>可访问公有资源 (S3) 和私有资源 (EC2)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img233024.png"></p><ul><li>连接类型:<ul><li>Dedicated Connections: 1Gbps - 100Gbps</li><li>Hosted Connections: 50Mbps - 10Gbps</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img004140.png"></p><ul><li>Direct Connect Gateway: 连接多个不同 Region 的 VPC</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img233531.png"></p><ul><li>与 PrivateLink 区别:<ul><li>PrivateLink: VPC 间和 AWS 服务连接</li><li>DX: On-Premise 到 AWS 的专用连接</li></ul></li></ul><hr><h4 id="Transit-Gateway"><a href="#Transit-Gateway" class="headerlink" title="Transit Gateway"></a>Transit Gateway</h4><ul><li>实现数千个 VPC 和 On-Premise 网络之间的传递对等 (transitive peering, 重要)<ul><li>Regional 资源, 支持跨 Region 连接</li><li>通过 ECMP 最大化 VPN 吞吐量</li></ul></li><li>支持 IP Multicast (IP 多播, 单次传输到多个接收者)</li><li>考试关键词: star network, hub-and-spoke (中心辐射型网络)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img334237.png"></p><ul><li>Site-to-Site VPN ECMP (重要)<ul><li>ECMP &#x3D; Equal-cost multi-path routing (等价多路径路由)</li><li>作用: 通过多条相同优先级路径转发数据包, 增加带宽</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img234354.png"></p><hr><h4 id="VPC-Traffic-Mirroring"><a href="#VPC-Traffic-Mirroring" class="headerlink" title="VPC Traffic Mirroring"></a>VPC Traffic Mirroring</h4><ul><li>捕获和检查 VPC 网络流量 (Capture and inspect network traffic)</li><li>从 ENI 镜像流量到安全设备进行分析</li><li>使用场景:<ul><li>内容检查 (content inspection)</li><li>威胁监控 (threat monitoring)</li><li>故障排查 (troubleshooting)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img002627.png"></p><hr><h4 id="IPv6-in-VPC"><a href="#IPv6-in-VPC" class="headerlink" title="IPv6 in VPC"></a>IPv6 in VPC</h4><ul><li>VPC 和 Subnet 的 IPv4 无法禁用 (IPv4 是必需的)</li><li>EC2 实例至少获得 1 个私有 IPv4 和 1 个公有 IPv6</li><li>故障排查:<ul><li>无法启动 EC2 实例 → IPv4 地址不足</li><li>解决方案: 在 Subnet 中创建新的 IPv4 CIDR (重要)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img001017.png"></p><hr><h4 id="Egress-only-Internet-Gateway"><a href="#Egress-only-Internet-Gateway" class="headerlink" title="Egress-only Internet Gateway"></a>Egress-only Internet Gateway</h4><ul><li>仅用于 IPv6 (IPv6 版本的 NAT Gateway)</li><li>只允许出站连接 (VPC → Internet), 阻止入站连接 (Internet → VPC)</li><li>需要更新路由表配置</li><li>对比:<ul><li>Egress-only IGW: IPv6 only</li><li>NAT Gateway: IPv4 only</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img001334.png"></p><hr><h4 id="AWS-Network-Firewall"><a href="#AWS-Network-Firewall" class="headerlink" title="AWS Network Firewall"></a>AWS Network Firewall</h4><ul><li>保护整个 VPC 的托管防火墙服务 (VPC 级别防火墙, 重要)</li><li>Layer 3 到 Layer 7 全层防护</li><li>流量过滤规则:<ul><li>Allow: 允许流量</li><li>Drop: 丢弃流量</li><li>Alert: 告警流量</li></ul></li><li>支持入站和出站流量过滤</li><li>适用于保护生产环境 VPC</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img002037.png"></p><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img002200.png"></p><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img234322.png"></p><hr><h3 id="25-Disaster-Recovery-amp-Migrations"><a href="#25-Disaster-Recovery-amp-Migrations" class="headerlink" title="25. Disaster Recovery &amp; Migrations"></a>25. Disaster Recovery &amp; Migrations</h3><h4 id="Disaster-Recovery"><a href="#Disaster-Recovery" class="headerlink" title="Disaster Recovery"></a>Disaster Recovery</h4><ul><li>RPO (Recovery Point Objective): 可容忍的数据丢失时间</li><li>RTO (Recovery Time Objective): 可容忍的应用停机时间</li><li>DR 策略通常采用 Multi-Region 部署 (考试重点)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img002206.png"></p><ul><li>Disaster Recovery Strategies (从慢到快):<ul><li>Backup and Restore: High RPO &amp; RTO<ul><li>将 On-Premise 数据备份到 Cloud</li><li>成本最低, 恢复最慢</li></ul></li><li>Pilot Light: Medium RPO &amp; RTO<ul><li>只运行核心关键基础设施</li><li>关键词: DR with minimum (考试重点)</li></ul></li><li>Warm Standby: Low RPO &amp; RTO<ul><li>运行缩减版本应用, 可快速扩展</li><li>关键词: DR with scale-down (考试重点)</li></ul></li><li>Multi-Site &#x2F; Hot Site: Very Low RPO &amp; RTO<ul><li>全部应用在 Cloud 运行</li><li>成本最高, 恢复最快</li></ul></li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img142543.png"></p><hr><h4 id="Database-Migration-Service-DMS"><a href="#Database-Migration-Service-DMS" class="headerlink" title="Database Migration Service (DMS)"></a>Database Migration Service (DMS)</h4><ul><li>将数据库迁移到 AWS 的托管服务 (考试重点)</li><li>需要运行 EC2 实例来执行迁移任务</li><li>支持两种迁移类型:<ul><li>Homogeneous (同构): 相同数据库引擎 (如 MySQL → RDS MySQL)</li><li>Heterogeneous (异构): 不同数据库引擎 (如 Oracle → Aurora)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img143551.png"></p><ul><li>AWS Schema Conversion Tool (SCT, 重要)<ul><li>用于异构迁移时转换数据库架构</li><li>同构迁移不需要 SCT (如 PostgreSQL → RDS PostgreSQL)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img143914.png"></p><ul><li>DMS Multi-AZ Deployment<ul><li>在不同 AZ 维护同步备份副本</li><li>提供迁移过程的高可用性保障</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img144109.png"></p><hr><h4 id="RDS-amp-Aurora-Migration"><a href="#RDS-amp-Aurora-Migration" class="headerlink" title="RDS &amp; Aurora Migration"></a>RDS &amp; Aurora Migration</h4><ul><li>RDS MySQL → Aurora MySQL (PostgreSQL 同理)<ul><li>方法 1: 通过 DB Snapshots 恢复</li><li>方法 2: 创建 Aurora Read Replica, 然后提升为主库</li></ul></li><li>External MySQL → Aurora MySQL<ul><li>方法 1: 备份到 S3, 从 S3 创建 Aurora</li><li>方法 2: 使用 Percona XtraBackup 创建备份并导入</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img144459.png"></p><hr><h4 id="On-Premise-Strategy-with-AWS"><a href="#On-Premise-Strategy-with-AWS" class="headerlink" title="On-Premise Strategy with AWS"></a>On-Premise Strategy with AWS</h4><ul><li>AWS Application Discovery Service (DS): 发现和收集 On-Premise 服务器信息</li><li>AWS Database Migration Service (DMS): 迁移数据库到 AWS</li><li>AWS Server Migration Service (SMS): 迁移虚拟机到 AWS</li><li>VM Import&#x2F;Export: 导入导出虚拟机镜像</li></ul><p>以上服务用于 On-Premise 环境迁移到 AWS</p><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img145118.png"></p><hr><h4 id="AWS-Backup"><a href="#AWS-Backup" class="headerlink" title="AWS Backup"></a>AWS Backup</h4><ul><li>自动化备份的托管服务 (跨服务集中备份, 重要)</li><li>支持服务: EC2, EBS, S3, RDS, EFS, DynamoDB 等</li><li>支持跨区域备份和跨账户备份</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img145310.png"></p><ul><li>AWS Backup Vault Lock<ul><li>启用 WORM (Write Once Read Many) 状态</li><li>备份一旦创建无法删除或修改, 防止恶意删除</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img145549.png"></p><hr><h4 id="Application-Migration-Service-MGN"><a href="#Application-Migration-Service-MGN" class="headerlink" title="Application Migration Service (MGN)"></a>Application Migration Service (MGN)</h4><ul><li>迁移流程分为两个阶段:</li></ul><p><strong>1. AWS Application Discovery Service (迁移规划阶段)</strong></p><ul><li>收集 On-Premise 数据中心信息, 规划迁移项目</li><li>两种发现模式:<ul><li>Agentless Discovery: 无需安装代理</li><li>Agent-based Discovery: 基于代理收集详细信息</li></ul></li><li>结果在 AWS Migration Hub 中查看</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img145820.png"></p><p><strong>2. AWS Application Migration Service (MGN) (迁移执行阶段)</strong></p><ul><li>简化应用迁移到 AWS 的过程</li><li>自动化物理、虚拟和云服务器的迁移</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img145954.png"></p><hr><h4 id="VMware-Cloud-on-AWS"><a href="#VMware-Cloud-on-AWS" class="headerlink" title="VMware Cloud on AWS"></a>VMware Cloud on AWS</h4><ul><li>使用 VMware 技术管理和扩展 On-Premise 数据中心到 AWS</li><li>使用场景:<ul><li>将现有 VMware 环境迁移到 AWS</li><li>灾难恢复和业务连续性</li><li>利用 AWS 服务扩展 VMware 工作负载</li></ul></li><li>优势: 无需重新设计应用架构, 直接迁移 VMware 虚拟机</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img150508.png"></p><hr><h3 id="26-More-SAA"><a href="#26-More-SAA" class="headerlink" title="26. More SAA"></a>26. More SAA</h3><h4 id="Event-Processing"><a href="#Event-Processing" class="headerlink" title="Event Processing"></a>Event Processing</h4><ul><li>Fan Out Pattern (扇出模式, 重要)<ul><li>SNS 作为中心, 订阅多个 SQS 队列</li><li>实现一对多的消息分发</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img185229.png"></p><ul><li><p>S3 Event Notifications</p><ul><li>S3 事件触发 Lambda 或 SNS</li><li>配置 DLQ (Dead Letter Queue): 选择 Lambda</li><li>DLQ 用于处理失败的消息</li></ul></li><li><p>与 EventBridge 集成</p><ul><li>提供高级过滤功能</li><li>结合 CloudTrail 拦截 API 调用</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img185348.png"></p><hr><h4 id="Caching-Strategies"><a href="#Caching-Strategies" class="headerlink" title="Caching Strategies"></a>Caching Strategies</h4><ul><li><p>缓存原则: 离用户越近越快, 但可能过期, 需要设置 TTL (Time to Live)</p></li><li><p>多层缓存架构:</p><ul><li>CloudFront: 边缘缓存, 全球分发</li><li>API Gateway: 区域级缓存 (Regional)</li><li>应用层: ElastiCache (Redis&#x2F;Memcached)</li><li>数据库层: DAX (DynamoDB), RDS 读副本</li></ul></li><li><p>作用: 减少延迟, 降低后端负载, 提升性能</p></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img185932.png"></p><hr><h4 id="Block-IP-Address"><a href="#Block-IP-Address" class="headerlink" title="Block IP Address"></a>Block IP Address</h4><ul><li>两种方式阻止 IP 地址:</li></ul><p><strong>NACL (Network ACL)</strong></p><ul><li>在 VPC 子网层面拒绝 IP</li><li>适用于 VPC 内部保护</li></ul><p><strong>WAF (Web Application Firewall)</strong></p><ul><li><p>在应用层过滤 IP</p></li><li><p>提供更精细的控制和日志</p></li><li><p>可用于 CloudFront, ALB, API Gateway</p></li><li><p>推荐: 优先选择 WAF (功能更强大, 更灵活)</p></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img190513.png"></p><hr><h4 id="HPC-in-AWS"><a href="#HPC-in-AWS" class="headerlink" title="HPC in AWS"></a>HPC in AWS</h4><ul><li>AWS 是执行高性能计算 (HPC) 的理想平台</li><li>HPC 关键组件: EFA, Cluster Placement Group, FSx for Lustre (考试重点)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img190820.png"></p><p><strong>数据管理和传输</strong></p><ul><li>Direct Connect: 专用网络连接</li><li>Snowball: 大规模数据迁移</li><li>DataSync: 自动化数据同步</li></ul><p><strong>计算和网络</strong></p><ul><li>EC2 Instance + Cluster Placement Group (低延迟, 高带宽)</li><li>EC2 Enhanced Networking (SR-IOV): 使用 Elastic Network Adapter (ENA)</li><li>Elastic Fabric Adapter (EFA): HPC 专用, 仅支持 Linux</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img190944.png"></p><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img191112.png"></p><p><strong>存储</strong></p><ul><li>实例附加存储: EBS, Instance Store</li><li>网络存储: S3, EFS, FSx for Lustre</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img191328.png"></p><p><strong>自动化和编排</strong></p><ul><li>AWS Batch: 多节点并行作业, 跨多个 EC2 实例</li><li>AWS ParallelCluster: 在 AWS 上部署 HPC 集群, 支持 EFA</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img191502.png"></p><hr><h4 id="EC2-Instance-High-Availability"><a href="#EC2-Instance-High-Availability" class="headerlink" title="EC2 Instance High Availability"></a>EC2 Instance High Availability</h4><ul><li>两种 EC2 高可用方案:</li></ul><p><strong>方案 1: Elastic IP + Standby EC2 + CloudWatch + Lambda</strong></p><ul><li>CloudWatch 监控主实例健康状态</li><li>故障时 Lambda 自动将 Elastic IP 切换到备用实例</li><li>需要手动维护备用实例</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img191841.png"></p><p><strong>方案 2: Elastic IP + Auto Scaling Group (推荐)</strong></p><ul><li>ASG 配置 min&#x3D;1, max&#x3D;1</li><li>实例故障时自动创建替换实例</li><li>无需 CloudWatch 和 Lambda, 更简单</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img192115.png"></p><hr><h3 id="27-Other-AWS-Services"><a href="#27-Other-AWS-Services" class="headerlink" title="27. Other AWS Services"></a>27. Other AWS Services</h3><h4 id="AWS-CloudFormation"><a href="#AWS-CloudFormation" class="headerlink" title="AWS CloudFormation"></a>AWS CloudFormation</h4><ul><li>声明式方式定义 AWS 基础设施 (Infrastructure as Code, IaC)</li><li>通过模板自动创建和管理资源<ul><li>示例: 定义 EC2, S3, VPC 等资源, CloudFormation 自动创建</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img003448.png"></p><ul><li>优势:<ul><li>无需手动创建资源</li><li>版本控制和可重复部署</li><li>在不同环境中快速复制架构</li><li>自动化资源编排和依赖管理</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img003657.png"></p><hr><h4 id="CloudFormation-StackSets"><a href="#CloudFormation-StackSets" class="headerlink" title="CloudFormation StackSets"></a>CloudFormation StackSets</h4><ul><li>扩展 CloudFormation 功能，支持跨账户和跨区域部署</li><li>使用场景: 需要在多个账户或区域中部署相同架构</li><li>单次操作即可跨多个账户和区域创建、更新或删除堆栈</li><li>适用于企业级多账户管理</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img013227.png"></p><hr><h4 id="CloudFormation-Service-Role"><a href="#CloudFormation-Service-Role" class="headerlink" title="CloudFormation Service Role"></a>CloudFormation Service Role</h4><ul><li>IAM 角色，授权 CloudFormation 创建&#x2F;更新&#x2F;删除资源</li><li>使用场景:<ul><li>用户本身无权限，但可通过 Service Role 执行操作</li><li>实现权限分离和最小权限原则</li></ul></li><li>安全优势: 无需直接授予用户资源权限</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img004103.png"></p><hr><h4 id="AWS-SES-Simple-Email-Service"><a href="#AWS-SES-Simple-Email-Service" class="headerlink" title="AWS SES (Simple Email Service)"></a>AWS SES (Simple Email Service)</h4><ul><li>托管邮件发送服务，安全可靠地发送电子邮件</li><li>使用场景:<ul><li>营销邮件和通知邮件</li><li>交易邮件 (订单确认、密码重置等)</li><li>批量邮件发送</li></ul></li><li>支持接收邮件和自定义邮件处理</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img004334.png"></p><hr><h4 id="AWS-Pinpoint"><a href="#AWS-Pinpoint" class="headerlink" title="AWS Pinpoint"></a>AWS Pinpoint</h4><ul><li>可扩展的双向营销通信服务 (outbound&#x2F;inbound, 重要)</li><li>支持渠道:<ul><li>Email, SMS, Push 通知, 语音, App 内消息</li></ul></li><li>功能特性:<ul><li>客户分群和个性化消息</li><li>接收客户回复并处理</li><li>营销活动管理和分析</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img004519.png"></p><hr><h4 id="AWS-SSM-Session-Manager"><a href="#AWS-SSM-Session-Manager" class="headerlink" title="AWS SSM Session Manager"></a>AWS SSM Session Manager</h4><ul><li>Systems Manager Session Manager 的简称</li><li>在 EC2 和 On-Premise 服务器上启动安全 Shell 会话</li><li>优势:<ul><li>无需 SSH 密钥和开放端口 22</li><li>无需堡垒机 (Bastion Host)</li><li>集中审计和会话日志</li><li>更高安全性和合规性</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img004759.png"></p><hr><h4 id="AWS-Cost-Explorer"><a href="#AWS-Cost-Explorer" class="headerlink" title="AWS Cost Explorer"></a>AWS Cost Explorer</h4><ul><li>可视化和管理 AWS 成本及使用情况</li><li>核心功能:<ul><li>生成成本和使用报告</li><li>分析历史支出趋势</li><li>预测未来成本</li><li>推荐最优 Savings Plan</li></ul></li><li>考试重点: 涉及成本分析和优化的问题，优先选择 Cost Explorer</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img005425.png"></p><hr><h4 id="AWS-Compute-Optimizer"><a href="#AWS-Compute-Optimizer" class="headerlink" title="AWS Compute Optimizer"></a>AWS Compute Optimizer</h4><ul><li>使用机器学习分析历史使用指标，推荐最优计算资源</li><li>支持资源类型:<ul><li>EC2 实例</li><li>Auto Scaling Groups</li><li>EBS 卷</li><li>Lambda 函数</li></ul></li><li>目标: 降低成本，提升性能</li><li>与 Cost Explorer 结合使用，实现成本优化</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img173241.png"></p><hr><h4 id="AWS-Batch"><a href="#AWS-Batch" class="headerlink" title="AWS Batch"></a>AWS Batch</h4><ul><li>任意规模的托管批处理服务</li><li>动态启动 EC2 实例或 Spot 实例</li><li>批处理作业以 Docker 镜像定义，运行在 ECS 上</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img005610.png"></p><ul><li>Batch vs Lambda<ul><li>Lambda: 有时间限制 (15 分钟), Serverless</li><li>Batch: 无时间限制, 非 Serverless, 适合长时间运行任务</li></ul></li><li>使用场景: 数据处理、图像处理、科学计算等长时间批处理任务</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img005741.png"></p><hr><h4 id="AWS-AppFlow"><a href="#AWS-AppFlow" class="headerlink" title="AWS AppFlow"></a>AWS AppFlow</h4><ul><li>在 SaaS 应用和 AWS 之间传输数据 (重要)</li><li>数据源 (Source): Salesforce, Slack, ServiceNow, SAP 等</li><li>数据目标 (Destination): S3, Redshift, Snowflake 等</li><li>功能: 数据转换、过滤、验证</li><li>考试重点: 遇到 SaaS 集成问题，优先选择 AppFlow</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img005910.png"></p><hr><h4 id="AWS-Amplify"><a href="#AWS-Amplify" class="headerlink" title="AWS Amplify"></a>AWS Amplify</h4><ul><li>开发和部署全栈 Web 和移动应用的工具集</li><li>核心功能:<ul><li>前端托管和 CI&#x2F;CD</li><li>后端 API 和数据库集成</li><li>用户认证和授权</li><li>存储和分析</li></ul></li><li>支持框架: React, Angular, Vue, iOS, Android</li><li>使用场景: 快速构建和部署全栈应用</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img010043.png"></p><hr><h4 id="AWS-Resource-Access-Manager-RAM"><a href="#AWS-Resource-Access-Manager-RAM" class="headerlink" title="AWS Resource Access Manager (RAM)"></a>AWS Resource Access Manager (RAM)</h4><ul><li>在 AWS 账户或组织内安全共享资源</li><li>可共享资源:<ul><li>Transit Gateway</li><li>VPC Subnets</li><li>Route53 Resolver Rules</li><li>License Manager Configurations</li></ul></li><li>优势: 避免资源重复，降低成本，简化管理</li><li>使用场景: 跨账户共享网络资源</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img043006.png"></p><hr><h4 id="AWS-Systems-Manager"><a href="#AWS-Systems-Manager" class="headerlink" title="AWS Systems Manager"></a>AWS Systems Manager</h4><ul><li>查看和控制 AWS 基础设施的集中管理服务</li><li>核心功能:<ul><li><strong>Session Manager</strong>: 安全访问 EC2 实例</li><li><strong>Run Command</strong>: 在多个实例上执行命令和补丁</li><li><strong>Patch Manager</strong>: 自动化补丁管理</li><li><strong>Parameter Store</strong>: 存储配置和密钥</li><li><strong>Inventory</strong>: 收集软件和配置信息</li></ul></li><li>使用场景: 大规模实例管理和运维自动化</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img013522.png"></p><hr><h3 id="28-WhitePapers"><a href="#28-WhitePapers" class="headerlink" title="28. WhitePapers"></a>28. WhitePapers</h3><h4 id="Well-Architected-Framework"><a href="#Well-Architected-Framework" class="headerlink" title="Well-Architected Framework"></a>Well-Architected Framework</h4><ul><li><p>6 个核心支柱 (6 Pillars, 考试重点):</p><ol><li><strong>Operational Excellence</strong> (卓越运营)</li><li><strong>Security</strong> (安全性)</li><li><strong>Reliability</strong> (可靠性)</li><li><strong>Performance Efficiency</strong> (性能效率)</li><li><strong>Cost Optimization</strong> (成本优化)</li><li><strong>Sustainability</strong> (可持续性)</li></ol></li><li><p>最大弹性实现方式: 在多个位置使用独立设备的独立连接</p></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img911011.png"></p><p><strong>AWS Well-Architected Tool</strong></p><ul><li>根据 6 大支柱评审架构</li><li>提供最佳实践建议和改进方案</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img010508.png"></p><hr><h4 id="AWS-Trusted-Advisor"><a href="#AWS-Trusted-Advisor" class="headerlink" title="AWS Trusted Advisor"></a>AWS Trusted Advisor</h4><ul><li><p>AWS 账户的高级评估工具</p></li><li><p>基于 Well-Architected Framework 的 6 大支柱提供建议:</p><ul><li>Cost Optimization (成本优化)</li><li>Performance (性能)</li><li>Security (安全)</li><li>Fault Tolerance (容错)</li><li>Service Limits (服务限制)</li><li>Operational Excellence (运营卓越)</li></ul></li><li><p>检查类型:</p><ul><li>免费: 7 项核心检查</li><li>Business &amp; Enterprise Support: 完整检查 + 自动化响应</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img010724.png"></p>]]></content>
      
      
      <categories>
          
          <category> Certification </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AWS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AWS CLF-C02</title>
      <link href="/posts/ced5b880.html"/>
      <url>/posts/ced5b880.html</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>官网: <a href="https://aws.amazon.com/certification/certified-cloud-practitioner/">https://aws.amazon.com/certification/certified-cloud-practitioner/</a></p><hr><h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img105337.png"></p><ul><li>AWS has three fundamental cost drivers: compute, storage, and outbound data transfer.</li><li>The pricing model is pay-as-you-go and on-demand, meaning you only pay for what you actually use.</li><li>Inbound data transfer to AWS is typically free, and data transfer between AWS services within the same region is also usually free. You’re only charged for outbound data transfer when data leaves AWS to external destinations.</li></ul><hr><h4 id="Types-of-Cloud-Computing"><a href="#Types-of-Cloud-Computing" class="headerlink" title="Types of Cloud Computing"></a>Types of Cloud Computing</h4><p>There are three types of cloud computing models:</p><ul><li>IaaS (Infrastructure as a Service) - You get basic infrastructure like virtual servers. Example: EC2.</li><li>PaaS (Platform as a Service) - You deploy applications without managing servers. Example: Elastic Beanstalk.</li><li>SaaS (Software as a Service) - You just use ready-made applications. Example: Rekognition.</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img110812.png"></p><hr><h4 id="AWS-Global-Infrastructure"><a href="#AWS-Global-Infrastructure" class="headerlink" title="AWS Global Infrastructure"></a>AWS Global Infrastructure</h4><p>（1）AWS Region</p><ul><li>A region is a cluster of data centers</li><li>一个 Region 至少有三个 AZ</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img114639.png"></p><p>（2）AWS Availability Zones</p><ul><li>Each availiablity zone (AZ) is one or more discrete data centers in the same location</li><li>AZ 组合起来就是 Region</li><li>All traffic between Availability Zones (AZ) is encrypted</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img114958.png"></p><p>（3）AWS Points of Presence (Edge Locations)</p><ul><li>Content is delivered to end users with low latency</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img115255.png"></p><hr><h4 id="AWS-Shared-Responsibility-Model"><a href="#AWS-Shared-Responsibility-Model" class="headerlink" title="AWS Shared Responsibility Model"></a>AWS Shared Responsibility Model</h4><ul><li>AWS负责云本身的安全 - 硬件、设施、基础设施</li><li>客户负责云里面的安全 - 你的数据、应用、配置</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img120115.png"></p><hr><h3 id="1-Identity-and-Access-Management"><a href="#1-Identity-and-Access-Management" class="headerlink" title="1. Identity and Access Management"></a>1. Identity and Access Management</h3><h4 id="IAM-Users-amp-Group"><a href="#IAM-Users-amp-Group" class="headerlink" title="IAM Users &amp; Group"></a>IAM Users &amp; Group</h4><p>IAM (Identity and Access Management) is a global service for managing users and permissions.</p><ul><li>Root account - Created with email and password. Don’t share it with anyone.</li><li>Users - Individual people in your organization.</li><li>Groups - Collections of users that share the same permissions.</li><li>Permissions - Follow the least privilege principle, meaning give users only the minimum access they need to do their job.</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img134540.png"></p><hr><h4 id="IAM-Policies"><a href="#IAM-Policies" class="headerlink" title="IAM Policies"></a>IAM Policies</h4><ul><li>IAM Policies - Define what actions users can perform. Inline Policy is attached directly to individual users.</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img140013.png"></p><ul><li>Password Policy &amp; MFA - Set password requirements for security. MFA (Multi-Factor Authentication) is a best practice, especially for the Root Account.</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img142218.png"></p><p>AWS Access Keys &amp; CLI &amp; SDK</p><ul><li>有 3 种方法 Access AWS: AWS Management Console，AWS CLI，AWS SDK</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img143439.png"></p><hr><h4 id="IAM-Roles"><a href="#IAM-Roles" class="headerlink" title="IAM Roles"></a>IAM Roles</h4><ul><li>IAM Roles - Assign permissions to AWS services (not people). For example, an EC2 instance needs a role to access S3.</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img150558.png"></p><p>IAM Guildlines &amp; Best Parctices</p><ul><li>Don’t use root account for daily tasks</li><li>Enable MFA</li><li>Use groups to assign permissions</li><li>Use roles for AWS services</li><li>Follow least privilege principle</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img153158.png"></p><hr><h3 id="2-Elastic-Compute-Cloud"><a href="#2-Elastic-Compute-Cloud" class="headerlink" title="2. Elastic Compute Cloud"></a>2. Elastic Compute Cloud</h3><h4 id="AWS-EC2-Elastic-Compute-Cloud"><a href="#AWS-EC2-Elastic-Compute-Cloud" class="headerlink" title="AWS EC2 (Elastic Compute Cloud)"></a>AWS EC2 (Elastic Compute Cloud)</h4><ul><li>60 seconds - There is a one-minute minimum charge for Linux based EC2 instances</li><li>Convertible reserved instance (RI): Purchase convertible reserved instance (RI) if you need additional flexibility, such as the ability to use different instance families, operating systems, or tenancies over the reserved instance (RI) term.</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img193350.png"></p><hr><h4 id="EC2-Instance-Types"><a href="#EC2-Instance-Types" class="headerlink" title="EC2 Instance Types"></a>EC2 Instance Types</h4><ul><li>General Purpose - Balanced compute, memory, and networking for most workloads</li><li>Compute Optimized - High performance processors for compute-intensive tasks</li><li>Memory Optimized - Large memory for processing big datasets</li><li>Storage Optimized - High disk performance for storage-intensive tasks</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img195856.png"></p><hr><h4 id="Security-Groups"><a href="#Security-Groups" class="headerlink" title="Security Groups"></a>Security Groups</h4><ul><li>Security Groups - EC2的防火墙，控制进出流量。</li><li>一个 Security Group 可以绑定到多个实例。</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img200755.png"></p><hr><h4 id="EC2-Instances-Purchasing-Options"><a href="#EC2-Instances-Purchasing-Options" class="headerlink" title="EC2 Instances Purchasing Options"></a>EC2 Instances Purchasing Options</h4><ul><li>On-Demand - 按需付费，用多少付多少</li><li>Reserved - 长期使用(1-3年)，价格更便宜</li><li>Savings Plans - 固定账单，超过部分按On-Demand计费</li><li>Spot Instances - 最便宜，但可能随时被收回</li><li>Dedicated Hosts - 完全控制一台物理服务器</li><li>Capacity Reservations - 短期预留容量，保证有实例可用(即使不用也付费)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img024118.png"></p><hr><h3 id="3-EC2-Instance-Storage"><a href="#3-EC2-Instance-Storage" class="headerlink" title="3. EC2 Instance Storage"></a>3. EC2 Instance Storage</h3><h4 id="AWS-EBS-Elastic-Block-Store"><a href="#AWS-EBS-Elastic-Block-Store" class="headerlink" title="AWS EBS (Elastic Block Store)"></a>AWS EBS (Elastic Block Store)</h4><ul><li>Attach EBS to EC2 instance like a USB drive</li><li>EBS Volume tied to AZ</li><li>Persist data even after termination</li><li>Block-level storage</li><li>Charge for EBS Volumes: Provisioned IOPS，Volume type</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img030842.png"></p><p>EBS Snapshots (备份)</p><ul><li>Make a backup (snapshot) of EBS volume</li><li>Recycle Bin 可以防止 Accidental Delete</li><li>Amazon Elastic Block Store (Amazon EBS) Snapshots are stored incrementally, which means you are billed only for the changed blocks stored</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img035925.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img040322.png"></p><p>EC2 Instance Store</p><ul><li>物理硬盘，直接连接到服务器。块级存储。超快I&#x2F;O性能。适合缓存。但实例停止时数据会丢失。</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img054643.png"></p><hr><h4 id="AWS-EFS-Elastic-File-System"><a href="#AWS-EFS-Elastic-File-System" class="headerlink" title="AWS EFS (Elastic File System)"></a>AWS EFS (Elastic File System)</h4><ul><li>可以 Mount 到多个 EC2 Instance</li><li>完全托管的 NFS 文件系统</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img055110.png"></p><ul><li>EBS只能连接到同一AZ的单个实例</li><li>EFS可以跨多个AZ、Region和VPC同时被多个实例访问</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img055536.png"></p><p>EFS Infrequent Access (EFS-IA)</p><ul><li>Storing files in an accessible location to satisfy audit requirements</li><li>You will pay a fee each time you read from or write data stored on the Amazon Elastic File System (Amazon EFS) - Infrequent Access storage class</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img055437.png"></p><hr><h4 id="AWS-AMI-Amazon-Machine-Image"><a href="#AWS-AMI-Amazon-Machine-Image" class="headerlink" title="AWS AMI (Amazon Machine Image)"></a>AWS AMI (Amazon Machine Image)</h4><ul><li>预配置好系统和软件(比如预装Apache)，快速启动实例。</li><li>区域特定 - 每个Region需要单独的AMI。</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img053649.png"></p><hr><h4 id="AWS-FSx"><a href="#AWS-FSx" class="headerlink" title="AWS FSx"></a>AWS FSx</h4><ul><li>托管的第三方文件系统服务。</li><li>FSx for Windows - 适合Windows应用，支持SMB协议和Active Directory集成</li><li>FSx for Lustre - 高性能文件系统，适合机器学习和高性能计算(HPC)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img060300.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img060312.png"></p><hr><h3 id="4-ELB-amp-ASG"><a href="#4-ELB-amp-ASG" class="headerlink" title="4. ELB &amp; ASG"></a>4. ELB &amp; ASG</h3><h4 id="Scalability-amp-High-Availability"><a href="#Scalability-amp-High-Availability" class="headerlink" title="Scalability &amp; High Availability"></a>Scalability &amp; High Availability</h4><ul><li>垂直扩展(Vertical Scale) - 增加实例大小(升级配置)</li><li>水平扩展(Horizontal Scale) - 增加实例数量(弹性扩展)</li><li>高可用性(High Availability) - 应用运行在至少2个可用区，实现灾难恢复</li></ul><hr><h4 id="AWS-ELB-Elastic-Load-Balancer"><a href="#AWS-ELB-Elastic-Load-Balancer" class="headerlink" title="AWS ELB (Elastic Load Balancer)"></a>AWS ELB (Elastic Load Balancer)</h4><ul><li>将流量分配到多个实例，实现负载均衡。</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img085521.png"></p><p>三种类型</p><ul><li>Application Load Balancer (ALB) - HTTP&#x2F;HTTPS流量，应用层(Layer 7)</li><li>Network Load Balancer (NLB) - TCP&#x2F;UDP流量，超高性能，网络层(Layer 4)</li><li>Gateway Load Balancer (GWLB) - 用于安全和防火墙设备</li><li>Classic Load Balancer已在2023年退役。</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img090125.png"></p><hr><h4 id="AWS-ASG-Auto-Scaling-Group"><a href="#AWS-ASG-Auto-Scaling-Group" class="headerlink" title="AWS ASG (Auto Scaling Group)"></a>AWS ASG (Auto Scaling Group)</h4><ul><li>使用Launch Template作为模板自动创建EC2实例。配合ELB根据负载自动扩展或缩减实例数量。自动替换不健康的实例，保持期望的实例数量。</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img091228.png"></p><p>扩展策略</p><ul><li>Manual Scaling - 手动调整实例数量</li><li>Dynamic Scaling - 根据指标(如CPU使用率)自动调整</li><li>Predictive Scaling - 使用机器学习预测流量并提前扩展</li></ul><hr><h3 id="5-Simple-Storage-Service"><a href="#5-Simple-Storage-Service" class="headerlink" title="5. Simple Storage Service"></a>5. Simple Storage Service</h3><h4 id="AWS-S3-Simple-Storage-Service"><a href="#AWS-S3-Simple-Storage-Service" class="headerlink" title="AWS S3 (Simple Storage Service)"></a>AWS S3 (Simple Storage Service)</h4><ul><li>对象存储服务，键值对结构，扁平化存储(非层级)。Bucket名称全局唯一，但定义在Region级别。默认加密(SSE-S3)。</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img093348.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img093802.png"></p><p>Bucket Policies</p><ul><li>User Access to S3: Use IAM permission</li><li>EC2 Instance Access: Use IAM Roles</li><li>Cross-Account Access: Use Bucket Policy</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img102509.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img102630.png"></p><p>S3 Website (Static Website Hosting): 托管静态网站</p><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img104755.png"></p><p>S3 Versioning: 版本控制，防止误删</p><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img105035.png"></p><p>S3 Replication (CRR &amp; SRR): 跨区域(CRR)或同区域(SRR)复制</p><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img105607.png"></p><p>S3 Storage Classes</p><ul><li>Standard - 频繁访问，最贵</li><li>Infrequent Access (IA) - 不常访问，便宜</li><li>Glacier - 归档存储，最便宜，检索慢</li><li>Intelligent Tiering - 自动根据访问频率移动数据</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img110113.png"></p><p>S3 Encryption: 默认启用服务器端加密</p><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img111248.png"></p><hr><h4 id="AWS-Snow-Family"><a href="#AWS-Snow-Family" class="headerlink" title="AWS Snow Family"></a>AWS Snow Family</h4><ul><li>物理设备，用于大规模数据传输到AWS</li><li>Snowcone - 最小，TB级</li><li>Snowball - 中等，TB到PB级</li><li>Snowmobile - 最大，EB级(卡车)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img122700.png"></p><p>Edge Computing</p><ul><li>Snow设备可以在任何地方(包括没网络的地方)处理数据，然后再传回AWS。</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img123338.png"></p><hr><h4 id="AWS-OpsHub"><a href="#AWS-OpsHub" class="headerlink" title="AWS OpsHub"></a>AWS OpsHub</h4><ul><li>用于管理Snow Family设备的软件工具。</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img123604.png"></p><hr><h4 id="AWS-Storage-Gateway"><a href="#AWS-Storage-Gateway" class="headerlink" title="AWS Storage Gateway"></a>AWS Storage Gateway</h4><ul><li>混合云存储解决方案，连接本地存储和AWS云存储</li><li>Automatically enabled data encryption</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img132624.png"></p><hr><h3 id="6-Database-amp-Analytics"><a href="#6-Database-amp-Analytics" class="headerlink" title="6. Database &amp; Analytics"></a>6. Database &amp; Analytics</h3><h4 id="AWS-RDS-Relational-Database-Service"><a href="#AWS-RDS-Relational-Database-Service" class="headerlink" title="AWS RDS (Relational Database Service)"></a>AWS RDS (Relational Database Service)</h4><ul><li>托管的关系型数据库服务(MySQL, PostgreSQL, Oracle等)。支持预留实例(RI)降低成本。</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img124658.png"></p><p>AWS Aurora</p><ul><li>AWS自研的高性能数据库，兼容MySQL和PostgreSQL。</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img134956.png"></p><p>RDS Deployments Options</p><ul><li>Read Replicas - 只读副本，提升读性能和扩展性</li><li>Multi-AZ - 多可用区，自动故障转移</li><li>Multi-Region - 多区域，灾难恢复和低延迟</li></ul><p>可以同时使用Read Replicas和Multi-AZ实现灾难恢复。</p><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img140045.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img148104.png"></p><hr><h4 id="AWS-Elastic-Cache"><a href="#AWS-Elastic-Cache" class="headerlink" title="AWS Elastic Cache"></a>AWS Elastic Cache</h4><ul><li>托管的内存数据库服务(支持Redis和Memcached)。</li><li>用于缓存数据，提升应用性能，减少数据库负载。</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img140153.png"></p><hr><h4 id="AWS-DynamoDB"><a href="#AWS-DynamoDB" class="headerlink" title="AWS DynamoDB"></a>AWS DynamoDB</h4><ul><li>完全托管的NoSQL数据库。支持预留容量降低成本。默认高可用(跨多个AZ)。</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img142315.png"></p><p>DynamoDB Accelerator (DAX)</p><ul><li>DynamoDB的内存缓存，微秒级延迟。</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img142430.png"></p><p>DynamoDB Global Tables</p><ul><li>多区域复制，实现全球低延迟访问。</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img142815.png"></p><hr><h4 id="AWS-Redshift"><a href="#AWS-Redshift" class="headerlink" title="AWS Redshift"></a>AWS Redshift</h4><ul><li>数据仓库服务，用于分析和大数据处理。基于列存储，适合OLAP(在线分析处理)。</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img143251.png"></p><p>Redshift Serverless</p><ul><li>无服务器版本，无需管理基础设施，按使用量付费。</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img123392.png"></p><hr><h4 id="AWS-EMR-Elastic-MapReduce"><a href="#AWS-EMR-Elastic-MapReduce" class="headerlink" title="AWS EMR (Elastic MapReduce)"></a>AWS EMR (Elastic MapReduce)</h4><ul><li>托管的Hadoop集群服务，用于大数据处理和分析。</li><li>支持Hadoop、Spark等大数据框架。</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img242278.png"></p><hr><h4 id="AWS-Athena"><a href="#AWS-Athena" class="headerlink" title="AWS Athena"></a>AWS Athena</h4><ul><li>无服务器查询服务，直接用SQL查询S3中的数据。</li><li>按扫描的数据量付费，无需加载数据。</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img144857.png"></p><hr><h4 id="AWS-QuickSight"><a href="#AWS-QuickSight" class="headerlink" title="AWS QuickSight"></a>AWS QuickSight</h4><ul><li>无服务器BI工具，创建可视化仪表板和报告。</li><li>支持从多种数据源导入数据进行分析。</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img145053.png"></p><hr><h4 id="AWS-DocumentDB"><a href="#AWS-DocumentDB" class="headerlink" title="AWS DocumentDB"></a>AWS DocumentDB</h4><ul><li>兼容MongoDB的托管NoSQL数据库服务。</li><li>完全托管，自动扩展，高可用。</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img145305.png"></p><hr><h4 id="AWS-Neptune"><a href="#AWS-Neptune" class="headerlink" title="AWS Neptune"></a>AWS Neptune</h4><ul><li>托管的图数据库服务。</li><li>适合社交网络、知识图谱、推荐系统等关系复杂的场景。</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img145437.png"></p><hr><h4 id="AWS-Timestream"><a href="#AWS-Timestream" class="headerlink" title="AWS Timestream"></a>AWS Timestream</h4><ul><li>托管的时序数据库。</li><li>适合IoT、监控指标、日志等时间序列数据。</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img145616.png"></p><hr><h4 id="AWS-QLDB"><a href="#AWS-QLDB" class="headerlink" title="AWS QLDB"></a>AWS QLDB</h4><ul><li>不可变的账本数据库。</li><li>适合金融交易记录、审计日志等需要完整历史追踪的场景。</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img122316.png"></p><hr><h4 id="AWS-Managed-Blockchain"><a href="#AWS-Managed-Blockchain" class="headerlink" title="AWS Managed Blockchain"></a>AWS Managed Blockchain</h4><ul><li>托管的区块链服务，支持去中心化网络。</li><li>支持Hyperledger Fabric和Ethereum框架。</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img150042.png"></p><hr><h4 id="AWS-Glue"><a href="#AWS-Glue" class="headerlink" title="AWS Glue"></a>AWS Glue</h4><ul><li>无服务器ETL服务(提取、转换、加载)。</li><li>自动发现数据、转换格式，为数据分析做准备。</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img150226.png"></p><hr><h4 id="AWS-DMS-Data-Migration-Service"><a href="#AWS-DMS-Data-Migration-Service" class="headerlink" title="AWS DMS (Data Migration Service)"></a>AWS DMS (Data Migration Service)</h4><ul><li>数据库迁移服务。</li><li>支持同构和异构数据库迁移，源数据库在迁移期间保持可用。</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img120404.png"></p><hr><h3 id="7-Other-Compute-Services"><a href="#7-Other-Compute-Services" class="headerlink" title="7. Other Compute Services"></a>7. Other Compute Services</h3><h4 id="AWS-ECS-Elastic-Container-Service"><a href="#AWS-ECS-Elastic-Container-Service" class="headerlink" title="AWS ECS (Elastic Container Service)"></a>AWS ECS (Elastic Container Service)</h4><ul><li>在AWS上运行Docker容器的服务。</li><li>需要自己管理EC2实例。</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img185536.png"></p><hr><h4 id="AWS-Fargate"><a href="#AWS-Fargate" class="headerlink" title="AWS Fargate"></a>AWS Fargate</h4><ul><li>无服务器容器运行平台。</li><li>运行Docker容器，无需管理EC2实例。</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img185649.png"></p><hr><h4 id="AWS-ECR-Elastic-Container-Registery"><a href="#AWS-ECR-Elastic-Container-Registery" class="headerlink" title="AWS ECR (Elastic Container Registery)"></a>AWS ECR (Elastic Container Registery)</h4><ul><li>Docker镜像仓库服务。</li><li>存储、管理和部署Docker容器镜像。</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img185752.png"></p><hr><h4 id="AWS-Lambda"><a href="#AWS-Lambda" class="headerlink" title="AWS Lambda"></a>AWS Lambda</h4><ul><li>无服务器计算服务。事件驱动，自动扩展。可用EventBridge定时触发(CRON)。</li><li>只为实际运行时间付费。</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img190238.png"></p><hr><h4 id="AWS-API-Gateway"><a href="#AWS-API-Gateway" class="headerlink" title="AWS API Gateway"></a>AWS API Gateway</h4><ul><li>创建、发布和管理REST&#x2F;HTTP API。</li><li>常与Lambda结合，将函数暴露为API端点。</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img031238.png"></p><hr><h4 id="AWS-Batch"><a href="#AWS-Batch" class="headerlink" title="AWS Batch"></a>AWS Batch</h4><ul><li>运行批处理作业(有开始和结束的任务)。</li><li>自动管理计算资源，适合大规模数据处理、机器学习训练等。</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img035927.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img040129.png"></p><hr><h4 id="AWS-Lightsail"><a href="#AWS-Lightsail" class="headerlink" title="AWS Lightsail"></a>AWS Lightsail</h4><ul><li>简化版云服务，适合初学者。</li><li>提供预配置的服务器、存储和网络，固定价格，易于使用。</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img042248.png"></p><hr><h3 id="8-Deployment-amp-Manage-Infrastructure"><a href="#8-Deployment-amp-Manage-Infrastructure" class="headerlink" title="8. Deployment &amp; Manage Infrastructure"></a>8. Deployment &amp; Manage Infrastructure</h3><h4 id="AWS-CloudFormation"><a href="#AWS-CloudFormation" class="headerlink" title="AWS CloudFormation"></a>AWS CloudFormation</h4><ul><li>基础设施即代码(IaC)服务。 (Terraform)</li><li>用模板文件自动创建和管理AWS资源，无需手动配置。支持版本控制和重复部署。</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img044630.png"></p><hr><h4 id="AWS-Elastic-Beanstalk"><a href="#AWS-Elastic-Beanstalk" class="headerlink" title="AWS Elastic Beanstalk"></a>AWS Elastic Beanstalk</h4><ul><li>PaaS平台即服务。只需上传代码，自动处理部署、负载均衡、扩展等。</li><li>服务本身免费，只为使用的底层资源付费。</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img064808.png"></p><hr><h4 id="AWS-CodeDeploy"><a href="#AWS-CodeDeploy" class="headerlink" title="AWS CodeDeploy"></a>AWS CodeDeploy</h4><ul><li>自动化应用部署服务。</li><li>支持部署到EC2、Lambda、本地服务器等。</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img074724.png"></p><hr><h4 id="AWS-CodeCommit"><a href="#AWS-CodeCommit" class="headerlink" title="AWS CodeCommit"></a>AWS CodeCommit</h4><ul><li>Git代码仓库托管服务，类似GitHub。</li><li>私有、安全、完全托管。</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img074839.png"></p><hr><h4 id="AWS-CodeBuild"><a href="#AWS-CodeBuild" class="headerlink" title="AWS CodeBuild"></a>AWS CodeBuild</h4><ul><li>持续集成服务，自动编译和测试代码。</li><li>按使用时间付费，无需管理构建服务器。</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img075430.png"></p><hr><h4 id="AWS-CodePipeline"><a href="#AWS-CodePipeline" class="headerlink" title="AWS CodePipeline"></a>AWS CodePipeline</h4><ul><li>CI&#x2F;CD持续集成&#x2F;持续交付服务。</li><li>编排整个发布流程(代码提交→构建→测试→部署)。通过CloudWatch Events监测CodeCommit变化。</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img081356.png"></p><hr><h4 id="AWS-CodeArtifact"><a href="#AWS-CodeArtifact" class="headerlink" title="AWS CodeArtifact"></a>AWS CodeArtifact</h4><ul><li>软件包仓库服务，管理依赖项。 (JFrog)</li><li>支持npm、Maven、pip等包管理工具。</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img082203.png"></p><hr><h4 id="AWS-CodeStar"><a href="#AWS-CodeStar" class="headerlink" title="AWS CodeStar"></a>AWS CodeStar</h4><ul><li>统一的开发工具集成平台。</li><li>整合CodePipeline、CodeCommit、CodeBuild、CodeDeploy等工具，快速搭建CI&#x2F;CD流程。可与Cloud9结合开发无服务器应用。</li></ul><hr><h4 id="AWS-Cloud9"><a href="#AWS-Cloud9" class="headerlink" title="AWS Cloud9"></a>AWS Cloud9</h4><ul><li>云端IDE(集成开发环境)。</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img082707.png"></p><hr><h4 id="AWS-SSM-Systems-Manager"><a href="#AWS-SSM-Systems-Manager" class="headerlink" title="AWS SSM (Systems Manager)"></a>AWS SSM (Systems Manager)</h4><ul><li>集中管理大量EC2实例和本地服务器。</li><li>自动化补丁、配置管理、运行命令等运维任务。</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img135524.png"></p><hr><h3 id="9-AWS-Global-Infrastructure"><a href="#9-AWS-Global-Infrastructure" class="headerlink" title="9. AWS Global Infrastructure"></a>9. AWS Global Infrastructure</h3><p>Why make a global application?</p><ul><li>Decreased Latency</li><li>Disaster Recovery (DR)</li></ul><p>Global Applications in AWS</p><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img142534.png"></p><hr><h4 id="AWS-Route53"><a href="#AWS-Route53" class="headerlink" title="AWS Route53"></a>AWS Route53</h4><ul><li>DNS域名解析服务</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img142637.png"></p><p>路由策略</p><ul><li>Simple - 简单路由，无健康检查</li><li>Weighted - 加权分配流量(如A&#x2F;B测试)</li><li>Latency - 基于延迟路由到最近的资源</li><li>Failover - 故障转移，主备切换(active-passive)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img142821.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img142907.png"></p><hr><h4 id="AWS-CloudFront"><a href="#AWS-CloudFront" class="headerlink" title="AWS CloudFront"></a>AWS CloudFront</h4><ul><li>全球CDN内容分发网络服务。</li><li>内容缓存在边缘节点，降低延迟。集成WAF(Web防火墙)和Shield(DDoS防护)。</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img144056.png"></p><hr><h4 id="AWS-Global-Accelerator"><a href="#AWS-Global-Accelerator" class="headerlink" title="AWS Global Accelerator"></a>AWS Global Accelerator</h4><ul><li>通过AWS内部网络加速全球流量(无缓存)。</li><li>提供静态IP作为应用的固定入口点。适合非HTTP场景(如游戏、IoT)。</li><li>与CloudFront区别：CloudFront有缓存且主要用于HTTP，Global Accelerator无缓存且用于任何协议。</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img184614.png"></p><hr><h4 id="AWS-Outposts"><a href="#AWS-Outposts" class="headerlink" title="AWS Outposts"></a>AWS Outposts</h4><ul><li>AWS物理服务器机架，部署在客户本地数据中心。</li><li>在本地运行AWS服务,实现混合云架构。</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img185046.png"></p><hr><h4 id="AWS-WaveLength"><a href="#AWS-WaveLength" class="headerlink" title="AWS WaveLength"></a>AWS WaveLength</h4><ul><li>将AWS服务部署到5G网络边缘。</li><li>超低延迟,适合移动应用和IoT设备。</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img185306.png"></p><hr><h3 id="10-Cloud-Integration"><a href="#10-Cloud-Integration" class="headerlink" title="10.Cloud Integration"></a>10.Cloud Integration</h3><h4 id="AWS-SQS-Simple-Queue-Service"><a href="#AWS-SQS-Simple-Queue-Service" class="headerlink" title="AWS SQS (Simple Queue Service)"></a>AWS SQS (Simple Queue Service)</h4><ul><li>消息队列服务,解耦应用组件。</li><li>消息被消费者读取后删除。保证消息至少被处理一次。队列模型(点对点)。</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img192052.png"></p><hr><h4 id="AWS-Kinesis"><a href="#AWS-Kinesis" class="headerlink" title="AWS Kinesis"></a>AWS Kinesis</h4><ul><li>实时大数据流处理服务。</li><li>实时收集、处理和分析流数据(如日志、点击流、IoT数据)。</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img200432.png"></p><hr><h4 id="AWS-SNS-Simple-Notification-Service"><a href="#AWS-SNS-Simple-Notification-Service" class="headerlink" title="AWS SNS (Simple Notification Service)"></a>AWS SNS (Simple Notification Service)</h4><ul><li>一条消息发送给多个接收者。</li><li>发布&#x2F;订阅模型(Pub&#x2F;Sub)。支持邮件、SMS、Lambda、SQS等多种订阅方式。</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img200634.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img200723.png"></p><hr><h4 id="AWS-MQ-Amazon-MQ"><a href="#AWS-MQ-Amazon-MQ" class="headerlink" title="AWS MQ (Amazon MQ)"></a>AWS MQ (Amazon MQ)</h4><ul><li>托管的消息代理服务,支持第三方消息中间件。</li><li>兼容Apache ActiveMQ和RabbitMQ,适合迁移现有应用。</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img201142.png"></p><hr><h3 id="11-Cloud-Monitoring"><a href="#11-Cloud-Monitoring" class="headerlink" title="11. Cloud Monitoring"></a>11. Cloud Monitoring</h3><h4 id="AWS-CloudWatch"><a href="#AWS-CloudWatch" class="headerlink" title="AWS CloudWatch"></a>AWS CloudWatch</h4><ul><li>监控AWS资源和应用性能。</li><li>CloudWatch Metric: 收集和跟踪指标(CPU、内存等)。账单指标存储在美东区域(N. Virginia),代表全球费用。</li><li>CloudWatch Alarms: 基于指标设置告警,触发通知或自动操作。</li><li>CloudWatch Logs: 收集和存储日志,支持EC2和本地服务器。</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img202020.png"></p><hr><h4 id="AWS-EventBridge"><a href="#AWS-EventBridge" class="headerlink" title="AWS EventBridge"></a>AWS EventBridge</h4><ul><li>事件总线服务,基于事件触发操作。</li><li>定制事件规则触发Lambda、SNS等服务。支持AWS服务事件、自定义事件和第三方SaaS应用事件。</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img203642.png"></p><hr><h4 id="AWS-CloudTrail"><a href="#AWS-CloudTrail" class="headerlink" title="AWS CloudTrail"></a>AWS CloudTrail</h4><ul><li>记录AWS账户的API调用和操作历史,用于治理、合规和审计。</li><li>CloudTrail Insights - 自动检测异常API活动(如写操作激增)。</li><li>默认记录所有管理事件,不包括数据事件和Insights事件。</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img064634.png"></p><hr><h4 id="AWS-X-Ray"><a href="#AWS-X-Ray" class="headerlink" title="AWS X-Ray"></a>AWS X-Ray</h4><ul><li>分布式应用追踪和调试服务。</li><li>分析和调试微服务和无服务器应用,可视化请求流程,定位性能瓶颈和错误。</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img070456.png"></p><hr><h4 id="AWS-CodeGuru"><a href="#AWS-CodeGuru" class="headerlink" title="AWS CodeGuru"></a>AWS CodeGuru</h4><ul><li>基于机器学习的代码审查和性能优化工具。</li><li>自动检测代码问题、安全漏洞和性能瓶颈,提供优化建议。</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img073052.png"></p><hr><h4 id="AWS-Health-Dashboard"><a href="#AWS-Health-Dashboard" class="headerlink" title="AWS Health Dashboard"></a>AWS Health Dashboard</h4><ul><li>显示AWS服务健康状态和影响账户的事件。</li><li>Service Health Dashboard - 所有AWS服务的全局状态</li><li>Account Health Dashboard - 影响你账户的个性化事件和通知</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img073557.png"></p><hr><h3 id="12-VPC-amp-Networking"><a href="#12-VPC-amp-Networking" class="headerlink" title="12. VPC &amp; Networking"></a>12. VPC &amp; Networking</h3><h4 id="AWS-VPC"><a href="#AWS-VPC" class="headerlink" title="AWS VPC"></a>AWS VPC</h4><p>AWS中的虚拟私有网络。</p><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img075533.png"></p><ul><li>Subnets: VPC内的子网分区(公有&#x2F;私有)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img075637.png"></p><ul><li>Internet Gateway (IGW) - 公有子网访问互联网</li><li>NAT Gateway - 私有子网访问互联网(单向)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img075859.png"></p><p>Security Group vs NACL</p><ul><li>Security Group: 实例级防火墙,只有允许规则,有状态(自动允许返回流量)</li><li>NACL: 子网级防火墙,允许和拒绝规则,无状态</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img080543.png"></p><p>VPC Flow Logs - 捕获VPC内网络流量日志</p><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img080849.png"></p><p>VPC Peering - 连接两个VPC</p><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img080936.png"></p><p>VPC Endpoints - 私密访问AWS服务,不经过互联网</p><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img101047.png"></p><hr><h4 id="AWS-PrivateLink"><a href="#AWS-PrivateLink" class="headerlink" title="AWS PrivateLink"></a>AWS PrivateLink</h4><ul><li>将第三方VPC或本地网络私密连接到AWS服务。</li><li>不经过公网,最安全的暴露服务方式。</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img101255.png"></p><hr><h4 id="Site-to-Site-VPN-amp-Direct-Connect"><a href="#Site-to-Site-VPN-amp-Direct-Connect" class="headerlink" title="Site to Site VPN &amp; Direct Connect"></a>Site to Site VPN &amp; Direct Connect</h4><p>Site-to-Site VPN</p><ul><li>通过公网建立加密连接,连接本地网络和AWS VPC。</li><li>组件: Virtual Private Gateway(VGW,AWS端) + Customer Gateway(客户端设备)</li></ul><p>Direct Connect</p><ul><li>专用物理网络连接,从本地直连AWS。</li><li>比VPN更稳定、低延迟、高带宽,但成本更高。</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img101436.png"></p><hr><h4 id="AWS-ClientVPN"><a href="#AWS-ClientVPN" class="headerlink" title="AWS ClientVPN"></a>AWS ClientVPN</h4><ul><li>允许用户从任何地方安全连接到AWS和本地网络。</li><li>基于OpenVPN的托管VPN服务,适合远程办公。</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img101635.png"></p><hr><h4 id="AWS-Transit-Gateway"><a href="#AWS-Transit-Gateway" class="headerlink" title="AWS Transit Gateway"></a>AWS Transit Gateway</h4><ul><li>中心化网络连接枢纽。</li><li>通过单个网关连接多个VPC和本地网络,简化复杂网络拓扑。</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img101746.png"></p><hr><h4 id="AWS-VPN"><a href="#AWS-VPN" class="headerlink" title="AWS VPN"></a>AWS VPN</h4><ul><li>在本地网络、远程办公室、客户端设备和AWS之间建立安全加密连接。</li><li>包括Site-to-Site VPN和Client VPN两种方式。</li></ul><hr><h3 id="13-Security-amp-Compliance"><a href="#13-Security-amp-Compliance" class="headerlink" title="13. Security &amp; Compliance"></a>13. Security &amp; Compliance</h3><h4 id="AWS-WAF-Web-Application-Firewall-amp-Shield"><a href="#AWS-WAF-Web-Application-Firewall-amp-Shield" class="headerlink" title="AWS WAF (Web Application Firewall) &amp; Shield"></a>AWS WAF (Web Application Firewall) &amp; Shield</h4><p>AWS Shield</p><ul><li>DDoS防护服务。</li><li>Shield Standard - 免费,自动防护基础DDoS攻击</li><li>Shield Advanced - 付费,高级防护,用于Route53和Global Accelerator等</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img103738.png"></p><p>AWS WAF</p><ul><li>Web应用防火墙,防护Layer 7攻击。</li><li>定义Web ACL规则,过滤恶意流量。可部署在CloudFront、ALB、API Gateway、AppSync上。</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img103839.png"></p><hr><h4 id="AWS-Network-Firewall"><a href="#AWS-Network-Firewall" class="headerlink" title="AWS Network Firewall"></a>AWS Network Firewall</h4><ul><li>托管的网络防火墙服务,保护整个VPC。</li><li>防护Layer 3-7流量,支持入侵检测&#x2F;防御(IDS&#x2F;IPS)。</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img103945.png"></p><hr><h4 id="AWS-Firewall-Manager"><a href="#AWS-Firewall-Manager" class="headerlink" title="AWS Firewall Manager"></a>AWS Firewall Manager</h4><ul><li>集中管理多个账户和应用的防火墙规则。</li><li>统一配置和管理WAF、Shield Advanced、Network Firewall等安全服务。</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img105934.png"></p><hr><h4 id="AWS-KMS-Key-Management-Service-amp-CloudHSM-Hardware-Security-Module"><a href="#AWS-KMS-Key-Management-Service-amp-CloudHSM-Hardware-Security-Module" class="headerlink" title="AWS KMS (Key Management Service) &amp; CloudHSM (Hardware Security Module)"></a>AWS KMS (Key Management Service) &amp; CloudHSM (Hardware Security Module)</h4><p>KMS</p><ul><li>托管的加密密钥管理服务。</li><li>创建和控制加密密钥,集成AWS服务自动加密。使用AWS托管密钥或客户托管密钥。</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img120343.png"></p><p>CloudHSM</p><ul><li>专用加密硬件设备。</li><li>客户完全控制密钥,符合严格合规要求(如FIPS 140-2 Level 3)。</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img120433.png"></p><hr><h4 id="AWS-ACM-AWS-Certificate-Manager"><a href="#AWS-ACM-AWS-Certificate-Manager" class="headerlink" title="AWS ACM (AWS Certificate Manager)"></a>AWS ACM (AWS Certificate Manager)</h4><ul><li>管理和部署SSL&#x2F;TLS证书。</li><li>免费提供公有证书,自动续期,集成到ELB、CloudFront、API Gateway等服务。</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img124350.png"></p><hr><h4 id="AWS-Secrets-Manager"><a href="#AWS-Secrets-Manager" class="headerlink" title="AWS Secrets Manager"></a>AWS Secrets Manager</h4><ul><li>存储和管理敏感信息(如数据库密码、API密钥)。</li><li>自动轮换密钥,加密存储,与RDS等服务集成。</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img124445.png"></p><hr><h4 id="AWS-Artifact"><a href="#AWS-Artifact" class="headerlink" title="AWS Artifact"></a>AWS Artifact</h4><ul><li>提供AWS合规报告和协议的自助服务门户。</li><li>下载SOC报告、PCI报告等合规文档,管理协议(如BAA)。</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img124706.png"></p><hr><h4 id="AWS-GuardDuty"><a href="#AWS-GuardDuty" class="headerlink" title="AWS GuardDuty"></a>AWS GuardDuty</h4><ul><li>智能威胁检测服务,使用机器学习分析账户活动。</li><li>持续监控VPC Flow Logs、CloudTrail、DNS日志,检测异常行为和恶意活动。</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img125533.png"></p><hr><h4 id="AWS-Inspector"><a href="#AWS-Inspector" class="headerlink" title="AWS Inspector"></a>AWS Inspector</h4><ul><li>自动化安全评估服务。</li><li>扫描EC2实例、容器镜像和Lambda函数,发现漏洞和安全问题,提供修复建议。</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img125801.png"></p><hr><h4 id="AWS-Config"><a href="#AWS-Config" class="headerlink" title="AWS Config"></a>AWS Config</h4><ul><li>记录和评估AWS资源配置的服务。</li><li>持续监控资源配置变化,审计合规性,查看配置历史。关键词:资源配置历史、审计、合规。</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img125948.png"></p><hr><h4 id="AWS-Macie"><a href="#AWS-Macie" class="headerlink" title="AWS Macie"></a>AWS Macie</h4><ul><li>使用机器学习发现和保护S3中的敏感数据。</li><li>自动识别PII(个人身份信息)、财务数据等敏感信息,提供数据安全评估。</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img130515.png"></p><hr><h4 id="AWS-Security-Hub"><a href="#AWS-Security-Hub" class="headerlink" title="AWS Security Hub"></a>AWS Security Hub</h4><ul><li>集中查看和管理AWS安全警报和合规状态。</li><li>聚合GuardDuty、Inspector、Macie等服务的安全发现,统一安全视图,自动合规检查。</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img131533.png"></p><hr><h4 id="AWS-Detective"><a href="#AWS-Detective" class="headerlink" title="AWS Detective"></a>AWS Detective</h4><ul><li>深入调查和分析安全问题根因。</li><li>自动收集和分析CloudTrail、VPC Flow Logs、GuardDuty发现,可视化展示安全事件关联。</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img132824.png"></p><hr><h4 id="IAM-Access-Analyzer"><a href="#IAM-Access-Analyzer" class="headerlink" title="IAM Access Analyzer"></a>IAM Access Analyzer</h4><ul><li>识别与外部实体共享的资源(S3 bucket、IAM角色等)。</li><li>分析资源策略,发现意外的公开访问或跨账户访问,提高安全性。</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img133559.png"></p><hr><h3 id="14-Machine-Learning"><a href="#14-Machine-Learning" class="headerlink" title="14. Machine Learning"></a>14. Machine Learning</h3><h4 id="AWS-Rekognition"><a href="#AWS-Rekognition" class="headerlink" title="AWS Rekognition"></a>AWS Rekognition</h4><ul><li>基于机器学习的图像和视频分析服务。</li><li>识别物体、人脸、文字、场景等。区域性服务。</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img164327.png"></p><hr><h4 id="AWS-Transcribe"><a href="#AWS-Transcribe" class="headerlink" title="AWS Transcribe"></a>AWS Transcribe</h4><ul><li>语音转文字服务,使用机器学习。</li><li>支持多种语言,自动识别说话人,可用于字幕生成、会议记录等。</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img164826.png"></p><hr><h4 id="Amazon-Elastic-Transcoder"><a href="#Amazon-Elastic-Transcoder" class="headerlink" title="Amazon Elastic Transcoder"></a>Amazon Elastic Transcoder</h4><ul><li>媒体转码服务。</li><li>将S3中的媒体文件转换为不同设备所需的格式(如移动设备、Web播放器)。</li></ul><hr><h4 id="AWS-Polly"><a href="#AWS-Polly" class="headerlink" title="AWS Polly"></a>AWS Polly</h4><ul><li>文字转语音服务,使用深度学习。</li><li>支持多种语言和声音,生成自然的人声,可用于应用朗读、辅助功能等。</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img165059.png"></p><hr><h4 id="AWS-Translate"><a href="#AWS-Translate" class="headerlink" title="AWS Translate"></a>AWS Translate</h4><ul><li>机器翻译服务,支持多语言互译。</li><li>使用神经网络提供自然流畅的翻译。</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img171433.png"></p><hr><h4 id="AWS-Lex-amp-Connect"><a href="#AWS-Lex-amp-Connect" class="headerlink" title="AWS Lex &amp; Connect"></a>AWS Lex &amp; Connect</h4><p>Lex</p><ul><li>构建对话机器人(聊天机器人、语音助手)。</li><li>与Alexa相同的技术,支持语音和文本交互。</li></ul><p>Connect</p><ul><li>云端呼叫中心服务。</li><li>管理客户联络,支持语音和聊天,与Lex集成实现智能客服。</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img171703.png"></p><hr><h4 id="AWS-Comprehend"><a href="#AWS-Comprehend" class="headerlink" title="AWS Comprehend"></a>AWS Comprehend</h4><ul><li>自然语言处理(NLP)服务。</li><li>分析文本情感、提取关键词、识别实体、语言检测、主题建模等。</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img171904.png"></p><hr><h4 id="AWS-SageMaker"><a href="#AWS-SageMaker" class="headerlink" title="AWS SageMaker"></a>AWS SageMaker</h4><ul><li>完全托管的机器学习平台。</li><li>构建、训练和部署机器学习模型,适合开发者和数据科学家。</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img175503.png"></p><hr><h4 id="AWS-Forecast"><a href="#AWS-Forecast" class="headerlink" title="AWS Forecast"></a>AWS Forecast</h4><ul><li>基于机器学习的时间序列预测服务。</li><li>预测需求、销量、资源需求等,使用与Amazon.com相同的技术。</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img180029.png"></p><hr><h4 id="AWS-Kendra"><a href="#AWS-Kendra" class="headerlink" title="AWS Kendra"></a>AWS Kendra</h4><ul><li>智能文档搜索服务,基于机器学习。</li><li>从各种文档中提取答案,理解自然语言查询,提供精准搜索结果。</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img180235.png"></p><hr><h4 id="AWS-Personalize"><a href="#AWS-Personalize" class="headerlink" title="AWS Personalize"></a>AWS Personalize</h4><ul><li>个性化推荐服务,基于机器学习。</li><li>提供实时个性化推荐(如产品、内容推荐),使用与Amazon.com相同的技术。</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img180943.png"></p><hr><h4 id="AWS-Textract"><a href="#AWS-Textract" class="headerlink" title="AWS Textract"></a>AWS Textract</h4><ul><li>从文档中自动提取文本和数据。</li><li>识别表单、表格、手写内容,无需手动处理,使用机器学习。</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img181533.png"></p><hr><h3 id="15-Account-Management，Billing-amp-Support"><a href="#15-Account-Management，Billing-amp-Support" class="headerlink" title="15. Account Management，Billing &amp; Support"></a>15. Account Management，Billing &amp; Support</h3><h4 id="AWS-Organization"><a href="#AWS-Organization" class="headerlink" title="AWS Organization"></a>AWS Organization</h4><ul><li>集中管理多个AWS账户,提供合并账单。所有账户统一计费,享受批量折扣。</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img215935.png"></p><hr><h4 id="AWS-Control-Tower"><a href="#AWS-Control-Tower" class="headerlink" title="AWS Control Tower"></a>AWS Control Tower</h4><ul><li>基于AWS Organizations运行。</li><li>提供预定义的蓝图和护栏,帮助客户为新AWS账户快速建立安全合规的登陆区(landing zone)。</li><li>自动化多账户环境的设置和治理。</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img230602.png"></p><hr><h4 id="AWS-Service-Catalog"><a href="#AWS-Service-Catalog" class="headerlink" title="AWS Service Catalog"></a>AWS Service Catalog</h4><ul><li>允许组织集中管理常用的已部署IT服务,确保合规性和标准化。</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img230820.png"></p><hr><h4 id="Pricing-Models-in-AWS"><a href="#Pricing-Models-in-AWS" class="headerlink" title="Pricing Models in AWS"></a>Pricing Models in AWS</h4><ul><li>按需付费(Pay as you go) - 根据实际使用量付费,无需预付或长期承诺。</li><li>预留容量(Save when you reserve) - 预留实例可获得大幅折扣,适合长期稳定的工作负载。</li><li>批量折扣(Pay less by using more) - 使用量越大,单价越低,享受分层定价优惠。</li><li>按需扩展节省成本(Pay less as AWS grows) - 随着AWS规模扩大,价格持续降低。</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img231117.png"></p><hr><h4 id="AWS-Compute-Optimizer"><a href="#AWS-Compute-Optimizer" class="headerlink" title="AWS Compute Optimizer"></a>AWS Compute Optimizer</h4><ul><li>分析资源使用情况,推荐最优的AWS资源配置。</li><li>支持EC2实例、Auto Scaling组、EBS卷和Lambda函数的优化建议。</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img232258.png"></p><hr><h4 id="Cost-Allocation-Tags"><a href="#Cost-Allocation-Tags" class="headerlink" title="Cost Allocation Tags"></a>Cost Allocation Tags</h4><ul><li>成本分配标签(Cost Allocation Tags) - 用于跟踪和管理AWS成本。</li><li>每个资源的标签键必须唯一,每个标签键只能有一个值。</li><li>必须分别激活AWS生成的标签和用户自定义标签,才能在Cost Explorer或成本分配报告中显示。</li></ul><hr><h4 id="AWS-Budgets"><a href="#AWS-Budgets" class="headerlink" title="AWS Budgets"></a>AWS Budgets</h4><p>预算类型</p><ul><li>成本预算(Cost budget) - 监控总支出</li><li>使用量预算(Usage budget) - 监控服务使用量</li><li>预留预算(Reservation budget) - 监控预留实例使用率</li></ul><p>设置自定义预算,当成本或使用量超出(或预计超出)预算金额时发送告警。</p><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img233133.png"></p><hr><h4 id="AWS-Pricing-Calculator"><a href="#AWS-Pricing-Calculator" class="headerlink" title="AWS Pricing Calculator"></a>AWS Pricing Calculator</h4><ul><li>估算AWS服务的成本,帮助规划和预算。</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img075527.png"></p><hr><h4 id="Cost-and-Usage-Reports"><a href="#Cost-and-Usage-Reports" class="headerlink" title="Cost and Usage Reports"></a>Cost and Usage Reports</h4><ul><li>提供详细的成本和使用情况数据,可导出到S3进行深入分析。</li><li>包含所有AWS服务的详细账单信息,支持自定义报告格式。</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img075737.png"></p><hr><h4 id="Cost-Explorer"><a href="#Cost-Explorer" class="headerlink" title="Cost Explorer"></a>Cost Explorer</h4><ul><li>提供易用的界面,查看历史成本和使用趋势。</li><li>可以预测未来的AWS账户使用量和成本。</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img075833.png"></p><hr><h4 id="AWS-Trusted-Advisor"><a href="#AWS-Trusted-Advisor" class="headerlink" title="AWS Trusted Advisor"></a>AWS Trusted Advisor</h4><ul><li>核心功能: 成本优化、性能、安全性、容错能力、服务限制检查。</li><li>识别未挂载或使用率低的EBS卷,优化资源使用和成本。</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img233600.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img175558.png"></p><hr><h4 id="AWS-Service-Quotas"><a href="#AWS-Service-Quotas" class="headerlink" title="AWS Service Quotas"></a>AWS Service Quotas</h4><ul><li>集中管理所有AWS服务的配额限制,可以请求提高配额。</li></ul><hr><h4 id="AWS-Support-Plans-Pricing"><a href="#AWS-Support-Plans-Pricing" class="headerlink" title="AWS Support Plans Pricing"></a>AWS Support Plans Pricing</h4><ul><li>Basic(免费) - 基础支持,访问文档和论坛。</li><li>Developer - 适合开发测试环境,工作时间内的技术支持。</li><li>Bsiness - 24&#x2F;7技术支持,1小时响应生产系统故障。</li><li>Enterprise On-Ramp - 包含部分企业级服务,技术客户经理(TAM)支持。</li><li>Enterprise - 全面企业级支持,专属TAM,15分钟响应关键业务系统故障。</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img233819.png"></p><hr><h3 id="16-Adavanced-Identity"><a href="#16-Adavanced-Identity" class="headerlink" title="16. Adavanced Identity"></a>16. Adavanced Identity</h3><h4 id="AWS-STS-Security-Token-Service"><a href="#AWS-STS-Security-Token-Service" class="headerlink" title="AWS STS (Security Token Service)"></a>AWS STS (Security Token Service)</h4><ul><li>创建临时的、有限权限的AWS访问凭证。</li><li>用于跨账户访问、联合身份验证或临时授权,无需共享长期凭证。</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img072649.png"></p><hr><h4 id="AWS-Cognito"><a href="#AWS-Cognito" class="headerlink" title="AWS Cognito"></a>AWS Cognito</h4><ul><li>处理用户注册、登录和访问控制。</li><li>支持社交登录(Google、Facebook等)和企业身份提供商集成。</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img072756.png"></p><hr><h4 id="AWS-IAM-Identity-Center"><a href="#AWS-IAM-Identity-Center" class="headerlink" title="AWS IAM Identity Center"></a>AWS IAM Identity Center</h4><ul><li>一次登录即可访问多个AWS账户和应用程序。</li><li>集中管理用户权限,简化多账户环境的访问管理。</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img073056.png"></p><hr><h3 id="17-Other-AWS-Services"><a href="#17-Other-AWS-Services" class="headerlink" title="17. Other AWS Services"></a>17. Other AWS Services</h3><h4 id="AWS-WorkSpace"><a href="#AWS-WorkSpace" class="headerlink" title="AWS WorkSpace"></a>AWS WorkSpace</h4><ul><li>提供托管的桌面即服务(DaaS),用户可以从任何地方访问云端桌面。</li><li>支持Windows和Linux,按需付费或按月订阅。</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img083303.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img083335.png"></p><hr><h4 id="AWS-AppStream"><a href="#AWS-AppStream" class="headerlink" title="AWS AppStream"></a>AWS AppStream</h4><ul><li>无需下载或安装,直接通过浏览器访问应用程序。</li><li>应用程序流式传输,用户无需管理基础设施。</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img083422.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img083502.png"></p><hr><h4 id="AWS-IoT"><a href="#AWS-IoT" class="headerlink" title="AWS IoT"></a>AWS IoT</h4><ul><li>连接和管理数十亿台IoT设备。</li><li>安全地收集、处理和分析设备数据,与其他AWS服务集成。</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img083607.png"></p><hr><h4 id="AWS-AppSync"><a href="#AWS-AppSync" class="headerlink" title="AWS AppSync"></a>AWS AppSync</h4><ul><li>简化应用程序开发,提供实时数据同步和离线访问。</li><li>自动扩展GraphQL API,连接多个数据源(DynamoDB、Lambda等)。</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img083702.png"></p><hr><h4 id="AWS-Amplify"><a href="#AWS-Amplify" class="headerlink" title="AWS Amplify"></a>AWS Amplify</h4><ul><li>提供前端和后端开发工具,快速构建和部署应用。</li><li>集成身份验证、存储、API等服务,支持CI&#x2F;CD自动部署。</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img085244.png"></p><hr><h4 id="AWS-Application-Composer"><a href="#AWS-Application-Composer" class="headerlink" title="AWS Application Composer"></a>AWS Application Composer</h4><ul><li>拖放式界面设计应用架构,自动生成基础设施即代码(IaC)。</li><li>简化Lambda、API Gateway等无服务器资源的配置和连接。</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img085340.png"></p><hr><h4 id="AWS-Device-Farm"><a href="#AWS-Device-Farm" class="headerlink" title="AWS Device Farm"></a>AWS Device Farm</h4><ul><li>提供真实物理设备和虚拟设备进行测试。</li><li>自动化测试,快速发现兼容性问题和bug。</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img085508.png"></p><hr><h4 id="AWS-Backup"><a href="#AWS-Backup" class="headerlink" title="AWS Backup"></a>AWS Backup</h4><ul><li>自动化和集中管理跨AWS服务的数据备份。</li><li>支持EC2、EBS、RDS、DynamoDB等多种服务,设置备份策略和保留周期。</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img085539.png"></p><hr><h4 id="Disaster-Recovery-Strategies"><a href="#Disaster-Recovery-Strategies" class="headerlink" title="Disaster Recovery Strategies"></a>Disaster Recovery Strategies</h4><p>从低成本到高可用性排序</p><ul><li>Backup and Restore(备份和恢复) - 最便宜,恢复时间最长,定期备份数据到S3。</li><li>Pilot Light(试点灯) - 核心系统保持最小运行状态,灾难时快速扩展。</li><li>Warm Standby(温备) - 维护缩小版本的完整环境,可快速扩展到生产容量。</li><li>Multi-Site&#x2F;Hot Site(多站点&#x2F;热备) - 最贵,恢复时间最短,在多个区域运行完整生产环境。</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img085705.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img085729.png"></p><hr><h4 id="AWS-DRS-Elastic-Disaster-Recovery"><a href="#AWS-DRS-Elastic-Disaster-Recovery" class="headerlink" title="AWS DRS (Elastic Disaster Recovery)"></a>AWS DRS (Elastic Disaster Recovery)</h4><ul><li>持续复制本地或云端服务器到AWS。</li><li>发生灾难时,快速故障转移到AWS,最小化停机时间和数据丢失。</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img085904.png"></p><hr><h4 id="AWS-DataSync"><a href="#AWS-DataSync" class="headerlink" title="AWS DataSync"></a>AWS DataSync</h4><ul><li>在本地存储和AWS之间快速移动大量数据。</li><li>支持增量复制,自动加密和数据完整性验证,比传统方法快10倍。</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img085958.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img090038.png"></p><hr><h4 id="AWS-Application-Discovery-Service"><a href="#AWS-Application-Discovery-Service" class="headerlink" title="AWS Application Discovery Service"></a>AWS Application Discovery Service</h4><ul><li>收集服务器配置、性能数据和依赖关系信息。</li><li>帮助规划AWS迁移,了解现有IT资产和应用依赖。</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img090147.png"></p><hr><h4 id="AWS-Application-Migration-Service"><a href="#AWS-Application-Migration-Service" class="headerlink" title="AWS Application Migration Service"></a>AWS Application Migration Service</h4><ul><li>简化和加速将应用迁移到AWS。</li><li>持续复制源服务器到AWS,最小化停机时间,自动转换和启动。</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img090259.png"></p><hr><h4 id="AWS-Migration-Hub"><a href="#AWS-Migration-Hub" class="headerlink" title="AWS Migration Hub"></a>AWS Migration Hub</h4><ul><li>统一查看和跟踪多个AWS迁移工具的迁移进度。</li><li>集成Application Migration Service、Database Migration Service等工具,提供单一视图。</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img090459.png"></p><hr><h4 id="AWS-Migration-Evaluator"><a href="#AWS-Migration-Evaluator" class="headerlink" title="AWS Migration Evaluator"></a>AWS Migration Evaluator</h4><ul><li>前身为TSO Logic,免费服务。</li><li>分析本地环境使用情况,提供成本估算和迁移建议,帮助规划云迁移决策。</li></ul><hr><h4 id="AWS-FIS-Fault-Injection-Simulator"><a href="#AWS-FIS-Fault-Injection-Simulator" class="headerlink" title="AWS FIS (Fault Injection Simulator)"></a>AWS FIS (Fault Injection Simulator)</h4><ul><li>在受控环境中测试应用的弹性和可靠性。</li><li>模拟各种故障场景(如EC2实例终止、网络延迟),验证系统恢复能力。</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img090535.png"></p><hr><h4 id="AWS-Step-Functions"><a href="#AWS-Step-Functions" class="headerlink" title="AWS Step Functions"></a>AWS Step Functions</h4><ul><li>可视化协调多个AWS服务(Lambda、ECS、SNS等)。</li><li>构建和管理复杂的分布式应用工作流,自动处理错误和重试。</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img090614.png"></p><hr><h4 id="AWS-Ground-Station"><a href="#AWS-Ground-Station" class="headerlink" title="AWS Ground Station"></a>AWS Ground Station</h4><ul><li>按需访问卫星通信,无需建设和维护地面站基础设施。</li><li>控制卫星、下载数据,与AWS服务集成进行数据处理和分析。</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img090709.png"></p><hr><h4 id="AWS-Pinpoint"><a href="#AWS-Pinpoint" class="headerlink" title="AWS Pinpoint"></a>AWS Pinpoint</h4><ul><li>发送个性化的电子邮件、短信、推送通知和语音消息。</li><li>支持用户细分、A&#x2F;B测试和营销活动分析,提高用户参与度。</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img090818.png"></p><hr><h4 id="AWS-Systems-Manager"><a href="#AWS-Systems-Manager" class="headerlink" title="AWS Systems Manager"></a>AWS Systems Manager</h4><ul><li>集中管理和自动化AWS资源的运维任务。</li><li>获取运维数据洞察,快速识别影响应用的问题,统一查看和控制基础设施。</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img075954.png"></p><hr><h4 id="AWS-SSM-Systems-Manager-Session-Manager"><a href="#AWS-SSM-Systems-Manager-Session-Manager" class="headerlink" title="AWS SSM (Systems Manager Session Manager)"></a>AWS SSM (Systems Manager Session Manager)</h4><ul><li>提供基于浏览器的交互式shell和CLI体验。</li><li>无需开放SSH端口或管理密钥,安全地访问和管理EC2实例。</li></ul><hr><h4 id="AWS-SSO"><a href="#AWS-SSO" class="headerlink" title="AWS SSO"></a>AWS SSO</h4><ul><li>集中管理多个AWS账户和业务应用的访问权限。</li><li>用户一次登录即可访问所有分配的账户和应用,简化身份管理。</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img080225.png"></p><hr><h4 id="AWS-Service-Health-Dashboard"><a href="#AWS-Service-Health-Dashboard" class="headerlink" title="AWS Service Health Dashboard"></a>AWS Service Health Dashboard</h4><ul><li>以表格形式显示所有AWS区域中各项服务的实时状态和可用性。</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img083127.png"></p><hr><h4 id="AWS-Marketplace"><a href="#AWS-Marketplace" class="headerlink" title="AWS Marketplace"></a>AWS Marketplace</h4><ul><li>向AWS客户销售软件即服务(SaaS)解决方案。</li><li>客户可以购买由卖家打包成自定义AMI的软件,快速部署第三方应用。</li></ul><hr><h4 id="AWS-Well-Architected-Tool"><a href="#AWS-Well-Architected-Tool" class="headerlink" title="AWS Well-Architected Tool"></a>AWS Well-Architected Tool</h4><ul><li>评估工作负载状态,与AWS架构最佳实践进行对比。</li><li>基于六大支柱(运营卓越、安全性、可靠性、性能效率、成本优化、可持续性)提供改进建议。</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img175558.png"></p><hr><h4 id="AWS-Resource-Groups"><a href="#AWS-Resource-Groups" class="headerlink" title="AWS Resource Groups"></a>AWS Resource Groups</h4><ul><li>将资源分组管理,便于对大量资源批量执行任务和自动化操作。</li><li>基于标签或其他标准创建资源组,简化管理和监控。</li></ul><hr><h4 id="AWS-Cloud-Foundations"><a href="#AWS-Cloud-Foundations" class="headerlink" title="AWS Cloud Foundations"></a>AWS Cloud Foundations</h4><ul><li>提供引导式路径,帮助客户部署、配置和保护新工作负载。</li><li>确保环境为云端持续运维做好准备,遵循AWS最佳实践。</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img170401.png"></p><hr><h4 id="AWS-IQ"><a href="#AWS-IQ" class="headerlink" title="AWS IQ"></a>AWS IQ</h4><ul><li>快速找到AWS认证的第三方专家帮助完成AWS项目。</li><li>按需付费,获得专业支持和咨询服务。</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img092907.png"></p><hr><h4 id="AWS-AMS-Managed-Services"><a href="#AWS-AMS-Managed-Services" class="headerlink" title="AWS AMS (Managed Services)"></a>AWS AMS (Managed Services)</h4><ul><li>AWS代为运营和管理基础设施。</li><li>处理日常运维任务、监控、补丁管理和安全,让客户专注业务。</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img093104.png"></p>]]></content>
      
      
      <categories>
          
          <category> Certification </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AWS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端切图仔</title>
      <link href="/posts/bfacd5b7.html"/>
      <url>/posts/bfacd5b7.html</url>
      
        <content type="html"><![CDATA[<hr><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><ul><li>正经人谁写<code>CSS</code>啊 😅 (<code>https://jsfiddle.net/user/fiddles/all/1/</code>)</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Hongda-OSU/PicGo/image/76d443f8f92e4e8eaeb8c4d368cdfe81~tplv-k3u1fbpfcp-jj-mark_3024_0_0_0_q75.awebp"></p><hr><h3 id="滚动视差"><a href="#滚动视差" class="headerlink" title="滚动视差"></a>滚动视差</h3><ul><li><code>Scroll Parallax</code></li></ul><iframe width="100%" height="400px" src="//jsfiddle.net/HDL52/ekg7nrs1/84/embedded/result/dark/" frameborder="0" loading="lazy" allowtransparency="true" allowfullscreen="true"></iframe><iframe width="100%" height="400px" src="//jsfiddle.net/HDL52/28rnshqx/88/embedded/result/dark/" rameborder="0" loading="lazy" allowfullscreen="allowfullscreen" allowpaymentrequest frameborder="0"></iframe><hr><h3 id="鼠标视差"><a href="#鼠标视差" class="headerlink" title="鼠标视差"></a>鼠标视差</h3><ul><li><code>Mouse Parallax</code></li></ul><iframe width="100%" height="400px" src="//jsfiddle.net/HDL52/18uedakg/331/embedded/result/dark/" frameborder="0" loading="lazy" allowtransparency="true" allowfullscreen="true"></iframe><hr><h3 id="打字机效果"><a href="#打字机效果" class="headerlink" title="打字机效果"></a>打字机效果</h3><ul><li>也可以叫做 <code>typing effect</code></li></ul><iframe width="100%" height="400px" src="//jsfiddle.net/HDL52/qgaywfs8/55/embedded/result/dark/" allowfullscreen="allowfullscreen" allowpaymentrequest frameborder="0"></iframe><iframe src="https://codesandbox.io/embed/fw94fg?view=preview&module=%2Fpublic%2Findex.html&hidenavigation=1"     style="width:100%; height: 500px; border:0; border-radius: 4px; overflow:hidden;"     title="Typing"     allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"     sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"   ></iframe><hr><h3 id="3D-卡片效果"><a href="#3D-卡片效果" class="headerlink" title="3D 卡片效果"></a>3D 卡片效果</h3><p><code>https://www.cnblogs.com/coco1s/p/17979602</code></p><iframe width="100%" height="400px" src="//jsfiddle.net/HDL52/cswk73b2/205/embedded/result/dark/" frameborder="0" loading="lazy" allowtransparency="true" allowfullscreen="true"></iframe><iframe src="https://codesandbox.io/embed/cwy6d7?view=preview&module=%2Fpublic%2Findex.html&hidenavigation=1"     style="width:100%; height: 500px; border:0; border-radius: 4px; overflow:hidden;"     title="3D 卡片"     allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"     sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"   ></iframe><iframe src="https://codesandbox.io/embed/9nldjd?view=preview&module=%2Fpublic%2Findex.html&hidenavigation=1"     style="width:100%; height: 500px; border:0; border-radius: 4px; overflow:hidden;"     title="卡片"     allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"     sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"   ></iframe><iframe width="100%" height="400px" src="//jsfiddle.net/HDL52/e01vtrpc/18/embedded/result/dark/" frameborder="0" loading="lazy" allowtransparency="true" allowfullscreen="true"></iframe><iframe width="100%" height="400px" src="//jsfiddle.net/HDL52/0wh5zu9s/6/embedded/result/dark/" frameborder="0" loading="lazy" allowtransparency="true" allowfullscreen="true"></iframe><hr><h3 id="卡片效果"><a href="#卡片效果" class="headerlink" title="卡片效果"></a>卡片效果</h3><iframe width="100%" height="400px" src="//jsfiddle.net/HDL52/9czbrops/46/embedded/result/dark/" frameborder="0" loading="lazy" allowtransparency="true" allowfullscreen="true"></iframe><iframe width="100%" height="400px" src="//jsfiddle.net/HDL52/cugLmsv3/354/embedded/result/dark/" frameborder="0" loading="lazy" allowtransparency="true" allowfullscreen="true"></iframe><iframe width="100%" height="400px" src="//jsfiddle.net/HDL52/ha8o2v65/143/embedded/result/dark/" frameborder="0" loading="lazy" allowtransparency="true" allowfullscreen="true"></iframe><hr><h3 id="下划线特效"><a href="#下划线特效" class="headerlink" title="下划线特效"></a>下划线特效</h3><iframe width="100%" height="400px" src="//jsfiddle.net/HDL52/xpq1g3eu/63/embedded/result/dark/" allowfullscreen="allowfullscreen" allowpaymentrequest frameborder="0"></iframe><hr><h3 id="Zoom-效果"><a href="#Zoom-效果" class="headerlink" title="Zoom 效果"></a>Zoom 效果</h3><ul><li><code>https://css-tricks.com/re-creating-the-porky-pig-animation-from-looney-tunes-in-css/</code></li></ul><iframe width="100%" height="400px" src="//jsfiddle.net/HDL52/cpuLzsfm/143/embedded/result/dark/" frameborder="0" loading="lazy" allowtransparency="true" allowfullscreen="true"></iframe><iframe width="100%" height="400px" src="//jsfiddle.net/HDL52/ugwzj47x/39/embedded/result/dark/" frameborder="0" loading="lazy" allowtransparency="true" allowfullscreen="true"></iframe><hr><h3 id="视频背景"><a href="#视频背景" class="headerlink" title="视频背景"></a>视频背景</h3><iframe width="100%" height="400px" src="//jsfiddle.net/HDL52/wdehmqgp/50/embedded/result/dark/" allowfullscreen="allowfullscreen" allowpaymentrequest frameborder="0"></iframe><hr><h3 id="头像特效"><a href="#头像特效" class="headerlink" title="头像特效"></a>头像特效</h3><iframe width="100%" height="400px" src="//jsfiddle.net/HDL52/56y0gqzw/37/embedded/result/dark/" frameborder="0" loading="lazy" allowtransparency="true" allowfullscreen="true"></iframe><iframe width="100%" height="400px" src="//jsfiddle.net/HDL52/c6uph9ab/69/embedded/result/dark/" frameborder="0" loading="lazy" allowtransparency="true" allowfullscreen="true"></iframe><hr><h3 id="鼠标效果"><a href="#鼠标效果" class="headerlink" title="鼠标效果"></a>鼠标效果</h3><iframe width="100%" height="400px" src="//jsfiddle.net/HDL52/qxndvehu/21/embedded/result/dark/" allowfullscreen="allowfullscreen" allowpaymentrequest frameborder="0"></iframe><iframe width="100%" height="400px" src="//jsfiddle.net/HDL52/8trua6n4/16/embedded/result/dark/" allowfullscreen="allowfullscreen" allowpaymentrequest frameborder="0"></iframe><iframe src="https://codesandbox.io/embed/fgrc6y?view=preview&module=%2Fsrc%2Fstyles.css"     style="width:100%; height: 500px; border:0; border-radius: 4px; overflow:hidden;"     title="鼠标特效"     allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"     sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"   ></iframe><iframe width="100%" height="400px" src="//jsfiddle.net/HDL52/ua5hfbwr/47/embedded/result/dark/" frameborder="0" loading="lazy" allowtransparency="true" allowfullscreen="true"></iframe><ul><li>动态鼠标效果</li></ul><iframe width="100%" height="400px" src="//jsfiddle.net/HDL52/fwbL130q/4/embedded/result/dark/" frameborder="0" loading="lazy" allowtransparency="true" allowfullscreen="true"></iframe><iframe width="100%" height="400px" src="//jsfiddle.net/HDL52/y93shdxv/9/embedded/result/dark/" frameborder="0" loading="lazy" allowtransparency="true" allowfullscreen="true"></iframe><hr><h3 id="图片倒影"><a href="#图片倒影" class="headerlink" title="图片倒影"></a>图片倒影</h3><iframe width="100%" height="400px" src="//jsfiddle.net/HDL52/v5Loj9b1/74/embedded/result/dark/" allowfullscreen="allowfullscreen" allowpaymentrequest frameborder="0"></iframe><hr><h3 id="噪音特效"><a href="#噪音特效" class="headerlink" title="噪音特效"></a>噪音特效</h3><iframe width="100%" height="400px" src="//jsfiddle.net/HDL52/ksyx497p/4/embedded/result/dark/" allowfullscreen="allowfullscreen" allowpaymentrequest frameborder="0"></iframe><hr><h3 id="图片堆叠"><a href="#图片堆叠" class="headerlink" title="图片堆叠"></a>图片堆叠</h3><iframe width="100%" height="400px" src="//jsfiddle.net/HDL52/sfc0anmu/86/embedded/result/dark/" allowfullscreen="allowfullscreen" allowpaymentrequest frameborder="0"></iframe><iframe width="100%" height="400px" src="//jsfiddle.net/HDL52/y41krcn9/58/embedded/result/dark/" allowfullscreen="allowfullscreen" allowpaymentrequest frameborder="0"></iframe><hr><h3 id="人潮汹涌"><a href="#人潮汹涌" class="headerlink" title="人潮汹涌"></a>人潮汹涌</h3><p><code>https://codepen.io/zadvorsky/pen/xxwbBQV</code></p><iframe src="https://codesandbox.io/embed/r327rm?view=preview&module=%2Fsrc%2FApp.js&hidenavigation=1"     style="width:100%; height: 500px; border:0; border-radius: 4px; overflow:hidden;"     title="人潮汹涌"     allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"     sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"   ></iframe><hr><h3 id="文字特效"><a href="#文字特效" class="headerlink" title="文字特效"></a>文字特效</h3><iframe width="100%" height="400px" src="//jsfiddle.net/HDL52/0ezmgf81/253/embedded/result/dark/" allowfullscreen="allowfullscreen" allowpaymentrequest frameborder="0"></iframe><iframe src="https://codesandbox.io/embed/yh5272?view=preview&module=%2Fpublic%2Findex.html"     style="width:100%; height: 500px; border:0; border-radius: 4px; overflow:hidden;"     title="名字"     allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"     sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"   ></iframe>   <hr><h3 id="图片消失"><a href="#图片消失" class="headerlink" title="图片消失"></a>图片消失</h3><iframe width="100%" height="400px" src="//jsfiddle.net/HDL52/e9kzqtop/228/embedded/result/dark/" allowfullscreen="allowfullscreen" allowpaymentrequest frameborder="0"></iframe><hr><h3 id="奇怪的特效"><a href="#奇怪的特效" class="headerlink" title="奇怪的特效"></a>奇怪的特效</h3><iframe width="100%" height="400px" src="//jsfiddle.net/HDL52/cyL2t579/34/embedded/result/dark/" frameborder="0" loading="lazy" allowtransparency="true" allowfullscreen="true"></iframe><iframe width="100%" height="400px" src="//jsfiddle.net/HDL52/tm3o4ncj/8/embedded/result/dark/" frameborder="0" loading="lazy" allowtransparency="true" allowfullscreen="true"></iframe><iframe width="100%" height="400px" src="//jsfiddle.net/HDL52/gmydz8ew/11/embedded/result/dark/" frameborder="0" loading="lazy" allowtransparency="true" allowfullscreen="true"></iframe><iframe width="100%" height="400px" src="//jsfiddle.net/HDL52/twL2a3nk/106/embedded/result/dark/" frameborder="0" loading="lazy" allowtransparency="true" allowfullscreen="true"></iframe><hr><h3 id="Hover-效果"><a href="#Hover-效果" class="headerlink" title="Hover 效果"></a>Hover 效果</h3><iframe width="100%" height="400px" src="//jsfiddle.net/HDL52/bf476zy1/11/embedded/result/dark/" allowfullscreen="allowfullscreen" allowpaymentrequest frameborder="0"></iframe><iframe width="100%" height="400px" src="//jsfiddle.net/HDL52/ok27hLs1/8/embedded/result/dark/" allowfullscreen="allowfullscreen" allowpaymentrequest frameborder="0"></iframe><iframe width="100%" height="400px" src="//jsfiddle.net/HDL52/fw9reojc/105/embedded/result/dark/" allowfullscreen="allowfullscreen" allowpaymentrequest frameborder="0"></iframe><iframe width="100%" height="400px" src="//jsfiddle.net/HDL52/anumv6g4/87/embedded/result/dark/" allowfullscreen="allowfullscreen" allowpaymentrequest frameborder="0"></iframe><hr><h3 id="无限图片"><a href="#无限图片" class="headerlink" title="无限图片"></a>无限图片</h3><iframe src="https://codesandbox.io/embed/k98xf4?view=preview&hidenavigation=1"     style="width:100%; height: 500px; border:0; border-radius: 4px; overflow:hidden;"     title="无限滑动"     allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"     sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"   ></iframe><iframe width="100%" height="400px" src="//jsfiddle.net/HDL52/y9gmv76d/64/embedded/result/dark/" frameborder="0" loading="lazy" allowtransparency="true" allowfullscreen="true"></iframe><hr><h3 id="神光效果"><a href="#神光效果" class="headerlink" title="神光效果"></a>神光效果</h3><iframe width="100%" height="400px" src="//jsfiddle.net/HDL52/cLmaf6tu/66/embedded/result/dark/" frameborder="0" loading="lazy" allowtransparency="true" allowfullscreen="true"></iframe><iframe width="100%" height="400px" src="//jsfiddle.net/HDL52/4wcd6th1/113/embedded/result/dark/" frameborder="0" loading="lazy" allowtransparency="true" allowfullscreen="true"></iframe><iframe width="100%" height="400px" src="//jsfiddle.net/HDL52/aLujzrpe/8/embedded/result/dark/" frameborder="0" loading="lazy" allowtransparency="true" allowfullscreen="true"></iframe><hr><h3 id="kokomi-js-用例"><a href="#kokomi-js-用例" class="headerlink" title="kokomi.js 用例"></a>kokomi.js 用例</h3><iframe src="https://codesandbox.io/embed/p4xxc9?view=preview&module=%2Ffrag.glsl&hidenavigation=1"     style="width:100%; height: 500px; border:0; border-radius: 4px; overflow:hidden;"     title="GL 效果"     allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"     sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"   ></iframe><hr><h3 id="跑马灯效果"><a href="#跑马灯效果" class="headerlink" title="跑马灯效果"></a>跑马灯效果</h3><ul><li>也叫做 <code>Marquee</code></li></ul><iframe width="100%" height="400px" src="//jsfiddle.net/HDL52/s8r6qtmg/153/embedded/result/dark/" frameborder="0" loading="lazy" allowtransparency="true" allowfullscreen="true"></iframe><iframe src="https://codesandbox.io/embed/kny9r5?view=preview&module=%2Fsrc%2FApp.js&hidenavigation=1"     style="width:100%; height: 400px; border:0; border-radius: 4px; overflow:hidden;"     title="focused-diffie"     allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"     sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"   ></iframe><iframe width="100%" height="400px" src="//jsfiddle.net/HDL52/zfvc9uqd/9/embedded/result/dark/" frameborder="0" loading="lazy" allowtransparency="true" allowfullscreen="true"></iframe><hr><h3 id="文字-Hover-翻转"><a href="#文字-Hover-翻转" class="headerlink" title="文字 Hover 翻转"></a>文字 Hover 翻转</h3><iframe src="https://codesandbox.io/embed/xhs6ws?view=preview&module=%2Fsrc%2FApp.js&hidenavigation=1"     style="width:100%; height: 500px; border:0; border-radius: 4px; overflow:hidden;"     title="翻转"     allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"     sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"   ></iframe><hr><h3 id="手电筒效果"><a href="#手电筒效果" class="headerlink" title="手电筒效果"></a>手电筒效果</h3><iframe width="100%" height="400px" src="//jsfiddle.net/HDL52/y5vo3kgp/57/embedded/result/dark/" allowfullscreen="allowfullscreen" allowpaymentrequest frameborder="0"></iframe><hr><h3 id="SVG-滤波器"><a href="#SVG-滤波器" class="headerlink" title="SVG 滤波器"></a>SVG 滤波器</h3><iframe width="100%" height="400px" src="//jsfiddle.net/HDL52/f4um57ns/73/embedded/result/dark/" allowfullscreen="allowfullscreen" allowpaymentrequest frameborder="0"></iframe><iframe width="100%" height="400px" src="//jsfiddle.net/HDL52/yfon0cp4/27/embedded/result/dark/" frameborder="0" loading="lazy" allowtransparency="true" allowfullscreen="true"></iframe><iframe width="100%" height="400px" src="//jsfiddle.net/HDL52/quyLpxzm/88/embedded/result/dark/" frameborder="0" loading="lazy" allowtransparency="true" allowfullscreen="true"></iframe><hr><h3 id="我的名字"><a href="#我的名字" class="headerlink" title="我的名字"></a>我的名字</h3><iframe width="100%" height="400px" src="//jsfiddle.net/HDL52/rdnx8m71/19/embedded/result/dark/" frameborder="0" loading="lazy" allowtransparency="true" allowfullscreen="true"></iframe><iframe width="100%" height="400px" src="//jsfiddle.net/HDL52/xmbL8eka/13/embedded/result/dark/" frameborder="0" loading="lazy" allowtransparency="true" allowfullscreen="true"></iframe><iframe width="100%" height="400px" src="//jsfiddle.net/HDL52/tfqcp70b/30/embedded/result/dark/" frameborder="0" loading="lazy" allowtransparency="true" allowfullscreen="true"></iframe><hr><h3 id="横向滑动"><a href="#横向滑动" class="headerlink" title="横向滑动"></a>横向滑动</h3><iframe src="https://codesandbox.io/embed/pm4cpy?view=preview"     style="width:100%; height: 500px; border:0; border-radius: 4px; overflow:hidden;"     title="H-Scroll"     allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"     sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"   ></iframe><ul><li>下面这个是纯原生实现</li></ul><iframe src="https://codesandbox.io/embed/98mlvg?view=preview&module=%2Fsrc%2Fscrollable.css&hidenavigation=1"     style="width:100%; height: 500px; border:0; border-radius: 4px; overflow:hidden;"     title="H-Scroll-2"     allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"     sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"   ></iframe><hr><h3 id="签名特效"><a href="#签名特效" class="headerlink" title="签名特效"></a>签名特效</h3><iframe width="100%" height="400px" src="//jsfiddle.net/HDL52/5bhxLd16/embedded/result/dark/" frameborder="0" loading="lazy" allowtransparency="true" allowfullscreen="true"></iframe><iframe width="100%" height="400px" src="//jsfiddle.net/HDL52/aozhc9k2/124/embedded/result/dark/" frameborder="0" loading="lazy" allowtransparency="true" allowfullscreen="true"></iframe><hr><h3 id="3D-菜单"><a href="#3D-菜单" class="headerlink" title="3D 菜单"></a>3D 菜单</h3><iframe width="100%" height="400px" src="//jsfiddle.net/HDL52/14am63yv/101/embedded/result/dark/" frameborder="0" loading="lazy" allowtransparency="true" allowfullscreen="true"></iframe><hr><h3 id="电影文字特效"><a href="#电影文字特效" class="headerlink" title="电影文字特效"></a>电影文字特效</h3><iframe width="100%" height="400px" src="//jsfiddle.net/HDL52/8m21o0bd/13/embedded/result/dark/" frameborder="0" loading="lazy" allowtransparency="true" allowfullscreen="true"></iframe><hr><h3 id="暖色背景"><a href="#暖色背景" class="headerlink" title="暖色背景"></a>暖色背景</h3><iframe width="100%" height="400px" src="//jsfiddle.net/HDL52/2p09ko8w/57/embedded/result/dark/" frameborder="0" loading="lazy" allowtransparency="true" allowfullscreen="true"></iframe><hr><h3 id="图片通过滑动展出"><a href="#图片通过滑动展出" class="headerlink" title="图片通过滑动展出"></a>图片通过滑动展出</h3><iframe width="100%" height="400px" src="//jsfiddle.net/HDL52/uf42ortp/17/embedded/result/dark/" frameborder="0" loading="lazy" allowtransparency="true" allowfullscreen="true"></iframe><hr><h3 id="原生划入动效"><a href="#原生划入动效" class="headerlink" title="原生划入动效"></a>原生划入动效</h3><iframe width="100%" height="400px" src="//jsfiddle.net/HDL52/w9L0cq3g/177/embedded/result/dark/" frameborder="0" loading="lazy" allowtransparency="true" allowfullscreen="true"></iframe><hr><h3 id="Rellax-js-用例"><a href="#Rellax-js-用例" class="headerlink" title="Rellax.js 用例"></a>Rellax.js 用例</h3><iframe width="100%" height="400px" src="//jsfiddle.net/HDL52/yabeLhsc/8/embedded/result/dark/" frameborder="0" loading="lazy" allowtransparency="true" allowfullscreen="true"></iframe><hr><h3 id="文字展示视频"><a href="#文字展示视频" class="headerlink" title="文字展示视频"></a>文字展示视频</h3><iframe width="100%" height="400px" src="//jsfiddle.net/HDL52/2zvc8La6/18/embedded/result/dark/" frameborder="0" loading="lazy" allowtransparency="true" allowfullscreen="true"></iframe><hr><h3 id="故障特效"><a href="#故障特效" class="headerlink" title="故障特效"></a>故障特效</h3><iframe width="100%" height="400px" src="//jsfiddle.net/HDL52/mavrgsu6/46/embedded/result/dark/" frameborder="0" loading="lazy" allowtransparency="true" allowfullscreen="true"></iframe><hr><h3 id="菜单特效"><a href="#菜单特效" class="headerlink" title="菜单特效"></a>菜单特效</h3><iframe width="100%" height="400px" src="//jsfiddle.net/HDL52/d5romxb3/34/embedded/result/dark/" frameborder="0" loading="lazy" allowtransparency="true" allowfullscreen="true"></iframe><hr><h3 id="原生导航栏"><a href="#原生导航栏" class="headerlink" title="原生导航栏"></a>原生导航栏</h3><iframe width="100%" height="400px" src="//jsfiddle.net/HDL52/7jxotqu1/5/embedded/result/dark/" frameborder="0" loading="lazy" allowtransparency="true" allowfullscreen="true"></iframe><hr><h3 id="创意列表交互"><a href="#创意列表交互" class="headerlink" title="创意列表交互"></a>创意列表交互</h3><iframe width="100%" height="400px" src="//jsfiddle.net/HDL52/o6n78gak/24/embedded/result/dark/" frameborder="0" loading="lazy" allowtransparency="true" allowfullscreen="true"></iframe><iframe width="100%" height="400px" src="//jsfiddle.net/HDL52/dzbf2wva/64/embedded/result/dark/" frameborder="0" loading="lazy" allowtransparency="true" allowfullscreen="true"></iframe><hr><h3 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h3><blockquote><p>请勿随意修改，谢谢</p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C# 关键字解析</title>
      <link href="/posts/cd5cb147.html"/>
      <url>/posts/cd5cb147.html</url>
      
        <content type="html"><![CDATA[<h2 id="C-中的关键字解析"><a href="#C-中的关键字解析" class="headerlink" title="C# 中的关键字解析"></a>C# 中的关键字解析</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><ul><li><p>结合<a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/">微软文档</a>，对<code>C#</code>中的关键字进行解析。</p></li><li><p>文章中，派生类默认为子类，基类默认为父类。</p></li><li><p>部分常见关键字省略: <a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/builtin-types/bool">bool</a>，<a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/statements/jump-statements#the-break-statement">break</a>，<a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/statements/selection-statements#the-switch-statement">case</a>，<a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/builtin-types/char">char</a>，<a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/statements/jump-statements#the-continue-statement">continue</a>，<a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/default">default</a>，<a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/statements/iteration-statements#the-do-statement">do</a>，<a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/builtin-types/floating-point-numeric-types">double</a>，<a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/statements/selection-statements#the-if-statement">else</a>，<a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/builtin-types/bool">false</a>，<a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/builtin-types/floating-point-numeric-types">float</a>，<a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/statements/iteration-statements#the-for-statement">for</a>，<a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/statements/selection-statements#the-if-statement">if</a>，<a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/builtin-types/integral-numeric-types">int</a>，<a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/builtin-types/integral-numeric-types">long</a>，<a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/new-operator">new</a>，<a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/public">public</a>，<a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/statements/jump-statements#the-return-statement">return</a>，<a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/sizeof">sizeof</a>，<a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/builtin-types/reference-types">string</a>，<a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/builtin-types/bool">true</a>，<a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/statements/exception-handling-statements">try</a>，<a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/type-testing-and-cast#typeof-operator">typeof</a>，<a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/builtin-types/void">void</a>，<a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/statements/iteration-statements#the-while-statement">while</a></p></li><li><p>关键字省略 (感觉可能用不到, 这里指的是日常哈): <a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/statements/checked-and-unchecked">checked</a>，<a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/extern">extern</a>，<a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/statements/fixed">fixed</a>，<a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/statements/jump-statements#the-goto-statement">goto</a>，<a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/user-defined-conversion-operators">implicit</a>，<a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/in">in</a>，<a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/statements/lock">lock</a>，<a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/programming-guide/types/boxing-and-unboxing">object</a>，<a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/operator-overloading">operator</a>，<a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/builtin-types/integral-numeric-types">sbyte</a>，<a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/builtin-types/integral-numeric-types">short</a>，<a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/stackalloc">stackalloc</a>，<a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/builtin-types/integral-numeric-types">uint</a>，<a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/builtin-types/integral-numeric-types">ulong</a>，<a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/statements/checked-and-unchecked">unchecked</a>，<a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/unsafe">unsafe</a>，<a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/builtin-types/integral-numeric-types">ushort</a>，<a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/volatile">volatile</a></p></li></ul><hr><h3 id="1-abstract-关键字"><a href="#1-abstract-关键字" class="headerlink" title="1. abstract 关键字"></a>1. abstract 关键字</h3><p>在<code>C#</code>中，关键字<a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/abstract"><code>abstract</code></a>用于<ins>声明抽象类或类中的抽象成员</ins>。<br><br></p><p>抽象类特点:</p><ol><li>抽象类不能实例化 (不能使用<code>new</code>关键字)。</li><li>抽象类可能包含抽象成员（方法、属性）和非抽象成员的实现。</li><li>只有抽象类中才允许抽象方法声明。</li><li>抽象类通常作为基类被子类继承，子类必须使用<code>override</code>实现抽象类中声明的抽象成员。</li></ol><p>抽象方法特点:</p><ol><li>凡是包含抽象方法的类都是抽象类。</li><li>抽象方法声明不提供实际的实现，因此没有方法主体。（抽象属性同理）</li><li>在抽象方法声明中不能使用<code>static</code>或<code>virtual</code>关键字。<ul><li>抽象方法没有具体实现，所以不能使用<code>static</code>关键字来声明为静态方法。</li><li>抽象方法是隐式的虚拟方法，所以不需要<code>virtual</code>关键字。</li></ul></li></ol><p>举个例子:</p><ul><li>枪（抽象基类）是可以 <code>Shoot</code> 和 <code>Reload</code>（抽象方法）。</li><li>比如<code>AK47</code>和<code>M4</code> (非抽象类子类)，它们拥有 <code>Shoot</code> 和 <code>Reload</code> 的功能。</li><li>但具体是怎么 <code>Shoot</code> 和 <code>Reload</code>，<code>AK47</code>和<code>M4</code>是不一样的（具体实现）。</li></ul><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 抽象类：Firearms</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Firearms</span></span><br><span class="line"> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">Shoot</span>()</span>; <span class="comment">// 抽象方法</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">Reload</span>()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">Init</span>()</span> &#123;...&#125; <span class="comment">// 非抽象方法</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="built_in">string</span> FireRate &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; <span class="comment">// 抽象属性</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类：AK47</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">AK47</span> : <span class="title">Firearms</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> fireRate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Shoot</span>()</span> &#123;...&#125; <span class="comment">// 具体实现</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Reload</span>()</span> &#123;...&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">override</span> <span class="built_in">string</span> FireRate</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> fireRate; &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123; fireRate = <span class="keyword">value</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么要用抽象类，而不是使用一般类<code>class</code>或者接口<code>interface</code>？</p><ol><li>共享代码：<ins>抽象类可以定义一组相关类的通用行为和属性，并提供默认的实现。通过继承抽象类，子类可以继承和重用抽象类中的代码</ins>，减少代码的重复编写。这样可以提高代码的可维护性和扩展性。(这里指的是在 <code>abstract class</code> 里声明的非抽象方法)</li><li>代码扩展性：抽象类可以包含抽象方法，这些方法在抽象类中没有具体的实现。通过继承抽象类并实现这些抽象方法，子类可以在具体的业务逻辑中实现自己的代码。这种方式使得代码具有扩展性，可以适应未来需求的变化。</li><li>部分实现：抽象类既可以包含抽象方法，也可以包含具体的实现。这使得抽象类可以提供一些默认的行为，同时也给子类提供了一定的灵活性。子类可以选择性地覆盖抽象类中的方法，或者直接使用抽象类中的实现。</li><li>（待补充）</li></ol><blockquote><p>注意, 从 <code>C# 8.0</code> 开始 <code>interface</code> 就可以在接口里提供默认的实现</p></blockquote><hr><h3 id="2-as-关键字"><a href="#2-as-关键字" class="headerlink" title="2. as 关键字"></a>2. as 关键字</h3><p>在<code>C#</code>中，关键字<a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/type-testing-and-cast#as-operator"><code>as</code></a>用于类型转换。</p><ul><li>在实际应用中，通常会与<code>null</code>检查一起使用<code>as</code>关键字。这是因为，如果转换不成功，<code>as</code>会返回<code>null</code>，而不是抛出异常。这使得<code>as</code>关键字在面对类型转换失败时的行为更加温和。</li></ul><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Animal</span> &#123; ... &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Dog</span> : <span class="title">Animal</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">Animal animal = <span class="keyword">new</span> Dog();</span><br><span class="line">Dog dog = animal <span class="keyword">as</span> Dog;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (dog != <span class="literal">null</span>)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Successful&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Failed&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>as</code>关键字尝试将<code>animal</code>转换为<code>Dog</code>类型。由于<code>animal</code>对象实际上是一个<code>Dog</code>类型的对象，所以转换成功。如果<code>animal</code>对象是<code>Animal</code>类型的对象，则上面代码会转换失败。</p><hr><h3 id="3-base-关键字"><a href="#3-base-关键字" class="headerlink" title="3. base 关键字"></a>3. base 关键字</h3><p>在<code>C#</code>中，<code>base</code>关键字用于<ins>在子类中引用基类的成员或调用基类的构造函数</ins>。</p><ul><li><code>base</code>关键字只能用于子类，而不是基类中。</li><li>如果基类成员是私有的，即使使用<code>base</code>关键字也无法访问。</li><li>在静态方法中使用 <code>base</code> 关键字将产生错误。</li><li>如果基类中有多个构造函数重载，子类在使用<code>base</code>关键字调用父类构造函数时，需要选择要调用的具体构造函数，并且提供与所选基类构造函数匹配的参数列表。</li></ul><p>下面是<code>base</code>关键字的几种常见用法<br><br></p><p><strong>(1) 调用基类的构造函数</strong></p><p>在派生类的构造函数中，可以使用<code>base</code>关键字调用基类的构造函数。<br><br></p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BaseClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 基类的构造函数 1</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BaseClass</span>(<span class="params"><span class="built_in">int</span> x</span>)</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 基类的构造函数 2</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BaseClass</span>(<span class="params"><span class="built_in">int</span> x, <span class="built_in">int</span> y</span>)</span> &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DerivedClass</span> : <span class="title">BaseClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 派生类的构造函数</span></span><br><span class="line">    <span class="comment">// 执行其他派生类的构造逻辑</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DerivedClass</span>(<span class="params"><span class="built_in">int</span> x</span>) : <span class="title">base</span>(<span class="params">x</span>)</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DerivedClass</span>(<span class="params"><span class="built_in">int</span> x, <span class="built_in">int</span> y</span>) : <span class="title">base</span>(<span class="params">x, y</span>)</span> &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x = <span class="keyword">new</span> DerivedClass(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">var</span> y = <span class="keyword">new</span> DerivedClass(<span class="number">1</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>上面代码中，<code>DerivedClass</code>继承自<code>BaseClass</code>。在<code>DerivedClass</code>的构造函数中，使用<code>base(x)</code>调用了基类<code>BaseClass</code>的构造函数，并传递参数<code>x</code>。<br><br></p><p><strong>（2）引用基类的成员</strong></p><p>当<ins>派生类中定义了一个与基类相同名称的成员变量或方法</ins>时，可以使用<code>base</code>关键字来访问它。<br><br></p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BaseClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 基类的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SomeMethod</span>()</span> &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DerivedClass</span> : <span class="title">BaseClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 调用基类的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SomeMethod</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">base</span>.SomeMethod();</span><br><span class="line">        <span class="comment">// ... 其他逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>DerivedClass</code>继承自<code>BaseClass</code>。在<code>DerivedClass</code>中的<code>SomeMethod</code>方法中，使用<code>base.SomeMethod()</code>调用了基类<code>BaseClass</code>的方法。<br><br></p><p>为什么要使用<code>base</code>去调用基类的构造函数？</p><ol><li>继承基类的行为和状态: 通过调用基类的构造函数，子类可以继承基类的行为和状态。基类可能包含一些重要的初始化逻辑，以确保它的成员和属性处于正确的状态。</li><li>提供基类所需的初始化参数: 如果基类的构造函数需要接收参数来进行初始化，派生类可以通过调用基类构造函数并传递适当的参数，来提供必要的信息。</li><li>避免冗余代码: 如果基类的构造函数已经包含了一些通用的、所有派生类都需要的初始化代码，那么在派生类中通过使用<code>base</code>关键字调用基类构造函数，可以避免重复编写这些初始化代码。</li><li>（待补充）</li></ol><hr><h3 id="4-byte-关键字"><a href="#4-byte-关键字" class="headerlink" title="4. byte 关键字"></a>4. byte 关键字</h3><p>在<code>C#</code>中，<code>byte</code>关键字用于声明一个<code>8</code>位无符号（<code>unsigned</code>）整数类型的变量。<br><br></p><p><code>byte</code>关键字在<code>C#</code>中具有多种用途和应用场景</p><ul><li>存储和处理二进制数据: <code>byte</code>类型是一个<code>8</code>位无符号整数，范围从<code>0</code>到<code>255</code>。因此，它非常适合用于存储和处理二进制数据，如图像、音频、视频、文件等。</li><li>网络编程: 在网络编程中，常常需要使用<code>byte</code>类型来读取和写入数据流、处理网络字节序等。</li><li>数据序列化和反序列化: 序列化是将对象转换为字节序列的过程，而反序列化则是将字节序列转换回对象。在数据序列化和反序列化过程中，<code>byte</code>类型通常用于表示和操作字节数据。</li><li>…</li></ul><p>举个例子<br><br></p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 读取图像文件的字节数据</span></span><br><span class="line"><span class="built_in">byte</span>[] imageData = File.ReadAllBytes(<span class="string">&quot;image.jpg&quot;</span>);</span><br><span class="line"><span class="comment">// 对数据进行压缩，返回压缩后的字节数据</span></span><br><span class="line"><span class="built_in">byte</span>[] compressedData = CompressData(originalData);</span><br></pre></td></tr></table></figure><hr><h3 id="5-异常处理关键字"><a href="#5-异常处理关键字" class="headerlink" title="5. 异常处理关键字"></a>5. 异常处理关键字</h3><p>在<code>C#</code>中，<code>try</code>关键字用于定义一个<code>try</code>块，表示其中可能会出现异常。</p><ul><li><code>try</code>块后面通常跟随一个或多个<code>catch</code>块，用于处理可能抛出的特定异常。最后还可以选择性地包含一个<code>finally</code>块，它包含的代码无论是否抛出异常都会被执行。</li></ul><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.IO;</span><br><span class="line"></span><br><span class="line">StreamReader reader = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    reader = <span class="keyword">new</span> StreamReader(<span class="string">&quot;nonexistent_file.txt&quot;</span>);</span><br><span class="line">    Console.WriteLine(reader.ReadToEnd());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (FileNotFoundException ex)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 处理文件找不到的异常</span></span><br><span class="line">    Console.WriteLine(<span class="string">&quot;File not found: &quot;</span> + ex.FileName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Exception ex)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 处理其他类型的异常</span></span><br><span class="line">    Console.WriteLine(<span class="string">&quot;An error occurred: &quot;</span> + ex.Message);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 确保关闭StreamReader对象，释放系统资源</span></span><br><span class="line">    <span class="keyword">if</span> (reader != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        reader.Close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，如果<code>try</code>块中的代码引发了异常，程序会立即跳转到<code>catch</code>块，寻找与异常类型匹配的<code>catch</code>块，并执行相应的代码块。每个<code>catch</code>块可以捕获并处理特定类型的异常。<br><br></p><p><strong>处理异步函数的异常</strong><br>异步函数通常返回一个<code>Task</code>或<code>Task&lt;T&gt;</code>对象。可以在<code>try</code>块中<code>await</code>这个任务，并在<code>catch</code>块中处理可能的异常。<br><br></p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 有可能抛出异常的异步操作</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">SomeAsyncOperation</span>()</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">HandleAsyncOperation</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">await</span> SomeAsyncOperation();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Exception ex)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;An exception occurred: <span class="subst">&#123;ex.Message&#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外，不是所有的异常都应该被捕获。在大多数情况下，只应该捕获知道如何处理的异常。对于不知道如何处理的异常，最好让它们传播出去，这样调用者或者全局异常处理器可以捕获并处理它们。</p><p>（这里暂时省略处理迭代器方法中的异常，待补充）</p><hr><h3 id="6-class-关键字"><a href="#6-class-关键字" class="headerlink" title="6. class 关键字"></a>6. class 关键字</h3><p>在<code>C#</code>中，<a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/class"><code>class</code></a>关键字用于定义一个类。</p><ul><li>类是一种引用类型，它定义了一组属性（字段、常量和事件）、方法和索引器的组合。类可以直接实例化，也可以作为基类继承。</li></ul><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 类的成员变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> myInt;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 类的构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyClass</span>(<span class="params"><span class="built_in">int</span> <span class="keyword">value</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        myInt = <span class="keyword">value</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 类的成员方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PrintValue</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;MyInt = &quot;</span> + myInt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><ins><code>C#</code> 中仅允许单一继承，即一个类仅能从一个基类继承实现。但是，一个类可拥有多个接口</ins> (重要)。<br><br></p><table><thead><tr><th align="left">继承</th><th align="left">示例</th></tr></thead><tbody><tr><td align="left">无</td><td align="left">class ClassA { }</td></tr><tr><td align="left">单一</td><td align="left">class DerivedClass : BaseClass { }</td></tr><tr><td align="left">无，实现两个接口</td><td align="left">class ImplClass : IFace1, IFace2 { }</td></tr><tr><td align="left">单一，实现一个接口</td><td align="left">class ImplDerivedClass : BaseClass, IFace1 { }</td></tr></tbody></table><p>下面是一些类的使用方法</p><ul><li><strong>访问修饰符</strong>: 类的访问修饰符决定了它在代码中的可见性。默认情况下，类是<code>internal</code>的，意味着它只在同一程序集中可见。类的成员默认是<code>private</code>的，只能在类的内部访问。</li></ul><p>（1）静态类</p><p>使用<code>static</code>关键字可以定义静态类和静态成员。静态类不能实例化，不能被继承，且只能包含静态成员。静态成员只有一份，属于类本身，而不属于类的任何实例。<br><br></p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">MathUtils</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">Add</span>(<span class="params"><span class="built_in">int</span> a, <span class="built_in">int</span> b</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">double</span> <span class="title">SquareRoot</span>(<span class="params"><span class="built_in">double</span> <span class="keyword">value</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> Math.Sqrt(<span class="keyword">value</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MathUtils.Add(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">MathUtils.SquareRoot(<span class="number">4.0</span>)</span><br></pre></td></tr></table></figure><p><strong>构造函数</strong>: 类可以有一个或多个构造函数，用于创建类的实例。构造函数的名称必须与类名相同，且不返回任何值。<br><br></p><p><strong>静态构造函数</strong>: <ins>用于初始化静态成员或执行静态初始化代码</ins>。它没有参数列表，也不能直接调用。<ins>静态构造函数在类的第一个实例或静态成员被访问之前自动调用，并且只执行一次</ins>。</p><ul><li>访问静态成员时调用</li><li>访问静态成员时</li></ul><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Config</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">string</span> AppName;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">readonly</span> <span class="built_in">string</span> Version;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 静态构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="title">Config</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;🔧 静态构造函数执行&quot;</span>);</span><br><span class="line">        AppName = <span class="string">&quot;我的应用&quot;</span>;</span><br><span class="line">        Version = <span class="string">&quot;1.0.0&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Config</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;📦 实例构造函数执行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 场景1：访问静态成员</span></span><br><span class="line">Console.WriteLine(Config.AppName);</span><br><span class="line"><span class="comment">// 输出:</span></span><br><span class="line"><span class="comment">// 🔧 静态构造函数执行</span></span><br><span class="line"><span class="comment">// 我的应用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 场景2：创建实例</span></span><br><span class="line">Config config = <span class="keyword">new</span> Config();</span><br><span class="line"><span class="comment">// 输出:</span></span><br><span class="line"><span class="comment">// 🔧 静态构造函数执行（只执行一次）</span></span><br><span class="line"><span class="comment">// 📦 实例构造函数执行</span></span><br></pre></td></tr></table></figure><p>（2）内部类</p><p>内部类是定义在另一个类内部的类。内部类拥有访问外部类成员的特权，可以用于实现更复杂的逻辑和封装。（注意，虽然内部类可以访问其外部类的所有成员，但反过来不成立。）<br><br></p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Outer</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> secretNumber = <span class="number">42</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 内部类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Inner</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> Outer outer;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Inner</span>(<span class="params">Outer outer</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>.outer = outer;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ShowSecret</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// ✅ 可以访问外部类的私有成员</span></span><br><span class="line">            Console.WriteLine(<span class="string">$&quot;秘密数字是: <span class="subst">&#123;outer.secretNumber&#125;</span>&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Inner <span class="title">CreateInner</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Inner(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line">Outer outer = <span class="keyword">new</span> Outer();</span><br><span class="line">Outer.Inner inner = outer.CreateInner();</span><br><span class="line">inner.ShowSecret();  <span class="comment">// 输出: 秘密数字是: 42</span></span><br></pre></td></tr></table></figure><p>（3）泛型类</p><p>泛型类具有在实例化时可以指定参数类型的特性，从而提供了更灵活和类型安全的代码重用方式。<br><br></p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Box</span>&lt;<span class="title">T</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> T item;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Box</span>(<span class="params">T item</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.item = item;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">GetItem</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> item;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ShowType</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;类型: <span class="subst">&#123;<span class="keyword">typeof</span>(T).Name&#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用不同类型</span></span><br><span class="line">Box&lt;<span class="built_in">int</span>&gt; intBox = <span class="keyword">new</span> Box&lt;<span class="built_in">int</span>&gt;(<span class="number">123</span>);</span><br><span class="line">Console.WriteLine(intBox.GetItem());  <span class="comment">// 输出: 123</span></span><br><span class="line">intBox.ShowType();                    <span class="comment">// 输出: 类型: Int32</span></span><br><span class="line"></span><br><span class="line">Box&lt;<span class="built_in">string</span>&gt; strBox = <span class="keyword">new</span> Box&lt;<span class="built_in">string</span>&gt;(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">Console.WriteLine(strBox.GetItem());  <span class="comment">// 输出: Hello</span></span><br><span class="line">strBox.ShowType();                    <span class="comment">// 输出: 类型: String</span></span><br></pre></td></tr></table></figure><p><code>C#</code>还有许多其他不同的类，比如之前介绍的抽象类，还有接口，密封类，枚举类，部分类，特性类，委托类等等。（待补充）<br><br></p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 抽象类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Shape</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="built_in">double</span> <span class="title">GetArea</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 密封类（不能被继承）</span></span><br><span class="line"><span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">Circle</span> : <span class="title">Shape</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">double</span> Radius &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">double</span> <span class="title">GetArea</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> Math.PI * Radius * Radius;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 部分类（可在多个文件中定义）</span></span><br><span class="line"><span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">User</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">User</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Age &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="7-const-关键字"><a href="#7-const-关键字" class="headerlink" title="7. const 关键字"></a>7. const 关键字</h3><p>在<code>C#</code>中，<code>const</code>关键字来声明某个常量字段或局部变量。常量字段和常量局部变量不是变量并且不能修改。<br><br></p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">int</span> X = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">const</span> <span class="built_in">double</span> GravitationalConstant = <span class="number">6.673e-11</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">const</span> <span class="built_in">string</span> ProductName = <span class="string">&quot;Visual C#&quot;</span>;</span><br></pre></td></tr></table></figure><hr><h3 id="8-decimal-关键字"><a href="#8-decimal-关键字" class="headerlink" title="8. decimal 关键字"></a>8. decimal 关键字</h3><p>在<code>C#</code>中，当所需的精度由小数点右侧的位数决定时，<a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/builtin-types/floating-point-numeric-types"><code>decimal</code></a>关键字是合适的。</p><ul><li>它是一种数据类型，用于存储精确的十进制数值（支持小数点后<code>28</code>的精确度），适用于需要高精度计算的场景，例如财务和货币计算。</li></ul><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">decimal</span> myDecimal = <span class="number">3.14</span>m; <span class="comment">// 使用后缀 &quot;m&quot; 表示 decimal 类型</span></span><br><span class="line"><span class="built_in">float</span> myFloat = <span class="number">3.14f</span>; <span class="comment">// 使用后缀 &quot;f&quot; 表示 float 类型</span></span><br><span class="line"><span class="built_in">double</span> myDouble = <span class="number">3.14</span>; <span class="comment">// 默认为 double 类型</span></span><br></pre></td></tr></table></figure><p>注意，<code>decimal</code>类型虽然具有较高的精度和准确性，它的计算速度通常比其他浮点类型，比如 <code>float</code> 和 <code>double</code>，慢。</p><hr><h3 id="9-delegate-关键字"><a href="#9-delegate-关键字" class="headerlink" title="9. delegate 关键字"></a>9. delegate 关键字</h3><p>在<code>C#</code>中，<a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/programming-guide/delegates/"><code>delegate</code></a>关键字用于声明和使用委托。<br><br></p><p>它类似于一个装着方法的容器，可以将方法（实例方法，静态方法）作为对象进行传递，但<ins>前提是委托和对应传递方法的签名得是相同的，签名指的是他们的参数类型和返回值类型</ins>。（类似回调函数或者<code>Thunk</code>函数）<br><br></p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 委托的声明，指定了返回值类型为 int，接收两个 int 类型的参数。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="built_in">int</span> <span class="title">MyDelegate</span>(<span class="params"><span class="built_in">int</span> num1, <span class="built_in">int</span> num2</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Calculator</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 使用委托的一个方法，这里的 method 参数是一个 Operation 类型的委托</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">Calculate</span>(<span class="params"><span class="built_in">int</span> num1, <span class="built_in">int</span> num2, MyDelegate callback</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 在Calculate方法中调用委托</span></span><br><span class="line">        <span class="keyword">return</span> callback(num1, num2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 两个符合 Operation 委托签名的方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">Add</span>(<span class="params"><span class="built_in">int</span> num1, <span class="built_in">int</span> num2</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">Subtract</span>(<span class="params"><span class="built_in">int</span> num1, <span class="built_in">int</span> num2</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 - num2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Calculator calculator = <span class="keyword">new</span> Calculator();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用委托将 Add 方法作为参数传入</span></span><br><span class="line"><span class="built_in">int</span> result = calculator.Calculate(<span class="number">10</span>, <span class="number">5</span>, Add);</span><br><span class="line">Console.WriteLine(result);  <span class="comment">// 输出：15</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用委托将 Subtract 方法作为参数传入</span></span><br><span class="line">result = calculator.Calculate(<span class="number">10</span>, <span class="number">5</span>, Subtract);</span><br><span class="line">Console.WriteLine(result);  <span class="comment">// 输出：5</span></span><br></pre></td></tr></table></figure><p>注意，在<code>C#</code>中创建委托对象时，并不一定需要使用<code>new</code>关键字来实例化委托。</p><ul><li>使用<code>new</code>关键字和委托类型的构造函数创建委托对象</li></ul><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">MyDelegate myDelegate = <span class="keyword">new</span> MyDelegate(ShowMessage);</span><br></pre></td></tr></table></figure><p>在这种情况下，我们使用<code>new MyDelegate</code>语法创建了一个委托对象<code>myDelegate</code>，并将<code>ShowMessage</code>方法绑定到委托上。</p><ul><li>使用隐式方法组转换来创建委托对象</li></ul><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">MyDelegate myDelegate = ShowMessage;</span><br></pre></td></tr></table></figure><p>在这种情况下，我们直接将方法名<code>ShowMessage</code>赋值给委托对象<code>myDelegate</code>，编译器会自动进行隐式方法组转换，将方法转换为委托对象。</p><ul><li>使用匿名方法创建委托对象</li></ul><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">MyDelegate myDelegate = <span class="built_in">delegate</span>(<span class="built_in">string</span> message)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(message);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>匿名方法的语法是使用关键字<code>delegate</code>后跟一个参数列表和方法体。</p><ul><li>使用<code>Lambda</code>表达式创建委托对象</li></ul><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Lambda表达式的参数部分只使用了参数名&quot;message&quot;，而没有指定参数类型。</span></span><br><span class="line"><span class="comment">// 编译器会根据委托类型推断出参数类型。</span></span><br><span class="line">MyDelegate myDelegate = (message) =&gt; Console.WriteLine(message);</span><br></pre></td></tr></table></figure><p>在这种情况下，我们使用<code>Lambda</code>表达式定义了一个匿名方法，将其赋值给委托对象<code>myDelegate</code>。</p><ul><li><p>那什么情况下应该使用委托<code>delegate</code>？</p></li><li><p><strong>事件处理</strong>: 委托广泛用于事件处理模型中。通过定义委托类型和事件，可以将事件与特定的处理方法关联起来。当事件发生时，委托会调用绑定的方法，从而实现事件的处理和响应。</p></li></ul><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明一个委托</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">EventHandler</span>(<span class="params"><span class="built_in">string</span> message</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">EventPublisher</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 声明一个事件，使用之前定义的委托</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">event</span> EventHandler Event;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TriggerEvent</span>(<span class="params"><span class="built_in">string</span> message</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 触发事件</span></span><br><span class="line">        Event?.Invoke(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">EventSubscriber</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Subscribe</span>(<span class="params">EventPublisher publisher</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 订阅事件</span></span><br><span class="line">        publisher.Event += HandleEvent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">HandleEvent</span>(<span class="params"><span class="built_in">string</span> message</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 处理事件</span></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Event received: &quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建事件发布者和订阅者</span></span><br><span class="line">EventPublisher publisher = <span class="keyword">new</span> EventPublisher();</span><br><span class="line">EventSubscriber subscriber = <span class="keyword">new</span> EventSubscriber();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 订阅事件</span></span><br><span class="line">subscriber.Subscribe(publisher);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 触发事件</span></span><br><span class="line">publisher.TriggerEvent(<span class="string">&quot;Hello, World!&quot;</span>);</span><br></pre></td></tr></table></figure><p>（1）回调函数 </p><p>委托可用作回调函数的一种方式。当一个方法需要在完成后通知另一个方法时，可以将委托作为参数传递给该方法，并在适当的时候调用委托以执行回调操作。<br><br></p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">Callback</span>(<span class="params"><span class="built_in">string</span> result</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DataProcessor</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Process</span>(<span class="params">Callback callback</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 模拟处理数据</span></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;正在处理数据...&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 处理完成后调用回调</span></span><br><span class="line">        callback(<span class="string">&quot;处理完成！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line">DataProcessor processor = <span class="keyword">new</span> DataProcessor();</span><br><span class="line">processor.Process((result) =&gt; Console.WriteLine(<span class="string">$&quot;✅ <span class="subst">&#123;result&#125;</span>&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// 正在处理数据...</span></span><br><span class="line"><span class="comment">// ✅ 处理完成！</span></span><br></pre></td></tr></table></figure><p>（2）多播委托 (委托链)</p><p>委托还支持多播（<code>multicast</code>）的功能，即一个委托可以绑定多个方法。这使得可以将多个方法作为委托的调用列表，并按顺序依次调用它们。<br><br></p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">Notify</span>()</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SendEmail</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;📧 发送邮件&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SendSMS</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;📱 发送短信&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SendPush</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;🔔 发送推送&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建多播委托</span></span><br><span class="line">Notify notify = SendEmail;</span><br><span class="line">notify += SendSMS;   <span class="comment">// 添加方法</span></span><br><span class="line">notify += SendPush;  <span class="comment">// 再添加方法</span></span><br><span class="line"></span><br><span class="line">notify();  <span class="comment">// 一次调用，执行所有方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// 📧 发送邮件</span></span><br><span class="line"><span class="comment">// 📱 发送短信</span></span><br><span class="line"><span class="comment">// 🔔 发送推送</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除方法</span></span><br><span class="line">notify -= SendSMS;</span><br><span class="line">notify();  <span class="comment">// 只执行邮件和推送</span></span><br></pre></td></tr></table></figure><p>（3）泛型委托</p><p><code>C#</code>中的委托支持泛型，可以更好地支持类型安全性和代码重用。<br><br></p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> T <span class="title">Transform</span>&lt;<span class="title">T</span>&gt;(<span class="params">T <span class="keyword">value</span></span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">Square</span>(<span class="params"><span class="built_in">int</span> x</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">string</span> <span class="title">ToUpper</span>(<span class="params"><span class="built_in">string</span> s</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> s.ToUpper();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line">Transform&lt;<span class="built_in">int</span>&gt; squareFunc = Square;</span><br><span class="line">Console.WriteLine(squareFunc(<span class="number">5</span>));  <span class="comment">// 输出: 25</span></span><br><span class="line"></span><br><span class="line">Transform&lt;<span class="built_in">string</span>&gt; upperFunc = ToUpper;</span><br><span class="line">Console.WriteLine(upperFunc(<span class="string">&quot;hello&quot;</span>));  <span class="comment">// 输出: HELLO</span></span><br></pre></td></tr></table></figure><p>（4）事件处理</p><p><code>Button</code>类声明了一个<code>OnClick</code>事件，当调用<code>Click()</code>方法时触发该事件，所有通过<code>+=</code>订阅的方法会按顺序执行并收到 “按钮被点击了” 的消息<br><br></p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">EventHandler</span>(<span class="params"><span class="built_in">string</span> message</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Button</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">event</span> EventHandler OnClick;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Click</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        OnClick?.Invoke(<span class="string">&quot;按钮被点击了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line">Button btn = <span class="keyword">new</span> Button();</span><br><span class="line">btn.OnClick += (msg) =&gt; Console.WriteLine(<span class="string">$&quot;处理1: <span class="subst">&#123;msg&#125;</span>&quot;</span>);</span><br><span class="line">btn.OnClick += (msg) =&gt; Console.WriteLine(<span class="string">$&quot;处理2: <span class="subst">&#123;msg&#125;</span>&quot;</span>);</span><br><span class="line"></span><br><span class="line">btn.Click();</span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// 处理1: 按钮被点击了</span></span><br><span class="line"><span class="comment">// 处理2: 按钮被点击了</span></span><br></pre></td></tr></table></figure><p>（6）<code>LINQ</code> 和 <code>Lambda</code> 表达式</p><p>在<code>LINQ</code>中，委托用于定义查询操作。而<code>Lambda</code>表达式实质上是一种特殊的委托，以一种更简洁和强大的方式定义匿名函数。<br><br></p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"></span><br><span class="line">List&lt;<span class="built_in">int</span>&gt; numbers = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt; &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Func&lt;int, bool&gt; 是内置的委托类型</span></span><br><span class="line">Func&lt;<span class="built_in">int</span>, <span class="built_in">bool</span>&gt; isEven = x =&gt; x % <span class="number">2</span> == <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用委托过滤偶数</span></span><br><span class="line"><span class="keyword">var</span> evens = numbers.Where(isEven);</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span> (<span class="built_in">int</span> num <span class="keyword">in</span> evens)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(num);  <span class="comment">// 输出: 2, 4, 6, 8, 10</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者直接用 Lambda</span></span><br><span class="line"><span class="keyword">var</span> odds = numbers.Where(x =&gt; x % <span class="number">2</span> != <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>注意，在<code>C#</code>中，不一定非要使用<code>delegate</code>关键字来定义委托。其实，<code>Func&lt;T, TResult&gt;</code>、<code>Action&lt;T&gt;</code>等都是内置的委托类型，你可以直接使用它们，而无需使用<code>delegate</code>关键字。（<code>C#</code>中内置的委托类型）<br><br></p><p>（7）定制或扩展方法 </p><p>在<code>C#</code>中，可以利用委托去定制或扩展方法，改变其行为或增加新的功能。例如，可以使用委托来定制比较方法，从而对集合进行自定义排序。<br><br></p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">List&lt;<span class="built_in">int</span>&gt; numbers = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt; &#123; <span class="number">5</span>, <span class="number">10</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">6</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 降序排序</span></span><br><span class="line">Comparison&lt;<span class="built_in">int</span>&gt; <span class="keyword">descending</span> = (x, y) =&gt; y.CompareTo(x);</span><br><span class="line">numbers.Sort(<span class="keyword">descending</span>);</span><br><span class="line"></span><br><span class="line">Console.WriteLine(<span class="built_in">string</span>.Join(<span class="string">&quot;, &quot;</span>, numbers));</span><br><span class="line"><span class="comment">// 输出: 10, 8, 6, 5, 3</span></span><br></pre></td></tr></table></figure><ul><li>(8)（待补充）</li></ul><hr><h3 id="10-enum-关键字"><a href="#10-enum-关键字" class="headerlink" title="10. enum 关键字"></a>10. enum 关键字</h3><p>在 <code>C#</code> 中，<a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/builtin-types/enum"><code>enum</code></a> 关键字用于声明枚举类型。</p><ul><li>枚举是一种值类型，它表示一个固定的值集合。这些值被称为枚举成员，并且每一个都有一个关联的常量值。默认情况下，第一个枚举成员的值是<code>0</code>，后续的成员值依次递增<code>1</code>，但是可以显式地改变这个顺序。</li></ul><p>假设有一个枚举类型定义了一周的天数<br><br></p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">enum</span> DayOfWeek</span><br><span class="line">&#123;</span><br><span class="line">    Sunday = <span class="number">0</span>,</span><br><span class="line">    Monday = <span class="number">1</span>,</span><br><span class="line">    Tuesday = <span class="number">2</span>,</span><br><span class="line">    Wednesday = <span class="number">3</span>,</span><br><span class="line">    Thursday = <span class="number">4</span>,</span><br><span class="line">    Friday = <span class="number">5</span>,</span><br><span class="line">    Saturday = <span class="number">6</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以创建一个变量来存储当前的星期几<br><br></p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">DayOfWeek today = DayOfWeek.Monday;</span><br></pre></td></tr></table></figure><p>可以将枚举值转换为其他类型，例如整数或字符串<br><br></p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> dayNumber = (<span class="built_in">int</span>)DayOfWeek.Friday;  <span class="comment">// 5</span></span><br><span class="line"><span class="built_in">string</span> dayName = DayOfWeek.Friday.ToString();  <span class="comment">// &quot;Friday&quot;</span></span><br></pre></td></tr></table></figure><p>反过来，也可以将其他类型转换为枚举值<br><br></p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">DayOfWeek day = (DayOfWeek)<span class="number">5</span>;  <span class="comment">// DayOfWeek.Friday</span></span><br><span class="line">DayOfWeek day = Enum.Parse&lt;DayOfWeek&gt;(<span class="string">&quot;Friday&quot;</span>);  <span class="comment">// DayOfWeek.Friday</span></span><br><span class="line"></span><br><span class="line">DayOfWeek day;</span><br><span class="line"><span class="built_in">bool</span> success = Enum.TryParse&lt;DayOfWeek&gt;(<span class="string">&quot;Sunday&quot;</span>, <span class="keyword">out</span> day); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>如果枚举表示的是一组位标志，那么应该使用<code>[Flags]</code>属性，并为枚举成员指定<code>2</code>的幂次方值。这样就可以使用位运算符来组合、添加或移除枚举值。<br><br></p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">Flags</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">enum</span> AccessRights</span><br><span class="line">&#123;</span><br><span class="line">    None = <span class="number">0</span>,     <span class="comment">// 0000</span></span><br><span class="line">    Read = <span class="number">1</span>,     <span class="comment">// 0001</span></span><br><span class="line">    Write = <span class="number">2</span>,    <span class="comment">// 0010</span></span><br><span class="line">    Execute = <span class="number">4</span>,  <span class="comment">// 0100</span></span><br><span class="line">    FullControl = Read | Write | Execute <span class="comment">// 0111</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>AccessRights</code>枚举定义了一组访问权限，每个权限是二进制位的一个标志。这允许我们将不同的权限组合到一起，然后通过位运算检查特定的权限是否存在。<br><br></p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置读和写权限</span></span><br><span class="line">AccessRights rights = AccessRights.Read | AccessRights.Write;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查是否有写权限</span></span><br><span class="line"><span class="keyword">if</span> ((rights &amp; AccessRights.Write) == AccessRights.Write)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;有写权限&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;无写权限&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了位运算符的使用，也可以直接使用<code>HasFlag</code>方法来检查特定的权限是否存在。<br><br></p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">AccessRights rights = AccessRights.Read | AccessRights.Write;</span><br><span class="line"></span><br><span class="line">rights.HasFlag(AccessRights.Write) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><hr><h3 id="11-event-关键字"><a href="#11-event-关键字" class="headerlink" title="11. event 关键字"></a>11. event 关键字</h3><p>在<code>C#</code>中，<a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/event"><code>event</code></a>关键字用于声明一个事件。（<a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/programming-guide/events/how-to-publish-events-that-conform-to-net-framework-guidelines">如何发布符合 .NET 准则的事件</a>）</p><ul><li>事件是由对象在特殊情况下触发的一种机制，例如用户点击了一个按钮，或者某个操作已经完成。对象可以订阅这个事件，这样当事件发生时，就会调用订阅者定义的事件处理程序。</li></ul><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个委托</span></span><br><span class="line"><span class="comment">// 1️⃣ 发布者：外卖平台</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DeliveryService</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 声明事件（使用标准的 EventHandler）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">event</span> EventHandler OrderDelivered;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 送达外卖</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Deliver</span>(<span class="params"><span class="built_in">string</span> orderNumber</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;外卖 <span class="subst">&#123;orderNumber&#125;</span> 正在配送中...&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 触发事件：通知所有订阅者</span></span><br><span class="line">        OrderDelivered?.Invoke(<span class="keyword">this</span>, EventArgs.Empty);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2️⃣ 订阅者：顾客</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Customer</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> name;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Customer</span>(<span class="params"><span class="built_in">string</span> name</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 订阅事件</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Subscribe</span>(<span class="params">DeliveryService service</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        service.OrderDelivered += OnOrderDelivered;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 取消订阅</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Unsubscribe</span>(<span class="params">DeliveryService service</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        service.OrderDelivered -= OnOrderDelivered;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 事件处理方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnOrderDelivered</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;[<span class="subst">&#123;name&#125;</span>] 收到通知：外卖已送达！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3️⃣ 使用</span></span><br><span class="line">DeliveryService service = <span class="keyword">new</span> DeliveryService();</span><br><span class="line">Customer customer1 = <span class="keyword">new</span> Customer(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">Customer customer2 = <span class="keyword">new</span> Customer(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 订阅</span></span><br><span class="line">customer1.Subscribe(service);</span><br><span class="line">customer2.Subscribe(service);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 触发事件</span></span><br><span class="line">service.Deliver(<span class="string">&quot;20241026001&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// 外卖 20241026001 正在配送中...</span></span><br><span class="line"><span class="comment">// [张三] 收到通知：外卖已送达！</span></span><br><span class="line"><span class="comment">// [李四] 收到通知：外卖已送达！</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 取消订阅</span></span><br><span class="line">customer1.Unsubscribe(service);</span><br></pre></td></tr></table></figure><p>上面例子可以看出，事件帮助了事件发布者和订阅者之间的解耦。发布者并不需要知道谁订阅了它的事件，也不需要知道事件将如何被处理。这使得我们可以独立地修改发布者和订阅者的代码，而不需要担心它们之间的依赖关系。<br><br></p><p><code>event</code>关键字使用注意点<br><br></p><p><strong>(1) 避免内存泄漏</strong><br>如果一个对象订阅了另一个对象的事件，那么在不需要订阅事件时应当及时取消订阅，以避免发生内存泄漏。（只要事件发布者还在内存中，订阅者就不会被垃圾回收，即使订阅者已经不再使用）<br><br></p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Customer</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Subscribe</span>(<span class="params">DeliveryService service</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        service.OrderDelivered += OnOrderDelivered;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ⚠️ 不用时一定要取消订阅！</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Unsubscribe</span>(<span class="params">DeliveryService service</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        service.OrderDelivered -= OnOrderDelivered;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnOrderDelivered</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;收到通知&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确使用</span></span><br><span class="line">Customer customer = <span class="keyword">new</span> Customer();</span><br><span class="line">customer.Subscribe(service);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不需要时取消订阅，避免内存泄漏</span></span><br><span class="line">customer.Unsubscribe(service);</span><br></pre></td></tr></table></figure><p><strong>(2) 委托类型</strong><br><code>System.EventHandler</code> 和 <code>System.EventHandler&lt;T&gt;</code> 是标准的事件委托类型，推荐在事件定义中使用这些类型以提高代码的可读性和一致性。<br><br></p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ✅ 推荐：使用标准 EventHandler</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">event</span> EventHandler MyEvent;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ✅ 推荐：使用泛型 EventHandler&lt;T&gt;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">event</span> EventHandler&lt;MyEventArgs&gt; MyEventWithArgs;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ❌ 不推荐：自定义委托（除非有特殊需求）</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">MyEventHandler</span>(<span class="params"><span class="built_in">string</span> message</span>)</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">event</span> MyEventHandler MyEvent;</span><br></pre></td></tr></table></figure><p><strong>(3) 事件访问器</strong><br>事件访问器允许在事件被添加或移除时执行自定义的逻辑。这对于调试或管理订阅者列表非常有用。<br><br></p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Publisher</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> EventHandler myEvent;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">event</span> EventHandler MyEvent</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">add</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;➕ 新增订阅者&quot;</span>);</span><br><span class="line">            myEvent += <span class="keyword">value</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">remove</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;➖ 移除订阅者&quot;</span>);</span><br><span class="line">            myEvent -= <span class="keyword">value</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">RaiseEvent</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        myEvent?.Invoke(<span class="keyword">this</span>, EventArgs.Empty);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line">Publisher pub = <span class="keyword">new</span> Publisher();</span><br><span class="line">pub.MyEvent += (sender, e) =&gt; Console.WriteLine(<span class="string">&quot;收到事件&quot;</span>);</span><br><span class="line"><span class="comment">// 输出: ➕ 新增订阅者</span></span><br><span class="line"></span><br><span class="line">pub.MyEvent -= (sender, e) =&gt; Console.WriteLine(<span class="string">&quot;收到事件&quot;</span>);</span><br><span class="line"><span class="comment">// 输出: ➖ 移除订阅者</span></span><br></pre></td></tr></table></figure><hr><h3 id="12-explicit-关键字"><a href="#12-explicit-关键字" class="headerlink" title="12. explicit 关键字"></a>12. explicit 关键字</h3><p>在<code>C#</code>中，<a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/user-defined-conversion-operators"><code>explicit</code></a>关键字用于类型转换。</p><ul><li><p><code>explicit</code>关键字通常用在用户定义的类型转换操作中，允许从一种数据类型转换到另一种数据类型，例如从类到接口，或者从父类到子类等等。</p></li><li><p>在某些情况下，转换操作可能导致数据丢失或抛出异常。使用<code>explicit</code>关键字可以强制开发者明确地处理转换，从而减少在转换过程中出现错误的可能性。</p></li></ul><p>下面是一个<code>explicit</code>关键字的例子<br><br></p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Fahrenheit</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> Temperature &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 推荐用 lambda 表达式写</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">Celsius</span>(<span class="params">Fahrenheit f</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> ConvertToFahrenheit(f);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Celsius <span class="title">ConvertToFahrenheit</span>(<span class="params">Fahrenheit f</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">float</span> celsiusTemperature = (<span class="number">5.0f</span> / <span class="number">9.0f</span>) * (f.Temperature - <span class="number">32</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Celsius(celsiusTemperature);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Celsius</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> Temperature &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Celsius</span>(<span class="params"><span class="built_in">float</span> temp</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Temperature = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Fahrenheit f = <span class="keyword">new</span> Fahrenheit &#123; Temperature = <span class="number">100</span> &#125;;</span><br><span class="line">Celsius c = (Celsius)f;  <span class="comment">// 显式转换</span></span><br></pre></td></tr></table></figure><p>上面例子中，不能直接将<code>Fahrenheit</code>对象转换为<code>Celsius</code>，必须明确地进行转换。</p><hr><h3 id="13-foreach-关键字"><a href="#13-foreach-关键字" class="headerlink" title="13. foreach 关键字"></a>13. foreach 关键字</h3><p>在<code>C#</code>中，<code>foreach</code>关键字用于遍历集合（如数组，列表等）中的元素。</p><ul><li>它的工作原理是通过调用集合对象的<code>GetEnumerator</code>方法来获取<code>IEnumerator</code>或<code>IEnumerator&lt;T&gt;</code>对象，然后在每次迭代中调用<code>MoveNext</code>方法和<code>Current</code>属性。</li></ul><blockquote><p>注意，后面<code>IEnumerator</code>和<code>IEnumerator&lt;T&gt;</code>统称为枚举器</p></blockquote><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fibNumbers = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt; &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">13</span> &#125;;</span><br><span class="line"><span class="keyword">foreach</span> (<span class="built_in">int</span> element <span class="keyword">in</span> fibNumbers)</span><br><span class="line">&#123;</span><br><span class="line">    Console.Write(<span class="string">$&quot;<span class="subst">&#123;element&#125;</span> &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// 0 1 1 2 3 5 8 13</span></span><br></pre></td></tr></table></figure><p>下面是一些<code>foreach</code>关键字的使用方法<br><br></p><p><strong>(1) 实现枚举器接口的集合</strong><br>在<code>C#</code>中，许多内置集合类型都实现了枚举器接口，这使得它们可以使用<code>foreach</code>循环进行迭代。<br><br></p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Dictionary&lt;<span class="built_in">string</span>, <span class="built_in">int</span>&gt; dictionary = <span class="keyword">new</span> Dictionary&lt;<span class="built_in">string</span>, <span class="built_in">int</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    &#123; <span class="string">&quot;One&quot;</span>, <span class="number">1</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;Two&quot;</span>, <span class="number">2</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;Three&quot;</span>, <span class="number">3</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span> (KeyValuePair&lt;<span class="built_in">string</span>, <span class="built_in">int</span>&gt; item <span class="keyword">in</span> dictionary)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">$&quot;Key: <span class="subst">&#123;item.Key&#125;</span>, Value: <span class="subst">&#123;item.Value&#125;</span>&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>(2) 实现枚举器接口的自定义类</strong><br>如果想要自定义类能够被<code>foreach</code>循环遍历，需要实现枚举器接口。这个接口定义了一个方法，<code>GetEnumerator</code>，返回一个实现了枚举器接口的对象。<br><br></p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyCollection</span> : <span class="title">IEnumerable</span>&lt;<span class="title">int</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span>[] data = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IEnumerator&lt;<span class="built_in">int</span>&gt; <span class="title">GetEnumerator</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; data.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">return</span> data[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    IEnumerator IEnumerable.GetEnumerator()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> GetEnumerator();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用自定义集合</span></span><br><span class="line">MyCollection collection = <span class="keyword">new</span> MyCollection();</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span> (<span class="built_in">int</span> number <span class="keyword">in</span> collection)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(number);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>(3) 异步流的迭代</strong><br>异步流的迭代是<code>C# 8.0</code>新增的特性，这使得我们能够在处理异步操作时，写出更高效和更易于理解的代码。异步流的迭代通过<code>await foreach</code>关键字实现。它能够异步地迭代这样的序列，而不会阻塞主线程。<br><br></p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">async</span> IAsyncEnumerable&lt;<span class="built_in">int</span>&gt; <span class="title">GenerateSequence</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">await</span> Task.Delay(<span class="number">100</span>);  <span class="comment">// 模拟异步操作</span></span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">TestAsyncStream</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="keyword">foreach</span> (<span class="function"><span class="keyword">var</span> number <span class="keyword">in</span> <span class="title">GenerateSequence</span>())</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(number);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述示例中，<code>GenerateSequence</code>方法生成了一个异步序列。每个元素都是在等待一段时间后生成的，以模拟异步操作。<code>TestAsyncStream</code>方法使用<code>await foreach</code>语句来异步地迭代这个序列。每次迭代都会异步地等待下一个元素。</p><hr><h3 id="14-interface-关键字"><a href="#14-interface-关键字" class="headerlink" title="14. interface 关键字"></a>14. interface 关键字</h3><p>在 <code>C#</code> 中，接口<code>interface</code>是一种定义行为契约的类型。接口声明一组方法、属性、事件或索引器，但不提供其实现。类<code>class</code>或结构体<code>struct</code>可以实现一个或多个接口，并提供接口中定义的成员的具体实现。<br><br></p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IAnimal</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Speak</span>()</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Move</span>()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类或结构体实现接口时，必须提供接口中定义的所有成员的具体实现。<br><br></p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title">IPoint</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Property signatures:</span></span><br><span class="line">    <span class="built_in">int</span> X &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">int</span> Y &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">double</span> Distance &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Point</span> : <span class="title">IPoint</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Constructor:</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Point</span>(<span class="params"><span class="built_in">int</span> x, <span class="built_in">int</span> y</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        X = x;</span><br><span class="line">        Y = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Property implementation:</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> X &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Y &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Property implementation</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">double</span> Distance =&gt;</span><br><span class="line">       Math.Sqrt(X * X + Y * Y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">MainClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">PrintPoint</span>(<span class="params">IPoint p</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;x=&#123;0&#125;, y=&#123;1&#125;&quot;</span>, p.X, p.Y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        IPoint p = <span class="keyword">new</span> Point(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">        Console.Write(<span class="string">&quot;My Point: &quot;</span>);</span><br><span class="line">        PrintPoint(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Output: My Point: x=2, y=3</span></span><br></pre></td></tr></table></figure><p>接口可以从一个或多个其他接口继承。实现该接口的类必须实现所有继承的接口成员。<br><br></p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IDrawable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Draw</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IResizable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Resize</span>(<span class="params"><span class="built_in">double</span> factor</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Shape</span> : <span class="title">IDrawable</span>, <span class="title">IResizable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">double</span> Width &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">double</span> Height &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Shape</span>(<span class="params"><span class="built_in">double</span> width, <span class="built_in">double</span> height</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Width = width;</span><br><span class="line">        Height = height;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实现 IDrawable 接口的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Draw</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;Drawing a shape with width <span class="subst">&#123;Width&#125;</span> and height <span class="subst">&#123;Height&#125;</span>.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实现 IResizable 接口的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Resize</span>(<span class="params"><span class="built_in">double</span> factor</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Width *= factor;</span><br><span class="line">        Height *= factor;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;Resized shape to width <span class="subst">&#123;Width&#125;</span> and height <span class="subst">&#123;Height&#125;</span>.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>接口与抽象类的区别<ul><li>实现: 接口中不能包含任何实现(<code>C# 8.0</code> 的默认接口方法除外)，而抽象类可以包含实现。</li><li>多重继承: 一个类可以实现多个接口，但只能继承一个抽象类。</li><li>构造函数: 接口不能有构造函数，而抽象类可以。</li><li>成员类型: 接口中不能包含字段（成员变量），而抽象类可以。</li></ul></li></ul><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IShape</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 接口不能有构造函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Shape</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Shape</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 构造函数逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IShape</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 接口中不能包含字段</span></span><br><span class="line">    <span class="function"><span class="built_in">double</span> <span class="title">CalculateArea</span>(<span class="params"><span class="built_in">double</span> size</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Shape</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="built_in">double</span> area;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="built_in">double</span> <span class="title">CalculateArea</span>(<span class="params"><span class="built_in">double</span> size</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">double</span> <span class="title">GetArea</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> area;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="15-internal-关键字"><a href="#15-internal-关键字" class="headerlink" title="15. internal 关键字"></a>15. internal 关键字</h3><p>在<code>C#</code>中，<code>internal</code>关键字用于指定成员的可访问性。<code>internal</code>修饰符使成员在同一程序集<code>assembly</code>内可访问，但在程序集外不可访问。(这里的程序集不是指同一个文件, 也不是指<code>namespace</code>)</p><ul><li>程序集<code>Assembly</code>: 程序集是<code>.NET</code>中的基本部署单元，可以是一个<code>DLL</code>或<code>EXE</code>文件。一个程序集包含一个或多个命名空间和类型，包含了元数据和代码。程序集是<code>.NET</code>中的物理边界。</li></ul><p>类的<code>internal</code>可访问性</p><ul><li>在以下示例中，<code>MyClass</code>类被声明为<code>internal</code>，因此它只能在同一程序集内访问。</li></ul><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 文件1：MyClass.cs</span></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Display</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Hello from MyClass!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件2：Program.cs</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        MyClass myClass = <span class="keyword">new</span> MyClass();</span><br><span class="line">        myClass.Display();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的示例中，<code>MyClass</code>类和它的<code>Display</code>方法都可以在<code>Program</code>类中访问，因为它们在同一个程序集内。<br><br></p><p>（1）方法的<code>internal</code>可访问性<br>在以下示例中，<code>MyClass</code>类是<code>public</code>的，但其中的<code>InternalMethod</code>方法被声明为<code>internal</code>，因此它只能在同一程序集内访问。<br><br></p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 文件1：MyClass.cs</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">internal</span> <span class="keyword">void</span> <span class="title">InternalMethod</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Hello from InternalMethod!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件2：Program.cs</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        MyClass myClass = <span class="keyword">new</span> MyClass();</span><br><span class="line">        myClass.InternalMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的示例中，<code>MyClass</code>的<code>InternalMethod</code>方法可以在<code>Program</code>类中访问，因为它们在同一个程序集内。<br><br></p><p>（2）跨程序集访问<br>如果尝试从另一个程序集访问<code>internal</code>成员，会导致编译错误。例如，假设有两个项目: <code>ProjectA</code>和<code>ProjectB</code>。<code>ProjectA</code>定义了一个<code>internal</code>类，而<code>ProjectB</code>试图访问它。<br><br></p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ProjectA - 文件1：MyClass.cs</span></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Display</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Hello from MyClass!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ProjectB - 文件1：Program.cs</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        MyClass myClass = <span class="keyword">new</span> MyClass(); <span class="comment">// 编译错误：&#x27;MyClass&#x27; is inaccessible due to its protection level</span></span><br><span class="line">        myClass.Display();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个示例中，由于<code>MyClass</code>被声明为<code>internal</code>，所以它不能在<code>ProjectB</code>中访问，会导致编译错误。<br><br></p><p>选择<code>internal</code>而不选择<code>public</code>的原因</p><ul><li>封装实现细节: 当你希望封装类、方法或其他成员，只让它们在同一个程序集内使用，而不暴露给外部程序集时，可以使用<code>internal</code>修饰符。</li><li>控制<code>API</code>公开性: 在设计库或框架时，<code>internal</code>修饰符可以帮助控制哪些类型和成员应暴露给库的使用者，哪些应保持内部使用。</li></ul><hr><h3 id="16-is-关键字"><a href="#16-is-关键字" class="headerlink" title="16. is 关键字"></a>16. is 关键字</h3><p><code>is</code>关键字在<code>C#</code>中用于检查对象是否是特定类型的实例。<br><br></p><p>（1）类型检查</p><p>使用<code>is</code>可以检查对象是否是特定类型的实例。如果是，则返回<code>true</code>，否则返回<code>false</code>。<br><br></p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">object</span> obj = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (obj <span class="keyword">is</span> <span class="built_in">string</span>)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;✅ obj 是字符串&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;❌ obj 不是字符串&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出: ✅ obj 是字符串</span></span><br></pre></td></tr></table></figure><p>（2）模式匹配</p><p>从<code>C# 7.0</code>开始，<code>is</code>关键字还支持模式匹配。这使得检查类型和转换类型可以在一个操作中完成。<br><br></p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">object</span> obj = <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一步完成：检查类型 + 转换 + 赋值</span></span><br><span class="line"><span class="keyword">if</span> (obj <span class="keyword">is</span> <span class="built_in">string</span> s)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">$&quot;✅ 字符串内容: <span class="subst">&#123;s&#125;</span>&quot;</span>);</span><br><span class="line">    Console.WriteLine(<span class="string">$&quot;长度: <span class="subst">&#123;s.Length&#125;</span>&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;❌ 不是字符串&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出:</span></span><br><span class="line"><span class="comment">// ✅ 字符串内容: Hello, World!</span></span><br><span class="line"><span class="comment">// 长度: 13</span></span><br></pre></td></tr></table></figure><p>在这个示例中，如果<code>obj</code>是<code>string</code>类型，<code>is</code>关键字不仅检查类型，还将<code>obj</code>转换为<code>string</code>并赋值给变量<code>s</code>。然后可以直接使用<code>s</code>。<br><br></p><p>（3）使用<code>is</code>进行<code>null</code>检查</p><p><code>is</code>关键字还可以用来检查对象是否为<code>null</code>。<br><br></p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">object</span> obj = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (obj <span class="keyword">is</span> <span class="literal">null</span>)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;✅ obj 是 null&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者使用 is not（C# 9.0+）</span></span><br><span class="line"><span class="keyword">if</span> (obj <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">null</span>)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;✅ obj 不是 null&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（4）检查接口实现</p><p><code>is</code>关键字也可以用于检查对象是否实现了某个接口。<br><br></p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IAnimal</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Speak</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Dog</span> : <span class="title">IAnimal</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Speak</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;🐕 汪汪汪！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Cat</span> : <span class="title">IAnimal</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Speak</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;🐱 喵喵喵！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="built_in">object</span> obj = <span class="keyword">new</span> Dog();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (obj <span class="keyword">is</span> IAnimal animal)</span><br><span class="line">&#123;</span><br><span class="line">    animal.Speak();  <span class="comment">// 输出: 🐕 汪汪汪！</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;❌ 不是动物&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="17-namespace-关键字"><a href="#17-namespace-关键字" class="headerlink" title="17. namespace 关键字"></a>17. namespace 关键字</h3><p>在<code>C#</code>中，<code>namespace</code>(命名空间) 是用于组织代码和防止命名冲突的一种机制。命名空间提供了一种逻辑上的分组方式，使得开发者可以更容易地管理和维护代码。<br><br></p><p>（1）定义命名空间<br>在这个示例中，<code>MyClass</code>类被定义在<code>MyApplication</code>命名空间中。<br><br></p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">MyApplication</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyClass</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">MyMethod</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Hello from MyMethod!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）使用命名空间<br>要使用某个命名空间中的类型，可以通过<code>using</code>关键字导入命名空间。<br><br></p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> MyApplication;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        MyClass myClass = <span class="keyword">new</span> MyClass();</span><br><span class="line">        myClass.MyMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>命名空间的好处</p><ul><li>组织代码: 通过使用命名空间，可以将相关的类、接口、枚举等进行分组，增加代码的可读性和维护性。</li><li>避免命名冲突: 在大型项目中，不同模块或库中可能会有同名的类型，通过使用命名空间，可以避免这些冲突。</li></ul><hr><h3 id="18-null-关键字"><a href="#18-null-关键字" class="headerlink" title="18. null 关键字"></a>18. null 关键字</h3><p><code>null</code>关键字在<code>C#</code>中表示对象引用不指向任何实例。它是引用类型的默认值，意味着变量不引用任何对象。<br><br></p><p>(1) 空合并运算符<br>空合并运算符<code>(??)</code>提供了简洁的语法来处理<code>null</code>值。如果左操作数为<code>null</code>，则返回右操作数。<br><br></p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> str = <span class="literal">null</span>;</span><br><span class="line"><span class="built_in">string</span> result = str ?? <span class="string">&quot;default value&quot;</span>;</span><br><span class="line">Console.WriteLine(result); <span class="comment">// 输出 &quot;default value&quot;</span></span><br></pre></td></tr></table></figure><p>(2) 空条件运算符<br>空条件运算符<code>(?.)</code>在访问成员或调用方法时检查<code>null</code>。如果对象为<code>null</code>，表达式返回<code>null</code>而不引发异常。<br><br></p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">MyClass obj = <span class="literal">null</span>;</span><br><span class="line">obj?.DoSomething(); <span class="comment">// 不会引发 NullReferenceException</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span>[] arr = <span class="literal">null</span>;</span><br><span class="line"><span class="built_in">int</span>? <span class="keyword">value</span> = arr?[<span class="number">0</span>]; <span class="comment">// value 为 null</span></span><br></pre></td></tr></table></figure><p>(3) 处理值类型的<code>null</code><br>对于值类型，不能直接赋值<code>null</code>。但是，可以使用可空类型（<code>Nullable&lt;T&gt;</code> 或 <code>T?</code>）来表示可以为<code>null</code>的值类型。<br><br></p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span>? nullableInt = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">if</span> (nullableInt.HasValue)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(nullableInt.Value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;nullableInt is null&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="19-out-关键字"><a href="#19-out-关键字" class="headerlink" title="19. out 关键字"></a>19. out 关键字</h3><p>在<code>C#</code>中，<code>out</code>关键字用于方法参数，表示该参数将由方法初始化并返回给调用方。<code>out</code>参数在方法调用时不需要被初始化，但在方法返回之前必须被赋值。<br><br></p><p>（1）定义和使用<code>out</code>参数</p><p>在方法声明中使用<code>out</code>关键字，并在方法调用时也使用<code>out</code>关键字。<br><br></p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> result;</span><br><span class="line">        <span class="built_in">bool</span> success = TryParse(<span class="string">&quot;123&quot;</span>, <span class="keyword">out</span> result);</span><br><span class="line">        <span class="keyword">if</span> (success)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">$&quot;Parsed number: <span class="subst">&#123;result&#125;</span>&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Failed to parse number.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">bool</span> <span class="title">TryParse</span>(<span class="params"><span class="built_in">string</span> input, <span class="keyword">out</span> <span class="built_in">int</span> number</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">int</span>.TryParse(input, <span class="keyword">out</span> number);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）使用<code>out</code>返回多个值</p><p>通过<code>out</code>参数，可以让方法返回多个值。<br><br></p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">double</span> area, perimeter;</span><br><span class="line">        CalculateCircle(<span class="number">5</span>, <span class="keyword">out</span> area, <span class="keyword">out</span> perimeter);</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;Area: <span class="subst">&#123;area&#125;</span>, Perimeter: <span class="subst">&#123;perimeter&#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">CalculateCircle</span>(<span class="params"><span class="built_in">double</span> radius, <span class="keyword">out</span> <span class="built_in">double</span> area, <span class="keyword">out</span> <span class="built_in">double</span> perimeter</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        area = Math.PI * radius * radius;</span><br><span class="line">        perimeter = <span class="number">2</span> * Math.PI * radius;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>out</code>与<code>ref</code>的区别</p><ul><li>初始化要求: 使用<code>out</code>参数的方法不要求在调用前初始化该参数，而<code>ref</code>参数必须在调用前初始化。</li><li>赋值要求: 使用<code>out</code>参数的方法必须在方法返回之前为该参数赋值，而<code>ref</code>参数不强制要求在方法内赋值。</li></ul><p>以下限制适用于使用<code>out</code>关键字</p><ul><li>异步方法中不允许使用<code>out</code>参数。</li><li>迭代器方法中不允许使用<code>out</code>参数。</li><li>属性不能作为<code>out</code>参数传递。</li></ul><hr><h3 id="20-override-关键字"><a href="#20-override-关键字" class="headerlink" title="20. override 关键字"></a>20. override 关键字</h3><p><code>override</code>关键字在<code>C#</code>中用于方法、属性、索引器或事件，表示派生类中重写基类的虚方法、虚属性、虚索引器或虚事件。通过使用<code>override</code>，派生类可以提供基类成员的新实现。<br><br></p><p>（1）定义基类和派生类</p><p>在基类中，使用<code>virtual</code>关键字定义可以被重写的成员。在派生类中，使用<code>override</code>关键字重写这些成员。<br><br></p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BaseClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Display</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;BaseClass Display method&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DerivedClass</span> : <span class="title">BaseClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Display</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;DerivedClass Display method&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）使用<code>override</code>重写属性和方法</p><p>可以使用<code>override</code>关键字重写基类中的虚属性。(重写方法如上)<br><br></p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BaseClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">virtual</span> <span class="built_in">int</span> Number &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">ShowNumber</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Number: &quot;</span> + Number);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DerivedClass</span> : <span class="title">BaseClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> _number;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">int</span> Number</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> _number; &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123; _number = <span class="keyword">value</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">ShowNumber</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Derived Number: &quot;</span> + Number);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意事项</p><ul><li>虚成员: 只有基类中标记为<code>virtual</code>或<code>abstract</code>的成员才能被重写。</li><li>访问修饰符: 重写的成员的访问级别必须与基类中的成员一致，或者更严格。例如，如果基类中的虚方法是<code>public</code>，则派生类中的重写方法也必须是<code>public</code>，不能是<code>protected</code>或<code>private</code>。</li></ul><hr><h3 id="21-params-关键字"><a href="#21-params-关键字" class="headerlink" title="21. params 关键字"></a>21. params 关键字</h3><p><code>params</code>关键字在<code>C#</code>中用于指定一个方法参数数组，使得方法可以接受可变数量的参数。</p><ul><li>使用<code>params</code>关键字的参数必须是方法的最后一个参数，并且它可以接受任意数量的参数，包括零个参数。</li></ul><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PrintNumbers</span>(<span class="params"><span class="keyword">params</span> <span class="built_in">int</span>[] numbers</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="built_in">int</span> number <span class="keyword">in</span> numbers)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(number);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PrintNumbers(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);  <span class="comment">// 输出: 1 2 3 4</span></span><br><span class="line">PrintNumbers(<span class="number">5</span>, <span class="number">6</span>);        <span class="comment">// 输出: 5 6</span></span><br><span class="line">PrintNumbers();            <span class="comment">// 输出: （空）</span></span><br></pre></td></tr></table></figure><p>使用<code>params</code>的理由<br><br></p><p>(1) 灵活性和简洁性</p><p><code>params</code>关键字提供了在方法调用时的灵活性和简洁性。它允许调用者传递任意数量的参数，而不需要显式地创建一个数组。这使得方法调用更简洁、更直观。<br><br></p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PrintNumbers</span>(<span class="params"><span class="built_in">int</span>[] numbers</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="built_in">int</span> number <span class="keyword">in</span> numbers)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(number);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用方法时需要创建数组</span></span><br><span class="line">PrintNumbers(<span class="keyword">new</span> <span class="built_in">int</span>[] &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;);</span><br><span class="line">PrintNumbers(<span class="keyword">new</span> <span class="built_in">int</span>[] &#123; <span class="number">10</span>, <span class="number">20</span> &#125;);</span><br><span class="line">PrintNumbers(<span class="keyword">new</span> <span class="built_in">int</span>[] &#123; &#125;);  <span class="comment">// 传递一个空数组</span></span><br></pre></td></tr></table></figure><p>如果不使用<code>params</code>关键字，则需要显式地创建数组<br><br></p><p>(2) 支持多参数重载</p><p><code>params</code>关键字允许方法支持多种参数重载，这在需要处理多个不同参数数量的情况下非常有用。它避免了为每种可能的参数数量定义多个重载方法。<br><br></p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DisplayItems</span>(<span class="params"><span class="keyword">params</span> <span class="built_in">string</span>[] items</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> item <span class="keyword">in</span> items)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(item);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用方法时</span></span><br><span class="line">DisplayItems(<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Cherry&quot;</span>);</span><br><span class="line">DisplayItems(<span class="string">&quot;Dog&quot;</span>, <span class="string">&quot;Cat&quot;</span>);</span><br><span class="line">DisplayItems();  <span class="comment">// 传递零个参数</span></span><br></pre></td></tr></table></figure><hr><h3 id="22-private-关键字"><a href="#22-private-关键字" class="headerlink" title="22. private 关键字"></a>22. private 关键字</h3><p><code>private</code>关键字是<code>C#</code>中的访问修饰符，用于控制类或结构体成员的可访问性。标记为<code>private</code>的成员只能在定义它们的类或结构体内部访问。</p><ul><li>使用<code>private</code>关键字可以隐藏类的实现细节，限制对类内部数据的直接访问，从而提高代码的封装性和安全性。</li></ul><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BankAccount</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">double</span> balance = <span class="number">1000</span>;  <span class="comment">// 私有字段：余额</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 存钱</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Deposit</span>(<span class="params"><span class="built_in">double</span> amount</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (amount &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            balance += amount;  <span class="comment">// ✅ 类内部可以访问 balance</span></span><br><span class="line">            Console.WriteLine(<span class="string">$&quot;存入 <span class="subst">&#123;amount&#125;</span> 元，当前余额: <span class="subst">&#123;balance&#125;</span>&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 取钱</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Withdraw</span>(<span class="params"><span class="built_in">double</span> amount</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (amount &gt; <span class="number">0</span> &amp;&amp; amount &lt;= balance)</span><br><span class="line">        &#123;</span><br><span class="line">            balance -= amount;  <span class="comment">// ✅ 类内部可以访问 balance</span></span><br><span class="line">            Console.WriteLine(<span class="string">$&quot;取出 <span class="subst">&#123;amount&#125;</span> 元，当前余额: <span class="subst">&#123;balance&#125;</span>&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;余额不足或金额无效&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 查询余额</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">double</span> <span class="title">GetBalance</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> balance;  <span class="comment">// ✅ 类内部可以访问 balance</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line">BankAccount account = <span class="keyword">new</span> BankAccount();</span><br><span class="line">account.Deposit(<span class="number">500</span>);      <span class="comment">// 输出: 存入 500 元，当前余额: 1500</span></span><br><span class="line">account.Withdraw(<span class="number">200</span>);     <span class="comment">// 输出: 取出 200 元，当前余额: 1300</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">double</span> money = account.GetBalance();  <span class="comment">// ✅ 通过方法获取余额</span></span><br><span class="line">Console.WriteLine(<span class="string">$&quot;余额: <span class="subst">&#123;money&#125;</span>&quot;</span>);  <span class="comment">// 输出: 余额: 1300</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// account.balance = 99999;  // ❌ 错误：不能直接修改私有字段</span></span><br></pre></td></tr></table></figure><p>注意事项</p><ul><li><code>private</code>是<code>C#</code>中最严格的访问修饰符，仅限于在类或结构体内部访问。</li><li><code>private</code>成员不能在派生类中访问，即使是通过继承。</li><li>在结构体中，所有成员默认为<code>private</code>，而在类中，成员默认为<code>private</code>。</li></ul><hr><h3 id="23-protected-关键字"><a href="#23-protected-关键字" class="headerlink" title="23. protected 关键字"></a>23. protected 关键字</h3><p><code>protected</code>关键字是<code>C#</code>中的访问修饰符，用于控制类或结构体成员的可访问性。标记为<code>protected</code>的成员只能在以下两种情况下访问</p><ul><li>在定义该成员的类内部访问</li><li>在派生类中访问</li></ul><p>这种访问修饰符允许你在保持数据封装的同时，为派生类提供访问基类成员的能力。<br><br></p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Animal</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="built_in">string</span> name;  <span class="comment">// 受保护的字段</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetName</span>(<span class="params"><span class="built_in">string</span> name</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">ShowInfo</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;动物名字: <span class="subst">&#123;name&#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Dog</span> : <span class="title">Animal</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Display</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        ShowInfo();  <span class="comment">// 可以访问基类的 protected 成员</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line">Dog dog = <span class="keyword">new</span> Dog();</span><br><span class="line">dog.SetName(<span class="string">&quot;旺财&quot;</span>);</span><br><span class="line">dog.Display();  <span class="comment">// 输出: 动物名字: 旺财</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// dog.name = &quot;小黑&quot;;  // ❌ 错误：外部无法访问</span></span><br><span class="line"><span class="comment">// dog.ShowInfo();     // ❌ 错误：外部无法访问</span></span><br></pre></td></tr></table></figure><p>使用<code>protected</code>的原因</p><ul><li>继承与扩展: <code>protected</code>关键字允许派生类访问基类的成员，从而支持类的继承和扩展。</li><li>数据封装: 通过限制成员的访问权限，<code>protected</code>关键字有助于保护类的内部状态，同时允许派生类进行必要的访问。</li></ul><p>以下是对<code>protected internal</code>和<code>private protected</code>访问修饰符的详细解释<br><br></p><p><code>protected internal</code>关键字结合了<code>protected</code>和<code>internal</code>的特性，成员可以在以下两种情况下访问</p><ul><li>同一程序集: <code>internal</code>允许同一程序集中的任何代码访问。</li><li>派生类: <code>protected</code>允许派生类访问，即使它们在不同的程序集中。</li></ul><p>因此，<code>protected internal</code>的成员可以被同一程序集中的所有代码访问，也可以被其他程序集中派生类访问。下面是一个例子<br><br></p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在 MyLibrary.dll 中</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Shape</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">internal</span> <span class="built_in">double</span> Area &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Circle</span> : <span class="title">Shape</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Calculate</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Area = <span class="number">3.14</span> * <span class="number">5</span> * <span class="number">5</span>;  <span class="comment">// ✅ 派生类可以访问</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 MyApp.exe 中</span></span><br><span class="line">Circle c = <span class="keyword">new</span> Circle();</span><br><span class="line">c.Area = <span class="number">100</span>;  <span class="comment">// ✅ 同程序集可以访问</span></span><br></pre></td></tr></table></figure><p>总而言之，<code>protected internal</code>允许灵活地在同一程序集内访问共享的实现细节，同时保留跨程序集继承的能力。<br><br></p><p><code>private protected</code>关键字结合了<code>private</code>和<code>protected</code>的特性，成员只能在以下两种情况下访问</p><ul><li>同一类内部: <code>private</code>允许在同一类内部访问。</li><li>同一程序集中派生类: <code>protected</code>允许在派生类中访问，但前提是这些派生类在同一程序集中。</li></ul><p>因此，<code>private protected</code>的成员只能被定义它们的类及其同一程序集中的派生类访问，不能被其他程序集的派生类访问。下面是一个例子<br><br></p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在 OrderSystem.dll 中</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Order</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">protected</span> <span class="built_in">string</span> OrderId &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SpecialOrder</span> : <span class="title">Order</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Show</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(OrderId);  <span class="comment">// ✅ 同程序集的派生类可访问</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 ExternalApp.dll 中</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyOrder</span> : <span class="title">Order</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Display</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Console.WriteLine(OrderId);  // ❌ 错误：不同程序集</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总而言之，<code>private protected</code>提供了一种更严格的访问控制，防止不同程序集中的类访问某些内部细节，这在保护敏感数据或内部实现细节时特别有用。</p><hr><h3 id="24-readonly-关键字"><a href="#24-readonly-关键字" class="headerlink" title="24. readonly 关键字"></a>24. readonly 关键字</h3><p><code>readonly</code>关键字在<code>C#</code>中用于修饰字段，表示该字段在初始化后不能被更改。<code>readonly</code>字段只能在以下情况下赋值</p><ul><li>字段声明时: 可以在声明字段时直接赋值。</li><li>构造函数中: 可以在类的构造函数中赋值，包括实例构造函数和静态构造函数。</li></ul><p><code>readonly</code>字段与<code>const</code>常量的不同之处在于，<code>const</code>是编译时常量，必须在声明时赋值，并且其值在编译时就确定，而<code>readonly</code>字段可以在运行时被赋值，并且可以根据构造函数的逻辑赋予不同的值。<br><br></p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">readonly</span> <span class="built_in">string</span> Name;      <span class="comment">// 构造函数中赋值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">readonly</span> <span class="built_in">int</span> Age;          <span class="comment">// 构造函数中赋值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">readonly</span> <span class="built_in">string</span> Country = <span class="string">&quot;中国&quot;</span>;  <span class="comment">// 声明时赋值</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span>(<span class="params"><span class="built_in">string</span> name, <span class="built_in">int</span> age</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Name = name;</span><br><span class="line">        Age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Display</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;姓名: <span class="subst">&#123;Name&#125;</span>, 年龄: <span class="subst">&#123;Age&#125;</span>, 国家: <span class="subst">&#123;Country&#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line">Person person = <span class="keyword">new</span> Person(<span class="string">&quot;张三&quot;</span>, <span class="number">25</span>);</span><br><span class="line">person.Display();  <span class="comment">// 输出: 姓名: 张三, 年龄: 25, 国家: 中国</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// person.Name = &quot;李四&quot;;  // ❌ 编译错误：不能修改 readonly 字段</span></span><br><span class="line"><span class="comment">// person.Age = 30;       // ❌ 编译错误</span></span><br></pre></td></tr></table></figure><p>（1）<code>const</code>和<code>readonly</code>的区别</p><p><code>const</code>适用于值在编译时就确定不变的情况，如数学常量<code>pi</code>。<br><br></p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MathConstants</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ✅ const：编译时就确定，永不改变</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">const</span> <span class="built_in">double</span> Pi = <span class="number">3.14159</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">const</span> <span class="built_in">int</span> MaxValue = <span class="number">100</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ❌ const 不能在构造函数中赋值</span></span><br><span class="line">    <span class="comment">// public const string Name;  // 错误：必须在声明时赋值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line">Console.WriteLine(MathConstants.Pi);  <span class="comment">// 3.14159</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// MathConstants.Pi = 3.14;  // ❌ 编译错误：不能修改常量</span></span><br></pre></td></tr></table></figure><p><code>readonly</code>适用于值在运行时确定且一旦初始化后不再改变的情况，如配置文件中的某些设置。<br><br></p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Config</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ✅ readonly：运行时确定，每个对象可以不同</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">readonly</span> DateTime CreationTime;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">readonly</span> <span class="built_in">string</span> UserId;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">readonly</span> <span class="built_in">int</span> MaxConnections = <span class="number">10</span>;  <span class="comment">// 可以声明时赋值</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Config</span>(<span class="params"><span class="built_in">string</span> userId</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        CreationTime = DateTime.Now;  <span class="comment">// 每次创建时不同</span></span><br><span class="line">        UserId = userId;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line">Config config1 = <span class="keyword">new</span> Config(<span class="string">&quot;user001&quot;</span>);</span><br><span class="line">Thread.Sleep(<span class="number">1000</span>);  <span class="comment">// 等待1秒</span></span><br><span class="line">Config config2 = <span class="keyword">new</span> Config(<span class="string">&quot;user002&quot;</span>);</span><br><span class="line"></span><br><span class="line">Console.WriteLine(config1.CreationTime);  <span class="comment">// 2025-10-26 10:00:00</span></span><br><span class="line">Console.WriteLine(config2.CreationTime);  <span class="comment">// 2025-10-26 10:00:01（不同）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// config1.UserId = &quot;user003&quot;;  // ❌ 编译错误：不能修改 readonly</span></span><br></pre></td></tr></table></figure><hr><h3 id="25-ref-关键字"><a href="#25-ref-关键字" class="headerlink" title="25. ref 关键字"></a>25. ref 关键字</h3><p><code>ref</code>关键字在<code>C#</code>中用于方法参数，表示参数以引用方式传递。这意味着在方法内对参数的任何修改都会影响到调用方传递的实际变量。使用<code>ref</code>关键字的要求</p><ul><li>在方法声明中使用: 必须在方法的参数列表中使用<code>ref</code>关键字。</li><li>在方法调用时使用: 调用方法时也必须在实际参数前加上<code>ref</code>关键字。</li><li>初始化要求: 传递给<code>ref</code>参数的变量必须在调用方法之前初始化。</li></ul><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Increment</span>(<span class="params"><span class="keyword">ref</span> <span class="built_in">int</span> number</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        number++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> <span class="keyword">value</span> = <span class="number">5</span>;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;Before: <span class="subst">&#123;<span class="keyword">value</span>&#125;</span>&quot;</span>); <span class="comment">// 输出: Before: 5</span></span><br><span class="line">        Increment(<span class="keyword">ref</span> <span class="keyword">value</span>);</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;After: <span class="subst">&#123;<span class="keyword">value</span>&#125;</span>&quot;</span>);  <span class="comment">// 输出: After: 6</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果上面的示例中没有使用<code>ref</code>，那么第二个<code>Console</code>的输出就还会是<code>5</code>。原因是方法接收参数的副本，方法内对参数的修改不会影响到外部的实际变量。<br><br></p><p>使用<code>ref</code>的场景</p><ul><li>需要修改调用方变量的场景: 当你希望在方法内修改调用方传递的变量时，可以使用<code>ref</code>关键字。例如，交换两个变量的值。</li><li>需要返回多个值的场景: 虽然方法本身只能返回一个值，但可以通过<code>ref</code>或<code>out</code>参数返回多个值。</li></ul><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Swap</span>(<span class="params"><span class="keyword">ref</span> <span class="built_in">int</span> a, <span class="keyword">ref</span> <span class="built_in">int</span> b</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> temp = a;</span><br><span class="line">        a = b;</span><br><span class="line">        b = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> x = <span class="number">10</span>;</span><br><span class="line">        <span class="built_in">int</span> y = <span class="number">20</span>;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;Before Swap: x = <span class="subst">&#123;x&#125;</span>, y = <span class="subst">&#123;y&#125;</span>&quot;</span>); <span class="comment">// 输出: Before Swap: x = 10, y = 20</span></span><br><span class="line">        Swap(<span class="keyword">ref</span> x, <span class="keyword">ref</span> y);</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;After Swap: x = <span class="subst">&#123;x&#125;</span>, y = <span class="subst">&#123;y&#125;</span>&quot;</span>);  <span class="comment">// 输出: After Swap: x = 20, y = 10</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ref</code>与<code>out</code>的区别</p><ul><li>初始化要求: 传递给<code>ref</code>参数的变量必须在调用方法之前初始化。传递给<code>out</code>参数的变量可以在方法调用之前未初始化，但必须在方法内部赋值。</li><li>主要用途: <code>ref</code>用于传递数据给方法，并且希望方法内部修改该数据。<code>out</code>用于方法返回多个值。</li></ul><hr><h3 id="26-sealed-关键字"><a href="#26-sealed-关键字" class="headerlink" title="26. sealed 关键字"></a>26. sealed 关键字</h3><p><code>sealed</code>关键字在<code>C#</code>中用于类和方法，提供了不同的功能</p><ul><li>用于类: 防止其他类从它派生。也就是说，<code>sealed</code>类不能作为基类，无法被继承。</li><li>用于方法: 当用在基类中的虚方法上时，防止派生类进一步重写该方法。</li></ul><p>当一个类被标记为<code>sealed</code>时，它不能被继承。这通常用于防止不希望的继承，或者当类的设计不需要被扩展时。使用<code>sealed</code>类可以提高性能，因为它的成员在编译时可以进行更多的优化。<br><br></p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">FinalClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Display</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;This is a sealed class.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下代码将会导致编译错误，因为不能继承一个 sealed 类</span></span><br><span class="line"><span class="comment">// public class DerivedClass : FinalClass</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure><p>当一个类继承自基类，并且重写了基类中的虚方法时，可以使用<code>sealed</code>关键字阻止进一步的重写。这种情况下，<code>sealed</code>关键字必须与<code>override</code>一起使用。<br><br></p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BaseClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Display</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;BaseClass Display method.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DerivedClass</span> : <span class="title">BaseClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Display</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;DerivedClass Display method.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下代码将会导致编译错误，因为 Display 方法被 sealed</span></span><br><span class="line"><span class="comment">// public class FurtherDerivedClass : DerivedClass</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//     public override void Display()</span></span><br><span class="line"><span class="comment">//     &#123;</span></span><br><span class="line"><span class="comment">//         Console.WriteLine(&quot;FurtherDerivedClass Display method.&quot;);</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure><p>使用<code>sealed</code>的场景</p><ul><li>提高安全性: 通过防止类的继承，可以保护类的实现细节，防止子类意外地改变类的行为。</li><li>性能优化: 标记为<code>sealed</code>的类和方法可以进行更多的编译时优化，因为编译器知道这些类和方法不会被重写。</li><li>限制扩展性: 当一个类的设计不适合扩展时，可以使用<code>sealed</code>防止进一步的继承。</li></ul><hr><h3 id="27-static-关键字"><a href="#27-static-关键字" class="headerlink" title="27. static 关键字"></a>27. static 关键字</h3><p><code>static</code>关键字在<code>C#</code>中用于声明类成员和类本身。它表示这些成员或类与具体实例无关，而是属于类型本身。<br><br></p><p>（1）静态类 <code>static class</code></p><ul><li>定义: 静态类是不能被实例化的类，所有成员都必须是静态的。</li><li>特性: 静态类通常用于组织一组相关的静态方法和常量，不允许创建静态类的实例。</li><li>用途: 常用于实用类<code>Utility class</code>或库，提供静态方法进行通用操作。</li></ul><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">MathUtilities</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">Add</span>(<span class="params"><span class="built_in">int</span> a, <span class="built_in">int</span> b</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">Multiply</span>(<span class="params"><span class="built_in">int</span> a, <span class="built_in">int</span> b</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> a * b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）静态类 <code>static</code> 成员</p><ul><li>静态成员包括静态字段、静态属性、静态方法、静态事件等。它们属于类本身，而不是类的具体实例。</li><li>静态字段: 所有实例共享的字段，可以用于存储全局状态或常量。</li><li>静态属性: 提供对静态字段的访问，通常用于封装。</li><li>静态方法: 可以在不创建类实例的情况下调用，用于执行与类实例无关的操作。</li><li>静态构造函数: 用于初始化静态字段或执行其他静态初始化，只在类首次被访问时调用一次。</li></ul><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Counter</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> Count &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Increment</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Count++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用静态成员</span></span><br><span class="line">Counter.Increment();</span><br><span class="line">Console.WriteLine(Counter.Count); <span class="comment">// 输出: 1</span></span><br></pre></td></tr></table></figure><p>（3）静态构造函数 <code>static constructor</code></p><ul><li>静态构造函数用于初始化静态字段或执行类级别的初始化。它在类的第一次使用时被调用，且只调用一次。</li><li>特性: 没有访问修饰符，因为它不能由外部代码调用；不接受参数，因为它是自动调用的。</li><li>用途: 通常用于初始化静态数据。</li></ul><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Example</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> Value;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="title">Example</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Value = <span class="number">42</span>; <span class="comment">// 静态初始化</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用静态成员</span></span><br><span class="line">Console.WriteLine(Example.Value); <span class="comment">// 输出: 42</span></span><br></pre></td></tr></table></figure><p><code>static</code>关键字在<code>C#</code>中非常重要，用于定义不依赖于具体对象实例的类和成员。它提供了一个全局的、共享的访问点，适用于需要统一管理状态或提供通用操作的场景。</p><hr><h3 id="28-struct-关键字"><a href="#28-struct-关键字" class="headerlink" title="28. struct 关键字"></a>28. struct 关键字</h3><p><code>struct</code>关键字在<code>C#</code>中用于定义值类型。值类型与引用类型（如类）不同，值类型在内存中直接存储其数据，而不是存储对数据的引用。结构体是一种轻量级的数据结构，通常用于表示小型数据对象。</p><ul><li>内存分配: 值类型的数据通常分配在栈上，而不是堆上。</li><li>数据存储: 值类型直接包含其数据，而引用类型包含对数据的引用。</li><li>无继承: 结构体不能继承自其他结构体或类，也不能被继承。但它们可以实现接口。</li><li>无参数的构造函数: 不能定义无参数的构造函数，因为默认的无参数构造函数始终存在，用于初始化字段为其默认值。</li></ul><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> Point</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> X &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Y &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Point</span>(<span class="params"><span class="built_in">int</span> x, <span class="built_in">int</span> y</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        X = x;</span><br><span class="line">        Y = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Display</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;Point at (<span class="subst">&#123;X&#125;</span>, <span class="subst">&#123;Y&#125;</span>)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Point p1 = <span class="keyword">new</span> Point(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">        p1.Display(); <span class="comment">// 输出: Point at (10, 20)</span></span><br><span class="line"></span><br><span class="line">        Point p2 = p1; <span class="comment">// 结构体的值复制</span></span><br><span class="line">        p2.X = <span class="number">30</span>;</span><br><span class="line">        p2.Display(); <span class="comment">// 输出: Point at (30, 20)</span></span><br><span class="line">        p1.Display(); <span class="comment">// 输出: Point at (10, 20) - p1 未受影响</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>struct</code> 的适用场景</p><ul><li>轻量级数据结构: 结构体适合用于表示轻量级的数据对象，如二维坐标、颜色、时间等。</li><li>不可变对象: 因为结构体是值类型，通常可以设计成不可变对象，提供更高的安全性和一致性。</li><li>性能考虑: 由于结构体在栈上分配，访问速度较快，适合于频繁分配和释放的小型对象。</li></ul><hr><h3 id="29-switch-关键字"><a href="#29-switch-关键字" class="headerlink" title="29. switch 关键字"></a>29. switch 关键字</h3><blockquote><p>这里主要介绍<code>switch</code>表达式</p></blockquote><p><code>switch</code>表达式是<code>C# 8.0</code>引入的一种简洁且功能强大的分支选择机制。与传统的<code>switch</code>语句不同，<code>switch</code>表达式不仅能根据输入值进行分支，而且更灵活地结合了模式匹配的特性。<br><br></p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> result = expression <span class="keyword">switch</span></span><br><span class="line">&#123;</span><br><span class="line">    pattern1 =&gt; result1,</span><br><span class="line">    pattern2 =&gt; result2,</span><br><span class="line">    pattern3 =&gt; result3,</span><br><span class="line">    _ =&gt; defaultResult</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>switch</code>表达式提供了一种简洁且灵活的方式来进行条件分支选择，与传统<code>switch</code>语句相比，它不仅减少了代码量，还提高了代码的可读性和维护性。</p><hr><h3 id="30-this-关键字"><a href="#30-this-关键字" class="headerlink" title="30. this 关键字"></a>30. this 关键字</h3><p><code>this</code>关键字在<code>C#</code>中用于引用当前实例的成员，包括字段、方法、属性、事件和索引器。它在类的非静态成员中非常有用。此外，<code>this</code>关键字还有其他特定用途，如调用构造函数和扩展方法。<br><br></p><p>（1）引用当前实例的成员</p><p>在类的实例方法或属性中，可以使用<code>this</code>关键字引用当前实例的成员，尤其是在成员名称与方法参数名称相同时。<br><br></p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span>(<span class="params"><span class="built_in">string</span> name</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 使用 this 引用当前实例的 name 字段</span></span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Display</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;Name: <span class="subst">&#123;<span class="keyword">this</span>.name&#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Person person = <span class="keyword">new</span> Person(<span class="string">&quot;Alice&quot;</span>);</span><br><span class="line">        person.Display(); <span class="comment">// 输出: Name: Alice</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）调用其他构造函数</p><p><code>this</code>关键字可以在构造函数中调用同一个类的其他构造函数，称为构造函数重载。<br><br></p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Rectangle</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Width &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Height &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Rectangle</span>() : <span class="title">this</span>(<span class="params"><span class="number">0</span>, <span class="number">0</span></span>) <span class="comment">// 调用具有两个参数的构造函数</span></span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Rectangle</span>(<span class="params"><span class="built_in">int</span> width, <span class="built_in">int</span> height</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.Width = width;</span><br><span class="line">        <span class="keyword">this</span>.Height = height;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Display</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;Width: <span class="subst">&#123;Width&#125;</span>, Height: <span class="subst">&#123;Height&#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Rectangle rect1 = <span class="keyword">new</span> Rectangle();</span><br><span class="line">        rect1.Display(); <span class="comment">// 输出: Width: 0, Height: 0</span></span><br><span class="line"></span><br><span class="line">        Rectangle rect2 = <span class="keyword">new</span> Rectangle(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">        rect2.Display(); <span class="comment">// 输出: Width: 10, Height: 20</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（3）扩展方法的调用</p><p><code>this</code>关键字在扩展方法的定义中用于指示被扩展的类型。<br><br></p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">StringExtensions</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">bool</span> <span class="title">IsNullOrEmpty</span>(<span class="params"><span class="keyword">this</span> <span class="built_in">string</span> <span class="keyword">value</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">string</span>.IsNullOrEmpty(<span class="keyword">value</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span> str = <span class="literal">null</span>;</span><br><span class="line">        <span class="built_in">bool</span> result = str.IsNullOrEmpty(); <span class="comment">// 使用扩展方法</span></span><br><span class="line">        Console.WriteLine(result); <span class="comment">// 输出: True</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个示例中，<code>IsNullOrEmpty</code>方法是一个扩展方法，它使用<code>this</code>关键字将<code>string</code>类型扩展为包含该方法的类型。<code>this</code>关键字指示<code>value</code>参数为被扩展的类型的实例。</p><hr><h3 id="31-throw-关键字"><a href="#31-throw-关键字" class="headerlink" title="31. throw 关键字"></a>31. throw 关键字</h3><p><code>throw</code>关键字在<code>C#</code>中用于引发异常。异常是一种在程序执行过程中出现的错误或意外情况，使用<code>throw</code>可以中断程序的正常执行流程，并转到相关的异常处理代码。<br><br></p><p>（1）引发异常</p><p>使用<code>throw</code>关键字可以显式引发一个异常，通常在检测到程序状态不合法或出现错误时使用。<br><br></p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">Divide</span>(<span class="params"><span class="built_in">int</span> a, <span class="built_in">int</span> b</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 引发异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> DivideByZeroException(<span class="string">&quot;除数不能为零&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a / b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> result = Divide(<span class="number">10</span>, <span class="number">0</span>);</span><br><span class="line">    Console.WriteLine(result);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (DivideByZeroException ex)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">$&quot;❌ 捕获异常: <span class="subst">&#123;ex.Message&#125;</span>&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出: ❌ 捕获异常: 除数不能为零</span></span><br></pre></td></tr></table></figure><p>（2）重新引发异常</p><p>在捕获异常后，可能希望重新引发异常以允许外部代码进一步处理。在<code>catch</code>块中使用<code>throw</code>可以重新引发当前捕获的异常。<br><br></p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ProcessData</span>(<span class="params"><span class="built_in">string</span> data</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 处理数据的逻辑</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">string</span>.IsNullOrEmpty(data))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentException(<span class="string">&quot;数据不能为空&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ... 其他处理</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (ArgumentException ex)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;⚠️ 数据验证失败&quot;</span>);</span><br><span class="line">        <span class="keyword">throw</span>;  <span class="comment">// ✅ 重新引发异常，保留堆栈跟踪</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    ProcessData(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (ArgumentException ex)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">$&quot;❌ 外层捕获: <span class="subst">&#123;ex.Message&#125;</span>&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出:</span></span><br><span class="line"><span class="comment">// ⚠️ 数据验证失败</span></span><br><span class="line"><span class="comment">// ❌ 外层捕获: 数据不能为空</span></span><br></pre></td></tr></table></figure><p>（3）<code>throw</code> or <code>throw ex</code></p><p>在<code>catch</code>块中重新引发异常时，使用<code>throw</code>; 而不是<code>throw ex</code>;。前者保留了原始异常的堆栈跟踪信息，而后者会重置堆栈跟踪。<br><br></p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 某些可能出错的代码</span></span><br><span class="line">    DoSomething();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Exception ex)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ❌ 错误方式：丢失原始堆栈跟踪</span></span><br><span class="line">    <span class="keyword">throw</span> ex;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ✅ 正确方式：保留原始堆栈跟踪</span></span><br><span class="line">    <span class="keyword">throw</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="32-using-关键字"><a href="#32-using-关键字" class="headerlink" title="32. using 关键字"></a>32. using 关键字</h3><p><code>using</code>关键字在<code>C#</code>中有两种主要的用法</p><ul><li>资源管理 (<code>using</code>语句): 用于定义一个范围，在该范围结束时会自动释放特定的资源。通常用于处理非托管资源，如文件、数据库连接等，需要显式释放的资源。</li><li>命名空间导入 (<code>using</code>指令): 用于导入命名空间，以便在代码中可以简化对命名空间内类型的引用。</li></ul><p>（1）资源管理 (<code>using</code>语句)<br><code>using</code>语句用于确保实现了<code>IDisposable</code>接口的对象在使用完后被正确地释放。<code>IDisposable</code>接口包含一个<code>Dispose</code>方法，用于释放资源。<br><br></p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.IO;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">using</span> (StreamReader reader = <span class="keyword">new</span> StreamReader(<span class="string">&quot;example.txt&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">string</span> content = reader.ReadToEnd();</span><br><span class="line">            Console.WriteLine(content);</span><br><span class="line">        &#125; <span class="comment">// reader 对象在此处被释放</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）命名空间导入 (<code>using</code>指令)</p><p><code>using</code>指令用于在文件的顶部导入命名空间，以便在代码中简化对该命名空间内类型的引用。这可以减少代码中的冗长类型名称，并提高代码的可读性。<br><br></p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        List&lt;<span class="built_in">int</span>&gt; numbers = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt; &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line">        Console.WriteLine(<span class="built_in">string</span>.Join(<span class="string">&quot;, &quot;</span>, numbers));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（3）别名</p><p>可以使用<code>using</code>指令为类型或命名空间创建别名。<br><br></p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> Project = MyCompany.ProjectNamespace;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Project.MyClass obj = <span class="keyword">new</span> Project.MyClass();</span><br><span class="line">        obj.MyMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="33-virtual-关键字"><a href="#33-virtual-关键字" class="headerlink" title="33. virtual 关键字"></a>33. virtual 关键字</h3><p><code>virtual</code>关键字在<code>C#</code>中用于修饰方法、属性、事件或索引器，表示这些成员可以在派生类中被重写。</p><ul><li>使用<code>virtual</code>关键字定义的成员提供了一个默认的实现，但允许派生类通过<code>override</code>关键字提供新的实现，从而改变基类的行为。</li></ul><p>（1）虚方法 <code>Virtual Methods</code></p><p>虚方法是指在基类中定义，并允许派生类重写的方法。虚方法在基类中提供了默认实现，但派生类可以通过重写它来提供新的行为。<br><br></p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 基类：提供默认实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Animal</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">MakeSound</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;动物发出声音&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 派生类：重写方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Dog</span> : <span class="title">Animal</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">MakeSound</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;🐕 汪汪汪！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Cat</span> : <span class="title">Animal</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">MakeSound</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;🐱 喵喵喵！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line">Animal animal1 = <span class="keyword">new</span> Animal();</span><br><span class="line">Animal animal2 = <span class="keyword">new</span> Dog();  <span class="comment">// 多态</span></span><br><span class="line">Animal animal3 = <span class="keyword">new</span> Cat();</span><br><span class="line"></span><br><span class="line">animal1.MakeSound();  <span class="comment">// 输出: 动物发出声音</span></span><br><span class="line">animal2.MakeSound();  <span class="comment">// 输出: 🐕 汪汪汪！</span></span><br><span class="line">animal3.MakeSound();  <span class="comment">// 输出: 🐱 喵喵喵！</span></span><br></pre></td></tr></table></figure><p>（2）虚属性 <code>Virtual Properties</code></p><p>虚属性类似于虚方法，它们允许在派生类中重写基类中的属性。<br><br></p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">ppublic <span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> name;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">virtual</span> <span class="built_in">string</span> Name</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> name; &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123; name = <span class="keyword">value</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Employee</span> : <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> name;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">string</span> Name</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> name; &#125;</span><br><span class="line">        <span class="keyword">set</span> </span><br><span class="line">        &#123; </span><br><span class="line">            <span class="comment">// 子类修改行为：自动转为大写</span></span><br><span class="line">            name = <span class="keyword">value</span>.ToUpper(); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line">Person person = <span class="keyword">new</span> Person();</span><br><span class="line">person.Name = <span class="string">&quot;zhang san&quot;</span>;</span><br><span class="line">Console.WriteLine(person.Name);  <span class="comment">// 输出: zhang san</span></span><br><span class="line"></span><br><span class="line">Employee employee = <span class="keyword">new</span> Employee();</span><br><span class="line">employee.Name = <span class="string">&quot;li si&quot;</span>;</span><br><span class="line">Console.WriteLine(employee.Name);  <span class="comment">// 输出: LI SI（自动大写）</span></span><br></pre></td></tr></table></figure><p><code>virtual</code>的使用场景</p><ul><li>多态性: 虚方法和属性允许派生类重写基类的实现，从而实现多态性。基类的方法可以调用派生类的实现，而无需了解派生类的具体类型。</li><li>默认行为: 虚方法和属性可以提供基类的默认行为，派生类可以选择接受默认行为或提供自己的实现。</li></ul><p>为什么选择<code>virtual</code>而不是<code>abstract</code></p><ul><li><p><code>virtual</code>关键字</p><ul><li>定义: <code>virtual</code>关键字用于定义可以在派生类中重写的成员。虚成员在基类中有一个默认的实现，派生类可以选择重写该实现。</li><li>用途: 当基类提供一个默认的实现，但派生类可以根据需要覆盖该实现时，使用<code>virtual</code>。它允许提供一个基础行为，并在派生类中进行扩展或修改。</li></ul></li><li><p><code>abstract</code>关键字</p><ul><li>定义: <code>abstract</code>关键字用于定义一个没有实现的成员，派生类必须提供该成员的具体实现。抽象成员没有方法体，类本身也必须是抽象的<code>abstract class</code>。</li><li>用途: 当基类强制派生类实现某些方法或属性时，使用<code>abstract</code>。它用于定义一个抽象的接口或行为规范，所有的派生类都必须实现这些行为。</li></ul></li></ul><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用 abstract：强制实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Animal</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 抽象方法：必须重写</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">Speak</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Dog</span> : <span class="title">Animal</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 必须实现 Speak</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Speak</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;汪汪&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 virtual：可选重写</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Vehicle</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 虚方法：提供默认实现</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;车辆启动&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Car</span> : <span class="title">Vehicle</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 可以选择不重写，使用默认实现</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ElectricCar</span> : <span class="title">Vehicle</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 也可以选择重写</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;⚡ 电动车静音启动&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line">Car car = <span class="keyword">new</span> Car();</span><br><span class="line">car.Start();  <span class="comment">// 输出: 车辆启动（使用默认实现）</span></span><br><span class="line"></span><br><span class="line">ElectricCar eCar = <span class="keyword">new</span> ElectricCar();</span><br><span class="line">eCar.Start();  <span class="comment">// 输出: ⚡ 电动车静音启动（重写后的实现）</span></span><br></pre></td></tr></table></figure><hr><h3 id="34-get-和-set-关键字"><a href="#34-get-和-set-关键字" class="headerlink" title="34. get 和 set 关键字"></a>34. get 和 set 关键字</h3><p><code>get</code>和<code>set</code>关键字在<code>C#</code>中用于定义属性的访问器。</p><ul><li><code>get</code>访问器用于返回属性的值，而<code>set</code>访问器用于为属性分配新值。</li></ul><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> _name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> _name; <span class="comment">// 返回字段的值</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span></span><br><span class="line">        &#123;</span><br><span class="line">            _name = <span class="keyword">value</span>; <span class="comment">// 设置字段的值</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Person person = <span class="keyword">new</span> Person();</span><br><span class="line">        person.Name = <span class="string">&quot;Alice&quot;</span>; <span class="comment">// 调用 set 访问器</span></span><br><span class="line">        Console.WriteLine(person.Name); <span class="comment">// 调用 get 访问器</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（1）自动属性<br>自动属性是一种简化语法，它让编译器自动生成私有的后备字段。使用自动属性时，不需要显式定义 <code>get</code>和<code>set</code>访问器的实现。<br><br></p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; <span class="comment">// 自动属性</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Person person = <span class="keyword">new</span> Person();</span><br><span class="line">        person.Name = <span class="string">&quot;Alice&quot;</span>; <span class="comment">// 自动属性的 set 访问器</span></span><br><span class="line">        Console.WriteLine(person.Name); <span class="comment">// 自动属性的 get 访问器</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）只读和写入属性</p><ul><li>只读属性: 只定义<code>get</code>访问器的属性。</li><li>写入属性: 只定义<code>set</code>访问器的属性。</li></ul><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 只读属性</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> _name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> _name; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span>(<span class="params"><span class="built_in">string</span> name</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写入属性</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> _name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">set</span> &#123; _name = <span class="keyword">value</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">GetName</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> _name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（3）属性的访问控制</p><p>可以为属性的<code>get</code>和<code>set</code>访问器指定不同的访问修饰符，以控制它们的访问级别。<br><br></p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> _name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> _name; &#125;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">set</span> &#123; _name = <span class="keyword">value</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span>(<span class="params"><span class="built_in">string</span> name</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Name = name; <span class="comment">// 可以在类内部设置值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个示例中，<code>Name</code>属性的<code>set</code>访问器是私有的，因此只能在<code>Person</code>类内部设置<code>Name</code>的值，而<code>get</code> 访问器是公有的，允许从外部读取<code>Name</code>的值。</p><hr><h3 id="35-add-和-remove-关键字"><a href="#35-add-和-remove-关键字" class="headerlink" title="35. add 和 remove 关键字"></a>35. add 和 remove 关键字</h3><p><code>add</code>和<code>remove</code>关键字在<code>C#</code>中用于自定义事件的访问器。这两个关键字允许你定义事件处理程序的添加和移除逻辑，它们通常与<code>event</code>关键字一起使用。<br><br></p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ✅ 标准事件（自动实现）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">StandardEvent</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">event</span> EventHandler MyEvent;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Trigger</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        MyEvent?.Invoke(<span class="keyword">this</span>, EventArgs.Empty);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ✅ 自定义事件（手动控制 add 和 remove）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CustomEvent</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> EventHandler myEvent;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">event</span> EventHandler MyEvent</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">add</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;➕ 添加订阅者&quot;</span>);</span><br><span class="line">            myEvent += <span class="keyword">value</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">remove</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;➖ 移除订阅者&quot;</span>);</span><br><span class="line">            myEvent -= <span class="keyword">value</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Trigger</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        myEvent?.Invoke(<span class="keyword">this</span>, EventArgs.Empty);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line">CustomEvent obj = <span class="keyword">new</span> CustomEvent();</span><br><span class="line"></span><br><span class="line">EventHandler handler = (sender, e) =&gt; Console.WriteLine(<span class="string">&quot;✅ 事件触发&quot;</span>);</span><br><span class="line"></span><br><span class="line">obj.MyEvent += handler;  <span class="comment">// 输出: ➕ 添加订阅者</span></span><br><span class="line">obj.Trigger();           <span class="comment">// 输出: ✅ 事件触发</span></span><br><span class="line"></span><br><span class="line">obj.MyEvent -= handler;  <span class="comment">// 输出: ➖ 移除订阅者</span></span><br><span class="line">obj.Trigger();           <span class="comment">// 没有输出</span></span><br></pre></td></tr></table></figure><p>通过自定义<code>add</code>和<code>remove</code>访问器，开发者可以完全控制事件的订阅和取消订阅过程，使得事件系统更加灵活和可控。</p><hr><h3 id="36-yield-语句"><a href="#36-yield-语句" class="headerlink" title="36. yield 语句"></a>36. yield 语句</h3><p><code>yield</code>语句在<code>C#</code>中用于实现迭代器，该语句使一个方法、<code>get</code>访问器或<code>operator</code>返回一个序列的元素而不必创建临时的集合。这对于在需要延迟执行或处理大数据集合时非常有用，因为它允许按需生成序列中的元素。<br><br></p><p>（1）基本概念</p><ul><li>迭代器: 一个对象，它实现了<code>IEnumerable</code>或<code>IEnumerator</code>接口，提供一种逐一访问序列中元素的方法，而无需暴露底层表示。</li><li>延迟执行: <code>yield</code>语句使得方法的执行在每次返回一个元素后可以暂停，并在下一次需要元素时恢复。这种特性被称为延迟执行。</li></ul><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ❌ 普通方法：一次性生成所有元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;<span class="built_in">int</span>&gt; <span class="title">GetNumbers</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> list = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;生成数字: <span class="subst">&#123;i&#125;</span>&quot;</span>);</span><br><span class="line">        list.Add(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ✅ yield：按需生成元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IEnumerable&lt;<span class="built_in">int</span>&gt; <span class="title">GetNumbersYield</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;生成数字: <span class="subst">&#123;i&#125;</span>&quot;</span>);</span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用对比</span></span><br><span class="line">Console.WriteLine(<span class="string">&quot;=== 普通方法 ===&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> numbers1 = GetNumbers();  <span class="comment">// 立即生成所有数字</span></span><br><span class="line">Console.WriteLine(<span class="string">&quot;开始遍历&quot;</span>);</span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> num <span class="keyword">in</span> numbers1)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">$&quot;使用: <span class="subst">&#123;num&#125;</span>&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出:</span></span><br><span class="line"><span class="comment">// 生成数字: 1</span></span><br><span class="line"><span class="comment">// 生成数字: 2</span></span><br><span class="line"><span class="comment">// 生成数字: 3</span></span><br><span class="line"><span class="comment">// 生成数字: 4</span></span><br><span class="line"><span class="comment">// 生成数字: 5</span></span><br><span class="line"><span class="comment">// 开始遍历</span></span><br><span class="line"><span class="comment">// 使用: 1</span></span><br><span class="line"><span class="comment">// 使用: 2</span></span><br><span class="line"><span class="comment">// 使用: 3</span></span><br><span class="line"><span class="comment">// 使用: 4</span></span><br><span class="line"><span class="comment">// 使用: 5</span></span><br><span class="line"></span><br><span class="line">Console.WriteLine(<span class="string">&quot;\n=== yield 方法 ===&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> numbers2 = GetNumbersYield();  <span class="comment">// 此时还没生成任何数字</span></span><br><span class="line">Console.WriteLine(<span class="string">&quot;开始遍历&quot;</span>);</span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> num <span class="keyword">in</span> numbers2)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">$&quot;使用: <span class="subst">&#123;num&#125;</span>&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出:</span></span><br><span class="line"><span class="comment">// 开始遍历</span></span><br><span class="line"><span class="comment">// 生成数字: 1</span></span><br><span class="line"><span class="comment">// 使用: 1</span></span><br><span class="line"><span class="comment">// 生成数字: 2</span></span><br><span class="line"><span class="comment">// 使用: 2</span></span><br><span class="line"><span class="comment">// 生成数字: 3</span></span><br><span class="line"><span class="comment">// 使用: 3</span></span><br><span class="line"><span class="comment">// 生成数字: 4</span></span><br><span class="line"><span class="comment">// 使用: 4</span></span><br><span class="line"><span class="comment">// 生成数字: 5</span></span><br><span class="line"><span class="comment">// 使用: 5</span></span><br></pre></td></tr></table></figure><p>（2）基本用法 <code>yield return</code> 和 <code>yield break</code></p><p><code>yield return</code>: 用于返回一个序列中的下一个元素，并暂停方法的执行，直到序列中的下一个元素被请求。<br><br></p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 生成 1 到 n 的数字</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IEnumerable&lt;<span class="built_in">int</span>&gt; <span class="title">GetRange</span>(<span class="params"><span class="built_in">int</span> n</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">return</span> i;  <span class="comment">// 返回一个元素并暂停</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="keyword">foreach</span> (<span class="function"><span class="built_in">int</span> num <span class="keyword">in</span> <span class="title">GetRange</span>(<span class="params"><span class="number">5</span></span>))</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(num);  <span class="comment">// 输出: 1, 2, 3, 4, 5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>yield break</code>: 用于终止迭代，立即退出迭代器块。<br><br></p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 生成素数，最多 n 个</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IEnumerable&lt;<span class="built_in">int</span>&gt; <span class="title">GetPrimes</span>(<span class="params"><span class="built_in">int</span> maxCount</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">int</span> number = <span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (IsPrime(number))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">return</span> number;</span><br><span class="line">            count++;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (count &gt;= maxCount)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">yield</span> <span class="keyword">break</span>;  <span class="comment">// 终止迭代</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        number++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="built_in">bool</span> <span class="title">IsPrime</span>(<span class="params"><span class="built_in">int</span> n</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">2</span>; i &lt;= Math.Sqrt(n); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (n % i == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="keyword">foreach</span> (<span class="function"><span class="built_in">int</span> prime <span class="keyword">in</span> <span class="title">GetPrimes</span>(<span class="params"><span class="number">5</span></span>))</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(prime);  <span class="comment">// 输出: 2, 3, 5, 7, 11</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>yield</code>的优点</p><ul><li>简化代码: 使用<code>yield</code>可以轻松地创建返回多个值的迭代器，而无需创建临时集合或手动实现 <code>IEnumerable</code>或<code>IEnumerator</code>接口。</li><li>节省内存: 由于<code>yield</code>语句支持延迟执行，它只在需要时生成元素，避免了一次性加载所有数据，节省了内存。</li><li>提高性能: 在处理大数据集或耗时的计算时，<code>yield</code>可以提高性能，因为它允许在序列中逐一访问元素，而不是一次性生成所有元素。</li></ul><hr><h3 id="37-async-关键字"><a href="#37-async-关键字" class="headerlink" title="37. async 关键字"></a>37. async 关键字</h3><p><code>async</code>关键字在<code>C#</code>中用于标识一个方法、<code>lambda</code>表达式或匿名方法是异步的。异步方法允许你在不阻塞调用线程的情况下执行长时间运行的操作（如<code>I/O</code>操作、网络请求等）。这种机制使得应用程序可以保持响应，而不需要为每个长时间运行的任务创建新线程。</p><ul><li>基本概念<ul><li>异步方法: 使用<code>async</code>关键字修饰的方法，它可以包含一个或多个<code>await</code>表达式。当异步方法执行到 <code>await</code>表达式时，它会异步地等待操作完成，而不阻塞当前线程。</li><li>返回类型: 异步方法通常返回<code>Task</code>或<code>Task&lt;T&gt;</code>对象，表示一个异步操作的结果。如果方法没有返回值，则返回<code>Task</code>；如果方法有返回值，则返回<code>Task&lt;T&gt;</code>，其中<code>T</code>是返回值的类型。</li></ul></li></ul><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Net.Http;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">async</span> Task <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span> url = <span class="string">&quot;https://jsonplaceholder.typicode.com/posts&quot;</span>;</span><br><span class="line">        <span class="built_in">string</span> result = <span class="keyword">await</span> FetchDataAsync(url);</span><br><span class="line">        Console.WriteLine(result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">async</span> Task&lt;<span class="built_in">string</span>&gt; <span class="title">FetchDataAsync</span>(<span class="params"><span class="built_in">string</span> url</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">using</span> (HttpClient client = <span class="keyword">new</span> HttpClient())</span><br><span class="line">        &#123;</span><br><span class="line">            HttpResponseMessage response = <span class="keyword">await</span> client.GetAsync(url);</span><br><span class="line">            response.EnsureSuccessStatusCode();</span><br><span class="line">            <span class="built_in">string</span> responseData = <span class="keyword">await</span> response.Content.ReadAsStringAsync();</span><br><span class="line">            <span class="keyword">return</span> responseData;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>重要注意事项<ul><li>异步所有: 异步方法内部调用的所有可能阻塞的操作也应尽可能使用异步版本。</li><li>错误处理: 在异步方法中，可以像处理同步代码中的异常一样使用<code>try-catch</code>进行异常处理。未处理的异常会在返回的<code>Task</code>对象上引发。</li></ul></li></ul><hr><h3 id="38-lambda-表达式"><a href="#38-lambda-表达式" class="headerlink" title="38. lambda 表达式"></a>38. lambda 表达式</h3><p><code>Lambda</code>表达式是<code>C#</code>中的一种匿名函数，它可以包含表达式或语句块，并且可以用来创建委托或表达式树类型。<code>Lambda</code>表达式提供了一种简洁的语法，用于定义内联的函数或将函数作为参数传递给方法。<code>Lambda</code>表达式通常用于<code>LINQ</code>查询、事件处理程序和函数式编程。<br><br></p><p>（1）使用单行表达式的<code>Lambda</code>表达式</p><p>在这个示例中，<code>multiply</code>是一个<code>Func&lt;int, int, int&gt;</code>类型的委托，它接受两个<code>int</code>参数并返回一个 <code>int</code>。<code>Lambda</code>表达式<code>(x, y) =&gt; x * y</code>定义了这个委托的实现。<br><br></p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Func&lt;<span class="built_in">int</span>, <span class="built_in">int</span>, <span class="built_in">int</span>&gt; multiply = (x, y) =&gt; x * y;</span><br><span class="line">Console.WriteLine(multiply(<span class="number">2</span>, <span class="number">3</span>)); <span class="comment">// 输出: 6</span></span><br></pre></td></tr></table></figure><p>（2）使用语句块的<code>Lambda</code>表达式</p><p>在这个示例中，<code>greet</code>是一个<code>Action&lt;string&gt;</code>类型的委托，它接受一个<code>string</code>参数并返回<code>void</code>。<code>Lambda</code>表达式<code>name =&gt; &#123; ... &#125;</code>使用了语句块来执行多行操作。<br><br></p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Action&lt;<span class="built_in">string</span>&gt; greet = name =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> greeting = <span class="string">$&quot;Hello, <span class="subst">&#123;name&#125;</span>!&quot;</span>;</span><br><span class="line">    Console.WriteLine(greeting);</span><br><span class="line">&#125;;</span><br><span class="line">greet(<span class="string">&quot;World&quot;</span>); <span class="comment">// 输出: Hello, World!</span></span><br></pre></td></tr></table></figure><p>（3）无参数的<code>Lambda</code>表达式</p><p>在这个示例中，<code>getRandomNumber</code>是一个<code>Func&lt;int&gt;</code>类型的委托，它不接受任何参数并返回一个<code>int</code>。<code>Lambda</code>表达式<code>() =&gt; new Random().Next(1, 100)</code>定义了一个没有参数的函数。<br><br></p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Func&lt;<span class="built_in">int</span>&gt; getRandomNumber = () =&gt; <span class="keyword">new</span> Random().Next(<span class="number">1</span>, <span class="number">100</span>);</span><br><span class="line">Console.WriteLine(getRandomNumber()); <span class="comment">// 输出一个随机数</span></span><br></pre></td></tr></table></figure><p>（4）单个参数的简写形式</p><p>在这个示例中，<code>square</code>是一个<code>Func&lt;int, int&gt;</code>类型的委托，它接受一个<code>int</code>参数并返回一个<code>int</code>。<code>Lambda</code>表达式<code>x =&gt; x * x</code>省略了参数类型和括号。<br><br></p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Func&lt;<span class="built_in">int</span>, <span class="built_in">int</span>&gt; square = x =&gt; x * x;</span><br><span class="line">Console.WriteLine(square(<span class="number">5</span>)); <span class="comment">// 输出: 25</span></span><br></pre></td></tr></table></figure><p>（5）<code>LINQ</code>查询</p><p><code>Lambda</code>表达式广泛用于<code>LINQ</code>查询中，作为查询表达式的条件和投影。<br><br></p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> numbers = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt; &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> evenNumbers = numbers.Where(n =&gt; n % <span class="number">2</span> == <span class="number">0</span>);</span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> number <span class="keyword">in</span> evenNumbers)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(number); <span class="comment">// 输出: 2, 4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（6）委托和事件处理</p><p><code>Lambda</code>表达式可以用来简洁地定义委托和事件处理程序。<br><br></p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Button btn = <span class="keyword">new</span> Button();</span><br><span class="line">btn.Click += (sender, e) =&gt; Console.WriteLine(<span class="string">&quot;Button clicked!&quot;</span>);</span><br></pre></td></tr></table></figure><hr><h3 id="39-匿名方法"><a href="#39-匿名方法" class="headerlink" title="39. 匿名方法"></a>39. 匿名方法</h3><p>匿名方法<code>Anonymous Methods</code>是<code>C#</code>中的一种定义委托实例的方式，它允许你在代码中直接声明一个没有名称的方法。匿名方法提供了一种简洁的方式来创建内联的委托，而不必显式地定义一个单独的方法。</p><ul><li>匿名方法使用<code>delegate</code>关键字，并且可以包含参数和方法体。</li></ul><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">DisplayMessage</span>(<span class="params"><span class="built_in">string</span> message</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 使用匿名方法定义委托实例</span></span><br><span class="line">        DisplayMessage display = <span class="built_in">delegate</span>(<span class="built_in">string</span> message)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(message);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用匿名方法</span></span><br><span class="line">        display(<span class="string">&quot;Hello, World!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>匿名方法和<code>Lambda</code>表达式比较</li></ul><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 匿名方法</span></span><br><span class="line">Func&lt;<span class="built_in">int</span>, <span class="built_in">int</span>&gt; square1 = <span class="built_in">delegate</span>(<span class="built_in">int</span> x) &#123; <span class="keyword">return</span> x * x; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Lambda 表达式</span></span><br><span class="line">Func&lt;<span class="built_in">int</span>, <span class="built_in">int</span>&gt; square2 = x =&gt; x * x;</span><br></pre></td></tr></table></figure><ul><li>何时使用匿名方法<ul><li>复杂逻辑: 当方法体包含复杂逻辑或多行代码时，可以选择使用匿名方法。</li><li>捕获多个变量: 需要捕获多个外部变量或参数时，匿名方法可以提供更清晰的语法结构。</li></ul></li></ul><hr><h3 id="40-泛型函数"><a href="#40-泛型函数" class="headerlink" title="40. 泛型函数"></a>40. 泛型函数</h3><p>泛型函数<code>Generic Functions</code>是指可以接受不同类型参数的函数。<code>C#</code>中的泛型函数通过在函数的定义中使用类型参数，使得函数可以独立于具体的数据类型来编写。在调用泛型函数时，具体的类型会被替换为实际使用的类型。这样，泛型函数可以在不重复编写代码的情况下适应多种数据类型。<br><br></p><p>（1）定义泛型函数<br>在<code>C#</code>中，泛型函数通过在方法名称后使用尖括号<code>&lt;T&gt;</code>形式的类型参数来定义，其中<code>T</code>是类型参数的占位符。可以有多个类型参数，例如<code>&lt;T, U&gt;</code>等。<br><br></p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Print&lt;<span class="built_in">int</span>&gt;(<span class="number">123</span>);        <span class="comment">// 输出: 123</span></span><br><span class="line">        Print&lt;<span class="built_in">string</span>&gt;(<span class="string">&quot;Hello&quot;</span>); <span class="comment">// 输出: Hello</span></span><br><span class="line">        Print&lt;<span class="built_in">double</span>&gt;(<span class="number">3.14</span>);    <span class="comment">// 输出: 3.14</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Print</span>&lt;<span class="title">T</span>&gt;(<span class="params">T <span class="keyword">value</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="keyword">value</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）多个类型参数<br>泛型函数可以有多个类型参数，使用逗号分隔。<br><br></p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Swap</span>&lt;<span class="title">T</span>, <span class="title">U</span>&gt;(<span class="params"><span class="keyword">ref</span> T first, <span class="keyword">ref</span> U second</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    T temp = first;</span><br><span class="line">    first = (T)(<span class="built_in">object</span>)second;</span><br><span class="line">    second = (U)(<span class="built_in">object</span>)temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个示例中，<code>Swap</code>方法使用了两个类型参数<code>T</code>和<code>U</code>，可以交换不同类型的变量。<br><br></p><p>（3）类型约束<br>可以对泛型类型参数施加约束，以限制可用的类型。例如，限制类型参数必须实现某个接口或继承自某个类。<br><br></p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Display</span>&lt;<span class="title">T</span>&gt;(<span class="params">T <span class="keyword">value</span></span>) <span class="keyword">where</span> T : IComparable&lt;T&gt;</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="keyword">value</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个示例中，<code>Display&lt;T&gt;</code>方法只能接受实现了<code>IComparable&lt;T&gt;</code>接口的类型。<br><br></p><p>泛型函数的优点</p><ul><li>代码重用: 泛型函数允许编写通用的代码，可以与不同的数据类型一起使用，而无需为每种类型编写重复的代码。</li><li>类型安全: 使用泛型可以在编译时检查类型一致性，避免运行时错误。</li><li>性能: 泛型函数不会像非泛型集合类那样引入装箱和拆箱操作（对于值类型），因此可以提高性能。</li></ul><hr><h3 id="41-LINQ-语言集成查询"><a href="#41-LINQ-语言集成查询" class="headerlink" title="41. LINQ (语言集成查询)"></a>41. LINQ (语言集成查询)</h3><p><code>LINQ</code>（语言集成查询）是<code>C#</code>提供的一种功能，使得开发者可以使用类似<code>SQL</code>的语法来查询和操作各种数据源，如对象集合、数据库、<code>XML</code>等。<code>LINQ</code>提供了一种统一的查询语法和机制，使得数据查询和操作更加简洁、类型安全和可维护。<br><br></p><p>（1）<code>LINQ</code>的基本概念</p><ul><li>统一的查询语法: 无论数据来源是什么，<code>LINQ</code>提供了统一的查询语法，简化了数据访问和操作的过程。</li><li>延迟执行: <code>LINQ</code>查询通常是延迟执行的，即只有在查询结果被真正访问时，才会执行查询。这可以提高性能，尤其是在处理大型数据集时。</li></ul><p>（2）<code>LINQ</code>查询语法</p><p>查询语法类似<code>SQL</code>，是一种声明式的语法，描述我们希望从数据源中提取什么样的数据。<br><br></p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span>[] numbers = &#123; <span class="number">5</span>, <span class="number">10</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">12</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> numQuery = <span class="keyword">from</span> num <span class="keyword">in</span> numbers</span><br><span class="line">               <span class="keyword">where</span> num % <span class="number">2</span> == <span class="number">0</span></span><br><span class="line">               <span class="keyword">orderby</span> num</span><br><span class="line">               <span class="keyword">select</span> num;</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span> (<span class="built_in">int</span> num <span class="keyword">in</span> numQuery)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（3）<code>LINQ</code>方法语法</p><p>方法语法使用标准查询运算符方法，这些方法是静态方法，可以像链条一样连接起来。<br><br></p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span>[] numbers = &#123; <span class="number">5</span>, <span class="number">10</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">12</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> numQuery = numbers.Where(num =&gt; num % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">                      .OrderBy(num =&gt; num)</span><br><span class="line">                      .Select(num =&gt; num);</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span> (<span class="built_in">int</span> num <span class="keyword">in</span> numQuery)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>LINQ</code>的核心概念之一就是它可以作用于实现了<code>IEnumerable&lt;T&gt;</code>接口的任何数据源。<br><br></p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        List&lt;<span class="built_in">int</span>&gt; numbers = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt; &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用 LINQ 查询</span></span><br><span class="line">        IEnumerable&lt;<span class="built_in">int</span>&gt; evenNumbers = numbers.Where(n =&gt; n % <span class="number">2</span> == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 枚举查询结果</span></span><br><span class="line">        <span class="keyword">foreach</span> (<span class="built_in">int</span> num <span class="keyword">in</span> evenNumbers)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(num); <span class="comment">// 输出: 2, 4</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总而言之，<code>LINQ</code>是<code>C#</code>中的一个强大功能，它提供了一个统一的方式来查询和操作各种数据源。通过 <code>LINQ</code>，开发者可以使用简单、清晰且类型安全的代码来执行复杂的数据操作。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ES6学习笔记 • 下</title>
      <link href="/posts/461e57d3.html"/>
      <url>/posts/461e57d3.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>本读书笔记节是针对阮一峰编写的 <a href="https://es6.ruanyifeng.com/">《ECMAScript 6 入门教程》</a>的总结。适合已经掌握 <code>ES5</code> 的读者，用来了解这门语言的最新发展。笔记内容仅包括日常开发中可能会用到的概念。</p></blockquote><hr><h2 id="20-async-函数"><a href="#20-async-函数" class="headerlink" title="20. async 函数"></a>20. async 函数</h2><h3 id="20-1-含义"><a href="#20-1-含义" class="headerlink" title="20.1 含义"></a>20.1 含义</h3><p><code>ES6</code>引入的 <code>async</code> 函数，使得异步操作变得更加方便。简单来说，<code>async</code> 函数就是 <code>Generator</code> 函数的语法糖。它将 <code>Generator</code>函数的星号<code>*</code>替换成<code>async</code>，<code>yield</code>替换成<code>await</code>。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> readFile = <span class="keyword">function</span> (<span class="params">fileName</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">    fs.<span class="title function_">readFile</span>(fileName, <span class="keyword">function</span> (<span class="params">error, data</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (error) <span class="keyword">return</span> <span class="title function_">reject</span>(error);</span><br><span class="line">      <span class="title function_">resolve</span>(data);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> gen = <span class="keyword">function</span>* () &#123;</span><br><span class="line">  <span class="keyword">const</span> f1 = <span class="keyword">yield</span> <span class="title function_">readFile</span>(<span class="string">&quot;/etc/fstab&quot;</span>);</span><br><span class="line">  <span class="keyword">const</span> f2 = <span class="keyword">yield</span> <span class="title function_">readFile</span>(<span class="string">&quot;/etc/shells&quot;</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(f1.<span class="title function_">toString</span>());</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(f2.<span class="title function_">toString</span>());</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面代码中，函数<code>gen</code>依次读取两个文件，如果写成<code>async</code>函数，就是下面这样。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> asyncReadFile = <span class="keyword">async</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> f1 = <span class="keyword">await</span> <span class="title function_">readFile</span>(<span class="string">&quot;/etc/fstab&quot;</span>);</span><br><span class="line">  <span class="keyword">const</span> f2 = <span class="keyword">await</span> <span class="title function_">readFile</span>(<span class="string">&quot;/etc/shells&quot;</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(f1.<span class="title function_">toString</span>());</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(f2.<span class="title function_">toString</span>());</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>async</code>函数对 <code>Generator</code> 函数的改进，体现在以下四点</p><ol><li>内置执行器: <code>Generator</code> 函数的执行必须靠执行器（<code>co</code>模块），而<code>async</code>函数自带执行器。也就是说，<code>async</code>函数的执行，与普通函数一模一样。</li><li>更好的语义: <code>async</code>和<code>await</code>，比起星号和<code>yield</code>，语义更清楚了。<code>async</code>表示函数里有异步操作，<code>await</code>表示紧跟在后面的表达式需要等待结果。</li><li>更广的适用性: <code>co</code>模块约定，<code>yield</code>命令后面只能是 <code>Thunk</code> 函数或 <code>Promise</code> 对象，而<code>async</code>函数的<code>await</code>命令后面，可以是 <code>Promise</code> 对象和原始类型的值。（数值、字符串和布尔值，但会自动转成立即 <code>resolved</code> 的 <code>Promise</code> 对象）</li><li>返回值是 Promise: <ins><code>async</code>函数的返回值是 <code>Promise</code> 对象</ins>，这比 <code>Generator</code> 函数的返回值是 <code>Iterator</code> 对象方便，可以用<code>then</code>方法指定下一步的操作。</li></ol><p>进一步说，<code>async</code>函数可以看作多个异步操作，包装成的一个 <code>Promise</code> 对象，而<code>await</code>命令就是可以替代<code>then</code>的语法糖。下面的 <code>Promise</code> 链可以被重写为一个 <code>async</code> 函数。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">fetch</span>(<span class="string">&quot;https://api.example.com/data&quot;</span>)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">response</span>) =&gt;</span> response.<span class="title function_">json</span>())</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">data</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(data))</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function">(<span class="params">error</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&quot;Error:&quot;</span>, error));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">fetchData</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> response = <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="string">&quot;https://api.example.com/data&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> data = <span class="keyword">await</span> response.<span class="title function_">json</span>();</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&quot;Error:&quot;</span>, error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="20-2-基本用法"><a href="#20-2-基本用法" class="headerlink" title="20.2 基本用法"></a>20.2 基本用法</h3><p><ins><code>async</code>函数返回一个 <code>Promise</code> 对象，可以使用<code>then</code>方法添加回调函数</ins>。当函数执行的时候，<ins>遇到<code>await</code>就会暂停当前的<code>async</code>函数执行，等到异步操作完成，再接着执行函数体内后面的语句</ins>。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">fetchUserData</span>(<span class="params">userId</span>) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 这里假设我们有一个返回Promise的fetch函数</span></span><br><span class="line">    <span class="keyword">const</span> response = <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="string">`https://api.example.com/user/<span class="subst">$&#123;userId&#125;</span>`</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 需要检查响应是否ok，如果不ok则抛出错误</span></span><br><span class="line">    <span class="keyword">if</span> (!response.<span class="property">ok</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">`HTTP error! status: <span class="subst">$&#123;response.status&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> user = <span class="keyword">await</span> response.<span class="title function_">json</span>(); <span class="comment">// 假设服务器响应的是JSON数据</span></span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(</span><br><span class="line">      <span class="string">`There was a problem with the fetch operation: <span class="subst">$&#123;error.message&#125;</span>`</span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用这个函数</span></span><br><span class="line"><span class="title function_">fetchUserData</span>(<span class="number">123</span>)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">user</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(user))</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function">(<span class="params">error</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">error</span>(error));</span><br></pre></td></tr></table></figure><p>上面代码中，<code>fetchUserData</code>是一个异步函数，它使用<code>fetchAPI</code>从服务器获取数据，然后使用<code>await</code>关键字等待<code>Promise</code>解决。注意，在异步函数中，我们应该始终使用<code>try/catch</code>来捕获可能出现的错误。<br><br></p><p><code>async</code>函数有多种使用形式。它可以作为声明，作为表达式，还可以用来定义对象或类的方法。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数表达式</span></span><br><span class="line"><span class="keyword">const</span> foo = <span class="keyword">async</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象的方法</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123; <span class="keyword">async</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;&#125; &#125;;</span><br><span class="line">obj.<span class="title function_">foo</span>().<span class="title function_">then</span>(...)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Class 的方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Storage</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">cachePromise</span> = caches.<span class="title function_">open</span>(<span class="string">&#x27;avatars&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">async</span> <span class="title function_">getAvatar</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> cache = <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="property">cachePromise</span>;</span><br><span class="line">    <span class="keyword">return</span> cache.<span class="title function_">match</span>(<span class="string">`/avatars/<span class="subst">$&#123;name&#125;</span>.jpg`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> storage = <span class="keyword">new</span> <span class="title class_">Storage</span>();</span><br><span class="line">storage.<span class="title function_">getAvatar</span>(<span class="string">&#x27;jake&#x27;</span>).<span class="title function_">then</span>(…);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 箭头函数</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">foo</span> = <span class="keyword">async</span> (<span class="params"></span>) =&gt; &#123;&#125;;</span><br></pre></td></tr></table></figure><hr><h3 id="20-3-语法"><a href="#20-3-语法" class="headerlink" title="20.3 语法"></a>20.3 语法</h3><p><code>async</code>函数的语法规则总体上比较简单，难点是错误处理机制。<br><br></p><p><strong>（1）返回 Promise 对象</strong></p><p><ins><code>async</code>函数返回一个 <code>Promise</code> 对象</ins>（不管有没有<code>return</code>语句，总是返回一个 <code>Promise</code> 对象）。<ins><code>async</code>函数内部<code>return</code>语句返回的值，会成为<code>then</code>方法回调函数的参数</ins>。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">f</span>().<span class="title function_">then</span>(<span class="function">(<span class="params">v</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(v));</span><br><span class="line"><span class="comment">// &quot;hello world&quot;</span></span><br></pre></td></tr></table></figure><p>上面代码中，函数<code>f</code>内部<code>return</code>命令返回的值，会被<code>then</code>方法回调函数接收到。<br><br></p><p><ins><code>async</code>函数内部抛出错误，会导致返回的 <code>Promise</code> 对象变为<code>reject</code>状态</ins>。抛出的错误对象会被<code>catch</code>方法回调函数接收到。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;出错了&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">f</span>()</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">v</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;resolve&quot;</span>, v))</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function">(<span class="params">e</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;reject&quot;</span>, e));</span><br></pre></td></tr></table></figure><p><strong>（2）Promise 对象的状态变化</strong></p><p><code>async</code>函数返回的 <code>Promise</code> 对象，必须等到内部所有<code>await</code>命令后面的 <code>Promise</code> 对象执行完，才会发生状态改变，除非遇到<code>return</code>语句或者抛出错误。也就是说，<ins>只有<code>async</code>函数内部的异步操作执行完，才会执行<code>then</code>方法指定的回调函数</ins>。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">asyncFunc</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> response = <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="string">&quot;https://api.example.com/data&quot;</span>);</span><br><span class="line">  <span class="keyword">const</span> data = <span class="keyword">await</span> response.<span class="title function_">json</span>();</span><br><span class="line">  <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">asyncFunc</span>()</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">data</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(data))</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function">(<span class="params">error</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">error</span>(error));</span><br></pre></td></tr></table></figure><p>上面代码中，<code>then</code>方法的回调函数会等到<code>asyncFunc</code>函数内部的两个<code>await</code>操作都完成后才会被调用。<br><br></p><p><strong>（3）await 命令</strong></p><p>正常情况下，<ins><code>await</code>命令后面是一个 <code>Promise</code> 对象，返回该对象的结果。如果不是 <code>Promise</code> 对象，就直接返回对应的值</ins>。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 等同于</span></span><br><span class="line">  <span class="comment">// return 123;</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">await</span> <span class="number">123</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">f</span>().<span class="title function_">then</span>(<span class="function">(<span class="params">v</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(v));</span><br><span class="line"><span class="comment">// 123</span></span><br></pre></td></tr></table></figure><p>另一种情况是，<code>await</code>命令后面是一个<code>thenable</code>对象（即定义了<code>then</code>方法的对象，详细请看<code>Promise</code>章节的<code>resolve()</code>方法），那么<code>await</code>会将其等同于 <code>Promise</code> 对象。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> thenable = &#123;</span><br><span class="line">  <span class="attr">then</span>: <span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="string">&quot;Resolved!&quot;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">asyncFunc</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="keyword">await</span> thenable;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(result); <span class="comment">// &#x27;Resolved!&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">asyncFunc</span>();</span><br><span class="line"><span class="comment">// 1000</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>thenable</code>对象有一个<code>then</code>方法，所以可以在<code>asyncFunc</code>函数中使用<code>await</code>来等待它。<ins>当<code>JS</code>引擎看到我们试图等待一个<code>thenable</code>对象时，它会自动调用该对象的<code>then</code>方法</ins>，并等待该方法调用其<code>resolve</code>参数所传入的值。<br><br></p><p>如果<ins><code>await</code>命令后面的 <code>Promise</code> 对象如果变为<code>reject</code>状态，则<code>reject</code>的参数会被<code>catch</code>方法的回调函数接收到</ins>。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="string">&quot;出错了&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">f</span>()</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">v</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(v))</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function">(<span class="params">e</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(e));</span><br><span class="line"><span class="comment">// 出错了</span></span><br></pre></td></tr></table></figure><p>注意，上面代码中<code>await</code>语句前面没有<code>return</code>，但是<code>reject</code>方法的参数依然传入了<code>catch</code>方法的回调函数。这里如果在<code>await</code>前面加上<code>return</code>，效果是一样的。<br><br></p><p><ins>任何一个<code>await</code>语句后面的 <code>Promise</code> 对象变为<code>reject</code>状态，不会导致整个 <code>async</code> 函数立即停止执行，而是会抛出异常。我们可以用 <code>try/catch</code> 语句来捕获这个异常并处理它。</ins>（如果没有错误处理机制，<code>async</code>函数会中断执行）<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 情况 1</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="string">&quot;出错了&quot;</span>);</span><br><span class="line">  <span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&quot;hello world&quot;</span>); <span class="comment">// 不会执行</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 情况 2</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">asyncFunc</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> response = <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="string">&quot;https://api.example.com/data&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> data = <span class="keyword">await</span> response.<span class="title function_">json</span>();</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&quot;Error:&quot;</span>, error);</span><br><span class="line">    <span class="comment">// 这里可以处理错误，并决定如何继续执行</span></span><br><span class="line">    <span class="comment">// 比如可以重新抛出错误，或者返回一个默认值，等等</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有时我们希望<ins>即使前一个异步操作失败，也不要中断后面的异步操作</ins>。我们可以将<code>await</code>放在<code>try...catch</code>结构里面，这样不管这个异步操作是否成功，下一个<code>await</code>都会执行。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="string">&quot;出错了&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(e);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">f</span>().<span class="title function_">then</span>(<span class="function">(<span class="params">v</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(v));</span><br><span class="line"><span class="comment">// 出错了</span></span><br><span class="line"><span class="comment">// hello world</span></span><br></pre></td></tr></table></figure><p>另一种方法是<code>await</code>后面的 <code>Promise</code> 对象再跟一个<code>catch</code>方法，处理前面可能出现的错误。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="string">&quot;出错了&quot;</span>).<span class="title function_">catch</span>(<span class="function">(<span class="params">e</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(e));</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">f</span>().<span class="title function_">then</span>(<span class="function">(<span class="params">v</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(v));</span><br><span class="line"><span class="comment">// 出错了</span></span><br><span class="line"><span class="comment">// hello world</span></span><br></pre></td></tr></table></figure><p>这种方法的优点是它更加紧凑，不需要显式地使用<code>try/catch</code>。但它的缺点是需要确保每个可能产生错误的<code>await</code>都有一个<code>catch</code>方法，否则错误可能会被忽视。<br><br></p><p><strong>（4）错误处理</strong></p><p>如果<ins><code>await</code>后面的异步操作出错，那么等同于<code>async</code>函数返回的 <code>Promise</code> 对象被<code>reject</code></ins>。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">asyncFunc</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> response = <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="string">&quot;https://api.example.com/data&quot;</span>);</span><br><span class="line">  <span class="comment">// 如果 fetch 出错（例如，由于网络问题），那么下面的代码将不会被执行</span></span><br><span class="line">  <span class="keyword">let</span> data = <span class="keyword">await</span> response.<span class="title function_">json</span>();</span><br><span class="line">  <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">asyncFunc</span>()</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">data</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(data))</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function">(<span class="params">error</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&quot;Error:&quot;</span>, error));</span><br><span class="line"><span class="comment">// 如果 asyncFunc 在任何地方抛出了一个错误，那么这个 .catch 将会捕获到</span></span><br></pre></td></tr></table></figure><p>上面代码中，如果<code>fetch</code>函数抛出一个错误，那么<code>asyncFunc</code>会立即停止执行并抛出一个错误，导致它返回的<code>Promise</code>变为<code>rejected</code>状态。这个错误然后被<code>catch</code>捕获并处理。<br><br></p><p>防止出错的方法，就是将其放在<code>try...catch</code>代码块之中。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;出错了&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(e);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">await</span> <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果有多个<code>await</code>命令，可以统一放在<code>try...catch</code>结构中。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> val1 = <span class="keyword">await</span> <span class="title function_">firstStep</span>();</span><br><span class="line">    <span class="keyword">const</span> val2 = <span class="keyword">await</span> <span class="title function_">secondStep</span>(val1);</span><br><span class="line">    <span class="keyword">const</span> val3 = <span class="keyword">await</span> <span class="title function_">thirdStep</span>(val1, val2);</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Final: &quot;</span>, val3);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(err);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，上面三个异步操作是串行处理，即<code>secondStep</code>将在<code>firstStep</code>完成后开始。如果这三个操作之间没有依赖关系，可以使用<code>Promise.all()</code>并行执行以提高效率。<br><br></p><p><strong>（5）使用注意点</strong></p><p>第一点，<code>await</code>命令后面的<code>Promise</code>对象，运行结果可能是<code>rejected</code>，所以<ins>最好把<code>await</code>命令放在<code>try...catch</code>代码块中</ins>。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">myFunction</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">somethingThatReturnsAPromise</span>();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(err);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 另一种写法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">myFunction</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="title function_">somethingThatReturnsAPromise</span>().<span class="title function_">catch</span>(<span class="keyword">function</span> (<span class="params">err</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(err);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二点，<ins>多个<code>await</code>命令后面的异步操作，如果不存在继发关系，最好让它们同时触发</ins>。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> foo = <span class="keyword">await</span> <span class="title function_">getFoo</span>();</span><br><span class="line"><span class="keyword">let</span> bar = <span class="keyword">await</span> <span class="title function_">getBar</span>();</span><br></pre></td></tr></table></figure><p>上面代码中，<code>getFoo</code>和<code>getBar</code>是两个独立的异步操作（即互不依赖），被写成继发关系。这样比较耗时，因为只有<code>getFoo</code>完成以后，才会执行<code>getBar</code>，完全可以让它们同时触发。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="keyword">let</span> [foo, bar] = <span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">all</span>([<span class="title function_">getFoo</span>(), <span class="title function_">getBar</span>()]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="keyword">let</span> fooPromise = <span class="title function_">getFoo</span>();</span><br><span class="line"><span class="keyword">let</span> barPromise = <span class="title function_">getBar</span>();</span><br><span class="line"><span class="keyword">let</span> foo = <span class="keyword">await</span> fooPromise;</span><br><span class="line"><span class="keyword">let</span> bar = <span class="keyword">await</span> barPromise;</span><br></pre></td></tr></table></figure><p>上面两种写法，<code>getFoo</code>和<code>getBar</code>都是同时触发，这样就会缩短程序的执行时间。<br><br></p><p>第三点，<code>await</code>命令只能用在<code>async</code>函数之中，如果用在普通函数，就会报错。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">dbFuc</span>(<span class="params">db</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 报错</span></span><br><span class="line">  docs.<span class="title function_">forEach</span>(<span class="keyword">function</span> (<span class="params">doc</span>) &#123;</span><br><span class="line">    <span class="keyword">await</span> db.<span class="title function_">post</span>(doc);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码会报错，因为<code>await</code>用在普通函数之中。但是，就算将<code>forEach</code>方法的参数改成<code>async</code>函数也有问题。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">dbFuc</span>(<span class="params">db</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 可能得到错误结果</span></span><br><span class="line">  docs.<span class="title function_">forEach</span>(<span class="keyword">async</span> <span class="keyword">function</span> (<span class="params">doc</span>) &#123;</span><br><span class="line">    <span class="keyword">await</span> db.<span class="title function_">post</span>(doc);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码可能不会正常工作，原因是这时三个<code>db.post()</code>操作将是并发执行（<code>forEach</code> 不会等待回调函数），也就是同时执行，而不是继发执行。正确的写法是采用<code>for</code>循环。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">dbFuc</span>(<span class="params">db</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> doc <span class="keyword">of</span> docs) &#123;</span><br><span class="line">    <span class="keyword">await</span> db.<span class="title function_">post</span>(doc);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一种方法是使用数组的<a href="https://www.javascripttutorial.net/javascript-array-reduce/"><code>reduce()</code></a>方法来逐个顺序处理数组中的元素。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">dbFunc</span>(<span class="params">db</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">await</span> docs.<span class="title function_">reduce</span>(<span class="keyword">async</span> (prevPromise, doc) =&gt; &#123;</span><br><span class="line">    <span class="keyword">await</span> prevPromise;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">await</span> db.<span class="title function_">post</span>(doc);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&quot;An error occurred: &quot;</span>, error);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, <span class="title class_">Promise</span>.<span class="title function_">resolve</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，传递给<code>reduce()</code>的函数返回一个<code>Promise</code>，这个<code>Promise</code>在前一个 <code>Promise</code>解析之后开始另一项数据库操作。我们使用<code>Promise.resolve()</code>作为初始值，以开始 <code>Promise</code>链。<br><br></p><p>如果希望<ins>多个请求并发执行，可以使用<code>Promise.all()</code>方法</ins>。下面两种写法效果相同。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">dbFuc</span>(<span class="params">db</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];</span><br><span class="line">  <span class="keyword">let</span> promises = docs.<span class="title function_">map</span>(<span class="function">(<span class="params">doc</span>) =&gt;</span> db.<span class="title function_">post</span>(doc));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> results = <span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">all</span>(promises);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(results);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者使用下面的写法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">dbFuc</span>(<span class="params">db</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];</span><br><span class="line">  <span class="keyword">let</span> promises = docs.<span class="title function_">map</span>(<span class="function">(<span class="params">doc</span>) =&gt;</span> db.<span class="title function_">post</span>(doc));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> results = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> promise <span class="keyword">of</span> promises) &#123;</span><br><span class="line">    results.<span class="title function_">push</span>(<span class="keyword">await</span> promise);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(results);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第四点，<code>async</code> 函数可以保留运行堆栈。它会在等待<code>Promise</code>解析期间暂停函数的执行，而不是在全局范围内阻止执行，这使得调试工具能够在可能发生错误的地方停下来。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">a</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="title function_">b</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="title function_">c</span>());</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面代码中，假定函数<code>a</code>内部运行了一个异步任务<code>b()</code>。当<code>b()</code>运行的时候，函数<code>a()</code>不会中断，而是继续执行。<ins>等到<code>b()</code>运行结束，可能<code>a()</code>早就运行结束了，<code>b()</code>所在的上下文环境已经消失了</ins>。如果<code>b()</code>或<code>c()</code>报错，<a href="https://zhuanlan.zhihu.com/p/26637923">错误堆栈</a>将不包括<code>a()</code>。<br><br></p><p>现在将这个例子改成<code>async</code>函数。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">a</span> = <span class="keyword">async</span> (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="title function_">b</span>();</span><br><span class="line">  <span class="title function_">c</span>();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>b()</code>运行的时候，<code>a()</code>是暂停执行，上下文环境都保存着。一旦<code>b()</code>或<code>c()</code>报错，错误堆栈将包括<code>a()</code>。</p><hr><h3 id="20-4-async-函数实现原理"><a href="#20-4-async-函数实现原理" class="headerlink" title="20.4 async 函数实现原理"></a>20.4 async 函数实现原理</h3><p><code>async</code> 函数的实现原理，就是将 <code>Generator</code> 函数和自动执行器，包装在一个函数里。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">args</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">args</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">spawn</span>(<span class="keyword">function</span>* () &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所有的<code>async</code>函数都可以写成上面的第二种形式，其中的<code>spawn</code>函数就是自动执行器。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">spawn</span>(<span class="params">genF</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> gen = <span class="title function_">genF</span>(); <span class="comment">// 建立 Generater 函数</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">step</span>(<span class="params">nextF</span>) &#123;</span><br><span class="line">      <span class="comment">// nextF 是一个 Generater 函数</span></span><br><span class="line">      <span class="keyword">let</span> next;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        next = <span class="title function_">nextF</span>(); <span class="comment">// 启动 Generater，返回当前状态，运行至下一个 yield</span></span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">reject</span>(e);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (next.<span class="property">done</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">resolve</span>(next.<span class="property">value</span>); <span class="comment">// 结束执行器</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(next.<span class="property">value</span>).<span class="title function_">then</span>(</span><br><span class="line">        <span class="keyword">function</span> (<span class="params">v</span>) &#123;</span><br><span class="line">          <span class="title function_">step</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> gen.<span class="title function_">next</span>(v);</span><br><span class="line">          &#125;); <span class="comment">// 开始递归</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">          <span class="title function_">step</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> gen.<span class="keyword">throw</span>(e);</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 传递一个 function，用来启动 Generater，第一次传参是无效的</span></span><br><span class="line">    <span class="title function_">step</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> gen.<span class="title function_">next</span>(<span class="literal">undefined</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="20-5-异步处理方法的比较"><a href="#20-5-异步处理方法的比较" class="headerlink" title="20.5 异步处理方法的比较"></a>20.5 异步处理方法的比较</h3><p>通过一个例子，我们来看看 <code>async</code> 函数与 <code>Promise</code>、<code>Generator</code> 函数的比较。</p><ul><li>假定某个 <code>DOM</code> 元素上面，部署了一系列的动画，前一个动画结束，才能开始后一个。如果当中有一个动画出错，就不再往下执行，返回上一个成功执行的动画的返回值。</li></ul><p>首先是 <code>Promise</code> 的写法。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">chainAnimationsPromise</span>(<span class="params">elem, animations</span>) &#123;</span><br><span class="line">  <span class="comment">// 变量 ret 用来保存上一个动画的返回值</span></span><br><span class="line">  <span class="keyword">let</span> ret = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始化一个已解决的 Promise</span></span><br><span class="line">  <span class="keyword">let</span> p = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 遍历 animations 数组中的每个动画</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> anim <span class="keyword">of</span> animations) &#123;</span><br><span class="line">    <span class="comment">// 将每个动画链接到 Promise 链</span></span><br><span class="line">    p = p.<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">val</span>) &#123;</span><br><span class="line">      <span class="comment">// 保存前一个动画的解决值</span></span><br><span class="line">      ret = val;</span><br><span class="line">      <span class="comment">// 执行当前动画并返回新的 Promise</span></span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">anim</span>(elem);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 任何一个动画的 Promise 被拒绝，将被 catch 捕捉</span></span><br><span class="line">  <span class="keyword">return</span> p</span><br><span class="line">    .<span class="title function_">catch</span>(<span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">      <span class="comment">/* 忽略错误，继续执行 */</span></span><br><span class="line">    &#125;)</span><br><span class="line">    .<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然 <code>Promise</code> 的写法比回调函数的写法大大改进，但是一眼看上去，代码完全都是 <code>Promise</code> 的 <code>API</code>，操作本身的语义反而不容易看出来。<br><br></p><p>接着是 <code>Generator</code> 函数的写法。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">chainAnimationsGenerator</span>(<span class="params">elem, animations</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">spawn</span>(<span class="keyword">function</span>* () &#123;</span><br><span class="line">    <span class="keyword">let</span> ret = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> anim <span class="keyword">of</span> animations) &#123;</span><br><span class="line">        ret = <span class="keyword">yield</span> <span class="title function_">anim</span>(elem);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="comment">/* 忽略错误，继续执行 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码使用 <code>Generator</code> 函数遍历了每个动画，语义比 <code>Promise</code> 写法更清晰，用户定义的操作全部都写在<code>spawn</code>函数的内部。但是，这个写法必须提供一个任务运行器，自动执行 <code>Generator</code> 函数，而且必须保证<code>yield</code>语句后面的表达式返回一个 <code>Promise</code>。<br><br></p><p>最后是 <code>async</code> 函数的写法。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">chainAnimationsAsync</span>(<span class="params">elem, animations</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> ret = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> anim <span class="keyword">of</span> animations) &#123;</span><br><span class="line">      ret = <span class="keyword">await</span> <span class="title function_">anim</span>(elem);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="comment">/* 忽略错误，继续执行 */</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到 <code>Async</code> 函数的实现最简洁，最符合语义。它将 <code>Generator</code> 写法中的自动执行器，改在语言层面提供，不暴露给用户，因此代码量最少。</p><hr><h3 id="20-6-按顺序完成异步操作"><a href="#20-6-按顺序完成异步操作" class="headerlink" title="20.6 按顺序完成异步操作"></a>20.6 按顺序完成异步操作</h3><p>实际开发中，会遇到一组异步操作需要按照顺序完成的情况。比如，依次远程读取一组 <code>URL</code>，然后按照读取的顺序输出结果。<br><br></p><p><code>Promise</code> 的写法如下。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">logInOrder</span>(<span class="params">urls</span>) &#123;</span><br><span class="line">  <span class="comment">// 远程读取所有URL</span></span><br><span class="line">  <span class="keyword">const</span> textPromises = urls.<span class="title function_">map</span>(<span class="function">(<span class="params">url</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">fetch</span>(url).<span class="title function_">then</span>(<span class="function">(<span class="params">response</span>) =&gt;</span> response.<span class="title function_">text</span>());</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 按次序输出</span></span><br><span class="line">  <span class="comment">// chain 代表当前的 Promise 链，初始值是 Promise.resolve()</span></span><br><span class="line">  textPromises.<span class="title function_">reduce</span>(<span class="function">(<span class="params">chain, textPromise</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 返回的是一个新的 Promise</span></span><br><span class="line">    <span class="keyword">return</span> chain</span><br><span class="line">      .<span class="title function_">then</span>(<span class="function">() =&gt;</span> textPromise) <span class="comment">// 返回当前正在处理的 textPromise</span></span><br><span class="line">      .<span class="title function_">then</span>(<span class="function">(<span class="params">text</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(text));</span><br><span class="line">  &#125;, <span class="title class_">Promise</span>.<span class="title function_">resolve</span>()); <span class="comment">// 初始化 Promise 链</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码使用<code>fetch</code>方法，同时远程读取一组 <code>URL</code>。每个<code>fetch</code>操作都返回一个 <code>Promise</code> 对象，放入<code>textPromises</code>数组。然后，<code>reduce</code>方法依次处理每个 <code>Promise</code> 对象，然后使用<code>then</code>，将所有 <code>Promise</code> 对象连起来，因此就可以依次输出结果。<br><br></p><p>这种写法可读性比较差。下面是 <code>async</code> 函数实现。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">logInOrder</span>(<span class="params">urls</span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> url <span class="keyword">of</span> urls) &#123;</span><br><span class="line">    <span class="keyword">const</span> response = <span class="keyword">await</span> <span class="title function_">fetch</span>(url);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">await</span> response.<span class="title function_">text</span>());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码确实大大简化，<ins>问题是所有远程操作都是继发。只有前一个 <code>URL</code> 返回结果，才会去读取下一个 <code>URL</code></ins>，这样做效率很差，我们需要的是并发发出远程请求。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">logInOrder</span>(<span class="params">urls</span>) &#123;</span><br><span class="line">  <span class="comment">// 并发读取远程URL</span></span><br><span class="line">  <span class="keyword">const</span> textPromises = urls.<span class="title function_">map</span>(<span class="keyword">async</span> (url) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> response = <span class="keyword">await</span> <span class="title function_">fetch</span>(url);</span><br><span class="line">    <span class="keyword">return</span> response.<span class="title function_">text</span>();</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 按次序输出</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> textPromise <span class="keyword">of</span> textPromises) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">await</span> textPromise);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>urls.map</code> 方法会对 <code>urls</code> 数组的每个元素执行一个异步函数，这个异步函数会远程读取<code>URL</code>，然后等待响应。所有的这些操作都在 <code>map</code> 方法调用的同时开始，所以这些操作是并发的。<br><br></p><p>注意，在这个异步函数中，<code>await fetch(url)</code> 会暂停函数的执行，直到 <code>fetch</code> 操作完成。但是，这并不会阻止其他操作，因为每个元素都在自己的异步函数中处理。因此，<code>textPromises</code> 是一个包含<code>Promise</code>的数组，每个<code>Promise</code>都代表一个正在进行的异步操作。</p><hr><h3 id="20-7-异步操作继发与并发"><a href="#20-7-异步操作继发与并发" class="headerlink" title="20.7 异步操作继发与并发"></a>20.7 异步操作继发与并发</h3><p>继发执行异步操作意味着等待一个操作完成后再执行下一个操作。<br><br></p><p>（1）使用 Promise 链<br>下面代码中，<code>func1</code>, <code>func2</code> 和 <code>func3</code> 是返回<code>Promise</code>的异步函数。这个代码段创建了一个<code>Promise</code>链，依次调用每个函数，并在所有函数都完成后输出一条消息。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>();</span><br><span class="line"></span><br><span class="line">[func1, func2, func3].<span class="title function_">forEach</span>(<span class="function">(<span class="params">func</span>) =&gt;</span> &#123;</span><br><span class="line">  promise = promise.<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="title function_">func</span>());</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise.<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;All async operations finished.&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>（2）使用 Promise 链 II<br>下面代码中，每一个 <code>then</code> 里面返回一个新的 <code>Promise</code>，这样只有前一个 <code>Promise</code> 状态变为 <code>resolved</code>，后一个 <code>Promise</code> 才会开始执行。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">doAsyncOperation1</span>()</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">result1</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(result1);</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">doAsyncOperation2</span>();</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">result2</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(result2);</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">doAsyncOperation3</span>();</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">result3</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(result3);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(error);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>（3）使用 async&#x2F;await<br>下面代码中，<code>func1</code>, <code>func2</code> 和 <code>func3</code>也是返回<code>Promise</code>的异步函数。<code>runInSequence</code>函数使用<code>await</code>关键字依次等待每个函数完成，然后输出一条消息。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">runInSequence</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="title function_">func1</span>();</span><br><span class="line">  <span class="keyword">await</span> <span class="title function_">func2</span>();</span><br><span class="line">  <span class="keyword">await</span> <span class="title function_">func3</span>();</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;All async operations finished.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">runInSequence</span>();</span><br></pre></td></tr></table></figure><p>（4）使用 for…of 循环<br>这个例子和前一个例子类似，但是<code>runInSequence</code>函数接受一个函数数组，并使用<code>for...of</code>循环来依次调用它们。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">runInSequence</span>(<span class="params">functions</span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> func <span class="keyword">of</span> functions) &#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">func</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;All async operations finished.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">runInSequence</span>([func1, func2, func3]);</span><br></pre></td></tr></table></figure><p>并发执行异步操作是指同时开始多个异步操作，并在它们都完成后进行下一步。<br><br></p><p>（1）使用 Promise.all()<br>下面代码中，三个<code>promise</code>会同时开始，并行执行。只有当这三个操作都成功完成，<code>Promise.all()</code> 才会解决。如果任何一个操作失败，那么 <code>Promise.all()</code> 也会立即被 <code>reject</code>，不再等待其他操作。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> promise1 = <span class="title function_">doAsyncOperation1</span>();</span><br><span class="line"><span class="keyword">let</span> promise2 = <span class="title function_">doAsyncOperation2</span>();</span><br><span class="line"><span class="keyword">let</span> promise3 = <span class="title function_">doAsyncOperation3</span>();</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">all</span>([promise1, promise2, promise3])</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">[result1, result2, result3]</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(result1, result2, result3);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(err);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>（2）使用 Promise.allSettled()<br><code>Promise.allSettled()</code> 的行为与 <code>Promise.all()</code> 类似，但是它会等待所有操作完成，无论成功还是失败。这对于希望了解所有操作的结果，而不仅仅是第一个失败的操作很有用。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> promise1 = <span class="title function_">doAsyncOperation1</span>();</span><br><span class="line"><span class="keyword">let</span> promise2 = <span class="title function_">doAsyncOperation2</span>();</span><br><span class="line"><span class="keyword">let</span> promise3 = <span class="title function_">doAsyncOperation3</span>();</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">allSettled</span>([promise1, promise2, promise3]).<span class="title function_">then</span>(<span class="function">(<span class="params">results</span>) =&gt;</span> &#123;</span><br><span class="line">  results.<span class="title function_">forEach</span>(<span class="function">(<span class="params">result, index</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (result.<span class="property">status</span> === <span class="string">&quot;fulfilled&quot;</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Operation <span class="subst">$&#123;index + <span class="number">1</span>&#125;</span> succeeded with <span class="subst">$&#123;result.value&#125;</span>`</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Operation <span class="subst">$&#123;index + <span class="number">1</span>&#125;</span> failed with <span class="subst">$&#123;result.reason&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>（3）使用 async&#x2F;await 结合 for..of<br>这种方法可以并发启动多个异步操作，但等待结果的顺序依然是串行的。也就是说，这种方法不会阻止异步操作的启动，但会按顺序等待每个异步操作的结果。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> urls = [<span class="string">&quot;url1&quot;</span>, <span class="string">&quot;url2&quot;</span>, <span class="string">&quot;url3&quot;</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> requests = urls.<span class="title function_">map</span>(<span class="function">(<span class="params">url</span>) =&gt;</span> <span class="title function_">fetch</span>(url));</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> request <span class="keyword">of</span> requests) &#123;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="keyword">await</span> request;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="20-8-顶层-await"><a href="#20-8-顶层-await" class="headerlink" title="20.8 顶层 await"></a>20.8 顶层 await</h3><p>早期的语法规定，<code>await</code>命令只能出现在 <code>async</code> 函数内部，否则报错。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">const</span> data = <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="string">&quot;https://api.example.com&quot;</span>);</span><br></pre></td></tr></table></figure><p>上面代码中，<code>await</code>命令独立使用，没有放在 <code>async</code> 函数里面，就会报错。<br><br></p><p>从 <a href="https://github.com/tc39/proposal-top-level-await">ES6</a> 开始，允许在模块的顶层独立使用<code>await</code>命令，使得上面那行代码不会报错了。它的主要目的是使用<code>await</code>解决模块异步加载的问题。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// awaiting.js</span></span><br><span class="line"><span class="keyword">let</span> output;</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> dynamic = <span class="keyword">await</span> <span class="keyword">import</span>(someMission);</span><br><span class="line">  <span class="keyword">const</span> data = <span class="keyword">await</span> <span class="title function_">fetch</span>(url);</span><br><span class="line">  output = <span class="title function_">someProcess</span>(dynamic.<span class="property">default</span>, data);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">main</span>();</span><br><span class="line"><span class="keyword">export</span> &#123; output &#125;;</span><br></pre></td></tr></table></figure><p>上面代码中，模块<code>awaiting.js</code>的输出值<code>output</code>，取决于异步操作。我们把异步操作包装在一个 <code>async</code> 函数里面，然后调用这个函数，只有等里面的异步操作都执行，变量<code>output</code>才会有值，否则就返回<code>undefined</code>。<br><br></p><p>下面是加载这个模块的写法。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// usage.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; output &#125; <span class="keyword">from</span> <span class="string">&quot;./awaiting.js&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">outputPlusValue</span>(<span class="params">value</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> output + value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">outputPlusValue</span>(<span class="number">100</span>));</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">outputPlusValue</span>(<span class="number">100</span>)), <span class="number">1000</span>);</span><br></pre></td></tr></table></figure><p>上面代码中，<ins><code>outputPlusValue()</code>的执行结果，完全取决于执行的时间。如果<code>awaiting.js</code>里面的异步操作没执行完，加载进来的<code>output</code>的值就是<code>undefined</code></ins>。<br><br></p><p>目前的解决方法，就是让原始模块输出一个 <code>Promise</code> 对象，从这个 <code>Promise</code> 对象判断异步操作有没有结束（检查当前状态是否为<code>resolved</code>，即使用<code>then</code>的回调函数）。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// awaiting.js</span></span><br><span class="line"><span class="keyword">let</span> output;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> (<span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> dynamic = <span class="keyword">await</span> <span class="keyword">import</span>(someMission);</span><br><span class="line">  <span class="keyword">const</span> data = <span class="keyword">await</span> <span class="title function_">fetch</span>(url);</span><br><span class="line">  output = <span class="title function_">someProcess</span>(dynamic.<span class="property">default</span>, data);</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="keyword">export</span> &#123; output &#125;;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>awaiting.js</code>除了输出<code>output</code>，还默认输出一个 <code>Promise</code> 对象（<code>async</code> 函数立即执行后，返回一个 <code>Promise</code> 对象），从这个对象判断异步操作是否结束。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// usage.js</span></span><br><span class="line"><span class="keyword">import</span> promise, &#123; output &#125; <span class="keyword">from</span> <span class="string">&quot;./awaiting.js&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">outputPlusValue</span>(<span class="params">value</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> output + value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">promise.<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">outputPlusValue</span>(<span class="number">100</span>));</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">outputPlusValue</span>(<span class="number">100</span>)), <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，将<code>awaiting.js</code>对象的输出，放在<code>promise.then()</code>里面，这样就能保证异步操作完成以后，才去读取<code>output</code>。<br><br></p><p>这种写法比较麻烦，<ins>等于要求模块的使用者遵守一个额外的使用协议</ins>，按照特殊的方法使用这个模块。一旦忘记使用 <code>Promise</code> 加载，这个模块的代码就可能出错。<br><br></p><p><ins>顶层的<code>await</code>命令，就是为了解决这个问题。它保证只有异步操作完成，模块才会输出值</ins>。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// awaiting.js</span></span><br><span class="line"><span class="keyword">const</span> dynamic = <span class="keyword">import</span>(someMission);</span><br><span class="line"><span class="keyword">const</span> data = <span class="title function_">fetch</span>(url);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> output = <span class="title function_">someProcess</span>((<span class="keyword">await</span> dynamic).<span class="property">default</span>, <span class="keyword">await</span> data);</span><br></pre></td></tr></table></figure><p>上面代码中，<ins>两个异步操作在输出的时候，都加上了<code>await</code>命令。只有等到异步操作完成，这个模块才会输出值</ins>。加载这个模块的写法如下。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// usage.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; output &#125; <span class="keyword">from</span> <span class="string">&quot;./awaiting.js&quot;</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">outputPlusValue</span>(<span class="params">value</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> output + value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">outputPlusValue</span>(<span class="number">100</span>));</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">outputPlusValue</span>(<span class="number">100</span>)), <span class="number">1000</span>);</span><br></pre></td></tr></table></figure><p>上面代码的写法，与普通的模块加载完全一样。也就是说，模块的使用者完全不用关心，依赖模块的内部有没有异步操作，正常加载即可。<br><br></p><p>这时，模块的加载会等待依赖模块的异步操作完成，才执行后面的代码。所以，它总是会得到正确的<code>output</code>，不会因为加载时机的不同，而得到不一样的值。<br><br></p><p>注意，顶层<code>await</code>只能用在 <code>ES6</code> 模块。</p><hr><h2 id="21-Class-的基本语法"><a href="#21-Class-的基本语法" class="headerlink" title="21. Class 的基本语法"></a>21. Class 的基本语法</h2><h3 id="21-1-类的由来"><a href="#21-1-类的由来" class="headerlink" title="21.1 类的由来"></a>21.1 类的由来</h3><p>在<code>JS</code>中，生成实例对象的传统方法是通过构造函数。下面是一个例子。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Point</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">x</span> = x;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">y</span> = y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Point</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;(&quot;</span> + <span class="variable language_">this</span>.<span class="property">x</span> + <span class="string">&quot;, &quot;</span> + <span class="variable language_">this</span>.<span class="property">y</span> + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="title class_">Point</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>上面这种写法跟传统的面向对象语言（比如 <code>C++</code> 和 <code>Java</code>）差异很大，很容易感到困惑。<br><code>ES6</code> 引入了 <code>Class</code>（类）这个概念。通过<code>class</code>关键字，可以定义类。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">x</span> = x;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">y</span> = y;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">toString</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;(&quot;</span> + <span class="variable language_">this</span>.<span class="property">x</span> + <span class="string">&quot;, &quot;</span> + <span class="variable language_">this</span>.<span class="property">y</span> + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码定义了一个“类”，<ins>可以看到里面有一个<code>constructor()</code>方法，这就是构造方法，而<code>this</code>关键字则代表实例对象</ins>。新的<code>class</code>写法让对象原型的写法更加清晰、更像面向对象编程。<br><br></p><p><code>Point</code>类除了构造方法，还定义了一个<code>toString()</code>方法。注意，定义<code>toString()</code>方法的时候，前面不需要加上<code>function</code>这个关键字，直接把函数定义放进去了就可以了。<br><br></p><p>使用的时候，也是直接对类使用<code>new</code>命令，跟构造函数的用法完全一致。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">x</span> = x;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">y</span> = y;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">toString</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;(&quot;</span> + <span class="variable language_">this</span>.<span class="property">x</span> + <span class="string">&quot;, &quot;</span> + <span class="variable language_">this</span>.<span class="property">y</span> + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> point = <span class="keyword">new</span> <span class="title class_">Point</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">point.<span class="title function_">toString</span>();</span><br></pre></td></tr></table></figure><p>事实上，类的所有方法都定义在类的<code>prototype</code>属性上面（也称为原型对象）。因此，在类的实例上面调用方法，其实就是调用原型上的方法。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Car</span>(<span class="params">make, model, year</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">make</span> = make;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">model</span> = model;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">year</span> = year;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Car</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">start</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">make</span> + <span class="string">&quot; &quot;</span> + <span class="variable language_">this</span>.<span class="property">model</span> + <span class="string">&quot; engine started.&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> car1 = <span class="keyword">new</span> <span class="title class_">Car</span>(<span class="string">&quot;Eagle&quot;</span>, <span class="string">&quot;Talon TSi&quot;</span>, <span class="number">1993</span>);</span><br><span class="line">car1.<span class="title function_">start</span>(); <span class="comment">// 输出：&quot;Eagle Talon TSi engine started.&quot;</span></span><br></pre></td></tr></table></figure><p>由于类的方法都定义在<code>prototype</code>对象上面，所以类的新方法可以添加在<code>prototype</code>对象上面。<code>Object.assign()</code>方法可以很方便地一次向类添加多个方法。（<code>class</code> 直接添加就行）<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Car</span>(<span class="params">make, model, year</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">make</span> = make;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">model</span> = model;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">year</span> = year;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">assign</span>(<span class="title class_">Car</span>.<span class="property"><span class="keyword">prototype</span></span>, &#123;</span><br><span class="line">  <span class="attr">start</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">make</span> + <span class="string">&quot; &quot;</span> + <span class="variable language_">this</span>.<span class="property">model</span> + <span class="string">&quot; engine started.&quot;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">stop</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">make</span> + <span class="string">&quot; &quot;</span> + <span class="variable language_">this</span>.<span class="property">model</span> + <span class="string">&quot; engine stopped.&quot;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> car1 = <span class="keyword">new</span> <span class="title class_">Car</span>(<span class="string">&quot;Eagle&quot;</span>, <span class="string">&quot;Talon TSi&quot;</span>, <span class="number">1993</span>);</span><br><span class="line">car1.<span class="title function_">start</span>(); <span class="comment">// 输出：&quot;Eagle Talon TSi engine started.&quot;</span></span><br><span class="line">car1.<span class="title function_">stop</span>(); <span class="comment">// 输出：&quot;Eagle Talon TSi engine stopped.&quot;</span></span><br></pre></td></tr></table></figure><p>在<code>JS</code>中，每一个函数（包括类，因为在<code>JS</code>中类也是函数）都有一个<code>prototype</code>属性，它是一个对象，这个对象有一个<code>constructor</code>属性，默认指向函数本身。也就是说，<code>prototype</code>对象的 <code>constructor</code>属性直接指向“类”的本身。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">make, model, year</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">make</span> = make;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">model</span> = model;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">year</span> = year;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Car</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> === <span class="title class_">Car</span>); <span class="comment">// 输出：true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> car = <span class="keyword">new</span> <span class="title class_">Car</span>(<span class="string">&quot;Eagle&quot;</span>, <span class="string">&quot;Talon TSi&quot;</span>, <span class="number">1993</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(car.<span class="property">constructor</span> === <span class="title class_">Car</span>); <span class="comment">// 输出：true</span></span><br></pre></td></tr></table></figure><hr><h3 id="21-2-constructor-方法"><a href="#21-2-constructor-方法" class="headerlink" title="21.2 constructor 方法"></a>21.2 constructor 方法</h3><p><code>constructor()</code>方法是类的默认方法，<ins>通过<code>new</code>命令生成对象实例时，自动调用该方法</ins>。一个类必须有<code>constructor()</code>方法，如果没有显式定义，一个空的<code>constructor()</code>方法会被默认添加。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果想在创建对象时进行一些初始化操作，比如设置对象的属性，那么需要显式定义你自己的 <code>constructor()</code>方法。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">make, model, year</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">make</span> = make;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">model</span> = model;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">year</span> = year;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">start</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">make</span> + <span class="string">&quot; &quot;</span> + <span class="variable language_">this</span>.<span class="property">model</span> + <span class="string">&quot; engine started.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> car = <span class="keyword">new</span> <span class="title class_">Car</span>(<span class="string">&quot;Eagle&quot;</span>, <span class="string">&quot;Talon TSi&quot;</span>, <span class="number">1993</span>);</span><br><span class="line">car.<span class="title function_">start</span>(); <span class="comment">// 输出：&quot;Eagle Talon TSi engine started.&quot;</span></span><br></pre></td></tr></table></figure><p><code>constructor()</code>方法默认返回实例对象（即<code>this</code>），但完全可以指定返回另外一个对象。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">make, model, year</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">make</span> = make;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">model</span> = model;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">year</span> = year;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个新对象，并返回它</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">make</span>: <span class="string">&quot;Ford&quot;</span>,</span><br><span class="line">      <span class="attr">model</span>: <span class="string">&quot;F-150&quot;</span>,</span><br><span class="line">      <span class="attr">year</span>: <span class="number">2020</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> car = <span class="keyword">new</span> <span class="title class_">Car</span>(<span class="string">&quot;Eagle&quot;</span>, <span class="string">&quot;Talon TSi&quot;</span>, <span class="number">1993</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(car.<span class="property">make</span>); <span class="comment">// 输出：&quot;Ford&quot;</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>constructor()</code>方法返回了一个完全不同的对象。因此，当我们打印<code>car.make</code>时，输出的是<code>&#39;Ford&#39;</code>而不是<code>&#39;Eagle&#39;</code>。</p><hr><h3 id="21-3-类的实例"><a href="#21-3-类的实例" class="headerlink" title="21.3 类的实例"></a>21.3 类的实例</h3><p>生成类的实例的写法，与<code>ES5</code>完全一样，也是使用<code>new</code>命令。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">let</span> point = <span class="title class_">Point</span>(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">let</span> point = <span class="keyword">new</span> <span class="title class_">Point</span>(<span class="number">2</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure><p><ins>类的属性和方法，除非显式定义在其本身（即定义在<code>this</code>对象上，通过实例访问），否则都是定义在原型上（即定义在<code>class</code>上，静态属性或者静态方法）</ins>。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">make, model, year</span>) &#123;</span><br><span class="line">    <span class="comment">// 实例属性</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">make</span> = make;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">model</span> = model;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">year</span> = year;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 原型方法</span></span><br><span class="line">  <span class="title function_">start</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">make</span> + <span class="string">&quot; &quot;</span> + <span class="variable language_">this</span>.<span class="property">model</span> + <span class="string">&quot; engine started.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 静态方法</span></span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">isCar</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> obj <span class="keyword">instanceof</span> <span class="title class_">Car</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态属性</span></span><br><span class="line"><span class="title class_">Car</span>.<span class="property">manu</span> = <span class="string">&quot;Unknown&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> car = <span class="keyword">new</span> <span class="title class_">Car</span>(<span class="string">&quot;Eagle&quot;</span>, <span class="string">&quot;Talon TSi&quot;</span>, <span class="number">1993</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(car.<span class="property">make</span>); <span class="comment">// 输出：&quot;Eagle&quot;</span></span><br><span class="line">car.<span class="title function_">start</span>(); <span class="comment">// 输出：&quot;Eagle Talon TSi engine started.&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Car</span>.<span class="title function_">isCar</span>(car)); <span class="comment">// 输出：true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Car</span>.<span class="property">manu</span>); <span class="comment">// 输出：&quot;Unknown&quot;</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>make</code>、<code>model</code>和<code>year</code>是实例属性，<code>start</code>是原型方法，<code>isCar</code>是静态方法，<code>manu</code>是静态属性。可以看到，<code>make</code>和<code>start</code>可以通过实例<code>car</code>访问，而<code>isCar</code>和<code>manu</code>只能通过类名<code>Car</code>访问。<br><br></p><p>与<code>ES5</code>一样，<ins>类的所有实例共享一个原型对象</ins>。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="title class_">Point</span>(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="title class_">Point</span>(<span class="number">3</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">p1.<span class="property">__proto__</span> === p2.<span class="property">__proto__</span>;</span><br><span class="line"><span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>p1</code>和<code>p2</code>都是<code>Point</code>的实例，它们的原型都是<code>Point.prototype</code>，所以<code>__proto__</code>属性是相等的。这也意味着，可以通过实例的<code>__proto__</code>属性为“类”添加方法。<br><br></p><p>然而，使用 <code>__proto__</code> 通常是不推荐的，因为这并不是语言的一个标准特性，而且在不同的 <code>JS</code> 环境中可能表现不同。更好的方式是直接使用 <code>Object.getPrototypeOf(obj)</code> 函数获取一个对象的原型，或者使用 <code>Object.setPrototypeOf(obj, prototype)</code> 函数设置一个对象的原型。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="title class_">Point</span>(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="title class_">Point</span>(<span class="number">3</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">p1.<span class="property">__proto__</span>.<span class="property">printName</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;Oops&quot;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">p1.<span class="title function_">printName</span>(); <span class="comment">// &quot;Oops&quot;</span></span><br><span class="line">p2.<span class="title function_">printName</span>(); <span class="comment">// &quot;Oops&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p3 = <span class="keyword">new</span> <span class="title class_">Point</span>(<span class="number">4</span>, <span class="number">2</span>);</span><br><span class="line">p3.<span class="title function_">printName</span>(); <span class="comment">// &quot;Oops&quot;</span></span><br></pre></td></tr></table></figure><p>上面代码在<code>p1</code>的原型上添加了一个<code>printName()</code>方法，由于<code>p1</code>的原型就是<code>p2</code>的原型，因此<code>p2</code>也可以调用这个方法。而且，此后新建的实例<code>p3</code>也可以调用这个方法。<ins>这意味着，使用实例的<code>__proto__</code>属性改写原型，必须相当谨慎，不推荐使用，因为这会改变“类”的原始定义，影响到所有实例</ins>。</p><hr><h3 id="21-4-实例属性的新写法"><a href="#21-4-实例属性的新写法" class="headerlink" title="21.4 实例属性的新写法"></a>21.4 实例属性的新写法</h3><p><a href="https://github.com/tc39/proposal-class-fields">ES6</a> 为类的实例属性，又规定了一种新写法。实例属性现在除了可以定义在<code>constructor()</code>方法里面的<code>this</code>上面，<ins>也可以定义在类内部的最顶层</ins>。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 原来的写法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IncreasingCounter</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_count</span> = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">value</span>() &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Getting the current value!&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_count</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">increment</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_count</span>++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面示例中，实例属性<code>_count</code>定义在<code>constructor()</code>方法里面的<code>this</code>上面。现在的新写法是，这个属性也可以定义在类的最顶层，其他都不变。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">IncreasingCounter</span> &#123;</span><br><span class="line">  _count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">value</span>() &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Getting the current value!&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_count</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">increment</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_count</span>++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，实例属性<code>_count</code>与取值函数<code>value()</code>和<code>increment()</code>方法，处于同一个层级。这时，不需要在实例属性前面加上<code>this</code>。<br><br></p><p>注意，<ins>新写法定义的属性是实例对象自身的属性，而不是定义在实例对象的原型<code>prototype</code>上面</ins>。因为如果原型变了，比如这里的<code>_count</code>我们做计数处理，那么所有实例的<code>_count</code>属性都会改变，这就会出现与我们预期不同的结果。<br><br></p><p>这种新写法的好处是，所有实例对象自身的属性都定义在类的头部，看上去比较整齐，一眼就能看出这个类有哪些实例属性。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">foo</span> &#123;</span><br><span class="line">  bar = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">  baz = <span class="string">&quot;world&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码，<code>foo</code>类有两个实例属性，一目了然。另外，写起来也比较简洁。</p><hr><h3 id="21-5-取值函数-getter-和存值函数-setter"><a href="#21-5-取值函数-getter-和存值函数-setter" class="headerlink" title="21.5 取值函数 getter 和存值函数 setter"></a>21.5 取值函数 getter 和存值函数 setter</h3><p>与<code>ES5</code>一样，<ins>在“类”的内部可以使用<code>get</code>和<code>set</code>关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为</ins>。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_myProperty</span> = <span class="string">&quot;Default value&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Getter</span></span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">myProperty</span>() &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Getting myProperty&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_myProperty</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Setter</span></span><br><span class="line">  <span class="keyword">set</span> <span class="title function_">myProperty</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Setting myProperty&quot;</span>);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_myProperty</span> = value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">myProperty</span>); <span class="comment">// 输出：&quot;Getting myProperty&quot; 和 &quot;Default value&quot;</span></span><br><span class="line">obj.<span class="property">myProperty</span> = <span class="string">&quot;New value&quot;</span>; <span class="comment">// 输出：&quot;Setting myProperty&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">myProperty</span>); <span class="comment">// 输出：&quot;Getting myProperty&quot; 和 &quot;New value&quot;</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>myProperty</code>属性有对应的存值函数和取值函数，因此赋值和读取行为都被自定义了。注意，<ins>存值函数和取值函数是设置在属性的 <code>Descriptor</code> 对象上的</ins>。</p><hr><h3 id="21-6-Class-表达式"><a href="#21-6-Class-表达式" class="headerlink" title="21.6 Class 表达式"></a>21.6 Class 表达式</h3><p>与函数一样，类也可以使用表达式的形式定义。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 命名类表达式</span></span><br><span class="line"><span class="keyword">let</span> <span class="title class_">User</span> = <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">sayHello</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hello, my name is <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> user = <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Alice&quot;</span>);</span><br><span class="line">user.<span class="title function_">sayHello</span>(); <span class="comment">// 输出 &quot;Hello, my name is Alice&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">MyClass</span>); <span class="comment">// 报错，MyClass 在类外部不可用</span></span><br></pre></td></tr></table></figure><p>上面代码使用表达式定义了一个类。<ins>需要注意的是，这个类的名字是<code>MyClass</code>，但是<code>MyClass</code>只在 <code>Class</code> 的内部可用，指代当前类。在 <code>Class</code> 外部，这个类只能用<code>User</code>引用</ins>。<br><br></p><p>如果类的内部没用到的话，可以省略<code>MyClass</code>，也就是可以写成下面的形式。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 匿名类表达式</span></span><br><span class="line"><span class="keyword">let</span> <span class="title class_">User</span> = <span class="keyword">class</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">sayHello</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hello, my name is <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> user = <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Alice&quot;</span>);</span><br><span class="line">user.<span class="title function_">sayHello</span>(); <span class="comment">// 输出 &quot;Hello, my name is Alice&quot;</span></span><br></pre></td></tr></table></figure><p>采用 <code>Class</code> 表达式，可以写出立即执行的 <code>Class</code>。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user = <span class="keyword">new</span> (<span class="keyword">class</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">sayHello</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hello, my name is <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)(<span class="string">&quot;Alice&quot;</span>);</span><br><span class="line"></span><br><span class="line">user.<span class="title function_">sayHello</span>(); <span class="comment">// 输出 &quot;Hello, my name is Alice&quot;</span></span><br></pre></td></tr></table></figure><hr><h3 id="21-7-静态方法"><a href="#21-7-静态方法" class="headerlink" title="21.7 静态方法"></a>21.7 静态方法</h3><p>类相当于实例的原型，所有在类中定义的方法都会被实例继承。<ins>如果在一个方法前，加上<code>static</code>关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”</ins>。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">classMethod</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Foo</span>.<span class="title function_">classMethod</span>(); <span class="comment">// &#x27;hello&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> foo = <span class="keyword">new</span> <span class="title class_">Foo</span>();</span><br><span class="line">foo.<span class="title function_">classMethod</span>();</span><br><span class="line"><span class="comment">// TypeError: foo.classMethod is not a function</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>Foo</code>类的<code>classMethod</code>方法前有<code>static</code>关键字，表明该方法是一个静态方法，可以直接在<code>Foo</code>类上调用，而不是在<code>Foo</code>类的实例上调用。如果在实例上调用静态方法，会抛出一个错误，表示不存在该方法。<br><br></p><p>注意，<ins>如果静态方法包含<code>this</code>关键字，这个<code>this</code>指的是类，而不是实例</ins>。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">myStaticMethod</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">myInstanceMethod</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">MyClass</span>.<span class="title function_">myStaticMethod</span>(); <span class="comment">// 输出 MyClass [Function: MyClass]，this 指向类</span></span><br><span class="line"><span class="keyword">let</span> instance = <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line">instance.<span class="title function_">myInstanceMethod</span>(); <span class="comment">// 输出 MyClass &#123;&#125;，this 指向实例</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>myStaticMethod</code>是<code>MyClass</code>的静态方法，<code>this</code>指向的是类<code>MyClass</code>。<code>myInstanceMethod</code>是实例方法，<code>this</code>指向的是类的实例。另外，从这个例子还可以看出，<ins>静态方法可以与非静态方法重名</ins>。<br><br></p><p><ins>父类的静态方法，可以被子类继承</ins>。同时，<ins>静态方法也是可以从<code>super</code>对象上调用的</ins>。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ParentClass</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">greeting</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello from ParentClass&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ChildClass</span> <span class="keyword">extends</span> <span class="title class_ inherited__">ParentClass</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">ChildClass</span>.<span class="title function_">greeting</span>(); <span class="comment">// 输出 &quot;Hello from ParentClass&quot;</span></span><br><span class="line"></span><br><span class="line">-----------------------------------------</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ParentClass</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">greeting</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello from ParentClass&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ChildClass</span> <span class="keyword">extends</span> <span class="title class_ inherited__">ParentClass</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">greeting</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>.<span class="title function_">greeting</span>();</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello from ChildClass&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">ChildClass</span>.<span class="title function_">greeting</span>();</span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// &quot;Hello from ParentClass&quot;</span></span><br><span class="line"><span class="comment">// &quot;Hello from ChildClass&quot;</span></span><br></pre></td></tr></table></figure><hr><h3 id="21-8-私有方法和私有属性"><a href="#21-8-私有方法和私有属性" class="headerlink" title="21.8 私有方法和私有属性"></a>21.8 私有方法和私有属性</h3><p><a href="https://github.com/tc39/proposal-class-fields">ES6</a>为<code>class</code>添加了私有属性，<ins>方法是在属性名之前使用<code>#</code>表示</ins>。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">IncreasingCounter</span> &#123;</span><br><span class="line">  #count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">value</span>() &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Getting the current value!&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.#count;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">increment</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.#count++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> counter = <span class="keyword">new</span> <span class="title class_">IncreasingCounter</span>();</span><br><span class="line">counter.#count; <span class="comment">// 报错</span></span><br><span class="line">counter.#count = <span class="number">42</span>; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>#count</code>就是私有属性，只能在类的内部使用（<code>this.#count</code>）。如果在类的外部使用，就会报错。<br><br></p><p>另外，<ins>不管在类的内部或外部，读取一个不存在的私有属性，都会报错</ins>。这跟公开属性的行为完全不同，如果读取一个不存在的公开属性，不会报错，只会返回<code>undefined</code>。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">IncreasingCounter</span> &#123;</span><br><span class="line">  #count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">value</span>() &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Getting the current value!&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.#myCount; <span class="comment">// 报错</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">increment</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.#count++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> counter = <span class="keyword">new</span> <span class="title class_">IncreasingCounter</span>();</span><br><span class="line">counter.#myCount; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><p>上面示例中，<code>#myCount</code>是一个不存在的私有属性，不管在函数内部或外部，读取该属性都会导致报错。注意，私有属性的属性名必须包括<code>#</code>，如果不带<code>#</code>，会被当作另一个属性。<br><br></p><p><code>ES6</code>中<ins>不仅可以写私有属性，还可以用来写私有方法</ins>。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">  #a;</span><br><span class="line">  #b;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.#a = a;</span><br><span class="line">    <span class="variable language_">this</span>.#b = b;</span><br><span class="line">  &#125;</span><br><span class="line">  #<span class="title function_">sum</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.#a + <span class="variable language_">this</span>.#b;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">printSum</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.#<span class="title function_">sum</span>());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外，<ins>私有属性也可以设置 <code>getter</code> 和 <code>setter</code> 方法</ins>。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">  #xValue = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.#x);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  get #<span class="title function_">x</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.#xValue;</span><br><span class="line">  &#125;</span><br><span class="line">  set #<span class="title function_">x</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.#xValue = value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>#x</code>是一个私有属性，它的读写都通过<code>get #x()</code>和<code>set #x()</code>操作另一个私有属性<code>#xValue</code>来完成。<br><br></p><p><ins>私有属性不限于从<code>this</code>引用，只要是在类的内部，实例也可以引用私有属性</ins>。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">  #privateProperty = <span class="string">&quot;I&#x27;m private&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">checkPrivateProperty</span>(<span class="params">otherInstance</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> otherInstance.#privateProperty;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> instance1 = <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line"><span class="keyword">const</span> instance2 = <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(instance1.<span class="title function_">checkPrivateProperty</span>(instance2));</span><br><span class="line"><span class="comment">// 输出 &quot;I&#x27;m private&quot;</span></span><br></pre></td></tr></table></figure><p><ins>私有属性和私有方法也可以加上<code>static</code>关键字，表示这是一个静态的私有属性或私有方法</ins>。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> #<span class="title function_">privateStaticMethod</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Hello from private static method&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">callPrivateStaticMethod</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.#<span class="title function_">privateStaticMethod</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">MyClass</span>.<span class="title function_">callPrivateStaticMethod</span>());</span><br><span class="line"><span class="comment">// 输出 &quot;Hello from private static method&quot;</span></span><br></pre></td></tr></table></figure><hr><h3 id="21-9-in-运算符"><a href="#21-9-in-运算符" class="headerlink" title="21.9 in 运算符"></a>21.9 in 运算符</h3><p>前面说过，<ins>直接访问某个类不存在的私有属性会报错，但是访问不存在的公开属性不会报错。这个特性可以用来判断，某个对象是否为类的实例</ins>。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line">  #brand;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">isC</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      obj.#brand;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面示例中，类<code>C</code>的静态方法<code>isC()</code>就用来判断，某个对象是否为<code>C</code>的实例。它采用的方法就是，访问该对象的私有属性<code>#brand</code>。如果不报错，就会返回<code>true</code>；如果报错，就说明该对象不是当前类的实例，从而<code>catch</code>部分返回<code>false</code>。<br><br></p><p>因此，<code>try...catch</code>结构可以用来判断某个私有属性是否存在。但是，这样的写法很麻烦，代码可读性很差，<a href="https://github.com/tc39/proposal-private-fields-in-in">ES6</a> 改进了<ins><code>in</code>运算符，使它也可以用来判断私有属性。它不会报错，而是返回一个布尔值</ins>。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line">  #brand;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">isC</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (#brand <span class="keyword">in</span> obj) &#123;</span><br><span class="line">      <span class="comment">// 私有属性 #brand 存在</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 私有属性 #foo 不存在</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>in</code>也可以跟<code>this</code>一起配合使用，用来检查一个对象是否拥有某个属性的，无论这个属性是在实例本身还是在它的原型链中。注意，<ins>判断私有属性时，<code>in</code>只能用在类的内部</ins>。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  #foo = <span class="number">0</span>;</span><br><span class="line">  <span class="title function_">m</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(#foo <span class="keyword">in</span> <span class="variable language_">this</span>); <span class="comment">// true</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(#bar <span class="keyword">in</span> <span class="variable language_">this</span>); <span class="comment">// false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="21-10-静态块"><a href="#21-10-静态块" class="headerlink" title="21.10 静态块"></a>21.10 静态块</h3><p>静态属性的一个问题是，如果它有初始化逻辑，这个逻辑要么写在类的外部，要么写在<code>constructor()</code>方法里面。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">MyClass</span>.<span class="property">myStaticProperty</span> = <span class="string">&quot;some value&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="title class_">MyClass</span>.<span class="property">myStaticProperty</span>) &#123;</span><br><span class="line">      <span class="title class_">MyClass</span>.<span class="property">myStaticProperty</span> = <span class="string">&quot;some value&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了解决这个问题，<code>ES2022</code> 引入了<a href="https://github.com/tc39/proposal-class-static-block">静态块</a>（<code>static block</code>），允许在类的内部设置一个代码块，<ins>在类生成时运行且只运行一次，主要作用是对静态属性进行初始化</ins>。以后，<ins>新建类的实例时，这个块就不运行了</ins>。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> a;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">a</span> = <span class="title function_">doSomethingThatMightFail</span>();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">a</span> = <span class="string">&quot;default value&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个类允许有多个静态块，每个静态块中只能访问之前声明的静态属性。同时，静态块的内部不能有<code>return</code>语句，但是可以使用类名或<code>this</code>，指代当前类。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> prop1;</span><br><span class="line">  <span class="keyword">static</span> prop2;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="comment">// 第一个静态块</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">prop1</span> = <span class="string">&quot;value1&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="comment">// 第二个静态块</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">prop2</span> = <span class="variable language_">this</span>.<span class="property">prop1</span> + <span class="string">&quot; value2&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">MyClass</span>.<span class="property">prop1</span>); <span class="comment">// 输出 &quot;value1&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">MyClass</span>.<span class="property">prop2</span>); <span class="comment">// 输出 &quot;value1 value2&quot;</span></span><br></pre></td></tr></table></figure><p>除了静态属性的初始化，静态块还有一个作用，就是<ins>将私有属性与类的外部代码分享</ins>。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">  <span class="comment">// 私有属性</span></span><br><span class="line">  <span class="keyword">static</span> #privateProp = <span class="string">&quot;private value&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="comment">// 在静态块中定义公开方法</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">getPrivateProp</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title class_">MyClass</span>.#privateProp;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">MyClass</span>.<span class="title function_">getPrivateProp</span>()); <span class="comment">// 输出 &quot;private value&quot;</span></span><br></pre></td></tr></table></figure><p>这个特性提供了一种灵活的方式来控制类的私有属性的访问，可以根据需要决定哪些私有属性应该对外部代码开放，以及在何种条件下开放。</p><hr><h3 id="21-11-类的注意点"><a href="#21-11-类的注意点" class="headerlink" title="21.11 类的注意点"></a>21.11 类的注意点</h3><p><strong>（1）Generator 方法</strong></p><p>如果某个方法之前加上星号<code>*</code>，就表示该方法是一个 <code>Generator</code> 函数。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">lass <span class="title class_">MyClass</span> &#123;</span><br><span class="line">  * <span class="title function_">generatorMethod</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&#x27;Hello,&#x27;</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&#x27;world!&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> myInstance = <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line"><span class="keyword">const</span> gen = myInstance.<span class="title function_">generatorMethod</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(gen.<span class="title function_">next</span>().<span class="property">value</span>); <span class="comment">// 输出 &quot;Hello,&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(gen.<span class="title function_">next</span>().<span class="property">value</span>); <span class="comment">// 输出 &quot;world!&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(gen.<span class="title function_">next</span>().<span class="property">value</span>); <span class="comment">// 输出 undefined</span></span><br></pre></td></tr></table></figure><p><strong>（2）this 的指向</strong></p><p>类的方法内部如果含有<code>this</code>，它默认指向类的实例。但是，如果将类的方法提取出来单独使用，那么<code>this</code>可能就不再指向原来的对象了。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">  <span class="title function_">myMethod</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> myInstance = <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line">myInstance.<span class="title function_">myMethod</span>(); <span class="comment">// MyClass的实例</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; method &#125; = myInstance;</span><br><span class="line"><span class="title function_">method</span>(); <span class="comment">// undefined或者全局对象（在非严格模式下）</span></span><br></pre></td></tr></table></figure><p>在上述代码中，<code>myMethod</code>方法中的<code>this</code>默认指向<code>MyClass</code>的实例。但当我们将<code>myMethod</code>方法赋值给变量<code>method</code>，并单独调用<code>method()</code>时，<code>this</code>就变成了<code>undefined</code>。<br><br></p><p>解决方法是，<ins>在构造方法中绑定<code>this</code></ins>，或者使用箭头函数。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">myMethod</span> = <span class="variable language_">this</span>.<span class="property">myMethod</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">myMethod</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">  myMethod = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="22-Class-的继承"><a href="#22-Class-的继承" class="headerlink" title="22. Class 的继承"></a>22. Class 的继承</h2><p><a href="https://es6.ruanyifeng.com/#docs/class-extends">本章</a>内容复杂，故先跳过一部分。</p><h3 id="22-1-简介"><a href="#22-1-简介" class="headerlink" title="22.1 简介"></a>22.1 简介</h3><p><ins><code>Class</code> 可以通过<code>extends</code>关键字实现继承，让子类继承父类的属性和方法</ins>。<code>extends</code> 的写法比 <code>ES5</code> 的原型链继承，要清晰和方便很多。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ColorPoint</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Point</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>上面示例中，<ins><code>Point</code>是父类，<code>ColorPoint</code>是子类，它通过<code>extends</code>关键字，继承了<code>Point</code>类的所有属性和方法</ins>。下面，我们在<code>ColorPoint</code>内部加上代码。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ColorPoint</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Point</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">x, y, color</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(x, y); <span class="comment">// 调用父类的 constructor(x, y)</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">color</span> = color;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">toString</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">color</span> + <span class="string">&quot; &quot;</span> + <span class="variable language_">super</span>.<span class="title function_">toString</span>(); <span class="comment">// 调用父类的 toString()</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面示例中，<code>constructor()</code>方法和<code>toString()</code>方法内部，都出现了<code>super</code>关键字。<ins><code>super</code>在这里表示父类的构造函数，用来新建一个父类的实例对象</ins>。<br><br></p><p><code>ES6</code> 规定，<ins>子类必须在<code>constructor()</code>方法中调用<code>super()</code></ins>，否则就会报错。这是因为子类自己的<code>this</code>对象，必须先通过父类的构造函数完成塑造，得到与父类同样的实例属性和方法，然后再添加子类自己的实例属性和方法。如果不调用<code>super()</code>方法，子类就得不到自己的<code>this</code>对象。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ColorPoint</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Point</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> cp = <span class="keyword">new</span> <span class="title class_">ColorPoint</span>(); <span class="comment">// ReferenceError</span></span><br></pre></td></tr></table></figure><p>为什么子类的构造函数，一定要调用<code>super()</code>？原因就在于 <code>ES6</code> 的继承机制，与 <code>ES5</code> 完全不同。</p><ul><li><code>ES5</code> 的继承机制，是先创造一个独立的子类的实例对象，然后再将父类的方法添加到这个对象上面，即“实例在前，继承在后”。</li><li><code>ES6</code> 的继承机制，则是先将父类的属性和方法，加到一个空的对象上面，然后再将该对象作为子类的实例，即“继承在前，实例在后”。</li></ul><p>这就是为什么 <code>ES6</code> 的继承必须先调用<code>super()</code>方法，因为这一步会生成一个继承父类的<code>this</code>对象，没有这一步就无法继承父类。<br><br></p><p>注意，这意味着<ins>新建子类实例时，父类的构造函数必定会先运行一次</ins>。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bar</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Foo</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>();</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> bar = <span class="keyword">new</span> <span class="title class_">Bar</span>();</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>上面示例中，子类 <code>Bar</code> 新建实例时，会输出<code>1</code>和<code>2</code>。原因就是子类构造函数调用<code>super()</code>时，会执行一次父类构造函数。<br><br></p><p>另一个需要注意的地方是，<ins>在子类的构造函数中，只有调用<code>super()</code>之后，才可以使用<code>this</code>关键字</ins>，否则会报错。这是因为子类实例的构建，必须先完成父类的继承，只有<code>super()</code>方法才能让子类实例继承父类。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&quot;Parent&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Parent</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// Error: Must call super constructor in derived class before accessing &#x27;this&#x27;</span></span><br><span class="line">    <span class="comment">// console.log(this.name);</span></span><br><span class="line"></span><br><span class="line">    <span class="variable language_">super</span>(); <span class="comment">// 正确初始化子类实例</span></span><br><span class="line"></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>); <span class="comment">// 输出: &#x27;Parent&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Child</span>();</span><br></pre></td></tr></table></figure><p>上面代码中，子类的<code>constructor()</code>方法没有调用<code>super()</code>之前，就使用<code>this</code>关键字，结果报错，而放在<code>super()</code>之后就是正确的。<br><br></p><p><ins>如果子类没有定义<code>constructor()</code>方法，这个方法会默认添加，并且里面会调用<code>super()</code></ins>。也就是说，不管有没有显式定义，任何一个子类都有<code>constructor()</code>方法。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Parent</span> &#123;</span><br><span class="line">  <span class="comment">// 这里我们没有显式定义 constructor()</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> child = <span class="keyword">new</span> <span class="title class_">Child</span>(<span class="string">&quot;John&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(child.<span class="property">name</span>); <span class="comment">// 输出: &#x27;John&#x27;</span></span><br></pre></td></tr></table></figure><p>有了子类的定义，就可以生成子类的实例了。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">child <span class="keyword">instanceof</span> <span class="title class_">Child</span>; <span class="comment">// true</span></span><br><span class="line">child <span class="keyword">instanceof</span> <span class="title class_">Parent</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>注意，<ins>如果父类和子类有同名属性，子类的属性会覆盖父类的属性</ins>。这是因为在子类中定义的属性和方法具有更高的优先级。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&quot;Parent&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Parent</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>();</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&quot;Child&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">showName</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> child = <span class="keyword">new</span> <span class="title class_">Child</span>();</span><br><span class="line">child.<span class="title function_">showName</span>(); <span class="comment">// 输出: &#x27;Child&#x27;</span></span><br></pre></td></tr></table></figure><hr><h3 id="22-2-私有属性和私有方法的继承"><a href="#22-2-私有属性和私有方法的继承" class="headerlink" title="22.2 私有属性和私有方法的继承"></a>22.2 私有属性和私有方法的继承</h3><p><ins>父类所有的属性和方法，都会被子类继承，除了私有的属性和方法</ins>。子类无法继承父类的私有属性，或者说，<ins>私有属性只能在定义它的 <code>class</code> 里面使用</ins>。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">  #p = <span class="number">1</span>;</span><br><span class="line">  #<span class="title function_">m</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bar</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Foo</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>();</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.#p); <span class="comment">// 报错</span></span><br><span class="line">    <span class="variable language_">this</span>.#<span class="title function_">m</span>(); <span class="comment">// 报错</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果<ins>父类定义了私有属性的读写方法，子类就可以通过这些方法，读写私有属性</ins>。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">  #p = <span class="number">1</span>;</span><br><span class="line">  <span class="title function_">getP</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.#p;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bar</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Foo</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>();</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="title function_">getP</span>()); <span class="comment">// 1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面示例中，<code>getP()</code>是父类用来读取私有属性的方法，子类可以用这个方法读到父类的私有属性。</p><hr><h3 id="22-3-静态属性和静态方法的继承"><a href="#22-3-静态属性和静态方法的继承" class="headerlink" title="22.3 静态属性和静态方法的继承"></a>22.3 静态属性和静态方法的继承</h3><p><ins>父类的静态属性和静态方法，也会被子类继承</ins>。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">hello</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_ inherited__">A</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">B.<span class="title function_">hello</span>(); <span class="comment">// hello world</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>hello()</code>是<code>A</code>类的静态方法，<code>B</code>继承<code>A</code>，也继承了<code>A</code>的静态方法。<br><br></p><p>注意，<ins>静态属性是通过<a href="https://vue3js.cn/interview/JavaScript/copy.html">软拷贝</a>实现继承的</ins>。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> foo = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_ inherited__">A</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>();</span><br><span class="line">    B.<span class="property">foo</span>--;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> b = <span class="keyword">new</span> <span class="title function_">B</span>();</span><br><span class="line">B.<span class="property">foo</span>; <span class="comment">// 99</span></span><br><span class="line">A.<span class="property">foo</span>; <span class="comment">// 100</span></span><br></pre></td></tr></table></figure><p>上面示例中，<code>foo</code>是 <code>A</code> 类的静态属性，<code>B</code> 类继承了 <code>A</code> 类，因此也继承了这个属性。但是，<ins>在 <code>B</code> 类内部操作<code>B.foo</code>这个静态属性，影响不到<code>A.foo</code></ins>，原因就是 <code>B</code> 类继承静态属性时，会采用浅拷贝，拷贝父类静态属性的值，因此<code>A.foo</code>和<code>B.foo</code>是两个彼此独立的属性。<br><br></p><p>但是，由于这种拷贝是浅拷贝，<ins>如果父类的静态属性的值是一个对象，那么子类的静态属性也会指向这个对象</ins>，因为浅拷贝只会拷贝对象的内存地址。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> foo = &#123; <span class="attr">n</span>: <span class="number">100</span> &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_ inherited__">A</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>();</span><br><span class="line">    B.<span class="property">foo</span>.<span class="property">n</span>--;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> b = <span class="keyword">new</span> <span class="title function_">B</span>();</span><br><span class="line">B.<span class="property">foo</span>.<span class="property">n</span>; <span class="comment">// 99</span></span><br><span class="line">A.<span class="property">foo</span>.<span class="property">n</span>; <span class="comment">// 99</span></span><br></pre></td></tr></table></figure><p>上面示例中，<code>A.foo</code>的值是一个对象，浅拷贝导致<code>B.foo</code>和<code>A.foo</code>指向同一个对象。所以，子类<code>B</code>修改这个对象的属性值，会影响到父类<code>A</code>。</p><hr><h3 id="22-4-super-关键字"><a href="#22-4-super-关键字" class="headerlink" title="22.4 super 关键字"></a>22.4 super 关键字</h3><p><code>super</code>这个关键字，既可以当作函数使用，也可以当作对象使用。<br><br></p><p>（1）当<code>super</code><ins>作为函数调用时，代表父类的构造函数</ins>。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_ inherited__">A</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用<code>super()</code>的作用是形成子类的<code>this</code>对象，把父类的实例属性和方法放到这个<code>this</code>对象上面。子类在调用<code>super()</code>之前，是没有<code>this</code>对象的，任何对<code>this</code>的操作都要放在<code>super()</code>的后面。<br><br></p><p>注意，<ins>这里的<code>super</code>虽然代表了父类的构造函数，但是因为返回的是子类的<code>this</code>（即子类的实例对象），所以<code>super</code>内部的<code>this</code>代表子类的实例，而不是父类的实例</ins>。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span>.<span class="property">target</span>.<span class="property">name</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_ inherited__">A</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> <span class="title function_">A</span>(); <span class="comment">// A</span></span><br><span class="line"><span class="keyword">new</span> <span class="title function_">B</span>(); <span class="comment">// B</span></span><br></pre></td></tr></table></figure><p>上面示例中，<code>new.target</code>指向当前正在执行的函数。可以看到，在<code>super()</code>执行时，它指向的是子类<code>B</code>的构造函数，而不是父类<code>A</code>的构造函数。也就是说，<code>super()</code>内部的<code>this</code>指向的是<code>B</code>。<br><br></p><p>不过，<ins>由于<code>super()</code>在子类构造方法中执行时，子类的属性和方法还没有绑定到<code>this</code>，所以如果存在同名属性，此时拿到的是父类的属性</ins>。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  name = <span class="string">&quot;A&quot;</span>;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;My name is &quot;</span> + <span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_ inherited__">A</span> &#123;</span><br><span class="line">  name = <span class="string">&quot;B&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> b = <span class="keyword">new</span> <span class="title function_">B</span>(); <span class="comment">// My name is A</span></span><br></pre></td></tr></table></figure><p>上面示例中，最后一行输出的是<code>A</code>，而不是<code>B</code>，原因就在于<code>super()</code>执行时，<code>B</code>的<code>name</code>属性还没有绑定到<code>this</code>，所以<code>this.name</code>拿到的是<code>A</code>类的<code>name</code>属性。<br><br></p><p><ins>作为函数时，<code>super()</code>只能用在子类的构造函数之中</ins>，用在其他地方就会报错。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_ inherited__">A</span> &#123;</span><br><span class="line">  <span class="title function_">m</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(); <span class="comment">// 报错</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）当<code>super</code><ins>作为对象时，在普通方法中指向父类的原型对象，在静态方法中指向父类</ins>。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&quot;Parent&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">greet</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hello, <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">sayHello</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello from Parent class&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Parent</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>();</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&quot;Child&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">greet</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>.<span class="title function_">greet</span>(); <span class="comment">// 使用super在普通方法中调用父类方法</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hello, <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span> from child class`</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">sayHello</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>.<span class="title function_">sayHello</span>(); <span class="comment">// 在静态方法中使用super调用父类静态方法</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello from Child class&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> c = <span class="keyword">new</span> <span class="title class_">Child</span>();</span><br><span class="line">c.<span class="title function_">greet</span>();</span><br><span class="line"><span class="title class_">Child</span>.<span class="title function_">sayHello</span>();</span><br></pre></td></tr></table></figure><p>如果<code>super</code>指向父类的原型对象，那么定义在父类实例上的方法或属性（即定义在<code>constructor</code>里），是无法通过<code>super</code>调用的。这时候想在子类中访问到父类实例上的属性，则需要在父类中定义一个方法来返回这个属性，然后在子类中调用这个方法。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&quot;Parent&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">getName</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Parent</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>();</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">super</span>.<span class="property">name</span>); <span class="comment">// TypeError ...</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">super</span>.<span class="title function_">getName</span>()); <span class="comment">// &#x27;Parent&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><ins>在子类普通方法中通过<code>super</code>调用父类的方法时，方法内部的<code>this</code>指向当前的子类实例</ins>。所以通过<code>super</code>对某个属性赋值，<code>super</code>就是<code>this</code>，赋值的属性会变成子类实例的属性。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">x</span> = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">print</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">x</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_ inherited__">A</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>();</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">x</span> = <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">m</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>.<span class="title function_">print</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> <span class="title function_">B</span>();</span><br><span class="line">b.<span class="title function_">m</span>(); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>super.print()</code>虽然调用的是<code>A.prototype.print()</code>，但是<code>A.prototype.print()</code>内部的<code>this</code>指向子类<code>B</code>的实例，导致输出的是<code>2</code>，而不是<code>1</code>。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">x</span> = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_ inherited__">A</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>();</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">x</span> = <span class="number">2</span>;</span><br><span class="line">    <span class="variable language_">super</span>.<span class="property">x</span> = <span class="number">3</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">super</span>.<span class="property">x</span>); <span class="comment">// undefined</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">x</span>); <span class="comment">// 3</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> <span class="title function_">B</span>();</span><br></pre></td></tr></table></figure><p>上面代码中，<code>super.x</code>赋值为<code>3</code>，这时等同于对<code>this.x</code>赋值为<code>3</code>。而当读取<code>super.x</code>的时候，读的是<code>A.prototype.x</code>，所以返回<code>undefined</code>。<br><br></p><p><ins>如果<code>super</code>作为对象，用在静态方法之中，这时<code>super</code>将指向父类，而不是父类的原型对象</ins>。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">myMethod</span>(<span class="params">msg</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;static&quot;</span>, msg);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">myMethod</span>(<span class="params">msg</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;instance&quot;</span>, msg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Parent</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">myMethod</span>(<span class="params">msg</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>.<span class="title function_">myMethod</span>(msg);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">myMethod</span>(<span class="params">msg</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>.<span class="title function_">myMethod</span>(msg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Child</span>.<span class="title function_">myMethod</span>(<span class="number">1</span>); <span class="comment">// static 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child = <span class="keyword">new</span> <span class="title class_">Child</span>();</span><br><span class="line">child.<span class="title function_">myMethod</span>(<span class="number">2</span>); <span class="comment">// instance 2</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>super</code>在静态方法之中指向父类，在普通方法之中指向父类的原型对象。<br><br></p><p>另外，<ins>在子类的静态方法中通过<code>super</code>调用父类的方法时，方法内部的<code>this</code>指向当前的子类，而不是子类的实例</ins>。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">x</span> = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">print</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">x</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_ inherited__">A</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>();</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">x</span> = <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">m</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>.<span class="title function_">print</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">B.<span class="property">x</span> = <span class="number">3</span>;</span><br><span class="line">B.<span class="title function_">m</span>(); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>上面代码中，静态方法<code>B.m</code>里面，<code>super.print</code>指向父类的静态方法。这个方法里面的<code>this</code>指向的是<code>B</code>，而不是<code>B</code>的实例。</p><hr><h3 id="22-5-类的-prototype-属性和-proto-属性"><a href="#22-5-类的-prototype-属性和-proto-属性" class="headerlink" title="22.5 类的 prototype 属性和 __proto__ 属性"></a>22.5 类的 prototype 属性和 __proto__ 属性</h3><p>大多数浏览器的 <code>ES5</code> 实现之中，每一个对象都有<code>__proto__</code>属性，指向对应的构造函数的<code>prototype</code>属性。<code>Class</code> 作为构造函数的语法糖，同时有<code>prototype</code>属性和<code>__proto__</code>属性，因此同时存在两条继承链。</p><ul><li>子类的<code>__proto__</code>属性，<ins>表示构造函数的继承，总是指向父类</ins>。</li><li>子类<code>prototype</code>属性的<code>__proto__</code>属性，<ins>表示方法的继承，总是指向父类的<code>prototype</code>属性</ins>。</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_ inherited__">A</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">B.<span class="property">__proto__</span> === A; <span class="comment">// true</span></span><br><span class="line">B.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">__proto__</span> === A.<span class="property"><span class="keyword">prototype</span></span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面代码中，<ins>子类<code>B</code>的<code>__proto__</code>属性指向父类<code>A</code>，子类<code>B</code>的<code>prototype</code>属性的<code>__proto__</code>属性指向父类<code>A</code>的<code>prototype</code>属性</ins>。</p><p>这两条继承链，可以这样理解：</p><ul><li>作为一个对象，子类（<code>B</code>）的原型（<code>__proto__</code>属性）是父类（<code>A</code>）。</li><li>作为一个构造函数，子类（<code>B</code>）的原型对象（<code>prototype</code>属性）是父类的原型对象（<code>prototype</code>属性）的实例。</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">B.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(A.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">B.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">__proto__</span> = A.<span class="property"><span class="keyword">prototype</span></span>;</span><br></pre></td></tr></table></figure><hr><h3 id="22-6-原生构造函数的继承"><a href="#22-6-原生构造函数的继承" class="headerlink" title="22.6 原生构造函数的继承"></a>22.6 原生构造函数的继承</h3><p><code>ES6</code> 允许继承原生构造函数定义子类，因为 <code>ES6</code> 是先新建父类的实例对象<code>this</code>，然后再用子类的构造函数修饰<code>this</code>，使得父类的所有行为都可以继承。下面是一个继承<code>Array</code>的例子。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyArray</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Array</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(...args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="title class_">MyArray</span>();</span><br><span class="line">arr[<span class="number">0</span>] = <span class="number">12</span>;</span><br><span class="line">arr.<span class="property">length</span>; <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">arr.<span class="property">length</span> = <span class="number">0</span>;</span><br><span class="line">arr[<span class="number">0</span>]; <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>上面代码定义了一个<code>MyArray</code>类，继承了<code>Array</code>构造函数，因此就可以从<code>MyArray</code>生成数组的实例。这意味着，<code>ES6</code> 可以自定义原生数据结构（比如<code>Array</code>、<code>String</code>等）的子类，这是 <code>ES5</code> 无法做到的。<br><br></p><p>上面这个例子也说明，<code>extends</code>关键字不仅可以用来继承类，还可以用来继承原生的构造函数。因此可以在原生数据结构的基础上，定义自己的数据结构。下面就是定义了一个带版本功能的数组。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">VersionedArray</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Array</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>();</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">history</span> = [[]];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">commit</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">history</span>.<span class="title function_">push</span>(<span class="variable language_">this</span>.<span class="title function_">slice</span>());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">revert</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">splice</span>(<span class="number">0</span>, <span class="variable language_">this</span>.<span class="property">length</span>, ...<span class="variable language_">this</span>.<span class="property">history</span>[<span class="variable language_">this</span>.<span class="property">history</span>.<span class="property">length</span> - <span class="number">1</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x = <span class="keyword">new</span> <span class="title class_">VersionedArray</span>();</span><br><span class="line"></span><br><span class="line">x.<span class="title function_">push</span>(<span class="number">1</span>);</span><br><span class="line">x.<span class="title function_">push</span>(<span class="number">2</span>);</span><br><span class="line">x; <span class="comment">// [1, 2]</span></span><br><span class="line">x.<span class="property">history</span>; <span class="comment">// [[]]</span></span><br><span class="line"></span><br><span class="line">x.<span class="title function_">commit</span>();</span><br><span class="line">x.<span class="property">history</span>; <span class="comment">// [[], [1, 2]]</span></span><br><span class="line"></span><br><span class="line">x.<span class="title function_">push</span>(<span class="number">3</span>);</span><br><span class="line">x; <span class="comment">// [1, 2, 3]</span></span><br><span class="line">x.<span class="property">history</span>; <span class="comment">// [[], [1, 2]]</span></span><br><span class="line"></span><br><span class="line">x.<span class="title function_">revert</span>();</span><br><span class="line">x; <span class="comment">// [1, 2]</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>VersionedArray</code>会通过<code>commit</code>方法，将自己的当前状态生成一个版本快照，存入<code>history</code>属性。<code>revert</code>方法用来将数组重置为最新一次保存的版本。除此之外，<code>VersionedArray</code>依然是一个普通数组，所有原生的数组方法都可以在它上面调用。<br><br></p><p>注意，继承<code>Object</code>的子类，有一个<a href="https://stackoverflow.com/questions/36203614/super-does-not-pass-arguments-when-instantiating-a-class-extended-from-object">行为差异</a>。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NewObj</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Object</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(...<span class="variable language_">arguments</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="title class_">NewObj</span>(&#123; <span class="attr">attr</span>: <span class="literal">true</span> &#125;);</span><br><span class="line">o.<span class="property">attr</span> === <span class="literal">true</span>; <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>NewObj</code>继承了<code>Object</code>，但是无法通过<code>super</code>方法向父类<code>Object</code>传参。这是因为 <code>ES6</code> 改变了<code>Object</code>构造函数的行为，一旦发现<code>Object</code>方法不是通过<code>new Object()</code>这种形式调用，<code>ES6</code> 规定<code>Object</code>构造函数会忽略参数。</p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> ES6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ES6学习笔记 • 中</title>
      <link href="/posts/9413d22e.html"/>
      <url>/posts/9413d22e.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>本读书笔记节是针对阮一峰编写的 <a href="https://es6.ruanyifeng.com/">《ECMAScript 6 入门教程》</a>的总结。适合已经掌握 <code>ES5</code> 的读者，用来了解这门语言的最新发展。笔记内容仅包括日常开发中可能会用到的概念。</p></blockquote><hr><h2 id="16-Promise-对象"><a href="#16-Promise-对象" class="headerlink" title="16. Promise 对象"></a>16. Promise 对象</h2><h3 id="16-1-事件循环"><a href="#16-1-事件循环" class="headerlink" title="16.1 事件循环"></a>16.1 事件循环</h3><p>推荐阅读：<a href="https://segmentfault.com/a/1190000038928521">js 事件循环机制 event-loop</a><br><br></p><p><code>JavaScript</code>是单线程语言，代码按顺序执行，但为了处理耗时操作（如网络请求、定时器），引入了异步机制。<br><br></p><p>执行顺序原则: 先同步，再异步；异步中先微任务，后宏任务</p><ul><li>宏任务（<code>macro-task</code>）：<code>setTimeout</code>、<code>setInterval</code>、整体代码<code>script</code></li><li>微任务（<code>micro-task</code>）：<code>Promise.then/catch</code>、<code>process.nextTick</code></li></ul><p>事件循环流程</p><ul><li><ol><li>同步任务直接在主线程执行</li></ol></li><li><ol start="2"><li>异步任务进入<code>Event Table</code>注册，完成后进入<code>Event Queue</code></li></ol></li><li><ol start="3"><li>主线程执行完毕后，从<code>Event Queue</code>读取任务执行</li></ol></li><li><ol start="4"><li>每执行完一个宏任务，就会清空所有微任务</li></ol></li><li><ol start="5"><li>然后进入下一个宏任务，循环往复</li></ol></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;1&#x27;</span>);  <span class="comment">// 同步，立即执行</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;2&#x27;</span>);  <span class="comment">// 宏任务</span></span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;3&#x27;</span>);  <span class="comment">// 微任务</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;4&#x27;</span>);  <span class="comment">// 同步，立即执行</span></span><br></pre></td></tr></table></figure><blockquote><p>输出顺序：1 → 4 → 3 → 2</p></blockquote><ul><li><code>setTimeout(fn, 0)</code> 不是立即执行，而是在主线程空闲时执行</li><li><code>new Promise</code> 的构造函数是同步执行的，只有 <code>.then()</code> 是异步的</li><li>每轮循环都是：执行一个宏任务 → 清空所有微任务 → 下一个宏任务</li></ul><hr><h3 id="16-2-Promise-的含义"><a href="#16-2-Promise-的含义" class="headerlink" title="16.2 Promise 的含义"></a>16.2 Promise 的含义</h3><p><code>Promise</code> 是异步编程的一种解决方案，比传统的<a href="https://segmentfault.com/a/1190000021942060">回调函数</a>和<a href="https://zh.javascript.info/introduction-browser-events">事件</a>，更合理和更强大。它类似于一个容器，里面保存着某个未来才会结束的事件，通常是一个异步操作的结果。<br><br></p><p><code>Promise</code>对象有以下两个特点</p><ul><li><ins><code>Promise</code>对象的状态不受外界影响</ins>。<code>Promise</code>对象代表一个异步操作，有三种状态：<code>pending</code>（进行中）、<code>fulfilled</code>（已成功）和<code>rejected</code>（已失败）。<ins>只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态</ins>。</li><li><ins><code>Promise</code>对象一旦状态改变，就不会再变</ins>。<code>Promise</code>对象的状态改变，只有两种可能：从<code>pending</code>变为<code>fulfilled</code>和从<code>pending</code>变为<code>rejected</code>。只要这两种情况发生，状态就凝固了，这时就称为 <code>resolved</code>（已定型）。</li></ul><p><code>Promise</code>对象的好处，是可以<ins>将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数</ins>。此外，<code>Promise</code>对象提供统一的接口，使得控制异步操作更加容易。<br><br></p><p><code>Promise</code>也有缺点。首先，<ins>无法取消<code>Promise</code>，一旦新建它就会立即执行，无法中途取消</ins>。其次，<ins>如果不设置回调函数，<code>Promise</code>内部抛出的错误，不会反应到外部</ins>。第三，当处于<code>pending</code>状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。</p><hr><h3 id="16-3-基本用法"><a href="#16-3-基本用法" class="headerlink" title="16.3 基本用法"></a>16.3 基本用法</h3><p><code>Promise</code>的构造函数接受一个函数作为参数，该函数的两个参数分别是<code>resolve</code>和<code>reject</code>。它们是两个函数，由 <code>JavaScript</code> 引擎提供，不用自己部署。</p><ul><li><code>resolve</code>函数的作用是，将<code>Promise</code>对象的状态从“未完成”变为“成功”（即从 <code>pending</code> 变为 <code>resolved</code>），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去。</li><li><code>reject</code>函数的作用是，将<code>Promise</code>对象的状态从“未完成”变为“失败”（即从 <code>pending</code> 变为 <code>rejected</code>），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="comment">/* 异步操作成功 */</span>)&#123;</span><br><span class="line">    <span class="title function_">resolve</span>(value);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="title function_">reject</span>(error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>Promise</code>实例生成后可以<ins>用<code>then</code>方法指定<code>resolved</code>和<code>rejected</code>的回调函数。这两个函数都是可选的，不一定要提供。它们都接受<code>Promise</code>对象传出的值作为参数</ins>。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">promise.<span class="title function_">then</span>(</span><br><span class="line">  <span class="keyword">function</span> (<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="comment">// success</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">function</span> (<span class="params">error</span>) &#123;</span><br><span class="line">    <span class="comment">// failure</span></span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>下面是一个<code>Promise</code>对象的例子。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">timeout</span>(<span class="params">ms</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// https://developer.mozilla.org/en-US/docs/Web/API/setTimeout</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(resolve, ms, <span class="string">&quot;done&quot;</span>); <span class="comment">// &#x27;done&#x27; 会传入回调函数 resolve</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">timeout</span>(<span class="number">1000</span>).<span class="title function_">then</span>(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 1秒后 &quot;done&quot;</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>timeout</code>方法返回一个<code>Promise</code>实例，表示一段时间以后才会发生的结果。过了指定的时间后，<code>Promise</code>实例的状态变为<code>resolved</code>，就会触发<code>then</code>方法绑定的回调函数。<br><br></p><p><ins><code>Promise</code> 新建后就会立即执行</ins>。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">  <span class="title function_">resolve</span>();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise.<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;resolved.&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hi!&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Hello</span></span><br><span class="line"><span class="comment">// Hi!</span></span><br><span class="line"><span class="comment">// resolved</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>Promise</code> 新建后立即执行，所以首先输出的是<code>Hello</code>。然后，<ins><code>then</code>方法指定的回调函数，将在当前脚本所有同步任务执行完才会执行</ins>，所以<code>resolved</code>最后输出。<br><br></p><p>如果<ins>调用<code>resolve</code>函数和<code>reject</code>函数时带有参数</ins>，那么它们的<ins>参数会被传递给回调函数</ins>。</p><ul><li><code>reject</code>函数的参数通常是<code>Error</code>对象的实例，表示抛出的错误。</li><li><code>resolve</code>函数的参数除了正常的值以外，还可能是另一个 <code>Promise</code> 实例。</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="title function_">resolve</span>(p1);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，<code>p1</code>和<code>p2</code>都是 <code>Promise</code> 的实例，但是<code>p2</code>的<code>resolve</code>方法将<code>p1</code>作为参数，即一个异步操作的结果是返回另一个异步操作。这时<code>p1</code>的状态就会传递给<code>p2</code>，此时<code>p1</code>的状态决定了<code>p2</code>的状态。</p><ul><li>如果<code>p1</code>的状态是<code>pending</code>，那么<code>p2</code>的回调函数就会等待<code>p1</code>的状态改变。</li><li>如果<code>p1</code>的状态已经是<code>resolved</code>或者<code>rejected</code>，那么<code>p2</code>的回调函数将会立刻执行。</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;fail&quot;</span>)), <span class="number">3000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">resolve</span>(p1), <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p2.<span class="title function_">then</span>(<span class="function">(<span class="params">result</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(result)).<span class="title function_">catch</span>(<span class="function">(<span class="params">error</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(error));</span><br><span class="line"><span class="comment">// Error: fail</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>p1</code>是一个 <code>Promise</code>，<code>3</code> 秒之后变为<code>rejected</code>。<code>p2</code>的状态在 <code>1</code> 秒之后改变，而且<code>resolve</code>方法返回的是<code>p1</code>。</p><ul><li>由于<code>p2</code>返回的是另一个 <code>Promise</code>，导致<code>p2</code>自己的状态无效了，<ins>由<code>p1</code>的状态决定<code>p2</code>的状态</ins>。所以，后面的<code>then</code>语句都变成针对后者<code>p1</code>。又过了 <code>2</code> 秒，<code>p1</code>变为<code>rejected</code>，导致触发<code>catch</code>方法指定的回调函数。</li></ul><p>注意，调用<code>resolve</code>或<code>reject</code>并不会终结 <code>Promise</code> 的参数函数的执行。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">(<span class="params">r</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(r);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>上面代码中，调用<code>resolve(1)</code>以后，后面的<code>console.log(2)</code>还是会执行，<ins>并且会首先打印出来。这是因为立即 <code>resolved</code> 的 <code>Promise</code> 是在本轮事件循环的末尾执行，总是晚于本轮循环的同步任务</ins>。<br><br></p><p>一般来说，调用<code>resolve</code>或<code>reject</code>以后，<code>Promise</code> 的使命就完成了，后继操作应该放到<code>then</code>方法里面，而不应该直接写在<code>resolve</code>或<code>reject</code>的后面。所以，<ins>最好在它们前面加上<code>return</code>语句</ins>，这样就不会有意外。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">resolve</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="comment">// 后面的语句不会执行</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><hr><h3 id="16-4-then-方法"><a href="#16-4-then-方法" class="headerlink" title="16.4 then 方法"></a>16.4 then 方法</h3><p><code>Promise.then()</code>方法的作用是为 <code>Promise</code> 实例添加状态改变时的回调函数。<ins><code>then</code>方法的第一个参数是<code>resolved</code>状态的回调函数，第二个参数是<code>rejected</code>状态的回调函数</ins>，它们都是可选的。<br><br></p><p><ins><code>then</code>方法返回的是一个新的<code>Promise</code>实例</ins>，因此可以采用链式写法，即<code>then</code>方法后面再调用另一个<code>then</code>方法。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">getJSON</span>(<span class="string">&quot;/posts.json&quot;</span>)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">json</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> json.<span class="property">post</span>;</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">post</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>上面的代码使用<code>then</code>方法，依次指定了两个回调函数。<ins>第一个回调函数完成以后，会将返回结果作为参数，传入第二个回调函数</ins>。<br><br></p><p>链式写法的<code>then</code>，可以指定一组按照次序调用的回调函数。<ins>这时，前一个回调函数，有可能返回的还是一个<code>Promise</code>对象（即有异步操作），这时后一个回调函数，就会等待该<code>Promise</code>对象的状态发生变化，才会被调用</ins>。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">getJSON</span>(<span class="string">&quot;/post/1.json&quot;</span>)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">post</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">getJSON</span>(post.<span class="property">commentURL</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(</span><br><span class="line">    <span class="keyword">function</span> (<span class="params">comments</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;resolved: &quot;</span>, comments);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">function</span> (<span class="params">err</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;rejected: &quot;</span>, err);</span><br><span class="line">    &#125;</span><br><span class="line">  );</span><br></pre></td></tr></table></figure><p>上面代码中，第一个<code>then</code>方法指定的回调函数，返回的是另一个<code>Promise</code>对象。<ins>这时，第二个<code>then</code>方法指定的回调函数，就会等待这个新的<code>Promise</code>对象状态发生变化</ins>。</p><ul><li>如果变为<code>resolved</code>，第二个<code>then</code>方法就调用第一个回调函数。</li><li>如果状态变为<code>rejected</code>，第二个<code>then</code>方法就调用第二个回调函数。</li></ul><p>如果采用箭头函数，上面的代码可以写得更简洁。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">getJSON</span>(<span class="string">&quot;/post/1.json&quot;</span>)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">post</span>) =&gt;</span> <span class="title function_">getJSON</span>(post.<span class="property">commentURL</span>))</span><br><span class="line">  .<span class="title function_">then</span>(</span><br><span class="line">    <span class="function">(<span class="params">comments</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;resolved: &quot;</span>, comments),</span><br><span class="line">    <span class="function">(<span class="params">err</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;rejected: &quot;</span>, err)</span><br><span class="line">  );</span><br></pre></td></tr></table></figure><hr><h3 id="16-5-catch-方法"><a href="#16-5-catch-方法" class="headerlink" title="16.5 catch 方法"></a>16.5 catch 方法</h3><p><code>Promise.catch()</code>方法用于指定发生错误时的回调函数。<ins>它返回的是一个新的<code>Promise</code>对象</ins>。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">getJSON</span>(<span class="string">&quot;/posts.json&quot;</span>)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">posts</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="keyword">function</span> (<span class="params">error</span>) &#123;</span><br><span class="line">    <span class="comment">// 处理 getJSON 和 前一个回调函数运行时发生的错误</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;发生错误！&quot;</span>, error);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，<code>getJSON()</code>方法返回一个 <code>Promise</code> 对象。</p><ul><li>如果该对象状态变为<code>resolved</code>，则会调用<code>then()</code>方法指定的回调函数。</li><li>如果异步操作抛出错误，状态就会变为<code>rejected</code>，就会调用<code>catch()</code>方法指定的回调函数处理这个错误。</li></ul><p>注意，<ins><code>then()</code>方法指定的回调函数，如果运行中抛出错误，也会被<code>catch()</code>方法捕获</ins>。</p><p>下面代码中，<code>promise</code>抛出一个错误，被<code>catch()</code>方法指定的回调函数捕获。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;test&quot;</span>); <span class="comment">// or reject(new Error(&#x27;test&#x27;));</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise.<span class="title function_">catch</span>(<span class="keyword">function</span> (<span class="params">error</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(error);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// Error: test</span></span><br></pre></td></tr></table></figure><p>下面两种写法与上面是等价的。（比较喜欢<code>try...catch...</code>的写法）<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="title function_">reject</span>(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise.<span class="title function_">catch</span>(<span class="keyword">function</span> (<span class="params">error</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(error);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">  <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;test&quot;</span>));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise.<span class="title function_">catch</span>(<span class="keyword">function</span> (<span class="params">error</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>注意，如果<code>Promise</code>状态已经变成<code>resolved</code>，再抛出错误是无效的。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="string">&quot;ok&quot;</span>);</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise</span><br><span class="line">  .<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="keyword">function</span> (<span class="params">error</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(error);</span><br><span class="line">  &#125;);</span><br><span class="line"><span class="comment">// ok</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>Promise</code> 在<code>resolve</code>语句后面，再抛出错误，并不会被捕获。因为 <code>Promise</code> 的状态一旦改变，就永久保持该状态。<br><br></p><p><code>Promise</code> 对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止。也就是说，错误总是会被下一个<code>catch</code>语句捕获。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">getJSON</span>(<span class="string">&quot;/post/1.json&quot;</span>)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">post</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">getJSON</span>(post.<span class="property">commentURL</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">comments</span>) &#123;</span><br><span class="line">    <span class="comment">// some code</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="keyword">function</span> (<span class="params">error</span>) &#123;</span><br><span class="line">    <span class="comment">// 处理前面三个Promise产生的错误</span></span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，一共有三个 <code>Promise</code> 对象: 一个由<code>getJSON()</code>产生，两个由<code>then()</code>产生。它们之中任何一个抛出的错误，都会被最后一个<code>catch()</code>捕获。<br><br></p><p>一般来说，<ins>不要在<code>then()</code>方法里面定义 <code>Reject</code> 状态的回调函数，总是使用<code>catch</code>方法</ins>。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line">promise.<span class="title function_">then</span>(</span><br><span class="line">  <span class="keyword">function</span> (<span class="params">data</span>) &#123;</span><br><span class="line">    <span class="comment">// success</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">function</span> (<span class="params">err</span>) &#123;</span><br><span class="line">    <span class="comment">// error</span></span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line">promise</span><br><span class="line">  .<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">data</span>) &#123;</span><br><span class="line">    <span class="comment">// success</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="keyword">function</span> (<span class="params">err</span>) &#123;</span><br><span class="line">    <span class="comment">// error</span></span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>跟传统的<code>try/catch</code>代码块不同的是，<ins>如果没有使用<code>catch()</code>方法指定错误处理的回调函数，<code>Promise</code> 对象抛出的错误不会传递到外层代码</ins>，即不会有任何反应。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> someAsyncThing = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">    <span class="comment">// 下面一行会报错，因为 x 没有声明</span></span><br><span class="line">    <span class="title function_">resolve</span>(x + <span class="number">2</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">someAsyncThing</span>().<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;everything is great&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">123</span>);</span><br><span class="line">&#125;, <span class="number">2000</span>);</span><br><span class="line"><span class="comment">// Uncaught (in promise) ReferenceError: x is not defined</span></span><br><span class="line"><span class="comment">// 123</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>someAsyncThing()</code>函数产生的 <code>Promise</code> 对象，内部有语法错误。运行到这一行时，会打印出错误提示，但是不会终止脚本执行，<code>2</code> 秒之后还是会输出<code>123</code>。这就是说，<ins><code>Promise</code> 内部的错误不会影响到 <code>Promise</code> 外部的代码</ins>，通俗的说法就是“<code>Promise</code> 会吃掉错误”。<br><br></p><p>所以建议，<code>Promise</code> 对象后面要跟<code>catch()</code>方法，这样可以处理 <code>Promise</code> 内部发生的错误。注意，<ins><code>catch()</code>方法返回的是一个新的<code>Promise</code>对象</ins>，因此后面还可以接着调用<code>then()</code>方法，或者<code>catch()</code>方法，去处理前一个<code>catch()</code>方法抛出的错误。</p><hr><h3 id="16-6-finally-方法"><a href="#16-6-finally-方法" class="headerlink" title="16.6 finally 方法"></a>16.6 finally 方法</h3><p><code>Promise.finally()</code>方法用于指定不管<code>Promise</code>对象最后状态如何，都会执行的操作。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">promise</span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">result</span> =&gt;</span> &#123;···&#125;)</span><br><span class="line">.<span class="title function_">catch</span>(<span class="function"><span class="params">error</span> =&gt;</span> &#123;···&#125;)</span><br><span class="line">.<span class="title function_">finally</span>(<span class="function">() =&gt;</span> &#123;···&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，不管<code>promise</code>最后的状态，在执行完<code>then</code>或<code>catch</code>指定的回调函数以后，都会执行<code>finally</code>方法指定的回调函数。<br><br></p><p>下面是一个例子，服务器使用 <code>Promise</code> 处理请求，然后使用<code>finally</code>方法关掉服务器。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">server</span><br><span class="line">  .<span class="title function_">listen</span>(port)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">finally</span>(server.<span class="property">stop</span>);</span><br></pre></td></tr></table></figure><p>由于<ins><code>finally</code>方法的回调函数不接受任何参数</ins>，这表明<ins><code>finally</code>方法里面的操作，应该是与状态无关的，不依赖于<code>Promise</code>的执行结果</ins>。</p><hr><h3 id="16-7-all-方法"><a href="#16-7-all-方法" class="headerlink" title="16.7 all 方法"></a>16.7 all 方法</h3><p><code>Promise.all()</code>方法用于将多个<code>Promise</code>实例，包装成一个新的<code>Promise</code>实例。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="title class_">Promise</span>.<span class="title function_">all</span>([p1, p2, p3]); <span class="comment">// 接受一个数组作为参数</span></span><br></pre></td></tr></table></figure><p>上面<code>p</code>的状态由<code>p1</code>、<code>p2</code>、<code>p3</code>决定，分成两种情况</p><ul><li>只有<code>p1</code>、<code>p2</code>、<code>p3</code>的<ins>状态都变成<code>fulfilled</code>，<code>p</code>的状态才会变成<code>fulfilled</code></ins>，此时<ins><code>p1</code>、<code>p2</code>、<code>p3</code>的返回值组成一个数组，传递给<code>p</code>的回调函数</ins>。</li><li>只要<code>p1</code>、<code>p2</code>、<code>p3</code>之中<ins>有一个被<code>rejected</code>，<code>p</code>的状态就变成<code>rejected</code></ins>，此时<ins>第一个被<code>reject</code>的实例的返回值，会传递给<code>p</code>的回调函数</ins>。</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 生成一个Promise对象的数组</span></span><br><span class="line"><span class="keyword">const</span> promises = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>].<span class="title function_">map</span>(<span class="keyword">function</span> (<span class="params">id</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">getJSON</span>(<span class="string">&quot;/post/&quot;</span> + id + <span class="string">&quot;.json&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">all</span>(promises)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">posts</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="keyword">function</span> (<span class="params">reason</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，只有<code>promises</code>中<code>6</code>个<code>Promise</code>实例的状态都变成<code>fulfilled</code>，或者有一个变为<code>rejected</code>，才会调用<code>Promise.all()</code>方法后面的回调函数。<br><br></p><p>下面是另一个例子。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> databasePromise = <span class="title function_">connectDatabase</span>(); <span class="comment">// 这里应该是返回一个 Promise 实例</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> booksPromise = databasePromise.<span class="title function_">then</span>(findAllBooks); <span class="comment">// 返回一个 Promise Object，为当前 Promise 的状态</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> userPromise = databasePromise.<span class="title function_">then</span>(getCurrentUser);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">all</span>([booksPromise, userPromise]).<span class="title function_">then</span>(<span class="function">(<span class="params">[books, user]</span>) =&gt;</span></span><br><span class="line">  <span class="title function_">pickTopRecommendations</span>(books, user)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>上面代码中，<code>booksPromise</code>和<code>userPromise</code>是两个异步操作，只有等到它们的结果都返回了，才会触发<code>pickTopRecommendations</code>这个回调函数。<br><br></p><p>注意，如果<ins>作为参数的 <code>Promise</code> 实例，自己定义了<code>catch</code>方法，那么它一旦被<code>rejected</code>，并不会触发<code>Promise.all()</code>的<code>catch</code>方法</ins>。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">&#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">result</span>) =&gt;</span> result)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function">(<span class="params">e</span>) =&gt;</span> e);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;报错了&quot;</span>);</span><br><span class="line">&#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">result</span>) =&gt;</span> result)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function">(<span class="params">e</span>) =&gt;</span> e);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">all</span>([p1, p2])</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">result</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(result))</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function">(<span class="params">e</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(e));</span><br><span class="line"><span class="comment">// [&quot;hello&quot;, Error: 报错了]</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>p1</code>是<code>resolved</code>，<code>p2</code>会被<code>rejected</code>。但是<code>p2</code>有自己的<code>catch</code>方法，返回一个新的 <code>Promise</code> 实例，<code>p2</code>实际指向的是这个新的实例。<ins>该实例执行完<code>catch</code>方法后，也会变成<code>resolved</code>，导致<code>Promise.all()</code>方法参数里面的两个实例都会<code>resolved</code>，因此会调用<code>then</code>方法指定的回调函数</ins>，而不会调用<code>catch</code>方法指定的回调函数。<br><br></p><p>如果<code>p2</code>没有自己的<code>catch</code>方法，就会调用<code>Promise.all()</code>的<code>catch</code>方法。</p><hr><h3 id="16-8-race-方法"><a href="#16-8-race-方法" class="headerlink" title="16.8 race 方法"></a>16.8 race 方法</h3><p><code>Promise.race()</code>方法同样是将多个 <code>Promise</code> 实例，包装成一个新的 <code>Promise</code> 实例。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="title class_">Promise</span>.<span class="title function_">race</span>([p1, p2, p3]);</span><br></pre></td></tr></table></figure><p>上面代码中，只要<code>p1</code>、<code>p2</code>、<code>p3</code>之中<ins>有一个实例率先改变状态，<code>p</code>的状态就跟着改变</ins>。那个率先改变的 <code>Promise</code> 实例的返回值，就传递给<code>p</code>的回调函数。<br><br></p><p>下面如果指定时间内没有获得结果，就将 <code>Promise</code> 的状态变为<code>reject</code>，否则变为<code>resolve</code>。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="title class_">Promise</span>.<span class="title function_">race</span>([</span><br><span class="line">  <span class="title function_">fetch</span>(<span class="string">&quot;/resource-that-may-take-a-while&quot;</span>),</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;request timeout&quot;</span>)), <span class="number">5000</span>);</span><br><span class="line">  &#125;),</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line">p.<span class="title function_">then</span>(<span class="variable language_">console</span>.<span class="property">log</span>).<span class="title function_">catch</span>(<span class="variable language_">console</span>.<span class="property">error</span>);</span><br></pre></td></tr></table></figure><p>上面代码中，如果 <code>5</code> 秒之内<code>fetch</code>方法无法返回结果，变量<code>p</code>的状态就会变为<code>rejected</code>，从而触发<code>catch</code>方法指定的回调函数。</p><hr><h3 id="16-9-allSettled-方法"><a href="#16-9-allSettled-方法" class="headerlink" title="16.9 allSettled 方法"></a>16.9 allSettled 方法</h3><p>有时候，我们希望等到一组异步操作都结束，不管每一个操作是成功还是失败，再进行下一步操作。为了解决这个问题，<code>ES6</code> 引入了<code>Promise.allSettled()</code>方法。<br><br></p><p><code>Promise.allSettled()</code>方法接受一个<code>Promise</code>数组作为参数，并<ins>返回一个新的 <code>Promise</code> 对象</ins>。只有等到参数数组的<ins>所有 <code>Promise</code> 对象都发生状态变更，不管是<code>fulfilled</code>还是<code>rejected</code>，返回的 <code>Promise</code> 对象才会发生状态变更</ins>。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promises = [<span class="title function_">fetch</span>(<span class="string">&quot;/api-1&quot;</span>), <span class="title function_">fetch</span>(<span class="string">&quot;/api-2&quot;</span>), <span class="title function_">fetch</span>(<span class="string">&quot;/api-3&quot;</span>)];</span><br><span class="line"></span><br><span class="line"><span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">allSettled</span>(promises);</span><br><span class="line"><span class="title function_">removeLoadingIndicator</span>();</span><br></pre></td></tr></table></figure><p>上面示例中，数组<code>promises</code>包含了三个请求，只有等到这三个请求都结束了，不管请求成功还是失败，<code>removeLoadingIndicator()</code>才会执行。<br><br></p><p><code>Promise.allSettled()</code>返回的 <code>Promise</code> 实例，<ins>状态总是<code>fulfilled</code>，不会变成<code>rejected</code></ins>。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> resolved = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">42</span>);</span><br><span class="line"><span class="keyword">const</span> rejected = <span class="title class_">Promise</span>.<span class="title function_">reject</span>(-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> allSettledPromise = <span class="title class_">Promise</span>.<span class="title function_">allSettled</span>([resolved, rejected]);</span><br><span class="line"></span><br><span class="line">allSettledPromise.<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">results</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(results);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// [</span></span><br><span class="line"><span class="comment">//    &#123; status: &#x27;fulfilled&#x27;, value: 42 &#125;,</span></span><br><span class="line"><span class="comment">//    &#123; status: &#x27;rejected&#x27;, reason: -1 &#125;</span></span><br><span class="line"><span class="comment">// ]</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>Promise.allSettled()</code>的返回值<code>allSettledPromise</code>，状态只可能变成<code>fulfilled</code>。<ins>它的回调函数接收到的参数是数组<code>results</code>，对应传入<code>Promise.allSettled()</code>的数组里面的两个 <code>Promise</code> 对象</ins>。<br><br></p><p>上面<code>results</code>的每个成员是一个对象，对应异步操作的结果。（重点）<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 异步操作成功时</span></span><br><span class="line">&#123;<span class="attr">status</span>: <span class="string">&#x27;fulfilled&#x27;</span>, <span class="attr">value</span>: value&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步操作失败时</span></span><br><span class="line">&#123;<span class="attr">status</span>: <span class="string">&#x27;rejected&#x27;</span>, <span class="attr">reason</span>: reason&#125;</span><br></pre></td></tr></table></figure><p>成员对象的<code>status</code>属性的值只可能是字符串<code>fulfilled</code>或字符串<code>rejected</code>，用来区分异步操作是成功还是失败。<ins>如果是成功<code>fulfilled</code>，对象会有<code>value</code>属性，如果是失败<code>rejected</code>，会有<code>reason</code>属性</ins>，对应两种状态时前面异步操作的返回值。</p><hr><h3 id="16-10-any-方法"><a href="#16-10-any-方法" class="headerlink" title="16.10 any 方法"></a>16.10 any 方法</h3><p><code>Promise.any()</code> 接受一组 <code>Promise</code> 实例作为参数，包装成一个新的 <code>Promise</code> 实例返回。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">any</span>([</span><br><span class="line">  <span class="title function_">fetch</span>(<span class="string">&quot;https://v8.dev/&quot;</span>).<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="string">&quot;home&quot;</span>),</span><br><span class="line">  <span class="title function_">fetch</span>(<span class="string">&quot;https://v8.dev/blog&quot;</span>).<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="string">&quot;blog&quot;</span>),</span><br><span class="line">  <span class="title function_">fetch</span>(<span class="string">&quot;https://v8.dev/docs&quot;</span>).<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="string">&quot;docs&quot;</span>),</span><br><span class="line">])</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">first</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 只要有一个 fetch() 请求成功</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(first);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 所有三个 fetch() 全部请求失败</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(error);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><ul><li>只要参数实例有一个变成<code>fulfilled</code>状态，包装实例就会变成<code>fulfilled</code>状态。</li><li>如果所有参数实例都变成<code>rejected</code>状态，包装实例就会变成<code>rejected</code>状态。</li></ul><p>下面是<code>Promise()</code>与<code>await</code>命令结合使用的例子。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promises = [</span><br><span class="line">  <span class="title function_">fetch</span>(<span class="string">&quot;/endpoint-a&quot;</span>).<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="string">&quot;a&quot;</span>),</span><br><span class="line">  <span class="title function_">fetch</span>(<span class="string">&quot;/endpoint-b&quot;</span>).<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="string">&quot;b&quot;</span>),</span><br><span class="line">  <span class="title function_">fetch</span>(<span class="string">&quot;/endpoint-c&quot;</span>).<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="string">&quot;c&quot;</span>),</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> first = <span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">any</span>(promises);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(first);</span><br><span class="line">&#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(error);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>Promise.any()</code>方法的参数包含三个 <code>Promise</code> 操作。其中只要有一个变成<code>fulfilled</code>，<code>Promise.any()</code>返回的 <code>Promise</code> 对象就变成<code>fulfilled</code>。如果所有三个操作都变成<code>rejected</code>，那么<code>await</code>命令就会抛出错误。</p><hr><h3 id="16-11-resolve-方法"><a href="#16-11-resolve-方法" class="headerlink" title="16.11 resolve 方法"></a>16.11 resolve 方法</h3><p>有时需要将现有对象转为 <code>Promise</code> 对象，<code>Promise.resolve()</code>方法就起到这个作用。<br><br></p><p><strong>（1）参数是一个 thenable 对象</strong></p><p><code>thenable</code>对象指的是具有<code>then</code>方法的对象，比如下面这个对象。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> thenable = &#123;</span><br><span class="line">  <span class="attr">then</span>: <span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="number">42</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(thenable);</span><br><span class="line"></span><br><span class="line">p1.<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">value</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(value); <span class="comment">// 42</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，<ins><code>resolve()</code>方法会将这个对象转为 <code>Promise</code> 对象，然后立即执行<code>thenable</code>对象的<code>then()</code>方法</ins>。<br><br></p><p><strong>（2）参数不是具有 then()方法的对象，或根本就不是对象</strong></p><p>如果参数是一个原始值，或者是一个不具有<code>then()</code>方法的对象，则<code>resolve()</code>方法返回一个新的 <code>Promise</code> 对象，状态为<code>resolved</code>。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">p.<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">s</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(s);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// Hello</span></span><br></pre></td></tr></table></figure><p><strong>（3）不带有任何参数</strong></p><p><code>resolve()</code>方法调用时可以<ins>不带参数，直接返回一个<code>resolved</code>状态的 <code>Promise</code> 对象</ins>。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>();</span><br><span class="line"></span><br><span class="line">p.<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><ins>立即<code>resolve()</code>的 <code>Promise</code> 对象，是在本轮“事件循环”的结束时执行，而不是在下一轮“事件循环”的开始时</ins>。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;three&quot;</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;two&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;one&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// one</span></span><br><span class="line"><span class="comment">// two</span></span><br><span class="line"><span class="comment">// three</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>setTimeout(fn, 0)</code>在下一轮“事件循环”开始时执行，<code>resolve()</code>在本轮“事件循环”结束时执行，<code>console.log(&#39;one&#39;)</code>则是立即执行，因此最先输出。</p><hr><h3 id="16-12-reject-方法"><a href="#16-12-reject-方法" class="headerlink" title="16.12 reject 方法"></a>16.12 reject 方法</h3><p><code>Promise.reject(reason)</code>方法也会返回一个新的 <code>Promise</code> 实例，该实例的状态为<code>rejected</code>。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="string">&quot;出错了&quot;</span>);</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="title function_">reject</span>(<span class="string">&quot;出错了&quot;</span>));</span><br><span class="line"></span><br><span class="line">p.<span class="title function_">then</span>(<span class="literal">null</span>, <span class="keyword">function</span> (<span class="params">s</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(s);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 出错了</span></span><br></pre></td></tr></table></figure><p><code>Promise.reject()</code>方法的参数，会原封不动地作为<code>reject</code>的理由，变成后续方法的参数。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="string">&quot;出错了&quot;</span>).<span class="title function_">catch</span>(<span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(e === <span class="string">&quot;出错了&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure><hr><h2 id="17-Iterator-和-for…of-循环"><a href="#17-Iterator-和-for…of-循环" class="headerlink" title="17. Iterator 和 for…of 循环"></a>17. Iterator 和 for…of 循环</h2><h3 id="17-1-Iterator-概念"><a href="#17-1-Iterator-概念" class="headerlink" title="17.1 Iterator 概念"></a>17.1 Iterator 概念</h3><p>遍历器<code>Iterator</code>是一种接口，<ins>为各种不同的数据结构提供统一的访问机制</ins>。任何数据结构只要部署 <code>Iterator</code> 接口，就可以完成遍历操作，依次处理该数据结构的所有成员。<br><br></p><p><code>Iterator</code> 的遍历过程</p><ol><li>创建一个指针对象，指向当前数据结构的起始位置。</li><li>第一次调用指针对象的<code>next</code>方法，可以将指针指向数据结构的第一个成员。</li><li>第二次调用指针对象的<code>next</code>方法，指针就指向数据结构的第二个成员。</li><li>不断调用指针对象的<code>next</code>方法，直到它指向数据结构的结束位置。</li></ol><p>每一次调用<code>next</code>方法，都会返回数据结构的当前成员的信息。具体来说，就是返回一个包含<code>value</code>和<code>done</code>两个属性的对象。其中，<ins><code>value</code>属性是当前成员的值，<code>done</code>属性是一个布尔值，表示遍历是否结束</ins>。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = [<span class="number">1</span>, <span class="number">5</span>, <span class="number">15</span>, <span class="number">25</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> it = a[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]();</span><br><span class="line"></span><br><span class="line">it.<span class="title function_">next</span>().<span class="property">value</span>; <span class="comment">// 1</span></span><br><span class="line">it.<span class="title function_">next</span>().<span class="property">value</span>; <span class="comment">// 5</span></span><br><span class="line">it.<span class="title function_">next</span>().<span class="property">value</span>; <span class="comment">// 15</span></span><br></pre></td></tr></table></figure><p><code>ES6</code> 规定，默认的 <code>Iterator</code> 接口部署在数据结构的<code>Symbol.iterator</code>属性，或者说，一个数据结构只要具有<code>Symbol.iterator</code>属性，就可以认为是“可遍历的”。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">numbers</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">  [<span class="title class_">Symbol</span>.<span class="property">iterator</span>]: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> self = <span class="variable language_">this</span>;</span><br><span class="line">    <span class="keyword">let</span> idx = -<span class="number">1</span>; <span class="comment">// &lt;--- 抵消 ++ 的 side-effect</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">next</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        idx++;</span><br><span class="line">        <span class="comment">// 可以尝试 log 出下面的 object</span></span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">          <span class="attr">value</span>: self.<span class="property">numbers</span>[idx],</span><br><span class="line">          <span class="attr">done</span>: idx &gt;= self.<span class="property">numbers</span>.<span class="property">length</span>,</span><br><span class="line">        &#125;;</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> num <span class="keyword">of</span> obj) <span class="variable language_">console</span>.<span class="title function_">log</span>(num); <span class="comment">// 1 2 3</span></span><br></pre></td></tr></table></figure><p>上面代码中，对象<code>obj</code>是可遍历的，因为具有<code>Symbol.iterator</code>属性。执行这个属性，会返回一个遍历器对象。该对象的根本特征就是具有<code>next</code>方法。每次调用<code>next</code>方法，都会返回一个代表当前成员的信息对象，具有<code>value</code>和<code>done</code>两个属性。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 上面 iterator 打印出来的 objects</span></span><br><span class="line">&#123; <span class="attr">value</span>: <span class="number">1</span>, <span class="attr">done</span>: <span class="literal">false</span> &#125;</span><br><span class="line">&#123; <span class="attr">value</span>: <span class="number">2</span>, <span class="attr">done</span>: <span class="literal">false</span> &#125;</span><br><span class="line">&#123; <span class="attr">value</span>: <span class="number">3</span>, <span class="attr">done</span>: <span class="literal">false</span> &#125;</span><br><span class="line">&#123; <span class="attr">value</span>: <span class="literal">undefined</span>, <span class="attr">done</span>: <span class="literal">true</span> &#125;</span><br></pre></td></tr></table></figure><p>注意，<code>done</code> 不代表返回的值是否是最后一个，而是表示迭代器是否没有更多的值可以返回。</p><hr><h3 id="17-2-for…of-循环"><a href="#17-2-for…of-循环" class="headerlink" title="17.2 for…of 循环"></a>17.2 for…of 循环</h3><p><strong>（1）数组，Set 与 Map</strong></p><p><code>ES6</code> 的数组，<code>Set</code> 和 <code>Map</code> 原生具有 <code>Iterator</code> 接口。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;green&quot;</span>, <span class="string">&quot;blue&quot;</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> color <span class="keyword">of</span> arr) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(color);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// red green blue</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>(arr);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> color <span class="keyword">of</span> set) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(color);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// red green blue</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>().<span class="title function_">set</span>(<span class="string">&quot;a&quot;</span>, <span class="number">1</span>).<span class="title function_">set</span>(<span class="string">&quot;b&quot;</span>, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> pair <span class="keyword">of</span> map) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(pair);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// [&#x27;a&#x27;, 1]</span></span><br><span class="line"><span class="comment">// [&#x27;b&#x27;, 2]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> map) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(key + <span class="string">&quot; : &quot;</span> + value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// a : 1</span></span><br><span class="line"><span class="comment">// b : 2</span></span><br></pre></td></tr></table></figure><p>上面代码可以看出，<code>Set</code> 和 <code>Map</code> 遍历的顺序是按照各个成员被添加进数据结构的顺序。<br><br></p><p><strong>（2）计算生成的数据结构</strong></p><p>有些数据结构是在现有数据结构的基础上，计算生成的。比如，<code>ES6</code> 的数组、<code>Set</code>、<code>Map</code> 都部署了以下三个方法，调用后都返回遍历器对象。</p><ul><li><code>entries()</code> 返回一个遍历器对象，用来遍历[键名, 键值]组成的数组。</li><li><code>keys()</code> 返回一个遍历器对象，用来遍历所有的键名。</li><li><code>values()</code> 返回一个遍历器对象，用来遍历所有的键值。</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> pair <span class="keyword">of</span> arr.<span class="title function_">entries</span>()) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(pair);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// [0, &#x27;a&#x27;]</span></span><br><span class="line"><span class="comment">// [1, &#x27;b&#x27;]</span></span><br><span class="line"><span class="comment">// [2, &#x27;c&#x27;]</span></span><br></pre></td></tr></table></figure><p><strong>（3）类似数组的对象</strong></p><p>字符串是一个类似数组的对象，也原生具有 <code>Iterator</code> 接口。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 字符串</span></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> s <span class="keyword">of</span> str) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(s); <span class="comment">// h e l l o</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// arguments对象</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">printArgs</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">of</span> <span class="variable language_">arguments</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">printArgs</span>(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>);</span><br><span class="line"><span class="comment">// &#x27;a&#x27;</span></span><br><span class="line"><span class="comment">// &#x27;b&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>（4）对象</strong></p><p><code>for...of</code>不能直接使用于普通对象上，必须部署 <code>Iterator</code> 接口后才能使用。</p><ul><li>一种解决方法是，遍历<code>Object.keys()</code>生成的对象键名的数组。</li><li>一种解决方法是，使用 <code>Generator</code> 函数将对象重新包装。</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">c</span>: <span class="number">3</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方案一</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> <span class="title class_">Object</span>.<span class="title function_">keys</span>(obj)) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(key, <span class="string">&quot;-&gt;&quot;</span>, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方案二</span></span><br><span class="line"><span class="keyword">function</span>* <span class="title function_">entries</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> <span class="title class_">Object</span>.<span class="title function_">keys</span>(obj)) &#123;</span><br><span class="line">    <span class="keyword">yield</span> [key, obj[key]];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> <span class="title function_">entries</span>(obj)) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(key, <span class="string">&quot;-&gt;&quot;</span>, value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// a -&gt; 1</span></span><br><span class="line"><span class="comment">// b -&gt; 2</span></span><br><span class="line"><span class="comment">// c -&gt; 3</span></span><br></pre></td></tr></table></figure><hr><h2 id="18-Generator-函数"><a href="#18-Generator-函数" class="headerlink" title="18. Generator 函数"></a>18. Generator 函数</h2><h3 id="18-1-基本概念"><a href="#18-1-基本概念" class="headerlink" title="18.1 基本概念"></a>18.1 基本概念</h3><p><code>Generator</code> 函数是 <code>ES6</code> 提供的一种异步编程解决方案，语法行为与传统函数完全不同。</p><ul><li><strong>语法上：</strong><ins><code>Generator</code> 函数类似一个状态机，封装了多个内部状态</ins>。执行 <code>Generator</code> 函数会返回一个遍历器对象，<ins>可以依次遍历 <code>Generator</code> 函数内部的每一个状态</ins>。</li><li><strong>形式上：</strong><code>Generator</code> 函数是一个普通函数，但是有两个特征。一是，<code>function</code>关键字与函数名之间有一个星号；二是，函数体内部使用<code>yield</code>表达式，定义不同的内部状态。</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">hwGenerator</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&quot;world&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;ending&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> hw = <span class="title function_">hwGenerator</span>();</span><br></pre></td></tr></table></figure><p>上面代码定义了一个 <code>Generator</code> 函数<code>hwGenerator</code>，它内部有两个<code>yield</code>表达式<code>hello</code>和<code>world</code>，即该函数有三个状态：<code>hello</code>，<code>world</code> 和 <code>return</code> 语句。<br><br></p><p><code>Generator</code> 函数的调用方法与普通函数一样。不同的是，<ins>调用 <code>Generator</code> 函数后，该函数并不执行，返回的也不是函数运行结果，而是一个指向内部状态的指针对象</ins>。通过调用遍历器对象的<code>next</code>方法，<ins>使得指针移向下一个状态</ins>。<br><br></p><p>每次调用<code>next</code>方法，内部指针就从函数头部或上一次停下来的地方开始执行，直到遇到下一个<code>yield</code>表达式（或<code>return</code>语句）为止。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">hw.<span class="title function_">next</span>();</span><br><span class="line"><span class="comment">// &#123; value: &#x27;hello&#x27;, done: false &#125;</span></span><br><span class="line"></span><br><span class="line">hw.<span class="title function_">next</span>();</span><br><span class="line"><span class="comment">// &#123; value: &#x27;world&#x27;, done: false &#125;</span></span><br><span class="line"></span><br><span class="line">hw.<span class="title function_">next</span>();</span><br><span class="line"><span class="comment">// &#123; value: &#x27;ending&#x27;, done: true &#125;</span></span><br><span class="line"></span><br><span class="line">hw.<span class="title function_">next</span>();</span><br><span class="line"><span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure><p>总结，调用 <code>Generator</code> 函数，返回一个遍历器对象，代表 <code>Generator</code> 函数的内部指针。每次调用遍历器对象的<code>next</code>方法，就会返回一个有着<code>value</code>和<code>done</code>两个属性的对象。<code>value</code>属性表示当前的内部状态的值，是<code>yield</code>表达式后面那个表达式的值；<code>done</code>属性是一个布尔值，表示是否遍历结束。</p><hr><h3 id="18-2-yield-表达式"><a href="#18-2-yield-表达式" class="headerlink" title="18.2 yield 表达式"></a>18.2 yield 表达式</h3><p>由于 <code>Generator</code> 函数返回的<ins>遍历器对象，只有调用<code>next</code>方法才会遍历下一个内部状态</ins>，所以<code>Generator</code>其实<ins>提供了一种可以暂停执行的函数</ins>。<code>yield</code>表达式就是暂停标志。<br><br></p><p>遍历器对象的<code>next</code>方法的运行逻辑如下</p><ul><li><ins>遇到<code>yield</code>表达式，就暂停执行后面的操作，并将紧跟在<code>yield</code>后面的那个表达式的值，作为返回的对象的<code>value</code>属性值</ins>。</li><li>下一次调用<code>next</code>方法时，再继续往下执行，直到遇到下一个<code>yield</code>表达式。</li><li>如果没有再遇到新的<code>yield</code>表达式，就一直运行到函数结束，直到<code>return</code>语句为止，并将<code>return</code>语句后面的表达式的值，作为返回的对象的<code>value</code>属性值。</li><li>如果该函数没有<code>return</code>语句，则返回的对象的<code>value</code>属性值为<code>undefined</code>。</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">gen</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">123</span> + <span class="number">456</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> g = <span class="title function_">gen</span>();</span><br><span class="line">g.<span class="title function_">next</span>(); <span class="comment">// &#123;value: 579, done: false&#125;</span></span><br><span class="line">g.<span class="title function_">next</span>(); <span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure><p><code>yield</code>表达式与<code>return</code>语句既有相似之处，也有区别。相似之处在于，都能返回紧跟在语句后面的那个表达式的值。<ins>区别在于每次遇到<code>yield</code>，函数暂停执行，下一次再从该位置继续向后执行，而<code>return</code>语句不具备位置记忆的功能</ins>。一个函数里面，只能执行一次<code>return</code>语句，但是可以执行多次<code>yield</code>表达式。</p><hr><h3 id="18-3-与-Iterator-接口的关系"><a href="#18-3-与-Iterator-接口的关系" class="headerlink" title="18.3 与 Iterator 接口的关系"></a>18.3 与 Iterator 接口的关系</h3><p>由于 <code>Generator</code> 函数就是遍历器生成函数，因此可以把 <code>Generator</code> 赋值给对象的<code>Symbol.iterator</code>属性，从而使得该对象具有 <code>Iterator</code> 接口。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> myIterable = &#123;&#125;;</span><br><span class="line">myIterable[<span class="title class_">Symbol</span>.<span class="property">iterator</span>] = <span class="keyword">function</span>* () &#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">[...myIterable]; <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>Generator</code> 函数赋值给<code>Symbol.iterator</code>属性，从而使得<code>myIterable</code>对象具有了 <code>Iterator</code> 接口，可以被<code>...</code>运算符遍历了。</p><hr><h3 id="18-4-next-方法的参数"><a href="#18-4-next-方法的参数" class="headerlink" title="18.4 next 方法的参数"></a>18.4 next 方法的参数</h3><p><code>yield</code>表达式本身没有返回值，或者说总是返回<code>undefined</code>。<code>next</code>方法可以带一个参数，<ins>该参数就会被当作上一个<code>yield</code>表达式的返回值</ins>。（每一次调用<code>next</code>方法，都会返回数据结构的当前成员的信息）<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; <span class="literal">true</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> reset = <span class="keyword">yield</span> i;</span><br><span class="line">    <span class="keyword">if</span> (reset) &#123;</span><br><span class="line">      i = -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> g = <span class="title function_">f</span>(); <span class="comment">// 启动</span></span><br><span class="line"></span><br><span class="line">g.<span class="title function_">next</span>(); <span class="comment">// &#123; value: 0, done: false &#125;</span></span><br><span class="line">g.<span class="title function_">next</span>(); <span class="comment">// &#123; value: 1, done: false &#125;</span></span><br><span class="line">g.<span class="title function_">next</span>(<span class="literal">true</span>); <span class="comment">// &#123; value: 0, done: false &#125;</span></span><br><span class="line"><span class="comment">// 此时 rest 为 true，所以 i = -1，又因为 i++，</span></span><br><span class="line"><span class="comment">// 所以下一次运行到 yield i 的时候 i 就是 0</span></span><br></pre></td></tr></table></figure><p>上面代码定义了一个可以无限运行的 <code>Generator</code> 函数<code>f</code>，如果<code>next</code>方法没有参数，每次运行到<code>yield</code>表达式，变量<code>reset</code>的值总是<code>undefined</code>。当<code>next</code>方法带一个参数<code>true</code>时，变量<code>reset</code>就被重置为这个参数，因此<code>i</code>会等于<code>-1</code>，下一轮循环就会从<code>-1</code>开始递增。<br><br></p><p>这个功能有很重要的意义。<code>Generator</code> 函数从暂停状态到恢复运行，它的上下文状态<code>context</code>是不变的。通过<code>next</code>方法的参数，就有办法在 <code>Generator</code> 函数开始运行之后，继续向函数体内部注入值。<ins>从而在 <code>Generator</code> 函数运行的不同阶段，调整函数行为</ins>。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">foo</span>(<span class="params">x</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> y = <span class="number">2</span> * (<span class="keyword">yield</span> x + <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">let</span> z = <span class="keyword">yield</span> y / <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">return</span> x + y + z;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="title function_">foo</span>(<span class="number">5</span>);</span><br><span class="line">a.<span class="title function_">next</span>(); <span class="comment">// &#123; value:6, done:false &#125;</span></span><br><span class="line">a.<span class="title function_">next</span>(); <span class="comment">// 此时 y 为 undefined, &#123; value:NaN, done:false &#125;</span></span><br><span class="line">a.<span class="title function_">next</span>(); <span class="comment">// 此时 z 为 undefined, &#123; value:NaN, done:true &#125;</span></span><br></pre></td></tr></table></figure><p>上面代码中，第二次运行<code>next()</code>的时候不带参数，导致 <code>y</code> 的值等于<code>2 * undefined</code>，除以 <code>3</code> 以后变成<code>NaN</code>，因此返回对象的<code>value</code>属性也等于<code>NaN</code>。第三次运行<code>next</code>方法的时候不带参数，所以<code>z</code>等于<code>undefined</code>，返回对象的<code>value</code>属性等于<code>5 + NaN + undefined</code>，即<code>NaN</code>。<br><br></p><p>如果向<code>next</code>方法提供参数，返回结果就完全不一样。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> b = <span class="title function_">foo</span>(<span class="number">5</span>);</span><br><span class="line">b.<span class="title function_">next</span>(); <span class="comment">// &#123; value:6, done:false &#125;</span></span><br><span class="line">b.<span class="title function_">next</span>(<span class="number">12</span>); <span class="comment">// 此时 y 为 24, 因为 yield (x + 1) = 12, &#123; value:8, done:false &#125;</span></span><br><span class="line">b.<span class="title function_">next</span>(<span class="number">13</span>); <span class="comment">// 此时 z 为 13, 因为 yield (y / 3) = 13, &#123; value:42, done:true &#125;</span></span><br></pre></td></tr></table></figure><p>上面代码第一次调用<code>next</code>方法时，返回<code>x+1</code>的值<code>6</code>；第二次调用<code>next</code>方法，将上一次<code>yield</code>表达式的值设为<code>12</code>，因此<code>y</code>等于<code>24</code>，返回<code>y / 3</code>的值<code>8</code>；第三次调用<code>next</code>方法，将上一次<code>yield</code>表达式的值设为<code>13</code>，因此<code>z</code>等于<code>13</code>，这时<code>x</code>等于<code>5</code>，<code>y</code>等于<code>24</code>，所以<code>return</code>语句的值等于<code>42</code>。<br><br></p><p>注意，由于<code>next</code>方法的参数表示上一个<code>yield</code>表达式的返回值，所以在第一次使用<code>next</code>方法时，传递参数是无效的。</p><hr><h3 id="18-5-for…of-循环"><a href="#18-5-for…of-循环" class="headerlink" title="18.5 for…of 循环"></a>18.5 for…of 循环</h3><p><code>for...of</code>可以自动遍历 <code>Generator</code> 函数生成的<code>Iterator</code>对象，且不需要调用<code>next</code>方法。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> v <span class="keyword">of</span> <span class="title function_">foo</span>()) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1 2 3 (没有4)</span></span><br></pre></td></tr></table></figure><p>上面的代码可以看出，一旦返回对象的<code>done</code>属性为<code>true</code>，<code>for...of</code>循环就会中止，且不包含该返回对象。所以上面代码的<code>return</code>语句返回的<code>4</code>，不包括在<code>for...of</code>循环之中。<br><br></p><p>除了<code>for...of</code>循环以外，扩展运算符、解构赋值和<code>Array.from</code>方法内部调用的，都是遍历器接口。这意味着，它们都可以将 <code>Generator</code> 函数返回的遍历器对象，作为参数。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">numbers</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩展运算符</span></span><br><span class="line">[...<span class="title function_">numbers</span>()]; <span class="comment">// [1, 2]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Array.from 方法</span></span><br><span class="line"><span class="title class_">Array</span>.<span class="title function_">from</span>(<span class="title function_">numbers</span>()); <span class="comment">// [1, 2]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 解构赋值</span></span><br><span class="line"><span class="keyword">let</span> [x, y] = <span class="title function_">numbers</span>();</span><br><span class="line">x; <span class="comment">// 1</span></span><br><span class="line">y; <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><hr><h3 id="18-6-throw-方法"><a href="#18-6-throw-方法" class="headerlink" title="18.6 throw 方法"></a>18.6 throw 方法</h3><p>遍历器对象的<code>throw()</code>方法，可以<ins>在函数体外抛出错误，然后在 <code>Generator</code> 函数体内捕获</ins>。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> g = <span class="keyword">function</span>* () &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">yield</span>;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;内部捕获&quot;</span>, e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> i = <span class="title function_">g</span>();</span><br><span class="line">i.<span class="title function_">next</span>(); <span class="comment">// 初始化启动</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  i.<span class="keyword">throw</span>(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">  i.<span class="keyword">throw</span>(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;外部捕获&quot;</span>, e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 内部捕获 a</span></span><br><span class="line"><span class="comment">// 外部捕获 b</span></span><br></pre></td></tr></table></figure><p>上面代码中，遍历器对象<code>i</code>连续抛出两个错误。<ins>第一个错误被 <code>Generator</code> 函数体内的<code>catch</code>语句捕获</ins>。<code>i</code>第二次抛出错误，由于 <code>Generator</code> 函数内部的<code>catch</code>语句已经执行过了，不会再捕捉到这个错误了，所以这个错误就<ins>被函数体外的<code>catch</code>语句捕获</ins>。<br><br></p><p>注意，不要混淆遍历器对象的<code>throw</code>方法和全局的<code>throw</code>命令。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;外部捕获&quot;</span>, e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 外部捕获 [Error: a]</span></span><br></pre></td></tr></table></figure><p>上面代码之所以只捕获了<code>a</code>，是因为函数体外的<code>catch</code>语句块，捕获了抛出的<code>a</code>错误以后，就不会再继续<code>try</code>代码块里面剩余的语句了。</p><ul><li>如果 <code>Generator</code> 函数内部没有部署<code>try...catch</code>代码块，那么<code>throw</code>方法抛出的错误，<ins>将被外部<code>try...catch</code>代码块捕获</ins>。</li><li>如果 <code>Generator</code> 函数内部和外部，都没有部署<code>try...catch</code>代码块，那么程序将报错，直接中断执行。</li></ul><p><code>throw</code>方法抛出的错误要被内部捕获，<ins>前提是必须至少执行过一次<code>next</code>方法</ins>。同时，<ins><code>throw</code>方法被捕获后，会附带执行下一条<code>yield</code>表达式</ins>，等同于执行一次<code>next</code>方法。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> gen = <span class="keyword">function</span>* <span class="title function_">gen</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">yield</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">  <span class="keyword">yield</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> g = <span class="title function_">gen</span>();</span><br><span class="line">g.<span class="title function_">next</span>(); <span class="comment">// a</span></span><br><span class="line">g.<span class="keyword">throw</span>(); <span class="comment">// b</span></span><br><span class="line">g.<span class="title function_">next</span>(); <span class="comment">// c</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>g.throw()</code>方法被捕获以后，自动执行了一次<code>next</code>方法，所以会打印<code>b</code>。这里可以看出，<ins>只要 <code>Generator</code> 函数内部部署了<code>try...catch</code>代码块，那么遍历器的<code>throw</code>方法抛出的错误，不影响下一次遍历</ins>。<br><br></p><p><code>Generator</code> 函数体外抛出的错误，可以在函数体内捕获；反过来，<code>Generator</code> 函数体内抛出的错误，也可以被函数体外的<code>catch</code>捕获。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> x = <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">let</span> y = x.<span class="title function_">toUpperCase</span>();</span><br><span class="line">  <span class="keyword">yield</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> it = <span class="title function_">foo</span>();</span><br><span class="line"></span><br><span class="line">it.<span class="title function_">next</span>(); <span class="comment">// &#123; value:3, done:false &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  it.<span class="title function_">next</span>(<span class="number">42</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(err);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，第二个<code>next</code>方法向函数体内传入一个参数 <code>42</code>，数值是没有<code>toUpperCase</code>方法的，所以会抛出一个 <code>TypeError</code> 错误，被函数体外的<code>catch</code>捕获。</p><hr><h3 id="18-7-return-方法"><a href="#18-7-return-方法" class="headerlink" title="18.7 return 方法"></a>18.7 return 方法</h3><p>遍历器对象的<code>return()</code>方法，可以返回给定的值，并且<ins>终结遍历 <code>Generator</code> 函数</ins>。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">gen</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> g = <span class="title function_">gen</span>();</span><br><span class="line"></span><br><span class="line">g.<span class="title function_">next</span>(); <span class="comment">// &#123; value: 1, done: false &#125;</span></span><br><span class="line">g.<span class="keyword">return</span>(<span class="string">&quot;foo&quot;</span>); <span class="comment">// &#123; value: &quot;foo&quot;, done: true &#125;</span></span><br><span class="line">g.<span class="title function_">next</span>(); <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure><p>上面代码中，遍历器对象<code>g</code>调用<code>return()</code>方法后，返回值的<code>value</code>属性就是<code>return()</code>方法的参数<code>foo</code>。并且，<code>Generator</code> 函数的遍历就终止了，返回值的<code>done</code>属性为<code>true</code>。</p><ul><li>如果<code>return()</code>方法调用时，不提供参数，则返回值的<code>value</code>属性为<code>undefined</code>。</li><li>如果 <code>Generator</code> 函数内部有<code>try...finally</code>代码块，且正在执行<code>try</code>代码块，那么<code>return()</code>方法会导致立刻进入<code>finally</code>代码块。</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">numbers</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">5</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">6</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> g = <span class="title function_">numbers</span>();</span><br><span class="line">g.<span class="title function_">next</span>(); <span class="comment">// &#123; value: 1, done: false &#125;</span></span><br><span class="line">g.<span class="title function_">next</span>(); <span class="comment">// &#123; value: 2, done: false &#125;</span></span><br><span class="line">g.<span class="keyword">return</span>(<span class="number">7</span>); <span class="comment">// &#123; value: 4, done: false &#125;</span></span><br><span class="line">g.<span class="title function_">next</span>(); <span class="comment">// &#123; value: 5, done: false &#125;</span></span><br><span class="line">g.<span class="title function_">next</span>(); <span class="comment">// &#123; value: 7, done: true &#125;</span></span><br></pre></td></tr></table></figure><p>上面代码中，调用<code>return()</code>方法后，就开始执行<code>finally</code>代码块，不执行<code>try</code>里面剩下的代码了，然后等到<code>finally</code>代码块执行完，再返回<code>return()</code>方法指定的返回值。</p><hr><h3 id="18-8-方法的共同点"><a href="#18-8-方法的共同点" class="headerlink" title="18.8 方法的共同点"></a>18.8 方法的共同点</h3><p><code>Generator</code> 函数返回的遍历器对象的<code>next()</code>、<code>throw()</code>、<code>return()</code>本质上是同一件事，它们的作用都是让 <code>Generator</code> 函数恢复执行，并且使用不同的语句替换<code>yield</code>表达式。</p><ul><li><code>next()</code>方法是将<code>yield</code>表达式替换成一个值。</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> g = <span class="keyword">function</span>* (x, y) &#123;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="keyword">yield</span> x + y;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> gen = <span class="title function_">g</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">gen.<span class="title function_">next</span>(); <span class="comment">// Object &#123;value: 3, done: false&#125;</span></span><br><span class="line"></span><br><span class="line">gen.<span class="title function_">next</span>(<span class="number">1</span>); <span class="comment">// Object &#123;value: 1, done: true&#125;</span></span><br><span class="line"><span class="comment">// 相当于将 let result = yield x + y</span></span><br><span class="line"><span class="comment">// 替换成 let result = 1;</span></span><br></pre></td></tr></table></figure><ul><li><code>throw()</code>方法是将<code>yield</code>表达式替换成一个<code>throw</code>语句。</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">gen.<span class="keyword">throw</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;出错了&quot;</span>)); <span class="comment">// Uncaught Error: 出错了</span></span><br><span class="line"><span class="comment">// 相当于将 let result = yield x + y</span></span><br><span class="line"><span class="comment">// 替换成 let result = throw(new Error(&#x27;出错了&#x27;));</span></span><br></pre></td></tr></table></figure><ul><li><code>return()</code>方法是将<code>yield</code>表达式替换成一个<code>return</code>语句。</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">gen.<span class="keyword">return</span>(<span class="number">2</span>); <span class="comment">// Object &#123;value: 2, done: true&#125;</span></span><br><span class="line"><span class="comment">// 相当于将 let result = yield x + y</span></span><br><span class="line"><span class="comment">// 替换成 let result = return 2;</span></span><br></pre></td></tr></table></figure><hr><h3 id="18-9-yield-表达式"><a href="#18-9-yield-表达式" class="headerlink" title="18.9 yield* 表达式"></a>18.9 yield* 表达式</h3><p><code>ES6</code> 提供的<code>yield*</code>表达式，可以在一个 <code>Generator</code> 函数里面执行另一个 <code>Generator</code> 函数。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> delegatedIterator = (<span class="keyword">function</span>* () &#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&quot;Hello!&quot;</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&quot;Bye!&quot;</span>;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> delegatingIterator = (<span class="keyword">function</span>* () &#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&quot;Greetings!&quot;</span>;</span><br><span class="line">  <span class="keyword">yield</span>* delegatedIterator;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&quot;Ok, bye.&quot;</span>;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> delegatingIterator) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &quot;Greetings!</span></span><br><span class="line"><span class="comment">// &quot;Hello!&quot;</span></span><br><span class="line"><span class="comment">// &quot;Bye!&quot;</span></span><br><span class="line"><span class="comment">// &quot;Ok, bye.&quot;</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>delegatingIterator</code>是代理者，<code>delegatedIterator</code>是被代理者。如果被代理的 <code>Generator</code> 函数有<code>return</code>语句，那么就可以向代理它的 <code>Generator</code> 函数返回数据。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">genFuncWithReturn</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&quot;a&quot;</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&quot;b&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;The result&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span>* <span class="title function_">logReturned</span>(<span class="params">genObj</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="keyword">yield</span>* genObj;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[...<span class="title function_">logReturned</span>(<span class="title function_">genFuncWithReturn</span>())];</span><br><span class="line"><span class="comment">// The result</span></span><br><span class="line"><span class="comment">// 值为 [ &#x27;a&#x27;, &#x27;b&#x27; ]</span></span><br></pre></td></tr></table></figure><p>上面代码中，存在两次遍历。</p><ul><li>第一次是扩展运算符遍历函数<code>logReturned</code>返回的遍历器对象。</li><li>第二次是<code>yield*</code>语句遍历函数<code>genFuncWithReturn</code>返回的遍历器对象。</li></ul><p>这两次遍历的效果是叠加的，最终表现为扩展运算符遍历函数<code>genFuncWithReturn</code>返回的遍历器对象。所以最后的数据表达式得到的值等于<code>[ &#39;a&#39;, &#39;b&#39; ]</code>。同时，函数<code>genFuncWithReturn</code>的<code>return</code>语句的返回值<code>The result</code>，会返回给函数<code>logReturned</code>内部的<code>result</code>变量。</p><hr><h3 id="18-10-作为对象的属性"><a href="#18-10-作为对象的属性" class="headerlink" title="18.10 作为对象的属性"></a>18.10 作为对象的属性</h3><p>如果一个对象的属性是 <code>Generator</code> 函数，可以简写成下面的形式。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  * <span class="title function_">myGeneratorMethod</span>(<span class="params"></span>) &#123;</span><br><span class="line">    ···</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>它的完整形式如下，与上面的写法是等价的。（详细请见上一章的属性的简洁表示法）<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">myGeneratorMethod</span>: <span class="keyword">function</span>* () &#123;</span><br><span class="line">    <span class="comment">// ···</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h3 id="18-11-含义"><a href="#18-11-含义" class="headerlink" title="18.11 含义"></a>18.11 含义</h3><p><strong>（1）Generator 与状态机</strong></p><p><code>Generator</code> 是实现状态机的最佳结构。比如，下面的<code>clock</code>函数就是一个状态机。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> ticking = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">let</span> clock = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (ticking) <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Tick!&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Tock!&quot;</span>);</span><br><span class="line">  ticking = !ticking;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面代码的<code>clock</code>函数一共有两种状态<code>Tick</code>和<code>Tock</code>，每运行一次，就改变一次状态。这个函数如果用 <code>Generator</code> 实现，就是下面这样。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> clock = <span class="keyword">function</span>* () &#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Tick!&quot;</span>);</span><br><span class="line">    <span class="keyword">yield</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Tock!&quot;</span>);</span><br><span class="line">    <span class="keyword">yield</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面的 <code>Generator</code> 实现与 <code>ES5</code> 实现对比，可以看到少了用来保存状态的外部变量<code>ticking</code>，这样就更简洁，更安全，在写法上也更优雅。<br><br></p><p><strong>（2）Generator 与协程</strong></p><p>协程 <code>coroutine</code> 是一种程序运行的方式，可以理解成“协作的线程”或“协作的函数”。协程既可以用单线程实现，也可以用多线程实现。</p><ul><li><p><strong>协程与子例程的差异</strong><br>传统的“子例程” <code>subroutine</code> 采用堆栈式“后进先出”的执行方式，只有当调用的子函数完全执行完毕，才会结束执行父函数。<ins>协程与其不同，多个线程（单线程情况下，即多个函数）可以并行执行，但是只有一个线程（或函数）处于正在运行的状态，其他线程（或函数）都处于暂停态 <code>suspended</code>，线程（或函数）之间可以交换执行权</ins>。这种可以并行执行、交换执行权的线程（或函数），就称为协程。</p></li><li><p><strong>协程与普通线程的差异</strong><br>协程适合用于多任务运行的环境。在这个意义上，它与普通的线程很相似，都有自己的执行上下文、可以分享全局变量。它们的不同之处在于，<ins>同一时间可以有多个线程处于运行状态，但是运行的协程只能有一个，其他协程都处于暂停状态</ins>。此外，<ins>普通的线程是抢先式的，到底哪个线程优先得到资源，必须由运行环境决定，但是协程是合作式的，执行权由协程自己分配</ins>。</p></li></ul><p><code>Generator</code> 函数是 <code>ES6</code> 对协程的实现，<ins>但属于不完全实现</ins>。<code>Generator</code> 函数被称为“半协程”，意思是只有 <code>Generator</code> 函数的调用者，才能将程序的执行权还给 <code>Generator</code> 函数。如果是完全实现的协程，任何函数都可以让暂停的协程继续执行。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">A</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;我是A&quot;</span>);</span><br><span class="line">  <span class="keyword">yield</span> <span class="title function_">B</span>(); <span class="comment">// A停住，在这里转交线程执行权给B</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;结束了&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">B</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;我是B&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">100</span>; <span class="comment">// 返回，并且将线程执行权还给A</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> gen = <span class="title function_">A</span>();</span><br><span class="line">gen.<span class="title function_">next</span>();</span><br><span class="line">gen.<span class="title function_">next</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我是A</span></span><br><span class="line"><span class="comment">// 我是B</span></span><br><span class="line"><span class="comment">// 结束了</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>A</code>将执行权交给<code>B</code>，我们称<code>A</code>是<code>B</code>的父协程。那么现在<code>B</code>执行，<code>A</code>就相当于处于暂停的状态。等到<code>B</code>最后<code>return 100</code>，执行权就会还给<code>A</code>。<br><br></p><p><strong>（3）Generator 与上下文</strong></p><p>执行 <code>JS</code> 代码时，会产生一个全局的上下文环境，包含了当前所有的变量和对象。执行函数或块级代码时，又会<mark class="hl-label red">在当前上下文环境的上层</mark> ，产生一个 <mark class="hl-label blue">函数运行的上下文</mark> ，作为 <mark class="hl-label green">当前active的上下文</mark> ，由此形成一个上下文环境的堆栈。<br><br></p><p>这个堆栈是“后进先出”的数据结构，最后产生的上下文环境首先执行完成，退出堆栈，然后再执行完成它下层的上下文，直至所有代码执行完成，堆栈清空。<br><br></p><p><code>Generator</code> 函数不一样，它执行产生的上下文环境，一旦<ins>遇到<code>yield</code>命令，就会暂时退出堆栈，但是并不消失，里面的所有变量和对象会冻结在当前状态</ins>。等到对它执行<code>next</code>命令时，这个上下文环境又会重新加入调用栈，冻结的变量和对象恢复执行。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">gen</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> g = <span class="title function_">gen</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="title function_">next</span>().<span class="property">value</span>, g.<span class="title function_">next</span>().<span class="property">value</span>); <span class="comment">// 1, 2</span></span><br></pre></td></tr></table></figure><p>上面代码中，第一次执行<code>g.next()</code>时，<code>Generator</code> 函数<code>gen</code>的上下文会加入堆栈，即开始运行<code>gen</code>内部的代码。等遇到<code>yield 1</code>时，<code>gen</code>上下文退出堆栈，内部状态冻结。第二次执行<code>g.next()</code>时，<code>gen</code>上下文重新加入堆栈，变成当前的上下文，重新恢复执行。</p><hr><h3 id="18-12-应用"><a href="#18-12-应用" class="headerlink" title="18.12 应用"></a>18.12 应用</h3><p><strong>（1）异步操作的同步化表达</strong></p><p><code>Generator</code> 函数的暂停执行的效果，意味着<ins>可以把异步操作写在<code>yield</code>表达式里面</ins>，等到调用<code>next</code>方法时再往后执行。所以，<code>Generator</code> 函数的一个重要实际意义就是用来处理异步操作，改写回调函数。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">loadUI</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title function_">showLoadingScreen</span>();</span><br><span class="line">  <span class="keyword">yield</span> <span class="title function_">loadUIDataAsynchronously</span>();</span><br><span class="line">  <span class="title function_">hideLoadingScreen</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> loader = <span class="title function_">loadUI</span>();</span><br><span class="line"><span class="comment">// 加载UI</span></span><br><span class="line">loader.<span class="title function_">next</span>();</span><br><span class="line"><span class="comment">// 卸载UI</span></span><br><span class="line">loader.<span class="title function_">next</span>();</span><br></pre></td></tr></table></figure><p>上面代码中，第一次调用<code>loadUI</code>函数时，该函数不会执行，仅返回一个遍历器。下一次对该遍历器调用<code>next</code>方法，则会显示<code>Loading</code>界面，并且异步加载数据。等到数据加载完成，再一次使用<code>next</code>方法，则会隐藏<code>Loading</code>界面。<br><br></p><p><strong>（2）控制流管理</strong></p><p>如果有一个多步操作，采用回调函数，可能会写成下面这样。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">step1</span>(<span class="keyword">function</span> (<span class="params">value1</span>) &#123;</span><br><span class="line">  <span class="title function_">step2</span>(value1, <span class="keyword">function</span> (<span class="params">value2</span>) &#123;</span><br><span class="line">    <span class="title function_">step3</span>(value2, <span class="keyword">function</span> (<span class="params">value3</span>) &#123;</span><br><span class="line">      <span class="title function_">step4</span>(value3, <span class="keyword">function</span> (<span class="params">value4</span>) &#123;</span><br><span class="line">        <span class="comment">// Do something with value4</span></span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>采用 <code>Promise</code> 改写上面的代码。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>(step1)</span><br><span class="line">  .<span class="title function_">then</span>(step2)</span><br><span class="line">  .<span class="title function_">then</span>(step3)</span><br><span class="line">  .<span class="title function_">then</span>(step4)</span><br><span class="line">  .<span class="title function_">then</span>(</span><br><span class="line">    <span class="keyword">function</span> (<span class="params">value4</span>) &#123;</span><br><span class="line">      <span class="comment">// Do something with value4</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">function</span> (<span class="params">error</span>) &#123;</span><br><span class="line">      <span class="comment">// Handle any error from step1 through step4</span></span><br><span class="line">    &#125;</span><br><span class="line">  )</span><br><span class="line">  .<span class="title function_">done</span>();</span><br></pre></td></tr></table></figure><p>上面代码已经把回调函数，改成了直线执行的形式，但是加入了大量 <code>Promise</code> 的语法。<code>Generator</code> 函数可以进一步改善代码运行流程。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">longRunningTask</span>(<span class="params">value1</span>) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> value2 = <span class="keyword">yield</span> <span class="title function_">step1</span>(value1);</span><br><span class="line">    <span class="keyword">let</span> value3 = <span class="keyword">yield</span> <span class="title function_">step2</span>(value2);</span><br><span class="line">    <span class="keyword">let</span> value4 = <span class="keyword">yield</span> <span class="title function_">step3</span>(value3);</span><br><span class="line">    <span class="keyword">let</span> value5 = <span class="keyword">yield</span> <span class="title function_">step4</span>(value4);</span><br><span class="line">    <span class="comment">// Do something with value4</span></span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="comment">// Handle any error from step1 through step4</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，<ins>使用一个函数，按次序自动执行所有步骤</ins>。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">scheduler</span>(<span class="title function_">longRunningTask</span>(initialValue));</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">scheduler</span>(<span class="params">task</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> taskObj = task.<span class="title function_">next</span>(task.<span class="property">value</span>);</span><br><span class="line">  <span class="comment">// 如果Generator函数未结束，就继续调用</span></span><br><span class="line">  <span class="keyword">if</span> (!taskObj.<span class="property">done</span>) &#123;</span><br><span class="line">    task.<span class="property">value</span> = taskObj.<span class="property">value</span>;</span><br><span class="line">    <span class="title function_">scheduler</span>(task);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，上面这种做法，只适合同步操作，即所有的<code>task</code>都必须是同步的，不能有异步操作。因为这里的代码一得到返回值，就继续往下执行，没有判断异步操作何时完成。<br><br></p><p><strong>（3）控制流管理 II</strong></p><p>利用<code>for...of</code>循环会自动依次执行<code>yield</code>命令的特性，能提供一种更一般的控制流管理的方法。</p><p>首先，用数组<code>steps</code>封装了一个任务的多个步骤，并依次为这些步骤加上<code>yield</code>命令。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> steps = [step1Func, step2Func, step3Func];</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span>* <span class="title function_">iterateSteps</span>(<span class="params">steps</span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; steps.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> step = steps[i];</span><br><span class="line">    <span class="keyword">yield</span> <span class="title function_">step</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，将任务分解成步骤之后，还可以再将项目分解成多个依次执行的任务<code>jobs</code>。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> jobs = [job1, job2, job3];</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span>* <span class="title function_">iterateJobs</span>(<span class="params">jobs</span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; jobs.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> job = jobs[i];</span><br><span class="line">    <span class="keyword">yield</span>* <span class="title function_">iterateSteps</span>(job.<span class="property">steps</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，就可以用<code>for...of</code>循环一次性依次执行所有任务的所有步骤。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> step <span class="keyword">of</span> <span class="title function_">iterateJobs</span>(jobs)) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(step.<span class="property">id</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再次提醒，上面的做法只能用于所有步骤都是同步操作的情况，不能有异步操作的步骤。</p><hr><h2 id="19-Generator-函数异步应用"><a href="#19-Generator-函数异步应用" class="headerlink" title="19. Generator 函数异步应用"></a>19. Generator 函数异步应用</h2><h3 id="19-1-基本概念"><a href="#19-1-基本概念" class="headerlink" title="19.1 基本概念"></a>19.1 基本概念</h3><p><strong>（1）异步</strong></p><p>所谓”异步”，可以理解成一个任务被人为分成两段，先执行第一段，然后转而执行其他任务，等做好了准备，再回过头执行第二段</ins>。</p><ul><li>比如，有一个任务是读取文件进行处理，任务的第一段向操作系统发出请求，要求读取文件。然后，程序执行其他任务，等到操作系统返回文件，再接着执行任务的第二段处理文件。</li></ul><p>相应地，连续的执行就叫做同步。由于是连续执行，不能插入其他任务，所以操作系统从硬盘读取文件的这段时间，程序只能干等着。<br><br></p><p><strong>（2）回调函数</strong></p><p><code>JS</code> 语言对异步编程的实现，就是回调函数。所谓<ins>回调函数，就是把任务的第二段单独写在一个函数里面，等到重新执行这个任务的时候，就直接调用这个函数</ins>。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">fs.<span class="title function_">readFile</span>(<span class="string">&quot;/etc/passwd&quot;</span>, <span class="string">&quot;utf-8&quot;</span>, <span class="keyword">function</span> (<span class="params">err, data</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，<code>readFile</code>函数的第三个参数，就是回调函数，也就是任务的第二段。等到操作系统返回了<code>/etc/passwd</code>这个文件以后，回调函数才会执行。<br><br></p><p><strong>（3）Promise</strong></p><p>回调函数的问题出现在多个回调函数嵌套。假定读取<code>A</code>文件之后，再读取<code>B</code>文件。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">fs.<span class="title function_">readFile</span>(fileA, <span class="string">&quot;utf-8&quot;</span>, <span class="keyword">function</span> (<span class="params">err, data</span>) &#123;</span><br><span class="line">  fs.<span class="title function_">readFile</span>(fileB, <span class="string">&quot;utf-8&quot;</span>, <span class="keyword">function</span> (<span class="params">err, data</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>不难想象，如果依次读取两个以上的文件，就会出现多重嵌套。因为多个异步操作形成了强耦合，只要有一个操作需要修改，它的上层回调函数和下层回调函数，可能都要跟着修改。<br><br></p><p><code>Promise</code> 对象就是为了解决这个问题而提出的。它不是新的语法功能，而是一种新的写法，<ins>允许将回调函数的嵌套，改成链式调用</ins>。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> readFile = <span class="built_in">require</span>(<span class="string">&quot;fs-readfile-promise&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_">readFile</span>(fileA)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">data</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data.<span class="title function_">toString</span>());</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">readFile</span>(fileB);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">data</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data.<span class="title function_">toString</span>());</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="keyword">function</span> (<span class="params">err</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(err);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>上面代码中的<code>fs-readfile-promise</code>模块，返回一个 <code>Promise</code> 版本的<code>readFile</code>函数，并通过<code>then</code>方法加载回调函数，<code>catch</code>方法捕捉执行过程中抛出的错误。<br><br></p><p><code>Promise</code> 的写法只是回调函数的改进，使用<code>then</code>方法以后，异步任务的两段执行看得更清楚了。但是，<code>Promise</code> 的最大问题是代码冗余，原来的任务被 <code>Promise</code> 包装了一下，不管什么操作，一眼看去许多<code>then</code>，原来的语义变得很不清楚。<br><br></p><p><strong>（4）Generator 函数</strong></p><p>“协程” <code>coroutine</code>，是多个线程互相协作，完成异步任务。协程有点像函数，又有点像线程。它的运行流程大致如下：</p><ul><li>第一步，协程<code>A</code>开始执行。</li><li>第二步，<ins>协程<code>A</code>执行到一半，进入暂停，执行权转移到协程<code>B</code></ins>。</li><li>第三步，一段时间后，协程<code>B</code>交还执行权。</li><li>第四步，协程<code>A</code>恢复执行。</li></ul><p>上面流程的协程<code>A</code>，就是异步任务，因为它分成两段或多段执行。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">asyncJob</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// ...其他代码</span></span><br><span class="line">  <span class="keyword">let</span> f = <span class="keyword">yield</span> <span class="title function_">readFile</span>(fileA);</span><br><span class="line">  <span class="comment">// ...其他代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码的函数<code>asyncJob</code>是一个协程，它的奥妙就在其中的<code>yield</code>命令，<ins>表示执行到此处，执行权将交给其他协程。也就是说，<code>yield</code>命令是异步两个阶段的分界线</ins>。<br><br></p><p><code>Generator</code> 函数是协程在 <code>ES6</code> 的实现，最大特点就是可以交出函数的执行权（即暂停执行）。它是一个封装的异步任务，或者说是异步任务的容器。异步操作需要暂停的地方，都用<code>yield</code>语句注明。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">gen</span>(<span class="params">x</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> y = <span class="keyword">yield</span> x + <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> g = <span class="title function_">gen</span>(<span class="number">1</span>);</span><br><span class="line">g.<span class="title function_">next</span>(); <span class="comment">// &#123; value: 3, done: false &#125;</span></span><br><span class="line">g.<span class="title function_">next</span>(); <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure><p>上面代码中，调用 <code>Generator</code> 函数，会返回一个内部指针（即遍历器）<code>g</code>。这是 <code>Generator</code> 函数不同于普通函数的另一个地方，即执行它不会返回结果，返回的是指针对象。调用指针<code>g</code>的<code>next</code>方法，会移动内部指针（即执行异步任务的第一段），指向第一个遇到的<code>yield</code>语句，上例是执行到<code>x + 2</code>为止。<br><br></p><p>换言之，<code>next</code>方法的作用是分阶段执行<code>Generator</code>函数。每次调用<code>next</code>方法，会返回一个对象，表示当前阶段的信息（<code>value</code>属性和<code>done</code>属性）。<code>value</code>属性是<code>yield</code>语句后面表达式的值，表示当前阶段的值；<code>done</code>属性是一个布尔值，表示 <code>Generator</code> 函数是否执行完毕，即是否还有下一个阶段。</p><hr><h3 id="19-2-数据交换和错误处理"><a href="#19-2-数据交换和错误处理" class="headerlink" title="19.2 数据交换和错误处理"></a>19.2 数据交换和错误处理</h3><p><code>Generator</code> 函数可以暂停和恢复执行，这是它能封装异步任务的根本原因。除此之外，它还有两个特性，使它可以作为异步编程的完整解决方案：<ins>函数体内外的数据交换和错误处理机制</ins>。<br><br></p><p><code>next</code>返回值的 <code>value</code> 属性，是 <code>Generator</code> 函数向外输出数据。<code>next</code>方法还可以接受参数，向 <code>Generator</code> 函数体内输入数据。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">gen</span>(<span class="params">x</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> y = <span class="keyword">yield</span> x + <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> g = <span class="title function_">gen</span>(<span class="number">1</span>);</span><br><span class="line">g.<span class="title function_">next</span>(); <span class="comment">// &#123; value: 3, done: false &#125;</span></span><br><span class="line">g.<span class="title function_">next</span>(<span class="number">2</span>); <span class="comment">// &#123; value: 2, done: true &#125;</span></span><br></pre></td></tr></table></figure><p>上面代码中，第一个<code>next</code>方法的<code>value</code>属性，返回表达式<code>x + 2</code>的值。第二个<code>next</code>方法带有参数，这个参数被传入 <code>Generator</code> 函数，作为上个阶段异步任务的返回结果，也就是<code>y</code>的值。因此，这一步的<code>value</code>属性，返回的就是<code>2</code>。<br><br></p><p><code>Generator</code> 函数内部还可以部署错误处理代码，捕获函数体外抛出的错误。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">gen</span>(<span class="params">x</span>) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> y = <span class="keyword">yield</span> x + <span class="number">2</span>;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(e);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> g = <span class="title function_">gen</span>(<span class="number">1</span>);</span><br><span class="line">g.<span class="title function_">next</span>();</span><br><span class="line">g.<span class="keyword">throw</span>(<span class="string">&quot;出错了&quot;</span>);</span><br><span class="line"><span class="comment">// 出错了</span></span><br></pre></td></tr></table></figure><p>上面代码的最后一行，<code>Generator</code> 函数体外，<ins>使用指针对象的<code>throw</code>方法抛出的错误，可以被函数体内的<code>try...catch</code>代码块捕获</ins>。这意味着，<ins>出错的代码与处理错误的代码，实现了时间和空间上的分离，这对于异步编程无疑是很重要的</ins>。</p><hr><h3 id="19-3-异步任务的封装"><a href="#19-3-异步任务的封装" class="headerlink" title="19.3 异步任务的封装"></a>19.3 异步任务的封装</h3><p>使用<code>Generator</code>封装异步操作的核心思路：</p><ul><li>在异步任务执行时，使用<code>yield</code>交出执行权。</li><li>在异步任务结束后，使用<code>next</code>交还执行权。</li></ul><p>下面看看如何使用 <code>Generator</code> 函数，执行一个真实的异步任务。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 首先写一个异步任务,在一秒后返回特定字符串</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">asyncTask</span>(<span class="params">callback</span>) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">callback</span>(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 接下来写出期望执行的顺序</span></span><br><span class="line"><span class="keyword">function</span>* <span class="title function_">runTask</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> text = <span class="keyword">yield</span> asyncTask;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(text); <span class="comment">// 我们期望这里正常输出 Hello World</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 按照期望值执行函数</span></span><br><span class="line"><span class="keyword">const</span> gen = <span class="title function_">runTask</span>(); <span class="comment">// 此时执行权已经交出</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里 gen.next().value 就是 asyncTask，执行 asyncTask</span></span><br><span class="line"><span class="comment">// 关键点在于 callback 里调用 next 交还执行权</span></span><br><span class="line"><span class="comment">// 由于 next 方法带有参数 text，且是 callback 的返回值，所以有终端输出。</span></span><br><span class="line">gen.<span class="title function_">next</span>().<span class="title function_">value</span>(<span class="keyword">function</span> (<span class="params">text</span>) &#123;</span><br><span class="line">  gen.<span class="title function_">next</span>(text);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码虽然很粗糙，但是已经反映了使用<code>Generator</code>封装异步任务的核心思想。最直观的受益就是，<code>runTask</code>的内容与同步代码相似，条理清晰，很适合阅读。<br><br></p><p>可以看到，虽然 <code>Generator</code> 函数将异步操作表示得很简洁，但是上面代码中第三部分的流程管理却不方便，即何时执行第一阶段、何时执行第二阶段。</p><hr><h3 id="19-4-Thunk-函数"><a href="#19-4-Thunk-函数" class="headerlink" title="19.4 Thunk 函数"></a>19.4 Thunk 函数</h3><p><code>Thunk</code> 函数是自动执行 <code>Generator</code> 函数的一种方法。<br><br></p><p><strong>（1）参数的求值策略</strong></p><p><code>Thunk</code> 函数早在上个世纪 <code>60</code> 年代就诞生了。那时，编程语言刚刚起步，计算机学家还在研究，编译器怎么写比较好。一个争论的焦点是”求值策略”，即函数的参数到底应该何时求值。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">m</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> m * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">f</span>(x + <span class="number">5</span>)；</span><br></pre></td></tr></table></figure><p>上面代码先定义函数<code>f</code>，然后向它传入表达式<code>x + 5</code>。请问，这个表达式应该何时求值？<br><br></p><p>一种意见是<ins>“传值调用”</ins>，即在进入函数体之前，就计算<code>x + 5</code>的值，再将这个值传入函数<code>f</code>。<code>C</code> 语言就采用这种策略。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">f</span>(x + <span class="number">5</span>);</span><br><span class="line"><span class="comment">// 传值调用时，等同于</span></span><br><span class="line"><span class="title function_">f</span>(<span class="number">6</span>);</span><br></pre></td></tr></table></figure><p>另一种意见是<ins>“传名调用”</ins>，即直接将表达式<code>x + 5</code>传入函数体，只在用到它的时候求值。<code>Haskell</code> 语言采用这种策略。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">f</span>(x + <span class="number">5</span>)(</span><br><span class="line">  <span class="comment">// 传名调用时，等同于</span></span><br><span class="line">  x + <span class="number">5</span></span><br><span class="line">) * <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>传值调用和传名调用，哪一种比较好？回答是各有利弊。传值调用比较简单，但是对参数求值的时候，实际上还没用到这个参数，有可能造成性能损失。<br><br></p><p><strong>（2）Thunk 函数的含义</strong></p><p>编译器“传名调用”的实现，往往是将参数放到一个临时函数之中，再将这个临时函数传入函数体。这个临时函数就叫做 <code>Thunk</code> 函数。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">m</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> m * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">f</span>(x + <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> thunk = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> x + <span class="number">5</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">thunk</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">thunk</span>() * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，函数 <code>f</code> 的参数<code>x + 5</code>被一个函数替换了。凡是用到原参数的地方，对<code>Thunk</code>函数求值即可。这就是 <code>Thunk</code> 函数的定义，<ins>它是“传名调用”的一种实现策略，用来替换某个表达式</ins>。<br><br></p><p><strong>（3）JS 语言的 Thunk 函数</strong></p><p><ins><code>JavaScript</code> 是传值调用</ins>，它的 <code>Thunk</code> 函数含义有所不同。在 <code>JavaScript</code> 中，<code>Thunk</code> 函数替换的不是表达式，而是多参数函数，将其替换成一个只接受回调函数作为参数的单参数函数。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 正常版本的 readFile（多参数版本）</span></span><br><span class="line">fs.<span class="title function_">readFile</span>(fileName, callback);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Thunk版本的 readFile（单参数版本）</span></span><br><span class="line"><span class="keyword">let</span> <span class="title class_">Thunk</span> = <span class="keyword">function</span> (<span class="params">fileName</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">callback</span>) &#123;</span><br><span class="line">    <span class="comment">// 注意</span></span><br><span class="line">    <span class="keyword">return</span> fs.<span class="title function_">readFile</span>(fileName, callback);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> readFileThunk = <span class="title class_">Thunk</span>(fileName);</span><br><span class="line"><span class="title function_">readFileThunk</span>(callback);</span><br></pre></td></tr></table></figure><p>上面代码中，<code>fs</code>模块的<code>readFile</code>方法是一个多参数函数，两个参数分别为文件名和回调函数。经过转换器处理，它变成了一个单参数函数，只接受回调函数作为参数。这个单参数版本，就叫做 <code>Thunk</code> 函数。<br><br></p><p>任何函数，只要参数有回调函数，就能写成 <code>Thunk</code> 函数的形式。（<a href="https://zhuanlan.zhihu.com/p/404060484">推荐阅读</a>）<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Thunk</span> = <span class="keyword">function</span> (<span class="params">fn</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">...args</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">callback</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> fn.<span class="title function_">call</span>(<span class="variable language_">this</span>, ...args, callback);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>（4）Thunkify 模块</strong></p><p><code>Thunkify</code> 模块的使用方式如下。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> thunkify = <span class="built_in">require</span>(<span class="string">&quot;thunkify&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> read = <span class="title function_">thunkify</span>(fs.<span class="property">readFile</span>);</span><br><span class="line"><span class="title function_">read</span>(<span class="string">&quot;package.json&quot;</span>)(<span class="keyword">function</span> (<span class="params">err, str</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>Thunkify</code> 的源码与上一节那个简单的转换器非常像。（<a href="https://segmentfault.com/a/1190000010414406">源码解读</a>）<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">thunkify</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> args = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="variable language_">arguments</span>.<span class="property">length</span>);</span><br><span class="line">    <span class="keyword">let</span> ctx = <span class="variable language_">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; args.<span class="property">length</span>; ++i) &#123;</span><br><span class="line">      args[i] = <span class="variable language_">arguments</span>[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">done</span>) &#123;</span><br><span class="line">      <span class="keyword">let</span> called;</span><br><span class="line"></span><br><span class="line">      args.<span class="title function_">push</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (called) &#123;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        called = <span class="literal">true</span>;</span><br><span class="line">        done.<span class="title function_">apply</span>(<span class="literal">null</span>, <span class="variable language_">arguments</span>);</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        fn.<span class="title function_">apply</span>(ctx, args);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">        <span class="title function_">done</span>(err);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它的源码主要多了一个检查机制，变量<code>called</code>确保回调函数只运行一次。这样的设计与下面的 <code>Generator</code> 函数相关。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">a, b, callback</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> sum = a + b;</span><br><span class="line">  <span class="title function_">callback</span>(sum);</span><br><span class="line">  <span class="title function_">callback</span>(sum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> ft = <span class="title function_">thunkify</span>(f);</span><br><span class="line"><span class="keyword">let</span> print = <span class="variable language_">console</span>.<span class="property">log</span>.<span class="title function_">bind</span>(<span class="variable language_">console</span>);</span><br><span class="line"><span class="title function_">ft</span>(<span class="number">1</span>, <span class="number">2</span>)(print);</span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>上面代码中，由于<code>thunkify</code>只允许回调函数执行一次，所以只输出一行结果。<br><br></p><p><strong>（5）Generator 函数的流程管理</strong></p><p><code>Thunk</code> 函数可以用于 <code>Generator</code> 函数的自动流程管理。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">gen</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> g = <span class="title function_">gen</span>();</span><br><span class="line"><span class="keyword">let</span> res = g.<span class="title function_">next</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!res.<span class="property">done</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res.<span class="property">value</span>);</span><br><span class="line">  res = g.<span class="title function_">next</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>Generator</code> 函数<code>gen</code>会自动执行完所有步骤。<br><br></p><p>但是，这不适合异步操作。<ins>如果必须保证前一步执行完，才能执行后一步，上面的自动执行就不可行</ins>。这时，<code>Thunk</code> 函数就能派上用处。<br><br></p><p>以读取文件为例。下面的 <code>Generator</code> 函数封装了两个异步操作。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> thunkify = <span class="built_in">require</span>(<span class="string">&quot;thunkify&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> readFileThunk = <span class="title function_">thunkify</span>(fs.<span class="property">readFile</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> gen = <span class="keyword">function</span>* () &#123;</span><br><span class="line">  <span class="keyword">let</span> r1 = <span class="keyword">yield</span> <span class="title function_">readFileThunk</span>(<span class="string">&quot;/etc/fstab&quot;</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(r1.<span class="title function_">toString</span>());</span><br><span class="line">  <span class="keyword">let</span> r2 = <span class="keyword">yield</span> <span class="title function_">readFileThunk</span>(<span class="string">&quot;/etc/shells&quot;</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(r2.<span class="title function_">toString</span>());</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面代码中，<ins><code>yield</code>命令用于将程序的执行权移出 <code>Generator</code> 函数，那么就需要一种方法，将执行权再交还给 <code>Generator</code> 函数</ins>。<br><br></p><p>这种方法就是 <code>Thunk</code> 函数，<ins>因为它可以在回调函数里，将执行权交还给 <code>Generator</code> 函数</ins>。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> g = <span class="title function_">gen</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> r1 = g.<span class="title function_">next</span>();</span><br><span class="line">r1.<span class="title function_">value</span>(<span class="keyword">function</span> (<span class="params">err, data</span>) &#123;</span><br><span class="line">  <span class="comment">// r1.value 就是 readFileThunk 方法</span></span><br><span class="line">  <span class="keyword">if</span> (err) &#123;</span><br><span class="line">    <span class="keyword">throw</span> err; <span class="comment">// 错误处理</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> r2 = g.<span class="title function_">next</span>(data); <span class="comment">// 如果 data 从 readFileThunk 方法回调出来</span></span><br><span class="line">  <span class="comment">// 归还执行权，r1 赋值成功，运行至下一个 yield</span></span><br><span class="line">  r2.<span class="title function_">value</span>(<span class="keyword">function</span> (<span class="params">err, data</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">      <span class="keyword">throw</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">    g.<span class="title function_">next</span>(data);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，变量<code>g</code>是 <code>Generator</code> 函数的内部指针，表示目前执行到哪一步。<code>next</code>方法负责将指针移动到下一步，并返回该步的<code>value</code>属性和<code>done</code>属性。<br><br></p><p>仔细看上面的代码，可以发现 <code>Generator</code> 函数的执行过程，其实是<ins>将同一个回调函数，反复传入<code>next</code>方法的<code>value</code>属性</ins>。这使得我们可以用递归来自动完成这个过程。（理论上）<br><br></p><p><strong>（6）Thunk 函数的自动流程管理</strong></p><p><code>Thunk</code> 函数真正的威力，在于可以自动执行 <code>Generator</code> 函数。下面就是一个基于 <code>Thunk</code> 函数的 <code>Generator</code> 执行器。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">run</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> gen = <span class="title function_">fn</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">next</span>(<span class="params">err, data</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> result = gen.<span class="title function_">next</span>(data);</span><br><span class="line">    <span class="keyword">if</span> (result.<span class="property">done</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    result.<span class="title function_">value</span>(next);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">next</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span>* <span class="title function_">g</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">run</span>(g);</span><br></pre></td></tr></table></figure><p>上面代码的<code>run</code>函数，就是一个 <code>Generator</code> 函数的自动执行器。内部的<code>next</code>函数就是 <code>Thunk</code> 的回调函数。<code>next</code>函数先将指针移到 <code>Generator</code> 函数的下一步（<code>gen.next</code>方法），然后判断 <code>Generator</code> 函数是否结束（<code>result.done</code>属性），如果没结束，就将<code>next</code>函数再传入 <code>Thunk</code> 函数（<code>result.value</code>属性），否则就直接退出。<br><br></p><p>有了这个执行器，执行 <code>Generator</code> 函数方便多了。不管内部有多少个异步操作，直接把 <code>Generator</code> 函数传入<code>run</code>函数即可。注意，<ins>前提是每一个异步操作，都要是 <code>Thunk</code> 函数，也就是说，跟在<code>yield</code>命令后面的必须是 <code>Thunk</code> 函数</ins>。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> g = <span class="keyword">function</span>* () &#123;</span><br><span class="line">  <span class="keyword">let</span> f1 = <span class="keyword">yield</span> <span class="title function_">readFileThunk</span>(<span class="string">&quot;fileA&quot;</span>);</span><br><span class="line">  <span class="keyword">let</span> f2 = <span class="keyword">yield</span> <span class="title function_">readFileThunk</span>(<span class="string">&quot;fileB&quot;</span>);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">let</span> fn = <span class="keyword">yield</span> <span class="title function_">readFileThunk</span>(<span class="string">&quot;fileN&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">run</span>(g);</span><br></pre></td></tr></table></figure><p>上面代码中，函数<code>g</code>封装了<code>n</code>个异步的读取文件操作，只要执行<code>run</code>函数，这些操作就会自动完成。这样一来，异步操作不仅可以写得像同步操作，而且一行代码就可以执行。<br><br></p><p><code>Thunk</code> 函数并不是 <code>Generator</code> 函数自动执行的唯一方案。因为自动执行的关键是，必须有一种机制，自动控制 <code>Generator</code> 函数的流程，接收和交还程序的执行权。回调函数可以做到这一点，<code>Promise</code> 对象也可以做到这一点。</p><hr><h3 id="19-5-co-模块"><a href="#19-5-co-模块" class="headerlink" title="19.5 co 模块"></a>19.5 co 模块</h3><p>下面是一个 <code>Generator</code> 函数，用于依次读取两个文件。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> gen = <span class="keyword">function</span>* () &#123;</span><br><span class="line">  <span class="keyword">let</span> f1 = <span class="keyword">yield</span> <span class="title function_">readFile</span>(<span class="string">&quot;/etc/fstab&quot;</span>);</span><br><span class="line">  <span class="keyword">let</span> f2 = <span class="keyword">yield</span> <span class="title function_">readFile</span>(<span class="string">&quot;/etc/shells&quot;</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(f1.<span class="title function_">toString</span>());</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(f2.<span class="title function_">toString</span>());</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/tj/co">co 模块</a>可以用于 <code>Generator</code> 函数的自动执行，不用再编写 <code>Generator</code> 函数的执行器。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> co = <span class="built_in">require</span>(<span class="string">&quot;co&quot;</span>);</span><br><span class="line"><span class="title function_">co</span>(gen);</span><br></pre></td></tr></table></figure><p>上面代码中，<code>Generator</code> 函数只要传入<code>co</code>函数，就会自动执行。</p><p><code>co</code>函数返回一个<code>Promise</code>对象，因此可以用<code>then</code>方法添加回调函数。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">co</span>(gen).<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Generator 函数执行完成&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，等到 <code>Generator</code> 函数执行结束，就会输出一行提示。<br><br></p><p><strong>（1）co 模块的原理</strong></p><p>为什么 <code>co</code> 可以自动执行 <code>Generator</code> 函数？</p><p>前面说过，<ins><code>Generator</code> 就是一个异步操作的容器。它的自动执行需要一种机制，当异步操作有了结果，能够自动交回执行权</ins>。</p><p>两种方法可以做到这一点：</p><ul><li>回调函数。将异步操作包装成 <code>Thunk</code> 函数，在回调函数里面交回执行权。</li><li><code>Promise</code> 对象。将异步操作包装成 <code>Promise</code> 对象，用<code>then</code>方法交回执行权。</li></ul><p><code>co</code> 模块其实就是将两种自动执行器（<code>Thunk</code> 函数和 <code>Promise</code> 对象），包装成一个模块。</p><ul><li>使用 <code>co</code> 的前提条件是，<code>Generator</code> 函数的<code>yield</code>命令后面，只能是 <code>Thunk</code> 函数或 <code>Promise</code> 对象。如果数组或对象的成员，全部都是 <code>Promise</code> 对象，也可以使用 <code>co</code>。<br><br></li></ul><p><strong>（2）基于 Promise 对象的自动执行</strong></p><p>沿用上面的例子。首先，把<code>fs</code>模块的<code>readFile</code>方法包装成一个 <code>Promise</code> 对象。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> readFile = <span class="keyword">function</span> (<span class="params">fileName</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">    <span class="comment">// Promise 新建后立即执行</span></span><br><span class="line">    fs.<span class="title function_">readFile</span>(fileName, <span class="keyword">function</span> (<span class="params">error, data</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (error) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">reject</span>(error);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="title function_">resolve</span>(data); <span class="comment">// 读取成功，传 data 进 then 方法</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> gen = <span class="keyword">function</span>* () &#123;</span><br><span class="line">  <span class="keyword">let</span> f1 = <span class="keyword">yield</span> <span class="title function_">readFile</span>(<span class="string">&quot;/etc/fstab&quot;</span>);</span><br><span class="line">  <span class="keyword">let</span> f2 = <span class="keyword">yield</span> <span class="title function_">readFile</span>(<span class="string">&quot;/etc/shells&quot;</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(f1.<span class="title function_">toString</span>());</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(f2.<span class="title function_">toString</span>());</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后，手动执行上面的 <code>Generator</code> 函数。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> g = <span class="title function_">gen</span>();</span><br><span class="line"><span class="comment">// 注意，此时 gen.next().value 是 readFile 返回的 Promise 对象</span></span><br><span class="line"><span class="comment">// resolve 返回的 data 进入回调函数</span></span><br><span class="line">g.<span class="title function_">next</span>().<span class="property">value</span>.<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">data</span>) &#123;</span><br><span class="line">  g.<span class="title function_">next</span>(data).<span class="property">value</span>.<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">data</span>) &#123;</span><br><span class="line">    g.<span class="title function_">next</span>(data);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>手动执行就是用<code>then</code>方法，层层添加回调函数。理解了这一点，就可以写出一个自动执行器。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">run</span>(<span class="params">gen</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> g = <span class="title function_">gen</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">next</span>(<span class="params">data</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> result = g.<span class="title function_">next</span>(data);</span><br><span class="line">    <span class="keyword">if</span> (result.<span class="property">done</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> result.<span class="property">value</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    result.<span class="property">value</span>.<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">data</span>) &#123;</span><br><span class="line">      <span class="title function_">next</span>(data);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">next</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">run</span>(gen);</span><br></pre></td></tr></table></figure><p>上面代码中，只要 <code>Generator</code> 函数还没执行到最后一步，<code>next</code>函数就调用自身，实现自动执行。<br><br></p><p><strong>（3）co 模块的源码</strong></p><p>首先，<code>co</code> 函数接受 <code>Generator</code> 函数作为参数，返回一个 <code>Promise</code> 对象。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">co</span>(<span class="params">gen</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> ctx = <span class="variable language_">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在返回的 <code>Promise</code> 对象里面，<code>co</code> 先检查参数<code>gen</code>是否为 <code>Generator</code> 函数。如果是，就执行该函数，得到一个内部指针对象；如果不是就返回，并将 <code>Promise</code> 对象的状态改为<code>resolved</code>。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">co</span>(<span class="params">gen</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> ctx = <span class="variable language_">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> gen === <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">      gen = gen.<span class="title function_">call</span>(ctx);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!gen || <span class="keyword">typeof</span> gen.<span class="property">next</span> !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">resolve</span>(gen);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着，<code>co</code> 将 <code>Generator</code> 函数的内部指针对象的<code>next</code>方法，包装成<code>onFulfilled</code>函数。这主要是为了能够捕捉抛出的错误。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">co</span>(<span class="params">gen</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> ctx = <span class="variable language_">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> gen === <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">      gen = gen.<span class="title function_">call</span>(ctx);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!gen || <span class="keyword">typeof</span> gen.<span class="property">next</span> !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">resolve</span>(gen);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">onFulfilled</span>();</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">onFulfilled</span>(<span class="params">res</span>) &#123;</span><br><span class="line">      <span class="keyword">let</span> ret;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        ret = gen.<span class="title function_">next</span>(res);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">reject</span>(e);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="title function_">next</span>(ret);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，就是关键的<code>next</code>函数，它会反复调用自身。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">next</span>(<span class="params">ret</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (ret.<span class="property">done</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">resolve</span>(ret.<span class="property">value</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> value = toPromise.<span class="title function_">call</span>(ctx, ret.<span class="property">value</span>);</span><br><span class="line">  <span class="keyword">if</span> (value &amp;&amp; <span class="title function_">isPromise</span>(value)) &#123;</span><br><span class="line">    <span class="keyword">return</span> value.<span class="title function_">then</span>(onFulfilled, onRejected);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">onRejected</span>(</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">TypeError</span>(</span><br><span class="line">      <span class="string">&quot;You may only yield a function, promise, generator, array, or object, &quot;</span> +</span><br><span class="line">        <span class="string">&#x27;but the following object was passed: &quot;&#x27;</span> +</span><br><span class="line">        <span class="title class_">String</span>(ret.<span class="property">value</span>) +</span><br><span class="line">        <span class="string">&#x27;&quot;&#x27;</span></span><br><span class="line">    )</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>next</code>函数的内部代码，一共只有四行命令。</p><ul><li>检查当前是否为 <code>Generator</code> 函数的最后一步，如果是就返回。</li><li>确保每一步的返回值，是 <code>Promise</code> 对象。</li><li><code>then</code>方法为返回值加上回调函数，然后通过<code>onFulfilled</code>函数再次调用<code>next</code>函数。</li><li>在参数不符合要求的情况下（参数非 <code>Thunk</code> 函数和 <code>Promise</code> 对象），将 <code>Promise</code> 对象的状态改为<code>rejected</code>，从而终止执行。</li></ul><p><strong>（4）处理并发的异步操作</strong></p><p><code>co</code> 支持并发的异步操作，即允许某些操作同时进行，等到它们全部完成，才进行下一步。这时，要把并发的操作都放在数组或对象里面，跟在<code>yield</code>语句后面。（<a href="https://es6.ruanyifeng.com/#docs/generator-async#%E5%AE%9E%E4%BE%8B%EF%BC%9A%E5%A4%84%E7%90%86-Stream">例子</a>）<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数组的写法</span></span><br><span class="line"><span class="title function_">co</span>(<span class="keyword">function</span>* () &#123;</span><br><span class="line">  <span class="keyword">let</span> res = <span class="keyword">yield</span> [<span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">1</span>), <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">2</span>)];</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br><span class="line">&#125;).<span class="title function_">catch</span>(onerror);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象的写法</span></span><br><span class="line"><span class="title function_">co</span>(<span class="keyword">function</span>* () &#123;</span><br><span class="line">  <span class="keyword">let</span> res = <span class="keyword">yield</span> &#123;</span><br><span class="line">    <span class="number">1</span>: <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">1</span>),</span><br><span class="line">    <span class="number">2</span>: <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">2</span>),</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br><span class="line">&#125;).<span class="title function_">catch</span>(onerror);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> ES6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ES6学习笔记 • 上</title>
      <link href="/posts/fbe58254.html"/>
      <url>/posts/fbe58254.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>本读书笔记节是针对阮一峰编写的 <a href="https://es6.ruanyifeng.com/">《ECMAScript 6 入门教程》</a>的总结。适合已经掌握 <code>ES5</code> 的读者，用来了解这门语言的最新发展。笔记内容仅包括日常开发中可能会用到的概念。</p></blockquote><hr><h2 id="1-let-和-const-命令"><a href="#1-let-和-const-命令" class="headerlink" title="1. let 和 const 命令"></a>1. let 和 const 命令</h2><h3 id="1-1-let-命令"><a href="#1-1-let-命令" class="headerlink" title="1.1 let 命令"></a>1.1 let 命令</h3><p><code>let</code>的用法类似于<code>var</code>，但所声明的变量只在<code>let</code>命令所在的代码块（即 <code>&#123;&#125;</code> 包裹起来的内容）内有效。而<code>var</code>所声明的变量在全局范围内都有效。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">var</span> b = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">a; <span class="comment">// ReferenceError: a is not defined.</span></span><br><span class="line">b; <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p><strong>（1）不存在变量提升</strong></p><p><code>var</code>命令会发生<ins>“变量提升”现象，即变量可以在声明之前使用，值为<code>undefined</code></ins>。为了纠正这种现象，<code>let</code>命令改变了语法行为，它所声明的变量一定要在声明后使用。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// var 的情况</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(foo); <span class="comment">// 输出 undefined</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// let 的情况</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(bar); <span class="comment">// 报错 ReferenceError</span></span><br><span class="line"><span class="keyword">let</span> bar = <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p><strong>（2）暂时性死区</strong></p><p>只要<a href="https://blog.poetries.top/browser-working-principle/guide/part2/lesson09.html#%E4%BD%9C%E7%94%A8%E5%9F%9F-scope">块级作用域</a>内存在<code>let</code>和<code>const</code>命令，它所声明的变量就“绑定”（<code>binding</code>）这个区域，不再受外部的影响。凡是在声明之前就使用这些变量，就会报错。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> tmp = <span class="number">123</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="comment">// TDZ 开始</span></span><br><span class="line">  tmp = <span class="string">&quot;abc&quot;</span>; <span class="comment">// ReferenceError</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(tmp); <span class="comment">// ReferenceError</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> tmp; <span class="comment">// TDZ 结束</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(tmp); <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line">  tmp = <span class="number">123</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(tmp); <span class="comment">// 123</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="1-2-块级作用域"><a href="#1-2-块级作用域" class="headerlink" title="1.2 块级作用域"></a>1.2 块级作用域</h3><p><code>ES5</code> 只有全局作用域和函数作用域，没有块级作用域，这带来很多不合理的情况 <br><br></p><p><strong>（1）内层变量覆盖外层变量</strong><br>下面代码的原意是，<code>if</code>代码块的外部使用外层的<code>tmp</code>变量，内部使用内层的<code>tmp</code>变量。但是函数<code>f</code>执行后，输出结果却为<code>undefined</code>。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> tmp = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(tmp);</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> tmp = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">f</span>(); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p><ins>原因其实就是变量提升，导致内层的<code>tmp</code>变量覆盖了外层的<code>tmp</code>变量</ins>。实际中的代码如下<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> tmp = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> tmp; <span class="comment">// 声明但未赋值 undefined</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(tmp); <span class="comment">// 输出 undefined</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">    tmp = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">f</span>(); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p><strong>（2）用来计数的循环变量泄露为全局变量</strong></p><p>下面代码中，变量<code>i</code>只用来控制循环，但是循环结束后，它并没有消失，泄露成了全局变量。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; s.<span class="property">length</span>; i++) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(s[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(i); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure><p>为了应对上面这些情况，<code>ES6</code> 新增了块级作用域，<ins>外层作用域无法获取到内层作用域</ins>。<ins>即使外层和内层都使用相同变量名，也都互不干扰</ins>。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f1</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> n = <span class="number">5</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> n = <span class="number">10</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(n); <span class="comment">// 5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的函数有两个代码块，都声明了变量<code>n</code>，运行后输出 <code>5</code>。这表示外层代码块不受内层代码块的影响。如果两次都使用<code>var</code>定义变量<code>n</code>，最后输出的值就是 <code>10</code>。</p><hr><h3 id="1-3-const-命令"><a href="#1-3-const-命令" class="headerlink" title="1.3 const 命令"></a>1.3 const 命令</h3><p><code>const</code>声明一个只读常量。一旦声明，常量的值就不能改变，<ins>且必须立即初始化</ins>。（与 <code>let</code> 一样，<code>const</code> 不存在变量提升，存在暂时性死区）<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">PI</span> = <span class="number">3.1415</span>;</span><br><span class="line"><span class="variable constant_">PI</span>; <span class="comment">// 3.1415</span></span><br><span class="line"><span class="variable constant_">PI</span> = <span class="number">3</span>;</span><br><span class="line"><span class="comment">// TypeError: Assignment to constant variable.</span></span><br></pre></td></tr></table></figure><p><code>const</code>保证的，并不是变量的值不得改动，<ins>而是变量指向的那个内存地址所保存的数据不得改动</ins>。</p><ul><li>对于简单类型的数据（比如数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。</li><li>但对于复合类型的数据（比如对象、数组），变量指向的内存地址，保存的只是一个指向实际数据的指针。<code>const</code>只能保证这个指针是固定的，至于它指向的数据结构是不是可变的，就完全不能控制了。</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为 foo 添加一个属性</span></span><br><span class="line">foo.<span class="property">prop</span> = <span class="number">123</span>;</span><br><span class="line">foo.<span class="property">prop</span>; <span class="comment">// 123</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 foo 指向另一个对象，报错</span></span><br><span class="line">foo = &#123;&#125;; <span class="comment">// TypeError: &quot;foo&quot; is read-only</span></span><br></pre></td></tr></table></figure><hr><h2 id="2-变量的解构赋值"><a href="#2-变量的解构赋值" class="headerlink" title="2. 变量的解构赋值"></a>2. 变量的解构赋值</h2><h3 id="2-1-数组的解构赋值"><a href="#2-1-数组的解构赋值" class="headerlink" title="2.1 数组的解构赋值"></a>2.1 数组的解构赋值</h3><p>从数组或对象中提取值，按照对应位置, 对变量进行赋值，这被称为解构。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [a, b, c] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br></pre></td></tr></table></figure><p>这种写法属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [foo, [[bar], baz]] = [<span class="number">1</span>, [[<span class="number">2</span>], <span class="number">3</span>]];</span><br><span class="line">foo; <span class="comment">// 1</span></span><br><span class="line">bar; <span class="comment">// 2</span></span><br><span class="line">baz; <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [, , third] = [<span class="string">&quot;foo&quot;</span>, <span class="string">&quot;bar&quot;</span>, <span class="string">&quot;baz&quot;</span>];</span><br><span class="line">third; <span class="comment">// &quot;baz&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [head, ...tail] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">head; <span class="comment">// 1</span></span><br><span class="line">tail; <span class="comment">// [2, 3, 4]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [x, y, ...z] = [<span class="string">&quot;a&quot;</span>];</span><br><span class="line">x; <span class="comment">// &quot;a&quot;</span></span><br><span class="line">y; <span class="comment">// undefined</span></span><br><span class="line">z; <span class="comment">// []</span></span><br></pre></td></tr></table></figure><p>数组的解构赋值有两种特殊情况</p><ul><li>解构不成功，那么对应变量的值就等于<code>undefined</code>。</li><li>不完全解构，等号左边的模式，只会匹配一部分的等号右边的数组。</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [foo] = []; <span class="comment">// foo == undefined</span></span><br><span class="line"><span class="keyword">let</span> [bar, foo] = [<span class="number">1</span>]; <span class="comment">// foo == undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [a, [b], d] = [<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>], <span class="number">4</span>];</span><br><span class="line">a; <span class="comment">// 1</span></span><br><span class="line">b; <span class="comment">// 2</span></span><br><span class="line">d; <span class="comment">// 4</span></span><br></pre></td></tr></table></figure><p>事实上，只要某种数据结构具有 <code>Iterator</code> 接口，都可以采用数组形式的解构赋值。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [x, y, z] = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>]); <span class="comment">// Set 原生带有 Iterator 接口</span></span><br><span class="line">x; <span class="comment">// &quot;a&quot;</span></span><br></pre></td></tr></table></figure><p>数组的解构赋值可以指定默认值，并且<ins>必须严格等于<code>undefined</code></ins>才会生效。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [foo = <span class="literal">true</span>] = [];</span><br><span class="line">foo; <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [x, y = <span class="string">&quot;b&quot;</span>] = [<span class="string">&quot;a&quot;</span>]; <span class="comment">// x=&#x27;a&#x27;, y=&#x27;b&#x27;</span></span><br><span class="line"><span class="keyword">let</span> [x, y = <span class="string">&quot;b&quot;</span>] = [<span class="string">&quot;a&quot;</span>, <span class="literal">undefined</span>]; <span class="comment">// x=&#x27;a&#x27;, y=&#x27;b&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [x = <span class="number">1</span>] = [<span class="literal">undefined</span>];</span><br><span class="line">x; <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [x = <span class="number">1</span>] = [<span class="literal">null</span>];</span><br><span class="line">x; <span class="comment">// null</span></span><br></pre></td></tr></table></figure><hr><h3 id="2-2-对象的解构赋值"><a href="#2-2-对象的解构赋值" class="headerlink" title="2.2 对象的解构赋值"></a>2.2 对象的解构赋值</h3><p>对象的解构与数组有一个重要的不同。<ins>数组的元素是按次序排列的，变量的取值由它的位置决定</ins>。<ins>而对象的属性没有次序，变量必须与属性同名，才能取到正确的值</ins>。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; bar, foo &#125; = &#123; <span class="attr">foo</span>: <span class="string">&quot;aaa&quot;</span>, <span class="attr">bar</span>: <span class="string">&quot;bbb&quot;</span> &#125;;</span><br><span class="line">foo; <span class="comment">// &quot;aaa&quot;</span></span><br><span class="line">bar; <span class="comment">// &quot;bbb&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; baz &#125; = &#123; <span class="attr">foo</span>: <span class="string">&quot;aaa&quot;</span>, <span class="attr">bar</span>: <span class="string">&quot;bbb&quot;</span> &#125;;</span><br><span class="line">baz; <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>如果<ins>变量名与属性名不一致</ins>，必须写成下面这样。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">first</span>: <span class="string">&quot;hello&quot;</span>, <span class="attr">last</span>: <span class="string">&quot;world&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">first</span>: f, <span class="attr">last</span>: l &#125; = obj;</span><br><span class="line">f; <span class="comment">// &#x27;hello&#x27;</span></span><br><span class="line">l; <span class="comment">// &#x27;world&#x27;</span></span><br></pre></td></tr></table></figure><p>上面的代码可以看出，对象的解构赋值的机制，是<ins>先找到同名属性，然后再赋给对应的变量</ins>，<mark class="hl-label red">真正被赋值的是后者，而不是前者</mark> 。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; <span class="attr">foo</span>: foo, <span class="attr">bar</span>: bar &#125; = &#123; <span class="attr">foo</span>: <span class="string">&quot;aaa&quot;</span>, <span class="attr">bar</span>: <span class="string">&quot;bbb&quot;</span> &#125;;</span><br><span class="line"><span class="comment">// let &#123;foo, bar&#125; = &#123; foo: &#x27;aaa&#x27;, bar: &#x27;bbb&#x27; &#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">foo</span>: baz &#125; = &#123; <span class="attr">foo</span>: <span class="string">&quot;aaa&quot;</span>, <span class="attr">bar</span>: <span class="string">&quot;bbb&quot;</span> &#125;;</span><br><span class="line">baz; <span class="comment">// &quot;aaa&quot;</span></span><br><span class="line">foo; <span class="comment">// error: foo is not defined</span></span><br></pre></td></tr></table></figure><p>解构也可以用于嵌套结构的对象。下面代码分别对<code>p</code>，<code>x</code>，<code>y</code>三个属性进行解构赋值。注意，在对<code>x</code>，<code>y</code>属性的解构赋值之中，<code>x</code>，<code>y</code>是变量，<code>p</code>是模式。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="attr">p</span>: [<span class="string">&quot;Hello&quot;</span>, &#123; <span class="attr">y</span>: <span class="string">&quot;World&quot;</span> &#125;],</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123;</span><br><span class="line">  p,</span><br><span class="line">  <span class="attr">p</span>: [x, &#123; y &#125;],</span><br><span class="line">&#125; = obj;</span><br><span class="line">p; <span class="comment">// [&quot;Hello&quot;, &#123;y: &quot;World&quot;&#125;]</span></span><br><span class="line">x; <span class="comment">// &quot;Hello&quot;</span></span><br><span class="line">y; <span class="comment">// &quot;World&quot;</span></span><br></pre></td></tr></table></figure><p>对象的解构也可以指定默认值，并且必须严格等于<code>undefined</code>才会生效。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; x = <span class="number">3</span> &#125; = &#123;&#125;;</span><br><span class="line">x; <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; x, y = <span class="number">5</span> &#125; = &#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="literal">undefined</span> &#125;;</span><br><span class="line">x; <span class="comment">// 1</span></span><br><span class="line">y; <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">x</span>: y = <span class="number">3</span> &#125; = &#123;&#125;;</span><br><span class="line">y; <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">x</span>: y = <span class="number">3</span> &#125; = &#123; <span class="attr">x</span>: <span class="number">5</span> &#125;;</span><br><span class="line">y; <span class="comment">// 5</span></span><br></pre></td></tr></table></figure><hr><h3 id="2-3-函数参数的解构赋值"><a href="#2-3-函数参数的解构赋值" class="headerlink" title="2.3 函数参数的解构赋值"></a>2.3 函数参数的解构赋值</h3><p>函数的参数也可以使用解构赋值。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">move</span>(<span class="params">&#123; x = <span class="number">0</span>, y = <span class="number">0</span> &#125; = &#123;&#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> [x, y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">move</span>(&#123; <span class="attr">x</span>: <span class="number">3</span>, <span class="attr">y</span>: <span class="number">8</span> &#125;); <span class="comment">// [3, 8]</span></span><br><span class="line"><span class="title function_">move</span>(&#123; <span class="attr">x</span>: <span class="number">3</span> &#125;); <span class="comment">// [3, 0]</span></span><br><span class="line"><span class="title function_">move</span>(&#123;&#125;); <span class="comment">// [0, 0]</span></span><br><span class="line"><span class="title function_">move</span>(); <span class="comment">// [0, 0]</span></span><br></pre></td></tr></table></figure><p>上面代码中，函数<code>move</code>的参数是一个对象。通过对这个对象进行解构，得到变量<code>x</code>和<code>y</code>的值。如果解构失败，<code>x</code>和<code>y</code>等于默认值。<br><br></p><p>注意，下面的写法会得到与上面不一样的结果。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">move</span>(<span class="params">&#123; x, y &#125; = &#123; x: <span class="number">0</span>, y: <span class="number">0</span> &#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> [x, y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">move</span>(&#123; <span class="attr">x</span>: <span class="number">3</span>, <span class="attr">y</span>: <span class="number">8</span> &#125;); <span class="comment">// [3, 8]</span></span><br><span class="line"><span class="title function_">move</span>(&#123; <span class="attr">x</span>: <span class="number">3</span> &#125;); <span class="comment">// [3, undefined]</span></span><br><span class="line"><span class="title function_">move</span>(&#123;&#125;); <span class="comment">// [undefined, undefined]</span></span><br><span class="line"><span class="title function_">move</span>(); <span class="comment">// [0, 0]</span></span><br></pre></td></tr></table></figure><p>上面代码<ins>为函数<code>move</code>的参数指定默认值，而不是为变量<code>x</code>和<code>y</code>指定默认值</ins>。当参数为<code>undefined</code>时，参数默认值启用。</p><hr><h3 id="2-4-解构赋值的用途"><a href="#2-4-解构赋值的用途" class="headerlink" title="2.4 解构赋值的用途"></a>2.4 解构赋值的用途</h3><p><strong>（1）交换变量的值</strong></p><p>下面代码交换变量<code>x</code>和<code>y</code>的值，这样的写法简洁易读，语义清晰。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> y = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">[x, y] = [y, x]; <span class="comment">// x = 2, y = 1</span></span><br></pre></td></tr></table></figure><p><strong>（2）从函数返回多个值</strong></p><p>函数只能返回一个值，如果要返回多个值，只能将它们放在数组或对象里返回。有了解构赋值，取出这些值就非常方便。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回一个数组</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">example</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> [a, b, c] = <span class="title function_">example</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回一个对象</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">example</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">foo</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">bar</span>: <span class="number">2</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> &#123; foo, bar &#125; = <span class="title function_">example</span>();</span><br></pre></td></tr></table></figure><p><strong>（3）提取 JSON 数据</strong></p><p>解构赋值对提取 <code>JSON</code> 对象中的数据，尤其有用。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> jsonData = &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="number">42</span>,</span><br><span class="line">  <span class="attr">status</span>: <span class="string">&quot;OK&quot;</span>,</span><br><span class="line">  <span class="attr">data</span>: [<span class="number">867</span>, <span class="number">5309</span>],</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; id, status, <span class="attr">data</span>: number &#125; = jsonData;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(id, status, number);</span><br><span class="line"><span class="comment">// 42, &quot;OK&quot;, [867, 5309]</span></span><br></pre></td></tr></table></figure><p><strong>（4）函数参数的定义</strong></p><p>解构赋值可以方便地将一组参数与变量名对应起来。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参数是一组有次序的值</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">[x, y, z]</span>) &#123; ... &#125;</span><br><span class="line"><span class="title function_">f</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数是一组无次序的值</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">&#123;x, y, z&#125;</span>) &#123; ... &#125;</span><br><span class="line"><span class="title function_">f</span>(&#123;<span class="attr">z</span>: <span class="number">3</span>, <span class="attr">y</span>: <span class="number">2</span>, <span class="attr">x</span>: <span class="number">1</span>&#125;);</span><br></pre></td></tr></table></figure><p><strong>（5）遍历 Map 结构</strong></p><p>前面提到，任何部署了 <code>Iterator</code> 接口的对象，都可以用<code>for...of</code>循环遍历。<code>Map</code> 结构原生支持 <code>Iterator</code> 接口，配合变量的解构赋值，获取键名和键值就非常方便。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">map.<span class="title function_">set</span>(<span class="string">&quot;first&quot;</span>, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line">map.<span class="title function_">set</span>(<span class="string">&quot;second&quot;</span>, <span class="string">&quot;world&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> map) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(key + <span class="string">&quot; is &quot;</span> + value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// first is hello</span></span><br><span class="line"><span class="comment">// second is world</span></span><br></pre></td></tr></table></figure><hr><h2 id="3-字符串的扩展"><a href="#3-字符串的扩展" class="headerlink" title="3. 字符串的扩展"></a>3. 字符串的扩展</h2><p><a href="https://es6.ruanyifeng.com/#docs/string">本章</a>内容复杂，故先跳过一部分。</p><h3 id="3-1-模板字符串"><a href="#3-1-模板字符串" class="headerlink" title="3.1 模板字符串"></a>3.1 模板字符串</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&quot;#result&quot;</span>).<span class="title function_">append</span>(<span class="string">`</span></span><br><span class="line"><span class="string">  There are &lt;b&gt;<span class="subst">$&#123;basket.count&#125;</span>&lt;/b&gt; items</span></span><br><span class="line"><span class="string">   in your basket, &lt;em&gt;<span class="subst">$&#123;basket.onSale&#125;</span>&lt;/em&gt;</span></span><br><span class="line"><span class="string">  are on sale!</span></span><br><span class="line"><span class="string">`</span>);</span><br></pre></td></tr></table></figure><p>模板字符串（<code>template string</code>）是增强版的字符串。它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 字符串中嵌入变量</span></span><br><span class="line"><span class="keyword">let</span> name = <span class="string">&quot;Bob&quot;</span>,</span><br><span class="line">  time = <span class="string">&quot;today&quot;</span>;</span><br><span class="line"><span class="string">`Hello <span class="subst">$&#123;name&#125;</span>, how are you <span class="subst">$&#123;time&#125;</span>?`</span>;</span><br></pre></td></tr></table></figure><p>注意，如果使用模板字符串表示多行字符串，所有的空格，换行，缩进都会被保留在输出之中。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str1 = <span class="string">&quot;Hello&quot;</span> + <span class="string">&quot;World&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> str2 = <span class="string">`Hello</span></span><br><span class="line"><span class="string">World`</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str1); <span class="comment">// HelloWorld</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str2); <span class="comment">// Hello</span></span><br><span class="line"><span class="comment">// World 换行被保留</span></span><br></pre></td></tr></table></figure><hr><h3 id="3-2-标签模板"><a href="#3-2-标签模板" class="headerlink" title="3.2 标签模板"></a>3.2 标签模板</h3><p>模板字符串可以紧跟在一个函数名后面，该函数将被调用来处理这个模板字符串。这被称为“标签模板”功能（<code>tagged template</code>）。</p><ul><li>标签模板不是模板，而是函数调用的一种特殊形式。“标签”指的是函数，它的参数是紧跟在后面的模板字符串。</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">alert<span class="string">`hello`</span>;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="title function_">alert</span>([<span class="string">&quot;hello&quot;</span>]);</span><br></pre></td></tr></table></figure><p>如果模板字符里面有变量，就不是直接调用了。会先将模板字符串先处理成多个参数，再调用函数。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">tag</span>(<span class="params">stringArr, ...values</span>)&#123; ... &#125;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">tag</span>(<span class="params">stringArr, value1, value2</span>)&#123; ... &#125;</span><br><span class="line"></span><br><span class="line">tag<span class="string">`Hello <span class="subst">$&#123; a + b &#125;</span> world <span class="subst">$&#123; a * b &#125;</span>`</span>;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="title function_">tag</span>([<span class="string">&#x27;Hello &#x27;</span>, <span class="string">&#x27; world &#x27;</span>, <span class="string">&#x27;&#x27;</span>], <span class="number">15</span>, <span class="number">50</span>);</span><br></pre></td></tr></table></figure><hr><h2 id="4-字符串的新增方法"><a href="#4-字符串的新增方法" class="headerlink" title="4. 字符串的新增方法"></a>4. 字符串的新增方法</h2><h3 id="4-1-新增方法"><a href="#4-1-新增方法" class="headerlink" title="4.1 新增方法"></a>4.1 新增方法</h3><p><code>ES5</code> 中只有<code>indexOf()</code>方法可以用来确定一个字符串是否包含在另一个字符串中。<code>ES6</code> 又提供了三种新方法</p><ul><li><code>includes()</code>：返回布尔值，表示是否找到了参数字符串。</li><li><code>startsWith()</code>：返回布尔值，表示参数字符串是否在原字符串的头部。</li><li><code>endsWith()</code>：返回布尔值，表示参数字符串是否在原字符串的尾部。</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">&quot;Hello world!&quot;</span>;</span><br><span class="line"></span><br><span class="line">s.<span class="title function_">startsWith</span>(<span class="string">&quot;Hello&quot;</span>); <span class="comment">// true</span></span><br><span class="line">s.<span class="title function_">endsWith</span>(<span class="string">&quot;!&quot;</span>); <span class="comment">// true</span></span><br><span class="line">s.<span class="title function_">includes</span>(<span class="string">&quot;o&quot;</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>这三个方法都支持第二个参数，表示开始搜索的位置。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">&quot;Hello world!&quot;</span>;</span><br><span class="line"></span><br><span class="line">s.<span class="title function_">startsWith</span>(<span class="string">&quot;world&quot;</span>, <span class="number">6</span>); <span class="comment">// true</span></span><br><span class="line">s.<span class="title function_">endsWith</span>(<span class="string">&quot;Hello&quot;</span>, <span class="number">5</span>); <span class="comment">// true</span></span><br><span class="line">s.<span class="title function_">includes</span>(<span class="string">&quot;Hello&quot;</span>, <span class="number">6</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>上面代码中，使用第二个参数<code>n</code>时，<code>endsWith()</code>的行为与其他两个方法不同。它针对前<code>n</code>个字符，而其他两个方法针对从第<code>n</code>个位置直到字符串结束。<br><br></p><p><code>repeat()</code>方法返回一个新字符串，将原字符串重复<code>n</code>次。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;na&quot;</span>.<span class="title function_">repeat</span>(<span class="number">3</span>); <span class="comment">// &quot;nana&quot;</span></span><br><span class="line"><span class="string">&quot;na&quot;</span>.<span class="title function_">repeat</span>(<span class="string">&quot;2&quot;</span>); <span class="comment">// &quot;nana&quot; 转换成数字</span></span><br><span class="line"><span class="string">&quot;na&quot;</span>.<span class="title function_">repeat</span>(<span class="number">0</span>); <span class="comment">// &quot;&quot;</span></span><br><span class="line"><span class="string">&quot;na&quot;</span>.<span class="title function_">repeat</span>(<span class="number">2.9</span>); <span class="comment">// &quot;nana&quot; 取整</span></span><br><span class="line"><span class="string">&quot;na&quot;</span>.<span class="title function_">repeat</span>(-<span class="number">1</span>); <span class="comment">// RangeError</span></span><br></pre></td></tr></table></figure><p><code>ES6</code> 引入字符串补全长度功能，能在某个字符串不够指定长度时，往头部或尾部补全。<code>padStart()</code>用于头部补全，<code>padEnd()</code>用于尾部补全。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;x&quot;</span>.<span class="title function_">padStart</span>(<span class="number">5</span>, <span class="string">&quot;ab&quot;</span>); <span class="comment">// &#x27;ababx&#x27; 补到length == 5</span></span><br><span class="line"><span class="string">&quot;abc&quot;</span>.<span class="title function_">padStart</span>(<span class="number">10</span>, <span class="string">&quot;0123456789&quot;</span>);</span><br><span class="line"><span class="comment">// &#x27;0123456abc&#x27; 如果两者的长度之和超过了最大长度，则会截去超出的位数</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;x&quot;</span>.<span class="title function_">padEnd</span>(<span class="number">5</span>, <span class="string">&quot;ab&quot;</span>); <span class="comment">// &#x27;xabab&#x27;</span></span><br><span class="line"><span class="string">&quot;x&quot;</span>.<span class="title function_">padEnd</span>(<span class="number">4</span>, <span class="string">&quot;ab&quot;</span>); <span class="comment">// &#x27;xaba&#x27;</span></span><br></pre></td></tr></table></figure><p><code>ES6</code> 新增了<code>trimStart()</code>和<code>trimEnd()</code>两个方法。它们的行为与<code>trim()</code>一致，<code>trimStart()</code>消除字符串头部的空格，<code>trimEnd()</code>消除尾部的空格。它们返回的都是新字符串，不会修改原始字符串。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="string">&quot;  abc  &quot;</span>;</span><br><span class="line"></span><br><span class="line">s.<span class="title function_">trim</span>(); <span class="comment">// &quot;abc&quot;</span></span><br><span class="line">s.<span class="title function_">trimStart</span>(); <span class="comment">// &quot;abc  &quot;</span></span><br><span class="line">s.<span class="title function_">trimEnd</span>(); <span class="comment">// &quot;  abc&quot;</span></span><br></pre></td></tr></table></figure><p><code>ES5</code>中，<code>replace()</code>只能替换第一个匹配。如果要替换所有的匹配，需要使用正则表达式的<code>g</code>修饰符。<code>ES6</code>引入了<code>replaceAll()</code>方法，可以一次性替换所有匹配。它返回的是新字符串，不会修改原始字符串。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;aabbcc&quot;</span>.<span class="title function_">replace</span>(<span class="string">&quot;b&quot;</span>, <span class="string">&quot;_&quot;</span>);</span><br><span class="line"><span class="comment">// &#x27;aa_bcc&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;aabbcc&quot;</span>.<span class="title function_">replace</span>(<span class="regexp">/b/g</span>, <span class="string">&quot;_&quot;</span>);</span><br><span class="line"><span class="comment">// &#x27;aa__cc&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;aabbcc&quot;</span>.<span class="title function_">replaceAll</span>(<span class="string">&quot;b&quot;</span>, <span class="string">&quot;_&quot;</span>);</span><br><span class="line"><span class="comment">// &#x27;aa__cc&#x27;</span></span><br></pre></td></tr></table></figure><p><code>ES6</code> 增加了<code>matchAll()</code>方法，可以一次性取出字符串里面所有匹配。但是，它返回的是一个遍历器，而不是数组。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> string = <span class="string">&quot;test1test2test3&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> regex = <span class="regexp">/t(e)(st(\d?))/g</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> match <span class="keyword">of</span> string.<span class="title function_">matchAll</span>(regex)) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(match);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// [&quot;test1&quot;, &quot;e&quot;, &quot;st1&quot;, &quot;1&quot;, index: 0, input: &quot;test1test2test3&quot;]</span></span><br><span class="line"><span class="comment">// [&quot;test2&quot;, &quot;e&quot;, &quot;st2&quot;, &quot;2&quot;, index: 5, input: &quot;test1test2test3&quot;]</span></span><br><span class="line"><span class="comment">// [&quot;test3&quot;, &quot;e&quot;, &quot;st3&quot;, &quot;3&quot;, index: 10, input: &quot;test1test2test3&quot;]</span></span><br></pre></td></tr></table></figure><p>遍历器转为数组是非常简单的，使用<code>...</code>运算符和<code>Array.from()</code>方法就可以。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 转为数组的方法一</span></span><br><span class="line">[...string.<span class="title function_">matchAll</span>(regex)];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转为数组的方法二</span></span><br><span class="line"><span class="title class_">Array</span>.<span class="title function_">from</span>(string.<span class="title function_">matchAll</span>(regex));</span><br></pre></td></tr></table></figure><hr><h2 id="5-正则的扩展"><a href="#5-正则的扩展" class="headerlink" title="5. 正则的扩展"></a>5. 正则的扩展</h2><p><a href="https://es6.ruanyifeng.com/#docs/regex">本章</a>内容复杂，故先跳过一部分。</p><h3 id="5-1-具名组匹配"><a href="#5-1-具名组匹配" class="headerlink" title="5.1 具名组匹配"></a>5.1 具名组匹配</h3><p>正则表达式使用圆括号进行<a href="https://segmentfault.com/a/1190000021043947">组匹配</a>。使用<code>exec</code>方法，就可以将这匹配结果提取出来。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">RE_DATE</span> = <span class="regexp">/(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> matchObj = <span class="variable constant_">RE_DATE</span>.<span class="title function_">exec</span>(<span class="string">&quot;1999-12-31&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> year = matchObj[<span class="number">1</span>]; <span class="comment">// 1999</span></span><br><span class="line"><span class="keyword">const</span> month = matchObj[<span class="number">2</span>]; <span class="comment">// 12</span></span><br><span class="line"><span class="keyword">const</span> day = matchObj[<span class="number">3</span>]; <span class="comment">// 31</span></span><br></pre></td></tr></table></figure><p>组匹配的一个问题是，每一组的匹配含义不容易看出来，而且只能用数字序号<code>XXX[1]</code>引用，要是组的顺序变了，引用的时候就必须修改序号。<br><br></p><p><code>ES6</code> 引入了具名组匹配（<code>Named Capture Groups</code>），允许为每一个组匹配指定一个名字，既便于阅读代码，又便于引用。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">RE_DATE</span> = <span class="regexp">/(?&lt;year&gt;\d&#123;4&#125;)-(?&lt;month&gt;\d&#123;2&#125;)-(?&lt;day&gt;\d&#123;2&#125;)/</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> matchObj = <span class="variable constant_">RE_DATE</span>.<span class="title function_">exec</span>(<span class="string">&quot;1999-12-31&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> year = matchObj.<span class="property">groups</span>.<span class="property">year</span>; <span class="comment">// &quot;1999&quot;</span></span><br><span class="line"><span class="keyword">const</span> month = matchObj.<span class="property">groups</span>.<span class="property">month</span>; <span class="comment">// &quot;12&quot;</span></span><br><span class="line"><span class="keyword">const</span> day = matchObj.<span class="property">groups</span>.<span class="property">day</span>; <span class="comment">// &quot;31&quot;</span></span><br></pre></td></tr></table></figure><hr><h2 id="6-数值的扩展"><a href="#6-数值的扩展" class="headerlink" title="6. 数值的扩展"></a>6. 数值的扩展</h2><p><a href="https://es6.ruanyifeng.com/#docs/number">本章</a>内容复杂，故先跳过一部分。</p><h3 id="6-1-BigInt-数据类型"><a href="#6-1-BigInt-数据类型" class="headerlink" title="6.1 BigInt 数据类型"></a>6.1 BigInt 数据类型</h3><p><code>ES5</code> 中所有数字都保存成 <code>64</code> 位浮点数，这给数值的表示带来了两大限制：</p><ul><li>数值的精度只能到 <code>53</code> 个二进制位，相当于 <code>16</code> 个十进制位，大于这个范围的整数，无法精确表示。 （不适合进行科学和金融方面的精确计算）</li><li>大于或等于<code>2</code>的<code>1024</code>次方的数值无法表示，会返回<code>Infinity</code>。</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 超过 53 个二进制位的数值，无法保持精度</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">pow</span>(<span class="number">2</span>, <span class="number">53</span>) === <span class="title class_">Math</span>.<span class="title function_">pow</span>(<span class="number">2</span>, <span class="number">53</span>) + <span class="number">1</span>; <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 超过 2 的 1024 次方的数值，无法表示</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">pow</span>(<span class="number">2</span>, <span class="number">1024</span>); <span class="comment">// Infinity</span></span><br></pre></td></tr></table></figure><p><code>ES6</code> 引入了一种新的数据类型 <code>BigInt</code>，来解决这个问题，这是 <code>ECMAScript</code> 的<a href="https://juejin.cn/post/6954892721173561358">第八种数据类型</a>。<code>BigInt</code> <ins>只用来表示整数</ins>，没有位数的限制，任何位数的整数都可以精确表示。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="number">2172141653n</span>;</span><br><span class="line"><span class="keyword">const</span> b = <span class="number">15346349309n</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// BigInt 可以保持精度</span></span><br><span class="line">a * b; <span class="comment">// 33334444555566667777n</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通整数无法保持精度</span></span><br><span class="line"><span class="title class_">Number</span>(a) * <span class="title class_">Number</span>(b); <span class="comment">// 33334444555566670000</span></span><br></pre></td></tr></table></figure><p><code>BigInt</code> 与普通整数是两种值，它们之间并不相等，且不能进行混合运算。为了与 <code>Number</code> 类型区别，<code>BigInt</code> 类型的数据必须添加后缀<code>n</code>。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">42n</span> === <span class="number">42</span>; <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="number">1n</span> + <span class="number">1.3</span>; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><hr><h2 id="7-函数的扩展"><a href="#7-函数的扩展" class="headerlink" title="7. 函数的扩展"></a>7. 函数的扩展</h2><h3 id="7-1-函数参数的默认值"><a href="#7-1-函数参数的默认值" class="headerlink" title="7.1 函数参数的默认值"></a>7.1 函数参数的默认值</h3><p><code>ES6</code> 允许为函数的参数设置默认值，可以直接写在参数定义的后面（通常是函数的尾参数）。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Point</span>(<span class="params">x = <span class="number">0</span>, y = <span class="number">0</span></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">x</span> = x; <span class="comment">// this.x = x || 0 （ES5 写法）</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">y</span> = y; <span class="comment">// this.y = y || 0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Point</span>();</span><br><span class="line">p; <span class="comment">// &#123; x: 0, y: 0 &#125;</span></span><br></pre></td></tr></table></figure><p>函数参数的默认值有两个好处</p><ul><li>阅读代码的人，可以立刻意识到哪些参数是可以省略的，不用查看函数体或文档。</li><li>有利于将来的代码优化，即使未来的版本在对外接口中，彻底拿掉这个参数，也不会导致以前的代码无法运行。</li></ul><p>参数默认值可以与解构赋值的默认值结合使用。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fetch</span>(<span class="params">url, &#123; body = <span class="string">&quot;&quot;</span>, method = <span class="string">&quot;GET&quot;</span>, headers = &#123;&#125; &#125;</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(method);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">fetch</span>(<span class="string">&quot;http://example.com&quot;</span>, &#123;&#125;);</span><br><span class="line"><span class="comment">// &quot;GET&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">fetch</span>(<span class="string">&quot;http://example.com&quot;</span>);</span><br><span class="line"><span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><p>上面代码中，函数<code>fetch</code>的第二个参数是一个对象，它的三个属性都有默认值。这种写法不能省略第二个参数，如果结合函数参数的默认值，就可以省略第二个参数。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fetch</span>(<span class="params">url, &#123; body = <span class="string">&quot;&quot;</span>, method = <span class="string">&quot;GET&quot;</span>, headers = &#123;&#125; &#125; = &#123;&#125;</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(method);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">fetch</span>(<span class="string">&quot;http://example.com&quot;</span>);</span><br><span class="line"><span class="comment">// &quot;GET&quot;</span></span><br></pre></td></tr></table></figure><p>上面代码中，当函数<code>fetch</code>没有第二个参数时，函数参数的默认值就会生效，然后才是解构赋值的默认值生效，变量<code>method</code>才会取到默认值<code>GET</code>。<br><br></p><p>注意，函数参数的默认值生效以后，参数解构赋值依然会进行。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">&#123; a, b = <span class="string">&quot;world&quot;</span> &#125; = &#123; a: <span class="string">&quot;hello&quot;</span> &#125;</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">f</span>(); <span class="comment">// world</span></span><br></pre></td></tr></table></figure><hr><h3 id="7-2-rest-参数"><a href="#7-2-rest-参数" class="headerlink" title="7.2 rest 参数"></a>7.2 rest 参数</h3><p><code>rest</code> 参数可以代替<code>arguments</code>对象，去获取函数的多余参数。<code>rest</code> 参数之后不能再有其他参数，它只能是最后一个参数。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// arguments变量的写法</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sortNumbers</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Array</span>.<span class="title function_">from</span>(<span class="variable language_">arguments</span>).<span class="title function_">sort</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">sortNumbers</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">3</span>));</span><br><span class="line"><span class="comment">// [1,2,3,5]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// rest参数的写法</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">sortNumbers</span> = (<span class="params">...numbers</span>) =&gt; numbers.<span class="title function_">sort</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">sortNumbers</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">3</span>));</span><br><span class="line"><span class="comment">// [1,2,3,5]</span></span><br></pre></td></tr></table></figure><p>上面代码的两种写法，比较后可以发现，<code>rest</code> 参数的写法更自然也更简洁。</p><hr><h3 id="7-3-箭头函数"><a href="#7-3-箭头函数" class="headerlink" title="7.3 箭头函数"></a>7.3 箭头函数</h3><p><code>ES6</code> 允许使用“箭头” <code>=&gt;</code> 定义函数。</p><ul><li>如果箭头函数不需要参数或需要多个参数，就使用一个圆括号代表参数部分。</li><li>如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用<code>return</code>语句返回。</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title function_">f</span> = (<span class="params"></span>) =&gt; <span class="number">5</span>;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">let</span> f = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="title function_">sum</span> = (<span class="params">num1, num2</span>) =&gt; num1 + num2;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">let</span> <span class="title function_">sum</span> = (<span class="params">num1, num2</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">let</span> sum = <span class="keyword">function</span> (<span class="params">num1, num2</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>箭头函数可以与变量解构结合使用。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">full</span> = (<span class="params">&#123; first, last &#125;</span>) =&gt; first + <span class="string">&quot; &quot;</span> + last;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">full</span>(<span class="params">person</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> person.<span class="property">first</span> + <span class="string">&quot; &quot;</span> + person.<span class="property">last</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>箭头函数还可以和上面的 <code>rest</code> 参数结合使用。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">numbers</span> = (<span class="params">...nums</span>) =&gt; nums;</span><br><span class="line"></span><br><span class="line"><span class="title function_">numbers</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line"><span class="comment">// [1,2,3,4,5]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">headAndTail</span> = (<span class="params">head, ...tail</span>) =&gt; [head, tail];</span><br><span class="line"></span><br><span class="line"><span class="title function_">headAndTail</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line"><span class="comment">// [1,[2,3,4,5]]</span></span><br></pre></td></tr></table></figure><p>箭头函数的重要用处是简化<a href="https://segmentfault.com/a/1190000021942060">回调函数</a>。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 普通函数写法</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].<span class="title function_">map</span>(<span class="keyword">function</span> (<span class="params">x</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 箭头函数写法</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].<span class="title function_">map</span>(<span class="function">(<span class="params">x</span>) =&gt;</span> x * x);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通函数写法</span></span><br><span class="line"><span class="keyword">let</span> result = values.<span class="title function_">sort</span>(<span class="keyword">function</span> (<span class="params">a, b</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> a - b;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 箭头函数写法</span></span><br><span class="line"><span class="keyword">let</span> result = values.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br></pre></td></tr></table></figure><p>箭头函数有几个使用<a href="https://es6.ruanyifeng.com/#docs/function#%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E7%82%B9">注意点</a>，其中最重要的是，箭头函数没有自己的<code>this</code>对象。</p><ul><li>对于<ins>普通函数来说，内部的<code>this</code>指向函数运行时所在的对象</ins>，但是<ins>这一点对箭头函数不成立。它没有自己的<code>this</code>对象，内部的<code>this</code>就是定义时上层作用域中的<code>this</code></ins>。也就是说，<ins>箭头函数内部的<code>this</code>指向是固定的</ins>，相比之下，<ins>普通函数的<code>this</code>指向是可变的</ins>。</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Timer</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">s1</span> = <span class="number">0</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">s2</span> = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 箭头函数</span></span><br><span class="line">  <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> <span class="variable language_">this</span>.<span class="property">s1</span>++, <span class="number">1000</span>);</span><br><span class="line">  <span class="comment">// 普通函数</span></span><br><span class="line">  <span class="built_in">setInterval</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">s2</span>++;</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> timer = <span class="keyword">new</span> <span class="title class_">Timer</span>(); <span class="comment">// 注意</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;s1: &quot;</span>, timer.<span class="property">s1</span>), <span class="number">3100</span>);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;s2: &quot;</span>, timer.<span class="property">s2</span>), <span class="number">3100</span>);</span><br><span class="line"><span class="comment">// s1: 3</span></span><br><span class="line"><span class="comment">// s2: 0</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>Timer</code>函数内部设置了两个定时器，分别使用了箭头函数和普通函数。<ins>前者的<code>this</code>绑定定义时所在的作用域，即<code>Timer</code>函数，后者的<code>this</code>指向运行时所在的作用域，即全局对象</ins>。所以，<code>3100</code> 毫秒之后，<code>timer.s1</code>被更新了 <code>3</code> 次，而<code>timer.s2</code>一次都没更新。</p><hr><h2 id="8-数组的扩展"><a href="#8-数组的扩展" class="headerlink" title="8. 数组的扩展"></a>8. 数组的扩展</h2><h3 id="8-1-扩展运算符"><a href="#8-1-扩展运算符" class="headerlink" title="8.1 扩展运算符"></a>8.1 扩展运算符</h3><p>扩展运算符 <code>...</code>，将一个数组转为用逗号分隔的参数序列。类似 <code>rest</code> 参数的逆运算。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(...[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="comment">// 1 2 3</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>, ...[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], <span class="number">5</span>)</span><br><span class="line"><span class="comment">// 1 2 3 4 5</span></span><br><span class="line"></span><br><span class="line">[...<span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;div&#x27;</span>)]</span><br><span class="line"><span class="comment">// [&lt;div&gt;, &lt;div&gt;, &lt;div&gt;]</span></span><br></pre></td></tr></table></figure><p>扩展运算符主要用于函数调用，可以代替<code>apply()</code>方法将数组转为函数的参数。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ES5 的写法</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">x, y, z</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> args = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">f.<span class="title function_">apply</span>(<span class="literal">null</span>, args);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6 的写法</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">x, y, z</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> args = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="title function_">f</span>(...args);</span><br></pre></td></tr></table></figure><hr><h3 id="8-2-扩展运算符的应用"><a href="#8-2-扩展运算符的应用" class="headerlink" title="8.2 扩展运算符的应用"></a>8.2 扩展运算符的应用</h3><p><strong>（1）复制数组</strong></p><p>数组是复合的数据类型，直接复制的话，只是复制了指向底层数据结构的指针，而不是克隆一个全新的数组。扩展运算符提供了复制数组的简便写法。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a1 = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">const</span> a2 = a1;</span><br><span class="line"></span><br><span class="line">a2[<span class="number">0</span>] = <span class="number">2</span>;</span><br><span class="line">a1; <span class="comment">// [2, 2]，浅拷贝</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="keyword">const</span> a2 = [...a1];</span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="keyword">const</span> [...a2] = a1;</span><br></pre></td></tr></table></figure><p><strong>（2）合并数组</strong></p><p>扩展运算符提供了数组合并的新写法。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr1 = [<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>];</span><br><span class="line"><span class="keyword">const</span> arr2 = [<span class="string">&quot;c&quot;</span>];</span><br><span class="line"><span class="keyword">const</span> arr3 = [<span class="string">&quot;d&quot;</span>, <span class="string">&quot;e&quot;</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES5 的合并数组</span></span><br><span class="line">arr1.<span class="title function_">concat</span>(arr2, arr3);</span><br><span class="line"><span class="comment">// [ &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27; ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6 的合并数组</span></span><br><span class="line">[...arr1, ...arr2, ...arr3];</span><br><span class="line"><span class="comment">// [ &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27; ]</span></span><br></pre></td></tr></table></figure><p>不过两种方法都是<a href="https://vue3js.cn/interview/JavaScript/copy.html">浅拷贝</a>，使用的时候需要特别小心。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a1 = [&#123; <span class="attr">foo</span>: <span class="number">1</span> &#125;];</span><br><span class="line"><span class="keyword">const</span> a2 = [&#123; <span class="attr">bar</span>: <span class="number">2</span> &#125;];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a3 = a1.<span class="title function_">concat</span>(a2);</span><br><span class="line"><span class="keyword">const</span> a4 = [...a1, ...a2];</span><br><span class="line"></span><br><span class="line">a3[<span class="number">0</span>] === a1[<span class="number">0</span>]; <span class="comment">// true</span></span><br><span class="line">a4[<span class="number">0</span>] === a1[<span class="number">0</span>]; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>a3</code>和<code>a4</code>是用两种不同方法合并而成的新数组，但是它们的成员都是对原数组成员的引用，这就是浅拷贝。<ins>如果修改了引用指向的值，会同步反映到新数组</ins>。<br><br></p><p><strong>（3）与解构赋值结合</strong></p><p>扩展运算符可以与解构赋值结合起来，用于生成数组。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> [first, ...rest] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">first; <span class="comment">// 1</span></span><br><span class="line">rest; <span class="comment">// [2, 3, 4, 5]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> [first, ...rest] = [];</span><br><span class="line">first; <span class="comment">// undefined</span></span><br><span class="line">rest; <span class="comment">// []</span></span><br></pre></td></tr></table></figure><p><strong>（4）具有 Iterator 接口的对象</strong></p><p>扩展运算符调用的是数据结构的 <code>Iterator</code> 接口，因此只要具有 <code>Iterator</code> 接口的对象，都可以使用扩展运算符。比如字符串，<code>Map</code>和<code>Set</code>，<code>Generator</code>函数返回的遍历器对象。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[...<span class="string">&quot;hello&quot;</span>];</span><br><span class="line"><span class="comment">// [ &quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot; ]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>([</span><br><span class="line">  [<span class="number">1</span>, <span class="string">&quot;one&quot;</span>],</span><br><span class="line">  [<span class="number">2</span>, <span class="string">&quot;two&quot;</span>],</span><br><span class="line">  [<span class="number">3</span>, <span class="string">&quot;three&quot;</span>],</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = [...map.<span class="title function_">keys</span>()]; <span class="comment">// [1, 2, 3]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> go = <span class="keyword">function</span>* () &#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">[...<span class="title function_">go</span>()]; <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure><hr><h3 id="8-3-新增方法"><a href="#8-3-新增方法" class="headerlink" title="8.3 新增方法"></a>8.3 新增方法</h3><p><code>Array.from()</code>方法用于将两类对象转为真正的数组，类似数组的对象和可遍历的对象。（包括 <code>ES6</code> 新增的数据结构 <code>Set</code> 和 <code>Map</code>，和部署了 <code>Iterator</code> 接口的数据结构）<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arrayLike = &#123;</span><br><span class="line">  <span class="number">0</span>: <span class="string">&quot;a&quot;</span>,</span><br><span class="line">  <span class="number">1</span>: <span class="string">&quot;b&quot;</span>,</span><br><span class="line">  <span class="number">2</span>: <span class="string">&quot;c&quot;</span>,</span><br><span class="line">  <span class="attr">length</span>: <span class="number">3</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES5 的写法</span></span><br><span class="line"><span class="keyword">var</span> arr1 = [].<span class="property">slice</span>.<span class="title function_">call</span>(arrayLike); <span class="comment">// [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6 的写法</span></span><br><span class="line"><span class="keyword">let</span> arr2 = <span class="title class_">Array</span>.<span class="title function_">from</span>(arrayLike); <span class="comment">// [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]</span></span><br></pre></td></tr></table></figure><p><code>Array.from()</code>还可以接受一个函数作为第二个参数，作用类似于数组的<code>map()</code>方法，用来对每个元素进行处理，将处理后的值放入返回的数组。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="title function_">from</span>(arrayLike, <span class="function">(<span class="params">x</span>) =&gt;</span> x * x);</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="title class_">Array</span>.<span class="title function_">from</span>(arrayLike).<span class="title function_">map</span>(<span class="function">(<span class="params">x</span>) =&gt;</span> x * x);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Array</span>.<span class="title function_">from</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="function">(<span class="params">x</span>) =&gt;</span> x * x);</span><br><span class="line"><span class="comment">// [1, 4, 9]</span></span><br></pre></td></tr></table></figure><p><code>Array.of()</code>方法用于将一组值，转换为数组。它可以替代<code>Array()</code>或<code>new Array()</code>，并且不存在由于参数不同而导致的重载。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="title function_">of</span>(<span class="number">3</span>, <span class="number">11</span>, <span class="number">8</span>); <span class="comment">// [3,11,8]</span></span><br><span class="line"><span class="title class_">Array</span>.<span class="title function_">of</span>(<span class="number">3</span>); <span class="comment">// [3]</span></span><br><span class="line"><span class="title class_">Array</span>.<span class="title function_">of</span>(<span class="number">3</span>).<span class="property">length</span>; <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载</span></span><br><span class="line"><span class="title class_">Array</span>(); <span class="comment">// []</span></span><br><span class="line"><span class="title class_">Array</span>(<span class="number">3</span>); <span class="comment">// [, , ,]</span></span><br><span class="line"><span class="title class_">Array</span>(<span class="number">3</span>, <span class="number">11</span>, <span class="number">8</span>); <span class="comment">// [3, 11, 8]</span></span><br></pre></td></tr></table></figure><p><code>find()</code>方法，用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为<code>true</code>的成员，然后返回该成员。如果没有符合条件的成员，则返回<code>undefined</code>。<br><br></p><p><code>findIndex()</code>方法的用法与<code>find()</code>方法类似，返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回<code>-1</code>。<code>find()</code>和<code>findIndex()</code>都是从数组的<code>0</code>号位，依次向后检查。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">4</span>, -<span class="number">5</span>, <span class="number">10</span>]</span><br><span class="line">  .<span class="title function_">find</span>(<span class="function">(<span class="params">n</span>) =&gt;</span> n &lt; <span class="number">0</span>)</span><br><span class="line">  [</span><br><span class="line">    <span class="comment">// -5</span></span><br><span class="line"></span><br><span class="line">    (<span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>)</span><br><span class="line">  ].<span class="title function_">findIndex</span>(<span class="keyword">function</span> (<span class="params">value, index, arr</span>) &#123;</span><br><span class="line">    <span class="comment">// 当前的值、当前的位置和原数组</span></span><br><span class="line">    <span class="keyword">return</span> value &gt; <span class="number">9</span>;</span><br><span class="line">  &#125;); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>与之相反，<code>findLast()</code>和<code>findLastIndex()</code>是从数组的最后一个成员开始，依次向前检查，其他都保持不变。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> array = [&#123; <span class="attr">value</span>: <span class="number">1</span> &#125;, &#123; <span class="attr">value</span>: <span class="number">2</span> &#125;, &#123; <span class="attr">value</span>: <span class="number">3</span> &#125;, &#123; <span class="attr">value</span>: <span class="number">4</span> &#125;];</span><br><span class="line"></span><br><span class="line">array.<span class="title function_">findLast</span>(<span class="function">(<span class="params">n</span>) =&gt;</span> n.<span class="property">value</span> % <span class="number">2</span> === <span class="number">1</span>); <span class="comment">// &#123; value: 3 &#125;</span></span><br><span class="line">array.<span class="title function_">findLastIndex</span>(<span class="function">(<span class="params">n</span>) =&gt;</span> n.<span class="property">value</span> % <span class="number">2</span> === <span class="number">1</span>); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p><code>fill()</code>方法使用给定值，填充一个数组。它还可以接受第二个和第三个参数，用于指定填充的起始位置和结束位置。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>].<span class="title function_">fill</span>(<span class="number">7</span>);</span><br><span class="line"><span class="comment">// [7, 7, 7]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">3</span>).<span class="title function_">fill</span>(<span class="number">7</span>)[</span><br><span class="line">  <span class="comment">// [7, 7, 7]</span></span><br><span class="line"></span><br><span class="line">  (<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>)</span><br><span class="line">].<span class="title function_">fill</span>(<span class="number">7</span>, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="comment">// [&#x27;a&#x27;, 7, &#x27;c&#x27;]</span></span><br></pre></td></tr></table></figure><p><code>ES6</code> 提供三个新的方法用于遍历数组。<code>keys()</code>是对键名的遍历，<code>values()</code>是对键值的遍历，<code>entries()</code>是对键值对的遍历。它们都可以用<code>for...of</code>循环进行遍历。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> index <span class="keyword">of</span> [<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>].<span class="title function_">keys</span>()) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(index);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> elem <span class="keyword">of</span> [<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>].<span class="title function_">values</span>()) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(elem);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &#x27;a&#x27;</span></span><br><span class="line"><span class="comment">// &#x27;b&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [index, elem] <span class="keyword">of</span> [<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>].<span class="title function_">entries</span>()) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(index, elem);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0 &quot;a&quot;</span></span><br><span class="line"><span class="comment">// 1 &quot;b&quot;</span></span><br></pre></td></tr></table></figure><p><code>includes()</code>方法返回一个布尔值，表示某个数组是否包含给定的值。该方法的第二个参数表示搜索的起始位置，默认为<code>0</code>。如果第二个参数为负数，则表示倒数的位置。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">  .<span class="title function_">includes</span>(<span class="number">2</span>) <span class="comment">// true</span></span><br><span class="line">  [(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)].<span class="title function_">includes</span>(<span class="number">4</span>) <span class="comment">// false</span></span><br><span class="line">  [(<span class="number">1</span>, <span class="number">2</span>, <span class="title class_">NaN</span>)].<span class="title function_">includes</span>(<span class="title class_">NaN</span>) <span class="comment">// true</span></span><br><span class="line">  [(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)].<span class="title function_">includes</span>(<span class="number">3</span>, -<span class="number">1</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>数组的成员有时还是数组，<code>flat()</code>方法用于将嵌套的数组“拉平”，变成一维的数组。该方法返回一个新数组，对原数据没有影响。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>]].<span class="title function_">flat</span>();</span><br><span class="line"><span class="comment">// [1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure><p><code>flat()</code>方法默认只会“拉平”一层，如果想要“拉平”多层的嵌套数组，可以指定<code>flat()</code>方法的参数，表示想要拉平的层数，默认为<code>1</code>。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>]]]</span><br><span class="line">  .<span class="title function_">flat</span>()</span><br><span class="line">  [</span><br><span class="line">    <span class="comment">// [1, 2, 3, [4, 5]]</span></span><br><span class="line"></span><br><span class="line">    (<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>]])</span><br><span class="line">  ].<span class="title function_">flat</span>(<span class="number">2</span>)</span><br><span class="line">  [</span><br><span class="line">    <span class="comment">// [1, 2, 3, 4, 5]</span></span><br><span class="line"></span><br><span class="line">    (<span class="number">1</span>, [<span class="number">2</span>, [<span class="number">3</span>]])</span><br><span class="line">  ].<span class="title function_">flat</span>(<span class="title class_">Infinity</span>);</span><br><span class="line"><span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure><p><code>flatMap()</code>方法对原数组的每个成员执行一个函数（相当于执行<code>map()</code>）, 然后对返回值组成的数组执行<code>flat()</code>方法。注意，<code>flatMap()</code>只能展开一层数组。该方法返回一个新数组，不改变原数组。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 相当于 [[2, 4], [3, 6], [4, 8]].flat()</span></span><br><span class="line">[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">  .<span class="title function_">flatMap</span>(<span class="function">(<span class="params">x</span>) =&gt;</span> [x, x * <span class="number">2</span>])</span><br><span class="line">  [</span><br><span class="line">    <span class="comment">// [2, 4, 3, 6, 4, 8]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 相当于 [[[2]], [[4]], [[6]], [[8]]].flat()</span></span><br><span class="line">    (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">  ].<span class="title function_">flatMap</span>(<span class="function">(<span class="params">x</span>) =&gt;</span> [[x * <span class="number">2</span>]]);</span><br><span class="line"><span class="comment">// [[2], [4], [6], [8]]</span></span><br></pre></td></tr></table></figure><p><code>ES5</code> 不支持数组的负索引，如果要引用数组的最后一个成员，不能写成<code>arr[-1]</code>，只能使用<code>arr[arr.length - 1]</code>。<code>ES6</code> 为数组实例增加了<code>at()</code>方法，接受一个整数作为参数，返回对应位置的成员，并支持负索引。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">5</span>, <span class="number">12</span>, <span class="number">8</span>, <span class="number">130</span>, <span class="number">44</span>];</span><br><span class="line"></span><br><span class="line">arr[-<span class="number">2</span>]; <span class="comment">// Error</span></span><br><span class="line">arr.<span class="title function_">at</span>(<span class="number">2</span>); <span class="comment">// 8</span></span><br><span class="line">arr.<span class="title function_">at</span>(-<span class="number">2</span>); <span class="comment">// 130</span></span><br></pre></td></tr></table></figure><hr><h2 id="9-对象的扩展"><a href="#9-对象的扩展" class="headerlink" title="9. 对象的扩展"></a>9. 对象的扩展</h2><p><a href="https://es6.ruanyifeng.com/#docs/object">本章</a>内容复杂，故先跳过一部分。</p><h3 id="9-1-属性的简洁表示法"><a href="#9-1-属性的简洁表示法" class="headerlink" title="9.1 属性的简洁表示法"></a>9.1 属性的简洁表示法</h3><p><code>ES6</code> 允许在大括号里面，直接写入变量和函数，作为对象的属性和方法。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> birth = <span class="string">&quot;2000/01/01&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Person</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;张三&quot;</span>,</span><br><span class="line">  birth, <span class="comment">// 等同于 birth: birth</span></span><br><span class="line">  <span class="title function_">hello</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;我的名字是&quot;</span>, <span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 等同于 hello: function ()...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h3 id="9-2-super-关键字"><a href="#9-2-super-关键字" class="headerlink" title="9.2 super 关键字"></a>9.2 super 关键字</h3><p>众所周知，<ins><code>this</code>关键字总是指向函数所在的当前对象</ins>，<code>ES6</code> 又新增了另一个类似的关键字<ins><code>super</code>，指向当前对象的原型对象</ins>。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> proto = &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="string">&quot;hello&quot;</span>,</span><br><span class="line">  <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">x</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="string">&quot;world&quot;</span>,</span><br><span class="line">  <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>.<span class="title function_">foo</span>();</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(obj, proto);</span><br><span class="line">obj.<span class="title function_">foo</span>(); <span class="comment">// &quot;world&quot;</span></span><br></pre></td></tr></table></figure><p>上面代码中，对象<code>obj.foo()</code>方法之中，通过<code>super.foo</code>引用了原型对象<code>proto</code>的<code>foo</code>方法。<ins>但是绑定的<code>this</code>却还是当前对象<code>obj</code>，因此输出的就是<code>world</code></ins>。<br><br></p><p>注意，<code>super</code>关键字表示原型对象时，<ins>只能用在对象的方法之中</ins>，用在其他地方都会报错。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">/ 报错</span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">foo</span>: <span class="variable language_">super</span>.<span class="property">foo</span> <span class="comment">// 对象属性</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">foo</span>: <span class="function">() =&gt;</span> <span class="variable language_">super</span>.<span class="property">foo</span> <span class="comment">// 对象属性</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">foo</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="comment">// 对象属性</span></span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">super</span>.<span class="property">foo</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="9-3-对象的扩展运算符"><a href="#9-3-对象的扩展运算符" class="headerlink" title="9.3 对象的扩展运算符"></a>9.3 对象的扩展运算符</h3><p><strong>（1）解构赋值</strong></p><p>对象的解构赋值用于从一个对象取值，将目标对象所有<a href="https://es6.ruanyifeng.com/#docs/object#%E5%B1%9E%E6%80%A7%E7%9A%84%E5%8F%AF%E6%9E%9A%E4%B8%BE%E6%80%A7%E5%92%8C%E9%81%8D%E5%8E%86">可遍历</a>的、但尚未被读取的属性，分配到指定的对象上面。（注意，解构赋值必须是最后一个参数，且等号右边不能是<code>undefined</code>或<code>null</code>）<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; x, y, ...z &#125; = &#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span>, <span class="attr">a</span>: <span class="number">3</span>, <span class="attr">b</span>: <span class="number">4</span> &#125;;</span><br><span class="line">x <span class="comment">// 1</span></span><br><span class="line">y <span class="comment">// 2</span></span><br><span class="line">z <span class="comment">// &#123; a: 3, b: 4 &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> z = &#123; <span class="attr">a</span>: <span class="number">3</span>, <span class="attr">b</span>: <span class="number">4</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> n = &#123; ...z &#125;;</span><br><span class="line">n <span class="comment">// &#123; a: 3, b: 4 &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; ...x, y, z &#125; = someObject; <span class="comment">// 句法错误</span></span><br></pre></td></tr></table></figure><p>解构赋值的拷贝是<a href="https://vue3js.cn/interview/JavaScript/copy.html">浅拷贝</a>，即<ins>如果一个键的值是复合类型的值（如数组、对象、函数），那么解构赋值拷贝的是这个值的引用，而不是这个值的副本</ins>。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">a</span>: &#123; <span class="attr">b</span>: <span class="number">1</span> &#125; &#125;;</span><br><span class="line"><span class="keyword">let</span> &#123; ...x &#125; = obj;</span><br><span class="line">obj.<span class="property">a</span>.<span class="property">b</span> = <span class="number">2</span>;</span><br><span class="line">x.<span class="property">a</span>.<span class="property">b</span>; <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>x</code>是解构赋值所在的对象，拷贝了对象<code>obj</code>的<code>a</code>属性。<code>a</code>属性引用了一个对象，修改这个对象的值，会影响到解构赋值对它的引用。<br><br></p><p>解构赋值的一个用处，是扩展某个函数的参数，引入其他操作。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">baseFunction</span>(<span class="params">&#123; a, b &#125;</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">wrapperFunction</span>(<span class="params">&#123; x, y, ...restConfig &#125;</span>) &#123;</span><br><span class="line">  <span class="comment">// 使用 x 和 y 参数进行操作</span></span><br><span class="line">  <span class="comment">// 其余参数传给原始函数</span></span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">baseFunction</span>(restConfig);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，原始函数<code>baseFunction</code>接受<code>a</code>和<code>b</code>作为参数，函数<code>wrapperFunction</code>在<code>baseFunction</code>的基础上进行了扩展，能够接受多余的参数，并且保留原始函数的行为。<br><br></p><p><strong>（2）扩展运算符</strong></p><p>对象的扩展运算符 <code>...</code> 用于取出参数对象的所有可遍历属性，拷贝到当前对象之中。（扩展运算符不需要是最后一个参数）<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> z = &#123; <span class="attr">a</span>: <span class="number">3</span>, <span class="attr">b</span>: <span class="number">4</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> n = &#123; ...z &#125;;</span><br><span class="line">n <span class="comment">// &#123; a: 3, b: 4 &#125;</span></span><br><span class="line"></span><br><span class="line">&#123;...&#123;&#125;, <span class="attr">a</span>: <span class="number">1</span>&#125;</span><br><span class="line"><span class="comment">// &#123; a: 1 &#125;</span></span><br></pre></td></tr></table></figure><p>扩展运算符还可以用于合并两个对象。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> ab = &#123; ...a, ...b &#125;;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">let</span> ab = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, a, b);</span><br></pre></td></tr></table></figure><p>如果用户自定义的属性，放在扩展运算符后面，则扩展运算符内部的同名属性会被覆盖掉。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> aWithOverrides = &#123; ...a, <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">let</span> aWithOverrides = &#123; ...a, ...&#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span> &#125; &#125;;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">let</span> x = <span class="number">1</span>,</span><br><span class="line">  y = <span class="number">2</span>,</span><br><span class="line">  aWithOverrides = &#123; ...a, x, y &#125;;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">let</span> aWithOverrides = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, a, &#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span> &#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，<code>a</code>对象的<code>x</code>属性和<code>y</code>属性，拷贝到新对象后会被覆盖掉。</p><hr><h2 id="10-对象的新增方法"><a href="#10-对象的新增方法" class="headerlink" title="10. 对象的新增方法"></a>10. 对象的新增方法</h2><p><a href="https://es6.ruanyifeng.com/#docs/object-methods">本章</a>内容复杂，故先跳过一部分。</p><h3 id="10-1-静态方法"><a href="#10-1-静态方法" class="headerlink" title="10.1 静态方法"></a>10.1 静态方法</h3><p><code>ES5</code> 中比较两个值是否相等，只有两个运算符，相等运算符<code>==</code>和严格相等运算符<code>===</code>。它们都有缺点，前者会自动转换数据类型，后者的<code>NaN</code>不等于自身，以及<code>+0</code>等于<code>-0</code>。<br><br></p><p><code>Object.is()</code>方法用来比较两个值是否严格相等，与严格比较运算符<code>===</code>的行为基本一致。不同之处只有两个，一是<code>+0</code>不等于<code>-0</code>，二是<code>NaN</code>等于自身。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">is</span>(<span class="string">&quot;foo&quot;</span>, <span class="string">&quot;foo&quot;</span>);</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">is</span>(&#123;&#125;, &#123;&#125;);</span><br><span class="line"><span class="comment">// false</span></span><br></pre></td></tr></table></figure><p><code>Object.assign()</code>方法用于对象的合并，将源对象<code>source</code>的所有可枚举属性，复制到目标对象<code>target</code>。它的第一个参数是目标对象，后面的参数都是源对象。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> source1 = &#123; <span class="attr">b</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> source2 = &#123; <span class="attr">c</span>: <span class="number">3</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">assign</span>(target, source1, source2);</span><br><span class="line">target; <span class="comment">// &#123;a:1, b:2, c:3&#125;</span></span><br></pre></td></tr></table></figure><p><code>Object.assign()</code>有以下几个使用注意点。<br><br></p><p><strong>（1）浅拷贝</strong></p><p><code>Object.assign()</code>方法实行的是浅拷贝，而不是深拷贝。也就是说，如果源对象某个属性的值是对象，那么目标对象拷贝得到的是这个对象的引用（指针）。<br><br></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const obj1 = &#123;a: &#123;b: 1&#125;&#125;;</span><br><span class="line">const obj2 = Object.assign(&#123;&#125;, obj1);</span><br><span class="line"></span><br><span class="line">obj1.a.b = 2;</span><br><span class="line">obj2.a.b // 2</span><br></pre></td></tr></table></figure><p>上面代码中，源对象<code>obj1</code>的<code>a</code>属性的值是一个对象，<code>Object.assign()</code>拷贝得到的是这个对象的引用。这个对象的任何变化，都会反映到目标对象上面。<br><br></p><p><strong>（2）同名属性的替换</strong></p><p>对于嵌套的对象，一旦遇到同名属性，<code>Object.assign()</code>的处理方法是替换，而不是添加。这通常不是我们想要的，需要特别小心。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123; <span class="attr">a</span>: &#123; <span class="attr">b</span>: <span class="string">&quot;c&quot;</span>, <span class="attr">d</span>: <span class="string">&quot;e&quot;</span> &#125; &#125;;</span><br><span class="line"><span class="keyword">const</span> source = &#123; <span class="attr">a</span>: &#123; <span class="attr">b</span>: <span class="string">&quot;hello&quot;</span> &#125; &#125;;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">assign</span>(target, source);</span><br><span class="line"><span class="comment">// &#123; a: &#123; b: &#x27;hello&#x27; &#125; &#125;</span></span><br></pre></td></tr></table></figure><p>对于普通对象，我们可以用下面的方法对对象进行遍历。</p><ul><li><code>Object.keys()</code>返回一个数组，成员是参数对象自身的所有可遍历属性的键名。</li><li><code>Object.values()</code>返回一个数组，成员是参数对象自身的所有可遍历属性的键值。</li><li><code>Object.entries()</code>返回一个数组，成员是参数对象自身的所有可遍历属性的键值对数组。</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">foo</span>: <span class="string">&quot;bar&quot;</span>, <span class="attr">baz</span>: <span class="number">42</span> &#125;;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">keys</span>(obj);</span><br><span class="line"><span class="comment">// [&quot;foo&quot;, &quot;baz&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">foo</span>: <span class="string">&quot;bar&quot;</span>, <span class="attr">baz</span>: <span class="number">42</span> &#125;;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">values</span>(obj);</span><br><span class="line"><span class="comment">// [&quot;bar&quot;, 42]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">foo</span>: <span class="string">&quot;bar&quot;</span>, <span class="attr">baz</span>: <span class="number">42</span> &#125;;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">entries</span>(obj);</span><br><span class="line"><span class="comment">// [ [&quot;foo&quot;, &quot;bar&quot;], [&quot;baz&quot;, 42] ]</span></span><br></pre></td></tr></table></figure><hr><h2 id="11-运算符的扩展"><a href="#11-运算符的扩展" class="headerlink" title="11. 运算符的扩展"></a>11. 运算符的扩展</h2><h3 id="11-1-链判断运算符"><a href="#11-1-链判断运算符" class="headerlink" title="11.1 链判断运算符"></a>11.1 链判断运算符</h3><p>当我们打算读取对象内部的某个属性时，往往需要判断一下属性的上层对象是否存在。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误的写法</span></span><br><span class="line"><span class="keyword">const</span> firstName = message.<span class="property">body</span>.<span class="property">user</span>.<span class="property">firstName</span> || <span class="string">&quot;default&quot;</span>; <span class="comment">// 无法保证 message.body 存在...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确的写法</span></span><br><span class="line"><span class="keyword">const</span> firstName =</span><br><span class="line">  (message &amp;&amp;</span><br><span class="line">    message.<span class="property">body</span> &amp;&amp;</span><br><span class="line">    message.<span class="property">body</span>.<span class="property">user</span> &amp;&amp;</span><br><span class="line">    message.<span class="property">body</span>.<span class="property">user</span>.<span class="property">firstName</span>) ||</span><br><span class="line">  <span class="string">&quot;default&quot;</span>;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>firstName</code>属性在对象的第四层，所以需要判断四次，每一层是否有值。这样的层层判断非常麻烦，因此 <code>ES6</code> 引入了“链判断运算符” <code>?.</code>，用来简化上面的写法。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> firstName = message?.<span class="property">body</span>?.<span class="property">user</span>?.<span class="property">firstName</span> || <span class="string">&quot;default&quot;</span>;</span><br></pre></td></tr></table></figure><p>上面代码使用了<code>?.</code>运算符，直接在链式调用的时候判断，左侧的对象是否为<code>null</code>或<code>undefined</code>。如果是的，就不再往下运算，而是返回<code>undefined</code>。<br><br></p><p>下面是 <code>?.</code> 运算符常见形式，以及不使用该运算符时的等价形式。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">a?.<span class="property">b</span>;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">a == <span class="literal">null</span> ? <span class="literal">undefined</span> : a.<span class="property">b</span>;</span><br><span class="line"></span><br><span class="line">a?.[x];</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">a == <span class="literal">null</span> ? <span class="literal">undefined</span> : a[x];</span><br><span class="line"></span><br><span class="line">a?.<span class="title function_">b</span>();</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">a == <span class="literal">null</span> ? <span class="literal">undefined</span> : a.<span class="title function_">b</span>();</span><br><span class="line"></span><br><span class="line">a?.();</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">a == <span class="literal">null</span> ? <span class="literal">undefined</span> : <span class="title function_">a</span>();</span><br></pre></td></tr></table></figure><hr><h3 id="11-2-Null-判断运算符"><a href="#11-2-Null-判断运算符" class="headerlink" title="11.2 Null 判断运算符"></a>11.2 Null 判断运算符</h3><p>读取对象属性的时候，如果某个属性的值是<code>null</code>或<code>undefined</code>，有时候需要为它们指定默认值。常见做法是通过<code>||</code>运算符指定默认值。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> headerText = response.<span class="property">settings</span>.<span class="property">headerText</span> || <span class="string">&quot;Hello, world!&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> animationDuration = response.<span class="property">settings</span>.<span class="property">animationDuration</span> || <span class="number">300</span>;</span><br><span class="line"><span class="keyword">const</span> showSplashScreen = response.<span class="property">settings</span>.<span class="property">showSplashScreen</span> || <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><p>但是属性的值如果为空字符串或<code>false</code>或<code>0</code>，默认值也会生效。为此，<code>ES6</code> 引入了一个新的 <code>Null</code> 判断运算符<code>??</code>。它的行为类似<code>||</code>，但是只有运算符左侧的值为<code>null</code>或<code>undefined</code>时，才会返回右侧的值。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> animationDuration = response.<span class="property">settings</span>?.<span class="property">animationDuration</span> ?? <span class="number">300</span>;</span><br></pre></td></tr></table></figure><p>上面代码中，如果<code>response.settings</code>是<code>null</code>或<code>undefined</code>，或者<code>response.settings.animationDuration</code>是<code>null</code>或<code>undefined</code>，就会返回默认值<code>300</code>。</p><hr><h2 id="12-Symbol-数据类型"><a href="#12-Symbol-数据类型" class="headerlink" title="12. Symbol 数据类型"></a>12. Symbol 数据类型</h2><p><a href="https://es6.ruanyifeng.com/#docs/symbol">本章</a>内容复杂，故先跳过一部分。</p><h3 id="12-1-Symbol-概述"><a href="#12-1-Symbol-概述" class="headerlink" title="12.1 Symbol 概述"></a>12.1 Symbol 概述</h3><p><code>ES6</code> 引入了一种新的原始数据类型 <code>Symbol</code>，表示独一无二的值。</p><p><code>Symbol</code> 通过 <code>Symbol()</code> 函数生成，可以用于为对象添加新的方法，且不存在属性名冲突。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="title class_">Symbol</span>(); <span class="comment">// Symbol() 函数前不能使用 new 命令</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> s;</span><br><span class="line"><span class="comment">// &quot;symbol&quot;</span></span><br></pre></td></tr></table></figure><p><code>ES6</code> 提供了一个 <code>Symbol</code> 值的实例属性<code>description</code>，直接返回 <code>Symbol</code> 值的描述。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> sym = <span class="title class_">Symbol</span>(<span class="string">&quot;foo&quot;</span>); <span class="comment">// 字符串作为参数</span></span><br><span class="line"></span><br><span class="line">sym; <span class="comment">// [object Symbol] &#123; ... &#125;</span></span><br><span class="line">sym.<span class="title function_">toString</span>(); <span class="comment">// &quot;Symbol(foo)&quot;</span></span><br><span class="line"></span><br><span class="line">sym.<span class="property">description</span>; <span class="comment">// &quot;foo&quot;</span></span><br></pre></td></tr></table></figure><p>因为 <code>Symbol</code> 值都是不相等的（就算是相同描述，除非使用 <a href="https://es6.ruanyifeng.com/#docs/symbol#Symbol-for%EF%BC%8CSymbol-keyFor"><code>Symbol.for</code></a>），使用 <code>Symbol</code> 值作为标识符，用于对象的属性名，就能保证不会出现同名的属性。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> mySymbol = <span class="title class_">Symbol</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一种写法</span></span><br><span class="line"><span class="keyword">let</span> a = &#123;&#125;;</span><br><span class="line">a[mySymbol] = <span class="string">&quot;Hello!&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种写法</span></span><br><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">  [mySymbol]: <span class="string">&quot;Hello!&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以上写法都得到同样结果</span></span><br><span class="line">a[mySymbol]; <span class="comment">// &quot;Hello!&quot;</span></span><br></pre></td></tr></table></figure><hr><h2 id="13-Set-和-Map-数据结构"><a href="#13-Set-和-Map-数据结构" class="headerlink" title="13. Set 和 Map 数据结构"></a>13. Set 和 Map 数据结构</h2><p><a href="https://es6.ruanyifeng.com/#docs/set-map">本章</a>跳过 <code>WeakSet</code> 和 <code>WeakMap</code> 部分。</p><h3 id="13-1-Set-基本用法"><a href="#13-1-Set-基本用法" class="headerlink" title="13.1 Set 基本用法"></a>13.1 Set 基本用法</h3><p><code>ES6</code>提供了新的数据结构 <code>Set</code>。它类似于数组，但是<ins>成员的值都是唯一的，没有重复的值</ins>。它可以接受一个数组，或者具有 <code>iterable</code> 接口的其他数据结构，作为参数初始化。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line"></span><br><span class="line">[<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">2</span>].<span class="title function_">forEach</span>(<span class="function">(<span class="params">x</span>) =&gt;</span> s.<span class="title function_">add</span>(x));</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> s) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2 3 5 4</span></span><br></pre></td></tr></table></figure><p>下面介绍 <code>Set</code> 实例的属性和方法</p><ul><li><code>Set.prototype.size</code>：返回<code>Set</code>实例的成员总数。</li><li><code>Set.prototype.add(value)</code>：添加某个值，返回 <code>Set</code> 结构本身。</li><li><code>Set.prototype.delete(value)</code>：删除某个值，返回一个布尔值，表示删除是否成功。</li><li><code>Set.prototype.has(value)</code>：返回一个布尔值，表示该值是否为<code>Set</code>的成员。</li><li><code>Set.prototype.clear()</code>：清除所有成员，没有返回值。</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line">s.<span class="title function_">add</span>(<span class="number">1</span>).<span class="title function_">add</span>(<span class="number">2</span>).<span class="title function_">add</span>(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 注意2被加入了两次</span></span><br><span class="line"></span><br><span class="line">s.<span class="property">size</span>; <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">s.<span class="title function_">has</span>(<span class="number">1</span>); <span class="comment">// true</span></span><br><span class="line">s.<span class="title function_">has</span>(<span class="number">2</span>); <span class="comment">// true</span></span><br><span class="line">s.<span class="title function_">has</span>(<span class="number">3</span>); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">s.<span class="title function_">delete</span>(<span class="number">2</span>);</span><br><span class="line">s.<span class="title function_">has</span>(<span class="number">2</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p><code>Set</code> 结构的实例默认可遍历, 可以直接用<code>for...of</code>循环遍历 <code>Set</code>。也可以用<code>forEach</code>方法，用于对每个成员执行某种操作，没有返回值。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="string">&quot;red&quot;</span>, <span class="string">&quot;green&quot;</span>, <span class="string">&quot;blue&quot;</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">of</span> set) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// red</span></span><br><span class="line"><span class="comment">// green</span></span><br><span class="line"><span class="comment">// blue</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>]);</span><br><span class="line">set.<span class="title function_">forEach</span>(<span class="function">(<span class="params">value, key</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(key + <span class="string">&quot; : &quot;</span> + value));</span><br><span class="line"><span class="comment">// 1 : 1</span></span><br><span class="line"><span class="comment">// 4 : 4</span></span><br><span class="line"><span class="comment">// 9 : 9</span></span><br></pre></td></tr></table></figure><p>上面代码中<code>forEach</code>方法的参数是一个处理函数。但是因为 <code>Set</code> 结构的键名就是键值，因此第一个参数与第二个参数的值永远都是一样的。</p><hr><h3 id="13-2-Set-遍历的应用"><a href="#13-2-Set-遍历的应用" class="headerlink" title="13.2 Set 遍历的应用"></a>13.2 Set 遍历的应用</h3><p>扩展运算符和 <code>Set</code> 结构相结合，可以去除数组的重复成员。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 去除数组的重复成员</span></span><br><span class="line">[...<span class="keyword">new</span> <span class="title class_">Set</span>(array)]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 去除字符串里面的重复字符</span></span><br><span class="line">[...<span class="keyword">new</span> <span class="title class_">Set</span>(<span class="string">&#x27;ababbc&#x27;</span>)].<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"><span class="comment">// &quot;abc&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用Array.from方法可以将 Set 结构转为数组。</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">dedupe</span>(<span class="params">array</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Array</span>.<span class="title function_">from</span>(<span class="keyword">new</span> <span class="title class_">Set</span>(array));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">dedupe</span>([<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]) <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure><p>数组的<code>map</code>和<code>filter</code>方法也可以间接用于 <code>Set</code>。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line">set = <span class="keyword">new</span> <span class="title class_">Set</span>([...set].<span class="title function_">map</span>(<span class="function">(<span class="params">x</span>) =&gt;</span> x * <span class="number">2</span>));</span><br><span class="line"><span class="comment">// 返回Set结构：&#123;2, 4, 6&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]);</span><br><span class="line">set = <span class="keyword">new</span> <span class="title class_">Set</span>([...set].<span class="title function_">filter</span>(<span class="function">(<span class="params">x</span>) =&gt;</span> x % <span class="number">2</span> == <span class="number">0</span>));</span><br><span class="line"><span class="comment">// 返回Set结构：&#123;2, 4&#125;</span></span><br></pre></td></tr></table></figure><hr><h3 id="13-3-Map-基本用法"><a href="#13-3-Map-基本用法" class="headerlink" title="13.3 Map 基本用法"></a>13.3 Map 基本用法</h3><p><code>Map</code> 数据结构类似于对象，是键值对的集合，但是各种类型的值（包括对象）都可以当作键。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>([</span><br><span class="line">  [<span class="string">&quot;name&quot;</span>, <span class="string">&quot;张三&quot;</span>],</span><br><span class="line">  [<span class="string">&quot;title&quot;</span>, <span class="string">&quot;Author&quot;</span>],</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line">map.<span class="property">size</span>; <span class="comment">// 2</span></span><br><span class="line">map.<span class="title function_">has</span>(<span class="string">&quot;name&quot;</span>); <span class="comment">// true</span></span><br><span class="line">map.<span class="title function_">get</span>(<span class="string">&quot;name&quot;</span>); <span class="comment">// &quot;张三&quot;</span></span><br><span class="line">map.<span class="title function_">has</span>(<span class="string">&quot;title&quot;</span>); <span class="comment">// true</span></span><br><span class="line">map.<span class="title function_">get</span>(<span class="string">&quot;title&quot;</span>); <span class="comment">// &quot;Author&quot;</span></span><br></pre></td></tr></table></figure><p>下面介绍 <code>Map</code> 实例的属性和方法</p><ul><li><code>Map.prototype.size</code>：返回 <code>Map</code> 结构的成员总数。</li><li><code>Map.prototype.set(key, value)</code>：设置键名<code>key</code>对应的键值为<code>value</code>，然后返回整个 <code>Map</code> 结构。如果<code>key</code>已经有值，则键值会被更新，否则就新生成该键。</li><li><code>Map.prototype.get(key)</code>：读取<code>key</code>对应的键值，如果找不到<code>key</code>，返回<code>undefined</code>。</li><li><code>Map.prototype.has(key)</code>：返回一个布尔值，表示某个键是否在当前 <code>Map</code> 对象之中。</li><li><code>Map.prototype.delete(key)</code>：删除某个键，返回<code>true</code>。如果删除失败，返回<code>false</code>。</li><li><code>Map.prototype.clear()</code>：清除所有成员，没有返回值。</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">map.<span class="title function_">set</span>(<span class="string">&quot;foo&quot;</span>, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line">map.<span class="title function_">set</span>(<span class="string">&quot;bar&quot;</span>, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">map.<span class="property">size</span>; <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">map.<span class="title function_">get</span>(<span class="string">&quot;foo&quot;</span>); <span class="comment">// hello</span></span><br><span class="line">map.<span class="title function_">has</span>(<span class="string">&quot;foo&quot;</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">map.<span class="title function_">delete</span>(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line">map.<span class="title function_">has</span>(<span class="string">&quot;foo&quot;</span>); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">map.<span class="title function_">clear</span>();</span><br><span class="line">map.<span class="property">size</span>; <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><p>下面介绍 <code>Map</code> 结构原生提供三个遍历器生成函数和一个遍历方法</p><ul><li><code>Map.prototype.keys()</code>：返回键名的遍历器。</li><li><code>Map.prototype.values()</code>：返回键值的遍历器。</li><li><code>Map.prototype.entries()</code>：返回所有成员的遍历器。</li><li><code>Map.prototype.forEach()</code>：遍历 <code>Map</code> 的所有成员。</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>([</span><br><span class="line">  [<span class="string">&quot;F&quot;</span>, <span class="string">&quot;no&quot;</span>],</span><br><span class="line">  [<span class="string">&quot;T&quot;</span>, <span class="string">&quot;yes&quot;</span>],</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> map.<span class="title function_">keys</span>()) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &quot;F&quot;</span></span><br><span class="line"><span class="comment">// &quot;T&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> map.<span class="title function_">values</span>()) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &quot;no&quot;</span></span><br><span class="line"><span class="comment">// &quot;yes&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> map.<span class="title function_">entries</span>()) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(item[<span class="number">0</span>], item[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &quot;F&quot; &quot;no&quot;</span></span><br><span class="line"><span class="comment">// &quot;T&quot; &quot;yes&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> map.<span class="title function_">entries</span>()) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(key, value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &quot;F&quot; &quot;no&quot;</span></span><br><span class="line"><span class="comment">// &quot;T&quot; &quot;yes&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于使用map.entries()</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> map) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(key, value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &quot;F&quot; &quot;no&quot;</span></span><br><span class="line"><span class="comment">// &quot;T&quot; &quot;yes&quot;</span></span><br><span class="line"></span><br><span class="line">map.<span class="title function_">forEach</span>(<span class="keyword">function</span> (<span class="params">value, key, map</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Key: %s, Value: %s&quot;</span>, key, value);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>需要特别注意的是，<code>Map</code> 的遍历顺序就是插入顺序。</p><hr><h3 id="13-4-Map-与其他数据结构转换"><a href="#13-4-Map-与其他数据结构转换" class="headerlink" title="13.4 Map 与其他数据结构转换"></a>13.4 Map 与其他数据结构转换</h3><p><strong>（1）Map 转为数组</strong></p><p><code>Map</code> 转为数组最方便的方法，就是使用扩展运算符<code>...</code>。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> myMap = <span class="keyword">new</span> <span class="title class_">Map</span>().<span class="title function_">set</span>(<span class="literal">true</span>, <span class="number">7</span>).<span class="title function_">set</span>(&#123; <span class="attr">foo</span>: <span class="number">3</span> &#125;, [<span class="string">&quot;abc&quot;</span>]);</span><br><span class="line">[...myMap];</span><br><span class="line"><span class="comment">// [ [ true, 7 ], [ &#123; foo: 3 &#125;, [ &#x27;abc&#x27; ] ] ]</span></span><br></pre></td></tr></table></figure><p>结合数组的<code>map</code>方法、<code>filter</code>方法，就可以实现 <code>Map</code> 的遍历和过滤。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> map0 = <span class="keyword">new</span> <span class="title class_">Map</span>().<span class="title function_">set</span>(<span class="number">1</span>, <span class="string">&quot;a&quot;</span>).<span class="title function_">set</span>(<span class="number">2</span>, <span class="string">&quot;b&quot;</span>).<span class="title function_">set</span>(<span class="number">3</span>, <span class="string">&quot;c&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> map1 = <span class="keyword">new</span> <span class="title class_">Map</span>([...map0].<span class="title function_">filter</span>(<span class="function">(<span class="params">[k, v]</span>) =&gt;</span> k &lt; <span class="number">3</span>));</span><br><span class="line"><span class="comment">// 产生 Map 结构 &#123;1 =&gt; &#x27;a&#x27;, 2 =&gt; &#x27;b&#x27;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> map2 = <span class="keyword">new</span> <span class="title class_">Map</span>([...map0].<span class="title function_">map</span>(<span class="function">(<span class="params">[k, v]</span>) =&gt;</span> [k * <span class="number">2</span>, <span class="string">&quot;_&quot;</span> + v]));</span><br><span class="line"><span class="comment">// 产生 Map 结构 &#123;2 =&gt; &#x27;_a&#x27;, 4 =&gt; &#x27;_b&#x27;, 6 =&gt; &#x27;_c&#x27;&#125;</span></span><br></pre></td></tr></table></figure><p><strong>（2）数组 转为 Map</strong></p><p>将数组传入 <code>Map</code> 构造函数，就可以转为 <code>Map</code>。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Map</span>([</span><br><span class="line">  [<span class="literal">true</span>, <span class="number">7</span>],</span><br><span class="line">  [&#123; <span class="attr">foo</span>: <span class="number">3</span> &#125;, [<span class="string">&quot;abc&quot;</span>]],</span><br><span class="line">]);</span><br><span class="line"><span class="comment">// Map &#123;</span></span><br><span class="line"><span class="comment">//   true =&gt; 7,</span></span><br><span class="line"><span class="comment">//   Object &#123;foo: 3&#125; =&gt; [&#x27;abc&#x27;]</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure><p><strong>（3）Map 转为对象</strong></p><p>如果所有 <code>Map</code> 的键都是字符串，它可以无损地转为对象。如果有非字符串的键名，那么这个键名会被转成字符串，再作为对象的键名。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">strMapToObj</span>(<span class="params">strMap</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> obj = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> [k, v] <span class="keyword">of</span> strMap) &#123;</span><br><span class="line">    obj[k] = v;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> myMap = <span class="keyword">new</span> <span class="title class_">Map</span>().<span class="title function_">set</span>(<span class="string">&quot;yes&quot;</span>, <span class="literal">true</span>).<span class="title function_">set</span>(<span class="string">&quot;no&quot;</span>, <span class="literal">false</span>);</span><br><span class="line"><span class="title function_">strMapToObj</span>(myMap);</span><br><span class="line"><span class="comment">// &#123; yes: true, no: false &#125;</span></span><br></pre></td></tr></table></figure><p><strong>（4）对象转为 Map</strong></p><p>对象转为 <code>Map</code> 可以通过 <code>Object.entries()</code>。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>(<span class="title class_">Object</span>.<span class="title function_">entries</span>(obj));</span><br></pre></td></tr></table></figure><p><strong>（5）Map 转为 JSON</strong></p><p><code>Map</code> 转为 <code>JSON</code> 要区分两种情况。</p><p>一种情况是，<code>Map</code> 的键名都是字符串，这时可以选择转为对象 <code>JSON</code>。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">strMapToJson</span>(<span class="params">strMap</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(<span class="title function_">strMapToObj</span>(strMap));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myMap = <span class="keyword">new</span> <span class="title class_">Map</span>().<span class="title function_">set</span>(<span class="string">&quot;yes&quot;</span>, <span class="literal">true</span>).<span class="title function_">set</span>(<span class="string">&quot;no&quot;</span>, <span class="literal">false</span>);</span><br><span class="line"><span class="title function_">strMapToJson</span>(myMap);</span><br><span class="line"><span class="comment">// &#x27;&#123;&quot;yes&quot;:true,&quot;no&quot;:false&#125;&#x27;</span></span><br></pre></td></tr></table></figure><p>另一种情况是，<code>Map</code> 的键名有非字符串，这时可以选择转为数组 <code>JSON</code>。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">mapToArrayJson</span>(<span class="params">map</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">JSON</span>.<span class="title function_">stringify</span>([...map]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myMap = <span class="keyword">new</span> <span class="title class_">Map</span>().<span class="title function_">set</span>(<span class="literal">true</span>, <span class="number">7</span>).<span class="title function_">set</span>(&#123; <span class="attr">foo</span>: <span class="number">3</span> &#125;, [<span class="string">&quot;abc&quot;</span>]);</span><br><span class="line"><span class="title function_">mapToArrayJson</span>(myMap);</span><br><span class="line"><span class="comment">// &#x27;[[true,7],[&#123;&quot;foo&quot;:3&#125;,[&quot;abc&quot;]]]&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>（6）JSON 转为 Map</strong></p><p><code>JSON</code> 转为 <code>Map</code>，正常情况下，所有键名都是字符串。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">objToStrMap</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> strMap = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> k <span class="keyword">of</span> <span class="title class_">Object</span>.<span class="title function_">keys</span>(obj)) &#123;</span><br><span class="line">    strMap.<span class="title function_">set</span>(k, obj[k]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> strMap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">jsonToStrMap</span>(<span class="params">jsonStr</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">objToStrMap</span>(<span class="title class_">JSON</span>.<span class="title function_">parse</span>(jsonStr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">jsonToStrMap</span>(<span class="string">&#x27;&#123;&quot;yes&quot;: true, &quot;no&quot;: false&#125;&#x27;</span>);</span><br><span class="line"><span class="comment">// Map &#123;&#x27;yes&#x27; =&gt; true, &#x27;no&#x27; =&gt; false&#125;</span></span><br></pre></td></tr></table></figure><p>如果整个 <code>JSON</code> 就是一个数组，且每个数组成员本身，又是一个有两个成员的数组。这时，它可以直接转为 <code>Map</code>。（类似 <code>Map</code> 转为数组 <code>JSON</code> 的逆操作）<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">jsonToMap</span>(<span class="params">jsonStr</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Map</span>(<span class="title class_">JSON</span>.<span class="title function_">parse</span>(jsonStr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">jsonToMap</span>(<span class="string">&#x27;[[true,7],[&#123;&quot;foo&quot;:3&#125;,[&quot;abc&quot;]]]&#x27;</span>);</span><br><span class="line"><span class="comment">// Map &#123;true =&gt; 7, Object &#123;foo: 3&#125; =&gt; [&#x27;abc&#x27;]&#125;</span></span><br></pre></td></tr></table></figure><hr><h2 id="14-Proxy"><a href="#14-Proxy" class="headerlink" title="14. Proxy"></a>14. Proxy</h2><p><a href="https://es6.ruanyifeng.com/#docs/proxy">本章</a>内容复杂，故先跳过一部分。</p><h3 id="14-1-Proxy-概述"><a href="#14-1-Proxy-概述" class="headerlink" title="14.1 Proxy 概述"></a>14.1 Proxy 概述</h3><p><code>Proxy</code> 可以理解成，<ins>在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写</ins>。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> <span class="title class_">Proxy</span>(</span><br><span class="line">  &#123;&#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">get</span>: <span class="keyword">function</span> (<span class="params">target, propKey, receiver</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`getting <span class="subst">$&#123;propKey&#125;</span>!`</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, propKey, receiver);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">set</span>: <span class="keyword">function</span> (<span class="params">target, propKey, value, receiver</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`setting <span class="subst">$&#123;propKey&#125;</span>!`</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">set</span>(target, propKey, value, receiver);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>上面代码对一个空对象架设了一层拦截，重定义了属性的读取<code>get</code>和设置<code>set</code>行为。对设置了拦截行为的对象<code>obj</code>读写它的属性，就会得到下面的结果。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">obj.<span class="property">count</span> = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//  setting count!</span></span><br><span class="line">++obj.<span class="property">count</span>;</span><br><span class="line"><span class="comment">//  getting count!</span></span><br><span class="line"><span class="comment">//  setting count!</span></span><br><span class="line"><span class="comment">//  2</span></span><br></pre></td></tr></table></figure><p>这里可以看出，<code>Proxy</code> 实际上重载<code>overload</code>了点运算符，即用自己的定义覆盖了语言的原始定义。(类似<code>C++</code>的重载)<br><br></p><p><code>ES6</code> 原生提供 <code>Proxy</code> 构造函数，用来生成 <code>Proxy</code> 实例。<code>target</code>参数表示所要拦截的目标对象，<code>handler</code>参数也是一个对象，用来定制拦截行为。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler);</span><br></pre></td></tr></table></figure><p>下面是另一个拦截读取属性行为的例子。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(</span><br><span class="line">  &#123;&#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">get</span>: <span class="keyword">function</span> (<span class="params">target, propKey</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">35</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">proxy.<span class="property">time</span>; <span class="comment">// 35</span></span><br><span class="line">proxy.<span class="property">name</span>; <span class="comment">// 35</span></span><br><span class="line">proxy.<span class="property">title</span>; <span class="comment">// 35</span></span><br></pre></td></tr></table></figure><p>上面代码中，作为构造函数，<code>Proxy</code>接受两个参数。第一个参数是所要代理的目标对象。第二个参数是一个配置对象，对于每一个被代理的操作，需要提供一个对应的处理函数，该函数将拦截对应的操作。<br><br></p><p>注意，要使得<code>Proxy</code>起作用，必须针对<code>Proxy</code>实例进行操作，而不是针对目标对象进行操作。</p><hr><h3 id="14-2-Proxy-的实例方法"><a href="#14-2-Proxy-的实例方法" class="headerlink" title="14.2 Proxy 的实例方法"></a>14.2 Proxy 的实例方法</h3><p><code>Proxy</code> 支持的拦截操作一共 <code>13</code> 种。(剩下的可以在<a href="https://es6.ruanyifeng.com/#docs/proxy#Proxy-%E5%AE%9E%E4%BE%8B%E7%9A%84%E6%96%B9%E6%B3%95">这里</a>找到) <br><br></p><p><code>get()</code>方法用于拦截某个属性的读取操作，可以接受三个参数，依次为目标对象、属性名和 <code>proxy</code> 实例本身。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;张三&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(person, &#123;</span><br><span class="line">  <span class="attr">get</span>: <span class="keyword">function</span> (<span class="params">target, propKey</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (propKey <span class="keyword">in</span> target) &#123;</span><br><span class="line">      <span class="keyword">return</span> target[propKey];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ReferenceError</span>(<span class="string">&#x27;Prop name &quot;&#x27;</span> + propKey + <span class="string">&#x27;&quot; does not exist.&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">proxy.<span class="property">name</span>; <span class="comment">// &quot;张三&quot;</span></span><br><span class="line">proxy.<span class="property">age</span>; <span class="comment">// 抛出一个错误</span></span><br></pre></td></tr></table></figure><p><code>set()</code>方法用来拦截某个属性的赋值操作，可以接受四个参数，依次为目标对象、属性名、属性值和 <code>Proxy</code> 实例本身。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> validator = &#123;</span><br><span class="line">  <span class="attr">set</span>: <span class="keyword">function</span> (<span class="params">obj, prop, value</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (prop === <span class="string">&quot;age&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="title class_">Number</span>.<span class="title function_">isInteger</span>(value)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&quot;The age is not an integer&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (value &gt; <span class="number">200</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RangeError</span>(<span class="string">&quot;The age seems invalid&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对于满足条件的 age 属性以及其他属性，直接保存</span></span><br><span class="line">    obj[prop] = value;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> <span class="title class_">Proxy</span>(&#123;&#125;, validator);</span><br><span class="line">person.<span class="property">age</span> = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">person.<span class="property">age</span>; <span class="comment">// 100</span></span><br><span class="line">person.<span class="property">age</span> = <span class="string">&quot;young&quot;</span>; <span class="comment">// 报错</span></span><br><span class="line">person.<span class="property">age</span> = <span class="number">300</span>; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><hr><h2 id="15-Reflect"><a href="#15-Reflect" class="headerlink" title="15. Reflect"></a>15. Reflect</h2><h3 id="15-1-Reflect-概述"><a href="#15-1-Reflect-概述" class="headerlink" title="15.1 Reflect 概述"></a>15.1 Reflect 概述</h3><p><code>Reflect</code>对象与<code>Proxy</code>对象一样，也是 <code>ES6</code> 为了操作对象而提供的新 <code>API</code>。<code>Reflect</code>对象的设计目的有这样几个。</p><ul><li><p>将<code>Object</code>对象的一些属于语言内部的方法（比如<code>Object.defineProperty</code>），放到<code>Reflect</code>对象上。也就是说，未来可以从<code>Reflect</code>对象上拿到语言内部的方法。</p></li><li><p>修改某些<code>Object</code>方法的返回结果，让其变得更合理。</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 老写法</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(target, property, attributes);</span><br><span class="line">  <span class="comment">// success</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="comment">// 报错</span></span><br><span class="line">  <span class="comment">// failure</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新写法</span></span><br><span class="line"><span class="keyword">if</span> (<span class="title class_">Reflect</span>.<span class="title function_">defineProperty</span>(target, property, attributes)) &#123;</span><br><span class="line">  <span class="comment">// success</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// 直接返回 false</span></span><br><span class="line">  <span class="comment">// failure</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>让<code>Object</code>操作都变成函数行为。比如<code>name in obj</code>和<code>delete obj[name]</code>，而<code>Reflect.has(obj, name)</code>和<code>Reflect.deleteProperty(obj, name)</code>让它们变成了函数行为。</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 老写法</span></span><br><span class="line"><span class="string">&quot;assign&quot;</span> <span class="keyword">in</span> <span class="title class_">Object</span>; <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 新写法</span></span><br><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">has</span>(<span class="title class_">Object</span>, <span class="string">&quot;assign&quot;</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><ul><li>让<code>Reflect</code>对象的方法与<code>Proxy</code>对象的方法对应，只要是<code>Proxy</code>对象的方法，就能在<code>Reflect</code>对象上找到对应的方法。这就让<code>Proxy</code>对象可以方便地调用对应的<code>Reflect</code>方法，完成默认行为，作为修改行为的基础。</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> loggedObj = <span class="keyword">new</span> <span class="title class_">Proxy</span>(obj, &#123;</span><br><span class="line">  <span class="title function_">get</span>(<span class="params">target, name</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;get&quot;</span>, target, name);</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, name);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">deleteProperty</span>(<span class="params">target, name</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;delete&quot;</span> + name);</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">deleteProperty</span>(target, name);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">has</span>(<span class="params">target, name</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;has&quot;</span> + name);</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">has</span>(target, name);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，每一个<code>Proxy</code>对象的拦截操作<code>get</code>、<code>delete</code>、<code>has</code>，内部都调用对应的<code>Reflect</code>方法，保证原生行为能够正常执行。<br><br></p><p>简单来说，有了<code>Reflect</code>对象以后，很多操作会更易读。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 老写法</span></span><br><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">apply</span>.<span class="title function_">call</span>(<span class="title class_">Math</span>.<span class="property">floor</span>, <span class="literal">undefined</span>, [<span class="number">1.75</span>]); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 新写法</span></span><br><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">apply</span>(<span class="title class_">Math</span>.<span class="property">floor</span>, <span class="literal">undefined</span>, [<span class="number">1.75</span>]); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><hr><h3 id="15-2-Reflect-静态方法"><a href="#15-2-Reflect-静态方法" class="headerlink" title="15.2 Reflect 静态方法"></a>15.2 Reflect 静态方法</h3><p><code>Reflect</code>对象也有 <code>13</code> 个静态方法。(剩下的可以在<a href="https://es6.ruanyifeng.com/#docs/reflect#%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95">这里</a>找到) <br><br></p><p><code>Reflect.get</code>方法查找并返回<code>target</code>对象的<code>name</code>属性。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> myObject = &#123;</span><br><span class="line">  <span class="attr">foo</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">bar</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">baz</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">foo</span> + <span class="variable language_">this</span>.<span class="property">bar</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">get</span>(myObject, <span class="string">&quot;foo&quot;</span>); <span class="comment">// 1</span></span><br><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">get</span>(myObject, <span class="string">&quot;bar&quot;</span>); <span class="comment">// 2</span></span><br><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">get</span>(myObject, <span class="string">&quot;baz&quot;</span>); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p><code>Reflect.set</code>方法设置<code>target</code>对象的<code>name</code>属性等于<code>value</code>。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> myObject = &#123;</span><br><span class="line">  <span class="attr">foo</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="keyword">set</span> <span class="title function_">bar</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="variable language_">this</span>.<span class="property">foo</span> = value);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">myObject.<span class="property">foo</span>; <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">set</span>(myObject, <span class="string">&quot;foo&quot;</span>, <span class="number">2</span>);</span><br><span class="line">myObject.<span class="property">foo</span>; <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">set</span>(myObject, <span class="string">&quot;bar&quot;</span>, <span class="number">3</span>);</span><br><span class="line">myObject.<span class="property">foo</span>; <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> ES6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Coding</title>
      <link href="/posts/3458e8f8.html"/>
      <url>/posts/3458e8f8.html</url>
      
        <content type="html"><![CDATA[<h3 id="PriorityQueue-优先队列"><a href="#PriorityQueue-优先队列" class="headerlink" title="PriorityQueue 优先队列"></a><code>PriorityQueue</code> 优先队列</h3><h4 id="第k大的元素"><a href="#第k大的元素" class="headerlink" title="第k大的元素"></a>第<code>k</code>大的元素</h4><blockquote><p><a href="https://leetcode.com/problems/kth-largest-element-in-an-array/">Leetcode 215. Kth Largest Element in an Array</a></p></blockquote><ul><li><code>题目:</code> 给定一个数组<code>nums</code>和一个整数<code>k</code>，输出数组中第<code>k</code>大的元素</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: nums = [3, 2, 1, 5, 6, 4], k = 2</span><br><span class="line">Output: 5</span><br></pre></td></tr></table></figure><ul><li><code>解法:</code> 最小堆 <a href="https://www.geeksforgeeks.org/heap-queue-or-heapq-in-python/">什么是 heap</a></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 初始化一个大小为 k 的最小堆，将前 k 个元素加入堆中</span><br><span class="line">2. 遍历剩余的元素，如果当前元素大于堆顶元素，则替换堆顶</span><br><span class="line">3. 遍历结束后，堆顶即为第 k 大的元素</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findKthLargest</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> k == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">        heap = nums[:k]</span><br><span class="line">        heapq.heapify(heap)  <span class="comment"># 建立最小堆</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums[k:]:</span><br><span class="line">            <span class="keyword">if</span> num &gt; heap[<span class="number">0</span>]:  <span class="comment"># 只在当前元素大于堆顶时替换</span></span><br><span class="line">                heapq.heapreplace(heap, num)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> heap[<span class="number">0</span>] <span class="comment"># 如果是 heap, 那就是返回数组前 k 大的元素</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">findKthLargest</span>(<span class="params">nums, k</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> minPQ = <span class="keyword">new</span> <span class="title class_">MinPriorityQueue</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.<span class="property">length</span>; i++) &#123;</span><br><span class="line">            minPQ.<span class="title function_">enqueue</span>(nums[i]);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (minPQ.<span class="title function_">size</span>() &gt; k)</span><br><span class="line">                minPQ.<span class="title function_">dequeue</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> minPQ.<span class="title function_">front</span>().<span class="property">element</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h4 id="前k个元素的频率"><a href="#前k个元素的频率" class="headerlink" title="前k个元素的频率"></a>前<code>k</code>个元素的频率</h4><blockquote><p><a href="https://leetcode.com/problems/top-k-frequent-elements/">Leetcode 347. Top K Frequent Elements</a></p></blockquote><ul><li><code>题目:</code> 给定一个数组<code>nums</code>和一个整数<code>k</code>，返回数组中出现频率最高的前<code>k</code>个元素</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: nums = [1, 1, 1, 2, 2, 3], k = 2</span><br><span class="line">Output: [1, 2]</span><br></pre></td></tr></table></figure><ul><li><code>解法 1: heapq.nlargest</code> (<code>Python</code>)</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 使用 `Counter` 统计元素出现频率</span><br><span class="line">2. 调用 `heapq.nlargest`，在 O(n + k log n) 时间内找到前 k 大的频率</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">topKFrequent</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums) == k:</span><br><span class="line">            <span class="keyword">return</span> nums</span><br><span class="line"></span><br><span class="line">        count = Counter(nums)</span><br><span class="line">        <span class="keyword">return</span> heapq.nlargest(k, count.keys(), key=count.get)</span><br></pre></td></tr></table></figure><ul><li><code>解法 2:</code> 最小堆</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 统计元素频率，使用堆存储前 k 个高频元素</span><br><span class="line">2. 每次比较当前元素与堆顶的频率，维护堆的大小为 k</span><br><span class="line">3. 最后堆中的元素即为结果</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">topKFrequent</span>(<span class="params">nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="comment"># 1. 统计每个元素的频率</span></span><br><span class="line">        freq_map = Counter(nums)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 2. 使用最小堆找到前 k 个频率最高的元素</span></span><br><span class="line">        heap = []</span><br><span class="line">        <span class="keyword">for</span> num, freq <span class="keyword">in</span> freq_map.items():</span><br><span class="line">            heapq.heappush(heap, (freq, num))  <span class="comment"># 堆中存储 (频率, 元素)</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(heap) &gt; k:</span><br><span class="line">                heapq.heappop(heap)  <span class="comment"># 维持堆的大小为 k</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 3. 提取堆中的元素</span></span><br><span class="line">        <span class="keyword">return</span> [num <span class="keyword">for</span> freq, num <span class="keyword">in</span> heap]</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">topKFrequent</span>(<span class="params">nums, k</span>) &#123;</span><br><span class="line">        <span class="comment">// 1. 统计频率</span></span><br><span class="line">        <span class="keyword">const</span> freqMap = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> num <span class="keyword">of</span> nums)</span><br><span class="line">            freqMap.<span class="title function_">set</span>(num, (freqMap.<span class="title function_">get</span>(num) || <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 使用最小堆</span></span><br><span class="line">        <span class="keyword">const</span> minPQ = <span class="keyword">new</span> <span class="title class_">MinPriorityQueue</span>(&#123; <span class="attr">priority</span>: <span class="function"><span class="params">x</span> =&gt;</span> x[<span class="number">1</span>] &#125;);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> [num, freq] <span class="keyword">of</span> freqMap) &#123;</span><br><span class="line">            minPQ.<span class="title function_">enqueue</span>([num, freq]);</span><br><span class="line">            <span class="keyword">if</span> (minPQ.<span class="title function_">size</span>() &gt; k)</span><br><span class="line">                minPQ.<span class="title function_">dequeue</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 提取堆中的元素</span></span><br><span class="line">        <span class="keyword">return</span> minPQ.<span class="title function_">toArray</span>().<span class="title function_">map</span>(<span class="function"><span class="params">x</span> =&gt;</span> x.<span class="property">element</span>[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><ul><li><code>解法 3:</code> 桶排序</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 统计频率，并将元素按频率存储在“桶”中</span><br><span class="line">2. 桶的索引表示频率，从高到低提取前 k 个元素</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">topKFrequent</span>(<span class="params">nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="comment"># 1. 统计频率</span></span><br><span class="line">        freq_map = Counter(nums)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 2. 桶排序</span></span><br><span class="line">        bucket = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums) + <span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> num, freq <span class="keyword">in</span> freq_map.items():</span><br><span class="line">            bucket[freq].append(num) <span class="comment"># 将元素按频率存储在对应桶中</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 3. 从高频到低频提取前 k 个元素</span></span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(bucket) - <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> num <span class="keyword">in</span> bucket[i]:</span><br><span class="line">                result.append(num)</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">len</span>(result) == k:</span><br><span class="line">                    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">topKFrequent</span>(<span class="params">nums, k</span>) &#123;</span><br><span class="line">        <span class="comment">// 1. 统计频率</span></span><br><span class="line">        <span class="keyword">const</span> freqMap = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> num <span class="keyword">of</span> nums)</span><br><span class="line">            freqMap.<span class="title function_">set</span>(num, (freqMap.<span class="title function_">get</span>(num) || <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 桶排序</span></span><br><span class="line">        <span class="keyword">const</span> bucket = <span class="title class_">Array</span>(nums.<span class="property">length</span> + <span class="number">1</span>).<span class="title function_">fill</span>(<span class="literal">null</span>).<span class="title function_">map</span>(<span class="function">() =&gt;</span> []);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> [num, freq] <span class="keyword">of</span> freqMap)</span><br><span class="line">            bucket[freq].<span class="title function_">push</span>(num);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 从高频到低频提取前 k 个元素</span></span><br><span class="line">        <span class="keyword">const</span> result = [];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = bucket.<span class="property">length</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; result.<span class="property">length</span> &lt; k; i--)</span><br><span class="line">            result.<span class="title function_">push</span>(...bucket[i]);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><blockquote><p><code>最小堆</code>: 更灵活，可以适应动态输入数据，适合<code>k</code>较小的情况<br><code>桶排序</code>: 更高效，尤其是当<code>k</code>较大或频率分布较均匀时</p></blockquote><hr><h3 id="Design"><a href="#Design" class="headerlink" title="Design"></a><code>Design</code></h3><h4 id="LRU-缓存"><a href="#LRU-缓存" class="headerlink" title="LRU 缓存"></a><code>LRU</code> 缓存</h4><blockquote><p><a href="https://leetcode.com/problems/lru-cache/">Leetcode 146. LRU Cache</a></p></blockquote><ul><li><p><code>题目:</code> 实现一个数据结构<code>LRU Cache (Least Recently Used Cache)</code>，它能够在固定容量下缓存键值对，同时满足以下两种操作</p><ul><li><code>get(key)</code>: 如果键存在，返回其值，并将该键标记为最近使用。如果不存在，返回<code>-1</code></li><li><code>put(key, value)</code>: 插入新键值对。如果缓存已满，移除最久未使用的键值对</li></ul></li><li><p><code>解法 1: OrderedDict</code> (<code>Python</code>)</p><ul><li><code>Python</code>中的<code>OrderedDict</code>可以非常直观地实现<code>LRU Cache</code></li><li><code>OrderedDict</code>自动维护插入顺序，最久未使用的元素总在最前面</li><li>提供了<code>move_to_end(key)</code>方法，可以将某个键移动到末尾，表示最近使用</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">get 方法</span><br><span class="line">    如果键存在，将其移到末尾，表示最近使用，并返回对应值</span><br><span class="line">    如果键不存在，返回 -1</span><br><span class="line"></span><br><span class="line">put 方法</span><br><span class="line">    如果键存在，更新值并移到末尾</span><br><span class="line">    如果键不存在，直接添加</span><br><span class="line">    如果缓存超出容量，删除最前面的键（popitem(last=False)）</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> OrderedDict</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, capacity: <span class="built_in">int</span></span>):</span><br><span class="line">        self.cache = OrderedDict() <span class="comment"># 创建一个有序字典</span></span><br><span class="line">        self.capacity = capacity</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">self, key: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">in</span> self.cache:</span><br><span class="line">            <span class="comment"># 将访问的键移到末尾</span></span><br><span class="line">            self.cache.move_to_end(key)</span><br><span class="line">            <span class="keyword">return</span> self.cache[key]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">put</span>(<span class="params">self, key: <span class="built_in">int</span>, value: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">in</span> self.cache:</span><br><span class="line">            <span class="comment"># 如果键已经存在，更新值，并移到末尾</span></span><br><span class="line">            self.cache.move_to_end(key)</span><br><span class="line"></span><br><span class="line">        self.cache[key] = value</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self.cache) &gt; self.capacity:</span><br><span class="line">            <span class="comment"># 超过容量时，删除第一个键（最久未使用）</span></span><br><span class="line">            self.cache.popitem(last=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><ul><li><code>解法 2: Map</code> (<code>Javascript</code>)<ul><li><code>JS</code>的<code>Map</code>数据结构，它按插入顺序存储键值对</li><li>使用<code>set(key, value)</code>方法更新键时，会将该键移到末尾，表示最近使用</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">get 方法</span><br><span class="line">    如果键存在，先删除它，再重新插入到末尾</span><br><span class="line">    如果键不存在，返回 -1</span><br><span class="line"></span><br><span class="line">put 方法</span><br><span class="line">    如果键已存在，先删除它，再插入新值</span><br><span class="line">    如果超过容量，删除最老的键（Map.keys().next().value 返回第一个键）</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">capacity</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">capacity</span> = capacity;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">cache</span> = <span class="keyword">new</span> <span class="title class_">Map</span>(); <span class="comment">// Map 是有序的，按插入顺序维护键值对</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">get</span>(<span class="params">key</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">cache</span>.<span class="title function_">has</span>(key)) <span class="keyword">return</span> -<span class="number">1</span>; </span><br><span class="line">        <span class="keyword">const</span> value = <span class="variable language_">this</span>.<span class="property">cache</span>.<span class="title function_">get</span>(key);</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">cache</span>.<span class="title function_">delete</span>(key); <span class="comment">// 删除旧位置的键</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">cache</span>.<span class="title function_">set</span>(key, value); <span class="comment">// 将键移到末尾（最新使用）</span></span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">put</span>(<span class="params">key, value</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">cache</span>.<span class="title function_">has</span>(key))</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">cache</span>.<span class="title function_">delete</span>(key); <span class="comment">// 如果键已存在，先删除它</span></span><br><span class="line"></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">cache</span>.<span class="title function_">set</span>(key, value); <span class="comment">// 插入新键值对</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">cache</span>.<span class="property">size</span> &gt; <span class="variable language_">this</span>.<span class="property">capacity</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> oldestKey = <span class="variable language_">this</span>.<span class="property">cache</span>.<span class="title function_">keys</span>().<span class="title function_">next</span>().<span class="property">value</span>; <span class="comment">// 获取最老的键</span></span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">cache</span>.<span class="title function_">delete</span>(oldestKey);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="实现随机集合"><a href="#实现随机集合" class="headerlink" title="实现随机集合"></a>实现随机集合</h4><blockquote><p><a href="https://leetcode.com/problems/insert-delete-getrandom-o1/">Leetcode 380. Insert Delete GetRandom O(1)</a></p></blockquote><ul><li><code>题目:</code> 设计一个支持以下操作的集合，在平均时间复杂度为<code>O(1)</code>下实现插入、删除和随机获取操作<ul><li><code>insert(val)</code>: 如果集合中没有该值，则插入</li><li><code>remove(val)</code>: 如果集合中存在该值</li><li><code>getRandom()</code>: 随机返回集合中的一个元素，每个元素被返回的概率相等</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input</span><br><span class="line">[&quot;RandomizedSet&quot;, &quot;insert&quot;, &quot;remove&quot;, &quot;insert&quot;, &quot;getRandom&quot;, &quot;remove&quot;, &quot;insert&quot;, &quot;getRandom&quot;]</span><br><span class="line">[[], [1], [2], [2], [], [1], [2], []]</span><br><span class="line">Output</span><br><span class="line">[null, true, false, true, 2, true, false, 2]</span><br></pre></td></tr></table></figure><ul><li><code>解法:</code> 数组 + 哈希表</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 数组存储集合的元素，用于随机访问</span><br><span class="line">2. 哈希表记录每个值在数组中的索引，方便 O(1) 时间查找和删除</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RandomizedSet</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.<span class="built_in">dict</span> = &#123;&#125;</span><br><span class="line">        self.<span class="built_in">list</span> = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">insert</span>(<span class="params">self, val: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">if</span> val <span class="keyword">in</span> self.<span class="built_in">dict</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        self.<span class="built_in">dict</span>[val] = <span class="built_in">len</span>(self.<span class="built_in">list</span>) <span class="comment"># 记录值的索引</span></span><br><span class="line">        self.<span class="built_in">list</span>.append(val) <span class="comment"># 将值添加到列表</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">remove</span>(<span class="params">self, val: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">if</span> val <span class="keyword">not</span> <span class="keyword">in</span> self.<span class="built_in">dict</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        idx = self.<span class="built_in">dict</span>[val] <span class="comment"># 获取值的索引</span></span><br><span class="line">        last = self.<span class="built_in">list</span>[-<span class="number">1</span>] <span class="comment"># 获取列表中的最后一个元素</span></span><br><span class="line"></span><br><span class="line">        self.<span class="built_in">list</span>[idx] = last <span class="comment"># 将最后一个元素移到被移除的位置</span></span><br><span class="line">        self.<span class="built_in">dict</span>[last] = idx <span class="comment"># 更新最后一个元素的索引</span></span><br><span class="line"></span><br><span class="line">        self.<span class="built_in">list</span>.pop() <span class="comment"># 删除最后一个元素</span></span><br><span class="line">        <span class="keyword">del</span> self.<span class="built_in">dict</span>[val] <span class="comment"># 从字典中删除该值</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getRandom</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">return</span> random.choice(self.<span class="built_in">list</span>) <span class="comment"># 随机选择一个列表中的值</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">map</span> = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">list</span> = [];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">insert</span>(<span class="params">val</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">map</span>.<span class="title function_">has</span>(val)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">map</span>.<span class="title function_">set</span>(val, <span class="variable language_">this</span>.<span class="property">list</span>.<span class="property">length</span>); <span class="comment">// 存储值和索引</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">list</span>.<span class="title function_">push</span>(val); <span class="comment">// 将值添加到数组</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">remove</span>(<span class="params">val</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">map</span>.<span class="title function_">has</span>(val)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> idx = <span class="variable language_">this</span>.<span class="property">map</span>.<span class="title function_">get</span>(val); <span class="comment">// 获取值的索引</span></span><br><span class="line">        <span class="keyword">const</span> last = <span class="variable language_">this</span>.<span class="property">list</span>[<span class="variable language_">this</span>.<span class="property">list</span>.<span class="property">length</span> - <span class="number">1</span>]; <span class="comment">// 获取最后一个值</span></span><br><span class="line"></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">list</span>[idx] = last; <span class="comment">// 将最后一个值移到被删除的位置</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">map</span>.<span class="title function_">set</span>(last, idx); <span class="comment">// 更新最后一个值的索引</span></span><br><span class="line"></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">list</span>.<span class="title function_">pop</span>(); <span class="comment">// 删除最后一个值</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">map</span>.<span class="title function_">delete</span>(val); <span class="comment">// 从映射中删除该值</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">getRandom</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> randomIndex = <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="variable language_">this</span>.<span class="property">list</span>.<span class="property">length</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">list</span>[randomIndex];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h3 id="LinkedList-链表"><a href="#LinkedList-链表" class="headerlink" title="LinkedList 链表"></a><code>LinkedList</code> 链表</h3><h4 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h4><blockquote><p><a href="https://leetcode.com/problems/reverse-linked-list/">Leetcode 206. Reverse Linked List</a></p></blockquote><ul><li><code>题目:</code> 给定一个单链表的头节点<code>head</code>，将其完全反转，并返回新的头节点</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: head = [0,1,2,3]</span><br><span class="line">Output: [3,2,1,0]</span><br></pre></td></tr></table></figure><ul><li><code>解法: Two Pointers</code> 双指针</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 初始化两个指针：prev 表示前一个节点，curr 表示当前节点</span><br><span class="line">2. 遍历链表，逐个调整当前节点的指向，使其指向前一个节点</span><br><span class="line">3. 移动指针，直到链表尾部</span><br><span class="line">4. 返回 prev 作为新的头节点</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseList</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        prev = <span class="literal">None</span></span><br><span class="line">        curr = head</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> curr:</span><br><span class="line">            next_node = curr.<span class="built_in">next</span> <span class="comment"># 暂存下一个节点</span></span><br><span class="line">            curr.<span class="built_in">next</span> = prev <span class="comment"># 当前节点指向前一个节点</span></span><br><span class="line">            prev = curr <span class="comment"># prev 向前移动到当前节点</span></span><br><span class="line">            curr = next_node <span class="comment"># curr 向前移动到下一个节点</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> prev   </span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">reverseList</span>(<span class="params">head</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> prev = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">let</span> curr = head;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (curr) &#123;</span><br><span class="line">            <span class="keyword">let</span> nextNode = curr.<span class="property">next</span>; <span class="comment">// 暂存下一个节点</span></span><br><span class="line">            curr.<span class="property">next</span> = prev; <span class="comment">// 当前节点指向前一个节点</span></span><br><span class="line">            prev = curr; <span class="comment">// prev 向前移动到当前节点</span></span><br><span class="line">            curr = nextNode; <span class="comment">// curr 向前移动到下一个节点</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h4 id="反转链表中间部分"><a href="#反转链表中间部分" class="headerlink" title="反转链表中间部分"></a>反转链表中间部分</h4><blockquote><p><a href="https://leetcode.com/problems/reverse-linked-list-ii/">Leetcode 92. Reverse Linked List II</a></p></blockquote><ul><li><code>题目:</code> 给定一个单链表的头节点<code>head</code>，以及两个整数<code>left</code>和<code>right</code>，反转链表中从位置<code>left</code>到位置<code>right</code>的部分，并返回链表的头节点</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: head = [1,2,3,4,5], left = 2, right = 4</span><br><span class="line">Output: [1,4,3,2,5]</span><br></pre></td></tr></table></figure><ul><li><code>解法:</code> 虚拟头节点法</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 添加虚拟头节点：用于处理从链表头部开始反转的特殊情况</span><br><span class="line">2. 找到 left 的前驱节点 prev 和要反转的第一个节点 curr</span><br><span class="line">3. 遍历从 left 到 right 的链表部分，逐个将当前节点插入到子链表的头部</span><br><span class="line">4. 返回链表的新头节点</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseBetween</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode], left: <span class="built_in">int</span>, right: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        dummy = ListNode(<span class="number">0</span>, head)</span><br><span class="line">        prev = dummy</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 1. 找到 left 的前驱节点（prev）和 left 节点（curr）</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(left - <span class="number">1</span>):</span><br><span class="line">            prev = prev.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        curr = prev.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 2. 反转 [left, right] 之间的节点</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(right - left):</span><br><span class="line">            next_node = curr.<span class="built_in">next</span> <span class="comment"># 暂存当前节点的 next</span></span><br><span class="line">            curr.<span class="built_in">next</span> = next_node.<span class="built_in">next</span> <span class="comment"># 当前节点指向 next 的 next</span></span><br><span class="line">            next_node.<span class="built_in">next</span> = prev.<span class="built_in">next</span> <span class="comment"># 插入到子链表头部</span></span><br><span class="line">            prev.<span class="built_in">next</span> = next_node <span class="comment"># 更新 prev 的 next</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">reverseBetween</span>(<span class="params">head, left, right</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> dummy = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>, head);</span><br><span class="line">        <span class="keyword">let</span> prev = dummy;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 找到 left 的前驱节点（prev）和 left 节点（curr）</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; left; i++)</span><br><span class="line">            prev = prev.<span class="property">next</span>;</span><br><span class="line"></span><br><span class="line">        curr = prev.<span class="property">next</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 反转 [left, right] 之间的节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; right - left; i++) &#123;</span><br><span class="line">            <span class="keyword">const</span> nextNode = curr.<span class="property">next</span>;</span><br><span class="line">            curr.<span class="property">next</span> = nextNode.<span class="property">next</span>;</span><br><span class="line">            nextNode.<span class="property">next</span> = prev.<span class="property">next</span>;</span><br><span class="line">            prev.<span class="property">next</span> = nextNode;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><ul><li>例子，反转链表<code>1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5</code> 第<code>2</code>个节点到第<code>4</code>个节点</li></ul><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Step 1</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Step 2</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img221705.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img221721.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h4 id="合成链表"><a href="#合成链表" class="headerlink" title="合成链表"></a>合成链表</h4><blockquote><p><a href="https://leetcode.com/problems/merge-two-sorted-lists/">Leetcode 21. Merge Two Sorted Lists</a></p></blockquote><ul><li><code>题目:</code> 给定两个单链表<code>list1</code>和<code>list2</code>，它们的元素按升序排列。将它们合并为一个新的链表，要求新链表也按照升序排列，并返回新链表的头节点</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: list1 = [1,2,4], list2 = [1,3,5]</span><br><span class="line">Output: [1,1,2,3,4,5]</span><br></pre></td></tr></table></figure><ul><li><code>解法:</code> 虚拟头节点法</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 使用一个虚拟头节点 dummy 来简化链表连接逻辑</span><br><span class="line">2. 遍历 list1 和 list2，逐步比较它们的节点值，将较小的节点连接到结果链表中</span><br><span class="line">3. 当一个链表遍历完成后，将另一个链表剩余的节点直接连接到结果链表</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">mergeTwoLists</span>(<span class="params">self, list1: <span class="type">Optional</span>[ListNode], list2: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        dummy = ListNode()</span><br><span class="line">        curr = dummy</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 遍历两个链表，比较节点值</span></span><br><span class="line">        <span class="keyword">while</span> list1 <span class="keyword">and</span> list2:</span><br><span class="line">            <span class="keyword">if</span> list1.val &lt; list2.val:</span><br><span class="line">                curr.<span class="built_in">next</span> = list1</span><br><span class="line">                list1 = list1.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                curr.<span class="built_in">next</span> = list2</span><br><span class="line">                list2 = list2.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">            curr = curr.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 连接剩余的节点</span></span><br><span class="line">        curr.<span class="built_in">next</span> = list1 <span class="keyword">or</span> list2</span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">mergeTwoLists</span>(<span class="params">list1, list2</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> dummy = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">let</span> curr = dummt;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历两个链表，比较节点值</span></span><br><span class="line">        <span class="keyword">while</span> (list1 !== <span class="literal">null</span> &amp;&amp; list2 !== <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (list1.<span class="property">val</span> &lt; list2.<span class="property">val</span>) &#123;</span><br><span class="line">                curr.<span class="property">next</span> = list1;</span><br><span class="line">                list1 = list1.<span class="property">next</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                curr.<span class="property">next</span> = list2;</span><br><span class="line">                list2 = list2.<span class="property">next</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            curr = curr.<span class="property">next</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 连接剩余的节点</span></span><br><span class="line">        curr.<span class="property">next</span> = list1 || list2;</span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h4 id="k个一组翻转链表"><a href="#k个一组翻转链表" class="headerlink" title="k个一组翻转链表"></a><code>k</code>个一组翻转链表</h4><blockquote><p><a href="https://leetcode.com/problems/reverse-nodes-in-k-group/">Leetcode 25. Reverse Nodes in k-Group</a></p></blockquote><ul><li><code>题目:</code> 给定一个单链表的头节点<code>head</code>和一个整数<code>k</code>，将链表按照每<code>k</code>个节点为一组进行翻转。如果剩余节点不足 <code>k</code>个，则保持原样。要求返回翻转后的链表</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: head = [1,2,3,4,5,6], k = 3</span><br><span class="line">Output: [3,2,1,6,5,4]</span><br></pre></td></tr></table></figure><ul><li><code>解法:</code> 按组翻转 + 双指针</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 遍历链表并按 k 个节点为一组分割</span><br><span class="line">2. 对每组节点执行翻转操作</span><br><span class="line">3. 翻转后的部分与链表的其他部分正确连接</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseKGroup</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode], k: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        dummy = ListNode(<span class="number">0</span>, head)</span><br><span class="line">        group_prev = dummy</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="comment"># 找到当前组的第 k 个节点</span></span><br><span class="line">            kth = self.getKthNode(group_prev, k)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> kth:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            group_next = kth.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 反转当前组的节点</span></span><br><span class="line">            prev, curr = group_next, group_prev.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">while</span> curr != group_next:</span><br><span class="line">                next_node = curr.<span class="built_in">next</span></span><br><span class="line">                curr.<span class="built_in">next</span> = prev</span><br><span class="line">                prev = curr</span><br><span class="line">                curr = next_node</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 处理连接：将反转后的部分与链表其余部分连接起来</span></span><br><span class="line">            next_node = group_prev.<span class="built_in">next</span></span><br><span class="line">            group_prev.<span class="built_in">next</span> = kth</span><br><span class="line">            group_prev = next_node</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getKthNode</span>(<span class="params">self, node, k</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        <span class="keyword">while</span> node <span class="keyword">and</span> k &gt; <span class="number">0</span>:</span><br><span class="line">            node = node.<span class="built_in">next</span></span><br><span class="line">            k -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> node</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">reverseKGroup</span>(<span class="params">head, k</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> dummy = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>, head);</span><br><span class="line">        <span class="keyword">let</span> groupPrev = dummy;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 找到当前组的第 k 个节点</span></span><br><span class="line">            <span class="keyword">const</span> kth = <span class="variable language_">this</span>.<span class="title function_">getKthNode</span>(groupPrev, k);</span><br><span class="line">            <span class="keyword">if</span> (!kth) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">const</span> groupNext = kth.<span class="property">next</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 反转当前组的节点</span></span><br><span class="line">            <span class="keyword">let</span> prev = groupNext;</span><br><span class="line">            <span class="keyword">let</span> curr = groupPrev.<span class="property">next</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (curr !== groupNext) &#123;</span><br><span class="line">                <span class="keyword">const</span> nextNode = curr.<span class="property">next</span>;</span><br><span class="line">                curr.<span class="property">next</span> = prev;</span><br><span class="line">                prev = curr;</span><br><span class="line">                curr = nextNode;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 处理连接</span></span><br><span class="line">            <span class="keyword">const</span> nextNode = groupPrev.<span class="property">next</span>;</span><br><span class="line">            groupPrev.<span class="property">next</span> = kth;</span><br><span class="line">            groupPrev = nextNode;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">getKthNode</span>(<span class="params">node, k</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (node &amp;&amp; k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            node = node.<span class="property">next</span>;</span><br><span class="line">            k--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h4 id="成对反转链表节点"><a href="#成对反转链表节点" class="headerlink" title="成对反转链表节点"></a>成对反转链表节点</h4><blockquote><p><a href="https://leetcode.com/problems/swap-nodes-in-pairs/">Leetcode 24. Swap Nodes in Pairs</a></p></blockquote><ul><li><code>题目:</code> 给定一个单链表的头节点<code>head</code>，将链表中的节点两两交换，并返回交换后的链表。如果链表节点数是奇数，最后一个节点保持不变</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: head = [1,2,3,4]</span><br><span class="line">Output: [2,1,4,3]</span><br></pre></td></tr></table></figure><ul><li><code>解法:</code> 虚拟头节点法</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 使用一个虚拟头节点 dummy，便于操作头节点及其后的节点</span><br><span class="line">2. 每次取出两个相邻节点，将它们交换</span><br><span class="line">3. 正确调整指针以保持链表的顺序</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">swapPairs</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        dummy = ListNode(<span class="number">0</span>, head)</span><br><span class="line">        prev = dummy</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> head <span class="keyword">and</span> head.<span class="built_in">next</span>:</span><br><span class="line">            <span class="comment"># 要交换的两个节点</span></span><br><span class="line">            first = head</span><br><span class="line">            second = head.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 交换节点</span></span><br><span class="line">            prev.<span class="built_in">next</span> = second</span><br><span class="line">            first.<span class="built_in">next</span> = second.<span class="built_in">next</span></span><br><span class="line">            second.<span class="built_in">next</span> = first</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 移动指针准备下一组交换</span></span><br><span class="line">            prev = first</span><br><span class="line">            head = first.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">swapPairs</span>(<span class="params">head</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> dummy = <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        dummy.<span class="property">next</span> = head;</span><br><span class="line">        <span class="keyword">let</span> prev = dummy;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (head &amp;&amp; head.<span class="property">next</span>) &#123;</span><br><span class="line">            <span class="comment">// 要交换的两个节点</span></span><br><span class="line">            <span class="keyword">const</span> first = head;</span><br><span class="line">            <span class="keyword">const</span> second = head.<span class="property">next</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 交换节点</span></span><br><span class="line">            prev.<span class="property">next</span> = second;</span><br><span class="line">            first.<span class="property">next</span> = second.<span class="property">next</span>;</span><br><span class="line">            second.<span class="property">next</span> = first;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 移动指针准备下一组交换</span></span><br><span class="line">            prev = first;</span><br><span class="line">            head = first.<span class="property">next</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h4 id="对折链表"><a href="#对折链表" class="headerlink" title="对折链表"></a>对折链表</h4><blockquote><p><a href="https://leetcode.com/problems/reorder-list/">Leetcode 143. Reorder List</a></p></blockquote><ul><li><code>题目:</code> 给定一个单链表<code>head</code>，要求在原地修改链表，不使用额外的空间, 将其重新排序为<ul><li>原链表的第一个节点 -&gt; 最后一个节点 -&gt; 第二个节点 -&gt; 倒数第二个节点 -&gt;</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: head = [1,2,3,4,5]</span><br><span class="line">Output: [1,5,2,4,3]</span><br></pre></td></tr></table></figure><ul><li><code>解法:</code> 快慢指针 + 反转链表 + 合并链表</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 找到链表中点</span><br><span class="line">   - 使用快慢指针，快指针每次移动两步，慢指针每次移动一步，当快指针到达末尾时，慢指针指向中点</span><br><span class="line">2. 反转链表后半部分</span><br><span class="line">   - 将链表从中点分成两部分，反转后半部分链表</span><br><span class="line">3. 合并链表</span><br><span class="line">   - 按顺序交替连接前半部分和反转后的后半部分链表</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reorderList</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify head in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 1. 使用快慢指针找到链表中点</span></span><br><span class="line">        slow, fast = head, head.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> fast <span class="keyword">and</span> fast.<span class="built_in">next</span>:</span><br><span class="line">            slow = slow.<span class="built_in">next</span></span><br><span class="line">            fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 2. 反转链表的后半部分</span></span><br><span class="line">        curr = slow.<span class="built_in">next</span></span><br><span class="line">        prev = <span class="literal">None</span></span><br><span class="line">        slow.<span class="built_in">next</span> = <span class="literal">None</span> <span class="comment"># 切断前半部分和后半部分链表的连接</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> curr:</span><br><span class="line">            next_node = curr.<span class="built_in">next</span></span><br><span class="line">            second.<span class="built_in">next</span> = prev</span><br><span class="line">            prev = curr</span><br><span class="line">            curr = next_node</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 3. 合并链表</span></span><br><span class="line">        first, second = head, prev <span class="comment"># first 是前半部分的链表头，second 是反转后的后半部分链表头</span></span><br><span class="line">        <span class="keyword">while</span> second:</span><br><span class="line">            tmp1, tmp2 = first.<span class="built_in">next</span>, second.<span class="built_in">next</span></span><br><span class="line">            first.<span class="built_in">next</span> = second</span><br><span class="line">            second.<span class="built_in">next</span> = tmp1</span><br><span class="line">            first, second = tmp1, tmp2</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">reorderList</span>(<span class="params">head</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!head || !head.<span class="property">next</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 使用快慢指针找到链表中点</span></span><br><span class="line">        <span class="keyword">let</span> slow = head, fast = head.<span class="property">next</span>;</span><br><span class="line">        <span class="keyword">while</span> (fast &amp;&amp; fast.<span class="property">next</span>) &#123;</span><br><span class="line">            slow = slow.<span class="property">next</span>;</span><br><span class="line">            fast = fast.<span class="property">next</span>.<span class="property">next</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 反转链表的后半部分</span></span><br><span class="line">        <span class="keyword">let</span> curr = slow.<span class="property">next</span>;</span><br><span class="line">        <span class="keyword">let</span> prev = <span class="literal">null</span>;</span><br><span class="line">        slow.<span class="property">next</span> = <span class="literal">null</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (curr) &#123;</span><br><span class="line">            <span class="keyword">const</span> nextNode = curr.<span class="property">next</span>;</span><br><span class="line">            curr.<span class="property">next</span> = prev;</span><br><span class="line">            prev = curr;</span><br><span class="line">            curr = nextNode;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 合并链表</span></span><br><span class="line">        <span class="keyword">let</span> first = head, second = prev;</span><br><span class="line">        <span class="keyword">while</span> (second) &#123;</span><br><span class="line">            <span class="keyword">let</span> tmp1 = first.<span class="property">next</span>, tmp2 = second.<span class="property">next</span>;</span><br><span class="line">            first.<span class="property">next</span> = second;</span><br><span class="line">            second.<span class="property">next</span> = tmp1;</span><br><span class="line">            first = tmp1, second = tmp2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h4 id="删除有序链表重复元素"><a href="#删除有序链表重复元素" class="headerlink" title="删除有序链表重复元素"></a>删除有序链表重复元素</h4><blockquote><p><a href="https://leetcode.com/problems/remove-duplicates-from-sorted-list/">Leetcode 83. Remove Duplicates from Sorted List</a></p></blockquote><ul><li><code>题目:</code> 从一个升序排列的链表中，删除所有重复的节点，确保每个值只出现一次</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: head = [1,1,2,3,3]</span><br><span class="line">Output: [1,2,3]</span><br></pre></td></tr></table></figure><ul><li><code>解法:</code> 遍历链表</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 从链表头开始，依次检查当前节点和下一个节点的值</span><br><span class="line">2. 如果当前节点值和下一个节点值相同，则跳过下一个节点</span><br><span class="line">3. 如果值不同，则移动指针到下一个节点</span><br><span class="line">4. 重复上述过程，直到遍历完整个链表</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">deleteDuplicates</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        curr = head</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> curr <span class="keyword">and</span> curr.<span class="built_in">next</span>:</span><br><span class="line">            next_node = curr.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">if</span> curr.val == next_node.val: <span class="comment"># 如果当前值等于下一个值</span></span><br><span class="line">                curr.<span class="built_in">next</span> = next_node.<span class="built_in">next</span> <span class="comment"># 跳过下一个节点</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                curr = curr.<span class="built_in">next</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">deleteDuplicates</span>(<span class="params">head</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> curr = head;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (curr &amp;&amp; curr.<span class="property">next</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> nextNode = curr.<span class="property">next</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (curr.<span class="property">val</span> === nextNode.<span class="property">val</span>) </span><br><span class="line">                curr.<span class="property">next</span> = nextNode.<span class="property">next</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                curr = curr.<span class="property">next</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h4 id="删除有序链表所有重复元素"><a href="#删除有序链表所有重复元素" class="headerlink" title="删除有序链表所有重复元素"></a>删除有序链表所有重复元素</h4><blockquote><p><a href="https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/">Leetcode 82. Remove Duplicates from Sorted List II</a></p></blockquote><ul><li><code>题目:</code> 从一个升序排列的链表中，删除所有出现次数超过<code>1</code>次的节点，仅保留没有重复的节点</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: head = [1,2,3,3,4,4,5]</span><br><span class="line">Output: [1,2,5]</span><br></pre></td></tr></table></figure><ul><li><code>解法:</code> 双指针 + 虚拟头节点</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 创建虚拟头节点 dummy，以处理可能需要删除头节点的情况</span><br><span class="line">2. 定义两个指针：</span><br><span class="line">    - prev：指向最后一个不重复的节点</span><br><span class="line">    - curr：用于遍历链表</span><br><span class="line">3. 遍历链表：</span><br><span class="line">    - 如果 curr 和 curr.next 的值相同，跳过所有重复的节点</span><br><span class="line">    - 如果没有重复，移动 prev 指针到当前节点</span><br><span class="line">4. 返回虚拟头节点的下一个节点</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">deleteDuplicates</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        dummy = ListNode(<span class="number">0</span>, head)</span><br><span class="line">        prev, curr = dummy, head</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> curr:</span><br><span class="line">            <span class="comment"># 如果当前节点的值与下一个节点的值相同</span></span><br><span class="line">            <span class="keyword">if</span> curr.<span class="built_in">next</span> <span class="keyword">and</span> curr.val == curr.<span class="built_in">next</span>.val:</span><br><span class="line">                <span class="comment"># 跳过所有值相同的节点</span></span><br><span class="line">                <span class="keyword">while</span> curr.<span class="built_in">next</span> <span class="keyword">and</span> curr.val == curr.<span class="built_in">next</span>.val:</span><br><span class="line">                    curr = curr.<span class="built_in">next</span></span><br><span class="line">                <span class="comment"># 将 prev 的 next 指向下一个不重复的节点</span></span><br><span class="line">                prev.<span class="built_in">next</span> = curr.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 如果没有重复，移动 prev 指针</span></span><br><span class="line">                prev = prev.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 移动 curr 指针</span></span><br><span class="line">            curr = curr.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">deleteDuplicates</span>(<span class="params">head</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> dummy = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>, head);</span><br><span class="line">        <span class="keyword">let</span> prev = dummy, curr = head;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (curr) &#123;</span><br><span class="line">            <span class="comment">// 如果当前节点的值与下一个节点的值相同</span></span><br><span class="line">            <span class="keyword">if</span> (curr.<span class="property">next</span> &amp;&amp; curr.<span class="property">val</span> === curr.<span class="property">next</span>.<span class="property">val</span>) &#123;</span><br><span class="line">                <span class="comment">// 跳过所有值相同的节点</span></span><br><span class="line">                <span class="keyword">while</span> (curr.<span class="property">next</span> &amp;&amp; curr.<span class="property">val</span> === curr.<span class="property">next</span>.<span class="property">val</span>)</span><br><span class="line">                    curr = curr.<span class="property">next</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将 prev 的 next 指向下一个不重复的节点</span></span><br><span class="line">            prev.<span class="property">next</span> = curr.<span class="property">next</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果没有重复，移动 prev 指针</span></span><br><span class="line">            prev = prev.<span class="property">next</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 移动 curr 指针</span></span><br><span class="line">        curr = curr.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dummy.<span class="property">next</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h4 id="链表转树"><a href="#链表转树" class="headerlink" title="链表转树"></a>链表转树</h4><blockquote><p><a href="https://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/">Leetcode 109. Convert Sorted List to Binary Search Tree</a></p></blockquote><ul><li>题目: 将一个有序链表转换为高度平衡的二叉搜索树（<code>BST</code>）。高度平衡指的是树中每个节点的两个子树的高度差不超过<code>1</code></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: head = [-10,-3,0,5,9]</span><br><span class="line">Output: [0,-3,9,-10,null,5]</span><br></pre></td></tr></table></figure><ul><li>解法: 分治法 + 快慢指针</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 使用快慢指针找到链表的中间节点，将其作为当前树的根节点</span><br><span class="line">2. 对中间节点之前的链表递归构建左子树</span><br><span class="line">3. 对中间节点之后的链表递归构建右子树</span><br><span class="line">4. 当链表为空时，返回 None</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sortedListToBST</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">        <span class="comment"># 辅助函数：找到链表的中间节点</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">find_middle</span>(<span class="params">start, end</span>):</span><br><span class="line">            slow = fast = start</span><br><span class="line">            <span class="keyword">while</span> fast != end <span class="keyword">and</span> fast.<span class="built_in">next</span> != end:</span><br><span class="line">                slow = slow.<span class="built_in">next</span></span><br><span class="line">                fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">return</span> slow</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 主函数：递归构建二叉搜索树</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">build_bst</span>(<span class="params">start, end</span>):</span><br><span class="line">            <span class="keyword">if</span> start == end:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            </span><br><span class="line">            mid = find_middle(start, end)</span><br><span class="line">            root = TreeNode(mid.val)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 构建左右子树</span></span><br><span class="line">            root.left = build_bst(start, mid)</span><br><span class="line">            root.right = build_bst(mid.<span class="built_in">next</span>, end)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> build_bst(head, <span class="literal">None</span>)</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">sortedListToBST</span>(<span class="params">head</span>) &#123;</span><br><span class="line">        <span class="comment">// 辅助函数：找到链表的中间节点</span></span><br><span class="line">        <span class="keyword">function</span> <span class="title function_">findMiddle</span>(<span class="params">start, end</span>) &#123;</span><br><span class="line">            <span class="keyword">let</span> slow = start;</span><br><span class="line">            <span class="keyword">let</span> fast = start;</span><br><span class="line">            <span class="keyword">while</span> (fast !== end &amp;&amp; fast.<span class="property">next</span> !== end) &#123;</span><br><span class="line">                slow = slow.<span class="property">next</span>;</span><br><span class="line">                fast = fast.<span class="property">next</span>.<span class="property">next</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> slow;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 主函数：递归构建二叉搜索树</span></span><br><span class="line">        <span class="keyword">function</span> <span class="title function_">buildBST</span>(<span class="params">start, end</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (start === end) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> mid = <span class="title function_">findMiddle</span>(start, end);</span><br><span class="line">            <span class="keyword">const</span> root = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(mid.<span class="property">val</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 构建左右子树</span></span><br><span class="line">            root.<span class="property">left</span> = <span class="title function_">buildBST</span>(start, mid);</span><br><span class="line">            root.<span class="property">right</span> = <span class="title function_">buildBST</span>(mid.<span class="property">next</span>, end);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">buildBST</span>(head, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h4 id="合并k个有序链表"><a href="#合并k个有序链表" class="headerlink" title="合并k个有序链表"></a>合并<code>k</code>个有序链表</h4><blockquote><p><a href="https://leetcode.com/problems/merge-k-sorted-lists/">Leetcode 23. Merge k Sorted Lists</a></p></blockquote><ul><li>题目: 给定<code>k</code>个有序链表，将它们合并成一个有序链表并返</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: lists = [[1,4,5],[1,3,4],[2,6]]</span><br><span class="line">Output: [1,1,2,3,4,4,5,6]</span><br></pre></td></tr></table></figure><ul><li>解法: 最小堆（优先队列）</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 将每个链表的头节点加入最小堆</span><br><span class="line">2. 每次从堆中取出最小值节点，将其加入结果链表</span><br><span class="line">3. 如果该节点有下一个节点，将下一个节点加入堆中</span><br><span class="line">4. 重复以上过程直到堆为空</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">mergeKLists</span>(<span class="params">self, lists: <span class="type">List</span>[<span class="type">Optional</span>[ListNode]]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        min_heap = []</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 将每个链表的头节点放入堆中</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(lists)):</span><br><span class="line">            <span class="keyword">if</span> lists[i]:</span><br><span class="line">                heapq.heappush(min_heap, (lists[i].val, i, lists[i]))</span><br><span class="line"></span><br><span class="line">        dummy = ListNode(<span class="number">0</span>)</span><br><span class="line">        curr = dummy</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 不断从堆中取出最小节点，并将其后续节点继续放入堆中</span></span><br><span class="line">        <span class="keyword">while</span> min_heap:</span><br><span class="line">            val, idx, node = heapq.heappop(min_heap)</span><br><span class="line">            curr.<span class="built_in">next</span> = node</span><br><span class="line">            curr = curr.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">if</span> node.<span class="built_in">next</span>:</span><br><span class="line">                heapq.heappush(min_heap, (node.<span class="built_in">next</span>.val, idx, node.<span class="built_in">next</span>))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">mergeKLists</span>(<span class="params">lists</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> minHeap = <span class="keyword">new</span> <span class="title class_">MinPriorityQueue</span>(&#123; <span class="attr">priority</span>: <span class="function">(<span class="params">node</span>) =&gt;</span> node.<span class="property">val</span> &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将每个链表的头节点加入堆中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; lists.<span class="property">length</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (lists[i])</span><br><span class="line">                minHeap.<span class="title function_">enqueue</span>(lists[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> dummy = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">let</span> curr = dummy;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从堆中取出最小节点，构建合并链表</span></span><br><span class="line">        <span class="keyword">while</span> (!minHeap.<span class="title function_">isEmpty</span>()) &#123;</span><br><span class="line">            <span class="keyword">const</span> smallestNode = minHeap.<span class="title function_">dequeue</span>().<span class="property">element</span>; <span class="comment">// 取出最小值节点</span></span><br><span class="line">            curr.<span class="property">next</span> = smallestNode;</span><br><span class="line">            curr = curr.<span class="property">next</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (smallestNode.<span class="property">next</span>)</span><br><span class="line">                minHeap.<span class="title function_">enqueue</span>(smallestNode.<span class="property">next</span>); <span class="comment">// 将下一个节点加入堆</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h3 id="BFS-amp-DFS"><a href="#BFS-amp-DFS" class="headerlink" title="BFS &amp; DFS"></a><code>BFS</code> &amp; <code>DFS</code></h3><h4 id="海岛问题"><a href="#海岛问题" class="headerlink" title="海岛问题"></a>海岛问题</h4><blockquote><p><a href="https://leetcode.com/problems/number-of-islands/">Leetcode 200. Number of Islands</a></p></blockquote><ul><li>题目: 给定一个由<code>&#39;1&#39;</code>和<code>&#39;0&#39;</code>组成的网格，<code>&#39;1&#39;</code>表示陆地，<code>&#39;0&#39;</code>表示水域，计算网格中岛屿的数量。岛屿被水域包围，由相邻的陆地（水平或垂直方向）连接而成</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: grid = [</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;]</span><br><span class="line">]</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure><ul><li>解法<code>1</code>: 广度优先搜索 (<code>BFS</code>)</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 遍历网格中的每个位置，找到未访问的陆地节点作为起点</span><br><span class="line">2. 从起点开始，使用 BFS 遍历整个岛屿，将所有相连的陆地标记为已访问</span><br><span class="line">3. 每发现一个新岛屿时，岛屿计数器加一</span><br><span class="line">4. 返回最终的岛屿数量</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">numIslands</span>(<span class="params">self, grid: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        island = <span class="number">0</span></span><br><span class="line">        visited = <span class="built_in">set</span>() <span class="comment"># 记录已访问节点</span></span><br><span class="line">        rows, cols = <span class="built_in">len</span>(grid), <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">bfs</span>(<span class="params">r, c</span>):</span><br><span class="line">            q = deque()</span><br><span class="line">            q.append((r, c))</span><br><span class="line">            visited.add((r, c))</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> q:</span><br><span class="line">                row, col = q.popleft()</span><br><span class="line">                <span class="keyword">for</span> dr, dc <span class="keyword">in</span> [[<span class="number">1</span>, <span class="number">0</span>], [-<span class="number">1</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">1</span>], [<span class="number">0</span>, -<span class="number">1</span>]]:</span><br><span class="line">                    nr, nc = dr + row, dc + col</span><br><span class="line">                    <span class="keyword">if</span> (</span><br><span class="line">                        <span class="number">0</span> &lt;= nr &lt; rows <span class="keyword">and</span></span><br><span class="line">                        <span class="number">0</span> &lt;= nc &lt; cols <span class="keyword">and</span></span><br><span class="line">                        grid[nr][nc] == <span class="string">&quot;1&quot;</span> <span class="keyword">and</span></span><br><span class="line">                        (nr, nc) <span class="keyword">not</span> <span class="keyword">in</span> visited</span><br><span class="line">                    ):</span><br><span class="line">                        q.append((nr, nc))</span><br><span class="line">                        visited.add((nr, nc))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> r <span class="keyword">in</span> <span class="built_in">range</span>(rows):</span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">range</span>(cols):</span><br><span class="line">                <span class="keyword">if</span> grid[r][c] == <span class="string">&quot;1&quot;</span> <span class="keyword">and</span> (r, c) <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">                    island += <span class="number">1</span></span><br><span class="line">                    bfs(r, c)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> island</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">numIslands</span>(<span class="params">grid</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> rows = grid.<span class="property">length</span>;</span><br><span class="line">        <span class="keyword">const</span> cols = grid[<span class="number">0</span>].<span class="property">length</span>;</span><br><span class="line">        <span class="keyword">const</span> visited = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line">        <span class="keyword">let</span> island = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> <span class="title function_">bfs</span> = (<span class="params">r, c</span>) =&gt; &#123;</span><br><span class="line">            <span class="keyword">const</span> queue = [];</span><br><span class="line">            queue.<span class="title function_">push</span>([r, c]);</span><br><span class="line">            visited.<span class="title function_">add</span>(<span class="string">`<span class="subst">$&#123;r&#125;</span>,<span class="subst">$&#123;c&#125;</span>`</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (queue.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">const</span> [row, col] = queue.<span class="title function_">shift</span>();</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">const</span> [dr, dc] <span class="keyword">of</span> [[<span class="number">1</span>, <span class="number">0</span>], [-<span class="number">1</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">1</span>], [<span class="number">0</span>, -<span class="number">1</span>]]) &#123;</span><br><span class="line">                    <span class="keyword">const</span> nr = dr + row;</span><br><span class="line">                    <span class="keyword">const</span> nc = dc + col;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (nr &gt;= <span class="number">0</span> &amp;&amp;</span><br><span class="line">                        nc &gt;= <span class="number">0</span> &amp;&amp;</span><br><span class="line">                        nr &lt; rows &amp;&amp;</span><br><span class="line">                        nc &lt; cols &amp;&amp;</span><br><span class="line">                        grid[nr][nc] === <span class="string">&quot;1&quot;</span> &amp;&amp;</span><br><span class="line">                        !visited.<span class="title function_">has</span>(<span class="string">`<span class="subst">$&#123;nr&#125;</span>,<span class="subst">$&#123;nc&#125;</span>`</span>)</span><br><span class="line">                    ) &#123;</span><br><span class="line">                        queue.<span class="title function_">push</span>([nr, nc]);</span><br><span class="line">                        visited.<span class="title function_">add</span>(<span class="string">`<span class="subst">$&#123;nr&#125;</span>,<span class="subst">$&#123;nc&#125;</span>`</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> r = <span class="number">0</span>; r &lt; rows; r++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> c = <span class="number">0</span>; c &lt; cols; c++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[r][c] === <span class="string">&quot;1&quot;</span> &amp;&amp; !visited.<span class="title function_">has</span>(<span class="string">`<span class="subst">$&#123;r&#125;</span>,<span class="subst">$&#123;c&#125;</span>`</span>)) &#123;</span><br><span class="line">                    island += <span class="number">1</span>;</span><br><span class="line">                    <span class="title function_">bfs</span>(r, c);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> island;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><ul><li>解法<code>2</code>: 深度优先搜索 (<code>DFS</code>)</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 使用递归替代 BFS 的队列逻辑</span><br><span class="line">2. 遍历网格，遇到未访问的陆地时，启动 DFS 遍历整个岛屿</span><br><span class="line">3. 每发现一个新岛屿时，岛屿计数器加一</span><br><span class="line">4. 返回岛屿数量</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">numIslands</span>(<span class="params">self, grid: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        island = <span class="number">0</span></span><br><span class="line">        rows, cols = <span class="built_in">len</span>(grid), <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">r, c</span>):</span><br><span class="line">            <span class="keyword">if</span> r &lt; <span class="number">0</span> <span class="keyword">or</span> c &lt; <span class="number">0</span> <span class="keyword">or</span> r &gt;= rows <span class="keyword">or</span> c &gt;= cols <span class="keyword">or</span> grid[r][c] == <span class="string">&quot;0&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            grid[r][c] = <span class="string">&quot;0&quot;</span> <span class="comment"># 标记为已访问</span></span><br><span class="line">            <span class="comment"># 遍历四个方向</span></span><br><span class="line">            <span class="keyword">for</span> dr, dc <span class="keyword">in</span> [[<span class="number">1</span>, <span class="number">0</span>], [-<span class="number">1</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">1</span>], [<span class="number">0</span>, -<span class="number">1</span>]]:</span><br><span class="line">                dfs(r + dr, c + dc)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> r <span class="keyword">in</span> <span class="built_in">range</span>(rows):</span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">range</span>(cols):</span><br><span class="line">                <span class="keyword">if</span> grid[r][c] == <span class="string">&quot;1&quot;</span>:</span><br><span class="line">                    island += <span class="number">1</span></span><br><span class="line">                    dfs(r, c)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> island</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">numIslands</span>(<span class="params">grid</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> rows = grid.<span class="property">length</span>;</span><br><span class="line">        <span class="keyword">const</span> cols = grid[<span class="number">0</span>].<span class="property">length</span>;</span><br><span class="line">        <span class="keyword">let</span> island = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> <span class="title function_">dfs</span> = (<span class="params">r, c</span>) =&gt; &#123;</span><br><span class="line">            <span class="comment">// 如果超出边界或遇到水域，则停止递归</span></span><br><span class="line">            <span class="keyword">if</span> (r &lt; <span class="number">0</span> || c &lt; <span class="number">0</span> || r &gt;= rows || c &gt;= cols || grid[r][c] === <span class="string">&quot;0&quot;</span>)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">            grid[r][c] = <span class="number">0</span>; <span class="comment">// 标记为已访问</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">const</span> [dr, dc] <span class="keyword">of</span> [[<span class="number">1</span>, <span class="number">0</span>], [-<span class="number">1</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">1</span>], [<span class="number">0</span>, -<span class="number">1</span>]])</span><br><span class="line">                <span class="title function_">dfs</span>(r + dr, c + dc);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> r = <span class="number">0</span>; r &lt; rows; r++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> c = <span class="number">0</span>; c &lt; cols; c++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[r][c] === <span class="string">&quot;1&quot;</span>) &#123;</span><br><span class="line">                    island += <span class="number">1</span>;</span><br><span class="line">                    <span class="title function_">dfs</span>(r, c);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> island;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h3 id="Two-Pointers-双指针"><a href="#Two-Pointers-双指针" class="headerlink" title="Two Pointers 双指针"></a><code>Two Pointers</code> 双指针</h3><h4 id="雨水问题"><a href="#雨水问题" class="headerlink" title="雨水问题"></a>雨水问题</h4><blockquote><p><a href="https://leetcode.com/problems/trapping-rain-water/">Leetcode 42. Trapping Rain Water</a></p></blockquote><ul><li>题目: 给定一个非负整数数组<code>height</code>，表示每个柱子的高度。假设下雨后水只会停留在柱子之间，请计算可以接住的总雨水量</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: height = [0,1,0,2,1,0,1,3,2,1,2,1]</span><br><span class="line">Output: 6</span><br></pre></td></tr></table></figure><ul><li>解法: 双指针</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 使用两个指针分别从数组的左右两端向中间靠拢</span><br><span class="line">2. 在遍历过程中，记录左右两侧的最大高度</span><br><span class="line">3. 计算当前柱子上方的雨水量：</span><br><span class="line">    - 雨水量 = 较低一侧的最大高度 - 当前柱子高度</span><br><span class="line">4. 移动较低一侧的指针，同时更新对应的最大高度</span><br><span class="line">5. 遍历结束时，累加所有雨水量并返回结果</span><br><span class="line"></span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">trap</span>(<span class="params">self, height: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> height:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        left, right = <span class="number">0</span>, <span class="built_in">len</span>(height) - <span class="number">1</span></span><br><span class="line">        <span class="comment"># 初始化左右两边的最大高度</span></span><br><span class="line">        left_max, right_max = height[left], height[right]</span><br><span class="line">        result = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            <span class="comment"># 如果左边的最大高度小于右边的最大高度</span></span><br><span class="line">            <span class="keyword">if</span> left_max &lt; right_max:</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">                <span class="comment"># 更新左边的最大高度</span></span><br><span class="line">                left_max = <span class="built_in">max</span>(left_max, height[left])</span><br><span class="line">                <span class="comment"># 计算当前左指针位置的接水量（左边的最大高度 - 当前柱子的高度）</span></span><br><span class="line">                result += left_max - height[left]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line">                <span class="comment"># 更新右边的最大高度</span></span><br><span class="line">                right_max = <span class="built_in">max</span>(right_max, height[right])</span><br><span class="line">                <span class="comment"># 计算当前右指针位置的接水量（右边的最大高度 - 当前柱子的高度）</span></span><br><span class="line">                result += right_max - height[right]</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">trap</span>(<span class="params">height</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> left = <span class="number">0</span>, right = height.<span class="property">length</span> - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">let</span> leftMax = height[left], rightMax = height[right];</span><br><span class="line">        <span class="keyword">let</span> result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">if</span> (leftMax &lt; rightMax) &#123;</span><br><span class="line">                left++;</span><br><span class="line">                leftMax = <span class="title class_">Math</span>.<span class="title function_">max</span>(leftMax, height[left]); <span class="comment">// 更新左边最大高度</span></span><br><span class="line">                result += leftMax - height[left]; <span class="comment">// 计算左侧接水量</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right--;</span><br><span class="line">                rightMax = <span class="title class_">Math</span>.<span class="title function_">max</span>(rightMax, height[right]); <span class="comment">// 更新右边最大高度</span></span><br><span class="line">                result += rightMax - height[right]; <span class="comment">// 计算右侧接水量</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h4 id="盛水问题"><a href="#盛水问题" class="headerlink" title="盛水问题"></a>盛水问题</h4><blockquote><p><a href="https://leetcode.com/problems/container-with-most-water/">Leetcode 11. Container With Most Water</a></p></blockquote><ul><li>题目: 给定一个数组<code>height</code>，其中每个元素表示一个竖线的高度，竖线在横轴上的间隔为<code>1</code>。找到两根竖线之间形成的容器能够盛水的最大面积</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: height = [1,8,6,2,5,4,8,3,7]</span><br><span class="line">Output: 49</span><br></pre></td></tr></table></figure><ul><li>解法: 双指针</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 初始化左右指针，分别指向数组的两端</span><br><span class="line">2. 每次计算由左右指针对应的竖线形成的容器面积，更新最大面积</span><br><span class="line">3. 移动较短竖线的一侧指针，尝试找到更大的容器</span><br><span class="line">4. 重复上述步骤，直到左右指针相遇</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxArea</span>(<span class="params">self, height: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        left, right = <span class="number">0</span>, <span class="built_in">len</span>(height) - <span class="number">1</span></span><br><span class="line">        result = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            <span class="comment"># 计算当前容器的面积</span></span><br><span class="line">            width = right - left</span><br><span class="line">            area = <span class="built_in">min</span>(height[left], height[right]) * width</span><br><span class="line">            <span class="comment"># 更新最大面积</span></span><br><span class="line">            result = <span class="built_in">max</span>(result, area)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 移动较短边对应的指针，尝试找到更大的容器</span></span><br><span class="line">            <span class="keyword">if</span> height[left] &lt; height[right]:</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">maxArea</span>(<span class="params">height</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> left = <span class="number">0</span>, right = height.<span class="property">length</span> - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">let</span> maxArea = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="comment">// 计算当前容器的面积</span></span><br><span class="line">            <span class="keyword">const</span> width = right - left;</span><br><span class="line">            <span class="keyword">const</span> area = <span class="title class_">Math</span>.<span class="title function_">min</span>(height[left], height[right]) * width;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 更新最大面积</span></span><br><span class="line">            maxArea = <span class="title class_">Math</span>.<span class="title function_">max</span>(maxArea, area);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 移动较短边对应的指针</span></span><br><span class="line">            <span class="keyword">if</span> (height[left] &lt; height[right])</span><br><span class="line">                left++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                right--;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> maxArea;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h4 id="一维数组去重"><a href="#一维数组去重" class="headerlink" title="一维数组去重"></a>一维数组去重</h4><blockquote><p><a href="https://leetcode.com/problems/remove-duplicates-from-sorted-array/">Leetcode 26. Remove Duplicates from Sorted Array</a></p></blockquote><ul><li>题目: 有序数组<code>nums</code>，需要原地移除重复项，使每个元素最多出现一次</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: nums = [0,0,1,1,1,2,2,3,3,4]</span><br><span class="line">Output: 5, nums = [0,1,2,3,4,_,_,_,_,_]</span><br></pre></td></tr></table></figure><ul><li>解法: 双指针</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 定义 i 指针跟踪去重后数组的最后一个位置</span><br><span class="line">2. 使用 j 指针遍历数组，寻找不重复的元素</span><br><span class="line">3. 遇到新元素时，将其放在 i+1 位置，并更新 i</span><br><span class="line">4. 返回去重后数组的长度 i+1</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeDuplicates</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        i = <span class="number">0</span> <span class="comment"># 跟踪去重后数组的最后一个位置</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[j] != nums[i]: <span class="comment"># 如果发现新的元素</span></span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">                nums[i] = nums[j] <span class="comment"># 将 nums[j] 移动到去重后的数组中</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> i + <span class="number">1</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">removeDuplicates</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="property">length</span> === <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>; j &lt; nums.<span class="property">length</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[j] !== nums[i]) &#123; <span class="comment">// 遇到新元素</span></span><br><span class="line">                i++;</span><br><span class="line">                nums[i] = nums[j]; <span class="comment">// 更新数组</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h4 id="最接近的三数之和"><a href="#最接近的三数之和" class="headerlink" title="最接近的三数之和"></a>最接近的三数之和</h4><blockquote><p><a href="https://leetcode.com/problems/3sum-closest/">Leetcode 16. 3Sum Closest</a></p></blockquote><ul><li>题目: 给定一个长度为<code>n</code>的整数数组<code>nums</code>和一个目标值<code>target</code>，找到数组中三个数的和，使其最接近目标值。返回这个和</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: nums = [-1,2,1,-4], target = 1</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: The sum that is closest to the target is 2. (-1 + 2 + 1 = 2)</span><br></pre></td></tr></table></figure><ul><li>解法: 排序 + 双指针</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 首先对数组进行排序</span><br><span class="line">2. 遍历数组，固定一个数 nums[i]，用双指针从 i+1 和数组末尾出发寻找最接近的三数之和</span><br><span class="line">3. 如果当前三数之和比记录的更接近目标值，更新结果</span><br><span class="line">4. 根据当前和与目标值的大小关系移动左右指针</span><br><span class="line">5. 返回最接近的三数之和</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">threeSumClosest</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        nums.sort() <span class="comment"># 排序</span></span><br><span class="line">        result = <span class="built_in">float</span>(<span class="string">&quot;inf&quot;</span>) <span class="comment"># 初始化最接近的结果</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums) - <span class="number">2</span>):</span><br><span class="line">            left, right = i + <span class="number">1</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> left &lt; right:</span><br><span class="line">                curr_sum = nums[i] + nums[left] + nums[right]</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 更新最接近的结果</span></span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">abs</span>(curr_sum - target) &lt; <span class="built_in">abs</span>(result - target):</span><br><span class="line">                    result = curr_sum</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 根据当前和与目标值的关系调整指针</span></span><br><span class="line">                <span class="keyword">if</span> curr_sum &lt; target:</span><br><span class="line">                    left += <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> curr_sum &gt; target:</span><br><span class="line">                    right -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> curr_sum <span class="comment"># 当前和等于目标值时直接返回</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">threeSumClosest</span>(<span class="params">nums, target</span>) &#123;</span><br><span class="line">        nums.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b); <span class="comment">// 排序</span></span><br><span class="line">        <span class="keyword">let</span> result = <span class="title class_">Infinity</span>; <span class="comment">// 初始化最接近的结果</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.<span class="property">length</span> - <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">let</span> left = i + <span class="number">1</span>, right = nums.<span class="property">length</span> - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">                <span class="keyword">let</span> currSum = nums[i] + nums[left] + nums[right];</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 更新最接近的结果</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="title class_">Math</span>.<span class="title function_">abs</span>(currSum - target) &lt; <span class="title class_">Math</span>.<span class="title function_">abs</span>(result - target))</span><br><span class="line">                    result = currSum;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 根据当前和与目标值的关系调整指针</span></span><br><span class="line">                <span class="keyword">if</span> (currSum &lt; target)</span><br><span class="line">                    left++;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (currSum &gt; target)</span><br><span class="line">                    right--;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">return</span> currSum; <span class="comment">// 当前和等于目标值时直接返回</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h4 id="三数之和"><a href="#三数之和" class="headerlink" title="三数之和"></a>三数之和</h4><blockquote><p><a href="https://leetcode.com/problems/3sum/">Leetcode 15. 3Sum</a></p></blockquote><ul><li>题目: 给定一个包含整数的数组<code>nums</code>，返回所有不重复的三元组<code>[nums[i], nums[j], nums[k]]</code>，使得<code>nums[i] + nums[j] + nums[k] == 0</code>。答案中不能包含重复的三元组</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: nums = [-1, 0, 1, 2, -1, -4]</span><br><span class="line">Output: [[-1, -1, 2], [-1, 0, 1]]</span><br><span class="line">Explanation: </span><br><span class="line">nums[0] + nums[1] + nums[3] = -1 + -1 + 2 = 0</span><br><span class="line">nums[0] + nums[2] + nums[4] = -1 + 0 + 1 = 0</span><br></pre></td></tr></table></figure><ul><li>解法: 排序 + 双指针</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 对数组进行排序，便于去重和使用双指针</span><br><span class="line">2. 遍历数组，固定一个数 nums[i]，然后用双指针从 i+1 和数组末尾出发，寻找和为 -nums[i] 的另外两个数</span><br><span class="line">3. 如果找到和为 0 的三元组，将其加入结果集中，同时移动指针跳过重复值</span><br><span class="line">4. 如果当前和小于 0，左指针右移；如果当前和大于 0，右指针左移</span><br><span class="line">5. 遍历结束返回结果</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">threeSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        nums.sort() <span class="comment"># 对数组进行排序，方便后续去重和双指针处理</span></span><br><span class="line">        result = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums) - <span class="number">2</span>):</span><br><span class="line">            <span class="comment"># 如果当前数和前一个数相同，跳过，避免重复三元组</span></span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i - <span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            left, right = i + <span class="number">1</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> left &lt; right:</span><br><span class="line">                total = nums[i] + nums[left] + nums[right] <span class="comment"># 计算当前三数之和</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> total == <span class="number">0</span>:</span><br><span class="line">                    result.append([nums[i], nums[left], nums[right]])</span><br><span class="line"></span><br><span class="line">                    <span class="comment"># 跳过重复的左指针和右指针值</span></span><br><span class="line">                    <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> nums[left] == nums[left + <span class="number">1</span>]:</span><br><span class="line">                        left += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> nums[right] == nums[right - <span class="number">1</span>]:</span><br><span class="line">                        right -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment"># 移动指针</span></span><br><span class="line">                    left += <span class="number">1</span></span><br><span class="line">                    right -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> total &lt; <span class="number">0</span>: <span class="comment"># 如果当前和小于 0，增加左指针</span></span><br><span class="line">                    left += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>: <span class="comment"># 如果当前和大于 0，减少右指针</span></span><br><span class="line">                    right -= <span class="number">1</span> </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">threeSum</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">        nums.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b); <span class="comment">// 对数组进行排序</span></span><br><span class="line">        <span class="keyword">const</span> result = [];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.<span class="property">length</span> - <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 如果当前数和前一个数相同，跳过，避免重复三元组</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] === nums[i - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">let</span> left = i + <span class="number">1</span>, right = nums.<span class="property">length</span> - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">                <span class="keyword">const</span> total = nums[i] + nums[left] + nums[right];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (total === <span class="number">0</span>) &#123;</span><br><span class="line">                    result.<span class="title function_">push</span>([nums[i], nums[left], nums[right]]);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 跳过重复的左指针和右指针值</span></span><br><span class="line">                    <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[left] === nums[left + <span class="number">1</span>]) left++;</span><br><span class="line">                    <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[right] === nums[right - <span class="number">1</span>]) right--;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 移动指针</span></span><br><span class="line">                    left++;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (total &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    left++; <span class="comment">// 如果当前和小于 0，增加左指针</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    right--;  如果当前和大于 <span class="number">0</span>，减少右指针</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h4 id="四数之和"><a href="#四数之和" class="headerlink" title="四数之和"></a>四数之和</h4><blockquote><p><a href="https://leetcode.com/problems/4sum/">Leetcode 18. 4Sum</a></p></blockquote><ul><li>题目: 给定一个由整数数组<code>nums</code>和一个目标值<code>target</code>，找出所有不重复的四元组<code>[nums[a], nums[b], nums[c], nums[d]]</code>，使得<code>nums[a] + nums[b] + nums[c] + nums[d] == target</code></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: nums = [1,0,-1,0,-2,2], target = 0</span><br><span class="line">Output: [[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]</span><br><span class="line">Explanation: The solution sets are unique and order does not matter</span><br></pre></td></tr></table></figure><ul><li>解法: 排序 + 双指针 + 多层遍历</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 对数组进行排序，以便后续去重和使用双指针</span><br><span class="line">2. 先固定两个数 nums[i] 和 nums[j]，然后使用双指针寻找剩下两个数，使得四数之和等于 target</span><br><span class="line">3. 遍历过程中跳过重复的数值，避免结果中出现重复的四元组</span><br><span class="line">4. 返回所有符合条件的四元组</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fourSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        nums.sort() <span class="comment"># 排序</span></span><br><span class="line">        result = []</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums) - <span class="number">3</span>):</span><br><span class="line">            <span class="comment"># 跳过重复的第一个数</span></span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i - <span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i + <span class="number">1</span>, <span class="built_in">len</span>(nums) - <span class="number">2</span>):</span><br><span class="line">                <span class="comment"># 跳过重复的第二个数</span></span><br><span class="line">                <span class="keyword">if</span> j &gt; i + <span class="number">1</span> <span class="keyword">and</span> nums[j] == nums[j - <span class="number">1</span>]:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                </span><br><span class="line">                left, right = j + <span class="number">1</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> left &lt; right:</span><br><span class="line">                    total = nums[i] + nums[j] + nums[left] + nums[right]</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> total == target:</span><br><span class="line">                        result.append([nums[i], nums[j], nums[left], nums[right]])</span><br><span class="line"></span><br><span class="line">                        <span class="comment"># 跳过重复的左指针和右指针值</span></span><br><span class="line">                        <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> nums[left] == nums[left + <span class="number">1</span>]:</span><br><span class="line">                            left += <span class="number">1</span></span><br><span class="line">                        <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> nums[right] == nums[right - <span class="number">1</span>]:</span><br><span class="line">                            right -= <span class="number">1</span></span><br><span class="line">                        </span><br><span class="line">                        <span class="comment"># 移动指针</span></span><br><span class="line">                        left += <span class="number">1</span></span><br><span class="line">                        right -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">elif</span> total &lt; target:</span><br><span class="line">                        left += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        right -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">fourSum</span>(<span class="params">nums, target</span>) &#123;</span><br><span class="line">        nums.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b); <span class="comment">// 排序</span></span><br><span class="line">        <span class="keyword">const</span> result = [];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.<span class="property">length</span> - <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 跳过重复的第一个数</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] === nums[i - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; nums.<span class="property">length</span> - <span class="number">2</span>; j++) &#123;</span><br><span class="line">                <span class="comment">// 跳过重复的第二个数</span></span><br><span class="line">                <span class="keyword">if</span> (j &gt; i + <span class="number">1</span> &amp;&amp; nums[j] === nums[j - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">let</span> left = j + <span class="number">1</span>, right = nums.<span class="property">length</span> - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">                    <span class="keyword">const</span> total = nums[i] + nums[j] + nums[left] + nums[right];</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (total === target) &#123;</span><br><span class="line">                        result.<span class="title function_">push</span>([nums[i], nums[j], nums[left], nums[right]]);</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 跳过重复的左指针和右指针值</span></span><br><span class="line">                        <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[left] === nums[left + <span class="number">1</span>]) left++;</span><br><span class="line">                        <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[right] === nums[right - <span class="number">1</span>]) right--;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 移动指针</span></span><br><span class="line">                        left++;</span><br><span class="line">                        right--;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (total &lt; target) &#123;</span><br><span class="line">                        left++;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        right--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h4 id="找出数组中的重复数字"><a href="#找出数组中的重复数字" class="headerlink" title="找出数组中的重复数字"></a>找出数组中的重复数字</h4><blockquote><p><a href="https://leetcode.com/problems/find-the-duplicate-number/">Leetcode 287. Find the Duplicate Number</a></p></blockquote><ul><li>题目: 给定一个包含<code>n + 1</code>个整数的数组 nums，其中每个整数都在范围 [1, n] 内，且只有一个重复的数字。找出该重复的数字。注意：不能修改数组内容，并且仅使用常数级别的额外空间</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: nums = [3,1,3,4,2]</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure><ul><li>解法: 快慢指针（<code>Floyd</code>判圈算法）</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 将数组看作链表，nums[i] 指向下一个节点</span><br><span class="line">2. 使用快慢指针找到环的位置：慢指针一次走一步，快指针一次走两步</span><br><span class="line">3. 在环中找到入口，也就是重复的数字</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findDuplicate</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 使用快慢指针</span></span><br><span class="line">        slow, fast = nums[<span class="number">0</span>], nums[nums[<span class="number">0</span>]]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 阶段 1：找到快慢指针相遇点</span></span><br><span class="line">        <span class="keyword">while</span> slow != fast:</span><br><span class="line">            slow = nums[slow]</span><br><span class="line">            fast = nums[nums[fast]]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 阶段 2：找到环的入口，即重复的数字</span></span><br><span class="line">        slow = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> slow != fast:</span><br><span class="line">            slow = nums[slow]</span><br><span class="line">            fast = nums[fast]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> slow</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">findDuplicate</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> slow = nums[<span class="number">0</span>], fast = nums[nums[<span class="number">0</span>]];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 阶段 1：找到快慢指针相遇点</span></span><br><span class="line">        <span class="keyword">while</span> (slow !== fast) &#123;</span><br><span class="line">            slow = nums[slow];</span><br><span class="line">            fast = nums[nums[fast]];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 阶段 2：找到环的入口，即重复的数字</span></span><br><span class="line">        slow = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (slow !== fast) &#123;</span><br><span class="line">            slow = nums[slow];</span><br><span class="line">            fast = nums[fast];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h3 id="Binary-Search"><a href="#Binary-Search" class="headerlink" title="Binary Search"></a><code>Binary Search</code></h3><h4 id="最长递增子序列"><a href="#最长递增子序列" class="headerlink" title="最长递增子序列"></a>最长递增子序列</h4><blockquote><p><a href="https://leetcode.com/problems/longest-increasing-subsequence/">Leetcode 300. Longest Increasing Subsequence</a></p></blockquote><ul><li>题目: 给定一个整数数组<code>nums</code>，找到其中最长严格递增子序列的长度</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: nums = [10,9,2,5,3,7,101,18]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4</span><br></pre></td></tr></table></figure><ul><li>解法: 动态规划 + 二分法优化</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 动态规划：</span><br><span class="line">   定义 dp[i] 表示以 nums[i] 为结尾的最长递增子序列的长度</span><br><span class="line">   状态转移方程：dp[i] = max(dp[i], dp[j] + 1) for all j &lt; i and nums[j] &lt; nums[i]</span><br><span class="line">   时间复杂度为 O(n^2)</span><br><span class="line"></span><br><span class="line">2. 二分法优化：</span><br><span class="line">   维护一个数组 tails，其中 tails[i] 表示长度为 i+1 的递增子序列的末尾最小值</span><br><span class="line">   对每个 nums 中的元素使用二分法更新 tails</span><br><span class="line">   时间复杂度为 O(n log n)</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lengthOfLIS</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 用于存储不同长度递增子序列的最小末尾值</span></span><br><span class="line">        tails = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="comment"># 二分查找，寻找第一个大于等于 num 的位置</span></span><br><span class="line">            left, right = <span class="number">0</span>, <span class="built_in">len</span>(tails)</span><br><span class="line">            <span class="keyword">while</span> left &lt; right:</span><br><span class="line">                mid = (left + right) // <span class="number">2</span></span><br><span class="line">                <span class="keyword">if</span> tails[mid] &lt; num:</span><br><span class="line">                    left = mid + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    right = mid</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 如果 left 等于 tails 长度，说明 num 是一个新的最大值</span></span><br><span class="line">            <span class="keyword">if</span> left == <span class="built_in">len</span>(tails):</span><br><span class="line">                tails.append(num)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                tails[left] = num</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(tails)</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">lengthOfLIS</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> tails = [];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> num <span class="keyword">of</span> nums) &#123;</span><br><span class="line">            <span class="comment">// 找到第一个大于等于 num 的位置</span></span><br><span class="line">            <span class="keyword">let</span> left = <span class="number">0</span>, right = tails.<span class="property">length</span>;</span><br><span class="line">            <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">                <span class="keyword">const</span> mid = <span class="title class_">Math</span>.<span class="title function_">floor</span>((left + right) / <span class="number">2</span>);</span><br><span class="line">                <span class="keyword">if</span> (tails[mid] &lt; num)</span><br><span class="line">                    left = mid + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    right = mid;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (left === tails.<span class="property">length</span>)</span><br><span class="line">                <span class="comment">// 如果 num 比 tails 中的所有值都大，直接添加到末尾</span></span><br><span class="line">                tails.<span class="title function_">push</span>(num);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="comment">// 否则替换位置 left 的值，保持更小的末尾</span></span><br><span class="line">                tails[left] = num;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> tails.<span class="property">length</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h3 id="Tree-树与二叉树"><a href="#Tree-树与二叉树" class="headerlink" title="Tree 树与二叉树"></a><code>Tree</code> 树与二叉树</h3><h4 id="二叉树层序遍历"><a href="#二叉树层序遍历" class="headerlink" title="二叉树层序遍历"></a>二叉树层序遍历</h4><ul><li>实现二叉树的层序遍历（广度优先遍历，<code>BFS</code>）</li><li>从二叉树的根节点开始，按层级顺序逐层访问节点，每层从左到右</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    3  </span><br><span class="line">   / \</span><br><span class="line">  9   20</span><br><span class="line">     /  \</span><br><span class="line">    15   7</span><br><span class="line"></span><br><span class="line">输出: </span><br><span class="line">[</span><br><span class="line">    [3],</span><br><span class="line">    [9, 20],</span><br><span class="line">    [15, 7]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><ul><li>解法: 队列实现<code>BFS</code></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 使用 deque 实现队列，初始包含根节点</span><br><span class="line">2. 遍历每一层：</span><br><span class="line">    - 记录当前层的节点数量（level_size）</span><br><span class="line">    - 弹出队首节点，存储值到当前层结果</span><br><span class="line">    - 将左右子节点加入队列</span><br><span class="line">3. 每层遍历结束后，将当前层结果加入最终结果</span><br><span class="line">4. 队列为空时，遍历完成</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, val=<span class="number">0</span>, left=<span class="literal">None</span>, right=<span class="literal">None</span></span>):</span><br><span class="line">        self.val = val</span><br><span class="line">        self.left = left</span><br><span class="line">        self.right = right</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">levelOrder</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="built_in">list</span>[<span class="built_in">list</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">        queue = deque([root]) <span class="comment"># 初始化队列，包含根节点</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            level_size = <span class="built_in">len</span>(queue) <span class="comment"># 当前层的节点数</span></span><br><span class="line">            current_level = [] <span class="comment"># 用于存储当前层的节点值</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(level_size):</span><br><span class="line">                node = queue.popleft() <span class="comment"># 弹出队首节点</span></span><br><span class="line">                current_level.append(node.val) <span class="comment"># 添加节点值到当前层</span></span><br><span class="line"></span><br><span class="line">                <span class="comment"># 将左右子节点加入队列</span></span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    queue.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    queue.append(node.right)</span><br><span class="line"></span><br><span class="line">            result.append(current_level) <span class="comment"># 将当前层加入结果</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result       </span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">val = <span class="number">0</span>, left = <span class="literal">null</span>, right = <span class="literal">null</span></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">val</span> = val;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">left</span> = left;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">right</span> = right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">levelOrder</span>(<span class="params">root</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> result = [];</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> queue = [root]; <span class="comment">// 初始化队列，包含根节点</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (queue.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> levelSize = queue.<span class="property">length</span>; <span class="comment">// 当前层的节点数</span></span><br><span class="line">            <span class="keyword">const</span> currentLevel = []; <span class="comment">// 用于存储当前层的节点值</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; levelSize; i++) &#123;</span><br><span class="line">                <span class="keyword">const</span> node = queue.<span class="title function_">shift</span>(); <span class="comment">// 弹出队首节点</span></span><br><span class="line">                currentLevel.<span class="title function_">push</span>(node.<span class="property">val</span>); <span class="comment">// 添加节点值到当前层</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 将左右子节点加入队列</span></span><br><span class="line">                <span class="keyword">if</span> (node.<span class="property">left</span>) queue.<span class="title function_">push</span>(node.<span class="property">left</span>);</span><br><span class="line">                <span class="keyword">if</span> (node.<span class="property">right</span>) queue.<span class="title function_">push</span>(node.<span class="property">right</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            result.<span class="title function_">push</span>(currentLevel);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h4 id="树每层的最大值"><a href="#树每层的最大值" class="headerlink" title="树每层的最大值"></a>树每层的最大值</h4><blockquote><p><a href="https://leetcode.com/problems/find-largest-value-in-each-tree-row/">Leetcode 515. Find Largest Value in Each Tree Row</a></p></blockquote><ul><li>题目: 给定一个二叉树，按层遍历树，返回每一行中的最大值</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">      1</span><br><span class="line">     / \</span><br><span class="line">    3   2</span><br><span class="line">   / \    \</span><br><span class="line">  5   3    9</span><br><span class="line"></span><br><span class="line">Output: [1,3,9]</span><br></pre></td></tr></table></figure><ul><li>解法: 广度优先搜索<code>BFS</code></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 使用队列（deque）进行层序遍历（BFS）</span><br><span class="line">2. 遍历每一层时，找出该层节点值的最大值</span><br><span class="line">3. 将每层的最大值添加到结果列表中</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">largestValues</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        </span><br><span class="line">        result = []</span><br><span class="line">        queue = deque([root])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            level_size = <span class="built_in">len</span>(queue)</span><br><span class="line">            max_val = <span class="built_in">float</span>(<span class="string">&quot;-inf&quot;</span>) <span class="comment"># 初始化每层最大值</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(level_size):</span><br><span class="line">                node = queue.popleft() <span class="comment"># 弹出当前层的节点</span></span><br><span class="line">                max_val = <span class="built_in">max</span>(max_val, node.val) <span class="comment"># 更新最大值</span></span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    queue.append(node.left) <span class="comment"># 加入左子节点</span></span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    queue.append(node.right) <span class="comment"># 加入右子节点</span></span><br><span class="line">            </span><br><span class="line">            result.append(max_val) <span class="comment"># 保存每层最大值</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">largestValues</span>(<span class="params">root</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> [];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> result = [];</span><br><span class="line">        <span class="keyword">const</span> queue = [root];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (queue.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> levelSize = queue.<span class="property">length</span>;</span><br><span class="line">            <span class="keyword">let</span> maxVal = -<span class="title class_">Infinity</span>; <span class="comment">// 初始化每层最大值</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; levelSize; i++) &#123;</span><br><span class="line">                <span class="keyword">const</span> node = queue.<span class="title function_">shift</span>(); <span class="comment">// 弹出当前层的节点</span></span><br><span class="line">                maxVal = <span class="title class_">Math</span>.<span class="title function_">max</span>(maxVal, node.<span class="property">val</span>); <span class="comment">// 更新最大值</span></span><br><span class="line">                <span class="keyword">if</span> (node.<span class="property">left</span>) queue.<span class="title function_">push</span>(node.<span class="property">left</span>); <span class="comment">// 加入左子节点</span></span><br><span class="line">                <span class="keyword">if</span> (node.<span class="property">right</span>) queue.<span class="title function_">push</span>(node.<span class="property">right</span>); <span class="comment">// 加入右子节点</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            result.<span class="title function_">push</span>(maxVal); <span class="comment">// 保存每层最大值</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h4 id="验证二叉搜索树"><a href="#验证二叉搜索树" class="headerlink" title="验证二叉搜索树"></a>验证二叉搜索树</h4><blockquote><p><a href="https://leetcode.com/problems/validate-binary-search-tree/">Leetcode 98. Validate Binary Search Tree</a></p></blockquote><ul><li>题目: 验证一棵二叉树是否为二叉搜索树（<code>BST</code>）</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">二叉搜索树的性质:</span><br><span class="line">1. 节点的左子树只包含比当前节点值小的节点</span><br><span class="line">2. 节点的右子树只包含比当前节点值大的节点</span><br><span class="line">3. 左右子树也必须是二叉搜索树</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: root = [2,1,3]</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><ul><li>解法: 递归验证上下界</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 使用递归检查每个节点的值是否满足二叉搜索树的性质:</span><br><span class="line">   节点的值应在一个范围内 `(low, high)`</span><br><span class="line">2. 初始范围是 `(-inf, inf)`</span><br><span class="line">3. 左子树的值范围: `(low, node.val)`</span><br><span class="line">   右子树的值范围: `(node.val, high)`</span><br><span class="line">4. 递归检查子树是否满足条件</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isValidBST</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="comment"># 递归函数，检查节点是否在 (low, high) 范围内</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">validate</span>(<span class="params">node, low, high</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node: <span class="comment"># 空节点是合法的</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="comment"># 当前节点值必须在范围内</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> (low &lt; node.val &lt; high):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">return</span> validate(node.left, low, node.val) <span class="keyword">and</span> validate(node.right, node.val, high)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 初始范围为 (-inf, inf)</span></span><br><span class="line">        <span class="keyword">return</span> validate(root, <span class="built_in">float</span>(<span class="string">&quot;-inf&quot;</span>), <span class="built_in">float</span>(<span class="string">&quot;inf&quot;</span>))</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">isValidBST</span>(<span class="params">root</span>) &#123;</span><br><span class="line">        <span class="keyword">function</span> <span class="title function_">validate</span>(<span class="params">node, low, high</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!node) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 空节点合法</span></span><br><span class="line">            <span class="keyword">if</span> (node.<span class="property">val</span> &lt;= low || node.<span class="property">val</span> &gt;= high) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 不在范围内</span></span><br><span class="line">            <span class="comment">// 检查左右子树</span></span><br><span class="line">            <span class="keyword">return</span> <span class="title function_">validate</span>(node.<span class="property">left</span>, low, node.<span class="property">val</span>) &amp;&amp; <span class="title function_">validate</span>(node.<span class="property">right</span>, node.<span class="property">val</span>, high);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始范围 (-Infinity, Infinity)</span></span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">validate</span>(root, -<span class="title class_">Infinity</span>, <span class="title class_">Infinity</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h4 id="二叉树最大差值"><a href="#二叉树最大差值" class="headerlink" title="二叉树最大差值"></a>二叉树最大差值</h4><blockquote><p><a href="https://leetcode.com/problems/maximum-difference-between-node-and-ancestor/">Leetcode 1026. Maximum Difference Between Node and Ancestor</a></p></blockquote><ul><li>题目: 找到二叉树中任意节点与其祖先节点值之间的最大差值<ul><li>祖先节点: 从根节点到当前节点路径上的任意节点</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: root = [8,3,10,1,6,null,14,null,null,4,7,13]</span><br><span class="line">Output: 7</span><br><span class="line"></span><br><span class="line">差值最大的一对节点是: 8 和 1，差值为 7</span><br></pre></td></tr></table></figure><ul><li>解法: 深度优先搜索（<code>DFS</code>）</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 使用递归（DFS）遍历二叉树</span><br><span class="line">2. 在递归过程中维护当前路径上的最小值和最大值</span><br><span class="line">3. 每到一个节点</span><br><span class="line">    - 更新路径的最小值和最大值</span><br><span class="line">    - 计算当前节点值与路径最小值或最大值的差值</span><br><span class="line">4. 遍历整棵树，返回最大差值</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxAncestorDiff</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">maxDiff</span>(<span class="params">node, curr_min, curr_max</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node: <span class="comment"># 如果节点为空，返回当前差值</span></span><br><span class="line">                <span class="keyword">return</span> curr_max - curr_min</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 更新当前路径的最小值和最大值</span></span><br><span class="line">            curr_min = <span class="built_in">min</span>(curr_min, node.val)</span><br><span class="line">            curr_max = <span class="built_in">max</span>(curr_max, node.val)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 递归左子树和右子树，计算最大差值</span></span><br><span class="line">            left_diff = maxDiff(node.left, curr_min, curr_max)</span><br><span class="line">            right_diff = maxDiff(node.right, curr_min, curr_max)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 返回左右子树中差值的最大值</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">max</span>(left_diff, right_diff)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 从根节点开始，初始最小值和最大值为根节点的值</span></span><br><span class="line">        <span class="keyword">return</span> maxDiff(root, root.val, root.val)</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">maxAncestorDiff</span>(<span class="params">root</span>) &#123;</span><br><span class="line">        <span class="keyword">function</span> <span class="title function_">maxDiff</span>(<span class="params">node, currMin, currMax</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!node) <span class="keyword">return</span> currMax - currMin; <span class="comment">// 返回当前差值</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 更新路径中的最小值和最大值</span></span><br><span class="line">            currMin = <span class="title class_">Math</span>.<span class="title function_">min</span>(currMin, node.<span class="property">val</span>);</span><br><span class="line">            currMax = <span class="title class_">Math</span>.<span class="title function_">max</span>(currMax, node.<span class="property">val</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 递归左右子树，计算最大差值</span></span><br><span class="line">            <span class="keyword">const</span> leftDiff = <span class="title function_">maxDiff</span>(node.<span class="property">left</span>, currMin, currMax);</span><br><span class="line">            <span class="keyword">const</span> rightDiff = <span class="title function_">maxDiff</span>(node.<span class="property">right</span>, currMin, currMax);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 返回左右子树中差值的最大值</span></span><br><span class="line">            <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">max</span>(leftDiff, rightDiff);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始最小值和最大值为根节点的值</span></span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">maxDiff</span>(root, root.<span class="property">val</span>, root.<span class="property">val</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h4 id="不同二叉搜索树的数量"><a href="#不同二叉搜索树的数量" class="headerlink" title="不同二叉搜索树的数量"></a>不同二叉搜索树的数量</h4><blockquote><p><a href="https://leetcode.com/problems/unique-binary-search-trees/">Leetcode 96. Unique Binary Search Trees</a></p></blockquote><ul><li>题目: 给定一个整数<code>n</code>，表示从<code>1</code>到<code>n</code>的节点，计算可以形成的不同二叉搜索树（<code>BST</code>）的数量</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: n = 3</span><br><span class="line">Output: 5</span><br><span class="line"></span><br><span class="line">   1         3     3      2      1</span><br><span class="line">    \       /     /      / \      \</span><br><span class="line">     3     2     1      1   3      2</span><br><span class="line">    /     /       \                 \</span><br><span class="line">   2     1         2                 3</span><br></pre></td></tr></table></figure><ul><li>解法: 动态规划 (卡特兰数公式)</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 定义 G[i] 表示由 i 个节点可以构成的不同二叉搜索树的数量</span><br><span class="line">2. 初始条件</span><br><span class="line">    - G[0] = 1（空树有 1 种情况）</span><br><span class="line">    - G[1] = 1（只有一个节点也只有 1 种情况）</span><br><span class="line">3. 递推公式</span><br><span class="line">    - G[i] = Σ G[j-1] * G[i-j]</span><br><span class="line">    - 即选择第 j 个节点为根时</span><br><span class="line">        - 左子树有 j-1 个节点，数量为 G[j-1]</span><br><span class="line">        - 右子树有 i-j 个节点，数量为 G[i-j]</span><br><span class="line">    - 对所有可能的根节点 j 求和</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">numTrees</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># G[i] 表示 i 个节点的不同二叉搜索树数量</span></span><br><span class="line">        G = [<span class="number">0</span>] * (n + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 初始条件</span></span><br><span class="line">        G[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        G[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 动态规划计算 G[2] 到 G[n]</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, i + <span class="number">1</span>):</span><br><span class="line">                G[i] += G[j - <span class="number">1</span>] * G[i - j]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> G[n]</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">numTrees</span>(<span class="params">n</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> G = <span class="keyword">new</span> <span class="title class_">Array</span>(n + <span class="number">1</span>).<span class="title function_">fill</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始条件</span></span><br><span class="line">        G[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        G[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 动态规划计算 G[2] 到 G[n]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>; j &lt;= i; j++) &#123;</span><br><span class="line">                G[i] += G[j - <span class="number">1</span>] * G[i - j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> G[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h4 id="检查二叉树是否平衡"><a href="#检查二叉树是否平衡" class="headerlink" title="检查二叉树是否平衡"></a>检查二叉树是否平衡</h4><blockquote><p><a href="https://leetcode.com/problems/balanced-binary-tree/">Leetcode 110. Balanced Binary Tree</a></p></blockquote><ul><li>题目: 给定一个二叉树，判断它是否是高度平衡的<ul><li>平衡二叉树的定义是: 二叉树的任意节点的左右子树高度差不超过<code>1</code></li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: root = [3,9,20,null,null,15,7]</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><ul><li>解法: 深度优先搜索 (<code>DFS</code>)</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 使用递归函数 dfs(node)</span><br><span class="line">   - 如果节点为空，返回平衡状态 True 和高度 0</span><br><span class="line">   - 递归检查左右子树，计算它们的平衡状态和高度</span><br><span class="line">2. 当前节点是否平衡</span><br><span class="line">   - 左右子树都平衡</span><br><span class="line">   - 左右子树高度差不超过 1</span><br><span class="line">3. 返回当前节点的平衡状态和高度</span><br><span class="line">4. 检查根节点的平衡状态</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isBalanced</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">node</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span>, <span class="number">0</span> <span class="comment"># [是否平衡, 高度]</span></span><br><span class="line">            </span><br><span class="line">            left_balanced, left_height = dfs(node.left)</span><br><span class="line">            right_balanced, right_height = dfs(node.right)</span><br><span class="line"></span><br><span class="line">            balanced = left_balanced <span class="keyword">and</span> right_balanced <span class="keyword">and</span> <span class="built_in">abs</span>(left_height - right_height) &lt;= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            height = <span class="built_in">max</span>(left_height, right_height) + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> balanced, height</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dfs(root)[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">isBalanced</span>(<span class="params">root</span>) &#123;</span><br><span class="line">        <span class="keyword">function</span> <span class="title function_">dfs</span>(<span class="params">node</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!node) <span class="keyword">return</span> [<span class="literal">true</span>, <span class="number">0</span>]; <span class="comment">// [是否平衡, 高度]</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">const</span> [leftBalanced, leftHeight] = <span class="title function_">dfs</span>(node.<span class="property">left</span>);</span><br><span class="line">            <span class="keyword">const</span> [rightBalanced, rightHeight] = <span class="title function_">dfs</span>(node.<span class="property">right</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> balanced = leftBalanced &amp;&amp; rightBalanced &amp;&amp; <span class="title class_">Math</span>.<span class="title function_">abs</span>(leftHeight - rightHeight) &lt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> height = <span class="title class_">Math</span>.<span class="title function_">max</span>(leftHeight, rightHeight) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> [balanced, height];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">dfs</span>(root)[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h4 id="二叉搜索树第k小的节点"><a href="#二叉搜索树第k小的节点" class="headerlink" title="二叉搜索树第k小的节点"></a>二叉搜索树第<code>k</code>小的节点</h4><blockquote><p><a href="https://leetcode.com/problems/kth-smallest-element-in-a-bst/">Leetcode 230. Kth Smallest Element in a BST</a></p></blockquote><ul><li>题目: 给定一棵二叉搜索树的根节点<code>root</code>，以及一个整数<code>k</code>，请返回该二叉搜索树中第<code>k</code>小的节点值</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: root = [3,1,4,null,2], k = 1</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure><ul><li>解法: 中序遍历 (<code>In-order Traversal</code>)</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 中序遍历二叉搜索树，按升序访问节点值</span><br><span class="line">2. 计数每访问一个节点，当计数等于 k 时，返回该节点值</span><br><span class="line">3. 使用递归实现中序遍历</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">kthSmallest</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        count = <span class="number">0</span> <span class="comment"># 计数器</span></span><br><span class="line">        result = <span class="literal">None</span> <span class="comment"># 结果存储</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">inorder</span>(<span class="params">node</span>):</span><br><span class="line">            <span class="keyword">nonlocal</span> count, result</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 遍历左子树</span></span><br><span class="line">            inorder(node.left)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 处理当前节点</span></span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> count == k:</span><br><span class="line">                result = node.val</span><br><span class="line">                <span class="keyword">return</span> </span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 遍历右子树</span></span><br><span class="line">            inorder(node.right)</span><br><span class="line"></span><br><span class="line">        inorder(root)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">kthSmallest</span>(<span class="params">root, k</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> count = <span class="number">0</span>; <span class="comment">// 计数器</span></span><br><span class="line">        <span class="keyword">let</span> result = <span class="literal">null</span>; <span class="comment">// 结果存储</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">function</span> <span class="title function_">inorder</span>(<span class="params">node</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!node) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 遍历左子树</span></span><br><span class="line">            <span class="title function_">inorder</span>(node.<span class="property">left</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 处理当前节点</span></span><br><span class="line">            count += <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (count === k) &#123;</span><br><span class="line">                result = node.<span class="property">val</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 遍历右子树</span></span><br><span class="line">            <span class="title function_">inorder</span>(node.<span class="property">right</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="title function_">inorder</span>(root);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h4 id="二叉树展开为链表"><a href="#二叉树展开为链表" class="headerlink" title="二叉树展开为链表"></a>二叉树展开为链表</h4><blockquote><p><a href="https://leetcode.com/problems/flatten-binary-tree-to-linked-list/">Leetcode 114. Flatten Binary Tree to Linked List</a></p></blockquote><ul><li>题目: 将二叉树展开为链表，要求“就地”修改树的结构，使其变为一个单链表形式，顺序与前序遍历一致</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: root = [1,2,5,3,4,null,6]</span><br><span class="line">Output: [1,null,2,null,3,null,4,null,5,null,6]</span><br></pre></td></tr></table></figure><ul><li>解法: 递归</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 递归处理左子树和右子树，将它们分别扁平化</span><br><span class="line">2. 保存右子树，并将左子树移到右子树的位置，将左子树置为 None</span><br><span class="line">3. 找到左子树的最右节点，将保存的右子树接到这个节点上</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">flatten</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 递归处理左子树和右子树</span></span><br><span class="line">        self.flatten(root.left)</span><br><span class="line">        self.flatten(root.right)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 保存右子树</span></span><br><span class="line">        right_subtree = root.right</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 将左子树移动到右子树的位置</span></span><br><span class="line">        root.right = root.left</span><br><span class="line">        root.left = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 找到左子树的最右节点</span></span><br><span class="line">        curr = root</span><br><span class="line">        <span class="keyword">while</span> curr.right:</span><br><span class="line">            curr = curr.right</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 将保存的右子树接到最右节点</span></span><br><span class="line">        curr.right = right_subtree</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">flatten</span>(<span class="params">root</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 递归处理左子树和右子树</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">flatten</span>(root.<span class="property">left</span>);</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">flatten</span>(root.<span class="property">right</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 保存右子树</span></span><br><span class="line">        <span class="keyword">const</span> rightSubtree = root.<span class="property">right</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将左子树移动到右子树的位置</span></span><br><span class="line">        root.<span class="property">right</span> = root.<span class="property">left</span>;</span><br><span class="line">        root.<span class="property">left</span> = <span class="literal">null</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 找到左子树的最右节点</span></span><br><span class="line">        <span class="keyword">let</span> curr = root;</span><br><span class="line">        <span class="keyword">while</span> (curr.<span class="property">right</span>)</span><br><span class="line">            curr = curr.<span class="property">right</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将保存的右子树接到最右节点</span></span><br><span class="line">        curr.<span class="property">right</span> = rightSubtree;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h4 id="二叉搜索树的最近公共祖先"><a href="#二叉搜索树的最近公共祖先" class="headerlink" title="二叉搜索树的最近公共祖先"></a>二叉搜索树的最近公共祖先</h4><blockquote><p><a href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/">Leetcode 235. Lowest Common Ancestor of a Binary Search Tree</a></p></blockquote><ul><li>题目: 在一个二叉搜索树（<code>BST</code>）中，给定两个节点<code>p</code>和<code>q</code>，找到它们的最近公共祖先（<code>LCA</code>）</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: root = [5,3,8,1,4,7,9,null,2], p = 3, q = 8</span><br><span class="line">Output: 5</span><br><span class="line">Explanation: 节点 5 是节点 3 和 8 的最近公共祖先</span><br></pre></td></tr></table></figure><ul><li>解法: 利用二叉搜索树的性质</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 从根节点开始遍历</span><br><span class="line">2. 如果 p 和 q 的值都小于当前节点值，则往左子树继续查找</span><br><span class="line">3. 如果 p 和 q 的值都大于当前节点值，则往右子树继续查找</span><br><span class="line">4. 如果 p 和 q 的值分别位于当前节点的两侧，或者当前节点值等于其中一个节点值，则当前节点为最近公共祖先</span><br></pre></td></tr></table></figure><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">Python</button></li><li class="tab"><button type="button" data-href="#test-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lowestCommonAncestor</span>(<span class="params">self, root: <span class="string">&#x27;TreeNode&#x27;</span>, p: <span class="string">&#x27;TreeNode&#x27;</span>, q: <span class="string">&#x27;TreeNode&#x27;</span></span>) -&gt; <span class="string">&#x27;TreeNode&#x27;</span>:</span><br><span class="line">        <span class="keyword">while</span> root:</span><br><span class="line">            <span class="keyword">if</span> root.val &gt; p.val <span class="keyword">and</span> root.val &gt; q.val:</span><br><span class="line">                root = root.left <span class="comment"># p 和 q 都在左子树</span></span><br><span class="line">            <span class="keyword">elif</span> root.val &lt; p.val <span class="keyword">and</span> root.val &lt; q.val:</span><br><span class="line">                root = root.right <span class="comment"># p 和 q 都在右子树</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> root <span class="comment"># 当前节点是最近公共祖先</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">lowestCommonAncestor</span>(<span class="params">root, p, q</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (root) &#123;</span><br><span class="line">            <span class="keyword">if</span> (root.<span class="property">val</span> &gt; p.<span class="property">val</span> &amp;&amp; root.<span class="property">val</span> &gt; q.<span class="property">val</span>)</span><br><span class="line">                root = root.<span class="property">left</span>; <span class="comment">// p 和 q 都在左子树</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (root.<span class="property">val</span> &lt; p.<span class="property">val</span> &amp;&amp; root.<span class="property">val</span> &lt; q.<span class="property">val</span>)</span><br><span class="line">                root = root.<span class="property">right</span>; <span class="comment">// p 和 q 都在右子树</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> root; <span class="comment">// 当前节点是最近公共祖先</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h4 id="对称二叉树"><a href="#对称二叉树" class="headerlink" title="对称二叉树"></a>对称二叉树</h4><blockquote><p><a href="https://leetcode.com/problems/symmetric-tree/">Leetcode 101. Symmetric Tree</a></p></blockquote><ul><li>题目: 判断给定的二叉树是否是对称的。如果一棵树的左子树和右子树是镜像对称的，则这棵树是对称</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: root = [1,2,2,3,4,4,3]</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><ul><li>解法: 递归</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 如果树为空，返回 True</span><br><span class="line">2. 定义一个辅助函数 isMirror，判断两个节点是否对称</span><br><span class="line">   - 如果两个节点都为空，返回 True</span><br><span class="line">   - 如果只有一个节点为空，返回 False</span><br><span class="line">   - 判断两个节点的值是否相等，并递归判断它们的左右子节点是否对称</span><br><span class="line">3. 调用 isMirror(root.left, root.right)</span><br></pre></td></tr></table></figure><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">Python</button></li><li class="tab"><button type="button" data-href="#test-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isSymmetric</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">isMirror</span>(<span class="params">t1, t2</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> t1 <span class="keyword">and</span> <span class="keyword">not</span> t2:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> t1 <span class="keyword">or</span> <span class="keyword">not</span> t2:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">return</span> t1.val == t2.val <span class="keyword">and</span> isMirror(t1.right, t2.left) <span class="keyword">and</span> isMirror(t1.left, t2.right)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> isMirror(root, root)</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">isSymmetric</span>(<span class="params">root</span>) &#123;</span><br><span class="line">        <span class="keyword">function</span> <span class="title function_">isMirror</span>(<span class="params">t1, t2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!t1 &amp;&amp; !t2) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (!t1 || !t2) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> t1.<span class="property">val</span> === t2.<span class="property">val</span> &amp;&amp; <span class="title function_">isMirror</span>(t1.<span class="property">right</span>, t2.<span class="property">left</span>) &amp;&amp; <span class="title function_">isMirror</span>(t1.<span class="property">left</span>, t2.<span class="property">right</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">isMirror</span>(root, root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h4 id="存在路径总和"><a href="#存在路径总和" class="headerlink" title="存在路径总和"></a>存在路径总和</h4><blockquote><p><a href="https://leetcode.com/problems/path-sum/">Leetcode 112. Path Sum</a></p></blockquote><ul><li>题目: 给定一个二叉树和一个目标和，判断树中是否存在从根节点到叶子节点的路径，使得路径上的所有节点值相加等于目标和</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22</span><br><span class="line">Output: true</span><br><span class="line">Explanation: The path 5 → 4 → 11 → 2 has a sum of 22</span><br></pre></td></tr></table></figure><ul><li>解法: 深度优先搜索</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 从根节点出发，递归地检查左右子树</span><br><span class="line">2. 在每次递归中，将目标值减去当前节点的值</span><br><span class="line">3. 当到达叶子节点时，检查剩余目标值是否为 0</span><br><span class="line">4. 如果找到一条路径符合条件，则返回 True；否则继续搜索</span><br></pre></td></tr></table></figure><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">Python</button></li><li class="tab"><button type="button" data-href="#test-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hasPathSum</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], targetSum: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 减去当前节点值</span></span><br><span class="line">        targetSum -= root.val</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 检查是否是叶子节点并且目标值为</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right:</span><br><span class="line">            <span class="keyword">return</span> targetSum == <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 递归检查左右子树</span></span><br><span class="line">        <span class="keyword">return</span> self.hasPathSum(root.left, targetSum) <span class="keyword">or</span> self.hasPathSum(root.right, targetSum)</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">hasPathSum</span>(<span class="params">root, targetSum</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 减去当前节点值</span></span><br><span class="line">        targetSum -= root.<span class="property">val</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查是否是叶子节点并且目标值为0</span></span><br><span class="line">        <span class="keyword">if</span> (!root.<span class="property">left</span> &amp;&amp; !root.<span class="property">right</span>)</span><br><span class="line">            <span class="keyword">return</span> targetSum === <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 递归检查左右子树</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">hasPathSum</span>(root.<span class="property">left</span>, targetSum) || <span class="variable language_">this</span>.<span class="title function_">hasPathSum</span>(root.<span class="property">right</span>, targetSum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h4 id="所有路径总和"><a href="#所有路径总和" class="headerlink" title="所有路径总和"></a>所有路径总和</h4><blockquote><p><a href="https://leetcode.com/problems/path-sum-ii/">Leetcode 113. Path Sum II</a></p></blockquote><ul><li>题目: 给定一个二叉树和一个目标和，返回所有从根节点到叶子节点的路径，使得路径上的节点值之和等于目标和</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22</span><br><span class="line">Output: [[5,4,11,2],[5,8,4,5]]</span><br><span class="line">Explanation: The paths are:</span><br><span class="line">5 → 4 → 11 → 2</span><br><span class="line">5 → 8 → 4 → 5</span><br></pre></td></tr></table></figure><ul><li>解法: 深度优先搜索 + 回溯</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 使用递归深度优先搜索（DFS）遍历二叉树</span><br><span class="line">2. 在路径上记录当前节点值，减去当前节点值更新目标和</span><br><span class="line">3. 当到达叶子节点且目标和为 0 时，将当前路径加入结果</span><br><span class="line">4. 回溯时移除当前节点值，返回上一层递归继续搜索</span><br></pre></td></tr></table></figure><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">Python</button></li><li class="tab"><button type="button" data-href="#test-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pathSum</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], targetSum: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        result = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">node, current_path, remaining_sum</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 添加当前节点值到路径</span></span><br><span class="line">            current_path.append(node.val)</span><br><span class="line">            remaining_sum -= node.val</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 如果是叶子节点且目标和为0，保存路径</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node.left <span class="keyword">and</span> <span class="keyword">not</span> node.right <span class="keyword">and</span> remaining_sum == <span class="number">0</span>:</span><br><span class="line">                result.append(<span class="built_in">list</span>(current_path))</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 递归遍历左右子树</span></span><br><span class="line">            dfs(node.left, current_path, remaining_sum)</span><br><span class="line">            dfs(node.right, current_path, remaining_sum)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 回溯</span></span><br><span class="line">            current_path.pop()</span><br><span class="line">        </span><br><span class="line">        dfs(root, [], targetSum)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">pathSum</span>(<span class="params">root, targetSum</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> result = [];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">function</span> <span class="title function_">dfs</span>(<span class="params">node, currentPath, remainingSum</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!node) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 添加当前节点值到路径</span></span><br><span class="line">            currentPath.<span class="title function_">push</span>(node.<span class="property">val</span>);</span><br><span class="line">            remainingSum -= node.<span class="property">val</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果是叶子节点且目标和为0，保存路径</span></span><br><span class="line">            <span class="keyword">if</span> (!node.<span class="property">left</span> &amp;&amp; !node.<span class="property">right</span> &amp;&amp; remainingSum === <span class="number">0</span>)</span><br><span class="line">                result.<span class="title function_">push</span>([...currentPath]);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 递归遍历左右子树</span></span><br><span class="line">            <span class="title function_">dfs</span>(node.<span class="property">left</span>, currentPath, remainingSum);</span><br><span class="line">            <span class="title function_">dfs</span>(node.<span class="property">right</span>, currentPath, remainingSum);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 回溯</span></span><br><span class="line">            currentPath.<span class="title function_">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="title function_">dfs</span>(root, [], targetSum);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h3 id="Matrix-矩阵"><a href="#Matrix-矩阵" class="headerlink" title="Matrix 矩阵"></a><code>Matrix</code> 矩阵</h3><h4 id="螺旋矩阵"><a href="#螺旋矩阵" class="headerlink" title="螺旋矩阵"></a>螺旋矩阵</h4><blockquote><p><a href="https://leetcode.com/problems/spiral-matrix/">Leetcode 54. Spiral Matrix</a></p></blockquote><ul><li>题目: 按照螺旋顺序输出矩阵中的所有元素</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: matrix = [[1,2,3],[4,5,6],[7,8,9]]</span><br><span class="line">Output: [1,2,3,6,9,8,7,4,5]</span><br></pre></td></tr></table></figure><ul><li>解法: 逐层遍历</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 初始化矩阵的边界</span><br><span class="line">    - 上边界 top，初始为 0</span><br><span class="line">    - 下边界 bottom，初始为矩阵的行数 - 1</span><br><span class="line">    - 左边界 left，初始为 0</span><br><span class="line">    - 右边界 right，初始为矩阵的列数 - 1</span><br><span class="line">2. 按照螺旋顺序</span><br><span class="line">    - 从左到右遍历最上面一行</span><br><span class="line">    - 从上到下遍历最右边一列</span><br><span class="line">    - 从右到左遍历最下面一行（如果还有剩余行）</span><br><span class="line">    - 从下到上遍历最左边一列（如果还有剩余列）</span><br><span class="line">3. 每遍历一层后缩小边界，直到遍历完整个矩阵</span><br></pre></td></tr></table></figure><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">Python</button></li><li class="tab"><button type="button" data-href="#test-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">spiralOrder</span>(<span class="params">self, matrix: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        top, bottom = <span class="number">0</span>, <span class="built_in">len</span>(matrix) - <span class="number">1</span></span><br><span class="line">        left, right = <span class="number">0</span>, <span class="built_in">len</span>(matrix[<span class="number">0</span>]) - <span class="number">1</span></span><br><span class="line">        result = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> top &lt;= bottom <span class="keyword">and</span> left &lt;= right:</span><br><span class="line">            <span class="comment"># 从左到右遍历最上面一行</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(left, right + <span class="number">1</span>):</span><br><span class="line">                result.append(matrix[top][i])</span><br><span class="line">            top += <span class="number">1</span>  <span class="comment"># 上边界向下移动</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 从上到下遍历最右边一列</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(top, bottom + <span class="number">1</span>):</span><br><span class="line">                result.append(matrix[i][right])</span><br><span class="line">            right -= <span class="number">1</span>  <span class="comment"># 右边界向左移动</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> top &lt;= bottom:</span><br><span class="line">                <span class="comment"># 从右到左遍历最下面一行</span></span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(right, left - <span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                    result.append(matrix[bottom][i])</span><br><span class="line">                bottom -= <span class="number">1</span>  <span class="comment"># 下边界向上移动</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> left &lt;= right:</span><br><span class="line">                <span class="comment"># 从下到上遍历最左边一列</span></span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(bottom, top - <span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                    result.append(matrix[i][left])</span><br><span class="line">                left += <span class="number">1</span>  <span class="comment"># 左边界向右移动</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">spiralOrder</span>(<span class="params">matrix</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> top = <span class="number">0</span>, bottom = matrix.<span class="property">length</span> - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">let</span> left = <span class="number">0</span>, right = matrix[<span class="number">0</span>].<span class="property">length</span> - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">let</span> result = [];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> ((top &lt;= bottom) &amp;&amp; (left &lt;= right)) &#123;</span><br><span class="line">            <span class="comment">// 从左到右遍历最上面一行</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = left; i &lt; right + <span class="number">1</span>; i++)</span><br><span class="line">                result.<span class="title function_">push</span>(matrix[top][i]);</span><br><span class="line">            top += <span class="number">1</span>; <span class="comment">// 上边界向下移动</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 从上到下遍历最右边一列</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> j = top; j &lt; bottom + <span class="number">1</span>; j++)</span><br><span class="line">                result.<span class="title function_">push</span>(matrix[j][right]);</span><br><span class="line">            right -= <span class="number">1</span>; <span class="comment">// 右边界向左移动</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (top &lt;= bottom) &#123;</span><br><span class="line">                <span class="comment">// 从右到左遍历最下面一行</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">let</span> i = right; i &gt; left - <span class="number">1</span>; i--)</span><br><span class="line">                    result.<span class="title function_">push</span>(matrix[bottom][i]);</span><br><span class="line">                bottom -= <span class="number">1</span>; <span class="comment">// 下边界向上移动</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (left &lt;= right) &#123;</span><br><span class="line">                <span class="comment">// 从下到上遍历最左边一列</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">let</span> j = bottom; j &gt; top - <span class="number">1</span>; j--)</span><br><span class="line">                    result.<span class="title function_">push</span>(matrix[j][left]);</span><br><span class="line">                left += <span class="number">1</span>; <span class="comment">// 左边界向右移动</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h4 id="有效数独"><a href="#有效数独" class="headerlink" title="有效数独"></a>有效数独</h4><blockquote><p><a href="https://leetcode.com/problems/valid-sudoku/">Leetcode 36. Valid Sudoku</a></p></blockquote><ul><li>题目: 给定一个<code>9x9</code>的数独棋盘，验证该棋盘是否有效<ul><li>每行数字不能重复</li><li>每列数字不能重复</li><li>每个<code>3x3</code>方块中的数字不能重复</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: board = </span><br><span class="line">[[&quot;5&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;]</span><br><span class="line">,[&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;]</span><br><span class="line">,[&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;]</span><br><span class="line">,[&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;]</span><br><span class="line">,[&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;]</span><br><span class="line">,[&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;]</span><br><span class="line">,[&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;]</span><br><span class="line">,[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;]</span><br><span class="line">,[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]]</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><ul><li>解法: 哈希表</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 使用三个哈希表分别记录</span><br><span class="line">    - 每行中已出现的数字</span><br><span class="line">    - 每列中已出现的数字</span><br><span class="line">    - 每个 3x3 方块中已出现的数字</span><br><span class="line">2. 遍历整个棋盘</span><br><span class="line">    - 如果遇到 .，跳过</span><br><span class="line">    - 检查数字是否已存在于当前行、列或对应的 3x3 方块中</span><br><span class="line">    - 如果存在，返回 False</span><br><span class="line">    - 如果不存在，添加到相应的哈希表中</span><br><span class="line">3. 遍历结束后，若未发现冲突，返回 True</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isValidSudoku</span>(<span class="params">board: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="comment"># 哈希表记录每行、每列和每个 3x3 方块的数字</span></span><br><span class="line">        rows = collections.defaultdict(<span class="built_in">set</span>)</span><br><span class="line">        cols = collections.defaultdict(<span class="built_in">set</span>)</span><br><span class="line">        squares = collections.defaultdict(<span class="built_in">set</span>) <span class="comment"># 键为 (r//3, c//3)</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> r <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">                num = board[r][c]</span><br><span class="line">                <span class="keyword">if</span> num == <span class="string">&quot;.&quot;</span>:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">                <span class="comment"># 检查当前数字是否已存在</span></span><br><span class="line">                <span class="keyword">if</span> num <span class="keyword">in</span> rows[r] <span class="keyword">or</span> num <span class="keyword">in</span> cols[c] <span class="keyword">or</span> num <span class="keyword">in</span> squares[(r // <span class="number">3</span>, c // <span class="number">3</span>)]:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">                <span class="comment"># 添加数字到对应哈希表</span></span><br><span class="line">                rows[r].add(num)</span><br><span class="line">                cols[c].add(num)</span><br><span class="line">                squares[((r // <span class="number">3</span>, c // <span class="number">3</span>))].add(num)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">isValidSudoku</span>(<span class="params">board</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> rows = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">9</span>).<span class="title function_">fill</span>(<span class="number">0</span>).<span class="title function_">map</span>(<span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="title class_">Set</span>());</span><br><span class="line">        <span class="keyword">const</span> cols = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">9</span>).<span class="title function_">fill</span>(<span class="number">0</span>).<span class="title function_">map</span>(<span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="title class_">Set</span>());</span><br><span class="line">        <span class="keyword">const</span> squares = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">9</span>).<span class="title function_">fill</span>(<span class="number">0</span>).<span class="title function_">map</span>(<span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="title class_">Set</span>());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> r = <span class="number">0</span>; r &lt; <span class="number">9</span>; r++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> c = <span class="number">0</span>; c &lt; <span class="number">9</span>; c++) &#123;</span><br><span class="line">                <span class="keyword">const</span> num = board[r][c];</span><br><span class="line">                <span class="keyword">if</span> (num === <span class="string">&quot;.&quot;</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">const</span> squareIndex = <span class="title class_">Math</span>.<span class="title function_">floor</span>(r / <span class="number">3</span>) * <span class="number">3</span> + <span class="title class_">Math</span>.<span class="title function_">floor</span>(c / <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (rows[r].<span class="title function_">has</span>(num) || cols[c].<span class="title function_">has</span>(num) || squares[squareIndex].<span class="title function_">has</span>(num))</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">                rows[r].<span class="title function_">add</span>(num);</span><br><span class="line">                cols[c].<span class="title function_">add</span>(num);</span><br><span class="line">                squares[squareIndex].<span class="title function_">add</span>(num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h4 id="最大岛屿面积"><a href="#最大岛屿面积" class="headerlink" title="最大岛屿面积"></a>最大岛屿面积</h4><blockquote><p><a href="https://leetcode.com/problems/max-area-of-island/">Leetcode 695. Max Area of Island</a></p></blockquote><ul><li>题目: 给定一个二维网格<code>grid</code>，其中<code>0</code>表示水域，<code>1</code>表示陆地，计算网格中最大的岛屿面积。岛屿由上下左右四个方向相连的陆地组成</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: grid = [[0,0,1,0,0,0,0,1,0,0,0,0,0],</span><br><span class="line">               [0,0,0,0,0,0,0,1,1,1,0,0,0],</span><br><span class="line">               [0,1,1,0,1,0,0,0,0,0,0,0,0],</span><br><span class="line">               [0,1,0,0,1,1,0,0,1,0,1,0,0],</span><br><span class="line">               [0,1,0,0,1,1,0,0,1,1,1,0,0],</span><br><span class="line">               [0,0,0,0,0,0,0,0,0,0,1,0,0],</span><br><span class="line">               [0,0,0,0,0,0,0,1,1,1,0,0,0],</span><br><span class="line">               [0,0,0,0,0,0,0,1,1,0,0,0,0]]</span><br><span class="line">Output: 6</span><br></pre></td></tr></table></figure><ul><li>解法: 深度优先搜索（<code>DFS</code>）</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 遍历整个网格</span><br><span class="line">2. 遇到 1 时，启动 DFS 计算连通岛屿的面积</span><br><span class="line">3. 将访问过的格子标记为 0，防止重复访问</span><br><span class="line">4. 更新最大岛屿面积</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxAreaOfIsland</span>(<span class="params">self, grid: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 定义 DFS 函数，遍历岛屿</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">i, j</span>):</span><br><span class="line">            <span class="comment"># 如果超出边界或当前位置不是岛屿，返回 0</span></span><br><span class="line">            <span class="keyword">if</span> i &lt; <span class="number">0</span> <span class="keyword">or</span> i &gt;= <span class="built_in">len</span>(grid) <span class="keyword">or</span> j &lt; <span class="number">0</span> <span class="keyword">or</span> j &gt;= <span class="built_in">len</span>(grid[<span class="number">0</span>]) <span class="keyword">or</span> grid[i][j] == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">            grid[i][j] = <span class="number">0</span> <span class="comment"># 标记为已访问</span></span><br><span class="line">            <span class="comment"># 递归地访问上下左右</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> + dfs(i + <span class="number">1</span>, j) + dfs(i - <span class="number">1</span>, j) + dfs(i, j + <span class="number">1</span>) + dfs(i, j - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        max_area = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(grid)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(grid[<span class="number">0</span>])):</span><br><span class="line">                <span class="keyword">if</span> grid[i][j] == <span class="number">1</span>:</span><br><span class="line">                    max_area = <span class="built_in">max</span>(max_area, dfs(i, j)) <span class="comment"># 如果找到岛屿，启动 DFS</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> max_area</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">maxAreaOfIsland</span>(<span class="params">grid</span>) &#123;</span><br><span class="line">        <span class="keyword">function</span> <span class="title function_">dfs</span>(<span class="params">i, j</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果超出边界或当前位置不是岛屿，返回 0</span></span><br><span class="line">            <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= grid.<span class="property">lenght</span> || j &lt; <span class="number">0</span> || j &gt;= grid[<span class="number">0</span>].<span class="property">length</span> || grid[i][j] === <span class="number">0</span>) </span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            grid[i][j] = <span class="number">0</span>; <span class="comment">// 标记为已访问</span></span><br><span class="line">            <span class="comment">// 递归地访问上下左右</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> + <span class="title function_">dfs</span>(i + <span class="number">1</span>, j) + <span class="title function_">dfs</span>(i - <span class="number">1</span>, j) + <span class="title function_">dfs</span>(i, j + <span class="number">1</span>) + <span class="title function_">dfs</span>(i, j - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> maxArea = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; grid.<span class="property">length</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].<span class="property">length</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] === <span class="number">1</span>)</span><br><span class="line">                    maxArea = <span class="title class_">Math</span>.<span class="title function_">max</span>(maxArea, <span class="title function_">dfs</span>(i, j));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxArea;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h3 id="Array-数组"><a href="#Array-数组" class="headerlink" title="Array 数组"></a><code>Array</code> 数组</h3><h4 id="轮转数组"><a href="#轮转数组" class="headerlink" title="轮转数组"></a>轮转数组</h4><blockquote><p><a href="https://leetcode.com/problems/rotate-array/">Leetcode 189. Rotate Array</a></p></blockquote><ul><li>题目: 给定一个数组，将其元素向右轮转<code>k</code>位，其中<code>k</code>是非负数</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: nums = [1,2,3,4,5,6,7], k = 3</span><br><span class="line">Output: [5,6,7,1,2,3,4]</span><br></pre></td></tr></table></figure><ul><li>解法: 翻转法</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 翻转整个数组</span><br><span class="line">2. 翻转前 k 个元素</span><br><span class="line">3. 翻转剩余的元素</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">rotate</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        k %= n <span class="comment"># 处理 k 大于数组长度的情况</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 翻转数组的辅助函数</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">reverse</span>(<span class="params">start, end</span>):</span><br><span class="line">            <span class="keyword">while</span> start &lt; end:</span><br><span class="line">                nums[start], nums[end] = nums[end], nums[start]</span><br><span class="line">                start += <span class="number">1</span></span><br><span class="line">                end -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 1. 翻转整个数组</span></span><br><span class="line">        reverse(<span class="number">0</span>, n - <span class="number">1</span>)</span><br><span class="line">        <span class="comment"># 2. 翻转前 k 个元素</span></span><br><span class="line">        reverse(<span class="number">0</span>, k - <span class="number">1</span>)</span><br><span class="line">        <span class="comment"># 3. 翻转剩下的元素</span></span><br><span class="line">        reverse(k, n - <span class="number">1</span>)</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">rotate</span>(<span class="params">nums, k</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> n = nums.<span class="property">length</span>;</span><br><span class="line">        k %= n; <span class="comment">// 处理 k 大于数组长度的情况</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">function</span> <span class="title function_">reverse</span>(<span class="params">start, end</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">                [nums[start], nums[end]] = [nums[end], nums[start]];</span><br><span class="line">                start++;</span><br><span class="line">                end--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 翻转整个数组</span></span><br><span class="line">        <span class="title function_">reverse</span>(<span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 2. 翻转前 k 个元素</span></span><br><span class="line">        <span class="title function_">reverse</span>(<span class="number">0</span>, k - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 3. 翻转剩下的元素</span></span><br><span class="line">        <span class="title function_">reverse</span>(k, n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h4 id="数组转树"><a href="#数组转树" class="headerlink" title="数组转树"></a>数组转树</h4><blockquote><p><a href="https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/">Leetcode 108. Convert Sorted Array to Binary Search Tree</a></p></blockquote><ul><li>题目: 将一个有序数组转换为一棵高度平衡的二叉搜索树（<code>BST</code>）。高度平衡指的是树中每个节点的两个子树的高度差不超过<code>1</code></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: nums = [-10,-3,0,5,9]</span><br><span class="line">Output: [0,-3,9,-10,null,5]</span><br></pre></td></tr></table></figure><ul><li>解法: 递归构建</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 选择数组的中间元素作为当前子树的根节点。</span><br><span class="line">2. 左侧子数组递归构建左子树。</span><br><span class="line">3. 右侧子数组递归构建右子树。</span><br><span class="line">4. 当数组为空时，返回 None。</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sortedArrayToBST</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">        <span class="comment"># 如果数组为空，返回 None</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 找到中间元素并创建当前根节点</span></span><br><span class="line">        mid = <span class="built_in">len</span>(nums) // <span class="number">2</span></span><br><span class="line">        root = TreeNode(nums[mid])</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 构建左子树和右子树</span></span><br><span class="line">        root.left = self.sortedArrayToBST(nums[:mid])</span><br><span class="line">        root.right = self.sortedArrayToBST(nums[mid + <span class="number">1</span>:])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">sortedArrayToBST</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果数组为空，返回 null</span></span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="property">length</span> === <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找到中间元素并创建当前根节点</span></span><br><span class="line">        <span class="keyword">const</span> mid = <span class="title class_">Math</span>.<span class="title function_">floor</span>(nums.<span class="property">length</span> / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">const</span> root = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(nums[mid]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构建左子树和右子树</span></span><br><span class="line">        root.<span class="property">left</span> = <span class="variable language_">this</span>.<span class="title function_">sortedArrayToBST</span>(nums.<span class="title function_">slice</span>(<span class="number">0</span>, mid));</span><br><span class="line">        root.<span class="property">right</span> = <span class="variable language_">this</span>.<span class="title function_">sortedArrayToBST</span>(nums.<span class="title function_">slice</span>(mid + <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h4 id="合并两个有序数组"><a href="#合并两个有序数组" class="headerlink" title="合并两个有序数组"></a>合并两个有序数组</h4><blockquote><p><a href="https://leetcode.com/problems/merge-sorted-array/">Leetcode 88. Merge Sorted Array</a></p></blockquote><ul><li>题目: 将两个有序数组<code>nums1</code>和<code>nums2</code>合并为一个有序数组，其中<code>nums1</code>有足够的空间存放<code>nums2</code>的元素</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3</span><br><span class="line">Output: [1,2,2,3,5,6]</span><br></pre></td></tr></table></figure><ul><li>解法: 双指针从后往前合并</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 设置三个指针</span><br><span class="line">   - i 指向 nums1 的有效元素部分的末尾</span><br><span class="line">   - j 指向 nums2 的末尾</span><br><span class="line">   - k 指向 nums1 的末尾</span><br><span class="line">2. 比较 nums1 和 nums2 中的元素，将较大的元素填入 nums1 的末尾，指针向前移动</span><br><span class="line">3. 如果 nums2 还有剩余的元素，直接填入 nums1</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">merge</span>(<span class="params">self, nums1: <span class="type">List</span>[<span class="built_in">int</span>], m: <span class="built_in">int</span>, nums2: <span class="type">List</span>[<span class="built_in">int</span>], n: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="comment"># 指针 i 指向 nums1 的有效部分末尾，j 指向 nums2 末尾，k 指向 nums1 的总末尾</span></span><br><span class="line">        i, j, k = m - <span class="number">1</span>, n - <span class="number">1</span>, m + n - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 从后往前合并</span></span><br><span class="line">        <span class="keyword">while</span> i &gt;= <span class="number">0</span> <span class="keyword">and</span> j &gt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> nums1[i] &gt; nums2[j]:</span><br><span class="line">                nums1[k] = nums1[i]</span><br><span class="line">                i -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                nums1[k] = nums2[j]</span><br><span class="line">                j -= <span class="number">1</span></span><br><span class="line">            k -= <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 如果 nums2 还有剩余元素，填入 nums1</span></span><br><span class="line">        <span class="keyword">while</span> j &gt;= <span class="number">0</span>:</span><br><span class="line">            nums1[k] = nums2[j]</span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">            k -= <span class="number">1</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">merge</span>(<span class="params">nums1, m, nums2, n</span>) &#123;</span><br><span class="line">        <span class="comment">// 指针 i 指向 nums1 的有效部分末尾，j 指向 nums2 末尾，k 指向 nums1 的总末尾</span></span><br><span class="line">        <span class="keyword">let</span> i = m - <span class="number">1</span>, j = n - <span class="number">1</span>, k = m + n - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从后往前合并</span></span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums1[i] &gt; nums2[j]) &#123;</span><br><span class="line">                nums1[k] = nums1[i];</span><br><span class="line">                i--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                nums1[k] = nums2[j];</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            k--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果 nums2 还有剩余元素，填入 nums1</span></span><br><span class="line">        <span class="keyword">while</span> (j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            nums1[k] = nums2[j];</span><br><span class="line">            j--;</span><br><span class="line">            k--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h4 id="每日温度"><a href="#每日温度" class="headerlink" title="每日温度"></a>每日温度</h4><blockquote><p><a href="https://leetcode.com/problems/daily-temperatures/">Leetcode 739. Daily Temperatures</a></p></blockquote><ul><li>题目: 给定一个整数数组<code>temperatures</code>，表示每天的温度，返回一个数组<code>answer</code>，其中<code>answer[i]</code>是需要等待的天数，直到<code>temperatures[i]</code>之后出现更高的温度。如果没有更高的温度，<code>answer[i] = 0</code></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: temperatures = [73,74,75,71,69,72,76,73]</span><br><span class="line">Output: [1,1,4,2,1,1,0,0]</span><br></pre></td></tr></table></figure><ul><li>解法: 单调栈</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 使用栈存储温度的索引</span><br><span class="line">2. 遍历 temperatures：</span><br><span class="line">   - 如果当前温度高于栈顶索引对应的温度，弹出栈顶索引并计算等待天数</span><br><span class="line">   - 否则，将当前索引压入栈</span><br><span class="line">3. 最后栈中未处理的索引对应的等待天数为 0</span><br><span class="line">4. 时间复杂度 O(n)</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dailyTemperatures</span>(<span class="params">self, temperatures: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="comment"># 初始化结果数组和栈</span></span><br><span class="line">        result = [<span class="number">0</span>] * <span class="built_in">len</span>(temperatures)</span><br><span class="line">        stack = []</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 遍历温度数组</span></span><br><span class="line">        <span class="keyword">for</span> i, temp <span class="keyword">in</span> <span class="built_in">enumerate</span>(temperatures):</span><br><span class="line">            <span class="comment"># 如果当前温度比栈顶的温度高</span></span><br><span class="line">            <span class="keyword">while</span> stack <span class="keyword">and</span> temp &gt; temperatures[stack[-<span class="number">1</span>]]:</span><br><span class="line">                prev_index = stack.pop()</span><br><span class="line">                result[prev_index] = i - prev_index</span><br><span class="line">            <span class="comment"># 将当前索引压入栈</span></span><br><span class="line">            stack.append(i)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">dailyTemperatures</span>(<span class="params">temperatures</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> result = <span class="keyword">new</span> <span class="title class_">Array</span>(temperatures.<span class="property">length</span>).<span class="title function_">fill</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">const</span> stack = [];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历温度数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; temperatures.<span class="property">length</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 如果当前温度比栈顶的温度高</span></span><br><span class="line">            <span class="keyword">while</span> (stack.<span class="property">length</span> &amp;&amp; temperatures[i] &gt; temperatures[stack[stack.<span class="property">length</span> - <span class="number">1</span>]]) &#123;</span><br><span class="line">                <span class="keyword">const</span> prevIndex = stack.<span class="title function_">pop</span>();</span><br><span class="line">                result[prevIndex] = i - prevIndex;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将当前索引压入栈</span></span><br><span class="line">            stack.<span class="title function_">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h3 id="String-字符串"><a href="#String-字符串" class="headerlink" title="String 字符串"></a><code>String</code> 字符串</h3><h4 id="字符串解码"><a href="#字符串解码" class="headerlink" title="字符串解码"></a>字符串解码</h4><blockquote><p><a href="https://leetcode.com/problems/decode-string/">Leetcode 394. Decode String</a></p></blockquote><ul><li>题目: 给定一个编码过的字符串<code>s</code>，其中包含嵌套的数字和括号结构，例如<code>3[a2[c]]</code>，其解码规则为<ul><li>数字表示括号内字符串的重复次数</li><li>解码后输出完整的字符串</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: s = &quot;3[a]2[bc]&quot;</span><br><span class="line">Output: &quot;aaabcbc&quot;</span><br></pre></td></tr></table></figure><ul><li>解法: 栈</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 使用栈保存当前的字符串和重复次数</span><br><span class="line">2. 遇到 [ 将当前字符串和次数入栈，清空当前的数字和字符串</span><br><span class="line">3. 遇到 ] 将栈中的字符串与当前字符串组合，并重复指定次数</span><br><span class="line">4. 遇到数字时，累积数字值</span><br><span class="line">5. 遇到普通字符时，将其追加到当前字符串</span><br><span class="line">6. 最后，栈中保存的即为解码后的结果</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">decodeString</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        stack = [] <span class="comment"># 栈，用于保存 (当前字符串, 当前数字)</span></span><br><span class="line">        curr_num = <span class="number">0</span> <span class="comment"># 当前的重复次数</span></span><br><span class="line">        curr_str = <span class="string">&quot;&quot;</span> <span class="comment"># 当前正在构建的字符串</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> c.isdigit():</span><br><span class="line">                <span class="comment"># 构建数字</span></span><br><span class="line">                curr_num = curr_num * <span class="number">10</span> + <span class="built_in">int</span>(c)</span><br><span class="line">            <span class="keyword">elif</span> c == <span class="string">&quot;[&quot;</span>:</span><br><span class="line">                <span class="comment"># 遇到左括号，将当前字符串和数字入栈</span></span><br><span class="line">                stack.append((curr_str, curr_num))</span><br><span class="line">                curr_str = <span class="string">&quot;&quot;</span></span><br><span class="line">                curr_num = <span class="number">0</span></span><br><span class="line">            <span class="keyword">elif</span> c == <span class="string">&quot;]&quot;</span>:</span><br><span class="line">                <span class="comment"># 遇到右括号，出栈并构造新字符串</span></span><br><span class="line">                prev_str, num = stack.pop()</span><br><span class="line">                curr_str = prev_str + num * curr_str</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 字母追加到当前字符串</span></span><br><span class="line">                curr_str += c</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> curr_str</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">decodeString</span>(<span class="params">s</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> stack = [];</span><br><span class="line">        <span class="keyword">let</span> currNum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">let</span> currStr = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> c <span class="keyword">of</span> s) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">isNaN</span>(c)) &#123;</span><br><span class="line">                <span class="comment">// 构建数字</span></span><br><span class="line">                currNum = currNum * <span class="number">10</span> + <span class="built_in">parseInt</span>(c);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c === <span class="string">&quot;[&quot;</span>) &#123;</span><br><span class="line">                <span class="comment">// 遇到左括号，将当前字符串和数字入栈</span></span><br><span class="line">                stack.<span class="title function_">push</span>([currStr, currNum]);</span><br><span class="line">                currStr = <span class="string">&quot;&quot;</span>;</span><br><span class="line">                currNum = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c === <span class="string">&quot;]&quot;</span>) &#123;</span><br><span class="line">                <span class="comment">// 遇到右括号，出栈并构造新字符串</span></span><br><span class="line">                <span class="keyword">const</span> [prevStr, num] = stack.<span class="title function_">pop</span>();</span><br><span class="line">                currStr = prevStr + currStr.<span class="title function_">repeat</span>(num);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 字母追加到当前字符串</span></span><br><span class="line">                currStr += c;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> currStr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h4 id="最长无重复子串"><a href="#最长无重复子串" class="headerlink" title="最长无重复子串"></a>最长无重复子串</h4><blockquote><p><a href="https://leetcode.com/problems/longest-substring-without-repeating-characters/">Leetcode 3. Longest Substring Without Repeating Characters</a></p></blockquote><ul><li>题目: 给定一个字符串<code>s</code>，找出其中不含重复字符的最长子串的长度</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: s = &quot;abcabcbb&quot;</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure><ul><li>解法: 滑动窗口</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 使用两个指针 `left` 和 `right` 维护一个滑动窗口，窗口内的字符不重复</span><br><span class="line">2. 用一个 `set` 存储当前窗口内的字符</span><br><span class="line">3. 每次移动右指针，将字符尝试加入窗口：</span><br><span class="line">   - 如果字符已存在，移动左指针，直到窗口中无重复字符</span><br><span class="line">4. 更新当前窗口的最大长度</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lengthOfLongestSubstring</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        result = <span class="number">0</span></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        char_set = <span class="built_in">set</span>()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> right <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">            <span class="comment"># 如果字符重复，移动左指针直到窗口无重复字符</span></span><br><span class="line">            <span class="keyword">while</span> s[right] <span class="keyword">in</span> char_set:</span><br><span class="line">                char_set.remove(s[left])</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 将当前字符加入窗口</span></span><br><span class="line">            char_set.add(s[right])</span><br><span class="line">            <span class="comment"># 更新最大长度</span></span><br><span class="line">            result = <span class="built_in">max</span>(result, right - left + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">lengthOfLongestSubstring</span>(<span class="params">s</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">let</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">let</span> charSet = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> right = <span class="number">0</span>; right &lt; s.<span class="property">length</span>; right++) &#123;</span><br><span class="line">            <span class="comment">// 如果字符重复，移动左指针直到窗口无重复字符</span></span><br><span class="line">            <span class="keyword">while</span> (charSet.<span class="title function_">has</span>(s[right])) &#123;</span><br><span class="line">                charSet.<span class="title function_">delete</span>(s[left]);</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将当前字符加入窗口</span></span><br><span class="line">            charSet.<span class="title function_">add</span>(s[right]);</span><br><span class="line">            <span class="comment">// 更新最大长度</span></span><br><span class="line">            result = <span class="title class_">Math</span>.<span class="title function_">max</span>(result, right - left + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h4 id="括号匹配"><a href="#括号匹配" class="headerlink" title="括号匹配"></a>括号匹配</h4><blockquote><p><a href="https://leetcode.com/problems/valid-parentheses/">Leetcode 20. Valid Parentheses</a></p></blockquote><ul><li>题目: 验证一个只包含括号的字符串是否有效<ul><li>所有的左括号必须有对应的右括号</li><li>左括号必须以正确的顺序闭合</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: s = &quot;()[]&#123;&#125;&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><ul><li>解法: 栈</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 用一个栈来保存左括号</span><br><span class="line">2. 遍历字符串</span><br><span class="line">    - 遇到左括号，就压入栈</span><br><span class="line">    - 遇到右括号，检查栈顶是否是对应的左括号</span><br><span class="line">        - 如果匹配，弹出栈顶</span><br><span class="line">        - 如果不匹配或栈为空，返回 False</span><br><span class="line">3. 遍历结束后，如果栈为空，说明括号有效</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isValid</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="comment"># 定义右括号到左括号的映射</span></span><br><span class="line">        char_map = &#123;<span class="string">&quot;)&quot;</span>: <span class="string">&quot;(&quot;</span>, <span class="string">&quot;]&quot;</span>: <span class="string">&quot;[&quot;</span>, <span class="string">&quot;&#125;&quot;</span>: <span class="string">&quot;&#123;&quot;</span>&#125;</span><br><span class="line">        stack = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">            <span class="comment"># 如果是左括号，压入栈中</span></span><br><span class="line">            <span class="keyword">if</span> c <span class="keyword">not</span> <span class="keyword">in</span> char_map:</span><br><span class="line">                stack.append(c)</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 如果栈为空或者栈顶元素不匹配，返回 False</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> stack <span class="keyword">or</span> stack[-<span class="number">1</span>] != char_map[c]:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 匹配成功，弹出栈顶</span></span><br><span class="line">            stack.pop()</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> stack</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">isValid</span>(<span class="params">s</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> charMap = &#123; <span class="string">&quot;)&quot;</span>: <span class="string">&quot;(&quot;</span>, <span class="string">&quot;]&quot;</span>: <span class="string">&quot;[&quot;</span>, <span class="string">&quot;&#125;&quot;</span>: <span class="string">&quot;&#123;&quot;</span> &#125;;</span><br><span class="line">        <span class="keyword">const</span> stack = [];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> c <span class="keyword">of</span> s) &#123;</span><br><span class="line">            <span class="comment">// 如果是左括号，压入栈中</span></span><br><span class="line">            <span class="keyword">if</span> (!(c <span class="keyword">in</span> charMap)) &#123;</span><br><span class="line">                stack.<span class="title function_">push</span>(c);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果栈为空或者栈顶元素不匹配，返回 false</span></span><br><span class="line">            <span class="keyword">if</span> (!stack.<span class="property">length</span> || stack[stack.<span class="property">length</span> - <span class="number">1</span>] !== charMap[c])</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 匹配成功，弹出栈顶</span></span><br><span class="line">            stack.<span class="title function_">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> stack.<span class="property">length</span> === <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h4 id="生成括号"><a href="#生成括号" class="headerlink" title="生成括号"></a>生成括号</h4><blockquote><p><a href="https://leetcode.com/problems/generate-parentheses/">Leetcode 22. Generate Parentheses</a></p></blockquote><ul><li>题目: 给定一个数字<code>n</code>，生成所有可能的有效括号组合<ul><li>左括号数量等于右括号数量，并且任意位置右括号的数量不超过左括号</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: n = 3</span><br><span class="line">Output: [&quot;((()))&quot;,&quot;(()())&quot;,&quot;(())()&quot;,&quot;()(())&quot;,&quot;()()()&quot;]</span><br></pre></td></tr></table></figure><ul><li>解法: 回溯法</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 使用递归来生成括号组合</span><br><span class="line">2. 每次递归时，维护当前括号字符串 s 和左右括号的数量</span><br><span class="line">    - 如果左括号的数量小于 n，可以添加左括号</span><br><span class="line">    - 如果右括号的数量小于左括号，添加右括号</span><br><span class="line">3. 当字符串长度等于 2 * n 时，添加到结果中</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">generateParenthesis</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">str</span>]:</span><br><span class="line">        result = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">s, left, right</span>):</span><br><span class="line">            <span class="comment"># 如果长度达到 2 * n，记录结果</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(s) == <span class="number">2</span> * n:</span><br><span class="line">                result.append(s)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 添加左括号</span></span><br><span class="line">            <span class="keyword">if</span> left &lt; n:</span><br><span class="line">                backtrack(s + <span class="string">&quot;(&quot;</span>, left + <span class="number">1</span>, right)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 添加右括号</span></span><br><span class="line">            <span class="keyword">if</span> right &lt; left:</span><br><span class="line">                backtrack(s + <span class="string">&quot;)&quot;</span>, left, right + <span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        backtrack(<span class="string">&quot;&quot;</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">generateParenthesis</span>(<span class="params">n</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> result = [];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">function</span> <span class="title function_">backtrack</span>(<span class="params">s, left, right</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果长度达到 2 * n，记录结果</span></span><br><span class="line">            <span class="keyword">if</span> (s.<span class="property">length</span> === <span class="number">2</span> * n) &#123;</span><br><span class="line">                result.<span class="title function_">push</span>(s);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 添加左括号</span></span><br><span class="line">            <span class="keyword">if</span> (left &lt; n) <span class="title function_">backtrack</span>(s + <span class="string">&quot;(&quot;</span>, left + <span class="number">1</span>, right);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 添加右括号</span></span><br><span class="line">            <span class="keyword">if</span> (right &lt; left) <span class="title function_">backtrack</span>(s + <span class="string">&quot;)&quot;</span>, left, right + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="title function_">backtrack</span>(<span class="string">&quot;&quot;</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h4 id="比较版本号"><a href="#比较版本号" class="headerlink" title="比较版本号"></a>比较版本号</h4><blockquote><p><a href="https://leetcode.com/problems/compare-version-numbers/">Leetcode 165. Compare Version Numbers</a></p></blockquote><ul><li>题目: 给定两个版本号<code>version1</code>和<code>version2</code>，比较它们的大小<ul><li>如果<code>version1 &gt; version2</code>返回<code>1</code></li><li>如果<code>version1 &lt; version2</code>返回<code>-1</code></li><li>如果它们相等，返回<code>0</code></li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: version1 = &quot;1.2&quot;, version2 = &quot;1.10&quot;</span><br><span class="line">Output: -1</span><br></pre></td></tr></table></figure><ul><li>解法: 分割和补齐</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 使用点号分割版本号，将其转换为整数列表</span><br><span class="line">2. 找到两个版本号的最大长度，将较短的版本号用 0 补齐</span><br><span class="line">3. 从左到右逐个比较对应的版本号部分，返回结果</span><br><span class="line">4. 如果遍历结束后仍然没有结果，则两个版本号相等</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">compareVersion</span>(<span class="params">self, version1: <span class="built_in">str</span>, version2: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 将版本号分割为整数列表</span></span><br><span class="line">        v1_parts = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, version1.split(<span class="string">&quot;.&quot;</span>)))</span><br><span class="line">        v2_parts = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, version2.split(<span class="string">&quot;.&quot;</span>)))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 用 0 补齐较短的版本号部分</span></span><br><span class="line">        max_len = <span class="built_in">max</span>(<span class="built_in">len</span>(v1_parts), <span class="built_in">len</span>(v2_parts))</span><br><span class="line">        v1_parts += [<span class="number">0</span>] * (max_len - <span class="built_in">len</span>(v1_parts))</span><br><span class="line">        v2_parts += [<span class="number">0</span>] * (max_len - <span class="built_in">len</span>(v2_parts))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 比较每一部分</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(max_len):</span><br><span class="line">            <span class="keyword">if</span> v1_parts[i] &gt; v2_parts[i]:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> v1_parts[i] &lt; v2_parts[<span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 如果遍历结束仍未分出大小，则版本号相等</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">compareVersion</span>(<span class="params">version1, version2</span>) &#123;</span><br><span class="line">        <span class="comment">// 将版本号分割为整数数组</span></span><br><span class="line">        <span class="keyword">const</span> v1Parts = version1.<span class="title function_">split</span>(<span class="string">&quot;.&quot;</span>).<span class="title function_">map</span>(<span class="title class_">Number</span>);</span><br><span class="line">        <span class="keyword">const</span> v2Parts = version2.<span class="title function_">split</span>(<span class="string">&quot;.&quot;</span>).<span class="title function_">map</span>(<span class="title class_">Number</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用 0 补齐较短的版本号部分</span></span><br><span class="line">        <span class="keyword">const</span> maxLen = <span class="title class_">Math</span>.<span class="title function_">max</span>(v1Parts.<span class="property">length</span>, v2Parts.<span class="property">length</span>);</span><br><span class="line">        <span class="keyword">while</span> (v1Parts.<span class="property">length</span> &lt; maxLen) v1Parts.<span class="title function_">push</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">while</span> (v2Parts.<span class="property">length</span> &lt; maxLen) v2Parts.<span class="title function_">push</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 比较每一部分</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; maxLen; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (v1Parts[i] &gt; v2Parts[i]) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (v1Parts[i] &lt; v2Parts[i]) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果遍历结束仍未分出大小，则版本号相等</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h4 id="经典计算器-无乘除"><a href="#经典计算器-无乘除" class="headerlink" title="经典计算器 (无乘除)"></a>经典计算器 (无乘除)</h4><blockquote><p><a href="https://leetcode.com/problems/basic-calculator/">Leetcode 224. Basic Calculator</a></p></blockquote><ul><li>题目: 实现一个基本的计算器来计算由正整数、<code>+</code>、<code>-</code>和括号组成的数学表达式的值。表达式中可能包含空格，确保输入合法且结果不会溢出</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: s = &quot;(1+(4+5+2)-3)+(6+8)&quot;</span><br><span class="line">Output: 23</span><br></pre></td></tr></table></figure><ul><li>解法: 栈 + 模拟</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 定义一个栈，用于存储运算结果和符号</span><br><span class="line">2. 遍历字符串:</span><br><span class="line">   - 如果是数字，累加当前数字</span><br><span class="line">   - 如果是 `+` 或 `-`，更新当前的符号，并将累加的数字加到结果中</span><br><span class="line">   - 如果是 `(`，将当前结果和符号压栈，并重置结果和符号</span><br><span class="line">   - 如果是 `)`，将栈顶的结果和符号弹出，并与当前结果相加</span><br><span class="line">3. 返回最终计算结果</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">calculate</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        stack = []</span><br><span class="line">        num = <span class="number">0</span></span><br><span class="line">        result = <span class="number">0</span></span><br><span class="line">        sign = <span class="number">1</span> <span class="comment"># 初始符号为正号</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> char <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> char.isdigit():</span><br><span class="line">                <span class="comment"># 如果是数字，更新当前数字</span></span><br><span class="line">                num = num * <span class="number">10</span> + <span class="built_in">int</span>(char)</span><br><span class="line">            <span class="keyword">elif</span> char <span class="keyword">in</span> <span class="string">&quot;+-&quot;</span>:</span><br><span class="line">                <span class="comment"># 如果是加号或减号，先更新当前结果</span></span><br><span class="line">                result += sign * num</span><br><span class="line">                num = <span class="number">0</span></span><br><span class="line">                sign = <span class="number">1</span> <span class="keyword">if</span> char == <span class="string">&quot;+&quot;</span> <span class="keyword">else</span> -<span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> char == <span class="string">&quot;(&quot;</span>:</span><br><span class="line">                <span class="comment"># 如果是左括号，保存当前结果和符号到栈中</span></span><br><span class="line">                stack.append(result)</span><br><span class="line">                stack.append(sign)</span><br><span class="line">                result = <span class="number">0</span></span><br><span class="line">                sign = <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> char == <span class="string">&quot;)&quot;</span>:</span><br><span class="line">                <span class="comment"># 如果是右括号，计算括号内的结果</span></span><br><span class="line">                result += sign * num</span><br><span class="line">                num = <span class="number">0</span></span><br><span class="line">                result *= stack.pop() <span class="comment"># 弹出符号并应用</span></span><br><span class="line">                result += stack.pop() <span class="comment"># 加上之前的结果</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> result + sign * num</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">calculate</span>(<span class="params">s</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> stack = [];</span><br><span class="line">        <span class="keyword">let</span> num = <span class="number">0</span>, result = <span class="number">0</span>, sign = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> char <span class="keyword">of</span> s) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">isNaN</span>(char) &amp;&amp; char !== <span class="string">&quot; &quot;</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果是数字，更新当前数字</span></span><br><span class="line">                num = num * <span class="number">10</span> + <span class="built_in">parseInt</span>(char);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (char === <span class="string">&quot;+&quot;</span> || char === <span class="string">&quot;-&quot;</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果是加号或减号，先更新当前结果</span></span><br><span class="line">                result += sign * num;</span><br><span class="line">                num = <span class="number">0</span>;</span><br><span class="line">                sign = char === <span class="string">&quot;+&quot;</span> ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (char === <span class="string">&quot;(&quot;</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果是左括号，保存当前结果和符号到栈中</span></span><br><span class="line">                stack.<span class="title function_">push</span>(result);</span><br><span class="line">                stack.<span class="title function_">push</span>(sign);</span><br><span class="line">                result = <span class="number">0</span>;</span><br><span class="line">                sign = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (char === <span class="string">&quot;)&quot;</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果是右括号，计算括号内的结果</span></span><br><span class="line">                result += sign * num;</span><br><span class="line">                num = <span class="number">0</span>;</span><br><span class="line">                result *= stack.<span class="title function_">pop</span>(); <span class="comment">// 弹出符号并应用</span></span><br><span class="line">                result += stack.<span class="title function_">pop</span>(); <span class="comment">// 加上之前的结果</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result + sign * num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h4 id="经典计算器-有乘除"><a href="#经典计算器-有乘除" class="headerlink" title="经典计算器 (有乘除)"></a>经典计算器 (有乘除)</h4><blockquote><p><a href="https://leetcode.com/problems/basic-calculator-ii/">Leetcode 227. Basic Calculator II</a></p></blockquote><ul><li>题目: 实现一个基本的计算器来计算一个字符串表达式的值。表达式仅包含非负整数、<code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>运算符以及空格</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: s = &quot;3+2*2&quot;</span><br><span class="line">Output: 7</span><br><span class="line">Explanation: 3 + (2 * 2) = 7</span><br></pre></td></tr></table></figure><ul><li>解法: 栈 + 模拟</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 使用栈来保存当前的计算结果</span><br><span class="line">2. 遍历字符串，处理数字、操作符和空格</span><br><span class="line">   - 如果是数字，累加构成完整数字</span><br><span class="line">   - 如果是操作符或到达字符串末尾，根据前一个操作符执行计算</span><br><span class="line">     - `+`：将当前数字压入栈</span><br><span class="line">     - `-`：将当前数字取反后压入栈</span><br><span class="line">     - `*`：弹出栈顶数字，与当前数字相乘后压入栈</span><br><span class="line">     - `/`：弹出栈顶数字，执行整数除法后压入栈</span><br><span class="line">3. 遍历结束后，栈中的所有元素求和即为最终结果</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">calculate</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        stack = []</span><br><span class="line">        num = <span class="number">0</span></span><br><span class="line">        op = <span class="string">&#x27;+&#x27;</span> <span class="comment"># 初始操作符为 &#x27;+&#x27;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i, c <span class="keyword">in</span> <span class="built_in">enumerate</span>(s):</span><br><span class="line">            <span class="keyword">if</span> c.isdigit():</span><br><span class="line">                num = num * <span class="number">10</span> + <span class="built_in">int</span>(c) <span class="comment"># 累加数字</span></span><br><span class="line">            <span class="keyword">if</span> c <span class="keyword">in</span> <span class="string">&quot;+-*/&quot;</span> <span class="keyword">or</span> i == <span class="built_in">len</span>(s) - <span class="number">1</span>: <span class="comment"># 遇到操作符或字符串末尾</span></span><br><span class="line">                <span class="keyword">if</span> op == <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">                    stack.append(num)</span><br><span class="line">                <span class="keyword">elif</span> op == <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">                    stack.append(-num)</span><br><span class="line">                <span class="keyword">elif</span> op == <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">                    stack.append(stack.pop() * num)</span><br><span class="line">                <span class="keyword">elif</span> op == <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">                    stack.append(<span class="built_in">int</span>(stack.pop() / num))</span><br><span class="line">                op = c <span class="comment"># 更新操作符</span></span><br><span class="line">                num = <span class="number">0</span> <span class="comment"># 重置当前数字</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span>(stack)</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">calculate</span>(<span class="params">s</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> stack = [];</span><br><span class="line">        <span class="keyword">let</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">let</span> op = <span class="string">&#x27;+&#x27;</span>; <span class="comment">// 初始操作符为 &#x27;+&#x27;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; s.<span class="property">length</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">const</span> c = s[i];</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">isNaN</span>(c) &amp;&amp; c !== <span class="string">&#x27; &#x27;</span>) num = num * <span class="number">10</span> + <span class="built_in">parseInt</span>(c); <span class="comment">// 累加数字</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;+-*/&quot;</span>.<span class="title function_">includes</span>(c) || i === s.<span class="property">length</span> - <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (op === <span class="string">&#x27;+&#x27;</span>) stack.<span class="title function_">push</span>(num);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (op === <span class="string">&#x27;-&#x27;</span>) stack.<span class="title function_">push</span>(-num);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (op === <span class="string">&#x27;*&#x27;</span>) stack.<span class="title function_">push</span>(stack.<span class="title function_">pop</span>() * num);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (op === <span class="string">&#x27;/&#x27;</span>) stack.<span class="title function_">push</span>(<span class="title class_">Math</span>.<span class="title function_">trunc</span>(stack.<span class="title function_">pop</span>() / num));</span><br><span class="line"></span><br><span class="line">                op = c; <span class="comment">// 更新操作符</span></span><br><span class="line">                num = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> stack.<span class="title function_">reduce</span>(<span class="function">(<span class="params">acc, num</span>) =&gt;</span> acc + num, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h4 id="回文子串个数"><a href="#回文子串个数" class="headerlink" title="回文子串个数"></a>回文子串个数</h4><blockquote><p><a href="https://leetcode.com/problems/palindromic-substrings/">Leetcode 647. Palindromic Substrings</a></p></blockquote><ul><li>题目: 给定一个字符串<code>s</code>，计算其中包含多少个回文子串</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: s = &quot;abc&quot;</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: Three palindromic substrings are &quot;a&quot;, &quot;b&quot;, and &quot;c&quot;</span><br><span class="line"></span><br><span class="line">Input: s = &quot;aaa&quot;</span><br><span class="line">Output: 6</span><br><span class="line">Explanation: Six palindromic substrings are &quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;aa&quot;, &quot;aa&quot;, and &quot;aaa&quot;</span><br></pre></td></tr></table></figure><ul><li>解法: 中心扩展法</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 中心扩展法</span><br><span class="line">   - 每个字符可以作为奇数长度回文的中心</span><br><span class="line">   - 每对相邻字符可以作为偶数长度回文的中心</span><br><span class="line">   - 从中心向两边扩展，判断两边字符是否相等，同时统计回文子串的数量</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">countSubstrings</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(s)</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">expand_around_center</span>(<span class="params">left, right</span>):</span><br><span class="line">            <span class="keyword">nonlocal</span> count</span><br><span class="line">            <span class="keyword">while</span> left &gt;= <span class="number">0</span> <span class="keyword">and</span> right &lt; n <span class="keyword">and</span> s[left] == s[right]:</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">                left -= <span class="number">1</span></span><br><span class="line">                right += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="comment"># 奇数长度的回文</span></span><br><span class="line">            expand_around_center(i, i)</span><br><span class="line">            <span class="comment"># 偶数长度的回文</span></span><br><span class="line">            expand_around_center(i, i + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">countSubstrings</span>(<span class="params">s</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> n = s.<span class="property">length</span>;</span><br><span class="line">        <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">function</span> <span class="title function_">expandAroundCenter</span>(<span class="params">left, right</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (left &gt;= <span class="number">0</span> &amp;&amp; right &lt; n &amp;&amp; s[left] === s[right]) &#123;</span><br><span class="line">                count++;</span><br><span class="line">                left--;</span><br><span class="line">                right++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">// 奇数长度的回文</span></span><br><span class="line">            <span class="title function_">expandAroundCenter</span>(i, i);</span><br><span class="line">            <span class="comment">// 偶数长度的回文</span></span><br><span class="line">            <span class="title function_">expandAroundCenter</span>(i, i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h4 id="最长回文子串"><a href="#最长回文子串" class="headerlink" title="最长回文子串"></a>最长回文子串</h4><blockquote><p><a href="https://leetcode.com/problems/longest-palindromic-substring/">Leetcode 5. Longest Palindromic Substring</a></p></blockquote><ul><li>题目: 给定一个字符串<code>s</code>，找到其中最长的回文子串</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: s = &quot;babad&quot;</span><br><span class="line">Output: &quot;bab&quot;</span><br><span class="line">Explanation: &quot;aba&quot; is also a valid answer</span><br></pre></td></tr></table></figure><ul><li>解法: 中心扩展法</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 回文的中心可以是一个字符，也可以是两个字符之间的间隔</span><br><span class="line">2. 遍历字符串，每个字符和每两个字符之间都作为回文中心进行扩展</span><br><span class="line">3. 在扩展过程中，更新最长的回文子串的起始位置和长度</span><br><span class="line">4. 时间复杂度 O(n^2)</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">longestPalindrome</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">expand_around_center</span>(<span class="params">left, right</span>):</span><br><span class="line">            <span class="comment"># 从中心扩展，寻找最长回文</span></span><br><span class="line">            <span class="keyword">while</span> left &gt;= <span class="number">0</span> <span class="keyword">and</span> right &lt; <span class="built_in">len</span>(s) <span class="keyword">and</span> s[left] == s[right]:</span><br><span class="line">                left -= <span class="number">1</span></span><br><span class="line">                right += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> s[left + <span class="number">1</span>:right]</span><br><span class="line"></span><br><span class="line">        longest = <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">            <span class="comment"># 奇数长度回文</span></span><br><span class="line">            odd_palindrome = expand_around_center(i, i)</span><br><span class="line">            <span class="comment"># 偶数长度回文</span></span><br><span class="line">            even_palindrome = expand_around_center(i, i + <span class="number">1</span>)</span><br><span class="line">            <span class="comment"># 更新最长回文子串</span></span><br><span class="line">            longest = <span class="built_in">max</span>(longest, odd_palindrome, even_palindrome, key=<span class="built_in">len</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> longest</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">longestPalindrome</span>(<span class="params">s</span>) &#123;</span><br><span class="line">        <span class="keyword">function</span> <span class="title function_">expandAroundCenter</span>(<span class="params">left, right</span>) &#123;</span><br><span class="line">            <span class="comment">// 从中心扩展，寻找最长回文</span></span><br><span class="line">            <span class="keyword">while</span> (left &gt;= <span class="number">0</span> &amp;&amp; right &lt; s.<span class="property">length</span> &amp;&amp; s[left] === s[right]) &#123;</span><br><span class="line">                left--;</span><br><span class="line">                right++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> s.<span class="title function_">substring</span>(left + <span class="number">1</span>, right);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> longest = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; s.<span class="property">length</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 奇数长度回文</span></span><br><span class="line">            <span class="keyword">const</span> oddPalindrome = <span class="title function_">expandAroundCenter</span>(i, i);</span><br><span class="line">            <span class="comment">// 偶数长度回文</span></span><br><span class="line">            <span class="keyword">const</span> evenPalindrome = <span class="title function_">expandAroundCenter</span>(i, i + <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 更新最长回文子串</span></span><br><span class="line">            <span class="keyword">if</span> (oddPalindrome.<span class="property">length</span> &gt; longest.<span class="property">length</span>) longest = oddPalindrome;</span><br><span class="line">            <span class="keyword">if</span> (evenPalindrome.<span class="property">length</span> &gt; longest.<span class="property">length</span>) longest = evenPalindrome;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> longest;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h4 id="大数相加"><a href="#大数相加" class="headerlink" title="大数相加"></a>大数相加</h4><blockquote><p><a href="https://leetcode.com/problems/add-strings/">Leetcode 415. Add Strings</a></p></blockquote><ul><li>题目: 给定两个非负整数<code>num1</code>和<code>num2</code>，以字符串的形式表示，返回它们的和，结果也用字符串表示。不能直接使用大整数库或将输入直接转换为整数</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: num1 = &quot;11&quot;, num2 = &quot;123&quot;</span><br><span class="line">Output: &quot;134&quot;</span><br></pre></td></tr></table></figure><ul><li>解法: 模拟逐位相加</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 从字符串末尾开始，逐位相加，记录进位</span><br><span class="line">2. 如果一个字符串较短，用零补齐</span><br><span class="line">3. 将每位的计算结果插入到最终结果的前面</span><br><span class="line">4. 如果最终还有进位，追加到结果</span><br><span class="line">5. 返回拼接的结果字符串</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">addStrings</span>(<span class="params">self, num1: <span class="built_in">str</span>, num2: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="comment"># 初始化指针和变量</span></span><br><span class="line">        i, j = <span class="built_in">len</span>(num1) - <span class="number">1</span>, <span class="built_in">len</span>(num2) - <span class="number">1</span></span><br><span class="line">        carry = <span class="number">0</span></span><br><span class="line">        result = []</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 从右向左逐位相加</span></span><br><span class="line">        <span class="keyword">while</span> i &gt;= <span class="number">0</span> <span class="keyword">or</span> j &gt;= <span class="number">0</span> <span class="keyword">or</span> carry:</span><br><span class="line">            n1 = <span class="built_in">int</span>(num1[i]) <span class="keyword">if</span> i &gt;= <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            n2 = <span class="built_in">int</span>(num2[j]) <span class="keyword">if</span> j &gt;= <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            total = n1 + n2 + carry</span><br><span class="line"></span><br><span class="line">            carry  = total // <span class="number">10</span> <span class="comment"># 计算进位</span></span><br><span class="line">            result.append(<span class="built_in">str</span>(total % <span class="number">10</span>))</span><br><span class="line"></span><br><span class="line">            i -= <span class="number">1</span></span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(result[::-<span class="number">1</span>]) <span class="comment"># 翻转并拼接结果</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">addStrings</span>(<span class="params">num1, num2</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> i = num1.<span class="property">length</span> - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">let</span> j = num2.<span class="property">length</span> - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">let</span> carry = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">let</span> result = [];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从右向左逐位相加</span></span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span> || carry) &#123;</span><br><span class="line">            <span class="keyword">const</span> n1 = i &gt;= <span class="number">0</span> ? <span class="built_in">parseInt</span>(num1[i]) : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">const</span> n2 = j &gt;= <span class="number">0</span> ? <span class="built_in">parseInt</span>(num2[j]) : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">const</span> total = n1 + n2 + carry;</span><br><span class="line"></span><br><span class="line">            carry = <span class="title class_">Math</span>.<span class="title function_">floor</span>(total / <span class="number">10</span>); <span class="comment">// 计算进位</span></span><br><span class="line">            result.<span class="title function_">push</span>(total % <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">            i--;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result.<span class="title function_">reverse</span>().<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>); <span class="comment">// 翻转并拼接结果</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h3 id="Backtrack-回溯"><a href="#Backtrack-回溯" class="headerlink" title="Backtrack 回溯"></a><code>Backtrack</code> 回溯</h3><h4 id="全排列（无重复元素）"><a href="#全排列（无重复元素）" class="headerlink" title="全排列（无重复元素）"></a>全排列（无重复元素）</h4><blockquote><p><a href="https://leetcode.com/problems/permutations/">Leetcode 46. Permutations</a></p></blockquote><ul><li>题目: 给定一个不包含重复的数组<code>nums</code>，返回数组的所有可能的排列，不包含重复</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: nums = [1,2,3]</span><br><span class="line">Output: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</span><br></pre></td></tr></table></figure><ul><li>解法: 回溯算法</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 初始化一个空路径 path 和一个 used 数组用于标记是否使用过某元素</span><br><span class="line">2. 遍历数组，对未使用的元素进行选择，加入路径</span><br><span class="line">3. 如果路径长度等于数组长度，将当前路径加入结果</span><br><span class="line">4. 撤销选择，尝试其他未使用的元素</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">permute</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        result = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">path, used</span>):</span><br><span class="line">            <span class="comment"># 如果路径长度等于数组长度，加入结果</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(path) == <span class="built_in">len</span>(nums):</span><br><span class="line">                result.append(path[:]) <span class="comment"># 深拷贝当前路径</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">                <span class="keyword">if</span> used[i]:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">                <span class="comment"># 做选择</span></span><br><span class="line">                path.append(nums[i])</span><br><span class="line">                used[i] = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">                <span class="comment"># 递归</span></span><br><span class="line">                backtrack(path, used)</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 撤销选择</span></span><br><span class="line">                path.pop()</span><br><span class="line">                used[i] = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        backtrack([], [<span class="literal">False</span>] * <span class="built_in">len</span>(nums))</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">permute</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> result = [];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">function</span> <span class="title function_">backtrack</span>(<span class="params">path, used</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果路径长度等于数组长度，加入结果</span></span><br><span class="line">            <span class="keyword">if</span> (path.<span class="property">length</span> === nums.<span class="property">length</span>) &#123;</span><br><span class="line">                result.<span class="title function_">push</span>([...path]); <span class="comment">// 深拷贝当前路径</span></span><br><span class="line">                <span class="keyword">return</span>; </span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.<span class="property">length</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (used[i]) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 做选择</span></span><br><span class="line">                path.<span class="title function_">push</span>(nums[i]);</span><br><span class="line">                used[i] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 递归</span></span><br><span class="line">                <span class="title function_">backtrack</span>(path, used);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 撤销选择</span></span><br><span class="line">                path.<span class="title function_">pop</span>();</span><br><span class="line">                used[i] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="title function_">backtrack</span>([], <span class="title class_">Array</span>(nums.<span class="property">length</span>).<span class="title function_">fill</span>(<span class="literal">false</span>));</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h4 id="全排列（有重复元素）"><a href="#全排列（有重复元素）" class="headerlink" title="全排列（有重复元素）"></a>全排列（有重复元素）</h4><blockquote><p><a href="https://leetcode.com/problems/permutations-ii/">Leetcode 47. Permutations II</a></p></blockquote><ul><li>题目: 给定一个可能包含重复数字的数组<code>nums</code>，返回数组的所有不重复的排列</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: nums = [1,1,2]</span><br><span class="line">Output:</span><br><span class="line">[[1,1,2],</span><br><span class="line"> [1,2,1],</span><br><span class="line"> [2,1,1]]</span><br></pre></td></tr></table></figure><ul><li>解法: 回溯算法 + 去重</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 对 nums 排序，使得相同的数字相邻，方便去重</span><br><span class="line">2. 在回溯过程中，跳过当前数字与前一个数字相同且前一个数字未被使用的情况</span><br><span class="line">3. 构建排列路径，记录已使用数字</span><br><span class="line">4. 撤销选择，尝试其他未使用的数字</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">permuteUnique</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        result = []</span><br><span class="line">        nums.sort() <span class="comment"># 排序以便去重</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">path, used</span>):</span><br><span class="line">            <span class="comment"># 如果路径长度等于数组长度，加入结果</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(path) == <span class="built_in">len</span>(nums):</span><br><span class="line">                result.append(path[:])</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">                <span class="comment"># 如果数字已使用，跳过</span></span><br><span class="line">                <span class="keyword">if</span> used[i]:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">                <span class="comment"># 去重：当前数字与前一个数字相同，且前一个数字未被使用</span></span><br><span class="line">                <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i - <span class="number">1</span>] <span class="keyword">and</span> <span class="keyword">not</span> used[i - <span class="number">1</span>]:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">                <span class="comment"># 做选择</span></span><br><span class="line">                path.append(nums[i])</span><br><span class="line">                used[i] = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">                <span class="comment"># 递归</span></span><br><span class="line">                backtrack(path, used)</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 撤销选择</span></span><br><span class="line">                path.pop()</span><br><span class="line">                used[i] = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        backtrack([], [<span class="literal">False</span>] * <span class="built_in">len</span>(nums))</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">permuteUnique</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> result = [];</span><br><span class="line">        nums.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b); <span class="comment">// 排序以便去重</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">function</span> <span class="title function_">backtrack</span>(<span class="params">path, used</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果路径长度等于数组长度，加入结果</span></span><br><span class="line">            <span class="keyword">if</span> (path.<span class="property">length</span> === nums.<span class="property">length</span>) &#123;</span><br><span class="line">                result.<span class="title function_">push</span>([...path]); <span class="comment">// 深拷贝路径</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.<span class="property">length</span>; i++) &#123;</span><br><span class="line">                <span class="comment">// 如果数字已使用，跳过</span></span><br><span class="line">                <span class="keyword">if</span> (used[i]) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 去重：当前数字与前一个数字相同，且前一个数字未被使用</span></span><br><span class="line">                <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] === nums[i - <span class="number">1</span>] &amp;&amp; !used[i - <span class="number">1</span>])</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 做选择</span></span><br><span class="line">                path.<span class="title function_">push</span>(nums[i]);</span><br><span class="line">                used[i] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 递归</span></span><br><span class="line">                <span class="title function_">backtrack</span>(path, used);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 撤销选择</span></span><br><span class="line">                path.<span class="title function_">pop</span>();</span><br><span class="line">                used[i] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="title function_">backtrack</span>([], <span class="title class_">Array</span>(nums.<span class="property">length</span>).<span class="title function_">fill</span>(<span class="literal">false</span>));</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h3 id="Dynamic-Programming"><a href="#Dynamic-Programming" class="headerlink" title="Dynamic Programming"></a><code>Dynamic Programming</code></h3><h4 id="分割等和子集"><a href="#分割等和子集" class="headerlink" title="分割等和子集"></a>分割等和子集</h4><blockquote><p><a href="https://leetcode.com/problems/partition-equal-subset-sum/">Leetcode 416. Partition Equal Subset Sum</a></p></blockquote><ul><li>题目: 给定一个非空正整数数组<code>nums</code>，判断是否可以将这个数组分割为两个子集，使得两个子集的元素和相等</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: nums = [1,5,11,5]</span><br><span class="line">Output: true</span><br><span class="line">Explanation: The array can be partitioned as [1, 5, 5] and [11]</span><br></pre></td></tr></table></figure><ul><li>解法: 动态规划（背包问题）</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 目标是找到一个子集，使其和等于总和的一半</span><br><span class="line">2. 如果数组总和为奇数，直接返回 False</span><br><span class="line">3. 定义 dp[i] 表示是否存在一个子集，使得这个子集的和为 i</span><br><span class="line">4. 初始化 dp[0] = True（空集的和为 0 总是成立）</span><br><span class="line">5. 遍历数组中的每个数，从 target（总和的一半）开始向下更新 dp 数组</span><br><span class="line">6. 对于每个数 num 和当前的和 i，如果 dp[i - num] 为 True，则 dp[i] 也为 True</span><br><span class="line">7. 最终检查 dp[target] 是否为 True</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">canPartition</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        total_sum = <span class="built_in">sum</span>(nums)</span><br><span class="line">        <span class="keyword">if</span> total_sum % <span class="number">2</span> != <span class="number">0</span>: <span class="comment"># 如果总和是奇数，无法平分</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        target = total_sum // <span class="number">2</span></span><br><span class="line">        dp = [<span class="literal">False</span>] * (target + <span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="literal">True</span> <span class="comment"># 和为 0 的子集总是存在</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(target, num - <span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                dp[i] = dp[i] <span class="keyword">or</span> dp[i - num]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[target]</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">canPartition</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> totalSum = nums.<span class="title function_">reduce</span>(<span class="function">(<span class="params">acc, num</span>) =&gt;</span> acc + num, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (totalSum % <span class="number">2</span> !== <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 如果总和是奇数，无法平分</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> target = totalSum / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">const</span> dp = <span class="title class_">Array</span>(target + <span class="number">1</span>).<span class="title function_">fill</span>(<span class="literal">false</span>);</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="literal">true</span>; <span class="comment">// 和为 0 的子集总是存在</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> num <span class="keyword">of</span> nums) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = target; i &gt;= num; i--) &#123;</span><br><span class="line">                dp[i] = dp[i] || dp[i - num];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h4 id="组成目标和"><a href="#组成目标和" class="headerlink" title="组成目标和"></a>组成目标和</h4><blockquote><p><a href="https://leetcode.com/problems/target-sum/">Leetcode 494. Target Sum</a></p></blockquote><ul><li>题目: 给定一个数组<code>nums</code>，可以为每个元素加上<code>+</code>或<code>-</code>符号，问有多少种不同的方式使得总和等于目标值<code>target</code></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: nums = [1,1,1,1,1], target = 3</span><br><span class="line">Output: 5</span><br><span class="line">Explanation: There are 5 ways to assign symbols to make the sum of nums be target 3</span><br><span class="line">-1 + 1 + 1 + 1 + 1 = 3</span><br><span class="line">+1 - 1 + 1 + 1 + 1 = 3</span><br><span class="line">+1 + 1 - 1 + 1 + 1 = 3</span><br><span class="line">+1 + 1 + 1 - 1 + 1 = 3</span><br><span class="line">+1 + 1 + 1 + 1 - 1 = 3</span><br></pre></td></tr></table></figure><ul><li>解法: 动态规划</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 将问题转换为子集问题，设 P 是正号部分，N 是负号部分</span><br><span class="line">2. 方程联立：P - N = target 和 P + N = sum(nums) 得到 P = (target + sum(nums)) / 2</span><br><span class="line">3. 如果 (target + sum(nums)) 不是偶数或 target 超过 sum(nums)，返回 0</span><br><span class="line">4. 定义 dp[i] 表示和为 i 的子集数，初始化 dp[0] = 1</span><br><span class="line">5. 遍历数组中的每个数，倒序更新 dp 数组</span><br><span class="line">6. dp[subset_sum] 即为结果</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findTargetSumWays</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        total_sum = <span class="built_in">sum</span>(nums)</span><br><span class="line">        <span class="comment"># 如果目标值无法分割为两部分，返回 </span></span><br><span class="line">        <span class="keyword">if</span> (target + total_sum) % <span class="number">2</span> != <span class="number">0</span> <span class="keyword">or</span> total_sum &lt; <span class="built_in">abs</span>(target):</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 转换为子集和问题</span></span><br><span class="line">        subset_sum = (target + total_sum) // <span class="number">2</span></span><br><span class="line">        <span class="comment"># dp[i] 表示和为 i 的子集数</span></span><br><span class="line">        dp = [<span class="number">0</span>] * (subset_sum + <span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span> <span class="comment"># 和为 0 的子集数为 1（空集）</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="comment"># 从后向前更新 dp 数组</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(subset_sum, num - <span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                dp[i] += dp[i - num]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[subset_sum]</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">findTargetSumWays</span>(<span class="params">nums, target</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> totalSum = nums.<span class="title function_">reduce</span>(<span class="function">(<span class="params">acc, num</span>) =&gt;</span> acc + num, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 如果目标值无法分割为两部分，返回 0</span></span><br><span class="line">        <span class="keyword">if</span> ((target + totalSum) % <span class="number">2</span> !== <span class="number">0</span> || totalSum &lt; <span class="title class_">Math</span>.<span class="title function_">abs</span>(target))</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 转换为子集和问题</span></span><br><span class="line">        <span class="keyword">const</span> subsetSum = (target + totalSum) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">const</span> dp = <span class="keyword">new</span> <span class="title class_">Array</span>(subsetSum + <span class="number">1</span>).<span class="title function_">fill</span>(<span class="number">0</span>);</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>; <span class="comment">// 和为 0 的子集数为 1（空集）</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> num <span class="keyword">of</span> nums) &#123;</span><br><span class="line">            <span class="comment">// 从后向前更新 dp 数组</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = subsetSum; i &gt;= num; i--) &#123;</span><br><span class="line">                dp[i] += dp[i - num];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[subsetSum];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h4 id="跳跃游戏"><a href="#跳跃游戏" class="headerlink" title="跳跃游戏"></a>跳跃游戏</h4><blockquote><p><a href="https://leetcode.com/problems/jump-game/">Leetcode 55. Jump Game</a></p></blockquote><ul><li>题目: 给定一个非负整数数组<code>nums</code>，每个元素表示在该位置上最多可以跳跃的步数。判断是否能够从数组的第一个位置跳到最后一个位置</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: nums = [2,3,1,1,4]</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><ul><li>解法: 贪心算法</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 初始化变量 maxReach 记录当前能到达的最远位置</span><br><span class="line">2. 遍历数组</span><br><span class="line">    - 如果当前位置 i 超过 maxReach，返回 False，表示无法跳到该位置</span><br><span class="line">    - 更新 maxReach 为 max(maxReach, i + nums[i])</span><br><span class="line">3. 遍历结束后，如果未返回 False，说明可以到达终点</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">canJump</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        max_reach = <span class="number">0</span> <span class="comment"># 初始化能够到达的最远位置</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="comment"># 如果当前位置超过了最远可达位置，返回 False</span></span><br><span class="line">            <span class="keyword">if</span> i &gt; max_reach:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 更新最远可达位置</span></span><br><span class="line">            max_reach = <span class="built_in">max</span>(max_reach, i + nums[i])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">canJump</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> maxReach = <span class="number">0</span>; <span class="comment">// 初始化能够到达的最远位置</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.<span class="property">length</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 如果当前位置超过了最远可达位置，返回 false</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; maxReach) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 更新最远可达位置</span></span><br><span class="line">            maxReach = <span class="title class_">Math</span>.<span class="title function_">max</span>(maxReach, i + nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h4 id="最小跳跃次数"><a href="#最小跳跃次数" class="headerlink" title="最小跳跃次数"></a>最小跳跃次数</h4><blockquote><p><a href="https://leetcode.com/problems/jump-game-ii/">Leetcode 45. Jump Game II</a></p></blockquote><ul><li>题目: 给定一个非负整数数组<code>nums</code>，每个元素表示在该位置上最多可以跳跃的步数。求从数组的第一个位置跳到最后一个位置所需的最小跳跃次数</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: nums = [2,3,1,1,4]</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure><ul><li>解法: 贪心算法</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 初始化 jumps（跳跃次数），current_end（当前跳跃的边界），farthest（能跳到的最远位置）</span><br><span class="line">2. 遍历数组，更新 farthest 为 max(farthest, i + nums[i])</span><br><span class="line">3. 当到达 current_end 时，增加跳跃次数，并更新 current_end 为 farthest</span><br><span class="line">4. 遍历结束返回 jumps</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">jump</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        jumps = <span class="number">0</span> <span class="comment"># 跳跃次数</span></span><br><span class="line">        current_end = <span class="number">0</span> <span class="comment"># 当前跳跃的边界</span></span><br><span class="line">        farthest = <span class="number">0</span> <span class="comment"># 当前能跳到的最远位置</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums) - <span class="number">1</span>): <span class="comment"># 最后一个元素不需要遍历</span></span><br><span class="line">            farthest = <span class="built_in">max</span>(farthest, i + nums[i])</span><br><span class="line">            <span class="keyword">if</span> i == current_end: <span class="comment"># 到达当前跳跃的边界</span></span><br><span class="line">                jumps += <span class="number">1</span></span><br><span class="line">                current_end = farthest</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> jumps</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">jump</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> jumps = <span class="number">0</span>; <span class="comment">// 跳跃次数</span></span><br><span class="line">        <span class="keyword">let</span> currentEnd = <span class="number">0</span>; <span class="comment">// 当前跳跃的边界</span></span><br><span class="line">        <span class="keyword">let</span> farthest = <span class="number">0</span>; <span class="comment">// 当前能跳到的最远位置</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.<span class="property">length</span> - <span class="number">1</span>; i++) &#123; <span class="comment">// 最后一个元素不需要遍历</span></span><br><span class="line">            farthest = <span class="title class_">Math</span>.<span class="title function_">max</span>(farthest, i + nums[i]);</span><br><span class="line">            <span class="keyword">if</span> (i === currentEnd) &#123;</span><br><span class="line">                jumps++;</span><br><span class="line">                currentEnd = farthest;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> jumps;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h4 id="买卖股票的最佳时机"><a href="#买卖股票的最佳时机" class="headerlink" title="买卖股票的最佳时机"></a>买卖股票的最佳时机</h4><blockquote><p><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock/">Leetcode 121. Best Time to Buy and Sell Stock</a></p></blockquote><ul><li>题目: 给定一个整数数组<code>prices</code>，其中<code>prices[i]</code>表示某天的股票价格。只允许完成一笔交易（买入和卖出），求最大利润。如果无法获得利润，返回<code>0</code></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: prices = [7,1,5,3,6,4]</span><br><span class="line">Output: 5</span><br><span class="line">Explanation: 在价格为1时买入，价格为6时卖出，利润为6-1=5</span><br></pre></td></tr></table></figure><ul><li>解法: 贪心算法</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 初始化最小买入价格为无穷大，最大利润为 0</span><br><span class="line">2. 遍历价格数组</span><br><span class="line">    - 如果当前价格小于最小买入价格，更新最小买入价格</span><br><span class="line">    - 如果当前价格减去最小买入价格的利润大于最大利润，更新最大利润</span><br><span class="line">3. 返回最大利润</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxProfit</span>(<span class="params">self, prices: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        min_price = <span class="built_in">float</span>(<span class="string">&quot;inf&quot;</span>) <span class="comment"># 最小买入价格</span></span><br><span class="line">        max_profit = <span class="number">0</span> <span class="comment"># 最大利润</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> price <span class="keyword">in</span> prices:</span><br><span class="line">            <span class="comment"># 更新最小买入价格</span></span><br><span class="line">            <span class="keyword">if</span> price &lt; min_price:</span><br><span class="line">                min_price = price</span><br><span class="line">            <span class="comment"># 计算当前利润，并更新最大利润</span></span><br><span class="line">            <span class="keyword">elif</span> price - min_price &gt; max_profit:</span><br><span class="line">                max_profit = price - min_price</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> max_profit</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">maxProfit</span>(<span class="params">prices</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> minPrice = <span class="title class_">Infinity</span>; <span class="comment">// 最小买入价格</span></span><br><span class="line">        <span class="keyword">let</span> maxProfit = <span class="number">0</span>; <span class="comment">// 最大利润</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> price <span class="keyword">of</span> prices) &#123;</span><br><span class="line">            <span class="comment">// 更新最小买入价格</span></span><br><span class="line">            <span class="keyword">if</span> (price &lt; minPrice) </span><br><span class="line">                minPrice = price;</span><br><span class="line">            <span class="comment">// 计算当前利润，并更新最大利润</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (price - minPrice &gt; maxProfit)</span><br><span class="line">                maxProfit = price - minPrice;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> maxProfit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h4 id="股票买卖的最大收益"><a href="#股票买卖的最大收益" class="headerlink" title="股票买卖的最大收益"></a>股票买卖的最大收益</h4><blockquote><p><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/">Leetcode 122. Best Time to Buy and Sell Stock II</a></p></blockquote><ul><li>题目: 给定一个数组，<code>prices[i]</code>表示第<code>i</code>天的股票价格。可以进行多次买卖操作（但必须先卖掉之前的股票后才能再次购买），求能获得的最大利润</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: prices = [7,1,5,3,6,4]</span><br><span class="line">Output: 7</span><br><span class="line">Explanation: 在第2天买入（价格=1），第3天卖出（价格=5），收益=5-1=4；然后在第4天买入（价格=3），第5天卖出（价格=6），收益=6-3=3，总收益为7</span><br></pre></td></tr></table></figure><ul><li>解法: 贪心算法</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 遍历价格数组，检查是否存在连续上涨的价格差</span><br><span class="line">2. 如果今天的价格高于昨天的价格，将差值累加到最大利润中</span><br><span class="line">3. 遍历完成后，返回最大利润</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxProfit</span>(<span class="params">self, prices: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        max_profit = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(prices)):</span><br><span class="line">            <span class="comment"># 如果今天的价格比昨天高，累加差值到利润中</span></span><br><span class="line">            <span class="keyword">if</span> prices[i] &gt; prices[i - <span class="number">1</span>]:</span><br><span class="line">                max_profit += prices[i] - prices[i - <span class="number">1</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> max_profit</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">maxProfit</span>(<span class="params">prices</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> maxProfit = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; prices.<span class="property">length</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 如果今天的价格比昨天高，累加差值到利润中</span></span><br><span class="line">            <span class="keyword">if</span> (prices[i] &gt; prices[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                maxProfit += prices[i] - prices[i - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> maxProfit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h4 id="不同路径的数目"><a href="#不同路径的数目" class="headerlink" title="不同路径的数目"></a>不同路径的数目</h4><blockquote><p><a href="https://leetcode.com/problems/unique-paths/">Leetcode 62. Unique Paths</a></p></blockquote><ul><li>题目: 一个机器人位于一个<code>m x n</code>网格的左上角 (起点在<code>(0, 0)</code>)。机器人每次只能向下或向右移动一步。网格的右下角在<code>(m-1, n-1)</code>。问有多少条不同的路径可以到达终点</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: m = 3, n = 7</span><br><span class="line">Output: 28</span><br></pre></td></tr></table></figure><ul><li>解法: 动态规划</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 定义 dp 数组，dp[i][j] 表示到达网格 (i, j) 的路径数量</span><br><span class="line">2. 初始状态: dp[0][j] 和 dp[i][0] 都为 1（第一行和第一列的路径数量都为 1）</span><br><span class="line">3. 状态转移方程: dp[i][j] = dp[i-1][j] + dp[i][j-1]</span><br><span class="line">4. 返回 dp[m-1][n-1]</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">uniquePaths</span>(<span class="params">self, m: <span class="built_in">int</span>, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 初始化 dp 数组，所有值为 1</span></span><br><span class="line">        dp = [[<span class="number">1</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m)]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 填充 dp 表格</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>]</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">uniquePaths</span>(<span class="params">m, n</span>) &#123;</span><br><span class="line">        <span class="comment">// 初始化 dp 数组，所有值为 1</span></span><br><span class="line">        <span class="keyword">const</span> dp = <span class="title class_">Array</span>.<span class="title function_">from</span>(&#123;<span class="attr">length</span>: m&#125;, <span class="function">() =&gt;</span> <span class="title class_">Array</span>(n).<span class="title function_">fill</span>(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 填充 dp 表格</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h4 id="最大连续和"><a href="#最大连续和" class="headerlink" title="最大连续和"></a>最大连续和</h4><blockquote><p><a href="https://leetcode.com/problems/maximum-subarray/">Leetcode 53. Maximum Subarray</a></p></blockquote><ul><li>题目: 给定一个整数数组<code>nums</code>，找到具有最大和的连续子数组（至少包含一个元素），返回其最大和</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: nums = [-2,1,-3,4,-1,2,1,-5,4]</span><br><span class="line">Output: 6</span><br><span class="line">Explanation: [4,-1,2,1] has the largest sum = 6</span><br></pre></td></tr></table></figure><ul><li>解法: 动态规划</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 定义 dp[i] 表示以 nums[i] 结尾的最大子数组和</span><br><span class="line">2. 状态转移方程:</span><br><span class="line">   dp[i] = max(nums[i], dp[i-1] + nums[i])</span><br><span class="line">   即当前位置的最大和，要么是当前数字本身，要么是当前数字加上前面的最大和</span><br><span class="line">3. 初始化: dp[0] = nums[0]</span><br><span class="line">4. 遍历数组，计算每个位置的 dp 值，并记录最大值</span><br><span class="line">5. 时间复杂度 O(n)，空间复杂度 O(1)（通过优化只保留当前值）</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxSubArray</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 初始化当前最大和和全局最大和</span></span><br><span class="line">        current_sum = max_sum = nums[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums[<span class="number">1</span>:]:</span><br><span class="line">            <span class="comment"># 当前和为当前数字或当前数字加之前的和</span></span><br><span class="line">            current_sum = <span class="built_in">max</span>(num, current_sum + num)</span><br><span class="line">            <span class="comment"># 更新全局最大和</span></span><br><span class="line">            max_sum = <span class="built_in">max</span>(max_sum, current_sum)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> max_sum</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">maxSubArray</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">        <span class="comment">// 初始化当前最大和和全局最大和</span></span><br><span class="line">        <span class="keyword">let</span> currentSum = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">let</span> maxSum = nums[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; nums.<span class="property">length</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 当前和为当前数字或当前数字加之前的和</span></span><br><span class="line">            currentSum = <span class="title class_">Math</span>.<span class="title function_">max</span>(nums[i], currentSum + nums[i]);</span><br><span class="line">            <span class="comment">// 更新全局最大和</span></span><br><span class="line">            maxSum = <span class="title class_">Math</span>.<span class="title function_">max</span>(maxSum, currentSum);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> maxSum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h4 id="最长公共子串"><a href="#最长公共子串" class="headerlink" title="最长公共子串"></a>最长公共子串</h4><blockquote><p><a href="https://leetcode.com/problems/longest-common-subsequence/">Leetcode 1143. Longest Common Subsequence</a></p></blockquote><ul><li>题目: 给定两个字符串<code>text1</code>和<code>text2</code>，返回它们最长公共子序列的长度。如果不存在公共子序列，则返回<code>0</code></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: text1 = &quot;abcde&quot;, text2 = &quot;ace&quot;</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: The longest common subsequence is &quot;ace&quot; and its length is 3</span><br></pre></td></tr></table></figure><ul><li>解法: 动态规划</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 定义 dp[i][j]:</span><br><span class="line">   - dp[i][j] 表示 text1 前 i 个字符和 text2 前 j 个字符的最长公共子序列长度</span><br><span class="line">2. 转移方程:</span><br><span class="line">   - 如果 text1[i-1] == text2[j-1]，则 dp[i][j] = dp[i-1][j-1] + 1</span><br><span class="line">   - 否则，dp[i][j] = max(dp[i-1][j], dp[i][j-1])</span><br><span class="line">3. 初始化:</span><br><span class="line">   - dp[0][j] = 0 和 dp[i][0] = 0，因为空字符串与任何字符串的公共子序列长度为 0</span><br><span class="line">4. 遍历:</span><br><span class="line">   - 填充整个 dp 表，并返回 dp[m][n]，其中 m 和 n 是 text1 和 text2 的长度</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">longestCommonSubsequence</span>(<span class="params">self, text1: <span class="built_in">str</span>, text2: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        m, n = <span class="built_in">len</span>(text1), <span class="built_in">len</span>(text2)</span><br><span class="line">        <span class="comment"># 创建 dp 数组并初始化</span></span><br><span class="line">        dp = [[<span class="number">0</span>] * (n + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m + <span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 遍历两个字符串的所有前缀组合</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> text1[i - <span class="number">1</span>] == text2[j - <span class="number">1</span>]:</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[m][n]</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">longestCommonSubsequence</span>(<span class="params">text1, text2</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> m = text1.<span class="property">length</span>, n = text2.<span class="property">length</span>;</span><br><span class="line">        <span class="comment">// 创建 dp 数组并初始化</span></span><br><span class="line">        <span class="keyword">const</span> dp = <span class="title class_">Array</span>.<span class="title function_">from</span>(&#123;<span class="attr">length</span>: m + <span class="number">1</span>&#125;, <span class="function">() =&gt;</span> <span class="title class_">Array</span>(n + <span class="number">1</span>).<span class="title function_">fill</span>(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历两个字符串的所有前缀组合</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (text1[i - <span class="number">1</span>] === text2[j - <span class="number">1</span>])</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp[i][j] = <span class="title class_">Math</span>.<span class="title function_">max</span>(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h3 id="Other-其他"><a href="#Other-其他" class="headerlink" title="Other 其他"></a><code>Other</code> 其他</h3><h4 id="二维数组去重"><a href="#二维数组去重" class="headerlink" title="二维数组去重"></a>二维数组去重</h4><ul><li>题目: 给定一个二维数组，可能包含重复的行，实现一个方法去重，返回去重后的二维数组</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">matrix = [</span><br><span class="line">    [1, 2, 3],</span><br><span class="line">    [1, 2, 3],</span><br><span class="line">    [4, 5, 6]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"># 输出: [(1, 2, 3), (4, 5, 6)]</span><br></pre></td></tr></table></figure><ul><li>解法<code>1</code>: 不保留顺序</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">将每一行转化为不可变类型</span><br><span class="line">    在 Python 中使用 tuple</span><br><span class="line">    在 JavaScript 中使用 JSON.stringify</span><br><span class="line">利用 Set 的特性去重</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">remove_duplicates</span>(<span class="params">matrix</span>):</span><br><span class="line">        <span class="comment"># 将每一行转化为元组并用 set 去重</span></span><br><span class="line">        unique_rows = <span class="built_in">set</span>(<span class="built_in">tuple</span>(row) <span class="keyword">for</span> row <span class="keyword">in</span> matrix)</span><br><span class="line">        <span class="comment"># 将去重后的结果转回列表形式</span></span><br><span class="line">        <span class="keyword">return</span> [<span class="built_in">list</span>(row) <span class="keyword">for</span> row <span class="keyword">in</span> unique_rows]</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">removeDuplicates</span>(<span class="params">matrix</span>) &#123;</span><br><span class="line">        <span class="comment">// 使用 Set 去重，将每一行转换为字符串</span></span><br><span class="line">        <span class="keyword">const</span> uniqueRows = <span class="keyword">new</span> <span class="title class_">Set</span>(matrix.<span class="title function_">map</span>(<span class="function"><span class="params">row</span> =&gt;</span> <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(rows)));</span><br><span class="line">        <span class="comment">// 将字符串还原为数组</span></span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Array</span>.<span class="title function_">from</span>(uniqueRows, <span class="function"><span class="params">row</span> =&gt;</span> <span class="title class_">JSON</span>.<span class="title function_">parse</span>(row));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><ul><li>解法<code>2</code>: 保留顺序</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">使用 Set 跟踪已经处理的行</span><br><span class="line">遍历二维数组，检查每一行是否已在 Set 中</span><br><span class="line">    如果未出现过，则添加到结果数组中，并将其标记为已处理</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">remove_duplicates_with_order</span>(<span class="params">matrix</span>):</span><br><span class="line">        seen = <span class="built_in">set</span>()</span><br><span class="line">        unique_rows = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> matrix:</span><br><span class="line">            row_tuple = <span class="built_in">tuple</span>(row)</span><br><span class="line">            <span class="keyword">if</span> row_tuple <span class="keyword">not</span> <span class="keyword">in</span> seen: <span class="comment"># 如果该行尚未处理</span></span><br><span class="line">                seen.add(row_tuple) <span class="comment"># 标记为已处理</span></span><br><span class="line">                unique_rows.append(row) <span class="comment"># 添加到结果中</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> unique_rows</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">removeDuplicatesWithOrder</span>(<span class="params">matrix</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> seen = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line">        <span class="keyword">const</span> uniqueRows = [];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> row <span class="keyword">of</span> matrix) &#123;</span><br><span class="line">            <span class="keyword">const</span> rowString = <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(row); <span class="comment">// 将行转化为字符串</span></span><br><span class="line">            <span class="keyword">if</span> (!seen.<span class="title function_">has</span>(rowString)) &#123;</span><br><span class="line">                seen.<span class="title function_">add</span>(rowString);</span><br><span class="line">                uniqueRows.<span class="title function_">push</span>(row);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> uniqueRows;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h4 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">斐波那契数列的定义是</span><br><span class="line">    F(0) = 0</span><br><span class="line">    F(1) = 1</span><br><span class="line">    对于 n &gt;= 2，F(n) = F(n-1) + F(n-2)</span><br><span class="line"></span><br><span class="line">数列前几项为</span><br><span class="line">    0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...</span><br></pre></td></tr></table></figure><ul><li>解法<code>1</code>: 递归</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">按照定义，递归计算每个斐波那契数</span><br><span class="line">优点：实现简单，代码清晰</span><br><span class="line">缺点：存在大量重复计算，效率较低</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fibonacci</span>(<span class="params">n</span>):</span><br><span class="line">        <span class="keyword">if</span> n &lt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">elif</span> n == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> fibonacci(n - <span class="number">1</span>) + fibonacci(n - <span class="number">2</span>)</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">fibonacci</span>(<span class="params">n</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (n === <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">fibonacci</span>(n - <span class="number">1</span>) + <span class="title function_">fibonacci</span>(n - <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><ul><li>解法<code>2</code>: 动态规划</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">使用两个变量存储前两个数值，避免重复计算</span><br><span class="line">从 F(2) 开始循环计算，最终返回 F(n)</span><br><span class="line">优点：时间复杂度 O(n)，空间复杂度 O(1)</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fibonacci</span>(<span class="params">n</span>):</span><br><span class="line">        <span class="keyword">if</span> n &lt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">elif</span> n == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        prev2, prev1 = <span class="number">0</span>, <span class="number">1</span> <span class="comment"># 初始值</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n + <span class="number">1</span>):</span><br><span class="line">            curr = prev1 + prev2 </span><br><span class="line">            prev2 = prev1  <span class="comment"># 更新前两个数</span></span><br><span class="line">            prev1 = curr</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> prev1</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">fibonacci</span>(<span class="params">n</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (n === <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> prev2 = <span class="number">0</span>, prev1 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">const</span> curr = prev1 + prev2;</span><br><span class="line">            prev2 = prev1;</span><br><span class="line">            prev1 = curr;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> prev1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><table><thead><tr><th>方法</th><th>时间复杂度</th><th>空间复杂度</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>递归</td><td><code>O(2^n)</code></td><td><code>O(n)</code></td><td>简单易理解，适合小问题</td><td>性能差，大量重复计算</td></tr><tr><td>动态规划优化空间</td><td><code>O(n)</code></td><td><code>O(1)</code></td><td>高效，占用空间少</td><td>不保存所有中间结果</td></tr><tr><td>通用迭代</td><td><code>O(n)</code></td><td><code>O(n)</code></td><td>清晰直观，适合扩展</td><td>占用更多空间</td></tr></tbody></table><hr><h4 id="整数反转"><a href="#整数反转" class="headerlink" title="整数反转"></a>整数反转</h4><blockquote><p><a href="https://leetcode.com/problems/reverse-integer/">Leetcode 7. Reverse Integer</a></p></blockquote><ul><li>题目: 给定一个<code>32</code>位有符号整数<code>x</code>，将其数字部分反转<ul><li>如果反转后整数溢出（不在<code>[-2^31, 2^31 - 1]</code>范围内），返回<code>0</code></li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: x = 123</span><br><span class="line">Output: 321</span><br></pre></td></tr></table></figure><ul><li>解法: 逐位反转</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 记录整数的符号（正或负），然后将整数取绝对值，方便处理</span><br><span class="line">2. 通过 取余操作 获取最后一位数字，将其添加到结果中</span><br><span class="line">    - 每次更新结果为 res = res * 10 + digit</span><br><span class="line">    - 再通过整除去掉最后一位数字</span><br><span class="line">3. 反转后乘以原始符号恢复符号</span><br><span class="line">4. 检查是否超出 32 位整数范围，如果超出返回 0</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverse</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 定义 32 位整数范围</span></span><br><span class="line">        INT_MIN, INT_MAX = -(<span class="number">2</span>**<span class="number">31</span>), <span class="number">2</span>**<span class="number">31</span> - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        result = <span class="number">0</span></span><br><span class="line">        sign = -<span class="number">1</span> <span class="keyword">if</span> x &lt; <span class="number">0</span> <span class="keyword">else</span> <span class="number">1</span> <span class="comment"># 记录符号</span></span><br><span class="line">        x = <span class="built_in">abs</span>(x)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> x != <span class="number">0</span>:</span><br><span class="line">            digit = x % <span class="number">10</span> <span class="comment"># 取出最后一位数字</span></span><br><span class="line">            result = result * <span class="number">10</span> + digit <span class="comment"># 更新结果</span></span><br><span class="line">            x //= <span class="number">10</span> <span class="comment"># 去掉最后一位</span></span><br><span class="line"></span><br><span class="line">        result *= sign <span class="comment"># 恢复符号</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> result &lt; INT_MIN <span class="keyword">or</span> result &gt; INT_MAX:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">reverse</span>(<span class="params">x</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="variable constant_">INT_MIN</span> = -(<span class="number">2</span> ** <span class="number">31</span>);</span><br><span class="line">        <span class="keyword">const</span> <span class="variable constant_">INT_MAX</span> = <span class="number">2</span> ** <span class="number">31</span> - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">const</span> sign = x &lt; <span class="number">0</span> ? -<span class="number">1</span> : <span class="number">1</span>;</span><br><span class="line">        x = <span class="title class_">Math</span>.<span class="title function_">abs</span>(x);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (x !== <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> digit = x % <span class="number">10</span>; <span class="comment">// 取出最后一位数字</span></span><br><span class="line">            result = result * <span class="number">10</span> + digit; <span class="comment">// 更新结果</span></span><br><span class="line">            x = <span class="title class_">Math</span>.<span class="title function_">floor</span>(x / <span class="number">10</span>); <span class="comment">// 去掉最后一位</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        result *= sign;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (result &lt; <span class="variable constant_">INT_MIN</span> || result &gt; <span class="variable constant_">INT_MAX</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h4 id="位1的个数"><a href="#位1的个数" class="headerlink" title="位1的个数"></a>位<code>1</code>的个数</h4><blockquote><p><a href="https://leetcode.com/problems/number-of-1-bits/">Leetcode 191. Number of 1 Bits</a></p></blockquote><ul><li>题目: 给定一个无符号整数，返回其二进制表示中<code>1</code>的个数（也称为汉明权重）</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: n = 11 (二进制表示为 00000000000000000000000000001011)</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: 11 的二进制表示有三个 1</span><br></pre></td></tr></table></figure><ul><li>解法: 位操作</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 使用按位与 (n &amp; (n - 1)) 消除最低位的 1，直到 n 为 0，统计次数</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hammingWeight</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> n:</span><br><span class="line">            n &amp;= n - <span class="number">1</span> <span class="comment"># 每次消除最低位的 1</span></span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">hammingWeight</span>(<span class="params">n</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n !== <span class="number">0</span>) &#123;</span><br><span class="line">            n &amp;= n - <span class="number">1</span>; <span class="comment">// 每次消除最低位的 1</span></span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><ul><li>快速排序是一种基于分治思想的高效排序算法，平均时间复杂度为<code>O(n log n)</code>，最坏情况下时间复杂度为 <code>O(n^2)</code>。它的基本思想是通过一次排序将待排序数组分割成独立的两部分，其中一部分的所有元素都比另一部分的所有元素小，然后对这两部分分别进行递归排序。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">quicksort</span>(<span class="params">arr</span>):</span><br><span class="line">    <span class="comment"># 基本条件：如果数组为空或只有一个元素，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(arr) &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> arr</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 选择基准元素</span></span><br><span class="line">    pivot = arr[<span class="built_in">len</span>(arr) // <span class="number">2</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 将数组分成三个部分：小于基准的部分、等于基准的部分、大于基准的部分</span></span><br><span class="line">    left = [x <span class="keyword">for</span> x <span class="keyword">in</span> arr <span class="keyword">if</span> x &lt; pivot]</span><br><span class="line">    middle = [x <span class="keyword">for</span> x <span class="keyword">in</span> arr <span class="keyword">if</span> x == pivot]</span><br><span class="line">    right = [x <span class="keyword">for</span> x <span class="keyword">in</span> arr <span class="keyword">if</span> x &gt; pivot]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 递归排序左右两部分</span></span><br><span class="line">    <span class="keyword">return</span> quicksort(left) + middle + quicksort(right)</span><br></pre></td></tr></table></figure><hr><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><ul><li>冒泡排序是一种简单的排序算法，它通过重复遍历列表，将相邻的元素进行比较并交换，使得每次遍历后最大（或最小）的元素逐步“冒泡”到列表的末尾。冒泡排序的时间复杂度为<code>O(n²)</code>，适用于小规模数据的排序。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">bubble_sort</span>(<span class="params">arr</span>):</span><br><span class="line">    n = <span class="built_in">len</span>(arr)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 外层循环控制遍历次数</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        swapped = <span class="literal">False</span>  <span class="comment"># 用来标记是否发生交换</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 内层循环进行相邻元素的比较和交换</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, n - i - <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> arr[j] &gt; arr[j + <span class="number">1</span>]:</span><br><span class="line">                <span class="comment"># 交换相邻元素</span></span><br><span class="line">                arr[j], arr[j + <span class="number">1</span>] = arr[j + <span class="number">1</span>], arr[j]</span><br><span class="line">                swapped = <span class="literal">True</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 如果没有发生交换，说明数组已经排序完毕</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> swapped:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> arr</span><br></pre></td></tr></table></figure><hr><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><ul><li>插入排序是一种简单直观的排序算法，适合处理小规模数据。它的工作原理是构建一个有序序列，对于未排序的数据，在已排序的序列中从后向前扫描，找到相应位置并插入。插入排序的时间复杂度为<code>O(n²)</code>，在数组几乎有序的情况下表现很好，接近<code>O(n)</code>。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">insertion_sort</span>(<span class="params">arr</span>):</span><br><span class="line">    <span class="comment"># 从第二个元素开始遍历</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(arr)):</span><br><span class="line">        key = arr[i]  <span class="comment"># 当前待插入的元素</span></span><br><span class="line">        j = i - <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 向前遍历已排序的序列，找到适合的位置插入当前元素</span></span><br><span class="line">        <span class="keyword">while</span> j &gt;= <span class="number">0</span> <span class="keyword">and</span> arr[j] &gt; key:</span><br><span class="line">            arr[j + <span class="number">1</span>] = arr[j]  <span class="comment"># 将大于 key 的元素向后移动</span></span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        arr[j + <span class="number">1</span>] = key  <span class="comment"># 将当前元素插入到正确的位置</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> arr</span><br></pre></td></tr></table></figure><hr><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><ul><li>归并排序是一种经典的分治算法，通过将数组递归地分成两个子数组，分别进行排序，然后合并这两个有序子数组来实现排序。归并排序的时间复杂度为<code>O(n log n)</code>，它具有稳定性且适用于大规模数据的排序。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">merge_sort</span>(<span class="params">arr</span>):</span><br><span class="line">    <span class="comment"># 如果数组长度小于等于1，则直接返回</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(arr) &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> arr</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 分割数组</span></span><br><span class="line">    mid = <span class="built_in">len</span>(arr) // <span class="number">2</span></span><br><span class="line">    left_half = merge_sort(arr[:mid])</span><br><span class="line">    right_half = merge_sort(arr[mid:])</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 合并两个已排序的子数组</span></span><br><span class="line">    <span class="keyword">return</span> merge(left_half, right_half)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">merge</span>(<span class="params">left, right</span>):</span><br><span class="line">    sorted_array = []</span><br><span class="line">    i = j = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 逐步比较两个子数组中的元素，按顺序合并</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(left) <span class="keyword">and</span> j &lt; <span class="built_in">len</span>(right):</span><br><span class="line">        <span class="keyword">if</span> left[i] &lt; right[j]:</span><br><span class="line">            sorted_array.append(left[i])</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            sorted_array.append(right[j])</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 将剩余的元素加入合并结果</span></span><br><span class="line">    sorted_array.extend(left[i:])</span><br><span class="line">    sorted_array.extend(right[j:])</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> sorted_array</span><br></pre></td></tr></table></figure><hr><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><ul><li>堆排序是一种基于二叉堆的数据结构的比较排序算法，时间复杂度为<code>O(n log n)</code>。堆排序分为最大堆和最小堆，通常使用最大堆来进行升序排序。堆排序具有原地排序的特点，不需要额外的存储空间。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">heapify</span>(<span class="params">arr, n, i</span>):</span><br><span class="line">    largest = i  <span class="comment"># 设当前节点 i 为最大</span></span><br><span class="line">    left = <span class="number">2</span> * i + <span class="number">1</span>  <span class="comment"># 左子节点</span></span><br><span class="line">    right = <span class="number">2</span> * i + <span class="number">2</span>  <span class="comment"># 右子节点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 如果左子节点存在，且大于当前最大值</span></span><br><span class="line">    <span class="keyword">if</span> left &lt; n <span class="keyword">and</span> arr[left] &gt; arr[largest]:</span><br><span class="line">        largest = left</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 如果右子节点存在，且大于当前最大值</span></span><br><span class="line">    <span class="keyword">if</span> right &lt; n <span class="keyword">and</span> arr[right] &gt; arr[largest]:</span><br><span class="line">        largest = right</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 如果最大值不是当前节点，进行交换并继续调整堆</span></span><br><span class="line">    <span class="keyword">if</span> largest != i:</span><br><span class="line">        arr[i], arr[largest] = arr[largest], arr[i]</span><br><span class="line">        heapify(arr, n, largest)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">heap_sort</span>(<span class="params">arr</span>):</span><br><span class="line">    n = <span class="built_in">len</span>(arr)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 构建最大堆</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n // <span class="number">2</span> - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">        heapify(arr, n, i)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 交换元素，并重新调整堆结构</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n - <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>):</span><br><span class="line">        arr[i], arr[<span class="number">0</span>] = arr[<span class="number">0</span>], arr[i]  <span class="comment"># 将堆顶元素移到数组末尾</span></span><br><span class="line">        heapify(arr, i, <span class="number">0</span>)  <span class="comment"># 调整剩下的部分为最大堆</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> arr</span><br></pre></td></tr></table></figure><hr><h3 id="深度优先搜索-DFS-amp-广度优先搜索-BFS"><a href="#深度优先搜索-DFS-amp-广度优先搜索-BFS" class="headerlink" title="深度优先搜索 (DFS) &amp; 广度优先搜索 (BFS)"></a>深度优先搜索 (DFS) &amp; 广度优先搜索 (BFS)</h3><ul><li>深度优先搜索: <code>DFS</code>是一种通过深入每一个节点并尽可能深地搜索其子节点的遍历算法。可以使用递归或显式栈来实现。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">dfs_recursive</span>(<span class="params">graph, node, visited=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="keyword">if</span> visited <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        visited = <span class="built_in">set</span>()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 访问当前节点</span></span><br><span class="line">    <span class="built_in">print</span>(node)</span><br><span class="line">    visited.add(node)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 递归访问相邻节点</span></span><br><span class="line">    <span class="keyword">for</span> neighbor <span class="keyword">in</span> graph[node]:</span><br><span class="line">        <span class="keyword">if</span> neighbor <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">            dfs_recursive(graph, neighbor, visited)</span><br></pre></td></tr></table></figure><ul><li>广度优先搜索: <code>BFS</code>是一种逐层遍历算法，先访问当前节点的所有相邻节点，再继续访问这些相邻节点的相邻节点。<code>BFS</code>通常用队列来实现。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">bfs</span>(<span class="params">graph, start</span>):</span><br><span class="line">    visited = <span class="built_in">set</span>()</span><br><span class="line">    queue = deque([start])  <span class="comment"># 使用双端队列作为队列</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> queue:</span><br><span class="line">        node = queue.popleft()  <span class="comment"># 从队列中取出第一个节点</span></span><br><span class="line">        <span class="keyword">if</span> node <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">            <span class="built_in">print</span>(node)</span><br><span class="line">            visited.add(node)</span><br><span class="line">            <span class="comment"># 将相邻节点加入队列</span></span><br><span class="line">            queue.extend(graph[node])</span><br></pre></td></tr></table></figure><hr><h3 id="前序，中序，后序"><a href="#前序，中序，后序" class="headerlink" title="前序，中序，后序"></a>前序，中序，后序</h3><ul><li>前序遍历顺序为：根节点 -&gt; 左子树 -&gt; 右子树</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">preorder</span>(<span class="params">root</span>):</span><br><span class="line">    <span class="keyword">if</span> root:</span><br><span class="line">        <span class="built_in">print</span>(root.val)  <span class="comment"># 先访问根节点</span></span><br><span class="line">        preorder(root.left)  <span class="comment"># 递归访问左子树</span></span><br><span class="line">        preorder(root.right)  <span class="comment"># 递归访问右子树</span></span><br></pre></td></tr></table></figure><ul><li>中序遍历顺序为：左子树 -&gt; 根节点 -&gt; 右子树</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">inorder</span>(<span class="params">root</span>):</span><br><span class="line">    <span class="keyword">if</span> root:</span><br><span class="line">        inorder(root.left)  <span class="comment"># 递归访问左子树</span></span><br><span class="line">        <span class="built_in">print</span>(root.val)  <span class="comment"># 访问根节点</span></span><br><span class="line">        inorder(root.right)  <span class="comment"># 递归访问右子树</span></span><br></pre></td></tr></table></figure><ul><li>后序遍历顺序为：左子树 -&gt; 右子树 -&gt; 根节点</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">postorder</span>(<span class="params">root</span>):</span><br><span class="line">    <span class="keyword">if</span> root:</span><br><span class="line">        postorder(root.left)  <span class="comment"># 递归访问左子树</span></span><br><span class="line">        postorder(root.right)  <span class="comment"># 递归访问右子树</span></span><br><span class="line">        <span class="built_in">print</span>(root.val)  <span class="comment"># 最后访问根节点</span></span><br></pre></td></tr></table></figure><hr>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>前端面试笔记</title>
      <link href="/posts/c7d67744.html"/>
      <url>/posts/c7d67744.html</url>
      
        <content type="html"><![CDATA[<h3 id="1-CSS-题目"><a href="#1-CSS-题目" class="headerlink" title="1. CSS 题目"></a>1. CSS 题目</h3><h4 id="1-1-画等腰直角三角形"><a href="#1-1-画等腰直角三角形" class="headerlink" title="1.1 画等腰直角三角形"></a>1.1 画等腰直角三角形</h4><ul><li><p>这题是美团前端面试一面题: <a href="https://juejin.cn/post/6950081305560219679?searchId=202410130111434E030964573D8F88A42E">参考链接</a></p></li><li><p>第一种方法: 使用<code>boarder</code></p></li></ul><iframe width="100%" height="300" src="//jsfiddle.net/HDL52/mojg3tqL/13/embedded/html,css,result/dark/" frameborder="0" loading="lazy" allowtransparency="true" allowfullscreen="true"></iframe><ul><li>第二种方法: 使用<code>linear-gradient</code></li></ul><iframe width="100%" height="300" src="//jsfiddle.net/HDL52/uwykmf1a/4/embedded/html,css,result/dark/" frameborder="0" loading="lazy" allowtransparency="true" allowfullscreen="true"></iframe><ul><li>第三种方法: 使用<code>clip-path</code></li></ul><iframe width="100%" height="300" src="//jsfiddle.net/HDL52/7eowjy52/15/embedded/html,css,result/dark/" frameborder="0" loading="lazy" allowtransparency="true" allowfullscreen="true"></iframe><hr><h4 id="1-2-不定宽高水平垂直居中"><a href="#1-2-不定宽高水平垂直居中" class="headerlink" title="1.2 不定宽高水平垂直居中"></a>1.2 不定宽高水平垂直居中</h4><ul><li>第一种方法: 使用<code>Flexbox</code> (也可以父元素是<code>flex</code>然后子元素<code>margin:auto</code>)</li></ul><iframe width="100%" height="300" src="//jsfiddle.net/HDL52/9fa0m5rg/14/embedded/html,css,result/dark/" frameborder="0" loading="lazy" allowtransparency="true" allowfullscreen="true"></iframe><ul><li>第二种方法: 使用<code>Grid</code></li></ul><iframe width="100%" height="300" src="//jsfiddle.net/HDL52/0b2oduje/4/embedded/html,css,result/dark/" frameborder="0" loading="lazy" allowtransparency="true" allowfullscreen="true"></iframe><ul><li>第三种方法: 绝对定位 + <code>transform</code></li></ul><iframe width="100%" height="300" src="//jsfiddle.net/HDL52/u1e7a2mv/5/embedded/html,css,result/dark/" frameborder="0" loading="lazy" allowtransparency="true" allowfullscreen="true"></iframe><hr><h4 id="1-3-正方形子元素"><a href="#1-3-正方形子元素" class="headerlink" title="1.3 正方形子元素"></a>1.3 正方形子元素</h4><ul><li>这题是字节跳动一面题: 父元素的宽高不固定，并且可以随窗口变形，而子元素必须保持正方形 (只能使用<code>CSS</code>)<ul><li>解决方案: 子元素使用百分比宽度并使用<code>aspect-ratio</code>属性来保持子元素的正方形比例</li></ul></li></ul><iframe width="100%" height="300" src="//jsfiddle.net/HDL52/qy79su82/27/embedded/html,css,result/dark/" frameborder="0" loading="lazy" allowtransparency="true" allowfullscreen="true"></iframe><hr><h4 id="1-4-position-定位"><a href="#1-4-position-定位" class="headerlink" title="1.4 position 定位"></a>1.4 position 定位</h4><ul><li><p><code>position: static</code>（默认定位）: 所有元素的默认定位方式。元素按照正常的文档流排列，不会受<code>top</code>、<code>right</code>、<code>bottom</code>或<code>left</code>等属性的影响</p></li><li><p><code>position: relative</code>（相对定位）: 相对于元素自身的原始位置进行定位，但可以通过<code>top</code>、<code>right</code>、<code>bottom</code>、<code>left</code>等属性调整元素的相对位置</p></li></ul><iframe width="100%" height="300" src="//jsfiddle.net/HDL52/5qb29Lzg/2/embedded/html,css,result/dark/" frameborder="0" loading="lazy" allowtransparency="true" allowfullscreen="true"></iframe><ul><li><code>position: absolute</code>（绝对定位）: 相对于最近的非<code>static</code>定位的父元素进行定位。如果没有非<code>static</code>的父元素，则相对于文档的根元素（通常是<code>&lt;html&gt;</code>或<code>&lt;body&gt;</code>）进行定位</li></ul><iframe width="100%" height="300" src="//jsfiddle.net/HDL52/3jmu7q8a/7/embedded/html,css,result/dark/" frameborder="0" loading="lazy" allowtransparency="true" allowfullscreen="true"></iframe><ul><li><p><code>position: fixed</code>（固定定位）: 相对于浏览器窗口进行定位，无论页面如何滚动，元素始终保持在浏览器窗口中的固定位置</p></li><li><p><code>position: sticky</code>（粘性定位）: 结合了<code>relative</code>和<code>fixed</code>的特性。元素一开始是相对于文档流定位的（<code>relative</code>），当页面滚动到某个阈值时，元素会变为固定定位（<code>fixed</code>）</p><ul><li>父元素不能<code>overflow:hidden</code>或者<code>overflow:auto</code>属性</li><li>必须指定<code>top</code>、<code>bottom</code>、<code>left</code>、<code>right</code>四个值之一，否则只会处于相对定位</li></ul></li></ul><iframe width="100%" height="300" src="//jsfiddle.net/HDL52/ybk3o9Lu/23/embedded/html,css,result/dark/" frameborder="0" loading="lazy" allowtransparency="true" allowfullscreen="true"></iframe><hr><h4 id="1-5-盒模型"><a href="#1-5-盒模型" class="headerlink" title="1.5 盒模型"></a>1.5 盒模型</h4><p>盒模型分为<code>IE</code>盒模型和<code>W3C</code>标准盒模型</p><ul><li>在标准盒模型下，一个块的总宽度 &#x3D; <code>width + margin(左右) + padding(左右) + border(左右)</code></li><li>在<code>IE</code>盒模型下，一个块的总宽度 &#x3D; <code>width + margin(左右)</code>（即<code>width</code>已经包含了<code>padding</code>和<code>border</code>值）</li></ul><blockquote><p>当设置<code>box-sizing:content-box</code>时，采用标准盒模型计算，也是默认模式<br>当设置<code>box-sizing:border-box</code>时，采用<code>IE</code>盒模型计算</p></blockquote><ul><li><code>JS</code>如何获取盒模型对应的宽和高<ul><li><code>window.getComputedStyle(dom).width/height</code>: 取到的是最终渲染后的宽和高</li><li><code>dom.getBoundingClientRect().width/height</code>: 得到渲染后的宽和高，还可以取到相对于视窗的上下左右的距离</li><li><code>dom.offsetWidth/offsetHeight</code>: 包括高度（宽度）、内边距和边框，不包括外边距 (兼容性最好)</li></ul></li></ul><hr><h4 id="1-6-CSS-实现扇形"><a href="#1-6-CSS-实现扇形" class="headerlink" title="1.6 CSS 实现扇形"></a>1.6 CSS 实现扇形</h4><hr><h4 id="1-7-BFC"><a href="#1-7-BFC" class="headerlink" title="1.7 BFC"></a>1.7 BFC</h4><ul><li><code>BFC</code>是<code>CSS</code>布局的一个概念，是一块独立的渲染区域，是一个环境，里面的元素不会影响到外部的元素</li></ul><hr><h3 id="2-JS-题目"><a href="#2-JS-题目" class="headerlink" title="2. JS 题目"></a>2. JS 题目</h3><h4 id="2-1-var-与循环"><a href="#2-1-var-与循环" class="headerlink" title="2.1 var 与循环"></a>2.1 var 与循环</h4><ul><li>字节跳动一面的题目</li><li>下面循环的最终结果是什么，<code>i</code>的最终值是什么，<code>i</code>在循环结束后的值是什么</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>这个循环将会输出<code>0 1 2 3 4</code>，<code>i</code>的最终值为<code>5</code></p></li><li><p>由于<code>var</code>声明的变量在整个函数（或全局范围内）都是共享的，它不受块作用域的限制。因此，<code>i</code>在整个函数或脚本范围内是可见的。换句话说，<code>i</code>仍然在循环结束后存在并且可以访问</p></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(i), <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>这个循环将会输出<code>5 5 5 5 5</code>，<code>i</code>的最终值为<code>5</code></li><li>由于<code>var</code>是函数级作用域，所有的<code>setTimeout</code>回调函数在执行时访问的都是同一个<code>i</code>，即循环结束时的<code>i</code>值<code>5</code>。因为<code>setTimeout</code>是异步的，它会在<code>1</code>秒后执行，此时循环早已结束，<code>i</code>已经被更新为<code>5</code></li><li>解决方案: 使用<code>let</code>或闭包可以解决这个问题，确保每次迭代时<code>i</code>的值是独立的</li></ul><hr><h4 id="2-2-手写倒计时"><a href="#2-2-手写倒计时" class="headerlink" title="2.2 手写倒计时"></a>2.2 手写倒计时</h4><ul><li><p>美团一面的题目</p></li><li><p>手写一个倒计时函数，要求输出<code>5 4 3 2 1</code>，每隔一分钟输出一个值</p></li><li><p>方法一: 使用<code>setInterval</code></p><ul><li><code>setInterval</code>会在指定的时间间隔内反复执行一个函数，直到手动清除这个定时器</li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">countdown</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">const</span> intervalId = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(count);</span><br><span class="line">        count--;</span><br><span class="line">        <span class="keyword">if</span> (count === <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">clearInterval</span>(intervalId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="number">60000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">countdown</span>();</span><br></pre></td></tr></table></figure><ul><li>方法二: 使用<code>Generator</code>函数<ul><li>使用<code>Generator</code>函数可以通过<code>yield</code>暂停和恢复函数的执行，结合<code>setTimeout</code>来实现倒计时</li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">countdownGenerator</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">while</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">yield</span> count;</span><br><span class="line">        count--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">countdown</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> generator = <span class="title function_">countdownGenerator</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">nextCountdown</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; value, done &#125; = generator.<span class="title function_">next</span>();</span><br><span class="line">        <span class="keyword">if</span> (!done) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">            <span class="built_in">setTimeout</span>(nextCountdown, <span class="number">60000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">nextCountdown</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">countdown</span>();</span><br></pre></td></tr></table></figure><hr><h4 id="2-3-防抖和节流"><a href="#2-3-防抖和节流" class="headerlink" title="2.3 防抖和节流"></a>2.3 防抖和节流</h4><ul><li><p>可以使用类似<code>loadash</code>这种库来实现</p></li><li><p>防抖 <code>Debounce</code></p><ul><li>防抖是指在事件被触发<code>n</code>秒后在执行回调，如果在这<code>n</code>秒内时间又被触发，则重新计时</li><li>可以使用在一些点击请求的事件上，避免因为用户的多次点击向后端发送多次请求</li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">fn, delay = <span class="number">500</span></span>) &#123;</span><br><span class="line">    <span class="comment">// 通过闭包缓存一个定时器 id</span></span><br><span class="line">    <span class="keyword">let</span> timer = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果已经设定过定时器就清空上一次的定时器</span></span><br><span class="line">        <span class="keyword">if</span> (timer) <span class="built_in">clearTimeout</span>(timer)</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 开始设定一个新的定时器，定时器结束后执行传入的函数 fn</span></span><br><span class="line">        <span class="comment">// 这里必须是箭头函数，不然 this 指向 window，要让 this 就指向 fn 的调用者</span></span><br><span class="line">        timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123; </span><br><span class="line">            fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args)</span><br><span class="line">        &#125;, delay)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行 debounce 函数返回新函数</span></span><br><span class="line"><span class="keyword">const</span> betterFn = <span class="title function_">debounce</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;fn 防抖执行了&#x27;</span>), <span class="number">1000</span>)</span><br><span class="line"><span class="comment">// 停止滑动 1 秒后执行函数 () =&gt; console.log(&#x27;fn 防抖执行了&#x27;)</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;scroll&#x27;</span>, betterFn)</span><br></pre></td></tr></table></figure><blockquote><p>防抖函数分为非立即执行版和立即执行版，需要根据不同的场景来决定需要使用哪一个版本的防抖函数</p></blockquote><ul><li>节流 <code>Throttle</code><ul><li>节流就是一定时间内执行一次事件，即使重复触发，也只有一次生效</li><li>可以使用在监听滚动<code>scroll</code>事件上，通过事件节流来降低事件调用的频率</li></ul></li></ul><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">时间戳版本</button></li><li class="tab"><button type="button" data-href="#test-2">定时器版本</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">throttle</span> = (<span class="params">fn, delay = <span class="number">500</span></span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 上一次执行 fn 的时间</span></span><br><span class="line">  <span class="keyword">let</span> prev = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">    <span class="comment">// 获取当前时间，转换成时间戳，单位毫秒</span></span><br><span class="line">    <span class="keyword">let</span> now = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line">    <span class="comment">// 如果差值大于等于设置的等待时间就执行函数</span></span><br><span class="line">    <span class="keyword">if</span> (now - prev &gt;= delay) &#123;</span><br><span class="line">      fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args);</span><br><span class="line">      prev = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行 throttle 函数返回新函数</span></span><br><span class="line"><span class="keyword">const</span> betterFn = <span class="title function_">throttle</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;fn 函数执行了&#x27;</span>), <span class="number">1000</span>)</span><br><span class="line"><span class="comment">// 每 10 毫秒执行一次 betterFn 函数，但是只有时间差大于 1s 时才会执行 fn</span></span><br><span class="line"><span class="built_in">setInterval</span>(betterFn, <span class="number">10</span>)</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">throttle</span> = (<span class="params">fn, delay = <span class="number">500</span></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> timer = <span class="literal">null</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (timer) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args);</span><br><span class="line">      <span class="comment">// 执行完后，需重置定时器，不然 timer 一直有值，无法开启下一个定时器</span></span><br><span class="line">      timer = <span class="literal">null</span>;</span><br><span class="line">    &#125;, delay)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><blockquote><p>对于节流，一般有两种方式可以实现，分别是时间戳版和定时器版。时间戳版的函数触发是在时间段内开始的时候，而定时器版的函数触发是在时间段内结束的时候</p></blockquote><hr><h4 id="2-4-undefined-与-null-的区别"><a href="#2-4-undefined-与-null-的区别" class="headerlink" title="2.4 undefined 与 null 的区别"></a>2.4 undefined 与 null 的区别</h4><ul><li><code>undefined</code>表示”缺少值”，就是此处应该有一个值，但是还没有定义</li><li><code>null</code>表示”没有对象”，即该处不应该有值</li></ul><hr><h4 id="2-5-浅拷贝和深拷贝"><a href="#2-5-浅拷贝和深拷贝" class="headerlink" title="2.5 浅拷贝和深拷贝"></a>2.5 浅拷贝和深拷贝</h4><ul><li>浅拷贝<ul><li>浅拷贝是创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝</li><li>如果属性是基本类型，拷贝的就是基本类型的值，如果属性是引用类型，拷贝的就是内存地址，所以如果其中一个对象改变了这个地址，就会影响到另一个对象</li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">shallowCopy</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="comment">// 只拷贝对象，基本类型或 null 直接返回</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="string">&#x27;object&#x27;</span> || object === <span class="literal">null</span>)</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断是新建一个数组还是对象</span></span><br><span class="line">  <span class="keyword">let</span> newObj = <span class="title class_">Array</span>.<span class="title function_">isArray</span>(obj) ? [] : &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="comment">// hasOwnProperty 判断是否是对象自身属性，会忽略从原型链上继承的属性</span></span><br><span class="line">    <span class="keyword">if</span> (obj.<span class="title function_">hasOwnProperty</span>(key))</span><br><span class="line">      newObj[key] = obj[key]; <span class="comment">// 只拷贝对象本身的属性</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> newObj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试</span></span><br><span class="line"><span class="keyword">var</span> obj =&#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&#x27;张三&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>:<span class="number">8</span>,</span><br><span class="line">    <span class="attr">pal</span>:[<span class="string">&#x27;王五&#x27;</span>,<span class="string">&#x27;王六&#x27;</span>,<span class="string">&#x27;王七&#x27;</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj2 = <span class="title function_">shallowCopy</span>(obj);</span><br><span class="line">obj2.<span class="property">name</span> = <span class="string">&#x27;李四&#x27;</span></span><br><span class="line">obj2.<span class="property">pal</span>[<span class="number">0</span>] = <span class="string">&#x27;王麻子&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj); <span class="comment">//&#123;age: 8, name: &quot;张三&quot;, pal: [&#x27;王麻子&#x27;, &#x27;王六&#x27;, &#x27;王七&#x27;]&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj2); <span class="comment">//&#123;age: 8, name: &quot;李四&quot;, pal: [&#x27;王麻子&#x27;, &#x27;王六&#x27;, &#x27;王七&#x27;]&#125;</span></span><br></pre></td></tr></table></figure><ul><li>深拷贝<ul><li>深拷贝是将一个对象从内存中完整的拷贝一份出来，从堆内存中开辟一个新的区域存放新对象，且修改新对象不会影响原对象</li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">deepCopy</span>(<span class="params">obj, map = <span class="keyword">new</span> <span class="built_in">WeakMap</span>()</span>) &#123;</span><br><span class="line">  <span class="comment">// 基本类型或 null 直接返回</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="string">&#x27;object&#x27;</span> || obj === <span class="literal">null</span>)</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断是新建一个数组还是对象</span></span><br><span class="line">  <span class="keyword">let</span> newObj = <span class="title class_">Array</span>.<span class="title function_">isArray</span>(obj) ? [] : &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 利用 map 解决循环引用</span></span><br><span class="line">  <span class="keyword">if</span> (map.<span class="title function_">has</span>(obj))</span><br><span class="line">    <span class="keyword">return</span> map.<span class="title function_">get</span>(obj);</span><br><span class="line"></span><br><span class="line">  map.<span class="title function_">set</span>(obj, newObj); <span class="comment">// 将当前对象作为 key，克隆对象作为 value</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> obj) &#123;</span><br><span class="line">    <span class="keyword">if</span> (obj.<span class="title function_">hasOwnProperty</span>(key))</span><br><span class="line">      newObj[key] = <span class="title function_">deepCopy</span>(object[key], map); <span class="comment">// 递归</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> newObj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="keyword">let</span> obj1 = &#123;</span><br><span class="line">    name : <span class="string">&#x27;AK、哒哒哒&#x27;</span>,</span><br><span class="line">    arr : [<span class="number">1</span>,[<span class="number">2</span>,<span class="number">3</span>],<span class="number">4</span>],</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> obj2=<span class="title function_">deepCopy</span>(obj1)</span><br><span class="line">obj2.<span class="property">name</span> = <span class="string">&quot;哒哒哒&quot;</span>;</span><br><span class="line">obj2.<span class="property">arr</span>[<span class="number">1</span>] = [<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>] ; <span class="comment">// 新对象跟原对象不共享内存</span></span><br><span class="line"> </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;obj1&#x27;</span>,obj1) <span class="comment">// obj1 &#123; name: &#x27;AK、哒哒哒&#x27;, arr: [ 1, [ 2, 3 ], 4 ] &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;obj2&#x27;</span>,obj2) <span class="comment">// obj2 &#123; name: &#x27;哒哒哒&#x27;, arr: [ 1, [ 5, 6, 7 ], 4 ] &#125;</span></span><br></pre></td></tr></table></figure><hr><h4 id="2-6-函数柯里化"><a href="#2-6-函数柯里化" class="headerlink" title="2.6 函数柯里化"></a>2.6 函数柯里化</h4><ul><li>在数学和计算机科学中，柯里化是一种将使用多个参数的一个函数转换成一系列使用一个参数的函数的技术</li></ul><blockquote><p>柯里化实际是把简单的问题复杂化，但是复杂化的同时，在使用函数时拥有了更加多的自由度。而对于函数参数的自由处理，正是柯里化的核心所在。柯里化本质上是降低通用性，提高适用性</p></blockquote><ul><li>参数定长的柯里化<ul><li>假设存在一个原函数<code>fn</code>，<code>fn</code>接受三个参数<code>a, b, c</code>，那么函数<code>fn</code>最多被柯里化三次</li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">curry</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">  <span class="comment">// 获取原函数的参数长度</span></span><br><span class="line">  <span class="keyword">const</span> argLen = fn.<span class="property">length</span>;</span><br><span class="line">  <span class="comment">// 保存预置参数</span></span><br><span class="line">  <span class="keyword">const</span> presetArgs = [].<span class="property">slice</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>, <span class="number">1</span>)</span><br><span class="line">  <span class="comment">// 返回一个新函数</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 新函数调用时会继续传参</span></span><br><span class="line">    <span class="keyword">const</span> restArgs = [].<span class="property">slice</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>)</span><br><span class="line">    <span class="keyword">const</span> allArgs = [...presetArgs, ...restArgs]</span><br><span class="line">    <span class="keyword">if</span> (allArgs.<span class="property">length</span> &gt;= argLen) &#123;</span><br><span class="line">      <span class="comment">// 如果参数够了，就执行原函数</span></span><br><span class="line">      <span class="keyword">return</span> fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, allArgs)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 否则继续柯里化</span></span><br><span class="line">      <span class="keyword">return</span> curry.<span class="title function_">call</span>(<span class="literal">null</span>, fn, ...allArgs)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">a, b, c</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b + c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> curried = <span class="title function_">curry</span>(sum);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">curried</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)); <span class="comment">//6</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">curried</span>(<span class="number">1</span>, <span class="number">2</span>)(<span class="number">3</span>)); <span class="comment">//6</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">curried</span>(<span class="number">1</span>)(<span class="number">2</span>, <span class="number">3</span>)); <span class="comment">//6</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">curried</span>(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)); <span class="comment">//6</span></span><br></pre></td></tr></table></figure><ul><li>参数不定长的柯里化<ul><li>如果要支持参数不定长的场景，已经柯里化的函数在执行完毕时不能返回一个值，只能返回一个函数。同时要让<code>JS</code>引擎在解析得到的这个结果时，能求出预期的值</li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">curry</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">  <span class="comment">// 保存预置参数</span></span><br><span class="line">  <span class="keyword">const</span> presetArgs = [].<span class="property">slice</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>, <span class="number">1</span>)</span><br><span class="line">  <span class="comment">// 返回一个新函数</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">curried</span> () &#123;</span><br><span class="line">    <span class="comment">// 新函数调用时会继续传参</span></span><br><span class="line">    <span class="keyword">const</span> restArgs = [].<span class="property">slice</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>)</span><br><span class="line">    <span class="keyword">const</span> allArgs = [...presetArgs, ...restArgs]</span><br><span class="line">    <span class="keyword">return</span> curry.<span class="title function_">call</span>(<span class="literal">null</span>, fn, ...allArgs)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 重写toString</span></span><br><span class="line">  curried.<span class="property">toString</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> fn.<span class="title function_">apply</span>(<span class="literal">null</span>, presetArgs)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> curried;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">dynamicAdd</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> [...<span class="variable language_">arguments</span>].<span class="title function_">reduce</span>(<span class="function">(<span class="params">prev, curr</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> prev + curr</span><br><span class="line">  &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> add = <span class="title function_">curry</span>(dynamicAdd);</span><br><span class="line"><span class="title function_">add</span>(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)(<span class="number">4</span>) <span class="comment">// 10</span></span><br><span class="line"><span class="title function_">add</span>(<span class="number">1</span>, <span class="number">2</span>)(<span class="number">3</span>, <span class="number">4</span>)(<span class="number">5</span>, <span class="number">6</span>) <span class="comment">// 21</span></span><br></pre></td></tr></table></figure><hr><h4 id="2-7-数组扁平化"><a href="#2-7-数组扁平化" class="headerlink" title="2.7 数组扁平化"></a>2.7 数组扁平化</h4><blockquote><p>实现扁平化的方法，封装<code>flatten</code><br>已有多级嵌套数组<code>[1, [2, [3, [4, 5]]], 6]</code> 将其扁平化处理，输出<code>[1,2,3,4,5,6]</code></p></blockquote><ul><li><code>ES6 flat</code><ul><li><code>flat(depth)</code>方法会按照一个可指定的深度递归遍历数组，并将所有元素与遍历到的子数组中的元素合并为一个新数组返回。使用<code>Infinity</code>，可展开任意深度的嵌套数组</li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, [<span class="number">2</span>, [<span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>]]], <span class="number">6</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">flatten</span>(<span class="params">params</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> params.<span class="title function_">flat</span>(<span class="title class_">Infinity</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">flatten</span>(arr));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出: [1,2,3,4,5,6]</span></span><br></pre></td></tr></table></figure><blockquote><p>⭐ 直接使用自带的方法可以很快的实现, 但是面试官当然不希望就看到这些呀</p></blockquote><ul><li>循环递归<ul><li>循环判断数组的每一项是否是数组<code>Array.isArray(arr[i])</code></li><li>是数组就递归调用扁平化代码<code>result = result.concat(flatten(arr[i]));</code></li><li>不是数组,直接通过<code>push</code>添加到返回值数组</li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">flatten</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> result = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(arr[i])) &#123;</span><br><span class="line">      result = result.<span class="title function_">concat</span>(<span class="title function_">flatten</span>(arr[i]));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      result.<span class="title function_">push</span>(arr[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">flatten</span>(arr));</span><br></pre></td></tr></table></figure><blockquote><p>⭐⭐⭐ 使用递归写出数组扁平化, 但是缺少控制层级关系</p></blockquote><ul><li>增加参数控制扁平化深度<ul><li>可以理解为手写<code>flat()</code>方法</li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// forEach 遍历数组会自动跳过空元素</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">eachFlat</span> = (<span class="params">arr = [], depth = <span class="number">1</span></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> result = []; <span class="comment">// 缓存递归结果</span></span><br><span class="line">  <span class="comment">// 开始递归</span></span><br><span class="line">  (<span class="keyword">function</span> <span class="title function_">flat</span>(<span class="params">arr, depth</span>) &#123;</span><br><span class="line">    <span class="comment">// forEach 会自动去除数组空位</span></span><br><span class="line">    arr.<span class="title function_">forEach</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 控制递归深度</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(item) &amp;&amp; depth &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 递归数组</span></span><br><span class="line">        <span class="title function_">flat</span>(item, depth - <span class="number">1</span>)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 缓存元素</span></span><br><span class="line">        result.<span class="title function_">push</span>(item)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)(arr, depth)</span><br><span class="line">  <span class="comment">// 返回递归结果</span></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>⭐⭐⭐⭐ 使用递归写出数组扁平化, 可以通过参数控制层级关系</p></blockquote><ul><li><code>while</code>循环+<code>some</code>方法<ul><li>通过<code>some</code>来判断数组中是否用数组, 通过<code>while</code>不断循环执行判断, 如果是数组的话可以使用拓展运算符<code>...</code>, <code>...</code>每次只能展开最外层的数组, 加上<code>contact</code>来减少嵌套层数</li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">flatten</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="keyword">while</span> (arr.<span class="title function_">some</span>(<span class="function"><span class="params">item</span>=&gt;</span> <span class="title class_">Array</span>.<span class="title function_">isArray</span>(item))) &#123;</span><br><span class="line">    arr = [].<span class="title function_">concat</span>(...arr)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">flatten</span>(arr));</span><br></pre></td></tr></table></figure><blockquote><p>⭐⭐⭐⭐ 使用<code>while</code>循环取消递归操作, 巧用<code>some</code>操作进行判断</p></blockquote><hr><h4 id="2-8-typeof-判断"><a href="#2-8-typeof-判断" class="headerlink" title="2.8 typeof 判断"></a>2.8 typeof 判断</h4><ul><li><code>typeof null</code> 是 <code>“object”</code>: 历史遗留问题</li><li><code>typeof NaN</code> 是 <code>“number”</code>: <code>NaN</code> 实际存储是一种特殊的数值类型</li><li><code>typeof Function.prototype</code> 是 <code>function</code></li></ul><table><thead><tr><th align="center">类型</th><th align="center">结果</th></tr></thead><tbody><tr><td align="center">Undefined</td><td align="center"><code>&quot;undefined&quot;</code></td></tr><tr><td align="center">Null</td><td align="center"><code>&quot;object&quot;</code></td></tr><tr><td align="center">Boolean</td><td align="center"><code>&quot;boolean&quot;</code></td></tr><tr><td align="center">Number</td><td align="center"><code>&quot;number&quot;</code></td></tr><tr><td align="center">BigInt</td><td align="center"><code>&quot;bigint&quot;</code></td></tr><tr><td align="center">String</td><td align="center"><code>&quot;string&quot;</code></td></tr><tr><td align="center">Symbol</td><td align="center"><code>&quot;symbol&quot;</code></td></tr><tr><td align="center">Function (class)</td><td align="center"><code>&quot;function&quot;</code></td></tr><tr><td align="center">其他任何对象</td><td align="center"><code>&quot;object&quot;</code></td></tr></tbody></table><hr><h4 id="2-9-事件委托优化"><a href="#2-9-事件委托优化" class="headerlink" title="2.9 事件委托优化"></a>2.9 事件委托优化</h4><ul><li>字节一面题</li></ul><blockquote><p>举个例子，比如我们需要去做<code>Event Tracking System</code>，需要去记录用户在网站内做了什么，点击了什么按钮。如果有很多个按钮，每个都绑一个点击事件性能很差，如何优化？</p></blockquote><ul><li>绑定事件到父元素<ul><li>而不是为每个子节点单独绑定事件处理程序，事件委托可以将事件处理程序绑定到公共的父元素上，然后通过事件的<code>target</code>来确定实际触发事件的子节点。</li></ul></li><li>检查目标元素<ul><li>使用事件对象的<code>event.target</code>属性来判断哪个子节点触发了事件，并根据需要处理相应的逻辑</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;ul id=&quot;parent&quot;&gt;</span><br><span class="line">  &lt;li class=&quot;child&quot;&gt;子节点 1&lt;/li&gt;</span><br><span class="line">  &lt;li class=&quot;child&quot;&gt;子节点 2&lt;/li&gt;</span><br><span class="line">  &lt;li class=&quot;child&quot;&gt;子节点 3&lt;/li&gt;</span><br><span class="line">  &lt;li class=&quot;child&quot;&gt;子节点 4&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line"></span><br><span class="line">// 使用事件委托，将点击事件绑定到父元素</span><br><span class="line">const parent = document.getElementById(&#x27;parent&#x27;);</span><br><span class="line"></span><br><span class="line">// 事件处理器绑定在父元素上</span><br><span class="line">parent.addEventListener(&#x27;click&#x27;, function (event) &#123;</span><br><span class="line">  // 通过 event.target 来判断点击的是否是目标子节点</span><br><span class="line">  if (event.target &amp;&amp; event.target.classList.contains(&#x27;child&#x27;)) &#123;</span><br><span class="line">    console.log(&#x27;点击了子节点：&#x27;, event.target.innerText);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><blockquote><p>事件委托特别适用于存在大量类似元素的场景，如列表、表格中的行、动态生成的元素等</p></blockquote><hr><h3 id="3-网络安全"><a href="#3-网络安全" class="headerlink" title="3. 网络安全"></a>3. 网络安全</h3><h4 id="3-1-跨站脚本攻击-XSS"><a href="#3-1-跨站脚本攻击-XSS" class="headerlink" title="3.1 跨站脚本攻击 XSS"></a>3.1 跨站脚本攻击 XSS</h4><ul><li><code>XSS</code>（跨站脚本攻击，<code>Cross-Site Scripting</code>）是一种安全漏洞，攻击者通过向网页注入恶意脚本，使得当用户访问受感染的页面时，恶意脚本会在用户的浏览器中执行<ul><li>防止 <code>XSS</code>攻击的关键是严格处理用户输入和输出</li><li>对用户输入进行严格验证和过滤<strong>，</strong>使用安全的框架和库</li></ul></li></ul><hr><h4 id="3-2-跨站请求伪造-CSRF"><a href="#3-2-跨站请求伪造-CSRF" class="headerlink" title="3.2 跨站请求伪造 CSRF"></a>3.2 跨站请求伪造 CSRF</h4><ul><li>跨站点请求伪造 (<code>CSRF</code>) 是一种前端安全攻击，通过伪造的形式来执行你原本不希望执行的操作<ul><li>防止<code>CSRF</code>攻击需要确保请求是合法的，并且是用户有意发起的</li><li>防止<code>CSRF</code>攻击的最简单方法之一是使用从服务器生成的<code>CSRF</code>令牌。如果客户端无法提供准确的令牌，服务器可以拒绝请求的操作</li></ul></li></ul><hr><h3 id="4-网络协议"><a href="#4-网络协议" class="headerlink" title="4. 网络协议"></a>4. 网络协议</h3><h4 id="4-1-网络七层模型与四层模型区别"><a href="#4-1-网络七层模型与四层模型区别" class="headerlink" title="4.1 网络七层模型与四层模型区别"></a>4.1 网络七层模型与四层模型区别</h4><ul><li>参考: <a href="https://juejin.cn/post/6844903492763533319?searchId=20241013095821BCBAFA2F17F7FC9E99C5">链接</a></li><li>网络七层模型 <code>OSI</code>（<code>Open Systems Interconnection Model</code>）是一个标准，而非实现</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/imgCapture1234.PNG"></p><ul><li><code>OSI</code>模型是从上往下的，越底层越接近硬件，越往上越接近软件，这七层模型分别是<strong>物理层、数据链路层、网络层、传输层、会话层、表示层、应用层</strong>。</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; 物理层：底层数据传输，如网线；网卡标准。</span><br><span class="line">&gt; 数据链路层：定义数据的基本格式，如何传输，如何标识；如网卡MAC地址。</span><br><span class="line">&gt; 网络层：定义IP编址，定义路由功能；如不同设备的数据转发。</span><br><span class="line">&gt; 传输层：端到端传输数据的基本功能；如 TCP、UDP。</span><br><span class="line">&gt; 会话层：控制应用程序之间会话能力；如不同软件数据分发给不同软件。</span><br><span class="line">&gt; 标识层：数据格式标识，基本压缩加密功能。</span><br><span class="line">&gt; 应用层：各种应用软件，包括 Web 应用。</span><br></pre></td></tr></table></figure><ul><li>网络四层模型是一个实现的应用模型，由七层模型简化合并而来</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/imgCapture4321.PNG"></p><ul><li><code>TCP/IP</code>模型将<code>OSI</code>模型由七层简化为四层，传输层和网络层被完整保留，因此网络中最核心的技术就是传输层和网络层技术</li></ul><hr><h4 id="4-2-http-和-https-基本概念"><a href="#4-2-http-和-https-基本概念" class="headerlink" title="4.2 http 和 https 基本概念"></a>4.2 http 和 https 基本概念</h4><ul><li><code>HTTP</code>: 是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准<code>TCP</code>，用于从<code>WWW</code>服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少</li><li><code>HTTPS</code>: 是以安全为目标的<code>HTTP</code>通道，简单讲是<code>HTTP</code>的安全版，即<code>HTTP</code>下加入<code>SSL</code>层，<code>HTTPS</code>的安全基础是<code>SSL</code>，因此加密的详细内容就需要<code>SSL</code></li><li><code>HTTPS</code>协议的主要作用可以分为两种：一种是建立一个信息安全通道，来保证数据传输的安全。另一种就是确认网站的真实性</li></ul><hr><h4 id="4-3-http-和-https-区别"><a href="#4-3-http-和-https-区别" class="headerlink" title="4.3 http 和 https 区别"></a>4.3 http 和 https 区别</h4><p><code>HTTP</code>协议传输的数据都是未加密的，也就是明文的，因此使用<code>HTTP</code>协议传输隐私信息非常不安全，为了保证 这些隐私数据能加密传输，于是网景公司设计了<code>SSL</code>(<code>Secure Sockets Layer</code>)协议用于对<code>HTTP</code>协议传输的数据进行加密，从而就诞生了<code>HTTPS</code>。简单来说，<code>HTTPS</code>协议是由<code>SSL+HTTP</code>协议构建的可进行加密传输、身份认证的网络协议，要比<code>HTTP</code>协议安全</p><ul><li><code>https</code>协议需要到<code>ca</code>申请证书，一般免费证书较少，因而需要一定费用</li><li><code>http</code>是超文本传输协议，信息是明文传输，<code>https</code>则是具有安全性的<code>ssl</code>加密传输协议</li><li><code>http</code>和<code>https</code>使用的是完全不同的连接方式，用的端口也不一样，前者是<code>80</code>，后者是<code>443</code></li><li><code>http</code>的连接很简单，是无状态的。<code>https</code>协议是由<code>SSL+HTTP</code>协议构建的可进行加密传输、身份认证的网络协议，比<code>http</code>协议安全</li></ul><blockquote><p>注意: <code>HTTPS = HTTP + SSL/TLS</code>，如今<code>SSL</code>已废弃，所以现在只关注<code>HTTP + TLS</code></p></blockquote><hr><h4 id="4-4-http1-x-和-http2-x-区别"><a href="#4-4-http1-x-和-http2-x-区别" class="headerlink" title="4.4 http1.x 和 http2.x 区别"></a>4.4 http1.x 和 http2.x 区别</h4><p><code>http1.x</code>和<code>http2.x</code>主要有以下<code>4</code>个区别</p><ul><li><p><code>HTTP2</code>使用的是二进制传送，<code>HTTP1.X</code>是文本(字符串)传送</p><ul><li>二进制传送的单位是帧和流。帧组成了流，同时流还有流<code>ID</code>标示</li><li>优势: 传输速度更快 (二进制数据体积较小), 处理更高效 (不需要进行文本解析), 适用于复杂数据类型 (图像、音频、视频), 安全性更高 (二进制数据不易被直接阅读)</li></ul></li><li><p><code>HTTP2</code>支持多路复用</p><ul><li>因为有流<code>ID</code>，所以通过同一个<code>http</code>请求实现多个<code>http</code>请求传输变成了可能，可以通过流<code>ID</code>来标示究竟是哪个流从而定位到是哪个<code>http</code>请求</li></ul></li><li><p><code>HTTP2</code>头部压缩</p><ul><li><code>HTTP2</code>通过<code>gzip</code>和<code>compress</code>压缩头部然后再发送，同时客户端和服务器端同时维护一张头信息表，所有字段都记录在这张表中，这样后面每次传输只需要传输表里面的索引<code>ID</code>就行，通过索引<code>ID</code>查询表头的值</li></ul></li><li><p><code>HTTP2</code>支持服务器推送</p><ul><li><code>HTTP2</code>支持在未经客户端许可的情况下，主动向客户端推送内容</li></ul></li></ul><hr><h4 id="4-5-http-请求方式"><a href="#4-5-http-请求方式" class="headerlink" title="4.5 http 请求方式"></a>4.5 http 请求方式</h4><p><code>http</code>请求方式有以下<code>8</code>种，其中<code>GET</code>和<code>POST</code>是最常用的</p><ul><li><code>GET</code>: 向特定的资源发出请求。<code>GET</code>方法不应当被用于产生“副作用”的操作中</li><li><code>POST</code>: 向指定资源提交数据进行处理请求, 例如提交表单或者上传文件。数据被包含在请求体中。<code>POST</code>请求可能会导致新的资源的建立和&#x2F;或已有资源的修改</li><li><code>PUT</code>: 向指定资源位置上传其最新内容</li><li><code>DELETE</code>: 请求服务器删除<code>Request-URL</code>所标识的资源</li><li><code>HEAD</code>: 向服务器索与<code>GET</code>请求相一致的响应，只不过响应体将不会被返回。这一方法可以再不必传输整个响应内容的情况下，就可以获取包含在响应小消息头中的元信息</li><li><code>OPTIONS</code>: 返回服务器针对特定资源所支持的<code>HTTP</code>请求方法，也可以利用向<code>web</code>服务器发送<code>‘*’</code>的请求来测试服务器的功能性</li><li><code>TRACE</code>: 回显服务器收到的请求，主要用于测试或诊断</li><li><code>CONNECT</code>: <code>HTTP/1.1</code>协议中预留给能够将连接改为管道方式的代理服务器</li></ul><hr><h4 id="4-6-TCP-三次握手"><a href="#4-6-TCP-三次握手" class="headerlink" title="4.6 TCP 三次握手"></a>4.6 TCP 三次握手</h4><hr><h3 id="5-React-题目"><a href="#5-React-题目" class="headerlink" title="5. React 题目"></a>5. React 题目</h3><hr><h3 id="6-缓存"><a href="#6-缓存" class="headerlink" title="6. 缓存"></a>6. 缓存</h3><h4 id="6-1-强缓存与协商缓存"><a href="#6-1-强缓存与协商缓存" class="headerlink" title="6.1 强缓存与协商缓存"></a>6.1 强缓存与协商缓存</h4><ul><li><p>参考: <a href="https://juejin.cn/post/7259298281578889273?searchId=20241013235036EC2DA00FC6CFFB00CC87">链接</a></p></li><li><p>为了减少资源请求次数，加快资源访问速度，浏览器会对资源文件如图片、<code>css</code>文件、<code>js</code>文件等进行缓存，而浏览器缓存策略又分为强缓存和协商缓存</p></li><li><p>强缓存 <code>Strong Cache</code></p><ul><li>所谓强缓存，可以理解为强制缓存的意思，即浏览器在访问某个资源时会判断是否使用本地缓存里已经存在的资源文件，使用本地缓存的话则不会发送请求到服务器，从而达到减轻服务器访问压力的作用，且由于直接从本地缓存读取资源文件，大大提高了加载速度</li><li>浏览器第一次请求远程服务器的某个资源时，如果服务器希望浏览器得到该资源后一段时间内不要再发送请求过来，直接从浏览器里的缓存里取，则服务器可以通过在响应头里设置<code>Cache-Control: max-age=31536000</code>，<code>max-age</code>代表缓存时间，单位为秒，这里的数据换算过来就是一年，意味着在一年内浏览器不会再向服务器发送请求。</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/imgCapture4567.PNG"></p><ul><li>使用缓存的话，状态码<code>200</code>后面会标明情况。浏览器缓存资源的地方有两个: 磁盘缓存（<code>disk cache</code>）和内存缓存（<code>memory cache</code>）</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/imgCapture7654.PNG"></p><ul><li>当缓存时间到期后再次访问时，状态码<code>200</code>后面便没有括号内的内容了</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/imgCapture12345.PNG"></p><blockquote><p>一般来说，浏览器会将较大的资源缓存到<code>disk cache</code>，而较小的资源则被缓存到<code>memory cache</code>里。内存缓存与磁盘缓存相比，访问速度要更快一些</p></blockquote><ul><li>强缓存除了使用<code>Cache-Control</code>实现之外，还可以使用<code>Expires</code>字段，<code>Expires</code>是<code>Http1.0</code>规范，<code>Cache-Control</code>是<code>Http1.1</code>规范，<code>Expires</code>返回一个具体的时间值，代表缓存的有效期，在该日期内浏览器不会向服务器发起请求，而是直接从缓存里获取资源</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/imgCapture5431.PNG"></p><ul><li>因为<code>Expires</code>参照的是本地客户端的时间，而客户端的时间是可以被修改的，所以会有误差产生的情况，这也是<code>Expires</code>的一个缺点，所以有了后来<code>Http1.1</code>规范的<code>Cache-control</code></li></ul><blockquote><p><code>Cache-control</code>的优先级要高于<code>Expires</code>，如果两者同时设置，会优先使用<code>Cache-control</code>而忽略掉<code>Expires</code></p></blockquote><ul><li>协商缓存 <code>Negotiation Cache</code><ul><li>在强缓存里，是否使用缓存是由浏览器来确定的，而协商缓存则是由服务器来告诉浏览器是否使用缓存资源，也就是浏览器每一次都要发送请求到服务器询问是否使用缓存</li><li>浏览器初次请求资源，服务器返回资源，同时生成一个<code>Etag</code>值携带在响应头里返回给浏览器，当浏览器再次请求资源时会在请求头里携带<code>If-None-Match</code>，值是之前服务器返回的<code>Etag</code>的值，服务器收到之后拿该值与资源文件最新的<code>Etag</code>值做对比</li></ul></li></ul><blockquote><p>如果没有变化则返回<code>304</code>，告诉浏览器继续使用缓存（不返回资源文件）<br>如果发生变化，则返回<code>200</code>和最新的资源文件给浏览器使用</p></blockquote><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/imgCapture2567.PNG"></p><ul><li>除了<code>Etag</code>外，还有一个<code>Last-Modified</code>的属性，它是<code>Http1.0</code>规范的，服务器返回<code>Last-Modified</code>，浏览器请求头对应携带的是<code>If-Modified-since</code>，与<code>Etag</code>不同的是，<code>Last-Modified</code>的值是一个时间值，代表文件的修改时间，服务器通过对比文件的修改时间是否发生改变来判断是否使用缓存</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/imgCapture7890.PNG"></p><ul><li>相比<code>Last-Modified</code>，<code>Etag</code>优先级更高，使用上也更精确一些，因为有时候会存在文件内容并没有改变，但文件的修改时间变更了，<code>Last-Modified</code>不一致所以服务器会重新返回资源文件，实际上还是可以继续使用缓存的</li></ul><blockquote><p>强缓存优先级大于协商缓存，即两者同时存在时，如果强缓存开启且在有效期内，则不会走协商缓存</p></blockquote><hr><h3 id="7-算法"><a href="#7-算法" class="headerlink" title="7. 算法"></a>7. 算法</h3><h4 id="7-1-LRU-Cache"><a href="#7-1-LRU-Cache" class="headerlink" title="7.1 LRU Cache"></a>7.1 LRU Cache</h4><ul><li>字节一面算法题</li><li>使用<code>JS</code>实现一个魔改版的<code>LRU Cache</code>，并且满足以下要求</li></ul><blockquote><p>维护一个容量为<code>n</code>的缓存<br>每个缓存项如果在<code>X</code>秒后没有被使用，则自动删除</p></blockquote><ul><li>可以使用<code>Map</code>来维护缓存的顺序和容量，利用<code>setTimeout</code>来实现自动删除的功能</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">capacity, expireTime</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">capacity</span> = capacity; <span class="comment">// 缓存容量</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">expireTime</span> = expireTime; <span class="comment">// 缓存项的有效时间（秒）</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">cache</span> = <span class="keyword">new</span> <span class="title class_">Map</span>(); <span class="comment">// 用 Map 来存储缓存数据</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">timers</span> = <span class="keyword">new</span> <span class="title class_">Map</span>(); <span class="comment">// 用来存储每个缓存项的定时器</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取缓存</span></span><br><span class="line">  <span class="title function_">get</span>(<span class="params">key</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">cache</span>.<span class="title function_">has</span>(key)) <span class="keyword">return</span> -<span class="number">1</span>; <span class="comment">// 如果缓存中没有这个key，返回-1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果缓存命中，需要刷新缓存的顺序（将这个key移到最新的位置）</span></span><br><span class="line">    <span class="keyword">const</span> value = <span class="variable language_">this</span>.<span class="property">cache</span>.<span class="title function_">get</span>(key);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">cache</span>.<span class="title function_">delete</span>(key); <span class="comment">// 先删除老的位置</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">cache</span>.<span class="title function_">set</span>(key, value); <span class="comment">// 重新插入，保证最新访问的在末尾</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重置定时器，延长过期时间</span></span><br><span class="line">    <span class="built_in">clearTimeout</span>(<span class="variable language_">this</span>.<span class="property">timers</span>.<span class="title function_">get</span>(key)); <span class="comment">// 清除老的定时器</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">timers</span>.<span class="title function_">set</span>(key, <span class="variable language_">this</span>.<span class="title function_">setExpiration</span>(key)); <span class="comment">// 重新设置定时器</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 添加缓存</span></span><br><span class="line">  <span class="title function_">put</span>(<span class="params">key, value</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">cache</span>.<span class="title function_">has</span>(key)) &#123;</span><br><span class="line">      <span class="comment">// 如果已经存在，删除旧的缓存</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">cache</span>.<span class="title function_">delete</span>(key);</span><br><span class="line">      <span class="built_in">clearTimeout</span>(<span class="variable language_">this</span>.<span class="property">timers</span>.<span class="title function_">get</span>(key));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果缓存已满，删除最老的缓存</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">cache</span>.<span class="property">size</span> &gt;= <span class="variable language_">this</span>.<span class="property">capacity</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> oldestKey = <span class="variable language_">this</span>.<span class="property">cache</span>.<span class="title function_">keys</span>().<span class="title function_">next</span>().<span class="property">value</span>; <span class="comment">// 获取 Map 中第一个（最旧）的key</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">cache</span>.<span class="title function_">delete</span>(oldestKey); <span class="comment">// 删除最旧的缓存项</span></span><br><span class="line">      <span class="built_in">clearTimeout</span>(<span class="variable language_">this</span>.<span class="property">timers</span>.<span class="title function_">get</span>(oldestKey)); <span class="comment">// 清除相应的定时器</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">timers</span>.<span class="title function_">delete</span>(oldestKey); <span class="comment">// 删除定时器记录</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入新的缓存项</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">cache</span>.<span class="title function_">set</span>(key, value);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">timers</span>.<span class="title function_">set</span>(key, <span class="variable language_">this</span>.<span class="title function_">setExpiration</span>(key)); <span class="comment">// 设置定时器</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置缓存项的自动删除定时器</span></span><br><span class="line">  <span class="title function_">setExpiration</span>(<span class="params">key</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">cache</span>.<span class="title function_">delete</span>(key); <span class="comment">// 删除缓存项</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">timers</span>.<span class="title function_">delete</span>(key); <span class="comment">// 删除定时器记录</span></span><br><span class="line">    &#125;, <span class="variable language_">this</span>.<span class="property">expireTime</span> * <span class="number">1000</span>); <span class="comment">// 转换为毫秒</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> lru = <span class="keyword">new</span> <span class="title class_">LRUCache</span>(<span class="number">3</span>, <span class="number">5</span>); <span class="comment">// 创建容量为3，缓存项5秒后失效的LRU Cache</span></span><br><span class="line">lru.<span class="title function_">put</span>(<span class="number">1</span>, <span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">lru.<span class="title function_">put</span>(<span class="number">2</span>, <span class="string">&#x27;B&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(lru.<span class="title function_">get</span>(<span class="number">1</span>)); <span class="comment">// 输出 &#x27;A&#x27;</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(lru.<span class="title function_">get</span>(<span class="number">2</span>)); <span class="comment">// 在5秒内访问，输出 &#x27;B&#x27;</span></span><br><span class="line">&#125;, <span class="number">4000</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(lru.<span class="title function_">get</span>(<span class="number">1</span>)); <span class="comment">// 超过5秒未访问，输出 -1（已过期）</span></span><br><span class="line">&#125;, <span class="number">6000</span>);</span><br></pre></td></tr></table></figure><hr><h4 id="7-2-格式化数字"><a href="#7-2-格式化数字" class="headerlink" title="7.2 格式化数字"></a>7.2 格式化数字</h4><ul><li><p>字节一面算法题</p></li><li><p>给一个数字比如<code>1000000</code>，把它转化成<code>1,000,000</code>。或者是<code>1000000.12</code>，把它转化成<code>1,000,000.12</code>。只能使用<code>JS</code>实现</p></li><li><p>解决方案一: 使用<code>toLocaleString()</code></p></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">formatNumberWithCommas</span>(<span class="params">number</span>) &#123;</span><br><span class="line">  <span class="comment">// 分离整数和小数部分，默认小数部分为空字符串</span></span><br><span class="line">  <span class="keyword">let</span> [integer, decimal = <span class="string">&#x27;&#x27;</span>] = (number + <span class="string">&#x27;&#x27;</span>).<span class="title function_">split</span>(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 通过 toLocaleString 格式化整数部分，自动加上千分位逗号</span></span><br><span class="line">  integer = (+integer).<span class="title function_">toLocaleString</span>();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 如果没有小数部分，直接返回格式化后的整数部分</span></span><br><span class="line">  <span class="keyword">if</span> (decimal === <span class="string">&#x27;&#x27;</span>) <span class="keyword">return</span> integer;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 小数部分无需反转或使用 toLocaleString，直接返回原来的小数部分即可</span></span><br><span class="line">  <span class="keyword">return</span> integer + <span class="string">&#x27;.&#x27;</span> + decimal;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">formatNumberWithCommas</span>(<span class="number">1000000</span>)); <span class="comment">// 输出 &quot;1,000,000&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">formatNumberWithCommas</span>(<span class="number">1000000.12</span>)); <span class="comment">// 输出 &quot;1,000,000.12&quot;</span></span><br></pre></td></tr></table></figure><ul><li>解决方案二: 正则表达式</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">formateNumberWithCommas</span>(<span class="params">number</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> number.<span class="title function_">toString</span>().<span class="title function_">replace</span>(<span class="regexp">/\B(?=(\d&#123;3&#125;)+(?!\d))/g</span>, <span class="string">&quot;,&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">formateNumberWithCommas</span>(<span class="number">1000000</span>)); <span class="comment">// 输出 &quot;1,000,000&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">formateNumberWithCommas</span>(<span class="number">1000000.12</span>)); <span class="comment">// 输出 &quot;1,000,000.12&quot;</span></span><br></pre></td></tr></table></figure><ul><li>解决方案三: 手动实现格式化</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">formatNumberWithCommas</span>(<span class="params">number</span>) &#123;</span><br><span class="line">  <span class="comment">// 类型检测</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> number !== <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 先转成字符串</span></span><br><span class="line">  number = number.<span class="title function_">toString</span>();</span><br><span class="line">  <span class="comment">// 支持小数,按小数点分成两部分 使用了es6解构</span></span><br><span class="line">  <span class="keyword">let</span> [integer, decimal] = number.<span class="title function_">split</span>(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 封装了 doSplit 方法 第二个参数 isInteger 来表示是整数部分还是小数部分</span></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">doSplit</span> = (<span class="params">num, isInteger = <span class="literal">true</span></span>) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 如果为空，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (!num) <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="comment">// 如果是整数部分 先按位切割再反转</span></span><br><span class="line">    <span class="comment">// 整数部分数字从右往左数，每3位插入一个逗号</span></span><br><span class="line">    <span class="comment">// 小数部分从左往右数</span></span><br><span class="line">    <span class="comment">// 两次反转，它的逗号顺序是一样的。</span></span><br><span class="line">    <span class="keyword">if</span> (isInteger) num = num.<span class="title function_">split</span>(<span class="string">&#x27;&#x27;</span>).<span class="title function_">reverse</span>();</span><br><span class="line">    <span class="keyword">let</span> str = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; num.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (i !== <span class="number">0</span> &amp;&amp; i % <span class="number">3</span> === <span class="number">0</span>) str.<span class="title function_">push</span>(<span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">      str.<span class="title function_">push</span>(num[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isInteger) <span class="keyword">return</span> str.<span class="title function_">reverse</span>().<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> str.<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 处理整数部分</span></span><br><span class="line">  integer = <span class="title function_">doSplit</span>(integer);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 处理小数部分，确保 undefined 小数不会导致问题</span></span><br><span class="line">  decimal = decimal ? <span class="title function_">doSplit</span>(decimal, <span class="literal">false</span>) : <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> integer + (decimal === <span class="string">&#x27;&#x27;</span> ? <span class="string">&#x27;&#x27;</span> : <span class="string">&#x27;.&#x27;</span> + decimal);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">formatNumberWithCommas</span>(<span class="number">1000000</span>)); <span class="comment">// 输出 &quot;1,000,000&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">formatNumberWithCommas</span>(<span class="number">1000000.12</span>)); <span class="comment">// 输出 &quot;1,000,000.12&quot;</span></span><br></pre></td></tr></table></figure><hr><h4 id="7-3-手写数组转树"><a href="#7-3-手写数组转树" class="headerlink" title="7.3 手写数组转树"></a>7.3 手写数组转树</h4><ul><li>做到类似下面的转换</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> input = [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">val</span>: <span class="string">&#x27;学校&#x27;</span>, <span class="attr">parentId</span>: <span class="literal">null</span></span><br><span class="line">    &#125;, &#123;</span><br><span class="line">        <span class="attr">id</span>: <span class="number">2</span>, <span class="attr">val</span>: <span class="string">&#x27;班级1&#x27;</span>, <span class="attr">parentId</span>: <span class="number">1</span></span><br><span class="line">    &#125;, &#123;</span><br><span class="line">        <span class="attr">id</span>: <span class="number">3</span>, <span class="attr">val</span>: <span class="string">&#x27;班级2&#x27;</span>, <span class="attr">parentId</span>: <span class="number">1</span></span><br><span class="line">    &#125;, &#123;</span><br><span class="line">        <span class="attr">id</span>: <span class="number">4</span>, <span class="attr">val</span>: <span class="string">&#x27;学生1&#x27;</span>, <span class="attr">parentId</span>: <span class="number">2</span></span><br><span class="line">    &#125;, &#123;</span><br><span class="line">        <span class="attr">id</span>: <span class="number">5</span>, <span class="attr">val</span>: <span class="string">&#x27;学生2&#x27;</span>, <span class="attr">parentId</span>: <span class="number">2</span></span><br><span class="line">    &#125;, &#123;</span><br><span class="line">        <span class="attr">id</span>: <span class="number">6</span>, <span class="attr">val</span>: <span class="string">&#x27;学生3&#x27;</span>, <span class="attr">parentId</span>: <span class="number">3</span></span><br><span class="line">    &#125;,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> output = &#123;</span><br><span class="line">    <span class="attr">id</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">val</span>: <span class="string">&#x27;学校&#x27;</span>,</span><br><span class="line">    <span class="attr">children</span>: [&#123;</span><br><span class="line">        <span class="attr">id</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="attr">val</span>: <span class="string">&#x27;班级1&#x27;</span>,</span><br><span class="line">        <span class="attr">children</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">id</span>: <span class="number">4</span>,</span><br><span class="line">                <span class="attr">val</span>: <span class="string">&#x27;学生1&#x27;</span>,</span><br><span class="line">                <span class="attr">children</span>: []</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">id</span>: <span class="number">5</span>,</span><br><span class="line">                <span class="attr">val</span>: <span class="string">&#x27;学生2&#x27;</span>,</span><br><span class="line">                <span class="attr">children</span>: []</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;, &#123;</span><br><span class="line">        <span class="attr">id</span>: <span class="number">3</span>,</span><br><span class="line">        <span class="attr">val</span>: <span class="string">&#x27;班级2&#x27;</span>,</span><br><span class="line">        <span class="attr">children</span>: [&#123;</span><br><span class="line">            <span class="attr">id</span>: <span class="number">6</span>,</span><br><span class="line">            <span class="attr">val</span>: <span class="string">&#x27;学生3&#x27;</span>,</span><br><span class="line">            <span class="attr">children</span>: []</span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">arrayToTree</span>(<span class="params">array</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> root = array[<span class="number">0</span>];</span><br><span class="line">  array.<span class="title function_">shift</span>();</span><br><span class="line">  <span class="keyword">let</span> tree = &#123;</span><br><span class="line">    <span class="attr">id</span>: root.<span class="property">id</span>,</span><br><span class="line">    <span class="attr">val</span>: root.<span class="property">val</span>,</span><br><span class="line">    <span class="attr">children</span>: array.<span class="property">length</span> &gt; <span class="number">0</span> ? <span class="title function_">toTree</span>(root.<span class="property">id</span>, array) : []</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> tree;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">toTree</span>(<span class="params">parentId, array</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> children = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; array.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> node = array[i];</span><br><span class="line">    <span class="keyword">if</span> (node.<span class="property">parentId</span> === parentId) &#123;</span><br><span class="line">      children.<span class="title function_">push</span>(&#123;</span><br><span class="line">        <span class="attr">id</span>: node.<span class="property">id</span>,</span><br><span class="line">        <span class="attr">val</span>: node.<span class="property">val</span>,</span><br><span class="line">        <span class="attr">children</span>: <span class="title function_">toTree</span>(node.<span class="property">id</span>, array)</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> children;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">arrayToTree</span>(input));</span><br></pre></td></tr></table></figure><hr><h4 id="7-4-数组去重"><a href="#7-4-数组去重" class="headerlink" title="7.4 数组去重"></a>7.4 数组去重</h4><ul><li><p>将<code>[1,1,2,2,3,3,4,4,5,5]</code>去重, 结果应该是<code>[1,2,3,4,5]</code></p></li><li><p>方法一: <code>ES6</code>的<code>Set</code>去重</p></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>];</span><br><span class="line"><span class="keyword">const</span> setData = <span class="title class_">Array</span>.<span class="title function_">from</span>(<span class="keyword">new</span> <span class="title class_">Set</span>(arr));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(setData);</span><br></pre></td></tr></table></figure><blockquote><p><code>Set</code>去重有一个弊端，无法去重引用类型的数据。比如对象数组<code>[&#123;a:1&#125;, &#123;a:1&#125;]</code></p></blockquote><ul><li>方法二: 双重<code>for</code>循环去重</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">handleRemoveRepeat</span> = (<span class="params">arr</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, len = arr.<span class="property">length</span>; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; len; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (arr[i] === arr[j]) &#123;</span><br><span class="line">        arr.<span class="title function_">splice</span>(j, <span class="number">1</span>);</span><br><span class="line">        j--;</span><br><span class="line">        len--;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>使用<code>len = arr.length</code>的原因: 假设这个循环需要循环<code>10000</code>次，<code>length</code>就会被执行<code>10000</code>次</p></blockquote><hr><h3 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h3><blockquote><p>文件还未上传 Github</p></blockquote>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
