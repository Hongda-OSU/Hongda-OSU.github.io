<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Liquibase 101</title>
      <link href="/posts/c888933a.html"/>
      <url>/posts/c888933a.html</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="密码错误" data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="15e82533bcb1293ce756ee9fbcc59de43332ea84af97385de66d9d2187f15914">03c03690e5a2c7a44b2aa66e251c66b95173940c42de79c65734cf256d748a1f3392aea18f5ba83a6ce29c7e1144d90c760cb672ac36819a3e414f16924b3610a129f4732b5b01d6a33086e7ec72383eec2d6c734fee1bd49b773e9dadb57d7103ffc8c872c93bfddda3671e1478d25af326387f2008078db54c42a5501acd5a88b40d06637002c29490e6eca76633cc7d9b1a85d00f9656c8af1ca351c236f451caeb05ff7c8f920c7e6c94d7ac82f57f55764ee39687bd81232ce46b396a6841b9dada990a9709e8d90afcb07cc5a1e3493665540714003cad9c3f0e28a22a</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-xray">      <input class="hbe hbe-input-field hbe-input-field-xray" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-xray" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-xray">密码</span>      </label>      <svg class="hbe hbe-graphic hbe-graphic-xray" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>        <path d="M0,2.5c0,0,298.666,0,399.333,0C448.336,2.5,513.994,13,597,13c77.327,0,135-10.5,200.999-10.5c95.996,0,402.001,0,402.001,0"></path>      </svg>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>AWS MLA-C01</title>
      <link href="/posts/50096d59.html"/>
      <url>/posts/50096d59.html</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="密码错误" data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="15e82533bcb1293ce756ee9fbcc59de43332ea84af97385de66d9d2187f15914">03c03690e5a2c7a44b2aa66e251c66b95173940c42de79c65734cf256d748a1f3392aea18f5ba83a6ce29c7e1144d90c760cb672ac36819a3e414f16924b3610a129f4732b5b01d6a33086e7ec72383eec2d6c734fee1bd49b773e9dadb57d7103ffc8c872c93bfddda3671e1478d25af326387f2008078db54c42a5501acd5a88b40d06637002c29490e6eca76633cc7d9b1a85d00f9656c8af1ca351c236f451caeb05ff7c8f920c7e6c94d7ac82f57f55764ee39687bd81232ce46b396a6841b9dada990a9709e8d90afcb07cc5a1e3493665540714003cad9c3f0e28a22a</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-xray">      <input class="hbe hbe-input-field hbe-input-field-xray" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-xray" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-xray">密码</span>      </label>      <svg class="hbe hbe-graphic hbe-graphic-xray" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>        <path d="M0,2.5c0,0,298.666,0,399.333,0C448.336,2.5,513.994,13,597,13c77.327,0,135-10.5,200.999-10.5c95.996,0,402.001,0,402.001,0"></path>      </svg>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> Certification </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AWS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS &amp; Python 小技巧</title>
      <link href="/posts/998b6089.html"/>
      <url>/posts/998b6089.html</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="密码错误" data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="15e82533bcb1293ce756ee9fbcc59de43332ea84af97385de66d9d2187f15914">03c03690e5a2c7a44b2aa66e251c66b95173940c42de79c65734cf256d748a1f3392aea18f5ba83a6ce29c7e1144d90c760cb672ac36819a3e414f16924b3610a129f4732b5b01d6a33086e7ec72383eec2d6c734fee1bd49b773e9dadb57d7103ffc8c872c93bfddda3671e1478d25af326387f2008078db54c42a5501acd5a88b40d06637002c29490e6eca76633cc7d9b1a85d00f9656c8af1ca351c236f451caeb05ff7c8f920c7e6c94d7ac82f57f55764ee39687bd81232ce46b396a6841b9dada990a9709e8d90afcb07cc5a1e3493665540714003cad9c3f0e28a22a</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-xray">      <input class="hbe hbe-input-field hbe-input-field-xray" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-xray" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-xray">密码</span>      </label>      <svg class="hbe hbe-graphic hbe-graphic-xray" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>        <path d="M0,2.5c0,0,298.666,0,399.333,0C448.336,2.5,513.994,13,597,13c77.327,0,135-10.5,200.999-10.5c95.996,0,402.001,0,402.001,0"></path>      </svg>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>GCP 实操练习</title>
      <link href="/posts/3f28c94.html"/>
      <url>/posts/3f28c94.html</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="密码错误" data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="15e82533bcb1293ce756ee9fbcc59de43332ea84af97385de66d9d2187f15914">03c03690e5a2c7a44b2aa66e251c66b95173940c42de79c65734cf256d748a1f3392aea18f5ba83a6ce29c7e1144d90c760cb672ac36819a3e414f16924b3610a129f4732b5b01d6a33086e7ec72383eec2d6c734fee1bd49b773e9dadb57d7103ffc8c872c93bfddda3671e1478d25af326387f2008078db54c42a5501acd5a88b40d06637002c29490e6eca76633cc7d9b1a85d00f9656c8af1ca351c236f451caeb05ff7c8f920c7e6c94d7ac82f57f55764ee39687bd81232ce46b396a6841b9dada990a9709e8d90afcb07cc5a1e3493665540714003cad9c3f0e28a22a</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-xray">      <input class="hbe hbe-input-field hbe-input-field-xray" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-xray" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-xray">密码</span>      </label>      <svg class="hbe hbe-graphic hbe-graphic-xray" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>        <path d="M0,2.5c0,0,298.666,0,399.333,0C448.336,2.5,513.994,13,597,13c77.327,0,135-10.5,200.999-10.5c95.996,0,402.001,0,402.001,0"></path>      </svg>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 练习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GCP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Security 101</title>
      <link href="/posts/e7e09e2.html"/>
      <url>/posts/e7e09e2.html</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="密码错误" data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="15e82533bcb1293ce756ee9fbcc59de43332ea84af97385de66d9d2187f15914">03c03690e5a2c7a44b2aa66e251c66b95173940c42de79c65734cf256d748a1f3392aea18f5ba83a6ce29c7e1144d90c760cb672ac36819a3e414f16924b3610a129f4732b5b01d6a33086e7ec72383eec2d6c734fee1bd49b773e9dadb57d7103ffc8c872c93bfddda3671e1478d25af326387f2008078db54c42a5501acd5a88b40d06637002c29490e6eca76633cc7d9b1a85d00f9656c8af1ca351c236f451caeb05ff7c8f920c7e6c94d7ac82f57f55764ee39687bd81232ce46b396a6841b9dada990a9709e8d90afcb07cc5a1e3493665540714003cad9c3f0e28a22a</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-xray">      <input class="hbe hbe-input-field hbe-input-field-xray" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-xray" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-xray">密码</span>      </label>      <svg class="hbe hbe-graphic hbe-graphic-xray" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>        <path d="M0,2.5c0,0,298.666,0,399.333,0C448.336,2.5,513.994,13,597,13c77.327,0,135-10.5,200.999-10.5c95.996,0,402.001,0,402.001,0"></path>      </svg>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 练习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Security </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>System Design 101</title>
      <link href="/posts/733301f0.html"/>
      <url>/posts/733301f0.html</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="密码错误" data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="15e82533bcb1293ce756ee9fbcc59de43332ea84af97385de66d9d2187f15914">03c03690e5a2c7a44b2aa66e251c66b95173940c42de79c65734cf256d748a1f3392aea18f5ba83a6ce29c7e1144d90c760cb672ac36819a3e414f16924b3610a129f4732b5b01d6a33086e7ec72383eec2d6c734fee1bd49b773e9dadb57d7103ffc8c872c93bfddda3671e1478d25af326387f2008078db54c42a5501acd5a88b40d06637002c29490e6eca76633cc7d9b1a85d00f9656c8af1ca351c236f451caeb05ff7c8f920c7e6c94d7ac82f57f55764ee39687bd81232ce46b396a6841b9dada990a9709e8d90afcb07cc5a1e3493665540714003cad9c3f0e28a22a</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-xray">      <input class="hbe hbe-input-field hbe-input-field-xray" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-xray" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-xray">密码</span>      </label>      <svg class="hbe hbe-graphic hbe-graphic-xray" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>        <path d="M0,2.5c0,0,298.666,0,399.333,0C448.336,2.5,513.994,13,597,13c77.327,0,135-10.5,200.999-10.5c95.996,0,402.001,0,402.001,0"></path>      </svg>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 练习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> System Design </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用算法集合</title>
      <link href="/posts/5470c8ce.html"/>
      <url>/posts/5470c8ce.html</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="密码错误" data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="15e82533bcb1293ce756ee9fbcc59de43332ea84af97385de66d9d2187f15914">03c03690e5a2c7a44b2aa66e251c66b95173940c42de79c65734cf256d748a1f3392aea18f5ba83a6ce29c7e1144d90c760cb672ac36819a3e414f16924b3610a129f4732b5b01d6a33086e7ec72383eec2d6c734fee1bd49b773e9dadb57d7103ffc8c872c93bfddda3671e1478d25af326387f2008078db54c42a5501acd5a88b40d06637002c29490e6eca76633cc7d9b1a85d00f9656c8af1ca351c236f451caeb05ff7c8f920c7e6c94d7ac82f57f55764ee39687bd81232ce46b396a6841b9dada990a9709e8d90afcb07cc5a1e3493665540714003cad9c3f0e28a22a</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-xray">      <input class="hbe hbe-input-field hbe-input-field-xray" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-xray" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-xray">密码</span>      </label>      <svg class="hbe hbe-graphic hbe-graphic-xray" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>        <path d="M0,2.5c0,0,298.666,0,399.333,0C448.336,2.5,513.994,13,597,13c77.327,0,135-10.5,200.999-10.5c95.996,0,402.001,0,402.001,0"></path>      </svg>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 练习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Google Cloud Associate Cloud Engineer</title>
      <link href="/posts/3fb7a84c.html"/>
      <url>/posts/3fb7a84c.html</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p>官网: <a href="https://cloud.google.com/learn/certification/cloud-engineer/">https://cloud.google.com/learn/certification/cloud-engineer/</a></p></blockquote><hr><h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3>]]></content>
      
      
      <categories>
          
          <category> Certification </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GCP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Terraform Associate 003</title>
      <link href="/posts/bb3fbb6d.html"/>
      <url>/posts/bb3fbb6d.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/imgrj2v0kxiwnf99hfja1ood1dwupdaex6.png"></p><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p>官网: <a href="https://developer.hashicorp.com/terraform">https://developer.hashicorp.com/terraform</a><br>Terraform Registry: <a href="https://registry.terraform.io/namespaces/hashicorp">https://registry.terraform.io/namespaces/hashicorp</a></p></blockquote><hr><h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><h4 id="What-is-Terraform"><a href="#What-is-Terraform" class="headerlink" title="What is Terraform"></a>What is Terraform</h4><ul><li><p>Terraform 是一个开源的“基础设施即代码（IaC）”工具，由 HashiCorp 开发。它允许你使用一种声明式语言（HCL，HashiCorp Configuration Language）来定义和管理云资源，比如服务器、数据库、网络、防火墙等</p><ul><li>Terraform 可以管理多个云平台上的基础设施</li><li>基础设施像写代码一样管理</li><li>Terraform 的状态允许您在整个部署过程中跟踪资源变化</li><li>代码审计 + 版本控制（配合 Git）</li></ul></li><li><p>为什么使用 Terraform</p><ul><li>传统部署方式手动点点点 ➜ 易出错、不可重复</li></ul></li><li><p>一些 Terraform 的 Alternatives</p><ul><li>AWS CloudFormation, Azure Resource Manager, GCP Deployment Manager, Pulumi</li></ul></li></ul><hr><h4 id="What-is-Infrastructure-as-Code"><a href="#What-is-Infrastructure-as-Code" class="headerlink" title="What is Infrastructure as Code"></a>What is Infrastructure as Code</h4><ul><li><p><a href="https://www.hashicorp.com/en/blog/infrastructure-as-code-in-a-private-or-public-cloud">Infrastructure as Code</a> 是一种用代码管理和部署基础设施（如服务器、网络、数据库等）的方式。它就像 DevOps 的“建筑图纸”，让你用脚本来创建和管理 IT 环境，而不是手动点击界面操作。</p></li><li><p>IaC 的核心价值</p><ul><li>协作平台: 作为团队协作的中心，让开发、运维等多角色共同构建和管理基础设施</li><li>快速扩展: 用代码快速复制和扩容资源，实现自动化部署</li><li>标准化部署: 所有环境都用相同模板，减少人为错误、提高一致性</li></ul></li></ul><blockquote><p>假设你需要在 AWS 上建一个 S3 桶，传统做法是登录控制台点点点<br>而用 Terraform，你可以写一个文件</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">resource &quot;aws_s3_bucket&quot; &quot;my_bucket&quot; &#123;</span><br><span class="line">  bucket = &quot;hongda-demo-bucket&quot;</span><br><span class="line">  acl    = &quot;private&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="Benefits-of-IaC"><a href="#Benefits-of-IaC" class="headerlink" title="Benefits of IaC"></a>Benefits of IaC</h4>]]></content>
      
      
      <categories>
          
          <category> Certification </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Terraform </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AWS SAP-C02</title>
      <link href="/posts/da74417d.html"/>
      <url>/posts/da74417d.html</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p>官网: <a href="https://aws.amazon.com/certification/certified-solutions-architect-professional/?ch=sec&sec=rmg&d=1">https://aws.amazon.com/certification/certified-solutions-architect-professional/?ch=sec&amp;sec=rmg&amp;d=1</a><br>题库: <a href="https://www.examtopics.com/exams/amazon/aws-certified-solutions-architect-professional-sap-c02/">https://www.examtopics.com/exams/amazon/aws-certified-solutions-architect-professional-sap-c02/</a></p></blockquote><hr><h3 id="1-Identity-amp-Federation"><a href="#1-Identity-amp-Federation" class="headerlink" title="1. Identity &amp; Federation"></a>1. Identity &amp; Federation</h3><h4 id="IAM"><a href="#IAM" class="headerlink" title="IAM"></a>IAM</h4><div style="text-align: center; padding: 0.5rem">🔐 IAM 身份类型一览</div><table><thead><tr><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>Users</td><td>长期凭证用户（用户名+密码 &#x2F; access key）</td></tr><tr><td>Groups</td><td>用户集合，用于统一授权</td></tr><tr><td>Roles</td><td>使用 STS 签发的临时凭证（跨账户、服务访问、EC2 等）</td></tr><tr><td>EC2 Instance Roles</td><td>通过 Instance Metadata Service 获取临时凭证（每个 EC2 一次只能有一个角色）</td></tr><tr><td>Service Roles</td><td>用于 AWS 服务访问另一个服务，如 API Gateway、CodeDeploy 等</td></tr><tr><td>Cross Account Roles</td><td>跨账户访问权限，使用 AssumeRole 实现</td></tr></tbody></table><div style="text-align: center; padding: 0.5rem">📝 IAM 策略类型</div><table><thead><tr><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>AWS Managed Policy</td><td>AWS 预定义的策略，如 <code>AdministratorAccess</code></td></tr><tr><td>Customer Managed</td><td>你创建和维护的可复用策略</td></tr><tr><td>Inline Policy</td><td>直接嵌入到用户 &#x2F; 组 &#x2F; 角色上的策略，作用域限于该实体</td></tr><tr><td>Resource-based Policy</td><td>应用于资源上的策略，如 S3 Bucket、SQS Queue 等</td></tr></tbody></table><div style="text-align: center; padding: 0.5rem">🔍 IAM 工具与可视化</div><table><thead><tr><th>工具名称</th><th>作用</th></tr></thead><tbody><tr><td>Access Advisor</td><td>查看角色或用户的权限实际使用情况（支持最近访问时间）</td></tr><tr><td>Access Analyzer</td><td>检查资源是否被外部实体共享（例如 S3 Bucket 公开、KMS Key 共享）</td></tr><tr><td>Policy Simulator</td><td>模拟策略效果，验证策略是否按预期生效</td></tr></tbody></table><hr><h4 id="IAM-Policy"><a href="#IAM-Policy" class="headerlink" title="IAM Policy"></a>IAM Policy</h4><ul><li>IAM 策略是一个 JSON 文档，通常包含以下字段</li></ul><table><thead><tr><th>字段</th><th>说明</th></tr></thead><tbody><tr><td><code>&quot;Effect&quot;</code></td><td>策略效果，可为 <code>&quot;Allow&quot;</code> 或 <code>&quot;Deny&quot;</code></td></tr><tr><td><code>&quot;Action&quot;</code></td><td>允许的操作，例如 <code>&quot;s3:GetObject&quot;</code></td></tr><tr><td><code>&quot;NotAction&quot;</code></td><td>明确排除的操作（通常与 <code>&quot;Effect&quot;: &quot;Allow&quot;</code> 搭配使用）</td></tr><tr><td><code>&quot;Resource&quot;</code></td><td>作用的资源 ARN，例如 <code>&quot;arn:aws:s3:::my-bucket/*&quot;</code></td></tr><tr><td><code>&quot;Condition&quot;</code></td><td>可选字段，用于添加附加限制条件</td></tr></tbody></table><ul><li><strong>显式 <code>Deny</code> 优先于 <code>Allow</code></strong>  </li><li><strong>最佳实践：始终遵循最小权限原则（Least Privilege）</strong></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img520756.png"></p><hr><h4 id="IAM-Policies-Variables-and-Tags"><a href="#IAM-Policies-Variables-and-Tags" class="headerlink" title="IAM Policies Variables and Tags"></a>IAM Policies Variables and Tags</h4><ul><li><code>$&#123;aws:username&#125;</code>: 代表当前执行请求的 IAM 用户名</li><li><code>AWS Specific</code>: aws:CurrentTime, aws:TokenIssueTime, aws:principaltype…</li><li><code>Service Specific</code>: s3:prefix, s3:max-keys, s3:x-amz-acl…</li><li><code>Tag Based</code>: iam:ResourceTag&#x2F;key-name, aws:PrincipalTag&#x2F;key-name…</li></ul><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;Effect&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Allow&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;Action&quot;</span><span class="punctuation">:</span> <span class="string">&quot;s3:*&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;Resource&quot;</span><span class="punctuation">:</span> <span class="string">&quot;arn:aws:s3:::mybucket/$&#123;aws:username&#125;/*&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><ul><li>假设 IAM 用户 alice 发起了请求，那么这个 policy 中的变量就会自动替换成</li></ul><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;Resource&quot;</span><span class="punctuation">:</span> <span class="string">&quot;arn:aws:s3:::mybucket/alice/*&quot;</span></span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img042721.png"></p><hr><h4 id="IAM-Roles-vs-Resource-Based-Policies"><a href="#IAM-Roles-vs-Resource-Based-Policies" class="headerlink" title="IAM Roles vs Resource Based Policies"></a>IAM Roles vs Resource Based Policies</h4><ul><li>IAM 中的访问控制可以通过两种方式实现<ul><li>使用角色（IAM Role）：通过扮演角色进行访问（代理身份）</li><li>使用资源策略（Resource-based Policy）：直接将权限附加在资源上</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img042719.png"></p><ul><li>IAM Role 示例：A 账户中的 Lambda 要访问 B 账户中的 DynamoDB，A 账户的 Lambda 必须 Assume B 账户中的角色</li><li>Resource-based Policy 示例：B 账户的 S3 Bucket Policy 直接允许 A 账户的某个角色或服务访问该 Bucket</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img421721.png"></p><div style="text-align: center; padding: 0.5rem">🆚 IAM Role vs Resource-based Policy 对比总结</div><table><thead><tr><th>维度</th><th>IAM Role（角色）</th><th>Resource-based Policy（资源策略）</th></tr></thead><tbody><tr><td>附加位置</td><td>附加在身份（User、Service、Account）上</td><td>附加在资源上（如 S3 Bucket、SQS、KMS 等）</td></tr><tr><td>使用方式</td><td>访问方先 AssumeRole，临时获取权限</td><td>资源接收外部请求时，根据策略判断是否允许访问</td></tr><tr><td>适用场景</td><td>用户 &#x2F; 服务访问其他账户资源</td><td>资源授权给外部账户、服务或匿名用户</td></tr><tr><td>支持跨账户访问</td><td>✅ 是，通过 <code>AssumeRole</code> 实现</td><td>✅ 是，直接在资源上允许其他账户 &#x2F; 服务访问</td></tr><tr><td>例子</td><td>EC2 实例角色、Lambda 执行角色、跨账户访问角色</td><td>S3 Bucket Policy、SQS Queue Policy、KMS Key Policy</td></tr><tr><td>授权主体控制权在哪一方？</td><td>访问者（主动扮演角色）</td><td>资源拥有者（决定谁可访问资源）</td></tr></tbody></table><hr><h4 id="IAM-Permission-Boundaries"><a href="#IAM-Permission-Boundaries" class="headerlink" title="IAM Permission Boundaries"></a>IAM Permission Boundaries</h4><ul><li>Permission Boundary 是一种高级 IAM 控制机制，用于为 User 或 Role 设置权限上限。⚠️ 不支持用于 Group<ul><li>假设用户 A 被授予了 AdministratorAccess（几乎所有权限）</li><li>但他的 Permission Boundary 限定为只允许：s3:<em>, ec2:</em>, cloudwatch:*</li><li>结果, 用户 A 无法执行 iam:CreateUser，即使他的策略中写了也无效</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img421726.png"></p><ul><li>委托权限给非管理员: 比如让开发者自行管理权限（但不能升权）</li><li>允许自助权限管理: 用户可以 attach policy，但受 boundary 限制</li><li>精细限制特定用户或角色: 针对关键岗位做严格边界控制</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img421729.png"></p><hr><h4 id="IAM-Access-Analyzer"><a href="#IAM-Access-Analyzer" class="headerlink" title="IAM Access Analyzer"></a>IAM Access Analyzer</h4><ul><li>Access Analyzer 是 IAM 的可视化工具，用于帮助你识别资源是否被意外共享，并提供策略分析与建议功能。</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img425312.png"></p><ul><li>IAM Access Analyzer Policy Validation<ul><li>Validates your policy against IAM policy grammar and best practices</li><li>自动检查 IAM Policy 是否符合语法 + 安全最佳实践</li></ul></li><li>IAM Access Analyzer Policy Generation<ul><li>Generates IAM policy based on access activity</li><li>根据实际访问行为自动生成最小权限策略（least privilege）</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img425314.png"></p><hr><h4 id="STS-Security-Token-Service"><a href="#STS-Security-Token-Service" class="headerlink" title="STS (Security Token Service)"></a>STS (Security Token Service)</h4><ul><li><p>使用 AWS Security Token Service (STS)，你可以让一个用户、服务或应用 临时扮演另一个 IAM Role，获取一组短期凭证</p></li><li><p>定义 IAM Role（本账户或跨账户）</p><ul><li>信任策略（Trust Policy）：定义谁可以 assume 这个角色（哪些 Principal）</li><li>权限策略（Permissions Policy）：定义这个角色 assume 后能做什么操作</li></ul></li><li><p>示例 Trust Policy（允许 IAM 用户 assume 该角色）</p></li></ul><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;Effect&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Allow&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;Principal&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;AWS&quot;</span><span class="punctuation">:</span> <span class="string">&quot;arn:aws:iam::123456789012:user/developer&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;Action&quot;</span><span class="punctuation">:</span> <span class="string">&quot;sts:AssumeRole&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><ul><li>使用 AWS STS 获取临时凭证：调用 AssumeRole API，获得临时凭证</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">aws sts assume-role \</span><br><span class="line">  --role-arn <span class="string">&quot;arn:aws:iam::123456789012:role/MyRole&quot;</span> \</span><br><span class="line">  --role-session-name <span class="string">&quot;example-session&quot;</span></span><br></pre></td></tr></table></figure><ul><li>临时凭证有效期：可配置范围：15 分钟 ~ 12 小时</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img204619.png"></p><table><thead><tr><th>场景</th><th>描述</th></tr></thead><tbody><tr><td>🔄 跨账户访问</td><td>让账户 A 的用户访问账户 B 的资源（你拥有两个账户）</td></tr><tr><td>🤝 第三方访问授权</td><td>授权第三方（如供应商）账户的 IAM 用户访问你账户中的资源</td></tr><tr><td>☁️ AWS 服务间访问</td><td>EC2、Lambda 等 AWS 服务通过 role 访问其他资源（S3、DynamoDB 等）</td></tr><tr><td>🌐 身份联合（Federation）</td><td>外部身份源（如 AD、Google、SAML）用户通过联合登录后 assume 角色</td></tr><tr><td>⛔ 会话吊销机制</td><td>使用 <code>aws:TokenIssueTime</code> + 条件策略吊销旧会话（<code>AWSRevokeOlderSessions</code>）</td></tr></tbody></table><ul><li>你可以让某个账户中的 IAM 用户切换身份，访问另一个账户（或同账户）中的 IAM Role</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img204957.png"></p><ul><li>如何安全地授权第三方 AWS 账户访问你资源中的 IAM Role<ul><li>Zone of Trust：你自己拥有的账户或 AWS Organization</li><li>Outside Zone of Trust：第三方拥有的 AWS 账户（如供应商、合作伙伴）</li></ul></li><li>访问授权流程（给第三方账户）<ul><li>第三方的 AWS Account ID</li><li>一个 External ID（共享的 secret 字符串，由第三方提供）</li><li>在你账户中创建 IAM Role<ul><li>指定允许 AssumeRole 的 AWS 账户 ID</li><li>添加 Condition 限制 External ID，确保只授权给特定第三方</li></ul></li><li>第三方 assume 该角色<ul><li>在调用 AssumeRole 时必须提供正确的 External ID，否则拒绝访问</li></ul></li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img205645.png"></p><ul><li>External ID 的重要性</li></ul><table><thead><tr><th>功能</th><th>说明</th></tr></thead><tbody><tr><td>🧿 防止“confused deputy” 攻击</td><td>防止别人冒用第三方身份去 assume 你暴露的角色</td></tr><tr><td>🔒 安全通道</td><td>External ID 是你与第三方之间的秘密，AWS 作为验证者</td></tr><tr><td>🤝 明确授权对象</td><td>你可以根据不同第三方使用不同 External ID，实现绑定</td></tr></tbody></table><ul><li>Session Tags in STS<ul><li>当你通过 STS AssumeRole &#x2F; AssumeRoleWithSAML &#x2F; AssumeRoleWithWebIdentity 获取临时凭证时，可以附带自定义 Tag，这些 Tag 会作为“身份元信息”跟随该会话</li></ul></li></ul><table><thead><tr><th>功能</th><th>描述</th></tr></thead><tbody><tr><td>🏷️ 权限控制</td><td>可用于通过 IAM Policy 中的 <code>aws:PrincipalTag</code> 条件限制资源访问</td></tr><tr><td>🔍 审计追踪</td><td>Session tags 会显示在 CloudTrail 中，便于审计</td></tr><tr><td>🧑‍💼 用户信息传递</td><td>可以传递比如 <code>Department=Finance</code>、<code>Project=Alpha</code> 这样的上下文信息</td></tr><tr><td>🔐 安全增强</td><td>限制只有具有特定 tag 的用户才能传递某些 tag（防止伪造）</td></tr></tbody></table><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img210325.png"></p><table><thead><tr><th>API 名称</th><th>描述</th></tr></thead><tbody><tr><td><strong>AssumeRole</strong></td><td>获取临时凭证以访问本账户或跨账户的 IAM Role，最常用的 STS 接口。</td></tr><tr><td><strong>AssumeRoleWithSAML</strong></td><td>为通过 SAML 登录的用户返回临时凭证，常用于企业 SSO（如 AD FS）。</td></tr><tr><td><strong>AssumeRoleWithWebIdentity</strong></td><td>为通过 Web Identity Provider（如 Cognito、Facebook、Google、OIDC）登录的用户提供临时凭证。AWS 推荐使用 Cognito。</td></tr><tr><td><strong>GetSessionToken</strong></td><td>获取当前 IAM 用户或 Root 用户的临时凭证，常与 MFA 一起使用。</td></tr><tr><td><strong>GetFederationToken</strong></td><td>为联合用户（不在 IAM 中注册的用户）获取临时凭证，常用于代理程序或内部网络中的应用。</td></tr></tbody></table><hr><h4 id="Identity-Federation-in-AWS"><a href="#Identity-Federation-in-AWS" class="headerlink" title="Identity Federation in AWS"></a>Identity Federation in AWS</h4><ul><li>Give users outside of AWS permissions to access AWS resources in your account</li><li>允许 AWS 账户外部的用户 获取对 AWS 资源的访问权限，无需创建 IAM 用户<ul><li>SAML 2.0, Custom Identity Broker, WebIdentityFederationWith(out)AmazonCognito, IAM Identity Center</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img426112.png"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+----------+     Authenticate    +-----------------+</span><br><span class="line">|   User   | -----------------&gt; | External IdP     |</span><br><span class="line">+----------+                    +-----------------+</span><br><span class="line">                                    |</span><br><span class="line">                                    v</span><br><span class="line">                      [Get Token / Assertion from IdP]</span><br><span class="line">                                    |</span><br><span class="line">                                    v</span><br><span class="line">                     +-----------------------------+</span><br><span class="line">                     | STS (AssumeRoleXxx)         |</span><br><span class="line">                     +-----------------------------+</span><br><span class="line">                                    |</span><br><span class="line">                                    v</span><br><span class="line">                     [Get Temporary Credentials]</span><br><span class="line">                                    |</span><br><span class="line">                                    v</span><br><span class="line">                          Access AWS Resources</span><br></pre></td></tr></table></figure><hr><h4 id="AWS-Directroy-Service-AD"><a href="#AWS-Directroy-Service-AD" class="headerlink" title="AWS Directroy Service (AD)"></a>AWS Directroy Service (AD)</h4><ul><li>Active Directory（AD） 是微软在 Windows Server 中提供的目录服务，用于集中管理网络中的用户、计算机、资源和权限</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img426133.png"></p><table><thead><tr><th>功能</th><th>说明</th></tr></thead><tbody><tr><td>🎯 用户管理</td><td>创建&#x2F;修改用户账号，设置密码策略、登录权限等</td></tr><tr><td>🖥️ 资源管理</td><td>统一管理计算机、打印机、文件共享等资源</td></tr><tr><td>🔐 权限分配</td><td>使用组（Security Groups）来简化访问控制</td></tr><tr><td>🗂️ 集中认证（SSO）</td><td>用户只需登录一次，便可访问多个网络资源（Kerberos 协议）</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Forest</span><br><span class="line">└── Tree (example.com)</span><br><span class="line">    ├── Domain: example.com</span><br><span class="line">    │   ├── OU: HR</span><br><span class="line">    │   │   └── User: Alice</span><br><span class="line">    │   ├── OU: IT</span><br><span class="line">    │   │   └── Computer: IT-PC-01</span><br><span class="line">    └── Domain: sub.example.com</span><br></pre></td></tr></table></figure><ul><li>AWS Directory Services</li></ul><table><thead><tr><th>服务名称</th><th>描述</th><th>是否与本地 AD 集成</th><th>支持 MFA</th><th>用户存储位置</th></tr></thead><tbody><tr><td>AWS Managed Microsoft AD</td><td>AWS 托管的 Microsoft AD，完全兼容，支持 AD 信任关系</td><td>✅（支持信任）</td><td>✅</td><td>存在 AWS 托管 AD 中</td></tr><tr><td>AD Connector</td><td>目录代理，充当 AWS 和本地 AD 的桥梁（不存储用户数据）</td><td>✅（直连）</td><td>✅</td><td>用户存储在本地 AD</td></tr><tr><td>Simple AD</td><td>AWS 提供的简化版、兼容 AD 协议的托管目录，适合轻量应用</td><td>❌（无法信任）</td><td>❌</td><td>存储在 AWS Simple AD</td></tr></tbody></table><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img4261136.png"></p><ul><li><code>AWS Managed Microsoft AD</code>（托管 Microsoft AD）<ul><li>完全托管的 Active Directory，运行在你的 AWS VPC 内，适合需要微软 AD 功能的企业工作负载</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+----------------------+        +----------------------+</span><br><span class="line">|   Availability Zone 1|        |   Availability Zone 2|</span><br><span class="line">|                      |        |                      |</span><br><span class="line">|  +----------------+  |        |  +----------------+  |</span><br><span class="line">|  |   AD DC        |  |        |  |   AD DC        |  |</span><br><span class="line">|  +----------------+  |        |  +----------------+  |</span><br><span class="line">|        ^   ^         |        |        ^   ^         |</span><br><span class="line">|       /     \        |        |       /     \        |</span><br><span class="line">|   EC2 / Apps  \      |        |   EC2 / Apps  \      |</span><br><span class="line">+----------------------+        +----------------------+</span><br><span class="line"></span><br><span class="line">            ↕  Auto replication</span><br><span class="line">      ↔ Cross-VPC / Multi-Account Join</span><br></pre></td></tr></table></figure><ul><li>Connect to on-premises AD<ul><li>在 AWS 中部署 AWS Managed Microsoft AD 后，可以通过 VPN 或 Direct Connect 与你现有的 本地 AD（on-premises AD） 建立 信任关系（Trust）</li></ul></li></ul><p>连接方式</p><table><thead><tr><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>🛰️ VPN</td><td>使用 AWS Site-to-Site VPN 建立加密连接</td></tr><tr><td>⚡ Direct Connect</td><td>使用 AWS DX 提供更稳定的私网连接</td></tr></tbody></table><p>支持的信任类型（Forest Trust）</p><table><thead><tr><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>🔁 双向信任 (Two-way)</td><td>AWS 和本地 AD 相互信任，可双向身份验证</td></tr><tr><td>👉 单向信任：AWS ➝ 本地 AD</td><td>AWS 用户可以访问本地资源</td></tr><tr><td>👉 单向信任：本地 ➝ AWS</td><td>本地用户可以访问 AWS 中的资源</td></tr></tbody></table><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img426123.png"></p><ul><li>Solution Architecture: Active Directory Replication<ul><li>为了降低延迟并提高可用性，可在 AWS 中部署本地 AD 的副本，以便在 VPN 或 Direct Connect 连接中断时仍可正常认证和访问资源</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img4261229.png"></p><ul><li><code>AWS Directory Services AD Connector</code><ul><li>AD Connector 是一种目录网关（Directory Gateway），用于将 AWS 内的身份验证请求转发至你的 本地 Microsoft Active Directory</li><li>适合纯身份验证代理，不支持 SQL Server</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img4261231.png"></p><ul><li><code>AWS Directory Services Simple AD</code><ul><li>Simple AD 是一种低成本、轻量级的目录服务，兼容 Microsoft Active Directory，适用于小规模身份认证需求</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img42561234.png"></p><table><thead><tr><th>目录服务类型</th><th>是否支持 Trust</th><th>支持 SSO</th><th>支持 MFA</th><th>用户管理位置</th><th>最大用户数</th></tr></thead><tbody><tr><td>Simple AD</td><td>❌ 不支持</td><td>❌ 不支持</td><td>❌ 不支持</td><td>托管在 AWS</td><td>500 &#x2F; 5000</td></tr><tr><td>AD Connector</td><td>❌ 不支持</td><td>✅ 支持</td><td>✅ 支持</td><td>本地 AD</td><td>取决于本地 AD</td></tr><tr><td>Managed Microsoft AD</td><td>✅ 支持</td><td>✅ 支持</td><td>✅ 支持</td><td>托管在 AWS</td><td>可扩展</td></tr></tbody></table><hr><h4 id="AWS-Organizations"><a href="#AWS-Organizations" class="headerlink" title="AWS Organizations"></a>AWS Organizations</h4><ul><li>AWS Organizations 允许你在一个统一的管理框架下，集中管理多个 AWS 账户。可通过组织单元（Organizational Units，OUs）分组，并应用策略统一控制<ul><li><code>Root</code>: 整个组织的顶层节点，包含所有 OUs 和账号</li><li><code>Management Account</code>: 用于创建组织、邀请账号、应用 SCP 策略</li><li><code>Organizational Unit (OU)</code>: 类似目录结构中的文件夹，用于逻辑分组账户（如 Dev、Prod、HR）</li><li><code>Member Accounts</code>: 加入组织的子账户，可继承 OU 的策略限制，但不具备组织控制权</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img4261238.png"></p><ul><li>AWS Organizations - <code>OrganizationAccountAccessRole</code><ul><li>这是一个 IAM 角色，用于允许 管理账户（Management Account） 对 成员账户（Member Accounts） 执行管理员操作</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img4261240.png"></p><ul><li>AWS Multi-Account Strategies<ul><li>在企业级架构中，采用多个 AWS 账户（Multi-Account）可以带来更高的安全性、资源隔离性和可扩展性</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img4261242.png"></p><ul><li>AWS Organizations – Feature Modes<ul><li>AWS Organizations 提供两种功能模式（Feature Sets），控制组织可用的功能范</li></ul></li></ul><p><code>Consolidated Billing Features</code>（账单整合模式）</p><table><thead><tr><th>特性</th><th>说明</th></tr></thead><tbody><tr><td>💳 统一账单管理</td><td>所有成员账户共享一个支付方式，由管理账户付款</td></tr><tr><td>💰 使用量聚合优惠</td><td>像 EC2、S3 这类资源使用量可跨账户聚合，享受更高折扣</td></tr><tr><td>🚫 无 SCP（Service Control Policies）支持</td><td>无法进行权限统一限制管理</td></tr></tbody></table><p><code>All Features</code>（全功能模式）✅ 默认选项</p><table><thead><tr><th>特性</th><th>说明</th></tr></thead><tbody><tr><td>✅ 包含 Consolidated Billing 所有功能</td><td>继承账单整合模式的所有优点</td></tr><tr><td>✅ 启用 Service Control Policies（SCP） 管理成员账户权限</td><td>可统一管理成员账户的服务访问权限</td></tr><tr><td>✅ 可将账户从组织中“锁定”</td><td>通过 SCP 防止成员账户擅自离开组织</td></tr><tr><td>🔐 更细粒度控制</td><td>适用于多账户安全与合规性架构</td></tr><tr><td>⚠️ 一旦启用，无法回退 到仅账单模式</td><td>启用后无法降级回 Consolidated Billing 模式</td></tr></tbody></table><ul><li>AWS Organizations – Moving Accounts（迁移账户）<ul><li>从原 Organization 中移除成员账户</li><li>从目标 Organization 发送邀请</li><li>成员账户接受邀请</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img4261248.png"></p><hr><h4 id="Service-Control-Policies-SCP"><a href="#Service-Control-Policies-SCP" class="headerlink" title="Service Control Policies (SCP)"></a>Service Control Policies (SCP)</h4><ul><li>SCP 是 AWS Organizations 的一种权限控制机制，用于对组织中的账户进行统一的服务访问控制</li><li>作用范围为 OU 或账户层级, 不作用于管理账户（Management Account）</li><li>作用于账号中的所有用户和角色, 包括 Root User，但不包括 Service-linked Roles</li><li>策略继承机制: SCP 的生效路径必须从 Root OU 到目标账号 每一层都有 Allow，默认不允许任何操作</li></ul><table><thead><tr><th>对象</th><th>作用域</th><th>控制行为</th></tr></thead><tbody><tr><td>IAM Policy</td><td>用户 &#x2F; 角色</td><td>定义用户可做什么</td></tr><tr><td>SCP</td><td>账号 &#x2F; OU</td><td>定义账号最多能做什么（权限上限）</td></tr></tbody></table><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img427514.png"></p><table><thead><tr><th>用例场景</th><th>示例</th></tr></thead><tbody><tr><td>🚫 禁止使用某些服务</td><td>禁止某个 OU 下使用 EMR、CloudShell 等高风险服务</td></tr><tr><td>✅ 限制资源创建区域</td><td>限制只能在 us-east-1 区域中使用服务</td></tr><tr><td>📋 强制合规策略</td><td>确保某些服务（如 RDS）开启加密，或关闭不合规服务以满足 PCI、HIPAA 要求</td></tr><tr><td>🔐 限制 root 权限</td><td>虽然 root 无法被删除，但可通过 SCP 禁止其访问敏感服务</td></tr></tbody></table><ul><li>Service Control Policies (SCP) 会沿着 Organizational Unit (OU) 层级向下继承，形成最终每个账户的权限上限</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Root OU (applies: FullAWSAccess)</span><br><span class="line">│</span><br><span class="line">├── Management Account → ✅ 不受 SCP 限制（Can do anything）</span><br><span class="line">│</span><br><span class="line">├── OU: Workloads (applies: FullAWSAccess)</span><br><span class="line">│   ├── OU: Test (applies: Deny EC2)</span><br><span class="line">│   │   └── Account D → ❌ EC2 被禁止，其余允许</span><br><span class="line">│   │</span><br><span class="line">│   └── OU: Prod (applies: FullAWSAccess)</span><br><span class="line">│       ├── Account E → ✅ 全部允许</span><br><span class="line">│       └── Account F → ✅ 全部允许</span><br><span class="line">│</span><br><span class="line">└── OU: Sandbox (applies: Deny S3)</span><br><span class="line">    ├── Account A → ❌ S3 被禁止（来自 Sandbox OU）  </span><br><span class="line">    ├── Account B → ❌ S3 被禁止（Sandbox）  </span><br><span class="line">    └── Account C → ❌ S3 被禁止（Sandbox）  </span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img427517.png"></p><ul><li>左边: 除了 DynamoDB 被禁用，其他服务（S3、EC2、Lambda 等）都可以用</li><li>右边: 除了 ec2:* 和 cloudwatch:* 以外的服务（如 S3、RDS、IAM）全部不允许访问</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img4275518.png"></p><ul><li>IAM Policy Evaluation Logic（权限评估逻辑）<ul><li><ol><li><code>Deny Evaluation</code>（最先评估）: 是否有明确 Deny? 如果存在显式 Deny（例如 IAM Policy、SCP、Resource Policy 中），立即终止评估，决策为 Deny（优先级最高）</li></ol></li><li><ol start="2"><li><code>Organizations SCPs</code>（组织级服务控制策略）: 如果账户有 SCP，则必须在 SCP 中允许相应操作</li></ol></li><li><ol start="3"><li><code>Resource-based Policies</code>（资源级策略）: 比如 S3 Bucket Policy、Lambda Resource Policy、KMS Key Policy 等, 若不允许，继续下一个阶段</li></ol></li><li><ol start="4"><li><code>Identity-based Policies</code>（身份策略）: 评估 IAM User&#x2F;Role&#x2F;Group 的策略是否存在有效的 Allow? 若无，则隐式拒绝（Implicit Deny）</li></ol></li><li><ol start="5"><li><code>IAM Permissions Boundaries</code>（权限边界）: 权限边界也会限制一个用户&#x2F;角色的最大权限范围, 必须同时满足 Identity Policy 和 Boundary 才能通过</li></ol></li><li><ol start="6"><li><code>Session Policies</code>（会话策略）: 如果是通过临时凭证（例如 AssumeRole）访问，会话中可能附带 policy</li></ol></li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img427519.png"></p><hr><h4 id="IAM-Identity-Center"><a href="#IAM-Identity-Center" class="headerlink" title="IAM Identity Center"></a>IAM Identity Center</h4><ul><li>Formerly known as AWS Single Sign-On (SSO)</li></ul><table><thead><tr><th>功能</th><th>描述</th></tr></thead><tbody><tr><td>🔐 统一登录（Single Sign-On）</td><td>实现一次登录，访问多个 AWS 账户及业务应用</td></tr><tr><td>🔄 集中式身份访问管理</td><td>统一管理用户权限，跨账户&#x2F;跨区域生效</td></tr><tr><td>🧑‍💼 支持多种身份源</td><td>内置用户目录 + 第三方 IdP（如 AD、Okta）</td></tr></tbody></table><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img427534.png"></p><ul><li>AWS IAM Identity Center（前 AWS SSO） 的架构整合与工作流程</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 用户通过浏览器登录 Identity Center</span><br><span class="line">2. 后端通过内置目录或 AD 确认身份</span><br><span class="line">3. 根据用户绑定的 Permission Set 分配访问权限</span><br><span class="line">4. 自动 SSO 到：</span><br><span class="line">   - AWS 控制台（多个账户）</span><br><span class="line">   - SaaS 应用</span><br><span class="line">   - 支持 SAML2.0 的自定义系统</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img427536.png"></p><ul><li>IAM Identity Center 与 AWS Organizations 的集成结构 <ul><li>如何通过权限集（Permission Set）为用户跨账户赋权</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Bob 和 Alice 属于 Developers 组 →</span><br><span class="line">Developers 组被赋予：</span><br><span class="line">  - ReadOnlyAccess → Dev Account A</span><br><span class="line">  - FullAccess → Prod Account A</span><br><span class="line"></span><br><span class="line">➡️ 用户登录后会看到对应 AWS 账户及其可选的 Role</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img427538.png"></p><ul><li>AWS IAM Identity Center – Fine-grained Permissions and Assignments（细粒度权限与授权）</li></ul><p>Multi-Account Permissions（跨账户权限）</p><table><thead><tr><th>功能</th><th>描述</th></tr></thead><tbody><tr><td>✅ 跨账户权限管理</td><td>管理整个 AWS Organization 中多个账户的访问权限</td></tr><tr><td>📦 Permission Set</td><td>一组 IAM Policy 的集合，用于赋予用户&#x2F;组 AWS 账户访问权限</td></tr><tr><td>➕ 权限赋予机制</td><td>将 Permission Set 分配给用户&#x2F;组 + 指定账户，即可跨账户访问</td></tr></tbody></table><p>Application Assignments（SAML 应用授权）</p><table><thead><tr><th>功能</th><th>描述</th></tr></thead><tbody><tr><td>✅ SSO 访问企业 SaaS 应用</td><td>支持 Salesforce、Box、Microsoft 365 等 SAML 2.0 应用</td></tr><tr><td>🔐 提供所需的连接信息</td><td>包括 SAML URL、证书、Metadata 供应用配置使用</td></tr></tbody></table><p>Attribute-Based Access Control (ABAC)</p><table><thead><tr><th>功能</th><th>描述</th></tr></thead><tbody><tr><td>🏷️ 基于用户属性的权限控制</td><td>可根据用户属性自动应用权限，降低手动维护成本</td></tr><tr><td>示例属性</td><td><code>costcenter</code>, <code>title</code>, <code>locale</code> 等</td></tr><tr><td>用例</td><td>定义一次权限，后续通过修改属性控制访问范围，无需修改策略</td></tr></tbody></table><hr><h4 id="AWS-Control-Tower"><a href="#AWS-Control-Tower" class="headerlink" title="AWS Control Tower"></a>AWS Control Tower</h4><ul><li>AWS Control Tower 是一种自动化搭建、管理安全合规多账户环境的服务，基于 AWS 最佳实践</li><li>Control Tower 依赖 AWS Organizations 管理多账户结构</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img428831.png"></p><ul><li>AWS Control Tower – Account Factory<ul><li>Account Factory 是 AWS Control Tower 提供的一个自动化工具，用来标准化和批量创建新的 AWS 账户</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img428832.png"></p><ul><li>AWS Control Tower – Detect and Remediate Policy Violations<ul><li>Control Tower 通过 Guardrails（护栏规则） 来持续监控和管理账户环境中的合规性</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img428834.png"></p><ul><li>AWS Control Tower – Guardrails Levels<ul><li>Guardrails（护栏规则）按重要性和强制性被分为三种不同级别</li></ul></li></ul><table><thead><tr><th>等级</th><th>描述</th><th>示例</th></tr></thead><tbody><tr><td>🛡️ Mandatory （强制）</td><td>自动启用，AWS Control Tower 必须强制执行</td><td>禁止 Log Archive 账户对外公开读权限</td></tr><tr><td>💬 Strongly Recommended （强烈推荐）</td><td>根据 AWS 最佳实践推荐，启用可提升安全性，但可选</td><td>建议为 EC2 挂载的 EBS 卷启用加密</td></tr><tr><td>📝 Elective （自选）</td><td>企业常用的附加控制措施，可根据需要选择性启用</td><td>禁止无 MFA 的 S3 删除操作</td></tr></tbody></table><hr><h4 id="AWS-Resource-Access-Manager-RAM"><a href="#AWS-Resource-Access-Manager-RAM" class="headerlink" title="AWS Resource Access Manager (RAM)"></a>AWS Resource Access Manager (RAM)</h4><ul><li>AWS RAM 允许你将 AWS 资源跨账户共享，避免资源重复创建，提高资源利用率和成本效益</li><li>利用 RAM 共享 VPC 子网，多个账户的资源可以部署在同一个 VPC 中，同时保持账户级资源隔离</li><li></li></ul><p>支持共享的资源示例</p><table><thead><tr><th>资源类型</th><th>说明</th></tr></thead><tbody><tr><td>🌐 VPC 子网（Subnets）</td><td>允许多个账户的资源部署到同一个子网内（但必须同属一个 AWS Organization）</td></tr><tr><td>🚫 限制</td><td>不支持共享 Security Groups 和 Default VPC</td></tr><tr><td>🚍 Transit Gateway</td><td>多账户共用同一个 Transit Gateway 实现网络互通</td></tr><tr><td>🌎 Route 53</td><td>可以共享 Resolver 规则、DNS Firewall 规则组等</td></tr><tr><td>🛡️ License Manager 配置</td><td>跨账户统一管理许可证分配</td></tr></tbody></table><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img428837.png"></p><hr><h3 id="2-Security"><a href="#2-Security" class="headerlink" title="2. Security"></a>2. Security</h3><h4 id="CloudTrail"><a href="#CloudTrail" class="headerlink" title="CloudTrail"></a>CloudTrail</h4><ul><li>CloudTrail 是 AWS 的日志审计服务，用于记录账号中的所有 API 调用历史，便于审计、合规与安全调查（资源删除了？先查 CloudTrail！）</li><li><code>默认启用</code>: 每个 AWS 账户自动启用基本事件记录（90 天内）</li><li><code>记录所有 API 调用</code>: 包括通过控制台、SDK、CLI、AWS 服务内部调用等</li><li><code>跨区域支持</code>: 可选择记录单个 Region，或跨 Region（默认 All Regions）</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img220750.png"></p><p>CloudTrail 事件类型对比</p><table><thead><tr><th>事件类型</th><th>默认启用</th><th>是否高频</th><th>是否区分读写</th><th>示例</th></tr></thead><tbody><tr><td>Management Events</td><td>✅ 是</td><td>中频</td><td>✅ 可区分</td><td>IAM, EC2, CloudTrail</td></tr><tr><td>Data Events</td><td>❌ 否</td><td>高频</td><td>✅ 可区分</td><td>S3 对象, Lambda 调用</td></tr><tr><td>CloudTrail Insights</td><td>❌ 否</td><td>智能检测</td><td>无需区分</td><td>检测突增&#x2F;异常行为</td></tr></tbody></table><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img221339.png"></p><ul><li>CloudTrail Events Retention<ul><li>默认保留期限: 90 天（CloudTrail 控制台中默认可查询的事件时间范围）</li><li>长期保存: 若需保存超过 90 天，需将日志写入 S3 存储桶</li><li>查询分析: 可配合 Amazon Athena 查询存储在 S3 中的历史日志，实现结构化分析</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img221603.png"></p><ul><li>EventBridge + CloudTrail<ul><li>通过 Amazon EventBridge + CloudTrail 拦截 AWS API 调用，用于实时安全响应与告警</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">用户发起 DeleteTable API 操作 ➝ 被 CloudTrail 记录 ➝ 事件被 EventBridge 捕捉 ➝ 发出 SNS 告警</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img221813.png"></p><hr><h4 id="KMS-Key-Management-Service"><a href="#KMS-Key-Management-Service" class="headerlink" title="KMS (Key Management Service)"></a>KMS (Key Management Service)</h4><ul><li>KMS 是 AWS 提供的托管密钥服务，用于管理加密、解密和密钥授权，几乎涉及所有数据加密的场景</li><li><code>数据加密引擎</code>: AWS 中所有“加密”相关功能几乎都依赖 KMS</li><li><code>密钥托管与控制</code>: AWS 管理密钥的生命周期（创建、轮换、禁用等）</li><li><code>与 IAM 集成授权</code>: 使用 IAM 权限控制谁能访问或使用密钥</li><li>KMS 支持两种类型的密钥：对称密钥（Symmetric） 和 非对称密钥（Asymmetric）</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img224545.png"></p><p>KMS 密钥类型对比</p><table><thead><tr><th>特性</th><th>Customer Managed Key</th><th>AWS Managed Key</th><th>AWS Owned Key</th></tr></thead><tbody><tr><td>用户控制</td><td>✅ 完全控制</td><td>❌ 受限</td><td>❌ 无法控制</td></tr><tr><td>自动轮换</td><td>✅ 可启用</td><td>✅ 自动启用</td><td>✅ AWS 自管</td></tr><tr><td>支持 CloudTrail 审计</td><td>✅ 支持</td><td>✅ 支持</td><td>❌ 不支持</td></tr><tr><td>可用作 Envelope 加密</td><td>✅ 是</td><td>✅ 是</td><td>❌ 否</td></tr><tr><td>常见使用场景</td><td>高敏感数据</td><td>服务默认加密</td><td>AWS 内部使用</td></tr></tbody></table><ul><li>KMS Key Material Origin（密钥材料来源）<ul><li><code>AWS_KMS</code>: 由 AWS 自动生成, KMS 在其受控的密钥存储中创建并管理密钥材料</li><li><code>EXTERNAL</code>: 用户自行导入密钥材料, 使用 ImportKeyMaterial API 将密钥注入到 KMS 中</li><li><code>AWS_CLOUDHSM</code>: 使用 AWS CloudHSM 创建密钥材料, CloudHSM 是基于硬件的密钥模块（HSM）服务</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img502823.png"></p><ul><li>KMS Key Source – Custom Key Store (CloudHSM)<ul><li>将 KMS 与 CloudHSM 集群集成，使 KMS 密钥材料托管在你自有的 HSM 中，进一步增强安全边界与合规能力</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img105554.png"></p><ul><li>KMS Key Source – External（Bring Your Own Key, BYOK）<ul><li>将你自己的密钥材料（Key Material）导入到 AWS KMS 中，使你能在 AWS 内部使用外部生成的密钥来进行加密操作</li><li>AWS 提供使用接口，但不再负责密钥生命周期的管理与安全</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img105739.png"></p><ul><li>AWS KMS Multi-Region Keys<ul><li>在多个 Region 中创建一组 功能上等效的 KMS 密钥，支持跨区域加密&#x2F;解密，无需重新加密或跨区域 API 调用</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img110341.png"></p><hr><h4 id="SSM-Parameter-Store"><a href="#SSM-Parameter-Store" class="headerlink" title="SSM Parameter Store"></a>SSM Parameter Store</h4><ul><li>Parameter Store 是 AWS 提供的 配置与密钥值存储服务，适用于环境变量、凭证、密钥等的安全管理</li></ul><p>SSM Parameter Store – 常见用途</p><table><thead><tr><th>用途</th><th>示例</th></tr></thead><tbody><tr><td>🧪 环境配置注入</td><td>Dev &#x2F; Staging &#x2F; Prod 使用不同参数</td></tr><tr><td>🔐 密钥存储</td><td>存储数据库密码、API 密钥、令牌等</td></tr><tr><td>🔁 CI&#x2F;CD 集成</td><td>Pipeline 中动态读取版本化配置</td></tr><tr><td>🧩 服务间解耦配置</td><td>多个 Lambda &#x2F; ECS 服务共享相同配置但不硬编码</td></tr></tbody></table><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img110601.png"></p><ul><li>SSM Parameter Store – 分层结构（Hierarchy）<ul><li>Parameter Store 支持以“路径”方式组织参数，非常适合大型项目的多环境配置管理</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/my-department/</span><br><span class="line">├── my-app/</span><br><span class="line">│   ├── dev/</span><br><span class="line">│   │   ├── db-url</span><br><span class="line">│   │   └── db-password</span><br><span class="line">│   └── prod/</span><br><span class="line">│       ├── db-url</span><br><span class="line">│       └── db-password</span><br><span class="line">├── other-app/</span><br><span class="line">/other-department/</span><br></pre></td></tr></table></figure><ul><li>SSM Parameter Store – Standard 与 Advanced 参数层级对比</li></ul><table><thead><tr><th>特性</th><th>Standard</th><th>Advanced</th></tr></thead><tbody><tr><td>参数总数量上限（每账户每区域）</td><td>10,000</td><td>100,000</td></tr><tr><td>单个参数最大值大小</td><td>4 KB</td><td>8 KB</td></tr><tr><td>是否支持参数策略（过期等）</td><td>❌ 不支持</td><td>✅ 支持</td></tr><tr><td>成本</td><td>✅ 免费</td><td>💲 每个参数 $0.05&#x2F;月</td></tr><tr><td>典型用途</td><td>一般配置、小规模系统</td><td>大型企业系统、合规要求、多版本配置等</td></tr></tbody></table><ul><li>SSM Parameter Store – Parameter Policies（参数策略，仅限 Advanced 参数）<ul><li>Parameter Policies 是为高级参数（Advanced Tier）提供的附加功能，用于控制参数的生命周期、安全性与合规性</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img110924.png"></p><hr><h4 id="AWS-Secrets-Manager"><a href="#AWS-Secrets-Manager" class="headerlink" title="AWS Secrets Manager"></a>AWS Secrets Manager</h4><ul><li>Secrets Manager 是 AWS 专门用于存储和自动轮换敏感凭证（如密码、API 密钥等）的服务，比 Parameter Store 更安全、更自动化</li></ul><p>Secrets Manager vs SSM Parameter Store 对比简表</p><table><thead><tr><th>项目</th><th>Secrets Manager</th><th>SSM Parameter Store (SecureString)</th></tr></thead><tbody><tr><td>自动轮换</td><td>✅ 支持</td><td>❌ 不支持（需手动）</td></tr><tr><td>成本</td><td>💲 $0.40 每密钥 &#x2F; 月</td><td>标准免费，高级 $0.05 &#x2F; 月</td></tr><tr><td>支持 Lambda 集成</td><td>✅ 原生支持</td><td>❌ 无</td></tr><tr><td>原生服务集成</td><td>✅ 强（RDS、Redshift）</td><td>✅ 一般</td></tr></tbody></table><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img506823.png"></p><ul><li>AWS Secrets Manager – 跨账户共享（Sharing Across Accounts）<ul><li>要让其他 AWS 账户访问某个 Secrets Manager 中的密钥，需 同时配置 KMS 策略与 Resource-based Policy</li></ul></li></ul><p>SSM Parameter Store vs. Secrets Manager – Rotation</p><table><thead><tr><th>特性</th><th>Secrets Manager</th><th>SSM Parameter Store</th></tr></thead><tbody><tr><td>轮换方式</td><td>✅ 内建自动轮换</td><td>❌ 需自建 EventBridge + Lambda</td></tr><tr><td>RDS 支持</td><td>✅ 原生集成</td><td>✅ 需自行实现连接与更新逻辑</td></tr><tr><td>Lambda 模板支持</td><td>✅ AWS 提供模板</td><td>❌ 无模板</td></tr><tr><td>成本</td><td>💲 $0.40 &#x2F; 月 &#x2F; 密钥</td><td>💲 免费（标准）或 $0.05 &#x2F; 月（高级）</td></tr><tr><td>使用建议</td><td>高敏感数据，数据库密码管理</td><td>简单配置轮换或成本敏感场景</td></tr></tbody></table><hr><h4 id="SSL-x2F-TLS-Basics"><a href="#SSL-x2F-TLS-Basics" class="headerlink" title="SSL&#x2F;TLS - Basics"></a>SSL&#x2F;TLS - Basics</h4><ul><li>SSL&#x2F;TLS 是用于网络连接加密的协议，常用于保护浏览器与服务器之间的数据传输安全</li></ul><table><thead><tr><th>项目</th><th>描述</th></tr></thead><tbody><tr><td>🔐 SSL（Secure Sockets Layer）</td><td>最初用于实现安全通信的协议，现已被淘汰</td></tr><tr><td>🔐 TLS（Transport Layer Security）</td><td>SSL 的升级版，当前主流安全传输协议（如 TLS 1.2, TLS 1.3）</td></tr><tr><td>🗣️ 通俗叫法</td><td>尽管使用的是 TLS，大家仍习惯说 “SSL 证书”</td></tr></tbody></table><ul><li>SSL – Man-in-the-Middle (MITM) Attack<ul><li>MITM（中间人攻击）是指攻击者在用户与服务器之间悄悄插入，拦截、读取甚至篡改传输的数据，常见于公共 Wi-Fi 或 DNS 欺骗场景</li></ul></li></ul><p>MITM 攻击防护措施分类</p><table><thead><tr><th>等级</th><th>描述</th><th>示例或建议</th></tr></thead><tbody><tr><td>🛡️ Mandatory （强制）</td><td>基本防护措施，必须启用</td><td>所有公网流量使用 HTTPS，部署有效 SSL&#x2F;TLS 证书</td></tr><tr><td>💬 Strongly Recommended （强烈推荐）</td><td>AWS 推荐的增强防护手段，可显著提升安全性</td><td>启用 DNSSEC 来防止 DNS 被劫持</td></tr><tr><td>📝 Elective （自选）</td><td>企业常用的附加手段，可视情况启用</td><td>使用自定义 DNS 服务器提升控制力（如 Bind、dnsmasq）</td></tr></tbody></table><hr><h4 id="AWS-Certificate-Manager-ACM"><a href="#AWS-Certificate-Manager-ACM" class="headerlink" title="AWS Certificate Manager (ACM)"></a>AWS Certificate Manager (ACM)</h4><ul><li>ACM（AWS Certificate Manager）是 AWS 提供的 SSL&#x2F;TLS 证书管理服务，支持申请、托管、分发、续期等功能，极大简化了证书在云中的部署流程</li></ul><p>ACM 支持集成的服务</p><table><thead><tr><th>集成服务</th><th>描述</th></tr></thead><tbody><tr><td>⚖️ Load Balancer</td><td>支持 ALB &#x2F; NLB，包括由 Elastic Beanstalk 创建的负载均衡器</td></tr><tr><td>🌎 CloudFront</td><td>可为分发的内容启用 HTTPS 支持</td></tr><tr><td>📡 API Gateway</td><td>为 API 网关的自定义域名配置 SSL 证书</td></tr></tbody></table><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img509401.png"></p><p>建议使用场景总结</p><table><thead><tr><th>场景</th><th>建议</th></tr></thead><tbody><tr><td>✅ 外部网站或 API</td><td>使用 ACM 公有证书（自动续期 + 免费）</td></tr><tr><td>🔐 内部微服务通信（非公网）</td><td>创建 Private CA + 私有证书，并配置系统信任链</td></tr><tr><td>🌍 多区域应用部署</td><td>在每个 AWS Region 内单独签发证书，<strong>不支持跨区域复制或复用</strong></td></tr></tbody></table><hr><h4 id="CloudHSM"><a href="#CloudHSM" class="headerlink" title="CloudHSM"></a>CloudHSM</h4><ul><li><p>CloudHSM 是 AWS 提供的 专属硬件加密模块服务（HSM &#x3D; Hardware Security Module），适用于对密钥有高度控制要求的场景</p></li><li><p>CloudHSM 特性概览</p><ul><li>💡 专属硬件实例（HSM）：每个用户拥有独立的物理设备</li><li>🔑 密钥全权管理：只有你拥有密钥控制权，AWS 无法访问</li><li>📜 合规优势：通过 FIPS 140-2 Level 3 安全认证</li><li>🔁 支持加解密算法：对称（AES）、非对称（RSA、ECC）、TLS 证书管理等</li><li>🧩 集成支持：如 Redshift 可使用 CloudHSM 进行数据库加密和密钥管理（SSE-C 场景推荐）</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img509405.png"></p><p>KMS vs. CloudHSM 选择建议</p><table><thead><tr><th>场景</th><th>建议选择</th></tr></thead><tbody><tr><td>✅ 一般加密需求，使用 AWS 服务集成</td><td>AWS KMS（托管式 + 易用）</td></tr><tr><td>🔐 高合规场景（如政府、金融、医疗）</td><td>AWS CloudHSM（专属硬件 + 用户控密钥）</td></tr></tbody></table><hr><h4 id="S3-Security"><a href="#S3-Security" class="headerlink" title="S3 Security"></a>S3 Security</h4><ul><li>S3 提供多种对象加密方式，确保数据静态加密（encryption at rest），适用于不同的密钥管理需求</li><li>S3 提供 HTTP 与 HTTPS 两种访问方式，建议始终使用 加密传输（HTTPS） 来保护数据在网络传输过程中的安全</li></ul><table><thead><tr><th>加密方式</th><th>描述</th></tr></thead><tbody><tr><td>🟣 SSE-S3</td><td>- 使用 AWS 自主管理的密钥（AES-256）<br>- 完全托管、零配置</td></tr><tr><td>🟡 SSE-KMS</td><td>- 使用 AWS KMS 管理密钥<br>- 支持访问控制与 CloudTrail 审计日志</td></tr><tr><td>🔒 SSE-C</td><td>- 自定义客户提供密钥（Client-Provided Keys）<br>- S3 不保存密钥，仅临时使用</td></tr><tr><td>💻 Client-Side</td><td>- 加密在客户端完成后再上传到 S3<br>- 客户端负责密钥生成、加密与解密逻辑</td></tr></tbody></table><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img509432.png"></p><ul><li>Events in S3 Buckets<ul><li>S3 支持多种事件与日志机制，用于追踪对象访问、变更与安全状态</li></ul></li></ul><table><thead><tr><th>目的</th><th>建议使用机制</th></tr></thead><tbody><tr><td>获取完整访问日志</td><td>S3 Access Logs</td></tr><tr><td>实时触发函数&#x2F;消息</td><td>S3 Event Notifications</td></tr><tr><td>对接跨服务事件处理</td><td>CloudTrail + EventBridge</td></tr><tr><td>检查桶权限是否合规</td><td>Trusted Advisor</td></tr></tbody></table><ul><li>S3 Security 安全控制方式<ul><li>S3 提供两种主要的访问控制机制：基于用户 与 基于资源，可灵活搭配使用以实现精细权限控制</li></ul></li></ul><p>👤 User-based（基于用户）</p><table><thead><tr><th>控制方式</th><th>描述</th></tr></thead><tbody><tr><td>🔐 IAM Policy</td><td>在 IAM 控制台中配置，定义特定用户可执行哪些 S3 API 操作（如 GetObject、PutObject）</td></tr></tbody></table><p>📦 Resource-based（基于资源）</p><table><thead><tr><th>控制方式</th><th>描述</th></tr></thead><tbody><tr><td>📜 Bucket Policy</td><td>在 S3 控制台中为 Bucket 设置的策略，支持跨账户访问控制</td></tr><tr><td>🧾 Object ACL</td><td>物件级权限控制，粒度更细（可控制单个对象的读&#x2F;写权限）</td></tr><tr><td>📦 Bucket ACL</td><td>针对整个桶的访问控制，不常用，功能已被 Bucket Policy 替代为主</td></tr></tbody></table><ul><li>S3 Bucket Policies<ul><li>S3 Bucket Policy 是一种 资源级别的访问控制机制，用于集中定义整桶对象的权限策略</li><li>授予公共访问权限（用于静态网站托管或公开资源）</li><li>强制上传对象时加密（通过条件限制加密方式）</li><li>跨账户授权访问（授予其他 AWS 账户访问权限）</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img222722.png"></p><ul><li>S3 Pre-signed URLs<ul><li>预签名 URL 允许临时授权用户访问 S3 中的对象，常用于 临时下载 或 受控上传 场景</li></ul></li></ul><p>使用场景示例</p><table><thead><tr><th>场景描述</th><th>示例效果</th></tr></thead><tbody><tr><td>🎬 仅登录用户可下载付费视频</td><td>生成 GET 类型的预签名 URL，供登录用户使用</td></tr><tr><td>📥 动态授权用户下载文件</td><td>根据用户身份动态生成 GET URL，实现灵活文件访问控制</td></tr><tr><td>📤 临时上传文件至指定位置（如头像、PDF）</td><td>为某路径生成 PUT 类型的预签名 URL，仅临时开放上传权限</td></tr></tbody></table><ul><li>S3 Object Lock &amp; Glacier Vault Lock<ul><li>这两种锁定机制都采用 WORM（Write Once Read Many）模型，主要用于 合规存储 与 防篡改数据保护</li></ul></li></ul><table><thead><tr><th>场景</th><th>推荐机制</th></tr></thead><tbody><tr><td>普通对象防删（含版本控制）</td><td>S3 Object Lock</td></tr><tr><td>归档数据长期不可更改（如交易记录）</td><td>Glacier Vault Lock</td></tr><tr><td>合规要求 + 防篡改 + 永久保存需求</td><td>可结合 S3 Object Lock + Glacier Vault Lock 双层保护</td></tr></tbody></table><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img510114.png"></p><hr><h4 id="S3-–-Access-Points"><a href="#S3-–-Access-Points" class="headerlink" title="S3 – Access Points"></a>S3 – Access Points</h4><ul><li>S3 Access Points 提供一种更灵活、安全的方式来管理不同用户或应用程序对同一 Bucket 的访问权限，按角色或业务线划分权限，简化 Bucket Policy 管理复杂度</li></ul><table><thead><tr><th>用户角色</th><th>访问前缀</th><th>Access Point 名称</th><th>策略说明</th></tr></thead><tbody><tr><td>Users (Finance)</td><td>&#x2F;finance&#x2F;*</td><td>FinanceAccessPoint</td><td>允许读写 &#x2F;finance 区域</td></tr><tr><td>Users (Sales)</td><td>&#x2F;sales&#x2F;*</td><td>SalesAccessPoint</td><td>允许读写 &#x2F;sales 区域</td></tr><tr><td>Users (Analytics)</td><td>所有路径（只读）</td><td>AnalyticsAccessPoint</td><td>对整个 Bucket 只读</td></tr></tbody></table><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img510115.png"></p><ul><li>S3 – Access Points（VPC Origin）<ul><li>S3 Access Points 可配置为 仅允许来自特定 VPC 内部的访问，提高安全性与隔离性，适合私有网络内的企业应用</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img510117.png"></p><ul><li>S3 – Multi-Region Access Points（MRAP）<ul><li>Multi-Region Access Points（MRAP）提供一个 全球统一的访问入口，自动将请求路由到多个 AWS 区域中的 S3 存储桶，实现跨区域高可用、低延迟访问</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img510118.png"></p><hr><h4 id="S3-Object-Lambda"><a href="#S3-Object-Lambda" class="headerlink" title="S3 Object Lambda"></a>S3 Object Lambda</h4><ul><li>S3 Object Lambda 允许在对象被读取前，通过 AWS Lambda 实时处理对象内容，无需修改原始 S3 对象</li></ul><table><thead><tr><th>使用场景描述</th><th>示例说明</th></tr></thead><tbody><tr><td>🔒 屏蔽敏感信息（如 PII）</td><td>在分析或测试环境中自动脱敏数据（如隐藏邮箱、手机号）</td></tr><tr><td>🔄 转换数据格式</td><td>将对象从 XML 转换为 JSON，提升兼容性</td></tr><tr><td>🖼️ 实时处理图片</td><td>根据调用用户信息动态缩放图片或添加水印</td></tr></tbody></table><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img511445.png"></p><hr><h4 id="DDoS-Protection-on-AWS"><a href="#DDoS-Protection-on-AWS" class="headerlink" title="DDoS Protection on AWS"></a>DDoS Protection on AWS</h4><ul><li>DDoS Protection on AWS<ul><li>AWS 提供多层次的防护方案，结合网络架构与服务配置，可有效缓解分布式拒绝服务（DDoS）攻击带来的影响</li></ul></li></ul><table><thead><tr><th>服务&#x2F;机制</th><th>描述</th></tr></thead><tbody><tr><td>🛡️ AWS Shield Standard</td><td>默认启用，免费为所有 AWS 用户提供基础 DDoS 防护（L3&#x2F;L4 攻击）</td></tr><tr><td>🛡️ AWS Shield Advanced</td><td>付费服务，提供 24&#x2F;7 SOC 支持、攻击检测、流量分析、费用保护等高级功能</td></tr><tr><td>🌐 AWS WAF</td><td>应用层防护（L7），可自定义规则过滤恶意请求（如 IP 黑名单、SQL 注入等）</td></tr><tr><td>🚀 CloudFront &amp; Route 53</td><td>借助 AWS 全球边缘网络进行流量分发，结合 AWS Shield 可实现边缘层 DDoS 缓解</td></tr></tbody></table><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img511449.png"></p><p>选择建议总结</p><table><thead><tr><th>需求场景</th><th>推荐机制</th></tr></thead><tbody><tr><td>基本防护（无需额外配置）</td><td>AWS Shield Standard</td></tr><tr><td>面对业务关键系统&#x2F;高风险目标</td><td>AWS Shield Advanced + WAF + CDN</td></tr><tr><td>Web 应用层级访问控制</td><td>AWS WAF（结合 CloudFront 效果更佳）</td></tr></tbody></table><hr><h4 id="AWS-Shield"><a href="#AWS-Shield" class="headerlink" title="AWS Shield"></a>AWS Shield</h4><ul><li>AWS Shield 是 AWS 提供的 分布式拒绝服务（DDoS）防护服务，分为 Standard 与 Advanced 两个等级，覆盖 L3&#x2F;L4 层的攻击防护</li></ul><p>🛡️ Shield Standard vs Advanced 简要对比</p><table><thead><tr><th>特性</th><th>Shield Standard</th><th>Shield Advanced</th></tr></thead><tbody><tr><td>费用</td><td>免费</td><td>$3,000&#x2F;月</td></tr><tr><td>攻击类型支持</td><td>基础网络攻击（L3&#x2F;L4）</td><td>复杂攻击（如应用层滥用、状态耗尽等）</td></tr><tr><td>保护服务范围</td><td>所有 AWS 公网服务</td><td>限定服务（EC2、ELB、CloudFront 等）</td></tr><tr><td>DDoS 响应团队支持</td><td>❌ 无</td><td>✅ 提供 24&#x2F;7 专家支持</td></tr><tr><td>费用豁免保障</td><td>❌ 无</td><td>✅ 提供（需符合 AWS 条件）</td></tr></tbody></table><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img511450.png"></p><hr><h4 id="AWS-WAF"><a href="#AWS-WAF" class="headerlink" title="AWS WAF"></a>AWS WAF</h4><ul><li>AWS WAF 是一款 应用层防火墙（Layer 7），用于保护 Web 应用免受常见攻击如 SQL 注入、XSS、恶意请求等</li><li>注意：WAF 并非 DDoS 防护工具，但可配合 Shield 使用以提升整体防护能力</li></ul><table><thead><tr><th>部署目标</th><th>描述</th></tr></thead><tbody><tr><td>⚖️ Application Load Balancer</td><td>在 ALB 上部署区域性规则，用于 EC2、ECS、Lambda 后端</td></tr><tr><td>🌐 CloudFront</td><td>在全球边缘节点上拦截攻击（全球生效）</td></tr><tr><td>📡 API Gateway</td><td>在 REST 或 HTTP API 前部署规则（区域级或边缘）</td></tr><tr><td>🧠 AppSync</td><td>保护 GraphQL 接口，防止恶意查询</td></tr><tr><td>🧱 支持自定义源站</td><td>如 Classic Load Balancer、EC2、S3 网站托管、自建应用等</td></tr></tbody></table><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img511455.png"></p><ul><li>Web ACL（Web Access Control List）<ul><li>Web ACL 是 WAF 的核心配置单元，由一组规则组成，控制哪些请求被允许、阻止或进一步挑战</li></ul></li></ul><table><thead><tr><th>规则内容类型</th><th>说明</th></tr></thead><tbody><tr><td>🔢 IP 地址过滤</td><td>包括黑名单 &#x2F; 白名单</td></tr><tr><td>📄 HTTP 内容匹配</td><td>可基于 Header、Body、URI 进行模式匹配</td></tr><tr><td>🔍 SQL Injection &#x2F; XSS 检测</td><td>AWS 提供内建规则集可直接启用防护</td></tr><tr><td>🌍 地理位置（Geo Match）</td><td>按国家 &#x2F; 区域限制访问</td></tr><tr><td>🔁 速率限制（Rate-based）</td><td>限制同一 IP 的请求频率，防止爬虫&#x2F;爆破</td></tr><tr><td>📏 请求大小限制（Size Constraint）</td><td>限制 URI、Header、Body 的最大长度</td></tr></tbody></table><ul><li>AWS WAF – Managed Rules（托管规则集）</li><li>AWS WAF 提供超过 190 条 托管规则（Managed Rules），由 AWS 与 AWS Marketplace 合作伙伴维护，开箱即用，简化防护配置</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img511457.png"></p><ul><li>AWS WAF – Web ACL Logging（日志记录）<ul><li>WAF 支持将 Web ACL 的匹配记录导出至多种日志系统，用于 安全审计、可视化分析和合规留档</li><li>CloudWatch Logs → 用于实时分析与可视化告警（搭配 Metric Filter）</li><li>S3 → 便于合规审计、存储与 Athena 分析</li><li>Firehose → 实时流处理、集成第三方 SIEM&#x2F;可观测平台</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img511459.png"></p><hr><h4 id="AWS-Firewall-Manager"><a href="#AWS-Firewall-Manager" class="headerlink" title="AWS Firewall Manager"></a>AWS Firewall Manager</h4><ul><li>AWS Firewall Manager 是一个集中式安全策略管理服务，适用于多账户环境（如 AWS Organizations），可统一下发并自动应用网络安全规则</li></ul><table><thead><tr><th>需求场景</th><th>建议操作</th></tr></thead><tbody><tr><td>统一管理所有账户的 WAF &#x2F; Shield 策略</td><td>启用 Firewall Manager 并创建 WAF Policy</td></tr><tr><td>实现自动化合规保障</td><td>结合 SCP + Firewall Manager + Config</td></tr><tr><td>集中控制 EC2&#x2F;ALB 安全组配置</td><td>启用 Security Group Policy 管理</td></tr></tbody></table><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img511541.png"></p><ul><li>WAF vs. Firewall Manager vs. Shield</li></ul><table><thead><tr><th>服务</th><th>作用范围</th></tr></thead><tbody><tr><td><strong>AWS WAF</strong></td><td>定义 Web ACL 规则，提供资源级别的应用层（Layer 7）攻击防护</td></tr><tr><td><strong>AWS Firewall Manager</strong></td><td>用于跨账户集中管理 WAF、Shield、Security Group、Network Firewall 策略</td></tr><tr><td><strong>AWS Shield</strong></td><td>防御 DDoS 攻击，包含免费版（Standard）和高级版（Advanced）</td></tr></tbody></table><hr><h4 id="AWS-Inspecctor"><a href="#AWS-Inspecctor" class="headerlink" title="AWS Inspecctor"></a>AWS Inspecctor</h4><ul><li>Amazon Inspector 是一项自动化安全评估服务，用于检测 AWS 上资源（如 EC2、ECR、Lambda）中存在的漏洞与配置风险，并集成报告和告警流程</li></ul><table><thead><tr><th>场景描述</th><th>建议配置</th></tr></thead><tbody><tr><td>需要定期评估 EC2 主机系统与网络风险</td><td>启用 Amazon Inspector + 安装&#x2F;激活 SSM Agent</td></tr><tr><td>容器镜像安全治理</td><td>启用 ECR 推送镜像扫描，配合 Inspector 自动检测依赖漏洞</td></tr><tr><td>保障 Serverless 函数运行时安全</td><td>启用对 Lambda 函数的 Inspector 扫描</td></tr><tr><td>多工具集成与统一监控</td><td>将 Inspector Findings 发送到 Security Hub &#x2F; EventBridge</td></tr></tbody></table><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img511545.png"></p><hr><h4 id="AWS-Config"><a href="#AWS-Config" class="headerlink" title="AWS Config"></a>AWS Config</h4><ul><li>AWS Config 是一项资源审计与合规性检查服务，能持续记录和追踪 AWS 资源的配置变更，帮助满足审计、合规与运营分析需求</li></ul><table><thead><tr><th>场景</th><th>建议操作</th></tr></thead><tbody><tr><td>持续合规审计与资源追踪</td><td>启用 AWS Config + 关键规则集</td></tr><tr><td>多账户环境统一合规视图</td><td>使用 Config Aggregator 聚合所有账户合规状态</td></tr><tr><td>定制企业规则</td><td>配置自定义 Lambda 规则，与 AWS Config 集成</td></tr><tr><td>结合响应机制</td><td>配置 SNS + EventBridge 实现实时响应或自动修复流程</td></tr></tbody></table><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img511547.png"></p><ul><li>AWS Config Rules<ul><li>AWS Config Rules 用于自动检查资源是否符合期望配置，并可与 EventBridge + Lambda &#x2F; SSM 配合实现自动修复</li></ul></li></ul><table><thead><tr><th>用例描述</th><th>规则示例</th></tr></thead><tbody><tr><td>确保所有 EBS 卷类型为 gp2</td><td>自定义规则：检查 EBS 类型是否为 gp2</td></tr><tr><td>检查所有 EC2 实例是否为 t2.micro</td><td>自定义规则：实例类型为 t2.micro 才合规</td></tr><tr><td>检查安全组是否开放 0.0.0.0&#x2F;0 的 SSH 端口</td><td>使用托管规则 <code>restricted-ssh</code></td></tr><tr><td>S3 Bucket 是否关闭公有访问</td><td>使用托管规则 <code>s3-bucket-public-read-prohibited</code> 等</td></tr></tbody></table><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img511548.png"></p><hr><h4 id="AWS-Managed-Logs"><a href="#AWS-Managed-Logs" class="headerlink" title="AWS Managed Logs"></a>AWS Managed Logs</h4><ul><li>AWS 提供多种服务的 托管日志记录功能，可将关键操作、流量或访问行为记录到 S3、CloudWatch Logs 或 Kinesis 中，供后续审计、监控与分析使用</li></ul><table><thead><tr><th>目标场景</th><th>建议配置</th></tr></thead><tbody><tr><td>审计账户 API 操作</td><td>启用 CloudTrail，写入 S3 + CloudWatch Logs</td></tr><tr><td>分析网络流量与安全行为</td><td>启用 VPC Flow Logs，结合 CloudWatch Logs 或 Athena 使用</td></tr><tr><td>回溯存储访问行为</td><td>启用 S3 或 CloudFront Access Logs</td></tr><tr><td>合规监管 &#x2F; 配置变更溯源</td><td>启用 AWS Config 并将日志导出至 S3</td></tr></tbody></table><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img511550.png"></p><hr><h4 id="AWS-GuardDuty"><a href="#AWS-GuardDuty" class="headerlink" title="AWS GuardDuty"></a>AWS GuardDuty</h4><ul><li>Amazon GuardDuty 是一项基于机器学习的智能威胁检测服务，可识别 AWS 环境中的异常行为、恶意活动与潜在攻击，无需安装代理或修改资源配置</li></ul><table><thead><tr><th>场景</th><th>推荐操作</th></tr></thead><tbody><tr><td>快速启用账户级安全监控</td><td>启用 GuardDuty，默认开启 CloudTrail、VPC、DNS 分析</td></tr><tr><td>自动化安全响应</td><td>配置 EventBridge + Lambda 处理 GuardDuty Findings</td></tr><tr><td>多账户统一检测</td><td>配置 GuardDuty 管理账户（Master-Detector 架构）</td></tr><tr><td>高风险资源（如 S3、Lambda）监控</td><td>启用可选数据源如 S3 Data Events、Lambda 运行监控等</td></tr></tbody></table><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img511555.png"></p><p>⚠️ 检测示例（Findings）</p><table><thead><tr><th>威胁类型</th><th>示例描述</th></tr></thead><tbody><tr><td>💰 加密货币挖矿攻击</td><td>检测 EC2 实例疑似被劫持用于挖矿（有专用 Finding 类型）</td></tr><tr><td>🔓 被盗凭证操作</td><td>使用已泄露的 API 密钥进行非常规操作</td></tr><tr><td>🔄 反常流量模式</td><td>某实例短时间内访问大量外部 IP 或发送异常 DNS 查询</td></tr></tbody></table><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img511558.png"></p><p>📥 输入日志源</p><table><thead><tr><th>来源类型</th><th>说明</th></tr></thead><tbody><tr><td>📋 CloudTrail Events</td><td>检测异常 API 调用、未授权操作（如 createTrail、createVpc、updateSecurityGroup）</td></tr><tr><td>🪣 CloudTrail S3 Data Events</td><td>检测异常访问行为（如 getObject、listObjects、deleteObject）</td></tr><tr><td>🌐 VPC Flow Logs</td><td>分析流量模式（如端口扫描、可疑内网通信、通信异常 IP）</td></tr><tr><td>🌍 DNS 查询日志</td><td>检测域名滥用，如 EC2 通过 DNS 隐蔽传输数据（数据渗漏）</td></tr><tr><td>🧪 可选数据源</td><td>包括 EKS 审计日志、RDS、Aurora、EBS 卷行为、Lambda、S3 数据事件等</td></tr></tbody></table><ul><li>GuardDuty – Delegated Administrator（委派管理员）<ul><li>在多账户架构下，可通过 委派管理员（Delegated Administrator） 集中管理 Amazon GuardDuty，适用于 AWS Organizations</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img511559.png"></p><hr><h4 id="IAM-Conditions"><a href="#IAM-Conditions" class="headerlink" title="IAM Conditions"></a>IAM Conditions</h4><ul><li>IAM 支持通过条件（Condition）限制策略作用范围，提升权限控制的灵活性与精细度</li></ul><p>✅ 常见 IAM 条件键（Condition Keys）</p><table><thead><tr><th>条件键</th><th>功能说明</th></tr></thead><tbody><tr><td><code>aws:SourceIp</code></td><td>限制 API 请求只能从指定 IP 范围发起</td></tr><tr><td><code>aws:RequestedRegion</code></td><td>限制 API 请求只能针对特定 AWS 区域</td></tr><tr><td><code>aws:MultiFactorAuthPresent</code></td><td>强制要求请求者启用并使用 MFA（多重身份验证）</td></tr><tr><td><code>ec2:ResourceTag</code></td><td>限制操作仅适用于包含指定标签的 EC2 资源（例如强制打标签）</td></tr></tbody></table><ul><li><code>aws:PrincipalOrgID</code> 是一个可用于 资源策略（Resource Policies） 的条件，用于限制访问者必须属于某个 AWS Organization，实现跨账户但受组织边界控制的安全授权</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img213524.png"></p><hr><h4 id="IAM-for-S3"><a href="#IAM-for-S3" class="headerlink" title="IAM for S3"></a>IAM for S3</h4><ul><li>针对 S3，权限粒度划分为 Bucket 级别 与 Object 级别</li></ul><p>🪣 S3 操作权限与 ARN 示例</p><table><thead><tr><th>操作权限</th><th>ARN 示例</th><th>权限说明</th></tr></thead><tbody><tr><td><code>s3:ListBucket</code></td><td><code>arn:aws:s3:::my-bucket</code></td><td>✅ Bucket 级权限</td></tr><tr><td><code>s3:GetObject</code><br><code>s3:PutObject</code><br><code>s3:DeleteObject</code></td><td><code>arn:aws:s3:::my-bucket/*</code></td><td>✅ Object 级权限</td></tr></tbody></table><hr><h4 id="AWS-Security-Hub"><a href="#AWS-Security-Hub" class="headerlink" title="AWS Security Hub"></a>AWS Security Hub</h4><ul><li>AWS Security Hub 是一个集中化的安全与合规状态可视化平台，自动聚合来自多个 AWS 服务与第三方工具的安全发现（Findings），并支持跨账户集中管理</li></ul><p>🧰 核心功能</p><table><thead><tr><th>功能</th><th>描述</th></tr></thead><tbody><tr><td>📊 统一仪表盘</td><td>提供多账户、多服务的安全状态总览，支持快速发现问题并响应</td></tr><tr><td>🔎 安全发现聚合</td><td>自动整合来自 AWS 服务与合作厂商的 Findings（支持 AWS Security Finding Format）</td></tr><tr><td>✅ 安全检查自动化</td><td>内建对照如 CIS Benchmarks、PCI DSS 的合规性检查规则集</td></tr><tr><td>🔔 集成通知与响应</td><td>可结合 EventBridge + Lambda&#x2F;SNS 触发自动修复或提醒流程</td></tr></tbody></table><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img511603.png"></p><p>📥 支持的 AWS 服务（Findings 来源）</p><table><thead><tr><th>来源服务</th><th>检测内容示例</th></tr></thead><tbody><tr><td>🧾 AWS Config</td><td>合规规则触发、不合规配置变更</td></tr><tr><td>🛡️ GuardDuty</td><td>异常行为、恶意流量、账号滥用等</td></tr><tr><td>🔍 Inspector</td><td>主机、容器、Lambda 漏洞扫描</td></tr><tr><td>🔐 Macie</td><td>S3 中的敏感数据检测（如 PII、信用卡号）</td></tr><tr><td>👁️ IAM Access Analyzer</td><td>资源暴露、外部可访问路径发现</td></tr><tr><td>⚙️ Systems Manager</td><td>异常补丁状态、实例合规性评估</td></tr><tr><td>🔥 Firewall Manager</td><td>防火墙规则不一致、策略未应用</td></tr><tr><td>🏥 AWS Health</td><td>AWS 服务层事件影响和通知</td></tr></tbody></table><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img511604.png"></p><hr><h4 id="Amazon-Detective"><a href="#Amazon-Detective" class="headerlink" title="Amazon Detective"></a>Amazon Detective</h4><ul><li>Amazon Detective 是一款专为深入分析和调查 AWS 安全事件根因而设计的服务，结合图数据库和机器学习技术，从大量日志中构建清晰的可视化上下文</li></ul><table><thead><tr><th>场景</th><th>建议操作</th></tr></thead><tbody><tr><td>分析 GuardDuty&#x2F;Macie Findings 背后的根因</td><td>启用 Detective 并结合图形分析视图使用</td></tr><tr><td>需要追溯用户 &#x2F; 资源行为全链路</td><td>使用 Detective 的行为图谱与时间线</td></tr><tr><td>多账户环境集中调查安全事件</td><td>在管理账户中启用 Amazon Detective 并连接所有子账户</td></tr></tbody></table><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img511605.png"></p><hr><h3 id="3-Compute-amp-Load-Balancing"><a href="#3-Compute-amp-Load-Balancing" class="headerlink" title="3. Compute &amp; Load Balancing"></a>3. Compute &amp; Load Balancing</h3><h4 id="EC2"><a href="#EC2" class="headerlink" title="EC2"></a>EC2</h4><ul><li>EC2 Instance Types – 常见类别速览<ul><li>Amazon EC2 提供多种实例类型，针对不同计算、内存、存储和图形加速需求进行优化</li></ul></li></ul><p>常见主流实例族对照表</p><table><thead><tr><th>实例类型</th><th>用途场景描述</th><th>特点关键词</th></tr></thead><tbody><tr><td><code>R</code></td><td>高内存场景，如 Redis、Memcached</td><td>内存优化型（RAM 优先）</td></tr><tr><td><code>C</code></td><td>高计算需求，如批量处理、数据库</td><td>计算优化型（CPU 性能优先）</td></tr><tr><td><code>M</code></td><td>通用业务，如 Web 应用、开发环境</td><td>均衡型（“M” &#x3D; Medium）</td></tr><tr><td><code>I</code></td><td>高本地 I&#x2F;O，如 NoSQL、日志聚合数据库</td><td>存储优化型（本地 SSD）</td></tr><tr><td><code>G</code></td><td>GPU 加速需求，如深度学习、图像处理</td><td>图形&#x2F;GPU 优化型</td></tr><tr><td><code>T2 / T3</code></td><td>突发型场景，轻量 Web、测试环境</td><td>突发性能型（CPU credit 模型）</td></tr><tr><td><code>T2/T3 - unlimited</code></td><td>支持持续突发，无性能限制</td><td>超出 baseline 不限时</td></tr></tbody></table><ul><li>EC2 – Placement Groups<ul><li>Placement Groups 可用于控制 EC2 实例在 AWS 数据中心中的物理部署方式，优化网络延迟、容错能力或分布策略</li><li><code>Cluster</code>: 低延迟网络、高带宽通信</li><li><code>Spread</code>: 高可用性 &#x2F; 避免单点故障硬件依赖</li><li><code>Partition</code>: 大规模分布式系统架构部署</li></ul></li></ul><p></p><p>🧩 三种 Placement Group 策略类型</p><table><thead><tr><th>策略类型</th><th>描述</th><th>场景示例</th></tr></thead><tbody><tr><td>Cluster</td><td>实例部署在同一个可用区（AZ）的近距离硬件上，实现超低网络延迟与高吞吐量</td><td>HPC、高频交易、分布式缓存</td></tr><tr><td>Spread</td><td>实例分布在多个底层硬件（每个 AZ 最多 7 个实例），以提升容错性</td><td>关键系统（如数据库主备、前端节点）</td></tr><tr><td>Partition</td><td>实例分布在多个“分区”内，每个分区基于不同的机架组，可扩展到数百台实例</td><td>大规模分布式系统（如 Hadoop、Kafka、Cassandra）</td></tr></tbody></table><ul><li>Placement Groups – Cluster 策略<ul><li>极高的网络性能，<strong>实例间带宽可达 10 Gbps</strong>（需启用 Enhanced Networking）</li><li>非常适合需要<strong>低延迟、高吞吐量</strong>的内部通信场景</li><li>所有实例集中在同一机架组，<strong>若该机架故障，则所有实例同时宕机</strong></li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img512712.png"></p><ul><li>Placement Groups – Spread 策略 <ul><li><strong>可跨多个可用区（AZ）部署</strong></li><li>实例部署在不同的物理硬件上，<strong>大大降低同时故障的风险</strong></li><li>合关键业务场景下的<strong>实例隔离</strong></li><li><strong>每个 AZ 限制最多 7 个实例</strong>（每个 Placement Group 中）</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img512722.png"></p><ul><li>Placement Groups – Partition 策略 <ul><li>每个 <strong>可用区（AZ）最多支持 7 个分区</strong></li><li>单个分区可包含 <strong>数百个 EC2 实例</strong></li><li>同一分区内的实例共享机架，不同分区的实例<strong>物理隔离</strong></li><li><strong>分区级故障</strong> 只影响单个分区，<strong>不会波及其它分区</strong></li><li>实例可以通过 <strong>实例元数据（Metadata）获取所属分区信息</strong></li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img512724.png"></p><ul><li>EC2 Instance Launch Types（启动类型）<ul><li>EC2 提供多种实例启动方式，适用于不同业务场景和成本策略</li></ul></li></ul><p>🚀 启动类型对照表</p><table><thead><tr><th>启动类型</th><th>适用场景</th><th>特点 &#x2F; 优势</th></tr></thead><tbody><tr><td>On-Demand Instances</td><td>短期、灵活性需求</td><td>✅ 按小时&#x2F;秒计费，可靠、无承诺</td></tr><tr><td>Spot Instances</td><td>可中断型短期任务</td><td>💰 价格低至按需的 90% 折扣，⚠️ 可能随时被回收</td></tr><tr><td>Reserved Instances</td><td>长期稳定工作负载（≥1 年）</td><td>💰 提前承诺换折扣（最多 75%），支持区域或实例预定</td></tr><tr><td>Convertible Reserved Instances</td><td>长期工作负载 + 实例类型灵活</td><td>✅ 允许在期限内更换实例规格，适合不确定未来实例类型的情况</td></tr><tr><td>Dedicated Instances</td><td>需隔离硬件、提升安全性</td><td>🛡️ 仅该客户使用物理服务器的部分资源，适合合规性需求</td></tr><tr><td>Dedicated Hosts</td><td>控制实例部署 + 软件许可需求</td><td>🧩 拥有整个物理服务器资源</td></tr></tbody></table><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img512834.png"></p><ul><li>EC2 Graviton 处理器<ul><li>AWS Graviton 是基于 Arm 架构 的自研处理器系列，提供卓越的性价比与能效优势，适用于多种计算场景</li></ul></li></ul><p>🧠 处理器版本对比</p><table><thead><tr><th>版本</th><th>性能提升</th><th>特点摘要</th></tr></thead><tbody><tr><td>Graviton2</td><td>比第 5 代 x86 实例高出约 40%</td><td>最早广泛部署的高性价比 Arm 实例</td></tr><tr><td>Graviton3</td><td>比 Graviton2 快 最高 3 倍</td><td>提升浮点计算、加密、ML 推理性能，功耗更低</td></tr></tbody></table><ul><li>EC2 默认监控指标（CloudWatch Metrics）<ul><li>EC2 实例在不额外配置的情况下，会自动收集以下基础指标，适用于性能监控与状态排查</li><li>内存（RAM）使用情况不是默认指标</li></ul></li></ul><p>📊 内建指标分类（EC2 默认 CloudWatch Metrics）</p><table><thead><tr><th>维度</th><th>监控项名称</th><th>说明</th></tr></thead><tbody><tr><td>🧠 CPU</td><td><code>CPUUtilization</code></td><td>CPU 使用率（%）</td></tr><tr><td></td><td><code>CPUCreditUsage</code> &#x2F; <code>CPUCreditBalance</code></td><td>仅适用于 T 系列突发型实例</td></tr><tr><td>🌐 网络</td><td><code>NetworkIn</code> &#x2F; <code>NetworkOut</code></td><td>网络流量（字节）</td></tr><tr><td>✅ 状态检查</td><td><code>InstanceStatusCheck</code></td><td>检查 EC2 虚拟机级别问题</td></tr><tr><td></td><td><code>SystemStatusCheck</code></td><td>检查宿主机硬件和网络是否正常</td></tr><tr><td>💽 磁盘（临时存储）</td><td><code>DiskReadOps</code> &#x2F; <code>WriteOps</code><br><code>DiskReadBytes</code> &#x2F; <code>WriteBytes</code></td><td>仅适用于 Instance Store，不包含 EBS</td></tr></tbody></table><ul><li>EC2 Instance Recovery（实例恢复）<ul><li>当 EC2 实例发生系统级故障时，AWS 支持通过 自动恢复机制（Instance Recovery）将实例迁移至健康硬件上，保留原有配置不变</li><li>只有 System Status Check 失败（StatusCheckFailed_System） 时才可触发 EC2 Recovery</li></ul></li></ul><p>✅ 状态检查（Status Check）</p><table><thead><tr><th>检查类型</th><th>说明</th></tr></thead><tbody><tr><td>Instance Status</td><td>检查 EC2 实例内操作系统、网络配置等</td></tr><tr><td>System Status</td><td>检查底层硬件（如宿主物理服务器故障）</td></tr></tbody></table><hr><h4 id="High-Performance-Computing-HPC"><a href="#High-Performance-Computing-HPC" class="headerlink" title="High Performance Computing (HPC)"></a>High Performance Computing (HPC)</h4><ul><li>云计算平台（特别是 AWS）非常适合进行 高性能计算（HPC），可动态扩展、快速部署并降低成本</li></ul><p>📦 Data Management &amp; Transfer for HPC</p><table><thead><tr><th>服务</th><th>用途场景</th></tr></thead><tbody><tr><td><strong>AWS Direct Connect</strong></td><td>提供高带宽、低延迟、专线连接 AWS，适合传输 GB&#x2F;s 数据</td></tr><tr><td><strong>AWS Snowball</strong></td><td>物理设备，适合批量传输 PB 级数据 到 AWS</td></tr><tr><td><strong>AWS DataSync</strong></td><td>快速将大量数据 从本地同步到 S3、EFS、FSx</td></tr></tbody></table><p>⚙️ Compute and Networking for HPC</p><table><thead><tr><th>选项</th><th>用途说明</th></tr></thead><tbody><tr><td><strong>EC2 实例</strong></td><td>提供基础的计算资源，可选择 CPU 优化型、GPU 优化型 实例</td></tr><tr><td><strong>Spot 实例 &#x2F; Spot Fleet</strong></td><td>适用于弹性、短时批处理任务，极大降低成本，可结合 Auto Scaling 使用</td></tr><tr><td><strong>Auto Scaling</strong></td><td>根据计算需求自动扩缩 EC2 数量，适应动态负载变化</td></tr></tbody></table><p>🚀 EC2 Enhanced Networking（基于 SR-IOV）</p><table><thead><tr><th>网络类型</th><th>特性说明</th><th>适用带宽</th></tr></thead><tbody><tr><td>Elastic Network Adapter (ENA)</td><td>默认推荐，支持多种实例类型，最高 100 Gbps</td><td>✅ 高速（现代标准）</td></tr><tr><td>Intel 82599 VF (Legacy)</td><td>较旧的选项，适用于部分早期实例</td><td>⛔ 最多 10 Gbps</td></tr><tr><td>Elastic Fabric Adapter (EFA)</td><td>基于 ENA 增强，适用于 HPC，支持 MPI，绕过内核，提供超低延迟通信</td><td>✅ 高速 + 极低延迟</td></tr></tbody></table><p>📌 实例附加存储（与 EC2 紧耦合）</p><table><thead><tr><th>类型</th><th>特点</th><th>使用建议</th></tr></thead><tbody><tr><td>Amazon EBS</td><td>可持久化、可独立挂载，支持快照、加密、IOPS 调优</td><td>✅ 通用存储，如数据库磁盘、容器卷</td></tr><tr><td>- io2 Block Express</td><td>提供高达 256,000 IOPS，适合高性能场景</td><td>高性能数据库、日志系统</td></tr><tr><td>Instance Store</td><td>与 EC2 实例生命周期绑定，超低延迟，可达百万级 IOPS</td><td>临时数据缓存、HPC 临时结果</td></tr></tbody></table><p>📦 网络存储（通过网络访问）</p><table><thead><tr><th>服务</th><th>特点</th><th>适用场景</th></tr></thead><tbody><tr><td>Amazon S3</td><td>对象存储服务，支持无限扩展，不是真正的文件系统</td><td>✅ 静态文件、模型数据、备份归档等</td></tr><tr><td>Amazon EFS</td><td>分布式共享文件系统，自动扩展，按容量计费，支持 provisioned IOPS</td><td>多实例共享挂载、容器、Web 文件存储</td></tr><tr><td>Amazon FSx for Lustre</td><td>面向 HPC 优化的高并行文件系统，支持百万级 IOPS，可挂载到 S3</td><td>Genomics、渲染、AI 模型训练等 HPC 场景</td></tr></tbody></table><p>🤖 自动化与编排工具（Automation &amp; Orchestration for HPC）</p><table><thead><tr><th>工具</th><th>特点</th><th>适用场景</th></tr></thead><tbody><tr><td><strong>AWS Batch</strong></td><td>支持多节点并行作业（Multi-node Parallel Jobs），自动调度和扩缩 EC2 实例</td><td>✅ 动态批处理任务调度、分布式训练、仿真、渲染等</td></tr><tr><td><strong>AWS ParallelCluster</strong></td><td>开源集群管理工具，基于文本配置，自动创建 VPC、子网、实例类型与作业调度器</td><td>✅ 构建完整 HPC 集群（支持 Lustre、EFA、Slurm 等）</td></tr></tbody></table><hr><h4 id="Auto-Scaling"><a href="#Auto-Scaling" class="headerlink" title="Auto Scaling"></a>Auto Scaling</h4><ul><li>Auto Scaling Groups – Dynamic Scaling Policies（动态扩缩容策略）<ul><li>动态扩缩容策略可以根据实时指标或已知使用模式自动调整 EC2 实例数量，确保系统既具备弹性又避免资源浪费</li></ul></li></ul><table><thead><tr><th>策略类型</th><th>描述</th><th>示例</th></tr></thead><tbody><tr><td>🎯 Target Tracking Scaling</td><td>✅ 最简单易用，自动将实例数维持在某个目标指标附近</td><td>希望平均 CPU 利用率维持在 40%</td></tr><tr><td>📈 Simple &#x2F; Step Scaling</td><td>基于 CloudWatch 警报进行扩缩容，支持多个阈值与动作，适合精细控制</td><td>CPU &gt; 70% ➝ 扩容 2 台<br>CPU &lt; 30% ➝ 缩容 1 台</td></tr><tr><td>⏰ Scheduled Actions</td><td>预设时间点触发扩缩计划，适用于流量规律明显的场景</td><td>每周五 17:00 ➝ 设置最小容量为 10，应对周末高峰</td></tr></tbody></table><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img223430.png"></p><ul><li>Auto Scaling Groups – Predictive Scaling（预测型扩缩策略<ul><li>预测型扩缩容通过 机器学习算法分析历史负载趋势，提前预测即将到来的负载变化，并提前预热实例，从而避免响应延迟或冷启动问题</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img225447.png"></p><p>📈 推荐用于扩缩容的指标</p><table><thead><tr><th>指标名称</th><th>描述</th></tr></thead><tbody><tr><td>CPUUtilization</td><td>实例的平均 CPU 使用率，最常用的通用扩缩容指标</td></tr><tr><td>RequestCountPerTarget</td><td>每个目标实例的请求量（适用于带有负载均衡器的 Web 应用）</td></tr><tr><td>Average Network In&#x2F;Out</td><td>平均网络流入 &#x2F; 流出字节数，适合网络密集型应用（如视频流、数据传输）</td></tr><tr><td>自定义指标（Custom Metric）</td><td>可使用 CloudWatch 自行推送任意业务相关指标（如队列长度、响应时间等）</td></tr></tbody></table><ul><li>Auto Scaling – Instance Refresh<ul><li>在不完全重建 Auto Scaling Group 的前提下，自动滚动更新 EC2 实例以使用新的启动模板（Launch Template）或配置</li><li>由用户主动调用 StartInstanceRefresh, 按照指定比例逐步替换现有实例，确保服务不中断</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img515727.png"></p><ul><li>Auto Scaling – Health Checks（健康检查机制）<ul><li>Auto Scaling Group（ASG）会根据健康检查结果自动识别失效实例，并执行终止 + 替换操作，确保服务高可用</li></ul></li></ul><table><thead><tr><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>EC2 Status Checks</td><td>默认启用，检查实例自身状态（如 CPU 卡死、内核崩溃）<br>包括系统级（System）和实例级（Instance）状态检查</td></tr><tr><td>ELB Health Checks</td><td>适用于 ASG 关联了 Load Balancer（ALB &#x2F; NLB &#x2F; CLB）<br>使用 HTTP&#x2F;TCP 定期探测实例健康，贴近业务层</td></tr><tr><td>自定义健康检查（Custom）</td><td>使用 AWS CLI &#x2F; SDK 主动上报实例健康状态<br>命令示例：<code>set-instance-health</code>（将实例标记为 Unhealthy）</td></tr></tbody></table><hr><h4 id="EC2-Spot-Instances"><a href="#EC2-Spot-Instances" class="headerlink" title="EC2 Spot Instances"></a>EC2 Spot Instances</h4><ul><li>EC2 Spot 实例是一种高性价比的计算资源获取方式，可以为弹性工作负载显著节省成本。适用于对中断容忍度高的场景，例如批处理、数据分析等</li></ul><table><thead><tr><th>特性</th><th>描述</th></tr></thead><tbody><tr><td>成本极低</td><td>相较 On-Demand 实例最高可省 90%</td></tr><tr><td>自定义最大竞价</td><td>用户设定最大可接受价格，当前市场价格低于该值时获取实例</td></tr><tr><td>实时价格浮动</td><td>价格依据区域容量供需情况每小时调整</td></tr><tr><td>可配置中断行为</td><td>价格上涨超出设定时可选择 Stop &#x2F; Terminate，提前 2 分钟通知</td></tr></tbody></table><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img515752.png"></p><hr><h4 id="EC2-Spot-Fleets"><a href="#EC2-Spot-Fleets" class="headerlink" title="EC2 Spot Fleets"></a>EC2 Spot Fleets</h4><ul><li>Spot Fleet 是 AWS 提供的一种方式，用于自动管理多个 Spot 实例 + 可选的 On-Demand 实例组合，以满足你设定的计算容量目标</li><li>大规模数据处理（如 Spark、EMR）, 训练机器学习模型, 非关键但高算力密集型任务</li></ul><p>🧩 Spot Fleet 启动池（Launch Pools）示例</p><ul><li>你可以定义多个候选配置池，Spot Fleet 会从这些池中自动选择最优组合以满足策略</li></ul><table><thead><tr><th>属性</th><th>示例</th></tr></thead><tbody><tr><td>实例类型</td><td><code>m5.large</code>, <code>c5.xlarge</code></td></tr><tr><td>操作系统</td><td>Amazon Linux 2, Ubuntu</td></tr><tr><td>可用区</td><td><code>us-east-1a</code>, <code>us-east-1b</code></td></tr></tbody></table><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img515754.png"></p><hr><h4 id="AWS-ECS-Elastic-Container-Service"><a href="#AWS-ECS-Elastic-Container-Service" class="headerlink" title="AWS ECS (Elastic Container Service)"></a>AWS ECS (Elastic Container Service)</h4><ul><li>要在 AWS 上管理 Docker 容器，你可以选择以下平台</li></ul><table><thead><tr><th>服务名称</th><th>描述</th></tr></thead><tbody><tr><td>Amazon ECS</td><td>AWS 自研容器编排平台，支持 Docker，易于集成 AWS 生态</td></tr><tr><td>Amazon EKS</td><td>托管版 Kubernetes（开源），适合已有 K8s 经验的团队</td></tr><tr><td>AWS Fargate</td><td>无服务器容器运行平台（Serverless），可搭配 ECS 或 EKS 使用</td></tr></tbody></table><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img517216.png"></p><ul><li>Amazon ECS – Use Cases<ul><li>Amazon ECS 是 AWS 自研的容器编排服务，适用于从微服务架构到批处理作业的多种场景</li></ul></li></ul><table><thead><tr><th>场景类型</th><th>示例与说明</th></tr></thead><tbody><tr><td>微服务架构</td><td>部署多个容器，支持模块化服务与独立扩展</td></tr><tr><td>自动扩缩容</td><td>支持任务和服务的动态扩缩容，匹配流量需求</td></tr><tr><td>与负载均衡集成</td><td>原生集成 ALB &#x2F; NLB，自动注册目标容器</td></tr><tr><td>批处理与定时任务</td><td>使用 ECS 运行定期任务，兼容 Spot &#x2F; On-Demand 等实例类型</td></tr><tr><td>应用上云迁移</td><td>将本地 Docker 化应用无缝迁移至 ECS 平台</td></tr></tbody></table><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img517219.png"></p><ul><li>Amazon ECS – 核心概念<ul><li>Amazon ECS 采用任务驱动模型，结合服务定义与 IAM 控制，适合高可用容器化部署</li></ul></li></ul><table><thead><tr><th>概念</th><th>描述</th></tr></thead><tbody><tr><td>ECS Cluster</td><td>EC2 实例的逻辑分组，容器任务在此集群中运行（Fargate 模式下可为空）</td></tr><tr><td>ECS Service</td><td>定义运行多少个任务，如何部署与维持任务副本数</td></tr><tr><td>Task Definition</td><td>任务定义文件（JSON），描述容器镜像、CPU、内存、端口等配置</td></tr><tr><td>ECS Task</td><td>某个 Task Definition 的运行实例，即一个或多个实际运行的容器</td></tr></tbody></table><ul><li>🔐 ECS IAM 角色</li></ul><table><thead><tr><th>IAM 角色类型</th><th>用途说明</th></tr></thead><tbody><tr><td>EC2 Instance Profile</td><td>附加在 ECS 所属 EC2 上，用于访问 ECS API、CloudWatch 等服务</td></tr><tr><td>Task IAM Role</td><td>附加在具体任务上，用于访问 S3、DynamoDB 等 AWS 服务，实现任务级权限隔离</td></tr></tbody></table><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img517221.png"></p><ul><li>Amazon ECS – ALB Integration（动态端口映射）<ul><li>Amazon ECS 可通过 ALB（Application Load Balancer） 实现容器的智能路由，支持 动态端口映射（Dynamic Port Mapping）</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Users</span><br><span class="line">  ↓</span><br><span class="line">Application Load Balancer</span><br><span class="line">  ├──→ EC2 Instance: Task A (port 36789)</span><br><span class="line">  └──→ EC2 Instance: Task B (port 39586)</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img522822.png"></p><ul><li>Amazon ECS – 安全与网络配置<ul><li>ECS 提供强大的配置注入与灵活的网络选项，支持不同任务隔离级别与安全需求</li><li>可将 参数和密钥 作为环境变量注入容器</li><li>支持集成以下服务: SSM Parameter Store, Secrets Manager</li></ul></li></ul><table><thead><tr><th>网络模式</th><th>描述</th></tr></thead><tbody><tr><td><code>none</code></td><td>无网络连接，无法与外部通信，通常用于完全离线的计算任务</td></tr><tr><td><code>bridge</code></td><td>Docker 默认桥接网络模式，容器间通过虚拟网桥通信，支持端口映射</td></tr><tr><td><code>host</code></td><td>容器直接使用主机网络接口，端口冲突风险高，但性能更好</td></tr><tr><td><code>awsvpc</code></td><td>每个任务获得独立 ENI + 私有 IP，支持 Security Groups、VPC Flow Logs 等</td></tr><tr><td></td><td>➤ Fargate 的默认网络模式，也是最推荐的生产部署模式</td></tr></tbody></table><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img522829.png"></p><ul><li>Amazon ECS – Service Auto Scaling<ul><li>ECS 支持在 服务层级自动扩缩容任务（Tasks），无需人工干预</li></ul></li></ul><table><thead><tr><th>策略类型</th><th>描述</th><th>示例</th></tr></thead><tbody><tr><td>🎯 Target Tracking</td><td>设置目标值，自动追踪（最常用，推荐）</td><td>维持 CPU 利用率在 50%</td></tr><tr><td>📉 Step Scaling</td><td>绑定 CloudWatch Alarm，设置触发阈值 + 调整步进</td><td>CPU &gt; 70% ➝ 扩容 2 个任务</td></tr><tr><td>⏰ Scheduled Scaling</td><td>预设某个时间自动扩缩容，适合预测性变化</td><td>每天 9:00 设置最小任务为 5</td></tr></tbody></table><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img522831.png"></p><ul><li>Amazon ECS – Spot Instances 支持<ul><li>ECS 支持使用 Spot 实例来降低成本，具体取决于 启动方式（EC2 vs Fargate）</li></ul></li></ul><table><thead><tr><th>特性</th><th>🖥️ ECS（EC2 Launch Type）</th><th>⚙️ Fargate（含 FARGATE_SPOT）</th></tr></thead><tbody><tr><td>Spot 控制方式</td><td>通过 Auto Scaling Group 管理 Spot 实例</td><td>每个任务可指定运行在 FARGATE 或 FARGATE_SPOT</td></tr><tr><td>中断机制</td><td>实例回收前进入 Draining Mode，任务自动迁移或终止</td><td>Spot 任务可随时被 AWS 回收（无预警），需容错设计</td></tr><tr><td>成本与稳定性平衡</td><td>成本低但中断影响较大，需搭配 ASG 和多 AZ 策略应对</td><td>支持混合部署，On-Demand 保底 + Spot 弹性</td></tr><tr><td>配置与运维复杂度</td><td>需要配置 EC2、ASG、Capacity Provider 等</td><td>更加简单，Serverless，任务级别指定运行方式</td></tr><tr><td>扩展弹性</td><td>依赖 EC2 容量，扩容受限于底层资源可用性</td><td>弹性强，无需 EC2，直接根据负载水平扩缩任务</td></tr></tbody></table><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img522833.png"></p><hr><h4 id="AWS-Fargate"><a href="#AWS-Fargate" class="headerlink" title="AWS Fargate"></a>AWS Fargate</h4><ul><li>AWS Fargate 是一种 无服务器（Serverless）容器运行平台，可搭配 ECS 或 EKS 使用，无需管理底层 EC2 实例</li></ul><table><thead><tr><th>特性</th><th>描述</th></tr></thead><tbody><tr><td>无需管理 EC2</td><td>无需预配 &#x2F; 管理任何虚拟机，真正 Serverless</td></tr><tr><td>按需分配资源</td><td>你只需定义任务所需的 CPU &#x2F; 内存，Fargate 自动调度运行</td></tr><tr><td>简化扩展</td><td>只需增加任务数量即可实现扩容，无需考虑实例容量或 Auto Scaling</td></tr><tr><td>与 ECS &#x2F; EKS 集成</td><td>可作为两者的运行模式，适配不同容器编排系统</td></tr></tbody></table><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img522826.png"></p><hr><h4 id="AWS-ECR-Elastic-Container-Registry"><a href="#AWS-ECR-Elastic-Container-Registry" class="headerlink" title="AWS ECR (Elastic Container Registry)"></a>AWS ECR (Elastic Container Registry)</h4><ul><li>Amazon ECR 是 AWS 提供的托管式 Docker 镜像仓库，可安全存储、管理和部署容器镜像<ul><li>ECR ≠ DockerHub：默认私有，更适合生产部署，权限可控</li><li>若使用 CodePipeline、ECS、Fargate，建议统一使用 ECR 管理镜像</li><li>推送镜像前需执行 aws ecr get-login-password 登录命令</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img522834.png"></p><ul><li>Amazon ECR – Cross Region Replication<ul><li>Amazon ECR 支持<strong>跨区域（Cross-Region）与跨账户（Cross-Account）</strong>镜像复制，用于提升多区域可用性与部署效率</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img523114.png"></p><ul><li>Amazon ECR 镜像扫描（Image Scanning）<ul><li>ECR 支持两种镜像扫描方式，用于发现潜在的安全漏洞</li><li>手动扫描（Manual Scan）：用户在控制台或 CLI 中手动触发扫描</li><li>推送即扫（Scan on Push）：镜像推送到 ECR 时自动触发扫描</li><li>扫描类型: 基础扫描（Basic Scanning）,增强扫描（Enhanced Scanning, 结合 Amazon Inspector）</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img523117.png"></p><hr><h4 id="AWS-EKS-Elastic-Kubernetes-Service"><a href="#AWS-EKS-Elastic-Kubernetes-Service" class="headerlink" title="AWS EKS (Elastic Kubernetes Service)"></a>AWS EKS (Elastic Kubernetes Service)</h4><ul><li>Amazon EKS：全托管的 Kubernetes 服务，在 AWS 上运行容器化应用</li><li>Kubernetes：开源系统，用于 自动部署、扩展和管理容器化应用（如 Docker 应用）</li><li>EKS 是 ECS 的替代方案：目标类似（运行容器），但 API 和生态不同（ECS 是 AWS 专有，EKS 是开源标准）</li><li>支持两种运行环境: EC2, Fargate</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img523158.png"></p><ul><li>Amazon EKS – Node Types（节点类型）<ul><li>在 EKS 中，你可以选择三种方式来运行 Kubernetes Pod：托管节点、自托管节点、或 Fargate 模式</li></ul></li></ul><table><thead><tr><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>托管节点组（Managed Node Groups）</td><td>由 EKS 自动创建和管理的 EC2 实例，自动加入集群；属于 ASG，支持 On-Demand &#x2F; Spot</td></tr><tr><td>自托管节点（Self-Managed Nodes）</td><td>你自己创建和管理的 EC2 实例，手动注册至集群；更灵活但需自行维护</td></tr><tr><td>AWS Fargate</td><td>完全 Serverless；无需管理任何节点，适合按需、自动化的容器部署</td></tr></tbody></table><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img523200.png"></p><ul><li>Amazon EKS – Data Volumes（数据卷）<ul><li>在 EKS 中，持久化数据需要通过存储插件（CSI 驱动）并配合 Kubernetes 的 StorageClass 来定义卷的生命周期和类型</li><li>使用 Fargate 时，仅支持 EFS（当前不支持 EBS）</li></ul></li></ul><table><thead><tr><th>存储类型</th><th>说明</th></tr></thead><tbody><tr><td>Amazon EBS</td><td>块存储，适用于 EC2 节点；不能跨 AZ</td></tr><tr><td>Amazon EFS</td><td>网络文件系统；支持多个 Pod 并发访问；支持 Fargate</td></tr><tr><td>Amazon FSx for Lustre</td><td>高性能文件系统，适合机器学习、大数据分析等高吞吐量场景</td></tr><tr><td>Amazon FSx for NetApp ONTAP</td><td>支持企业级文件系统功能，如快照、复制、数据压缩</td></tr></tbody></table><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img523202.png"></p><hr><h4 id="AWS-App-Runner"><a href="#AWS-App-Runner" class="headerlink" title="AWS App Runner"></a>AWS App Runner</h4><ul><li>AWS App Runner 是一种全托管服务，用于轻松部署 Web 应用和 API，无需管理底层基础设施</li></ul><table><thead><tr><th>特性</th><th>描述</th></tr></thead><tbody><tr><td>无需基础设施经验</td><td>完全托管，无需管理服务器、扩展或负载均衡</td></tr><tr><td>源码 &#x2F; 镜像部署</td><td>支持从 GitHub 或 ECR 容器镜像直接部署</td></tr><tr><td>自动扩缩容</td><td>根据流量自动调整资源，无需手动配置 Auto Scaling</td></tr><tr><td>高可用 &amp; 加密</td><td>默认提供负载均衡与 TLS 加密</td></tr><tr><td>VPC 支持</td><td>可访问 RDS、ElastiCache 等 VPC 内部资源</td></tr><tr><td>URL 直接访问</td><td>部署后自动分配公开访问地址</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1️⃣ Source Code / Container Image (ECR)</span><br><span class="line">        ↓</span><br><span class="line">2️⃣ 配置：vCPU、RAM、Auto Scaling、Health Check</span><br><span class="line">        ↓</span><br><span class="line">3️⃣ 创建并部署（Create &amp; Deploy）</span><br><span class="line">        ↓</span><br><span class="line">4️⃣ 获得访问 URL，立即可用</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img523204.png"></p><hr><h4 id="ECS-Anywhere-amp-EKS-Anywhere"><a href="#ECS-Anywhere-amp-EKS-Anywhere" class="headerlink" title="ECS Anywhere &amp; EKS Anywhere"></a>ECS Anywhere &amp; EKS Anywhere</h4><ul><li>Amazon ECS Anywhere<ul><li>让你能在本地数据中心、虚拟机或其他自管基础设施上运行原生 ECS 任务，结合云端控制面板与本地执行能力</li><li>满足 合规性 &#x2F; 数据本地化 &#x2F; 低延迟 要求, 运行在 无 AWS 区域覆盖的地方</li><li>本地机器学习、视频处理、大数据分析 等边缘计算需求</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img523209.png"></p><ul><li>Amazon EKS Anywhere<ul><li>EKS Anywhere 允许你在 本地或其他云环境中创建并运行 Kubernetes 集群</li><li>想保留 本地运行环境，但又想用上 EKS 管理体验</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img523210.png"></p><hr><h4 id="AWS-Lambda"><a href="#AWS-Lambda" class="headerlink" title="AWS Lambda"></a>AWS Lambda</h4><ul><li>AWS Lambda 是一种 无服务器计算服务，让你只需写代码，不用管服务器。你上传函数，设置触发条件，AWS 自动运行它</li><li>AWS Lambda 可无服务器执行函数，常被以下服务触发或与之集成</li></ul><table><thead><tr><th>服务名称</th><th>触发 &#x2F; 集成方式说明</th></tr></thead><tbody><tr><td>API Gateway</td><td>通过 HTTP 请求触发 Lambda，常用于构建无服务器 API</td></tr><tr><td>Amazon S3</td><td>对象创建 &#x2F; 删除触发（如上传图片自动处理）</td></tr><tr><td>Amazon DynamoDB</td><td>表更新事件触发（使用 DynamoDB Streams）</td></tr><tr><td>Amazon Kinesis</td><td>流式数据处理，如日志分析、实时计算</td></tr><tr><td>Amazon EventBridge</td><td>基于事件总线实现复杂事件驱动架构 (CRON JOB)</td></tr><tr><td>Amazon SQS</td><td>从消息队列中拉取消息处理</td></tr><tr><td>AWS IoT Core</td><td>设备消息触发 Lambda</td></tr><tr><td>AWS Cognito</td><td>用户注册、登录等事件触发 Lambda（如验证逻辑）</td></tr><tr><td>CloudWatch Logs</td><td>可配合日志处理 &#x2F; 告警</td></tr><tr><td>AWS SNS</td><td>订阅 SNS 主题，处理发布消息</td></tr></tbody></table><ul><li>AWS Lambda 限制<ul><li>内存（RAM）：最小 128MB，最大 10GB</li><li>CPU：不能手动设置，跟内存挂钩</li><li>最长运行时间：15 分钟</li><li>部署包限制：ZIP 格式最大 50MB，解压后 + Layer 总共不能超过 250MB</li><li>并发执行数：默认 1000（可以申请提高）</li><li>容器镜像大小：最大 10GB</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img523230.png"></p><ul><li>Lambda 并发与限流（Concurrency &amp; Throttling）<ul><li>默认并发限制是 1000 个，也就是最多同时跑 1000 个函数实例</li><li>可以给某个函数设置 Reserved Concurrency，意思是给它专门留几个名额</li><li>一旦请求超出这个并发限制，就会触发 Throttle（被限流），导致调用失败或延迟</li><li>如果不够用，可以去 Service Quotas 页面申请提高并发上限</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img523248.png"></p><ul><li>Lambda 并发问题（Concurrency Issue）<ul><li>如果你不设置 Reserved Concurrency，就默认大家一起抢那 1000 个并发名额</li><li>用户多的时候，像 API Gateway、ALB（负载均衡器） 都可能因为没抢到资源而 被限流（Throttle）</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img523313.png"></p><ul><li>Lambda &amp; CodeDeploy 简介<ul><li>AWS CodeDeploy 可以帮你自动管理 Lambda 的流量切换，实现平滑部署（渐进式发布），防止直接上线出问题</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img225541.png"></p><hr><h4 id=""><a href="#" class="headerlink" title=""></a></h4>]]></content>
      
      
      <categories>
          
          <category> Certification </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AWS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>伊利诺伊州交规</title>
      <link href="/posts/80b8adf.html"/>
      <url>/posts/80b8adf.html</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.ilsos.gov/publications/pdf_publications/dsd_a112.pdf">ILLINOIS RULES OF THE ROAD 2025 链接</a></p><h3 id="1-交通法规"><a href="#1-交通法规" class="headerlink" title="1. 交通法规"></a>1. 交通法规</h3><h4 id="被警察拦下时该怎么做"><a href="#被警察拦下时该怎么做" class="headerlink" title="被警察拦下时该怎么做"></a>被警察拦下时该怎么做</h4><ul><li><p>慢慢减速，打转向灯，安全地<ins>靠右</ins>停车</p><ul><li>如果路肩太窄或没有路肩，就继续慢慢开，<ins>找到安全的位置再停车</ins></li><li>不要突然急刹车或停在车道中间</li></ul></li><li><p>停车后，双手放在方向盘上，保持可见</p></li><li><p>未经允许，不要下车</p></li><li><p>配合警察检查驾驶证和保险证明</p><ul><li>如果证件在手套箱、座位下，或手机里，<ins>提前告诉警察</ins>，等他同意后再去拿</li></ul></li><li><p>如果不确定是警车或警察</p><ul><li>保持低速、安全行驶</li><li><ins>开到灯光明亮、人多的地方再停车</ins></li><li>慢慢开到最近的警察局，寻求穿制服警察帮助</li><li><ins>拨打911确认</ins></li></ul></li><li><p>如果是晚上被拦</p><ul><li>可以打开车内灯，让警察看到车内情况，增加安全感</li></ul></li></ul><hr><h4 id="交通拦截导致开罚单或被逮捕"><a href="#交通拦截导致开罚单或被逮捕" class="headerlink" title="交通拦截导致开罚单或被逮捕"></a>交通拦截导致开罚单或被逮捕</h4><ul><li><p>不要当场和警察争论或辩解</p><ul><li><ins>无论你觉得自己有没有错，不要在现场争执，可以后续去法庭申诉</ins></li></ul></li><li><p>如果收到罚单，不要拒绝签字</p><ul><li><ins>签字只是确认收到罚单，不是承认你有罪</ins></li></ul></li><li><p>保持配合，礼貌对待警察</p></li><li><p>如果被逮捕，不要反抗</p><ul><li>反抗逮捕（比如挣脱、推搡）会让你面临更多罪名，后果严重</li></ul></li><li><p>警察必须尊重你的尊严，不得无礼或滥用权力</p></li><li><p>如果你觉得警察行为不当（比如态度恶劣、滥权），应该</p><ul><li>尽快向警方上级举报</li><li><ins>警察必须提供姓名和警号，如果你要求</ins></li><li>可以向<strong>内部事务部门（Internal Affairs）或民众投诉委员会（Civilian Complaint Board）</strong>提出书面投诉</li></ul></li></ul><hr><h4 id="分心驾驶"><a href="#分心驾驶" class="headerlink" title="分心驾驶"></a>分心驾驶</h4><ul><li><p>禁止开车时手持手机，即使开扬声器</p></li><li><p>禁止发短信或使用其他电子通讯设备（如平板、笔记本等）</p></li><li><p>禁止佩戴耳机（只允许单边使用）</p></li><li><p>允许的行为（有限制）</p><ul><li>19岁及以上驾驶员可以使用 免提设备（hands-free），如蓝牙、语音助手</li></ul></li><li><p>唯一允许手持手机的情况（例外）</p><ul><li><ins>报告紧急情况（如报警、求救）</ins></li><li>车辆停在路肩上，安全状态</li><li>因正常交通阻塞导致停车，且挂空挡或停车挡（如遇红灯时，不允许拿手机，只有真正完全停住且挂P或N挡才行）</li></ul></li></ul><hr><h4 id="安全带法规"><a href="#安全带法规" class="headerlink" title="安全带法规"></a>安全带法规</h4><ul><li>所有8岁及以上的司机和乘客（不论前排还是后排），都必须系安全带</li><li>8岁以下的儿童 必须使用符合规定的 儿童安全座椅</li></ul><hr><h4 id="伊利诺伊州限速规定"><a href="#伊利诺伊州限速规定" class="headerlink" title="伊利诺伊州限速规定"></a>伊利诺伊州限速规定</h4><p>道路限速规定（除非另有标示）</p><ul><li>州际公路和收费公路（Interstates and Tollways）：最高限速 70 mph</li><li>四车道公路（Highways with Four Lanes）：最高限速 65 mph</li><li>其他公路和乡村道路（Other Highways and Rural Areas）：最高限速 55 mph</li><li>城市&#x2F;城镇地区（City&#x2F;Town Areas）：最高限速 30 mph</li><li>小巷（Alleys）：最高限速 15 mph</li><li>学校区域（School Zones）：最高限速 20 mph（仅在上学日 6:30 a.m. 至 4 p.m.，且孩子在场且有标志的情况下）</li></ul><p>以下情形必须减速</p><ul><li>接近或穿越路口：为了避免与其他车辆或行人相撞</li><li>转弯或绕弯：控制车速，防止转弯时失控</li><li>上坡或接近坡顶：防止突然遇到看不见的对向车辆或障碍物</li><li>行驶在狭窄或曲折的道路上：保障行车安全和可控性</li><li>遇到行人、自行车、恶劣天气、机械故障或糟糕路况时：减少事故风险，防止发生意外</li></ul><hr><h4 id="工地区域驾驶规定"><a href="#工地区域驾驶规定" class="headerlink" title="工地区域驾驶规定"></a>工地区域驾驶规定</h4><ul><li>减速慢行: 进入或靠近施工&#x2F;养护区域时必须减速，确保安全</li><li>禁止使用手机</li><li>为施工车辆和工人让行</li><li>变道避开施工人员: 如果条件允许，应该变道远离施工人员所在的车道</li><li>工地限速全天有效，不管有没有工人在现场</li></ul><hr><h4 id="应急车辆"><a href="#应急车辆" class="headerlink" title="应急车辆"></a>应急车辆</h4><p>遇到停在路边的应急车辆（开启警示灯）</p><ul><li>如果看到<ins>停靠路边</ins>且开启闪烁警示灯（蓝色、红色、橙色、白色、绿色，旋转或闪烁灯）的车辆，或现场出现这些灯光的紧急场景，驾驶人必须<ul><li>减速慢行或让行</li><li>变道远离，如果无法变道，必须减速并特别小心通过</li><li>保持减速状态，直到完全通过该区域</li><li>禁止在距离500英尺（约152米）内 拍照或使用手机，除非特殊情况（如报警）</li></ul></li></ul><p>遇到行驶中的应急车辆（鸣笛+闪灯）</p><ul><li><p>当应急车辆（如救护车、消防车、警车等）鸣响警笛并闪灯接近时</p><ul><li><ins>立刻靠右停车</ins>，为其让路</li><li>视情况完全停车，确保应急车辆可以安全通过</li><li>如果在十字路口等红灯，保持停车状态，直到应急车辆完全通过路口</li></ul></li><li><p>其他特殊规定</p><ul><li>禁止压过消防水管，除非得到现场消防指挥官的许可</li></ul></li></ul><hr><h4 id="学校区域驾驶规"><a href="#学校区域驾驶规" class="headerlink" title="学校区域驾驶规"></a>学校区域驾驶规</h4><ul><li>在上学日 6:30 a.m. - 4:00 p.m.，如果有孩子在场，必须减速到 20 mph、禁止手持手机、停车让人先行，确保儿童安全<ul><li>限速 20 mph</li><li>停车让行: 必须停车让行给所有在斑马线上的儿童或成年人</li></ul></li></ul><hr><h4 id="送葬队伍驾驶规定"><a href="#送葬队伍驾驶规定" class="headerlink" title="送葬队伍驾驶规定"></a>送葬队伍驾驶规定</h4><ul><li><p>所有参与送葬队伍的车辆应打开大灯和危险警示灯（双闪灯），以示识别</p><ul><li>有一辆领头车辆（通常是一辆挂着闪光灯和葬礼旗帜的黑色轿车），后面跟着灵车，然后是载有亲朋好友的车辆，所有车辆都打开了前灯和可能的危险警告灯</li></ul></li><li><p>必须让行，不得插队进入送葬车队中间，靠右停车</p></li><li><p>不得穿插队伍，不得尾随或借送葬队伍占道</p></li></ul><hr><h4 id="让路规定"><a href="#让路规定" class="headerlink" title="让路规定"></a>让路规定</h4><ul><li><p>驾驶员必须让路的情况</p></li><li><ol><li><ins>红灯右转时，在完全停车后必须让行</ins></li></ol></li><li><ol start="2"><li>在<code>STOP</code>标志或红灯闪烁信号处 (闪烁的红灯) 完全停车后</li></ol><ul><li>若无停止线，停在人行横道前</li><li>无人行横道或停止线时，停在能看到来车的位置</li></ul></li><li><ol start="3"><li><ins>红灯下，从单行道左转到另一条单行道，且有车辆向左行驶时</ins>，让行 (Figure A)</li></ol></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img035426.png"></p><ul><li><ol start="4"><li>四路停车（四方停，四向 STOP）路口</li></ol><ul><li>谁先停，谁先走</li><li><ins>如果同时到达，左侧车辆让右侧车辆先行</ins> (Figure B)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img035426.png"></p><ul><li><ol start="5"><li>当进入<ins>有闪烁黄色箭头</ins>的路口时</li></ol></li><li><ol start="6"><li>无人管控的普通路口，<ins>左侧车辆让右侧车辆先行</ins></li></ol></li><li><ol start="7"><li>左转时遇对面来车，必须等来车通过或让行</li></ol><ul><li><ins>如果在绿灯亮时进入路口，即使灯变成红灯，您也可以完成转弯</ins></li></ul></li><li><ol start="8"><li>遇到<code>MERGE</code>合流标志时，调整车速避让主路车辆，避免碰撞</li></ol></li><li><ol start="9"><li>遇到<code>YIELD</code>让行标志时，减速或停车避让，确保安全</li></ol></li><li><ol start="10"><li>绿灯时，如果路口内有车未清空，必须等待 (针对第7点)</li></ol></li><li><ol start="11"><li>从 巷子、建筑物、私人道路或车道出来时，先停车，后让行 (Figure C)</li></ol></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img035426.png"></p><ul><li><ol start="12"><li>在“T字路口”准备进入主路时（主路无任何交通标志或信号灯），让行主路所有车辆 (Figure D)</li></ol></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img035426.png"></p><ul><li><ol start="13"><li>遇到鸣笛+闪灯的应急车辆 (救护车)，必须让行</li></ol></li></ul><p>禁止行为</p><ul><li>如果前方没有足够的空间让车顺利通过整个路口，就不可以开进路口<ul><li>前面堵车或者行人过马路，被堵住，挡住其他方向来车或者行人道上的行人</li></ul></li><li>不得驶入铁路道口（火车道），除非前方有空间安全通过<ul><li>开车来到铁路道口，前面排了很多车，车队移动得很慢</li></ul></li></ul><hr><h4 id="行人优先权规定"><a href="#行人优先权规定" class="headerlink" title="行人优先权规定"></a>行人优先权规定</h4><ul><li><p>必须停车让行的情况（完全停车 并 让行人先过）</p><ul><li>行人在有标线的人行横道内时（Marked Crosswalk）</li><li>学校区域内的斑马线附近有儿童时，尤其在上学日</li><li>有残疾人士（包括肢体、听力或视力障碍）过马路时</li></ul></li><li><p>必须减速或停车让行的其他情况</p><ul><li>没有红绿灯管控的无标线人行横道</li><li>在任何路口转弯时</li><li>红灯允许右转时，转弯前必须先停车，并让行人先过</li><li>在<code>STOP</code>停止标志或红灯闪烁处停车后，如果有行人，必须让行人先走</li><li>行人在交通灯变灯前已进入人行横道时，必须等行人先过完</li><li>在闪烁黄色箭头的路口转弯时，让行人先过</li></ul></li></ul><hr><h4 id="超车规定"><a href="#超车规定" class="headerlink" title="超车规定"></a>超车规定</h4><p>两车道公路上超车</p><ul><li><p>左侧车道必须清晰可见，且没有迎面来车，确保有足够距离完成超车</p></li><li><p><ins>超车完成后，必须等到被超车辆在你的后视镜里完全可见，才可以安全返回原车道</ins> (意思就是超车过后不能马上改变车道回去)</p></li><li><p>在与迎面车辆相距 200 英尺内，必须回到自己的车道，不得继续占用对面车道超车</p></li><li><p>被超车辆不得加速，必须配合你完成超车动作</p></li><li><p>禁止通过闪灯或打转向灯提醒对方“可以超车”，这种做法违法</p></li><li><p>禁止开车压路肩或驶离主道进行超车，不论是左边还是右边</p></li></ul><p>哪些情况下可以从右侧超车</p><ul><li>前车准备左转或正在左转，你右侧有足够空间</li><li>单行道，或每个方向有两条或以上车道的道路</li><li>为超车而拓宽的路口区域</li></ul><p>禁止超车的情况</p><ul><li>在道路中间是黄色实线或有“禁止超车”(<code>DO NOT PASS</code>)标志的区域</li><li>在上坡或弯道，无法清楚看到对向来车的地方</li><li>在距离交叉路口或铁路道口100英尺以内</li><li>在桥梁、天桥或隧道中，如果视线受阻，且距离障碍物不足100英尺</li><li>当前方车辆因让行人而停在斑马线或路口时</li><li>在施工区域，无论有无标志，一律禁止超车</li><li>在郊区（非市区）的学校区域内</li><li>在市区内有标示的学校区域</li><li>当校车停靠上下学生，且停车标志臂伸出、红灯闪烁时</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img316518.png"></p><hr><h4 id="车道使用"><a href="#车道使用" class="headerlink" title="车道使用"></a>车道使用</h4><ul><li><p><ins>通常情况下: 必须靠右侧行驶</ins>，除非符合以下例外情况</p></li><li><p>允许不靠右侧行驶的情况</p><ul><li>超车时: 在两车道或高速公路&#x2F;受控高速公路上，超车时可以占用左车道</li><li>右侧被阻挡: 遇到障碍（如停着的车、路障），必须让行对向车辆后，绕道左侧行驶</li><li>道路划分为三条车道: 按照车道标线分流，不一定非要靠右</li><li>单行道: 有两条及以上车道时，可在任一车道行驶</li><li>交通标志指示: 多车道双向公路上，如果有交通标志指示需使用左车道，按规定行驶</li><li>左转时: 从巷子、私人道路、车道左转进入马路，或准备左转时</li><li>避让紧急或故障车辆: 遇到停在路边的应急车辆或故障车辆，须变更至左车道避让</li><li>右侧施工: 道路右侧施工或封闭时，须进入左车道</li></ul></li><li><p><ins>高速公路&#x2F;受控高速公路特别规定: 左车道仅用于超车</ins>，除非以下情况</p><ul><li>交通状况&#x2F;拥堵使右车道行驶不切实际</li><li>天气状况使您必须使用左车道</li><li>右车道有障碍物或危险</li><li>您正在变道以让路给紧急车辆或施工车辆</li></ul></li></ul><hr><h4 id="转向灯规定"><a href="#转向灯规定" class="headerlink" title="转向灯规定"></a>转向灯规定</h4><ul><li><p>打灯的两种方法</p></li><li><p>电子转向灯: 右转 ➡️ 打右转灯，左转 ⬅️ 打左转灯</p></li><li><p>手势信号（Hand and Arm Signals）（如电子灯坏了时必须使用）</p><ul><li>右转: 左手向上举，手掌平伸，呈90度直角向上</li><li>左转: 左手平直伸向左侧</li><li>减速或停车: 左手向下伸，手掌朝后，垂直向下</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img316515.png"></p><hr><h4 id="转弯、变道、掉头"><a href="#转弯、变道、掉头" class="headerlink" title="转弯、变道、掉头"></a>转弯、变道、掉头</h4><p>右转规定</p><ul><li>从正确的右转车道打右转灯</li><li>观察左侧来车，确保安全</li><li><ins>转入您要进入的道路的右侧车道</ins></li></ul><p>左转规定</p><ul><li>从正确的左转车道打左转灯</li><li>观察所有方向的来车，确认安全</li><li><ins>完成转弯，进入最接近预定方向的车道</ins></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img316624.png"></p><p>变道规定</p><ul><li>从右向左变道时<ul><li>回头查看左后方盲区，确认没有来车</li><li>打左转灯示意变道意图</li><li>在确保安全的情况下，缓慢而平稳地变道</li></ul></li><li>从左向右变道时<ul><li>回头查看右后方盲区，确认没有来车</li><li>打右转灯示意变道意图</li><li>在确保安全的情况下，缓慢而平稳地变道</li></ul></li></ul><p>掉头规定</p><ul><li>除非您能看到至少 500 英尺的各个方向，否则您不得在弯​​道和山丘上掉头。市政当局可能禁止在某些道路上掉头</li></ul><p>危险信号</p><ul><li>同时打开左右转向灯（双闪灯），表示故障车辆或临时停靠车辆，用于警示其他司机注意避让</li></ul><p>双向左转车道</p><ul><li>路中间划有左右双向箭头的专用左转区，专供等候左转进&#x2F;出道路、巷子、车道</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/imgimage002.jpg"></p><hr><h4 id="环形交叉口"><a href="#环形交叉口" class="headerlink" title="环形交叉口"></a>环形交叉口</h4><ul><li><p>环形交叉口: 一种绕中心岛以逆时针方向（Counter-clockwise）行驶的交叉路口</p><ul><li><ins>进入和离开环岛时，必须让行所有车辆、行人和自行车</ins></li></ul></li><li><p>通过环形交叉口步骤</p><ul><li>减速慢行，准备进入环岛</li><li>观察交通标志和地面标线，注意是否有禁止某些方向的提示</li><li>当安全时，向右进入环岛</li><li>保持在自己的车道，不随意换道</li><li>准备离开环岛时打右转灯，告知其他车辆你将出口</li></ul></li></ul><hr><h4 id="特殊停车规定"><a href="#特殊停车规定" class="headerlink" title="特殊停车规定"></a>特殊停车规定</h4><ul><li><p>校车（School Buses）停车规定</p><ul><li><ins>当校车停靠上下乘客、开启闪光灯、伸出停车标志牌时，双向来车和同向跟车都必须停车，直到停车标志收回、闪光灯熄灭、或司机示意可以通行</ins></li></ul></li><li><p>铁路道口（Railroad Crossings）停车规定</p><ul><li>距离铁轨 15-50英尺 内停车，以下情况: 有停车标志、闪光电灯开启、栏杆放下、火车临近&#x2F;发出警告</li><li>无提示设备（仅有铁路交叉标志）的处理: 减速，观察两侧轨道，听声音，确认无火车，再通过</li><li>如果车被卡在轨道: 立刻下车，以与火车成 45 度角的方向逃离，拨打 911</li></ul></li><li><p>巷道&#x2F;车道出口（Alleys&#x2F;Driveways）停车规定</p><ul><li>完全停车，让行人、车辆优先</li></ul></li></ul><hr><h4 id="停车规则"><a href="#停车规则" class="headerlink" title="停车规则"></a>停车规则</h4><p>坡道停车</p><ul><li>在坡道停车时，必须正确调整车轮方向，以防车辆滑动<ul><li><ins>下坡时（有路缘）：将前轮朝向路缘，这样如果车辆滑动，会被路缘挡住</ins></li><li><ins>上坡时（有路缘）：将前轮远离路缘，让车轮靠住路缘，防止车辆后滑</ins></li><li><ins>上坡或下坡时（无路缘）：将前轮朝向路边，以确保滑动时不会冲入车道</ins></li></ul></li><li>停车后，务必挂P档（自动挡）或手刹（手动挡），并拉起手刹，确保车辆固定。在启动车辆离开时，检查来车，释放手刹，打开转向灯后安全驶离</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img224340.png"></p><p>平行停车</p><ul><li>在双向车道停车时，车辆的右侧车轮必须距离路缘不超过12英寸。在单行道上停车时，可以停在道路的任意一侧，但必须与车辆行驶方向一致</li></ul><p>残疾人停车位</p><ul><li>残疾人专用停车位仅限持有有效残疾人停车证或残疾人车牌的车辆使用。</li></ul><p>电动车停车位</p><ul><li>一些停车场设有电动车专用停车位，通常配备充电桩。这些车位仅供电动车使用，普通燃油车不得占用，否则可能会面临罚款或拖车处理</li></ul><hr><h4 id="禁止停车、停留或临时停车的规定"><a href="#禁止停车、停留或临时停车的规定" class="headerlink" title="禁止停车、停留或临时停车的规定"></a>禁止停车、停留或临时停车的规定</h4><p>在某些地点禁止停车、停留（短暂停靠）或临时停车，即使没有标志，也必须遵守相关规定。此外，各地政府可能会设立额外的停车限制，需要注意交通标志指示</p><ul><li>停在已停放车辆旁 (就是停在已经停着的车的旁边)</li><li>人行道、斑马线或交叉路口内</li><li>安全区域（如公交站台）与路缘之间</li><li>自行车道内（包括划线、自行车缓冲区或用护栏隔开的车道）</li><li>靠近施工区域或任何可能阻碍交通的位置</li><li>桥梁、天桥、铁路轨道或公路隧道内</li><li>高速公路或受控公路（只能在指定入口或出口上下）</li><li>分隔公路的中央隔离带（包括用于紧急掉头的区域）</li></ul><p>禁止停车或临时停留（即使车上有人）的地点</p><ul><li>公共或私人车道前（不能挡住进出）</li><li>消防栓 15 英尺范围内</li><li>消防站出入口 20 英尺范围内，以及交叉路口的斑马线 20 英尺内</li><li>STOP 标志、YIELD 标志或红绿灯 30 英尺范围内</li><li>铁路道口 50 英尺范围内</li></ul><hr><h4 id="额外交通法规"><a href="#额外交通法规" class="headerlink" title="额外交通法规"></a>额外交通法规</h4><ul><li>不得向行驶车辆投掷物品</li><li>禁止驶上人行道，除非该人行道是车道的一部分，例如私人车道的出入口</li><li>不得超载</li><li>不得制造噪音污染</li></ul><hr><h3 id="2-道路共用"><a href="#2-道路共用" class="headerlink" title="2. 道路共用"></a>2. 道路共用</h3><h4 id="与行人共用道路"><a href="#与行人共用道路" class="headerlink" title="与行人共用道路"></a>与行人共用道路</h4><p>在法律中，“行人”不仅指走路的人，还包括</p><ul><li>使用滑板、<strong>轮滑（in-line speed skates）</strong>的人</li><li>使用轮椅、导盲犬、白手杖等辅助工具的残障人士</li><li>行动不便、视力或听力受限者也都属于行人</li></ul><p>行人与驾驶员的共同责任</p><ul><li>行人与驾驶员都应为交通安全负责</li><li>驾驶员应始终准备让行人优先通行，尤其不要贴太近</li></ul><hr><h4 id="儿童与交通安全"><a href="#儿童与交通安全" class="headerlink" title="儿童与交通安全"></a>儿童与交通安全</h4><p>驾驶员须注意</p><ul><li>特别注意危险区域标志：如学校区域、校车上下客点、游乐场、公园等，这些都是儿童高频出没区域</li><li>在居民区、学校周边或有孩子可能出现的地方，务必提前减速、保持警觉</li><li>倒车进出车道时，尤其要小心，儿童个子矮小，容易出现在盲区</li><li>留意突然跑出马路的孩子，不要指望孩子知道交通规则，要靠你防范</li></ul><hr><h4 id="与摩托车共用道路"><a href="#与摩托车共用道路" class="headerlink" title="与摩托车共用道路"></a>与摩托车共用道路</h4><p>摩托车和其他机动车享有相同的通行权利与责任，但由于摩托车体积小、缺乏保护、容易受伤，驾驶员应给予特别注意</p><ul><li>很多摩托车事故发生的原因是：驾驶员没有看到摩托车，或低估了摩托车的速度</li><li>超过50%的摩托车事故发生在交叉路口, 最常见情形是：汽车左转时，撞上对向直行的摩托车</li><li>当摩托车从你身边超车时，你应<ul><li>保持原车道，不要向一侧挪动</li><li>保持当前车速</li><li>等摩托车完成变道，留出空间</li></ul></li></ul><hr><h4 id="故障车辆处理规定"><a href="#故障车辆处理规定" class="headerlink" title="故障车辆处理规定"></a>故障车辆处理规定</h4><p>靠近故障车辆时该怎么做</p><ul><li>当你在四车道高速公路上遇到一辆开启双闪灯的抛锚车辆时<ul><li>如果安全可以变道：必须变道远离故障车</li><li>如果不能变道：应减速通过，不要高速从旁边驶过</li><li>直到完全超过该车辆后，才可以恢复原本车速</li></ul></li></ul><p>禁止的行为</p><ul><li>不得在乡村公路上推车，除非是紧急情况，且必须尽快将其移除以避免造成危险</li><li>不得移走事故车辆时留下碎玻璃或残骸。必须将所有碎片清理干净</li><li>车辆之间拖车必须使用连接杆（drawbar）。在多数情况下<ul><li>拖车距离不得超过 15 英尺</li><li>必须使用 两根链条或缆绳将拖车固定连接</li></ul></li></ul><hr><h3 id="3-酒后驾驶-DUI"><a href="#3-酒后驾驶-DUI" class="headerlink" title="3. 酒后驾驶 (DUI)"></a>3. 酒后驾驶 (DUI)</h3><h4 id="血液酒精浓度"><a href="#血液酒精浓度" class="headerlink" title="血液酒精浓度"></a>血液酒精浓度</h4><p>什么是 BAC</p><ul><li>BAC（Blood-Alcohol Concentration）是指血液中的酒精浓度，可以通过以下方式测量<ul><li>呼气测试, 血液检测, 尿液检测</li></ul></li></ul><p>BAC 与 DUI 的法律底线</p><ul><li>如果你的 BAC ≥ 0.08%，驾驶即违法</li><li>即使 BAC &lt; 0.08%，只要酒精影响了你的驾驶能力，也可能被认定为酒驾（DUI）</li></ul><hr><h4 id="DUI-法律详解"><a href="#DUI-法律详解" class="headerlink" title="DUI 法律详解"></a>DUI 法律详解</h4><p>在伊利诺伊州，酒驾（DUI）被认定为暴力犯罪<br>一旦被判定为 DUI，记录将永久保留在你的驾驶记录上</p><p>默示同意法（Implied Consent Law）</p><ul><li>你只要在伊州开车，就自动同意接受下列检测<ul><li>呼气测试, 血液测试, 尿液或其他体液测试</li></ul></li></ul><p>法定摘要性吊销</p><ul><li>检测结果达到以下标准将被吊销驾照<ul><li>BAC ≥ 0.08%</li><li>THC ≥ 5 ng&#x2F;mL（血液）或 ≥ 10 ng&#x2F;mL（其他体液）</li><li>检测出任何受控药物&#x2F;致幻化合物&#x2F;冰毒</li></ul></li></ul><hr><h4 id="DUI-相关违法行为"><a href="#DUI-相关违法行为" class="headerlink" title="DUI 相关违法行为"></a>DUI 相关违法行为</h4><p>加重酒驾（Aggravated DUI）</p><ul><li>你在以下情况下将被起诉为加重酒驾（Aggravated DUI），处罚远重于普通 DUI<ul><li>酒驾时发生致人死亡或人身伤害</li><li>是第三次或以上 DUI 犯罪</li><li>酒驾时没有有效驾照、许可证或保险</li></ul></li></ul><p>酒精饮品的非法运输 &#x2F; 开放容器法（Open Container Law）</p><ul><li>任何人在车内饮酒都是违法行为，包括司机与乘客</li><li>开封的酒精饮料不得放在乘客区，即使不喝也违法</li></ul><p>父母或监护人责任（Parental Responsibility）</p><ul><li>禁止让未满21岁者饮酒；</li><li>不得纵容或未控制孩子在自家或自己管理的场所饮酒（包括车辆或船上）</li></ul><p>协助酒驾也违法（Contributing to a DUI）</p><ul><li>你不得把车借给已知正在酒驾的人</li><li>若你向未满21岁者提供酒精，你可能会被判刑入狱</li></ul><hr><h3 id="4-交通违规-x2F-事故处理"><a href="#4-交通违规-x2F-事故处理" class="headerlink" title="4. 交通违规 &#x2F; 事故处理"></a>4. 交通违规 &#x2F; 事故处理</h3><h4 id="发生或遇到交通事故时怎么办"><a href="#发生或遇到交通事故时怎么办" class="headerlink" title="发生或遇到交通事故时怎么办"></a>发生或遇到交通事故时怎么办</h4><p>若你卷入或目睹交通事故，应立即按以下步骤处理</p><ul><li><ol><li>停车</li></ol><ul><li>立即将车辆停在安全、明亮、不会阻碍交通的公共区域</li><li>若车辆还能移动，应尽量把车移到不影响道路的位置</li></ul></li><li><ol start="2"><li>帮助伤者</li></ol><ul><li>如果有人员受伤，应在能力范围内提供帮助，或者在对方请求时提供协助</li></ul></li><li><ol start="3"><li>立即拨打 911</li></ol><ul><li>报警并告知是否有人伤亡</li></ul></li><li><ol start="4"><li>警示其他车辆</li></ol><ul><li>开启双闪警示灯</li><li>如有条件，可摆放三角警示牌或照明警示灯，防止二次事故</li></ul></li><li><ol start="5"><li>信息交换</li></ol><ul><li>向所有涉事人员收集并提供以下信息</li><li>姓名，地址，电话号码，驾照号码，车牌号码</li></ul></li></ul><hr><h4 id="出庭相关规定"><a href="#出庭相关规定" class="headerlink" title="出庭相关规定"></a>出庭相关规定</h4><ul><li>如果你因为轻微交通违规而收到罚单，罚单上会写明你必须出庭的日期</li><li>不付款也不出庭会导致<ul><li>安排第二次出庭日期（至少提前30天通知）</li><li>法院书记员会通过你提供的地址、手机、邮箱或短信系统通知你</li><li>若你第二次仍未出庭，将会被视为默认有罪（Ex-Parte Conviction），记录会被上报到伊利诺伊州务卿（Secretary of State）</li><li>最终结果：等同于一次正式交通违法定罪</li></ul></li></ul><p>在外州被开罚单怎么办？（非居民违规者协议）</p><ul><li>如果你在其他州（该州为“非居民违规者协议成员州”）被开罚单，你有三个选择<ul><li>当场留在该州打官司</li><li>直接缴纳罚款</li><li>签字承诺后回家处理（Promise to Comply）</li></ul></li></ul><hr><h4 id="交通事故报告"><a href="#交通事故报告" class="headerlink" title="交通事故报告"></a>交通事故报告</h4><p>哪些情况必须提交事故报告</p><ul><li>无论是否为事故责任方，只要满足以下任一情况，就必须提交事故报告<ul><li>事故导致人员死亡</li><li>事故导致人员受伤</li><li>财产损失超过 1500 美元</li><li>如果其中任一辆车没有保险，只要财产损失超过 500 美元，也必须上报</li><li>涉及校车并造成任何财产损失或人员受伤</li><li>事故发生在距离校车 50 英尺内，并导致上下车人员受伤或死亡</li></ul></li></ul><p>报告时限及方式</p><ul><li>事故发生后，必须在 30 分钟内报告</li><li>如果警察已在现场，会当场记录</li><li>如果现场无警察，应尽快前往最近的警察局报案</li><li>在农村地区，需联系郡治安官或伊利诺伊州州警</li><li>如果司机因伤无法报案，乘客有责任代为报告</li></ul><p>未按规定报告的后果</p><ul><li>最严重可被罚款 2500 美元，还可能面临最长 1 年监禁</li></ul><hr><h4 id="肇事逃逸、无人车辆事故、安全责任法"><a href="#肇事逃逸、无人车辆事故、安全责任法" class="headerlink" title="肇事逃逸、无人车辆事故、安全责任法"></a>肇事逃逸、无人车辆事故、安全责任法</h4><p>离开事故现场（Leaving the Scene of a Crash）</p><ul><li>如果在交通事故中，司机擅自离开现场，尤其是在有人员伤亡的情况下<ul><li>将会被依法追究刑事责任</li><li>若事故造成人员受伤或死亡: 伊利诺伊州务卿（Secretary of State）必须吊销该驾驶员的驾照</li><li>若事故造成财产损失超过 1000 美元: 驾驶员的驾驶资格将被暂</li></ul></li></ul><p>无人车辆事故处理（Unattended Vehicles）</p><ul><li>如果你发生了撞到无人车辆或财产的事故（即对方不在现场）<ul><li>停车并将车辆移至不妨碍交通的位置</li><li>如果找不到车主，必须在对方车或财产上留下以下信息<ul><li>姓名、地址、电话号码、车牌号</li></ul></li><li>向警方报告</li><li>完成所有规定的事故报告</li></ul></li></ul><p>安全责任法（Safety Responsibility Law）</p><ul><li>如果你在事故中负主要责任，且<strong>没有投保责任险</strong>，还需要遵守下列额外规定<ul><li>你必须向伊利诺伊州交通部（IDOT）缴纳<strong>保证金（security）</strong>来赔偿受害方损失</li><li>金额由交通部决定</li></ul></li></ul><hr><h3 id="5-道路标志"><a href="#5-道路标志" class="headerlink" title="5. 道路标志"></a>5. 道路标志</h3><h4 id="标志的形状与颜色"><a href="#标志的形状与颜色" class="headerlink" title="标志的形状与颜色"></a>标志的形状与颜色</h4><p>伊利诺伊州将道路标志分为三类，每类标志都有特定的形状和颜色，用于传达不同的道路信息</p><p>标志的形状及用途</p><ol><li><p>八角形: 专用于“停车（STOP）”标志<br><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img322133.png"></p></li><li><p>倒三角形: 表示“让行（YIELD）”，车辆需减速或停下让其他车辆或行人先行<br><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img322135.png"></p></li><li><p>圆形: 专用于铁路道口警示<br><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img322136.png"></p></li><li><p>五边形（顶部尖、底部平）: 用于学校区域或学生穿越标志，提示前方有学校或学生正在穿越马路<br><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img322137.png"></p></li><li><p>菱形: 表示警告标志，用来提示前方道路可能存在危险或变化（如弯道、滑路、施工等）<br><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img322138.png"></p></li><li><p>朝右的等腰三角形（立在路左侧）: 表示“禁止超车区域（NO PASSING ZONE）”开始<br><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img322139.png"></p></li><li><p>正方形或矩形: 可用于规章标志（如限速）或指示标志（如路名、方向、距离等）<br><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img322140.png"></p></li></ol><p>交通标志颜色及其意义</p><ol><li><p>红色（RED）: 用于规章标志，必须遵守<br>常见于: 停车（STOP）、让行（YIELD）、禁止进入（DO NOT ENTER）、逆行（WRONG WAY）<br><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img322142.png"></p></li><li><p>黑色和白色（BLACK and WHITE）: 大多数是规章标志，也必须遵守<br>部分黑白标志也用于路线编号或方向指示<br><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img322143.png"></p></li><li><p>黄色（YELLOW）: 用于常规警告标志，提醒前方道路状况或危险<br>例如：弯道、滑路、交叉口等<br><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img322144.png"></p></li><li><p>黄绿色（YELLOW-GREEN）: 用于专门警告行人、自行车和学校相关区域<br><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img322145.png"></p></li><li><p>橙色（ORANGE）: 用于施工或养护区域的警告标志，提示前方可能存在道路施工或设备<br><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img322146.png"></p></li><li><p>绿色（GREEN）: 用于引导标志，提供方向、路名、出口、距离等信息<br><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img322147.png"></p></li><li><p>蓝色（BLUE）: 用于服务类引导标志，提供与交通相关的服务信息<br><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img322148.png"></p></li><li><p>棕色（BROWN）: 用于公园、文化和休闲地点的指示标志<br><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img322149.png"></p></li><li><p>粉色（PINK）: 用于突发事件相关标志，警告可能由于事故或自然灾害而产生的交通风险<br><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img322150.png"></p></li></ol><hr><h4 id="规章标志"><a href="#规章标志" class="headerlink" title="规章标志"></a>规章标志</h4><p>这类标志用来明确规定你“必须做什么”或“不能做什么”，具有法律效力，必须遵守</p><ol><li><p>停车（Stop）: 八角形标志，在停车线前完全停车<br><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img322205.png"></p></li><li><p>四向停车（All-Way Stop）: 所有方向都设有停车标志<br>谁先停，谁先走；其他车辆按顺序等待<br><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img322207.png"></p></li><li><p>让行（Yield）: 倒三角形标志，表示你必须让行，让所有车辆或行人优先通行<br><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img322208.png"></p></li><li><p>禁止进入（Do Not Enter）: 通常用于单行道反方向入口或高速公路错误方向的匝道，表示此方向禁止进入<br><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img322209.png"></p></li><li><p>前方限速区域（Speed Zone Ahead）: 提醒你即将进入一个新的限速区域，准备减速<br><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img322210.png"></p></li><li><p>限速（Speed Limit）: 显示最大和最小车速限制<br>如果你慢到影响正常交通，是违法的（除非出于安全考虑）<br><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img322214.png"></p></li><li><p>方向错误（Wrong Way）: 表示你正在逆向行驶，必须立即调整方向<br><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img322215.png"></p></li><li><p>禁止行为（No ___）: 红圈+对角斜杠的标志表示某种行为不被允许<br>比如：No U-turn：禁止掉头，No Right Turn &#x2F; No Left Turn：禁止右转或左转<br><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img322216.png"></p></li><li><p>单行道（One-Way）: 只能按照箭头指示方向行驶，常见于市区单行道<br><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img322217.png"></p></li><li><p>中央左转车道（Two-Way Left Turn Lanes）: 表示中间为双向共用左转道<br><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img322221.png"></p></li><li><p>红灯禁止转弯（No Turn on Red）: 指定交叉口禁止红灯时右转或左转<br><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img322222.png"></p></li><li><p>接近分隔公路（Approaching a Divided Highway）: 表示前方道路有中央隔离带，两边是相反方向的车道<br><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img322223.png"></p></li><li><p>靠右行驶（Keep Right）: 当你遇到中央岛、隔离带或障碍物时，必须靠右通行<br><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img322224.png"></p></li><li><p>慢车靠右（Slower Traffic Keep Right）: 通常用于高速公路，慢速车辆必须行驶在右侧车道<br><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img322225.png"></p></li><li><p>红灯停车位置（Stop Here on Red）: 指明在红灯时你必须在哪里停车，常用于视线不清的路口<br><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img322226.png"></p></li><li><p>禁止超车（Do Not Pass）+ 可安全超车（Pass With Care）<br>表示在该路段禁止超车 + 表示禁止超车区域结束<br><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img322227.png"></p></li><li><p>道路封闭（Road Closed）: 道路对所有车辆封闭，禁止通行<br><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img322228.png"></p></li><li><p>自行车道（Bike Lane）: 标记了专用的自行车车道，不可停放或行驶<br><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img322229.png"></p></li></ol><hr><h4 id="警告标志"><a href="#警告标志" class="headerlink" title="警告标志"></a>警告标志</h4><p>警告标志通常为菱形，颜色多为黄色或橙色（施工区域），部分地区对行人、自行车、学校相关标志使用荧光黄绿色。这些标志提醒你前方有特殊路况或危险情况，需格外小心</p><ol><li><p>行人横道（Pedestrian Crosswalk）: 提醒前方有行人可能横穿马路，横道不一定在路口，需注意左右两侧，部分标志配有闪烁灯<br><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img322248.png"></p></li><li><p>特殊通行区域: 行人&#x2F;牲畜穿越区、轮椅通行区、自行车道交汇点等<br><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img322249.png"></p></li><li><p>学校区域与学校横道: 提醒靠近学校或学生穿越区域<br>上学日 6:30 a.m. - 4 p.m. 时段减速至标明限速（通常为 20mph），注意学校巡逻员、交警等指挥交通<br><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img322250.png"></p></li><li><p>红灯&#x2F;让行&#x2F;信号灯预告（Stop Ahead &#x2F; Yield Ahead &#x2F; Signal Ahead）: 提醒前方即将进入有交通信号控制的区域，即使信号灯还看不见，也应减速准备停车<br><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img322251.png"></p></li><li><p>路口预告（Intersections Ahead）: 常见的四种路口，十字路口、T字型路口、Y字型路口、侧路接入<br><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img322252.png"></p></li><li><p>转弯与弯道（Turns and Curves）: 标志上会用箭头表示，右转&#x2F;左转、S形弯道、单侧弯道、指定的转弯速度（标志下方可能会有附加限速）<br><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img322253.png"></p></li><li><p>高速出口限速（Exit Ramp Speed）: 高速公路出口或匝道上标注的“安全最大车速”<br><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img322254.png"></p></li><li><p>湿滑路面（Slippery Pavement）: 提示雨天或潮湿路段易打滑，需减速慢行、保持车距<br><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img322255.png"></p></li><li><p>陡坡（Downgrade）: 前方为长或陡峭下坡，可能还有急弯，应提前减速<br><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img322256.png"></p></li><li><p>桥面变窄（Narrow Bridge）: 桥面比原道路狭窄，通常比路面窄 2 英尺，小心会车<br><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img322257.png"></p></li><li><p>车道减少（Reduction in Lanes）: 原多车道将变成少车道（可能是施工导致），需提前变道或合流<br><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img322258.png"></p></li><li><p>道路变窄（Road Narrows）: 双车道即将变窄，小心会车<br><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img322259.png"></p></li><li><p>禁止超车区开始（No Passing Zone）: 设置在双向两车道，标志通常放在路左侧，配合黄色实线<br><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img322300.png"></p></li><li><p>合流（Merging Lanes）: 提示你即将进入合并区域（如匝道合流），应减速或允许他车并入<br><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img322301.png"></p></li><li><p>方向变化或路面收窄（Change in Direction）: 常见于急转弯外侧、窄桥入口，提示方向急变<br><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img322302.png"></p></li><li><p>分隔公路开始&#x2F;结束（Divided Highway Begins&#x2F;Ends）: 开始：即将进入有中央隔离带的双向道路，结束：即将离开分隔公路，注意迎面来车<br><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img322304.png"></p></li><li><p>双向道路（Two-Way Roadway）: 提醒你正在进入一条双向行驶的道路，要靠右侧行驶并注意来车<br><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img322325.png"></p></li></ol><hr><h4 id="施工与养护标志"><a href="#施工与养护标志" class="headerlink" title="施工与养护标志"></a>施工与养护标志</h4><p>这类标志提醒驾驶者注意道路状况的改变，同时保障道路工作人员的安全</p><ol><li><p>工人前方（Workers Ahead）: 标志通常设置在距离施工区域较远的位置，为你提供提前减速的时间<br><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img322306.png"></p></li><li><p>警示锥筒、路障桶与路障（Warning Cones, Drums, and Barricades）: 用于标示行车路线，引导车辆安全通过施工区域，也用于提醒现有的危险区域，例如坑洞、障碍物或车道变化<br><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img322307.png"></p></li><li><p>警示灯与方向箭板（Warning Lights and Arrow Boards）: 警示灯：在夜间帮助你发现路障、锥桶、施工边界等障碍，方向箭板：用于提醒你即将车道关闭或变道合流，并指示安全的行驶方向<br><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img322308.png"></p></li><li><p>旗手标志（Flagger）: 表示前方有交通指挥员（旗手）协助交通控制，驶近时要减速，注意其发出的手势或旗语指令，如被示意停车，必须停下<br><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img322309.png"></p></li></ol><hr><h4 id="可变信息标志"><a href="#可变信息标志" class="headerlink" title="可变信息标志"></a>可变信息标志</h4><p>这些是道路上常见的电子显示屏，通常架设在三脚架或大型拖车上，能实时更新内容</p><ul><li>提醒交通拥堵、前方事故、慢车道段落</li><li>通知车道&#x2F;道路关闭</li><li>提示路线变更或行车方式变化</li><li>提供延误时间或绕行建议</li><li>告知你需要合流（使用“拉链式合流”）</li></ul><p>其他特殊标志（Other Special Signs）</p><ol><li><p>慢速车辆标志（Slow-Moving Vehicle）: 这个橙色三角标志出现在农用车、建筑设备、动物牵引车等慢速移动的车辆后方<br><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img322310.png"></p></li><li><p>残障人士专用停车标志: 标示停车位专为以下车辆保留，持有残障人士专用车牌、持有合法停车通行证（Placard）、退伍残障军人牌照<br><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img322311.png"></p></li></ol><hr><h4 id="指引标志"><a href="#指引标志" class="headerlink" title="指引标志"></a>指引标志</h4><p>指引标志用于告诉你: 你在哪里、你正在行驶的是哪条道路、如何到达某个特定地点</p><p>这些标志单独使用或搭配小标志，用于引导你前往特定路线或道路，常见的类型包括</p><ul><li>州际公路（Interstate）</li><li>美国国道（U.S. Route）</li><li>州道（State Route）</li><li>县道（County Road）</li><li>出口编号（Exit Numbers）</li><li>方向牌（如“North 55”或“East 90”）</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img322312.png"></p><hr><h4 id="危险品标志"><a href="#危险品标志" class="headerlink" title="危险品标志"></a>危险品标志</h4><p>危险品标志是一种张贴在运输车辆、容器或包装外部的标识，用于说明所运输的危险物品的种类和危险程度</p><p>如果你靠近一辆张贴有危险品标志的事故车辆</p><ul><li>立即远离事故现场，尤其是当你看到烟雾、有毒标志、或听到爆炸声</li><li>服从紧急救援人员指示，他们受过专业训练</li><li>如果现场没有应急车辆，应尽快远离事故区域，并在安全地点报警</li><li>即使短时间内没感觉不适，也有可能存在延迟性中毒反应，如有不适，请立即就医</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img322313.png"></p><hr><h3 id="6-交通信号灯与路面标记"><a href="#6-交通信号灯与路面标记" class="headerlink" title="6. 交通信号灯与路面标记"></a>6. 交通信号灯与路面标记</h3><h4 id="交通信号灯"><a href="#交通信号灯" class="headerlink" title="交通信号灯"></a>交通信号灯</h4><ol><li>红灯</li></ol><ul><li>必须停车</li><li>可以右转（除非有标志禁止），但需先停并让行人和来车先行</li><li>从单行道左转到另一条左向单行道也可以在红灯时左转，前提同上</li></ul><ol start="2"><li>黄灯</li></ol><ul><li>灯即将变红，不要进入路口</li></ul><ol start="3"><li>绿灯</li></ol><ul><li>可以通行，但要礼让路口中行人和车辆</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img322428.png"></p><p>闪烁灯（Flashing Lights）</p><ol><li>闪烁红灯：像“Stop”标志，停车，让行后再通行</li><li>闪烁黄灯：减速，小心通行</li></ol><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img322429.png"></p><p>箭头灯（Arrows）</p><ol><li>红箭头：禁止对应方向的转弯。但可以右转或从单行道左转入另一条左向单行道，条件和红灯相同</li><li>常亮黄箭头：绿箭头即将结束，准备变红</li><li>闪烁黄箭头：在让行后可以转弯</li><li>绿箭头: 向上：直行，向左：左转，向右：右转</li></ol><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img322431.png"></p><p>车道灯（Lane Signals）</p><ol><li>红 X：禁止驶入此车道</li><li>黄 X：该车道将关闭，尽快换道</li><li>闪烁黄箭头：该车道可左转</li><li>绿箭头：可以使用该车道</li></ol><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img322432.png"></p><hr><h4 id="道路标线"><a href="#道路标线" class="headerlink" title="道路标线"></a>道路标线</h4><p>白色车道线（White Lane Lines）: 用于<ins>同向行驶</ins>的车道之间</p><ul><li>白色虚线：可变道或转弯</li><li>白色实线：尽量不要变道，只有在非常必要时可小心越过</li><li>双白色实线：禁止变道</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img322436.png"></p><p>黄色中心线（Yellow Center Lines）: 用于<ins>相反方向行驶</ins>的车道之间</p><ul><li>黄色虚线：可越线超车</li><li>双黄实线：禁止穿越，仅可左转进&#x2F;出小路或车道</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img322437.png"></p><p>黄色禁止超车线（No Passing Lines）</p><ul><li>单侧黄色实线在你这边：不能起始超车，只能完成超车或左转</li><li>一虚一实黄线：只有靠虚线一侧的车道可以超车</li><li>双黄实线：不能超车，但允许左转进出小路</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img322439.png"></p><p>双向左转车道（Two-Way Left Turn Lanes）</p><ul><li>中间专用左转车道，两侧用黄色线和白色箭头标识</li><li>仅可用来左转或调头，不能在此车道上长时间行驶</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img322440.png"></p><hr><h4 id="铁路道口"><a href="#铁路道口" class="headerlink" title="铁路道口"></a>铁路道口</h4><p>铁路道口警示标志</p><ol><li>圆形黄色预警标志（Advance Warning Sign）: 标有黑色“X”和“RR”，意味着你即将到达铁路道口，通常设置在道口前750英尺以内</li><li>铁路交叉标志（Railroad Crossbuck Sign）: 类似于“让行”标志，如果是多轨道交叉，会显示有多少条轨道</li><li>闪烁灯光信号（Flashing Light Signals）: 灯光开始闪烁时必须停车，直到火车完全通过且灯光停止闪烁</li><li>道闸（Gates）: 不能试图在道闸下降时抢行，也不能绕过道闸，必须等到闸杆完全抬起、灯光熄灭后再继续前进</li></ol><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img322457.png"></p><p>紧急联系信息（ENS）</p><ul><li>ENS（Emergency Notification System） 是铁路道口上提供的蓝色紧急联系标识</li><li>如果发生紧急情况（比如车辆卡在轨道上），你可以立刻拨打这个电话联系铁路公司并报告准确位置</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img322458.png"></p><hr><h3 id="7-安全驾驶小贴士"><a href="#7-安全驾驶小贴士" class="headerlink" title="7. 安全驾驶小贴士"></a>7. 安全驾驶小贴士</h3><h4 id="防御性驾驶"><a href="#防御性驾驶" class="headerlink" title="防御性驾驶"></a>防御性驾驶</h4><ul><li>保持警觉，预判他人行为: 不要假设其他驾驶者一定会遵守交通规则或让你</li><li>保持安全距离: 给自己留出足够的反应空间，比如和前车保持 3 秒或以上的跟车距离</li><li>控制车速: 根据路况、天气和交通状况适当减速</li><li>随时做好应对突发情况的准备: 比如突然有人变道、急刹车、横穿马路的行人或动物等</li><li>保持冷静，选择最安全的处理方式: 万一无法避免碰撞，尽可能选择“最小伤害”的解决方案，比如控制方向，避让人群、灯柱等硬物</li></ul><hr><h4 id="跟车距离"><a href="#跟车距离" class="headerlink" title="跟车距离"></a>跟车距离</h4><p>为什么保持跟车距离很重要</p><ul><li>尾随过近（Tailgating） 是导致追尾事故的最常见原因</li><li>在紧急情况（比如前车突然刹车）时，没有足够的反应空间容易出事故</li></ul><p>三秒规则（Three-Second Rule）怎么用</p><ul><li>选一个固定物体：比如路边的标志牌、树、天桥等</li><li>当前车经过该物体时开始计数</li><li>如果你数到三之前已经到达那个物体，说明你跟太近了，应该放慢速度、拉开距离</li></ul><p>特殊情况需增加距离</p><ul><li>雨、雪、雾、冰滑路面：延长为 4-6 秒甚至更多</li><li>高速行驶时：反应距离更长，建议超过 3 秒</li><li>跟大型车辆（如卡车、公交）：因视线受阻也应拉大距离</li></ul><p>如果被别人尾随太紧怎么办</p><ul><li>切换车道：让他先过去</li><li>逐渐减速靠边：找安全的地方让对方超车，不要急刹车挑衅</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img223047.png"></p><hr><h4 id="车速"><a href="#车速" class="headerlink" title="车速"></a>车速</h4><p>为什么控制车速很重要</p><ul><li>开太快或太慢 都可能造成危险</li><li>安全车速 ≠ 限速标志，而是要结合天气、道路、交通状况调整</li><li>就算限速是 55mph，如果大雾大雨，可能只能开 35mph 才安全</li><li><ins>速度翻倍，刹车距离是四倍（不是两倍）</ins></li></ul><p>决定车速时要考虑什么</p><ul><li>你自己的反应能力：精神状态好不好？是否疲劳</li><li>道路状况：坑洼、打滑、下坡、施工等都得减速</li><li>轮胎大小和花纹深度：越大的轮胎、花纹越深，越容易刹住</li><li>风向和风速：逆风能帮助你刹车，顺风（tailwind）反而会延长刹车距离</li></ul><hr><h4 id="疲劳驾驶"><a href="#疲劳驾驶" class="headerlink" title="疲劳驾驶"></a>疲劳驾驶</h4><p>即使你没有真的睡着，疲劳也会严重影响你开车的反应时间和判断力</p><ul><li>很多疲劳驾驶者在关键时刻无法及时刹车或转向避险</li><li>一瞬间的打瞌睡，可能就造成车祸，尤其在高速上</li></ul><p>如何避免疲劳驾驶</p><ul><li>保证充足睡眠，尤其是长途出发前</li><li>经常停车休息，建议每2小时或100英里停一次</li><li>不要硬撑！ 如果困了，就找安全的地方休息</li></ul><hr><h4 id="不同天气条件下的安全驾驶建议"><a href="#不同天气条件下的安全驾驶建议" class="headerlink" title="不同天气条件下的安全驾驶建议"></a>不同天气条件下的安全驾驶建议</h4><p>雾天驾驶（Fog）</p><ul><li>建议避免在浓雾中驾驶，如必须开车，请注意<ul><li>关闭巡航控制，加大跟车距离</li><li>减速行驶，若看到前方车灯，更要减速，防止对方在中线行驶或停着不动</li><li>开启近光灯或雾灯，切勿开远光灯</li><li>不要“盲目开车”，切记不能超出视野范围驾驶，如果雾太浓，应尽快驶出路面，安全停车</li><li>提前打转向灯，增加他人反应时间</li><li>提前刹车提醒后车，避免追尾</li></ul></li></ul><p>雨天驾驶（Rain）</p><ul><li>雨天地面湿滑、能见度低<ul><li>根据伊利诺伊州法律：雨刷一开，车灯也必须开启</li><li>关闭巡航控制，减速慢行，注意弯道、刹车时打滑风险</li><li>避免水滑现象（Hydroplaning）：若车轮失控打滑，松油门，不要急刹车，尽量掌控方向</li><li>若遇积水路段或桥下积水，不可冒险通过，应掉头寻找替代路线</li></ul></li></ul><p>大风天气（High Winds）</p><ul><li>降低车速，特别是从遮挡区驶入开阔区域或与大车交会时</li><li>注意路面湿滑、冰雪或大雨伴随的大风</li><li>在伊利诺伊收费公路上，大风天气禁止拖挂房车通行</li></ul><p>冬季驾驶（Winter Driving）</p><ul><li>冬季常见冰雪低温、视线差，是一年中最难驾驶的季节<ul><li>减速，拉开车距，冰雪阴影区域尤其滑</li><li>清除车身所有冰雪，确保前后灯、挡风玻璃和窗户都干净</li><li>轻踩刹车，以测试当前路况抓地力</li><li>桥梁、阴影、匝道、弯道可能比道路更早结冰，需提前减速</li><li>车内准备好毛毯、食物、小铲子等应急装备，如果抛锚，应待在车内，短时间启动发动机保暖，并打开窗户防止一氧化碳中毒，确保排气管无积雪</li></ul></li></ul><hr><h4 id="特殊驾驶情况与潜在危险的应对方法"><a href="#特殊驾驶情况与潜在危险的应对方法" class="headerlink" title="特殊驾驶情况与潜在危险的应对方法"></a>特殊驾驶情况与潜在危险的应对方法</h4><p>高速公路（Expressway）驾驶安全提示</p><ul><li>加速合流区：上高速时利用加速车道提速，与主路车速一致再合流</li><li>使用转向灯，变道前先观察后视镜与盲区</li><li>保持安全车距，避免追尾</li><li>右车道行驶，左车道超车用，不要长时间占用左车道</li><li>如遇故障不可在高速上停车行走，应尽快靠边开启双闪、打开引擎盖等待救援</li><li>错过出口不可倒车，应继续前行到下一个出口</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img223857.png"></p><p>夜间驾驶（Night Driving）</p><ul><li>不要超出车灯照射范围行驶（避免“盲驾”</li><li>开远光灯时<ul><li>遇对向来车提前500英尺改为近光</li><li>准备超车前300英尺也要切换为近光</li></ul></li></ul><p>弯道（Curves）</p><ul><li>弯前减速，不要急刹或过弯时踩刹车，否则易打滑或翻车</li><li>切勿越过道路中心线</li></ul><p>正面来车驶入你的车道（Head-on Approaches）</p><ul><li>立刻减速，向右侧避让，并鸣喇叭提醒</li></ul><p>打滑（Skidding）</p><ul><li>若车辆打滑：松开油门或刹车，<ins>顺着打滑方向轻打方向盘</ins>恢复控制，然后重新调整方向</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img224051.png"></p><p>驶出路面（Driving Off the Pavement）</p><ul><li>车辆驶出路缘，紧握方向盘，慢松油门并轻刹车</li><li>等安全后，确认后方无车再缓慢驶回路面</li><li>切勿猛打方向盘，以防偏到对向车道</li></ul><p>车辆起火（Fire）</p><ul><li>立刻停车，关闭发动机，远离车辆，拨打911</li></ul><p>掉入水中（Water Crashes）</p><ul><li>若车辆暂未沉没，迅速通过窗户逃生（车门通常打不开）</li><li>若车辆已沉入水中，移至后排空气口袋区，深呼吸后从后窗逃生</li></ul><p>一氧化碳中毒（Carbon Monoxide Poisoning）</p><ul><li>一氧化碳无色无味，症状像感冒：头痛、恶心、眩晕</li><li>不要在封闭车库中启动汽车</li></ul><p>高压电（Power Line）</p><ul><li>如果有电线落在车上，留在车内等救援</li><li>若有火灾风险需逃生：双脚跳车，保持身体不接触车和地面同时，之后用双脚跳或小步滑行50英尺远离车体</li></ul><p>加油安全（Explosive Fire Hazard）</p><ul><li>熄火加油，禁止吸烟</li><li>加油时请勿离开油枪</li></ul><hr><h4 id="设备故障时的应对措施"><a href="#设备故障时的应对措施" class="headerlink" title="设备故障时的应对措施"></a>设备故障时的应对措施</h4><p>轮胎爆胎（Blowouts）</p><ul><li>爆胎前会听到“砰砰”的声音</li><li>不要猛踩刹车</li><li>做法<ul><li>慢慢松开油门</li><li>双手紧握方向盘，保持控制</li><li>稳定方向后慢慢靠边停车</li><li>打开双闪灯</li><li>下车检查轮胎</li></ul></li></ul><p>轮胎或车轮脱落（Loss of Wheel or Tire）</p><ul><li>应对方式与爆胎一致：松油门、保持方向、慢慢停车</li></ul><p>转向失灵（Steering Failure）</p><ul><li>没法控制方向盘时<ul><li>松开油门</li><li>打开双闪灯</li><li>轻踩刹车（不能猛踩，避免打滑或原地旋转</li><li>不要关闭点火开关</li></ul></li></ul><p>刹车失灵（Brake Failure）</p><ul><li>踩刹车发现刹车踏板直接踩到底<ul><li>连续快速踩几下，试图重新建立刹车压力</li><li>如果无效，<strong>拉手刹（紧急&#x2F;驻车刹车）</strong>减速</li><li>同时，将挡位换到低速档辅助减速</li><li>小心控制方向，靠边停车</li></ul></li></ul><p>大灯失效（Headlight Failure）</p><ul><li>如果灯突然全灭<ul><li>尝试打开: 双闪灯、转向灯、停车灯</li><li>慢慢靠边停车</li><li>不要再行驶，等待修理或救援</li></ul></li></ul><p>油门卡住（Stuck Gas Pedal）</p><ul><li>油门无法松开时<ul><li>用脚勾住油门试图拉回来</li><li>如果没法解卡: 立即挂入空挡（N）、轻踩刹车减速、打双闪，靠边安全停车</li></ul></li></ul><p>视线受阻（Blocked Vision）</p><ul><li>如果突然视线模糊或完全遮挡<ul><li>摇下侧窗来观察外面</li><li>打开双闪，慢慢靠边停车</li><li>等视线恢复或问题排除再继续开车</li></ul></li></ul><hr><h4 id="攻击性驾驶"><a href="#攻击性驾驶" class="headerlink" title="攻击性驾驶"></a>攻击性驾驶</h4><p>攻击性驾驶是指一种可能危及他人或财产安全的驾驶方式，常见的行为包括</p><ul><li>超速驾驶</li><li>闯红灯、闯停车标志</li><li>贴车尾（尾随距离过近）</li><li>从路肩强行超车</li><li>强行插队、突然变道切入他人车道</li><li>故意急刹车报复后车</li><li>对其他司机做出侮辱性手势或面部表情</li><li>大声咆哮或辱骂</li><li>反复按喇叭</li><li>不停闪远光灯骚扰前车</li></ul><p>遇到攻击性驾驶者怎么办</p><ul><li>保持冷静，不要还击或回应对方行为</li><li>避免眼神接触，不要激怒对方</li><li>锁好车门窗</li><li>保持车距，避免被困在前车和攻击者之间</li><li>如果对方试图逼停你，尽量开往人多或安全的地方（如警察局、加油站）</li><li>不要低估对方的潜在威胁性，避免冲突升级</li></ul><hr><h4 id="不同类型道上遇到车辆抛锚或紧急状况时该如何自保"><a href="#不同类型道上遇到车辆抛锚或紧急状况时该如何自保" class="headerlink" title="不同类型道上遇到车辆抛锚或紧急状况时该如何自保"></a>不同类型道上遇到车辆抛锚或紧急状况时该如何自保</h4><p>在高容量道路（如高速、高架、主要干道）</p><ul><li>尽量驶入最右侧的应急车道或安全区域，远离正常车流</li><li>留在车内，并系好安全带</li><li>打开双闪灯（Hazard Lights）</li><li>拨打 911 求助</li><li>等待救援人员到来，不要贸然下车</li></ul><p>在低容量道路（如乡村公路、住宅区、次要道路）</p><ul><li>尽可能靠边停车，避开车流</li><li>如果安全，从远离来车方向一侧下车</li><li>离车后，站在人行道、护栏后方或田边安全处</li><li>如果无法安全下车，继续留在车内并系好安全带</li><li>打开双闪灯</li><li>拨打 911</li></ul><p>在 Illinois Tollway（收费公路）</p><ul><li>尽可能驶入最右侧路肩</li><li>留在车内，系好安全带</li><li>打开双闪灯</li><li>拨打 *999 或 911</li><li>候 Tollway 维护人员或紧急响应人员救援</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>TAG 工作总结</title>
      <link href="/posts/d1eea1ad.html"/>
      <url>/posts/d1eea1ad.html</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="密码错误" data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="78574d1df27a3b398e97025b2f9f837b6c1d14e1569f23018f1ac7281e69b12e">03c03690e5a2c7a44b2aa66e251c66b95173940c42de79c65734cf256d748a1f46d4edc41bf8a6c07bf99d5237d754ba8fef694fa8061ed5abd56befd5b172bf7aa9e02dbabf20b1ff75bdca3f4be84a954b0f8ef003469d7a6900a563b68009d2c34866a6a5935d4d1c036cd734ade8db7dcefba458b565085db502003ffecfffaabf2393c212ad061cb06b159743394d3617b881c8fdee5fddc5df985537a8a3e819156486926a158d55a31abfacb60e378384d53ed9e45cc5102b9cd419c113a35cf95362735a8c817967425eba16ac5e55f72c044a595aeccd332025c1561ec7fdecf8cc1b1b5ba9233aca3716948a3f8d98c4914a05fc3596708ed0e83aaf0916023a7b38d9182e9b59f129726f0c363e59de7ebb75d99131056cefd199294f67b7cfc02e51950d5e3e6b2d4903c549b622649e825d6707d47f89679209693afdf35fbd51aa21ff0329d452ebb87f07f0696f99ffd885faf302ba7b26c19bf3cc4a30e6bf6b1dc93cd5b0a68f5b11f6e2914ba44deb00e22b0866677124a35b2665ca6e2cac6976ea0b201cf2551896aa9b57ce301e16e9b2fc6a7b367e3260f1946957d70d0d941045d804e77ce18eaa12f2a75782b6549232126497dabf371347cea7c50051c44dc642e819cb74d35346bf6666afb177b5bdaa45b646a4e23c99e32f698e13350cb422518ed1454b43097c45d7da58f5b43cb0ea2fdd3cc663d4ce0be03c10725c6f7e1832961a638d6f7a985bb6130d2ed629af1daa4951e538ffc78931731722825cc7e7beb15a5a891cedca61ef89ff82230446930ab2870a2e903ec3129a3be702afe18b230aa96358ecd5bfa4c53b6fb0bef7b6cf0ff974437635d8d496eadf8f17ad49fc176861e816f842722eac571c897f2f7d5ee8bacec5e51d8fa1170a3752df68c78e60403e3702a5c4523697ef148fa9a9fb65b3a7c248ceae07930c6b49cc923c102edb61089b8ae370b6b7257a923ecc69b74e32c2fd4398026bee9a45f08e1c988d367848bb5d92e43c1ceebecd3cb285736154900979061620c776d62c6ee8dc9aea7620c25d584f3c54cf31c79bdcdc5c19c22820edc1565eedb48a783df8afda340e2047bb30fcc28e26ecb4efa3eeffb549131e41ede27de7a4edb713d7b35d8313689eb224e48581fa9e260636d5abcc9ce04da0c6daf8c07edd64da1f44ae9d33e19066687aceeb71588f2f490c1519008b2c2d0b58f56899548296e59c9b4c289c9662084c03c1d1d6b087d390af586fd4e979ad4bf66db7c5ad00c9f2ec86b1045ceb3660e1097be4384618545c0c2700fa7809dadc125ec848ec7dc37e15c296dcc36b8806bf10f164a7a6697f9aac0d6458aa012d2a01f5559ed2cf9e2cfaffa76283d9d36f2f29cc7895cba5b17192e6a4db2d973429296b370b723893dafaaa6ab72c7f5668f90392865b2257957bea7cdbdc96df0a2fb8534c1e7bbca891ccb454310419265d7ef3a3309e4ab24162850ff2a53abc405e6ec216f2ccec02e7059b3583e75ef178293f6208d451e44b21ee86e8afcc6f40290cb3e949db3857fff99ec0c160169501650b2ce3f350d39574533ef2ffcaa374a07671fdaeec3be0496159e037dad56e6f275dced1fff10e4d53f66ee3001c41eabfec3d86cdb9bb601fdd376d29e1c3db67b3c85c874d3d00363c2cf4896574a427499b74954d12f7da3ca55a1d4967</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-xray">      <input class="hbe hbe-input-field hbe-input-field-xray" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-xray" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-xray">密码</span>      </label>      <svg class="hbe hbe-graphic hbe-graphic-xray" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>        <path d="M0,2.5c0,0,298.666,0,399.333,0C448.336,2.5,513.994,13,597,13c77.327,0,135-10.5,200.999-10.5c95.996,0,402.001,0,402.001,0"></path>      </svg>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>hireEZ 工作总结</title>
      <link href="/posts/79e72cc1.html"/>
      <url>/posts/79e72cc1.html</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="密码错误" data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="62fb4248181382378ecf77221268a62beaaed1405152dc8bce9e5dc8f0e2d0ca">03c03690e5a2c7a44b2aa66e251c66b95173940c42de79c65734cf256d748a1f3c5f1ebb1b6e1ed78155da26973b1aeea8de5b916b35a11f47804a60fc3a26dadec394d226bcb265ffe40a3d42643dd4f382154869fe2dc2c64023f7d446dd58</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-xray">      <input class="hbe hbe-input-field hbe-input-field-xray" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-xray" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-xray">密码</span>      </label>      <svg class="hbe hbe-graphic hbe-graphic-xray" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>        <path d="M0,2.5c0,0,298.666,0,399.333,0C448.336,2.5,513.994,13,597,13c77.327,0,135-10.5,200.999-10.5c95.996,0,402.001,0,402.001,0"></path>      </svg>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>前端 101</title>
      <link href="/posts/7c522c36.html"/>
      <url>/posts/7c522c36.html</url>
      
        <content type="html"><![CDATA[<hr><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><h4 id="终端"><a href="#终端" class="headerlink" title="终端"></a>终端</h4><iframe width="100%" height="400px" src="https://stackblitz.com/edit/stackblitz-starters-nurriis6?embed=1&file=script.js&hideExplorer=1&hideNavigation=1&theme=dark&view=preview" frameborder="0" loading="lazy" allowtransparency="true" allowfullscreen="true"></iframe><iframe width="100%" height="400px" src="https://stackblitz.com/edit/stackblitz-starters-dudf15co?embed=1&file=script.js&hideExplorer=1&hideNavigation=1&theme=dark&view=preview" frameborder="0" loading="lazy" allowtransparency="true" allowfullscreen="true"></iframe><hr><h3 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h3><blockquote><p>请勿随意修改，谢谢</p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>WebGL 学习笔记</title>
      <link href="/posts/d58818f0.html"/>
      <url>/posts/d58818f0.html</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p><a href="https://webglfundamentals.org/">WebGL Fundamentals</a>: 适合初学者，包含详细的教程和示例代码</p></blockquote><h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><h4 id="什么是Shader"><a href="#什么是Shader" class="headerlink" title="什么是Shader"></a>什么是<code>Shader</code></h4><p><code>Shader</code>是运行在<code>GPU</code>上的一段程序，主要负责控制图形渲染管线中的一部分。主要类型</p><ul><li>顶点着色器 (<code>Vertex Shader</code>): 确定图形的每一个顶点的位置</li><li>片元着色器 (<code>Fragment Shader</code>): 渲染图形的每一个片元（像素）的颜色</li></ul><h4 id="Shader和其他技术"><a href="#Shader和其他技术" class="headerlink" title="Shader和其他技术"></a><code>Shader</code>和其他技术</h4><p><code>Shader</code>是前端图形技术中的重要一环，它与常见的图形技术如<code>CSS</code>、<code>SVG</code>、<code>Canvas2D</code>和<code>WebGL</code>都有着密切的关系，每一种技术都在不同层面提供了图形渲染的能力，但<code>Shader</code>的独特之处在于它直接操作<code>GPU</code>，能够实现高度复杂的视觉效果</p><ul><li><p><code>CSS</code>: <code>CSS</code>的主要功能是网页布局，但它也可以通过一些属性（如<code>animation</code>和<code>transform</code>）实现简单的动画效果。它的局限性在于无法很好地处理复杂的动态变化，尤其是像素级的精细操作</p></li><li><p><code>SVG</code>: <code>SVG</code>提供了矢量图形的能力，允许开发者通过路径（<code>path</code>标签）定义任意形状，并结合属性（如 <code>stroke-dasharray</code>和<code>stroke-dashoffset</code>）实现动画。相比<code>CSS</code>，<code>SVG</code>更适合处理复杂的几何图形。然而，它仍然难以实现动态粒子效果或像素级控制</p></li><li><p><code>Canvas2D</code>: <code>Canvas2D</code>提供了对每个像素的直接控制，开发者可以通过数学运算和随机函数实现动态效果，例如粒子拖尾动画。但它的设计初衷是处理<code>2D</code>图形，对<code>3D</code>图形的支持相对较弱</p></li><li><p><code>WebGL</code>: <code>WebGL</code>是在浏览器中渲染<code>3D</code>图形的标准，它通过“渲染管线”处理图形数据。<code>WebGL</code>的强大之处在于既可以处理<code>2D</code>图形，也可以实现<code>3D</code>场景。<code>Shader</code>是<code>WebGL</code>的核心组成部分，用于自定义渲染管线中的特定部分，提供开发者完全的渲染控制能力</p></li></ul><hr><h3 id="Shader基础知识"><a href="#Shader基础知识" class="headerlink" title="Shader基础知识"></a><code>Shader</code>基础知识</h3><h4 id="Shader编程语言选择"><a href="#Shader编程语言选择" class="headerlink" title="Shader编程语言选择"></a><code>Shader</code>编程语言选择</h4><p>目前主要的<code>Shader</code>编程语言有以下几种</p><ul><li><code>GLSL</code>: 主要用于<code>OpenGL</code>平台的图形<code>API</code></li><li><code>HLSL</code>: 由微软开发，主要用于<code>DirectX</code>平台的图形API</li><li><code>Cg</code>: 由<code>Nvidia</code>开发，可被编译为<code>GLSL</code>和<code>HLSL</code>，主要被用于<code>Unity</code>平台</li><li><code>WGSL</code>: <code>WebGPU</code>的专用语言，适用于未来的浏览器图形开发</li></ul><p>本学习笔记重点是<code>Web</code>环境中的<code>Shader</code>开发，并基于<code>WebGL</code>平台，选择<code>GLSL</code>作为主要的学习语言</p><h4 id="WebGL渲染管线流程"><a href="#WebGL渲染管线流程" class="headerlink" title="WebGL渲染管线流程"></a><code>WebGL</code>渲染管线流程</h4><p><code>WebGL</code>的渲染管线的核心流程（一个物体是如何被渲染到屏幕上的）主要包括以下几个步骤</p><ul><li>顶点着色器: 处理顶点数据（如位置、颜色、纹理坐标）</li><li>图元装配: 将顶点数据组合成图元（如点、线、三角形）</li><li>光栅化: 将图元转换为屏幕上的像素</li><li>片元着色器: 计算每个像素的颜色</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img0a729b8d1dae444c9799c7083aa84f65%7Etplv-k3u1fbpfcp-jj-mark_3024_0_0_0_q75.awebp"></p><blockquote><p>整个流程是: 在<code>JS</code>中提供顶点的数据（通常是<code>Float32Array</code>类型的数组，包含了顶点的位置等信息），将这些数据传递给顶点着色器，让它计算每个顶点的位置，然后<code>WebGL</code>将顶点装配成图元（如三角形），图元再被转换成屏幕上的空像素（光栅化），让片元着色器来计算每个像素的颜色并填充上去，最终将物体渲染到屏幕上</p></blockquote><ul><li>图元装配和光栅化是<code>WebGL</code>自带的操作，无法进行额外的定制，但<strong>顶点着色器和片元着色器则是完全可通过编程来定制化的</strong></li></ul><h4 id="Shader开发环境"><a href="#Shader开发环境" class="headerlink" title="Shader开发环境"></a><code>Shader</code>开发环境</h4><p>在线开发工具</p><ul><li><a href="https://www.shadertoy.com/">ShaderToy</a>: 一个实时运行和分享<code>Shader</code>的在线平台</li><li><a href="https://codesandbox.io/s/kokomi-js-starter-tjh29w?file=/src/app.ts">codesandbox</a>: 偏向工程化的<code>Template</code></li><li><code>jsfiddle</code>: <code>Fork</code>下面的<code>fiddle</code>然后编辑<code>JS</code> (当然也可以在<code>codepen</code>里写)</li></ul><iframe width="100%" height="400" src="//jsfiddle.net/HDL52/ftos1vp6/15/embedded/result/dark/" frameborder="0" loading="lazy" allowtransparency="true" allowfullscreen="true"></iframe><!-- - `stackblitz`: `Fork`下面的`blitz`然后编辑`JS`<iframe width="100%" height="400" src="https://stackblitz.com/edit/stackblitz-starters-7fggovzz?embed=1&file=script.js&hideExplorer=1&hideNavigation=1&theme=dark&view=preview" frameborder="0" loading="lazy" allowtransparency="true" allowfullscreen="true"></iframe> --><p>编辑器开发工具</p><ul><li><code>VSCode</code>: 安装以下插件 <code>Shader language support</code>, <code>Shader Toy</code>, <code>Live Preview</code>, <code>glsl-canvas</code></li></ul><h4 id="实现第一个Shader"><a href="#实现第一个Shader" class="headerlink" title="实现第一个Shader"></a>实现第一个<code>Shader</code></h4><p><code>GLSL</code>语言的<code>Shader</code>文件后缀名是<code>.glsl</code></p><ul><li>下面定义了一个<code>mainImage</code>函数，它不返回任何值，故返回类型为<code>void</code>。它接受<code>2</code>个参数，一个是<code>4</code>维的<code>fragColor</code>，代表输出的像素颜色。另一个是<code>2</code>维的<code>fragCoord</code>，代表输入的像素坐标</li></ul><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> mainImage(<span class="keyword">out</span> <span class="type">vec4</span> fragColor,<span class="keyword">in</span> <span class="type">vec2</span> fragCoord)&#123;</span><br><span class="line">    <span class="type">vec3</span> color = <span class="type">vec3</span>(<span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>); <span class="comment">// 定义红色</span></span><br><span class="line">    fragColor = <span class="type">vec4</span>(color, <span class="number">1.0</span>);     <span class="comment">// 输出红色</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>上面代码定义了一个名为<code>color</code>的<code>3</code>维变量，将它的值设置为红色，红色的<code>RGB</code>颜色值为<code>(255,0,0)</code>，在<code>GLSL</code>中，需要先将颜色原先的值进行归一化操作（除以<code>255</code>）后才能将它正确地输出，因此将红色的值归一化后就得到了<code>(1,0,0)</code>这个值，将它转换为<code>3</code>维变量<code>vec3(1.,0.,0.)</code>赋给<code>color</code>变量</p></li><li><p>最后给输出颜色<code>fragColor</code>赋值一个<code>4</code>维变量，前<code>3</code>维就是<code>color</code>这个颜色变量，最后一维是透明度，由于纯红色并不透明，直接将其设为<code>1</code>即可</p></li></ul><iframe width="100%" height="400" src="//jsfiddle.net/HDL52/8p2obeju/1/embedded/result/dark/" frameborder="0" loading="lazy" allowtransparency="true" allowfullscreen="true"></iframe><ul><li><p>当然也可以通过判断像素坐标范围，给不同区域填充不同的颜色</p></li><li><p>这里就要用到<code>fragCoord</code>变量，它代表了输入的像素坐标，有<code>2</code>个维度<code>xy</code>，它们的大小取决于画面本身的大小。假设画面当前的大小为<code>1536x864</code>，那么每一个像素的<code>fragCoord</code>的<code>x</code>坐标值将会分布在<code>(0,1536)</code>之间，<code>y</code>坐标值则分布在<code>(0,864)</code>之间</p></li><li><p>在当前的<code>Shader</code>开发环境内，还有个内置的变量<code>iResolution</code>，代表了画面整体的大小，使用它时一般会取它的<code>xy</code>维度</p></li></ul><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> mainImage(<span class="keyword">out</span> <span class="type">vec4</span> fragColor, <span class="keyword">in</span> <span class="type">vec2</span> fragCoord) &#123;</span><br><span class="line">    <span class="type">vec3</span> color1 = <span class="type">vec3</span>(<span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>); <span class="comment">// 红色</span></span><br><span class="line">    <span class="type">vec3</span> color2 = <span class="type">vec3</span>(<span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>); <span class="comment">// 绿色</span></span><br><span class="line">    <span class="type">vec3</span> color3 = <span class="type">vec3</span>(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>); <span class="comment">// 蓝色</span></span><br><span class="line">    <span class="type">vec3</span> color4 = <span class="type">vec3</span>(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>); <span class="comment">// 黄色</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fragCoord.x &lt; iResolution.x * <span class="number">0.25</span>) &#123;</span><br><span class="line">        fragColor = <span class="type">vec4</span>(color1, <span class="number">1.0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (fragCoord.x &lt; iResolution.x * <span class="number">0.5</span>) &#123;</span><br><span class="line">        fragColor = <span class="type">vec4</span>(color2, <span class="number">1.0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (fragCoord.x &lt; iResolution.x * <span class="number">0.75</span>) &#123;</span><br><span class="line">        fragColor = <span class="type">vec4</span>(color3, <span class="number">1.0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fragColor = <span class="type">vec4</span>(color4, <span class="number">1.0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>之所以能够显示出四种颜色，是因为<code>GPU</code>会对屏幕上的每一个像素点进行独立的并行计算</li></ul><iframe width="100%" height="400" src="//jsfiddle.net/HDL52/qtzxg7dj/1/embedded/result/dark/" frameborder="0" loading="lazy" allowtransparency="true" allowfullscreen="true"></iframe><hr><h3 id="GLSL基础知识"><a href="#GLSL基础知识" class="headerlink" title="GLSL基础知识"></a><code>GLSL</code>基础知识</h3><p><code>GLSL</code>是一种类似<code>C</code>的语言，用于控制<code>GPU</code>的渲染逻辑，如果有<code>C/C++</code>的基础会更容易理解，以下内容将逐步介绍<code>GLSL</code>的核心知识</p><h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><ul><li>一维变量（标量）: 比如<code>int</code>，<code>float</code>，<code>bool</code>。浮点型<code>float</code>可以说是<code>GLSL</code>里最常用的类型，浮点型变量必须要有小数点，不能省略，而且语句结尾一定要加一个分号<code>;</code></li></ul><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span> foo = <span class="number">1.0</span>; <span class="comment">// 浮点型</span></span><br><span class="line"><span class="type">int</span> bar = <span class="number">10</span>;    <span class="comment">// 整型</span></span><br><span class="line"><span class="type">bool</span> flag = <span class="literal">true</span>; <span class="comment">// 布尔型</span></span><br></pre></td></tr></table></figure><ul><li>向量变量: 向量类型支持<code>3</code>种维度，二维<code>vec2</code>、三维<code>vec3</code>和四维<code>vec4</code>，通过<code>.x</code>,<code>.y</code>,<code>.z</code>,<code>.w</code>（或<code>.r</code>,<code>.g</code>,<code>.b</code>,<code>.a</code>）访问。如果想对多维度变量进行取值或赋值操作，就要用到<code>.</code>符号，并且四个维度可以任意组合（称为<code>Swizzling</code>）</li></ul><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="type">vec2</span> a = <span class="type">vec2</span>(<span class="number">1.0</span>, <span class="number">0.0</span>);  <span class="comment">// 二维向量</span></span><br><span class="line"></span><br><span class="line"><span class="type">vec3</span> b = <span class="type">vec3</span>(<span class="number">1.0</span>, <span class="number">0.5</span>, <span class="number">0.0</span>);  <span class="comment">// 三维向量</span></span><br><span class="line"><span class="type">vec2</span> d = b.xy; <span class="comment">// 提取 b 的 x 和 y 分量，构成二维向量 d (1.0, 0.5)</span></span><br><span class="line">d.y = <span class="number">2.0</span>; <span class="comment">// 修改 d 的 y 分量为 2.0</span></span><br><span class="line"></span><br><span class="line"><span class="type">vec4</span> c = <span class="type">vec4</span>(<span class="number">1.0</span>, <span class="number">0.5</span>, <span class="number">0.0</span>, <span class="number">1.0</span>); <span class="comment">// 四维向量</span></span><br><span class="line"><span class="type">vec3</span> e = c.yxy; <span class="comment">// 重组 c 的分量，形成一个新的三维向量 (0.5, 1.0, 0.5)</span></span><br><span class="line">e.zx = <span class="type">vec2</span>(<span class="number">1.0</span>); <span class="comment">// 修改 e 的 z 和 x 分量为 1.0</span></span><br></pre></td></tr></table></figure><ul><li>矩阵变量: 矩阵用于线性变换，<code>mat2</code>类型代表了一个大小是<code>2x2</code>的矩阵，<code>mat3</code>类型则代表了一个<code>3x3</code>的矩阵、<code>mat4</code>类型是<code>4x4</code>的矩阵</li></ul><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="type">mat2</span> m1 = <span class="type">mat2</span>(<span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>);  <span class="comment">// 2x2 矩阵</span></span><br><span class="line"><span class="type">mat3</span> m2 = <span class="type">mat3</span>(<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">2.0</span>, <span class="number">1.0</span>); <span class="comment">// 3x3 矩阵</span></span><br></pre></td></tr></table></figure><ul><li>结构体: 如果想把多个变量捆绑到一个变量上，可以使用结构体<code>struct</code></li></ul><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">struct Ray &#123;</span><br><span class="line">    <span class="type">vec3</span> ro;  <span class="comment">// 起点</span></span><br><span class="line">    <span class="type">vec3</span> rd;  <span class="comment">// 方向</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Ray ray = Ray(<span class="type">vec3</span>(<span class="number">0.0</span>), <span class="type">vec3</span>(<span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>));</span><br></pre></td></tr></table></figure><h4 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h4><ul><li><p><code>GLSL</code>支持常见的算术运算符和赋值运算符</p></li><li><p>要注意的一点是，运算一定要保证维度的匹配，比如不能将一个<code>vec2</code>的变量与一个<code>vec3</code>的变量相加，要加的话得选取<code>vec3</code>变量的其中<code>2</code>个维度，转成<code>vec2</code>变量才能与另一个<code>vec2</code>变量相加</p></li><li><p>也有一种特殊的情况，当<strong>一个向量和一个标量进行运算</strong>时，<code>GLSL</code>会将标量广播（<code>broadcast</code>）到向量的每一个分量上</p></li></ul><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="type">vec2</span> v = <span class="type">vec2</span>(<span class="number">1.0</span>, <span class="number">2.0</span>);</span><br><span class="line">v += <span class="number">1.0</span>; <span class="comment">// v 的值为 vec2(2.0, 3.0)</span></span><br></pre></td></tr></table></figure><h4 id="控制流"><a href="#控制流" class="headerlink" title="控制流"></a>控制流</h4><ul><li>和常规的编程语言一样，<code>GLSL</code>有基本的控制流结构</li></ul><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line">    <span class="comment">// 条件满足时执行</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 条件不满足时执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>这里要注意一点，<code>Shader</code>是针对整个屏幕的像素进行处理的，因此<code>if</code>的所有分支只要满足一定的条件，都会被执行。这是由于<code>GPU</code>的<strong>并行特性</strong>和<strong>像素级独立处理</strong>的工作方式</li></ul><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (fragCoord.x &lt; iResolution.x * <span class="number">0.25</span>)</span><br><span class="line">    fragColor = <span class="type">vec4</span>(<span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>); <span class="comment">// 红色</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (fragCoord.x &lt; iResolution.x * <span class="number">0.5</span>)</span><br><span class="line">    fragColor = <span class="type">vec4</span>(<span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>); <span class="comment">// 绿色</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    fragColor = <span class="type">vec4</span>(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>); <span class="comment">// 蓝色</span></span><br></pre></td></tr></table></figure><ul><li><code>GPU</code>会为屏幕上的每个像素单独运行一遍<code>Fragment Shader</code>代码，代码中的<code>if</code>条件根据每个像素的位置（<code>fragCoord.x</code>）来决定应该执行哪一段代码</li></ul><iframe width="100%" height="400" src="//jsfiddle.net/HDL52/0wrkqhm2/2/embedded/result/dark/" frameborder="0" loading="lazy" allowtransparency="true" allowfullscreen="true"></iframe><h4 id="变量限定符"><a href="#变量限定符" class="headerlink" title="变量限定符"></a>变量限定符</h4><p>变量限定符是用来描述变量的存储和使用方式的关键词</p><ul><li><code>GLSL</code>中常用的变量限定符有以下几种，<code>uniform</code>、<code>const</code>、<code>varying</code>、<code>attribute</code></li></ul><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="keyword">uniform</span> <span class="type">vec3</span> uColor; <span class="comment">// 定义统一的颜色变量</span></span><br><span class="line"><span class="keyword">varying</span> <span class="type">vec3</span> vColor; <span class="comment">// 顶点着色器向片元着色器传递的颜色 (旧版 GLSL)</span></span><br><span class="line"><span class="keyword">attribute</span> <span class="type">vec3</span> aPosition; <span class="comment">// 传递顶点位置 (旧版 GLSL)</span></span><br></pre></td></tr></table></figure><ul><li><code>uniform</code>: 全局变量，一旦定义后会同时存在于顶点着色器与片元着色器中，并且它在每一个顶点和片元上的值都是相同的，是一个“统一”的值</li><li><code>const</code>: 定义常量，它是无法被改变的一个值</li><li><code>iTime</code>: 表示<code>Shader</code>从开始到现在执行所经过的时间，用于创作动画效果</li><li><code>iResolution</code>: 表示<code>Shader</code>所在画布的大小，默认是占满整个屏幕</li><li><code>iMouse</code>: 表示用户鼠标当前所在的位置</li></ul><h4 id="宏定义"><a href="#宏定义" class="headerlink" title="宏定义"></a>宏定义</h4><p>宏（<code>macros</code>）是一种预处理指令，用于在编译时进行文本的替换，常用于定义常量、函数、条件编译等</p><ul><li>宏定义的格式是<code>#define 宏的名称 宏的值</code>，语句结尾没有分号。下面代码定义了一个名为<code>PI</code>的宏，<code>Shader</code>编译时会将所有的<code>PI</code>替换为<code>3.14159265359</code>这个值</li></ul><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="meta">#define PI 3.14159265359</span></span><br></pre></td></tr></table></figure><ul><li>宏也可以带有参数。下面代码定义了一个名为<code>add</code>的宏，接受<code>2</code>个参数<code>a</code>和<code>b</code>，对它们应用相加的运算，并且无需指定明确的类型，调用这个宏时只要参数的类型相匹配，就能正确执行宏定义的运算</li></ul><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="meta">#define add(a,b) a+b</span></span><br></pre></td></tr></table></figure><ul><li>宏也可以条件编译。下面代码会在<strong>编译时</strong>通过<code>#if</code>判断宏<code>USE_COLOR</code>的值是否为<code>1</code>，如果<code>USE_COLOR == 1</code>，代码会保留红色的定义，反之，代码会保留黑色的定义</li></ul><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="meta">#define USE_COLOR 1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#if USE_COLOR == 1</span></span><br><span class="line">    <span class="type">vec3</span> color = <span class="type">vec3</span>(<span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>);</span><br><span class="line"><span class="meta">#else</span></span><br><span class="line">    <span class="type">vec3</span> color = <span class="type">vec3</span>(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>);</span><br><span class="line"><span class="meta">#endif</span></span><br></pre></td></tr></table></figure><hr><h3 id="UV基础与核心概念"><a href="#UV基础与核心概念" class="headerlink" title="UV基础与核心概念"></a><code>UV</code>基础与核心概念</h3><h4 id="UV坐标"><a href="#UV坐标" class="headerlink" title="UV坐标"></a><code>UV</code>坐标</h4><ul><li><code>UV</code>坐标是一种将像素坐标归一化到<code>[0.0, 1.0]</code>范围的坐标系，其中<code>U</code>代表水平方向（<code>x</code>坐标），<code>V</code>代表垂直方向（<code>y</code>坐标）</li><li>在<code>Shader</code>编程中，<code>UV</code>坐标用于描述画布上的归一化像素位置，通常由片元着色器中的<code>fragCoord</code>和<code>iResolution</code>计算得出，下面是<strong>归一化公式</strong></li></ul><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> mainImage(<span class="keyword">out</span> <span class="type">vec4</span> fragColor, <span class="keyword">in</span> <span class="type">vec2</span> fragCoord) &#123;</span><br><span class="line">    <span class="type">vec2</span> uv = fragCoord / iResolution.xy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="UV坐标的分布特性"><a href="#UV坐标的分布特性" class="headerlink" title="UV坐标的分布特性"></a><code>UV</code>坐标的分布特性</h4><ul><li>先看下<code>x</code>坐标的分布情况</li></ul><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> mainImage(<span class="keyword">out</span> <span class="type">vec4</span> fragColor, <span class="keyword">in</span> <span class="type">vec2</span> fragCoord) &#123;</span><br><span class="line">    <span class="type">vec2</span> uv = fragCoord / iResolution.xy;</span><br><span class="line">    fragColor = <span class="type">vec4</span>(uv.x, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>现在默认颜色的第<code>3</code>个值是<code>0</code>，只看前<code>2</code>个值。可以看到<code>x</code>坐标从左边开始是黑色，值是<code>(0,0)</code>，到最右边是纯红色，值是<code>(1,0)</code>，而中间则是分布在<code>(0,1)</code>之间的值。从整体上看，得到了一个横向的渐变图案</li></ul><iframe width="100%" height="400" src="//jsfiddle.net/HDL52/q0wxagrm/1/embedded/result/dark/" frameborder="0" loading="lazy" allowtransparency="true" allowfullscreen="true"></iframe><ul><li>再看下<code>y</code>坐标的分布情况</li></ul><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> mainImage(<span class="keyword">out</span> <span class="type">vec4</span> fragColor, <span class="keyword">in</span> <span class="type">vec2</span> fragCoord) &#123;</span><br><span class="line">    <span class="type">vec2</span> uv = fragCoord / iResolution.xy;</span><br><span class="line">    fragColor = <span class="type">vec4</span>(<span class="number">0.0</span>, uv.y, <span class="number">0.0</span>, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>可以看到<code>y</code>坐标从底下开始是黑色，值是<code>(0,0)</code>，到最上面是纯绿色，值是<code>(0,1)</code>，而中间则是分布在<code>(0,1)</code>之间的值。从整体上看，得到了一个纵向的渐变图案</li></ul><iframe width="100%" height="400" src="//jsfiddle.net/HDL52/arktw6dy/14/embedded/result/dark/" frameborder="0" loading="lazy" allowtransparency="true" allowfullscreen="true"></iframe><ul><li>接下来同时输出<code>x</code>坐标和<code>y</code>坐标的分布</li></ul><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> mainImage(<span class="keyword">out</span> <span class="type">vec4</span> fragColor, <span class="keyword">in</span> <span class="type">vec2</span> fragCoord) &#123;</span><br><span class="line">    <span class="type">vec2</span> uv = fragCoord / iResolution.xy;</span><br><span class="line">    fragColor = <span class="type">vec4</span>(uv, <span class="number">0.0</span>, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>左下角原点是黑色，值是<code>(0,0)</code>，右下角是红色，值是<code>(1,0)</code>，左上角是绿色，值是<code>(0,1)</code>，右上角是黄色，值是<code>(1,1)</code>，中间的所有值在<code>(0,0)</code>到<code>(1,1)</code>这<code>2</code>个区间分布。从整体上看，得到了一个有多种颜色的渐变图案</li></ul><iframe width="100%" height="400" src="//jsfiddle.net/HDL52/beun0ztc/1/embedded/result/dark/" frameborder="0" loading="lazy" allowtransparency="true" allowfullscreen="true"></iframe><ul><li>上面就是所谓的<code>UV</code>坐标，它代表了图像（这里指画布）上所有像素的归一化后的坐标位置，其中<code>U</code>代表水平方向，<code>V</code>代表垂直方向</li></ul><h4 id="图形绘制-圆形"><a href="#图形绘制-圆形" class="headerlink" title="图形绘制 (圆形)"></a>图形绘制 (圆形)</h4><ul><li>先计算<code>UV</code>坐标上的点到原点的距离，然后根据这些距离的值来设定对应点的颜色</li><li>为了计算<code>UV</code>上点到原点的距离，可以用<code>GLSL</code>的内置函数<code>length</code>函数来实现</li></ul><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> mainImage(<span class="keyword">out</span> <span class="type">vec4</span> fragColor, <span class="keyword">in</span> <span class="type">vec2</span> fragCoord) &#123;</span><br><span class="line">    <span class="type">vec2</span> uv = fragCoord / iResolution.xy;</span><br><span class="line">    <span class="type">float</span> d = <span class="built_in">length</span>(uv);</span><br><span class="line">    fragColor = <span class="type">vec4</span>(<span class="type">vec3</span>(d), <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>左下角原点是黑色，值是<code>(0,0)</code>，从原点向右上方向辐射的径向渐变，上面每个点的值代表的就是该点到原点的距离，越靠近原点距离越小，越接近黑色，反之越远离原点距离越大，越接近白色</li></ul><iframe width="100%" height="400" src="//jsfiddle.net/HDL52/tphn4ge7/1/embedded/result/dark/" frameborder="0" loading="lazy" allowtransparency="true" allowfullscreen="true"></iframe><ul><li>目前图形的位置在左下角，把它挪到中间，将<code>UV</code>的坐标减去<code>0.5</code>，再整体乘上<code>2</code>，这一步被称为“<code>UV</code>的居中处理”</li></ul><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> mainImage(<span class="keyword">out</span> <span class="type">vec4</span> fragColor, <span class="keyword">in</span> <span class="type">vec2</span> fragCoord) &#123;</span><br><span class="line">    <span class="type">vec2</span> uv = fragCoord / iResolution.xy;</span><br><span class="line">    uv = (uv - <span class="number">0.5</span>) * <span class="number">2.0</span>;</span><br><span class="line">    fragColor = <span class="type">vec4</span>(uv, <span class="number">0.0</span>, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><iframe width="100%" height="400" src="//jsfiddle.net/HDL52/kc9tjwpq/2/embedded/result/dark/" frameborder="0" loading="lazy" allowtransparency="true" allowfullscreen="true"></iframe><ul><li>看下操作前后的对比图</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/imgb29b63a75cb74fb9abe31376184db120%7Etplv-k3u1fbpfcp-jj-mark_3024_0_0_0_q75.awebp"></p><ul><li><p>之前的坐标系原点是第一幅图左下角的<code>(0,0)</code>，通过整体减去<code>0.5</code>，将原点变成了<code>(-0.5,-0.5)</code>，也就是第二幅图左下角的那个点的位置，第一幅图的中点<code>(0.5,0.5)</code>就变成了第二幅图的中点<code>(0,0)</code>，然后，将坐标整体乘上<code>2</code>，将<code>0.5</code>变成了<code>1</code>，这样归一化后能方便后续的计算</p></li><li><p>理解<code>UV</code>的居中处理后，将<code>UV</code>坐标输出的代码注释掉，换回之前的距离代码</p></li></ul><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> mainImage(<span class="keyword">out</span> <span class="type">vec4</span> fragColor, <span class="keyword">in</span> <span class="type">vec2</span> fragCoord) &#123;</span><br><span class="line">    <span class="type">vec2</span> uv = fragCoord / iResolution.xy;</span><br><span class="line">    uv = (uv - <span class="number">0.5</span>) * <span class="number">2.0</span>;</span><br><span class="line">    <span class="type">float</span> d = <span class="built_in">length</span>(uv);</span><br><span class="line">    fragColor = <span class="type">vec4</span>(<span class="type">vec3</span>(d), <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>可以看到图形确实被挪到了中间。然而，图形目前的形状是一个椭圆，这是为什么呢？因为<code>UV</code>坐标的值并不会自动地适应画布的比例，导致了图形被拉伸这一现象</li></ul><iframe width="100%" height="400" src="//jsfiddle.net/HDL52/rcogqxp6/2/embedded/result/dark/" frameborder="0" loading="lazy" allowtransparency="true" allowfullscreen="true"></iframe><ul><li>为了修正这一点，需要计算画布的比例，将画布长除以画布宽就能算出，再将<code>UV</code>的<code>x</code>坐标与比例相乘即可</li></ul><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> mainImage(<span class="keyword">out</span> <span class="type">vec4</span> fragColor, <span class="keyword">in</span> <span class="type">vec2</span> fragCoord) &#123;</span><br><span class="line">    <span class="type">vec2</span> uv = fragCoord / iResolution.xy;</span><br><span class="line">    uv = (uv - <span class="number">0.5</span>) * <span class="number">2.0</span>;</span><br><span class="line">    uv.x *= iResolution.x / iResolution.y;</span><br><span class="line">    <span class="type">float</span> d = <span class="built_in">length</span>(uv);</span><br><span class="line">    fragColor = <span class="type">vec4</span>(<span class="type">vec3</span>(d), <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>上面代码得到了一个完整的圆形径向渐变。中点的值是<code>(0,0)</code>，颜色是纯黑色，然而从中点开始向四周辐射的那些区域，它们的值都大于<code>0</code>，不是纯黑色。我们的目标，是要把其中的一片区域也变成纯黑色，也就是说要把分布在这片区域上面的点的值也变成<code>0</code></li></ul><iframe width="100%" height="400" src="//jsfiddle.net/HDL52/hnfbt9a7/2/embedded/result/dark/" frameborder="0" loading="lazy" allowtransparency="true" allowfullscreen="true"></iframe><ul><li>在<code>Shader</code>中，值的显示范围只会是<code>[0,1]</code>之间，小于<code>0</code>的负数实际显示的值还是<code>0</code>（黑色），大于<code>1</code>的数实际显示的值还是<code>1</code>（白色）。可以利用这一点，给距离<code>d</code>减去一个值（这里取<code>0.5</code>），制造出一片负数的区域，而这片区域就是黑色</li></ul><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> mainImage(<span class="keyword">out</span> <span class="type">vec4</span> fragColor, <span class="keyword">in</span> <span class="type">vec2</span> fragCoord) &#123;</span><br><span class="line">    <span class="type">vec2</span> uv = fragCoord / iResolution.xy;</span><br><span class="line">    uv = (uv - <span class="number">0.5</span>) * <span class="number">2.0</span>;</span><br><span class="line">    uv.x *= iResolution.x / iResolution.y;</span><br><span class="line">    <span class="type">float</span> d = <span class="built_in">length</span>(uv);</span><br><span class="line">    d -= <span class="number">0.5</span>;</span><br><span class="line">    fragColor = <span class="type">vec4</span>(<span class="type">vec3</span>(d), <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>中间确实出现了纯黑色的圆形区域，然后只需把周围的渐变给消除，就能得到真正的圆形</li></ul><iframe width="100%" height="400" src="//jsfiddle.net/HDL52/waL3k1b0/1/embedded/result/dark/" frameborder="0" loading="lazy" allowtransparency="true" allowfullscreen="true"></iframe><ul><li>先定义一个中间变量<code>c</code>，用<code>if</code>语句来判断距离<code>d</code>的大小，如果大于<code>0</code>，代表的是除了中间纯黑区域外的渐变区域，将它们的值设为<code>1</code>（白色）。反之，就代表的是中间的纯黑区域，将它们的值设为<code>0</code>（黑色），最后将中间变量直接作为结果输出即可</li></ul><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> mainImage(<span class="keyword">out</span> <span class="type">vec4</span> fragColor, <span class="keyword">in</span> <span class="type">vec2</span> fragCoord) &#123;</span><br><span class="line">    <span class="type">vec2</span> uv = fragCoord / iResolution.xy;</span><br><span class="line">    uv = (uv - <span class="number">0.5</span>) * <span class="number">2.0</span>;</span><br><span class="line">    uv.x *= iResolution.x / iResolution.y;</span><br><span class="line">    <span class="type">float</span> d = <span class="built_in">length</span>(uv);</span><br><span class="line">    d -= <span class="number">0.5</span>;</span><br><span class="line">    <span class="type">float</span> c = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">if</span> (d &gt; <span class="number">0.0</span>) &#123;</span><br><span class="line">        c = <span class="number">1.0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        c = <span class="number">0.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    fragColor = <span class="type">vec4</span>(<span class="type">vec3</span>(c), <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><iframe width="100%" height="400" src="//jsfiddle.net/HDL52/1hgnwc0r/5/embedded/result/dark/" frameborder="0" loading="lazy" allowtransparency="true" allowfullscreen="true"></iframe><ul><li>在<code>Shader</code>的编写中，应当尽量避免使用<code>if</code>语句。因为<code>GPU</code>是并行处理结果的，而<code>if</code>语句会让处理器进行分支切换这一操作，处理多个分支会降低并行处理的性能。</li><li>可以用<code>GLSL</code>其中的一个内置函数来优化掉<code>if</code>语句，这个内置函数是 <code>step</code>函数，也被称作“阶梯函数”，是因为它的图像是阶梯的形状</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/imgc6098091ff504641b13f961d79233dd7%7Etplv-k3u1fbpfcp-jj-mark_3024_0_0_0_q75.awebp"></p><ul><li>它的代码表示形式是这样的</li></ul><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="built_in">step</span>(edge, x)</span><br></pre></td></tr></table></figure><ul><li>它接受<code>2</code>个参数，边界值<code>edge</code>和目标值<code>x</code>，如果目标值<code>x</code>大于边界值<code>edge</code>，则返回<code>1</code>，反之返回<code>0</code></li></ul><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> mainImage(<span class="keyword">out</span> <span class="type">vec4</span> fragColor, <span class="keyword">in</span> <span class="type">vec2</span> fragCoord) &#123;</span><br><span class="line">    <span class="type">vec2</span> uv = fragCoord / iResolution.xy;</span><br><span class="line">    uv = (uv - <span class="number">0.5</span>) * <span class="number">2.0</span>;</span><br><span class="line">    uv.x *= iResolution.x / iResolution.y;</span><br><span class="line">    <span class="type">float</span> d = <span class="built_in">length</span>(uv);</span><br><span class="line">    d -= <span class="number">0.5</span>;</span><br><span class="line">    <span class="type">float</span> c = <span class="built_in">step</span>(<span class="number">0.0</span>, d);</span><br><span class="line">    fragColor = <span class="type">vec4</span>(<span class="type">vec3</span>(c), <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><iframe width="100%" height="400" src="//jsfiddle.net/HDL52/2nz7p9bg/1/embedded/result/dark/" frameborder="0" loading="lazy" allowtransparency="true" allowfullscreen="true"></iframe><ul><li>尽管圆形是画出来了，但仔细一看，就会发现图形的周围有锯齿，比较影响美观，要消除它们</li><li>再来认识一个<code>GLSL</code>的内置函数——<code>smoothstep</code>函数，它也被称作“平滑阶梯函数”，是因为它的函数图像是一个平滑过的阶梯的形状</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img4553d587e19e41af8e44b5639e4b09df%7Etplv-k3u1fbpfcp-jj-mark_3024_0_0_0_q75.awebp"></p><ul><li>它的代码表示形式是这样的</li></ul><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="built_in">smoothstep</span>(edge1, edge2, x)</span><br></pre></td></tr></table></figure><ul><li>它的边界值比<code>step</code>函数要多一个，可以将它的边界值定为<code>edge1</code>和<code>edge2</code>。如果目标值<code>x</code>小于边界值<code>edge1</code>，则返回<code>0</code>。如果目标值<code>x</code>大于边界值<code>edge2</code>，则返回<code>1</code>。如果目标值<code>x</code>在<code>2</code>个边界值之间，则返回从<code>0</code>到<code>1</code>平滑过渡的值</li><li>把之前代码里的<code>step</code>函数的语句注释掉，改成用<code>smoothstep</code>函数来实现，再将第<code>2</code>个边界值设定为一个比<code>0</code>稍微大一点的值。这里取了<code>0.02</code></li></ul><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> mainImage(<span class="keyword">out</span> <span class="type">vec4</span> fragColor, <span class="keyword">in</span> <span class="type">vec2</span> fragCoord) &#123;</span><br><span class="line">    <span class="type">vec2</span> uv = fragCoord / iResolution.xy;</span><br><span class="line">    uv = (uv - <span class="number">0.5</span>) * <span class="number">2.0</span>;</span><br><span class="line">    uv.x *= iResolution.x / iResolution.y;</span><br><span class="line">    <span class="type">float</span> d = <span class="built_in">length</span>(uv);</span><br><span class="line">    d -= <span class="number">0.5</span>;</span><br><span class="line">    <span class="type">float</span> c = <span class="built_in">smoothstep</span>(<span class="number">0.0</span>, <span class="number">0.02</span>, d);</span><br><span class="line">    fragColor = <span class="type">vec4</span>(<span class="type">vec3</span>(c), <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>这样，就得到了一个边缘是平滑的，没有锯齿的圆形</li></ul><iframe width="100%" height="400" src="//jsfiddle.net/HDL52/q3vu9nb7/1/embedded/result/dark/" frameborder="0" loading="lazy" allowtransparency="true" allowfullscreen="true"></iframe><h4 id="图形效果"><a href="#图形效果" class="headerlink" title="图形效果"></a>图形效果</h4><ul><li>尽管<code>Shader</code>的绘图步骤确实要比传统的绘图方式要繁琐一点，但是也带来了很多意想不到的可能性，比方说，它能实现一些特殊的图形效果</li></ul><h5 id="模糊效果"><a href="#模糊效果" class="headerlink" title="模糊效果"></a><p style='font-size: 14px'>模糊效果</p></h5><ul><li>上面代码用到了<code>smoothstep</code>函数来绘制圆形，它的第二个参数用的是一个很小的值<code>0.02</code>，尝试把这个值改大一点，比如<code>0.2</code></li></ul><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> mainImage(<span class="keyword">out</span> <span class="type">vec4</span> fragColor, <span class="keyword">in</span> <span class="type">vec2</span> fragCoord) &#123;</span><br><span class="line">    <span class="type">vec2</span> uv = fragCoord / iResolution.xy;</span><br><span class="line">    uv = (uv - <span class="number">0.5</span>) * <span class="number">2.0</span>;</span><br><span class="line">    uv.x *= iResolution.x / iResolution.y;</span><br><span class="line">    <span class="type">float</span> d = <span class="built_in">length</span>(uv);</span><br><span class="line">    d -= <span class="number">0.5</span>;</span><br><span class="line">    <span class="type">float</span> c = <span class="built_in">smoothstep</span>(<span class="number">0.0</span>, <span class="number">0.2</span>, d);</span><br><span class="line">    fragColor = <span class="type">vec4</span>(<span class="type">vec3</span>(c), <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>随着渐变区域的扩大，圆形的边缘变得模糊了起来，这是因为两个边界值的差变大了，渐变的区域也就随着变大了，这样就营造出了一种模糊的效果</li></ul><iframe width="100%" height="400" src="//jsfiddle.net/HDL52/298mf57z/1/embedded/result/dark/" frameborder="0" loading="lazy" allowtransparency="true" allowfullscreen="true"></iframe><h5 id="发光效果"><a href="#发光效果" class="headerlink" title="发光效果"></a><p style='font-size: 14px'>发光效果</p></h5><ul><li>这里不用<code>smoothstep</code>函数来绘制图形，取距离<code>d</code>的倒数，并且乘上一个比较小的值</li></ul><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> mainImage(<span class="keyword">out</span> <span class="type">vec4</span> fragColor, <span class="keyword">in</span> <span class="type">vec2</span> fragCoord) &#123;</span><br><span class="line">    <span class="type">vec2</span> uv = fragCoord / iResolution.xy;</span><br><span class="line">    uv = (uv - <span class="number">0.5</span>) * <span class="number">2.0</span>;</span><br><span class="line">    uv.x *= iResolution.x / iResolution.y;</span><br><span class="line">    <span class="type">float</span> d = <span class="built_in">length</span>(uv);</span><br><span class="line">    <span class="type">float</span> c = <span class="number">0.25</span> / d;</span><br><span class="line">    fragColor = <span class="type">vec4</span>(<span class="type">vec3</span>(c), <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><iframe width="100%" height="400" src="//jsfiddle.net/HDL52/20jhyq9m/2/embedded/result/dark/" frameborder="0" loading="lazy" allowtransparency="true" allowfullscreen="true"></iframe><ul><li>画面上出现了一个美丽的光球，它是怎么形成的呢</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img59b48526299f48f4b5e1b3adac92425b%7Etplv-k3u1fbpfcp-jj-mark_3024_0_0_0_q75.awebp"></p><ul><li><p>这是个反比例函数的图像，目前输入值范围是<code>(0.,1.)</code>，在这段范围内，输入值位于<code>(0.,.25)</code>时，输出值都大于<code>1</code>，<code>Shader</code>中比<code>1</code>大的值输出的还是白色，因此能看到中间的白色圆形部分。输入值位于<code>(.25,1.)</code>时，输出的值开始变成了比<code>1</code>小的值，而且是逐渐变化的，因此会产生一种渐变的效果</p></li><li><p>目前光的辐射范围太大了，要稍微缩小一些</p></li><li><p>再来认识一个新的内置函数——<code>pow</code>函数，它用于计算数字的指数幂，比如<code>pow(4.,3.)</code>，返回的值就是<code>4</code>的<code>3</code>次方——<code>64</code>，也就是说，<code>pow</code>这个函数能让数值指数般地增长</p></li></ul><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> mainImage(<span class="keyword">out</span> <span class="type">vec4</span> fragColor, <span class="keyword">in</span> <span class="type">vec2</span> fragCoord) &#123;</span><br><span class="line">    <span class="type">vec2</span> uv = fragCoord / iResolution.xy;</span><br><span class="line">    uv = (uv - <span class="number">0.5</span>) * <span class="number">2.0</span>;</span><br><span class="line">    uv.x *= iResolution.x / iResolution.y;</span><br><span class="line">    <span class="type">float</span> d = <span class="built_in">length</span>(uv);</span><br><span class="line">    <span class="type">float</span> c = <span class="number">0.25</span> / d;</span><br><span class="line">    c = <span class="built_in">pow</span>(c, <span class="number">1.6</span>);</span><br><span class="line">    fragColor = <span class="type">vec4</span>(<span class="type">vec3</span>(c), <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><iframe width="100%" height="400" src="//jsfiddle.net/HDL52/yf4gt3L5/1/embedded/result/dark/" frameborder="0" loading="lazy" allowtransparency="true" allowfullscreen="true"></iframe><ul><li>为了理解这一步，依旧来看图</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img88ddcf2cfc24418aa5c405b7e57b2110%7Etplv-k3u1fbpfcp-jj-mark_3024_0_0_0_q75.awebp"></p><ul><li>函数图像比之前要往下“躺”了一些，输出值总体变小了，这样光的辐射也稍微缩小了一点</li></ul><h4 id="SDF函数"><a href="#SDF函数" class="headerlink" title="SDF函数"></a><code>SDF</code>函数</h4><ul><li>圆形是众多几何图形中的其中一种，既然已经通过上面的方式将它画了出来，那肯定也能用类似的手段来把其他图形给画出来</li><li>绘制圆形时，在调用<code>smoothstep</code>函数之前做了如下的操作</li></ul><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span> d = <span class="built_in">length</span>(uv);</span><br><span class="line">d -= <span class="number">0.5</span>;</span><br></pre></td></tr></table></figure><ul><li>其实，可以把这些操作抽象成一个函数，叫<code>sdCircle</code></li></ul><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span> sdCircle(<span class="type">vec2</span> p, <span class="type">float</span> r) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">length</span>(p) - r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> mainImage(<span class="keyword">out</span> <span class="type">vec4</span> fragColor, <span class="keyword">in</span> <span class="type">vec2</span> fragCoord) &#123;</span><br><span class="line">    <span class="type">vec2</span> uv = fragCoord / iResolution.xy;</span><br><span class="line">    <span class="type">float</span> d = sdCircle(uv, <span class="number">0.5</span>);</span><br><span class="line">    fragColor = <span class="type">vec4</span>(<span class="type">vec3</span>(d), <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>尽管这个函数的调用结果跟之前写的一模一样，但它有一个特殊的含义，它是一个<code>SDF</code>函数</li><li><code>SDF</code>函数（<code>Signed Distance Function</code>），中文译作“符号距离函数”，它用于描述这么一个函数，它将空间里的一个位置作为输入，并返回该位置到给定形状的距离，它的前面还有个“符号”，是因为在形状外的距离为正数（“<code>+</code>”号），在形状内的距离为负数（“<code>-</code>”号），边界处的值恰好为<code>0</code></li><li>下图是圆形<code>SDF</code>函数的可视化图，可以更形象地理解它的意义</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img302511b0a5124c039ddcc8b15bd2a764%7Etplv-k3u1fbpfcp-jj-mark_3024_0_0_0_q75.awebp"></p><blockquote><p>图形学大咖<code>Inigo Quilez</code>（后文简称<code>iq</code>）的博客上有篇文章把常用的<code>2D</code>图形的<code>SDF</code>函数都列了出来，如果有需要可以<a href="https://iquilezles.org/articles/distfunctions2d/">随时查阅</a></p></blockquote><ul><li>知道<code>SDF</code>函数的概念后，绘制其他图形将会变得非常轻松，比如想要画一个长方形，那么只需找到长方形的<code>SDF</code>函数（<code>sdBox</code>），调用它获取距离，再用<code>step</code>或<code>smoothstep</code>函数勾画出图形即可</li></ul><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span> sdBox(<span class="keyword">in</span> <span class="type">vec2</span> p, <span class="keyword">in</span> <span class="type">vec2</span> b)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">vec2</span> d = <span class="built_in">abs</span>(p) - b;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">length</span>(<span class="built_in">max</span>(d, <span class="type">vec2</span>(<span class="number">0.</span>))) + <span class="built_in">min</span>(<span class="built_in">max</span>(d.x, d.y), <span class="number">0.</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> mainImage(<span class="keyword">out</span> <span class="type">vec4</span> fragColor, <span class="keyword">in</span> <span class="type">vec2</span> fragCoord)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">vec2</span> uv = fragCoord / iResolution.xy;</span><br><span class="line">    uv = (uv - <span class="type">vec2</span>(<span class="number">0.5</span>)) * <span class="number">2.0</span>;</span><br><span class="line">    uv.x *= iResolution.x / iResolution.y;</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> d = sdBox(uv, <span class="type">vec2</span>(<span class="number">0.6</span>, <span class="number">0.3</span>));</span><br><span class="line">    <span class="type">float</span> c = <span class="built_in">smoothstep</span>(<span class="number">0.0</span>, <span class="number">0.02</span>, d);</span><br><span class="line">    fragColor = <span class="type">vec4</span>(<span class="type">vec3</span>(c), <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>上面的代码画出了一个半尺寸长为<code>0.6</code>、宽为<code>0.3</code>（实际长为<code>1.2</code>、宽为<code>0.6</code>）的长方形</li><li>在<code>SDF</code>中，矩形的<code>sdBox</code>函数定义的<code>b</code>参数（如<code>vec2(0.6, 0.3)</code>）表示的是矩形的半尺寸。这是因为<code>SDF</code>函数设计时，通常使用半尺寸来计算方便</li></ul><iframe width="100%" height="400" src="//jsfiddle.net/HDL52/f6Lwb17t/2/embedded/result/dark/" frameborder="0" loading="lazy" allowtransparency="true" allowfullscreen="true"></iframe><h4 id="UV变换"><a href="#UV变换" class="headerlink" title="UV变换"></a><code>UV</code>变换</h4><ul><li>基于已经画好的这个长方形，来学习一些基本的<code>UV</code>变换操作</li></ul><h5 id="平移"><a href="#平移" class="headerlink" title="平移"></a><p style='font-size: 14px'>平移</p></h5><ul><li>先尝试给<code>UV</code>的<code>x</code>或<code>y</code>坐标加上想移动的值</li></ul><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span> sdBox(<span class="keyword">in</span> <span class="type">vec2</span> p, <span class="keyword">in</span> <span class="type">vec2</span> b)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">vec2</span> d = <span class="built_in">abs</span>(p) - b;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">length</span>(<span class="built_in">max</span>(d, <span class="type">vec2</span>(<span class="number">0.0</span>))) + <span class="built_in">min</span>(<span class="built_in">max</span>(d.x, d.y), <span class="number">0.0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> mainImage(<span class="keyword">out</span> <span class="type">vec4</span> fragColor, <span class="keyword">in</span> <span class="type">vec2</span> fragCoord)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">vec2</span> uv = fragCoord / iResolution.xy;</span><br><span class="line">    uv = (uv - <span class="type">vec2</span>(<span class="number">0.5</span>)) * <span class="number">2.0</span>;</span><br><span class="line">    uv.x *= iResolution.x / iResolution.y;</span><br><span class="line">    uv.x += <span class="number">0.2</span>;</span><br><span class="line">    uv.y += <span class="number">0.4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> d = sdBox(uv, <span class="type">vec2</span>(<span class="number">0.6</span>, <span class="number">0.3</span>));</span><br><span class="line">    <span class="type">float</span> c = <span class="built_in">smoothstep</span>(<span class="number">0.0</span>, <span class="number">0.02</span>, d);</span><br><span class="line">    fragColor = <span class="type">vec4</span>(<span class="type">vec3</span>(c), <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><iframe width="100%" height="400" src="//jsfiddle.net/HDL52/b2Lmw09n/1/embedded/result/dark/" frameborder="0" loading="lazy" allowtransparency="true" allowfullscreen="true"></iframe><ul><li>明明是给坐标加上了值，为什么图形的坐标并未朝右上移动，而是朝相反的左下方向移动了呢</li></ul><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> mainImage(<span class="keyword">out</span> <span class="type">vec4</span> fragColor, <span class="keyword">in</span> <span class="type">vec2</span> fragCoord)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">vec2</span> uv = fragCoord / iResolution.xy;</span><br><span class="line">    uv = (uv - <span class="type">vec2</span>(<span class="number">0.5</span>)) * <span class="number">2.0</span>;</span><br><span class="line">    uv.x *= iResolution.x / iResolution.y;</span><br><span class="line">    uv.x += <span class="number">0.2</span>;</span><br><span class="line">    uv.y += <span class="number">0.4</span>;</span><br><span class="line">    fragColor = <span class="type">vec4</span>(uv, <span class="number">0.0</span>, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img57f5a49e288c4afa9bbd2e9cf103fba6%7Etplv-k3u1fbpfcp-jj-mark_3024_0_0_0_q75.awebp"></p><ul><li>之前位于中间的原点值是<code>(0,0)</code>，现在则变成了<code>(0.2,0.4)</code>，上一个<code>(0,0)</code>移动到了当前中间点的左下方，<code>SDF</code>函数输入的坐标值的原点值是<code>(0,0)</code>，正好对应左下方的那个点，因此图形才会整体往左下方移动</li><li>为了确定<code>SDF</code>图形位置的变化，要看目前<code>(0,0)</code>这个点的位置变化。如果要平移符合正方向的移动（右上方），把之前的加法操作改成与其相反的减法操作即可</li></ul><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span> sdBox(<span class="keyword">in</span> <span class="type">vec2</span> p, <span class="keyword">in</span> <span class="type">vec2</span> b)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">vec2</span> d = <span class="built_in">abs</span>(p) - b;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">length</span>(<span class="built_in">max</span>(d, <span class="type">vec2</span>(<span class="number">0.0</span>))) + <span class="built_in">min</span>(<span class="built_in">max</span>(d.x, d.y), <span class="number">0.0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> mainImage(<span class="keyword">out</span> <span class="type">vec4</span> fragColor, <span class="keyword">in</span> <span class="type">vec2</span> fragCoord)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">vec2</span> uv = fragCoord / iResolution.xy;</span><br><span class="line">    uv = (uv - <span class="type">vec2</span>(<span class="number">0.5</span>)) * <span class="number">2.0</span>;</span><br><span class="line">    uv.x *= iResolution.x / iResolution.y;</span><br><span class="line">    uv -= <span class="type">vec2</span>(<span class="number">0.2</span>, <span class="number">0.4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> d = sdBox(uv, <span class="type">vec2</span>(<span class="number">0.6</span>, <span class="number">0.3</span>));</span><br><span class="line">    <span class="type">float</span> c = <span class="built_in">smoothstep</span>(<span class="number">0.0</span>, <span class="number">0.02</span>, d);</span><br><span class="line">    fragColor = <span class="type">vec4</span>(<span class="type">vec3</span>(c), <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><iframe width="100%" height="400" src="//jsfiddle.net/HDL52/94f6p7zd/2/embedded/result/dark/" frameborder="0" loading="lazy" allowtransparency="true" allowfullscreen="true"></iframe><h5 id="缩放"><a href="#缩放" class="headerlink" title="缩放"></a><p style='font-size: 14px'>缩放</p></h5><ul><li>先尝试给<code>UV</code>的<code>x</code>或<code>y</code>坐标乘上想缩放的值</li></ul><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span> sdBox(<span class="keyword">in</span> <span class="type">vec2</span> p, <span class="keyword">in</span> <span class="type">vec2</span> b)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">vec2</span> d = <span class="built_in">abs</span>(p) - b;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">length</span>(<span class="built_in">max</span>(d, <span class="type">vec2</span>(<span class="number">0.0</span>))) + <span class="built_in">min</span>(<span class="built_in">max</span>(d.x, d.y), <span class="number">0.0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> mainImage(<span class="keyword">out</span> <span class="type">vec4</span> fragColor, <span class="keyword">in</span> <span class="type">vec2</span> fragCoord)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">vec2</span> uv = fragCoord / iResolution.xy;</span><br><span class="line">    uv = (uv - <span class="type">vec2</span>(<span class="number">0.5</span>)) * <span class="number">2.0</span>;</span><br><span class="line">    uv.x *= iResolution.x / iResolution.y;</span><br><span class="line">    uv *= <span class="type">vec2</span>(<span class="number">2.0</span>, <span class="number">2.0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> d = sdBox(uv, <span class="type">vec2</span>(<span class="number">0.6</span>, <span class="number">0.3</span>));</span><br><span class="line">    <span class="type">float</span> c = <span class="built_in">smoothstep</span>(<span class="number">0.0</span>, <span class="number">0.02</span>, d);</span><br><span class="line">    fragColor = <span class="type">vec4</span>(<span class="type">vec3</span>(c), <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><iframe width="100%" height="400" src="//jsfiddle.net/HDL52/3o56r9kp/1/embedded/result/dark/" frameborder="0" loading="lazy" allowtransparency="true" allowfullscreen="true"></iframe><ul><li>果不其然，图形并非扩大，而是缩小了相应的倍数</li><li>当坐标范围从<code>[-1.0, 1.0]</code>扩大到<code>[-2.0, 2.0]</code>时，矩形的顶点坐标虽然变大了（例如从<code>0.6</code>变成<code>1.2</code>），但由于画布的整体范围也变大了，矩形在整个画布中的相对比例缩小了。因此，矩形看起来变小了。简单来说，矩形的“绝对大小”没有改变，但它在画布中的“相对大小”变小了</li><li>同样地，如果要符合正方向的缩放（扩大），把之前的乘法操作改成与其相反的除法操作即可</li></ul><h5 id="翻转"><a href="#翻转" class="headerlink" title="翻转"></a><p style='font-size: 14px'>翻转</p></h5><hr><h3 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h3><blockquote></blockquote>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WebGL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GO 学习笔记</title>
      <link href="/posts/558bc4fb.html"/>
      <url>/posts/558bc4fb.html</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p>参考网站: <a href="https://wiki.eryajf.net/go-learn/">https://wiki.eryajf.net/go-learn/</a></p></blockquote><h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><h4 id="什么是Go语言"><a href="#什么是Go语言" class="headerlink" title="什么是Go语言"></a>什么是<code>Go</code>语言</h4><p><code>Go</code>是由<code>Google</code>开发的一种开源编程语言，设计初衷是让开发者可以快速构建高效的现代应用。<code>Go</code>结合了静态语言的性能和动态语言的开发效率，<ins>特别适合开发高并发的后端服务</ins></p><h4 id="Go命令"><a href="#Go命令" class="headerlink" title="Go命令"></a><code>Go</code>命令</h4><blockquote><p><a href="https://docs.kilvn.com/go_command_tutorial/0.0.html">https://docs.kilvn.com/go_command_tutorial/0.0.html</a> (这一块得靠实践)</p></blockquote><table><thead><tr><th>命令</th><th>功能描述</th></tr></thead><tbody><tr><td><code>build</code></td><td>编译代码生成可执行文件</td></tr><tr><td><code>run</code></td><td>编译并立即运行代码</td></tr><tr><td><code>fmt</code></td><td>格式化代码，确保统一的编码风格</td></tr><tr><td><code>test</code></td><td>执行单元测试</td></tr><tr><td><code>get</code></td><td>下载和管理依赖包</td></tr><tr><td><code>version</code></td><td>查看 Go 的版本</td></tr></tbody></table><h4 id="包的概念"><a href="#包的概念" class="headerlink" title="包的概念"></a>包的概念</h4><p><code>Go</code>是一个以<ins>包</ins>为基础的语言</p><ul><li>把相同功能的代码放到一个目录，称之为包</li><li>包可以被其他包引用</li><li><code>main</code>包是用来生成可执行文件的，每个程序有且只有一个<code>main</code>包</li><li>包的主要作用是提高代码的可复用性</li></ul><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1) Go 语言以包作为管理单位</span></span><br><span class="line"><span class="comment">// 2) 每个文件必须先声明包</span></span><br><span class="line"><span class="comment">// 3) 程序必须有一个 main 包（重要）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main <span class="comment">// 声明当前文件属于 main 包</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Go 语言以双斜杠作为单行注释的标识</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这是块注释</span></span><br><span class="line"><span class="comment">可以多行注释</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 引入 fmt 包，用于格式化输出</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 入口函数，有且只有一个</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123; <span class="comment">// 左括号必须与函数名同行，否则会报错</span></span><br><span class="line"><span class="comment">// 打印 “hello go” 到屏幕，Println() 会自动换行</span></span><br><span class="line"><span class="comment">// 调用 Println 函数时，需要导入 fmt 包</span></span><br><span class="line">fmt.Println(<span class="string">&quot;hello go&quot;</span>) <span class="comment">// 注意：Go 语言语句结尾没有分号</span></span><br><span class="line">fmt.Println(<span class="string">&quot;hello haha&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="变量的声明"><a href="#变量的声明" class="headerlink" title="变量的声明"></a>变量的声明</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span> <span class="comment">// 导入包，未使用会报错</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 1. 声明变量但不赋值，默认为零值</span></span><br><span class="line"><span class="keyword">var</span> a <span class="type">int</span></span><br><span class="line">fmt.Println(<span class="string">&quot;a =&quot;</span>, a) <span class="comment">// 输出：a = 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 变量赋值后再使用</span></span><br><span class="line">a = <span class="number">10</span></span><br><span class="line">fmt.Println(<span class="string">&quot;a =&quot;</span>, a) <span class="comment">// 输出：a = 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 声明并初始化变量</span></span><br><span class="line"><span class="keyword">var</span> b <span class="type">int</span> = <span class="number">10</span></span><br><span class="line">b = <span class="number">20</span> <span class="comment">// 可重新赋值</span></span><br><span class="line">fmt.Println(<span class="string">&quot;b =&quot;</span>, b) <span class="comment">// 输出：b = 20</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 同时声明多个变量（用逗号隔开）</span></span><br><span class="line"><span class="keyword">var</span> x, y <span class="type">int</span></span><br><span class="line">x, y = <span class="number">1</span>, <span class="number">2</span></span><br><span class="line">fmt.Println(<span class="string">&quot;x =&quot;</span>, x, <span class="string">&quot;, y =&quot;</span>, y) <span class="comment">// 输出：x = 1, y = 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. 自动推导类型（推荐）</span></span><br><span class="line">c := <span class="number">30</span> <span class="comment">// 根据赋值的类型推导变量类型</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;c type is %T\n&quot;</span>, c) <span class="comment">// 输出：c type is int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Println和Printf"><a href="#Println和Printf" class="headerlink" title="Println和Printf"></a><code>Println</code>和<code>Printf</code></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Println</span><br><span class="line">  按段输出内容，每段用空格分隔</span><br><span class="line">  自动在内容后添加换行符</span><br><span class="line"></span><br><span class="line">Printf</span><br><span class="line">  格式化输出内容，通过格式占位符插入变量值</span><br><span class="line">  不会自动换行，需要显式添加 \n</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 使用 Println 输出</span></span><br><span class="line">a := <span class="number">10</span></span><br><span class="line">fmt.Println(<span class="string">&quot;a =&quot;</span>, a) <span class="comment">// 输出：a = 10（自动换行）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 Printf 格式化输出</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;a = %d\n&quot;</span>, a) <span class="comment">// 输出：a = 10\n（精确控制格式）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 多个变量输出</span></span><br><span class="line">b := <span class="number">20</span></span><br><span class="line">c := <span class="number">30</span></span><br><span class="line">fmt.Println(<span class="string">&quot;a =&quot;</span>, a, <span class="string">&quot;, b =&quot;</span>, b, <span class="string">&quot;, c =&quot;</span>, c) <span class="comment">// 输出：a = 10 , b = 20 , c = 30（每段用空格分隔）</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;a = %d, b = %d, c = %d\n&quot;</span>, a, b, c) <span class="comment">// 输出：a = 10, b = 20, c = 30\n</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="多重赋值与匿名变量"><a href="#多重赋值与匿名变量" class="headerlink" title="多重赋值与匿名变量"></a>多重赋值与匿名变量</h4><hr><h3 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h3><blockquote><p>参考网站: <a href="https://wiki.eryajf.net/go-learn/">https://wiki.eryajf.net/go-learn/</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS 原型链</title>
      <link href="/posts/13fe9182.html"/>
      <url>/posts/13fe9182.html</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p>参考文章: <a href="https://juejin.cn/post/7007416743215759373">https://juejin.cn/post/7007416743215759373</a></p></blockquote><h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><h4 id="prototype和-proto"><a href="#prototype和-proto" class="headerlink" title="prototype和__proto__"></a><code>prototype</code>和<code>__proto__</code></h4><h5 id="两者是什么"><a href="#两者是什么" class="headerlink" title="两者是什么"></a><p style='font-size: 14px'>两者是什么</p></h5><ul><li><code>prototype</code>: 显式原型<ul><li>是构造函数的一个属性, 用于定义实例共享的方法和属性</li><li>它指向原型对象，该对象上的属性和方法会被实例继承</li></ul></li><li><code>__proto__</code>: 隐式原型<ul><li>是每个对象都有的内部属性</li><li>它指向创建该对象的构造函数的<code>prototype</code>，用于建立原型链</li></ul></li></ul><h5 id="两者的关系"><a href="#两者的关系" class="headerlink" title="两者的关系"></a><p style='font-size: 14px'>两者的关系</p></h5><ul><li>构造函数的<code>prototype</code>和其实例的<code>__proto__</code>指向同一个地方，这个地方叫做原型对象</li><li>原型对象是实现继承的核心</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, age</span>) &#123; <span class="comment">// 构造函数</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person1 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;小明&#x27;</span>, <span class="number">20</span>); <span class="comment">// 构造函数的实例</span></span><br><span class="line"><span class="keyword">const</span> person2 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;小红&#x27;</span>, <span class="number">30</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span> === person1.<span class="property">__proto__</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span> === person2.<span class="property">__proto__</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h5 id="什么是构造函数"><a href="#什么是构造函数" class="headerlink" title="什么是构造函数"></a><p style='font-size: 14px'>什么是构造函数</p></h5><ul><li>可构造函数是可以用<code>new</code>操作符调用的函数，用于创建对象</li><li>箭头函数不能作为构造函数</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, age</span>) &#123; <span class="comment">// 这个就是构造函数</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person1 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;小明&#x27;</span>, <span class="number">20</span>) <span class="comment">// 这个是Person构造函数的实例</span></span><br><span class="line"><span class="keyword">const</span> person2 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;小红&#x27;</span>, <span class="number">30</span>) <span class="comment">// 这个也是Person构造函数的实例</span></span><br></pre></td></tr></table></figure><h5 id="验证prototype和-proto-的关系"><a href="#验证prototype和-proto-的关系" class="headerlink" title="验证prototype和__proto__的关系"></a><p style='font-size: 14px'>验证<code>prototype</code>和<code>__proto__</code>的关系</p></h5><ul><li>构造函数的<code>prototype</code>定义实例可以继承的方法</li><li>实例的<code>__proto__</code>指向构造函数的<code>prototype</code></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123; <span class="comment">// 在原型对象上定义方法</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person1 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;小明&#x27;</span>, <span class="number">20</span>);</span><br><span class="line"><span class="keyword">const</span> person2 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;小红&#x27;</span>, <span class="number">30</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 验证 prototype 和 __proto__</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>); <span class="comment">// &#123; sayName: [Function] &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person1.<span class="property">__proto__</span>); <span class="comment">// &#123; sayName: [Function] &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span> === person1.<span class="property">__proto__</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span> === person2.<span class="property">__proto__</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用原型方法</span></span><br><span class="line">person1.<span class="title function_">sayName</span>(); <span class="comment">// 小明</span></span><br><span class="line">person2.<span class="title function_">sayName</span>(); <span class="comment">// 小红</span></span><br></pre></td></tr></table></figure><h4 id="构造函数与对象的关系"><a href="#构造函数与对象的关系" class="headerlink" title="构造函数与对象的关系"></a>构造函数与对象的关系</h4><h5 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a><p style='font-size: 14px'>构造函数</p></h5><ul><li>构造函数本质上是函数，用来创建对象。定义构造函数有以下几种常见方式</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn1</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`我是<span class="subst">$&#123;name&#125;</span>, 我今年<span class="subst">$&#123;age&#125;</span>岁`</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">fn1</span>(<span class="string">&#x27;abc&#x27;</span>, <span class="number">10</span>); <span class="comment">// 输出：我是abc, 我今年10岁</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数表达式</span></span><br><span class="line"><span class="keyword">const</span> fn2 = <span class="keyword">function</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`我是<span class="subst">$&#123;name&#125;</span>, 我今年<span class="subst">$&#123;age&#125;</span>岁`</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title function_">fn2</span>(<span class="string">&#x27;abc&#x27;</span>, <span class="number">10</span>); <span class="comment">// 输出：我是abc, 我今年10岁</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 箭头函数</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">arrowFn</span> = (<span class="params">name, age</span>) =&gt; &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`我是<span class="subst">$&#123;name&#125;</span>, 我今年<span class="subst">$&#123;age&#125;</span>岁`</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title function_">arrowFn</span>(<span class="string">&#x27;abc&#x27;</span>, <span class="number">10</span>); <span class="comment">// 输出：我是abc, 我今年10岁</span></span><br></pre></td></tr></table></figure><h5 id="构造函数的本质"><a href="#构造函数的本质" class="headerlink" title="构造函数的本质"></a><p style='font-size: 14px'>构造函数的本质</p></h5><ul><li>所有函数的本质都是由<code>Function</code>构造函数创建的</li><li>上述三种写法等同于以下代码</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fn1 = <span class="keyword">new</span> <span class="title class_">Function</span>(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;age&#x27;</span>, <span class="string">&#x27;console.log(`我是$&#123;name&#125;, 我今年$&#123;age&#125;岁`)&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> fn2 = <span class="keyword">new</span> <span class="title class_">Function</span>(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;age&#x27;</span>, <span class="string">&#x27;console.log(`我是$&#123;name&#125;, 我今年$&#123;age&#125;岁`)&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> arrowFn = <span class="keyword">new</span> <span class="title class_">Function</span>(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;age&#x27;</span>, <span class="string">&#x27;console.log(`我是$&#123;name&#125;, 我今年$&#123;age&#125;岁`)&#x27;</span>);</span><br></pre></td></tr></table></figure><h5 id="构造函数与原型的关系"><a href="#构造函数与原型的关系" class="headerlink" title="构造函数与原型的关系"></a><p style='font-size: 14px'>构造函数与原型的关系</p></h5><ul><li>每个构造函数的<code>prototype</code>和其实例的<code>__proto__</code>都指向同一个原型对象</li><li>同时，所有函数本身都是<code>Function</code>构造函数的实例</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn1</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`我是<span class="subst">$&#123;name&#125;</span>, 我今年<span class="subst">$&#123;age&#125;</span>岁`</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> fn2 = <span class="keyword">function</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`我是<span class="subst">$&#123;name&#125;</span>, 我今年<span class="subst">$&#123;age&#125;</span>岁`</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">arrowFn</span> = (<span class="params">name, age</span>) =&gt; &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`我是<span class="subst">$&#123;name&#125;</span>, 我今年<span class="subst">$&#123;age&#125;</span>岁`</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span> === fn1.<span class="property">__proto__</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span> === fn2.<span class="property">__proto__</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span> === arrowFn.<span class="property">__proto__</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h5 id="创建对象的方式"><a href="#创建对象的方式" class="headerlink" title="创建对象的方式"></a><p style='font-size: 14px'>创建对象的方式</p></h5><p>在开发中，创建对象有以下几种方式</p><ul><li>构造函数创建对象: 使用<code>new</code>调用构造函数创建对象</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> person1 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;abc&#x27;</span>, <span class="number">10</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person1); <span class="comment">// 输出：Person &#123; name: &#x27;abc&#x27;, age: 10 &#125;</span></span><br></pre></td></tr></table></figure><ul><li>字面量创建对象</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person2 = &#123; <span class="attr">name</span>: <span class="string">&#x27;abc&#x27;</span>, <span class="attr">age</span>: <span class="number">10</span> &#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person2); <span class="comment">// 输出：&#123; name: &#x27;abc&#x27;, age: 10 &#125;</span></span><br></pre></td></tr></table></figure><ul><li><code>new Object</code>创建对象</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person3 = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">person3.<span class="property">name</span> = <span class="string">&#x27;abc&#x27;</span>;</span><br><span class="line">person3.<span class="property">age</span> = <span class="number">10</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person3); <span class="comment">// 输出：&#123; name: &#x27;abc&#x27;, age: 10 &#125;</span></span><br></pre></td></tr></table></figure><ul><li><code>Object.create</code>创建对象: 创建一个具有指定原型的空对象</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person4 = <span class="title class_">Object</span>.<span class="title function_">create</span>(&#123;&#125;);</span><br><span class="line">person4.<span class="property">name</span> = <span class="string">&#x27;abc&#x27;</span>;</span><br><span class="line">person4.<span class="property">age</span> = <span class="number">10</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person4); <span class="comment">// 输出：&#123; name: &#x27;abc&#x27;, age: 10 &#125;</span></span><br></pre></td></tr></table></figure><h5 id="字面量与new-Object的关系"><a href="#字面量与new-Object的关系" class="headerlink" title="字面量与new Object的关系"></a><p style='font-size: 14px'>字面量与<code>new Object</code>的关系</p></h5><ul><li>字面量和<code>new Object</code>创建的对象本质上都是<code>Object</code>构造函数的实例</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person2 = &#123; <span class="attr">name</span>: <span class="string">&#x27;abc&#x27;</span>, <span class="attr">age</span>: <span class="number">10</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> person3 = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">person3.<span class="property">name</span> = <span class="string">&#x27;abc&#x27;</span>;</span><br><span class="line">person3.<span class="property">age</span> = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span> === person2.<span class="property">__proto__</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span> === person3.<span class="property">__proto__</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h5 id="Function和Object的关系"><a href="#Function和Object的关系" class="headerlink" title="Function和Object的关系"></a><p style='font-size: 14px'><code>Function</code>和<code>Object</code>的关系</p></h5><ul><li>函数是<code>Function</code>构造函数的实例</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span> === fn.<span class="property">__proto__</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><ul><li>对象是<code>Object</code>构造函数的实例</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span> === obj.<span class="property">__proto__</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><ul><li>特殊关系<ul><li><code>Object</code>是一个函数，因此它是<code>Function</code>的实例</li><li><code>Function</code>本身也是一个函数，因此它是自己的实例</li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span> === <span class="title class_">Object</span>.<span class="property">__proto__</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span> === <span class="title class_">Function</span>.<span class="property">__proto__</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><hr><h3 id="深入解析"><a href="#深入解析" class="headerlink" title="深入解析"></a>深入解析</h3><h4 id="原型链的起点与终点"><a href="#原型链的起点与终点" class="headerlink" title="原型链的起点与终点"></a>原型链的起点与终点</h4><h5 id="原型的本质"><a href="#原型的本质" class="headerlink" title="原型的本质"></a><p style='font-size: 14px'>原型的本质</p></h5><ul><li><code>Person.prototype</code>是构造函数<code>Person</code>的原型对象</li><li><code>Function.prototype</code>是构造函数<code>Function</code>的原型对象</li><li>所有的原型对象都是对象，因此本质上它们是通过<code>new Object()</code>创建的</li></ul><h5 id="原型链上的关系"><a href="#原型链上的关系" class="headerlink" title="原型链上的关系"></a><p style='font-size: 14px'>原型链上的关系</p></h5><ul><li><code>Person.prototype</code>和<code>Function.prototype</code>都是<code>Object</code>构造函数的实例</li><li>因此，它们的<code>__proto__</code>都指向<code>Object.prototype</code></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">__proto__</span> === <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">__proto__</span> === <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h5 id="什么是原型链"><a href="#什么是原型链" class="headerlink" title="什么是原型链"></a><p style='font-size: 14px'>什么是原型链</p></h5><ul><li>原型链是通过<code>__proto__</code>属性连接起来的对象链</li><li>当访问一个对象的属性时，如果该对象没有这个属性，会通过<code>__proto__</code>向上查找，直到<code>null</code>为止</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img0a4b669cc49c4fd39905b0e22113d66e%7Etplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp"></p><h5 id="原型链的终点"><a href="#原型链的终点" class="headerlink" title="原型链的终点"></a><p style='font-size: 14px'>原型链的终点</p></h5><ul><li>原型链的终点是<code>null</code>，这是<code>JavaScript</code>中的对象链的终止点</li><li>任何对象的<code>__proto__</code>最终都会指向<code>Object.prototype</code>，而<code>Object.prototype.__proto__ === null</code></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img61a5a0bce57948988f29fc1bedb75382%7Etplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp"></p><h4 id="原型链的实际应用（继承与查找）"><a href="#原型链的实际应用（继承与查找）" class="headerlink" title="原型链的实际应用（继承与查找）"></a>原型链的实际应用（继承与查找）</h4><h5 id="原型继承的机制"><a href="#原型继承的机制" class="headerlink" title="原型继承的机制"></a><p style='font-size: 14px'>原型继承的机制</p></h5><ul><li>原型继承允许实例对象使用构造函数原型对象上的方法或属性</li><li>实例对象会通过<code>__proto__</code>链接到构造函数的<code>prototype</code>，实现属性和方法的继承</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name</span>) &#123; <span class="comment">// 构造函数</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name; <span class="comment">// 实例属性</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123; <span class="comment">// 定义在原型对象上的方法</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;abc&#x27;</span>); <span class="comment">// 实例化对象</span></span><br><span class="line">person.<span class="title function_">sayName</span>(); <span class="comment">// 输出：abc</span></span><br></pre></td></tr></table></figure><ul><li><code>person</code>实例对象的<code>__proto__</code>指向<code>Person.prototype</code></li><li>调用<code>person.sayName()</code>时，<code>JavaScript</code>引擎会通过<code>__proto__</code>查找到原型对象上的<code>sayName</code>方法</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img6888b0f41bd047938f1f7f287b3e3f34%7Etplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp"></p><h5 id="属性查找规则"><a href="#属性查找规则" class="headerlink" title="属性查找规则"></a><p style='font-size: 14px'>属性查找规则</p></h5><ul><li>优先查找实例对象本身的属性</li><li>如果实例对象中没有该属性，会沿着原型链向上查找，直到<code>null</code></li><li>如果在原型链中也未找到，返回<code>undefined</code></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Animal</span>(<span class="params">type</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">type</span> = type;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Animal</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayType</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">type</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> dog = <span class="keyword">new</span> <span class="title class_">Animal</span>(<span class="string">&#x27;dog&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(dog.<span class="property">type</span>); <span class="comment">// 输出：dog</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(dog.<span class="title function_">hasOwnProperty</span>(<span class="string">&#x27;type&#x27;</span>)); <span class="comment">// true（实例自身属性）</span></span><br><span class="line">dog.<span class="title function_">sayType</span>(); <span class="comment">// 输出：dog</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(dog.<span class="property">__proto__</span>.<span class="title function_">hasOwnProperty</span>(<span class="string">&#x27;sayType&#x27;</span>)); <span class="comment">// true（原型上的方法）</span></span><br></pre></td></tr></table></figure><hr><h3 id="高级特性"><a href="#高级特性" class="headerlink" title="高级特性"></a>高级特性</h3><h4 id="instanceof的机制"><a href="#instanceof的机制" class="headerlink" title="instanceof的机制"></a><code>instanceof</code>的机制</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">A <span class="keyword">instanceof</span> B</span><br></pre></td></tr></table></figure><ul><li>判断<code>B.prototype</code>是否在对象<code>A</code>的原型链上</li><li><code>instanceof</code>通过检查<code>A.__proto__</code>是否等于<code>B.prototype</code>或者沿着原型链向上查找直到<code>null</code>，来判断结果</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name</span>) &#123; <span class="comment">// 构造函数</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;abc&#x27;</span>); <span class="comment">// 实例</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span> <span class="keyword">instanceof</span> <span class="title class_">Function</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span> <span class="keyword">instanceof</span> <span class="title class_">Object</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person <span class="keyword">instanceof</span> <span class="title class_">Person</span>);  <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person <span class="keyword">instanceof</span> <span class="title class_">Object</span>);  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><ul><li><p><code>Person instanceof Function</code></p><ul><li>构造函数<code>Person</code>是函数，函数是<code>Function</code>的实例</li><li><code>Function.prototype === Person.__proto__</code></li></ul></li><li><p><code>Person instanceof Object</code></p><ul><li>所有对象最终继承自<code>Object</code>，包括函数</li><li><code>Object.prototype === Function.prototype.__proto__</code></li></ul></li><li><p><code>person instanceof Person</code></p><ul><li><code>person.__proto__ === Person.prototype</code>，因此返回<code>true</code></li></ul></li><li><p><code>person instanceof Object</code></p><ul><li><code>person</code>的原型链最终指向<code>Object.prototype</code>，因此返回<code>true</code></li></ul></li></ul><p>自定义实现<code>instanceof</code></p><ul><li>以下是<code>instanceof</code>的核心逻辑，用递归实现</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">myInstanceof</span>(<span class="params">A, B</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> proto = A.<span class="property">__proto__</span>;</span><br><span class="line">  <span class="keyword">while</span> (proto) &#123;</span><br><span class="line">    <span class="keyword">if</span> (proto === B.<span class="property"><span class="keyword">prototype</span></span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    proto = proto.<span class="property">__proto__</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">myInstanceof</span>(person, <span class="title class_">Person</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">myInstanceof</span>(person, <span class="title class_">Object</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">myInstanceof</span>(person, <span class="title class_">Function</span>)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h4 id="constructor的作用"><a href="#constructor的作用" class="headerlink" title="constructor的作用"></a><code>constructor</code>的作用</h4><p><code>constructor</code>是每个对象的一个属性，指向创建该对象的构造函数</p><ul><li><code>prototype</code>与<code>constructor</code>的互指关系<ul><li>构造函数的<code>prototype</code>上有一个<code>constructor</code>属性，指向该构造函数本身</li><li><code>Fn.prototype.constructor === Fn</code></li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Fn</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Fn</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> === <span class="title class_">Fn</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><ul><li>实例的<code>constructor</code>属性<ul><li>实例对象通过<code>__proto__</code>继承<code>prototype</code>，因此可以访问<code>constructor</code></li><li><code>instance.constructor === Fn</code></li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> instance = <span class="keyword">new</span> <span class="title class_">Fn</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(instance.<span class="property">constructor</span> === <span class="title class_">Fn</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><hr><h3 id="原型链练习"><a href="#原型链练习" class="headerlink" title="原型链练习"></a>原型链练习</h3><h4 id="原型链练习-1"><a href="#原型链练习-1" class="headerlink" title="原型链练习#1"></a>原型链练习<code>#1</code></h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> F = <span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">a</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">b</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;b&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f = <span class="keyword">new</span> <span class="title function_">F</span>();</span><br><span class="line"></span><br><span class="line">f.<span class="title function_">a</span>(); <span class="comment">// ?</span></span><br><span class="line">f.<span class="title function_">b</span>(); <span class="comment">// ?</span></span><br><span class="line"></span><br><span class="line">F.<span class="title function_">a</span>(); <span class="comment">// ?</span></span><br><span class="line">F.<span class="title function_">b</span>(); <span class="comment">// ?</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">f.<span class="title function_">a</span>(); <span class="comment">// 输出 &#x27;a&#x27;</span></span><br><span class="line">f.<span class="title function_">b</span>(); <span class="comment">// 报错：f.b is not a function</span></span><br><span class="line"></span><br><span class="line">F.<span class="title function_">a</span>(); <span class="comment">// 输出 &#x27;a&#x27;</span></span><br><span class="line">F.<span class="title function_">b</span>(); <span class="comment">// 输出 &#x27;b&#x27;</span></span><br></pre></td></tr></table></figure><h5 id="解析"><a href="#解析" class="headerlink" title="解析"></a><p style='font-size: 14px'>解析</p></h5><p><code>f.a()</code></p><ul><li><code>f</code>是<code>F</code>的实例，而<code>F</code>是通过构造函数创建的</li><li><code>f</code>的原型链如下</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">f.<span class="property">__proto__</span> === F.<span class="property"><span class="keyword">prototype</span></span></span><br><span class="line">F.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">__proto__</span> === <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">a</span>() 定义了方法</span><br></pre></td></tr></table></figure><ul><li>因此，<code>f</code>可以通过原型链访问<code>Object.prototype.a</code>，输出<code>&#39;a&#39;</code></li></ul><p><code>f.b()</code></p><ul><li><code>f</code>的原型链中没有定义<code>b</code>方法</li><li><code>b</code>是定义在<code>Function.prototype</code>上的，而<code>f</code>并不是函数，因此无法访问<code>Function.prototype.b</code></li><li>结果: 报错<code>f.b is not a function</code></li></ul><p><code>F.a()</code></p><ul><li><code>F</code>是函数，函数是<code>Function</code>构造函数的实例</li><li><code>F</code>的原型链如下</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">F.<span class="property">__proto__</span> === <span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span></span><br><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">__proto__</span> === <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span></span><br></pre></td></tr></table></figure><ul><li>因此，<code>F</code>可以通过原型链访问到<code>Object.prototype.a</code>，输出<code>&#39;a&#39;</code></li></ul><p><code>F.b()</code></p><ul><li><code>F</code>是函数，<code>b</code>方法定义在<code>Function.prototype</code>上</li><li>因为<code>F.__proto__ === Function.prototype</code>，所以<code>F</code>可以直接访问到<code>b</code>方法</li><li>结果: 输出<code>&#39;b&#39;</code></li></ul><h5 id="原型链示意图"><a href="#原型链示意图" class="headerlink" title="原型链示意图"></a><p style='font-size: 14px'>原型链示意图</p></h5><ul><li><code>f</code>的原型链</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">f.<span class="property">__proto__</span> → F.<span class="property"><span class="keyword">prototype</span></span> → <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span> → <span class="literal">null</span></span><br></pre></td></tr></table></figure><ul><li><code>F</code>的原型链</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">F.<span class="property">__proto__</span> → <span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span> → <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span> → <span class="literal">null</span></span><br></pre></td></tr></table></figure><hr><h4 id="原型链练习-2"><a href="#原型链练习-2" class="headerlink" title="原型链练习#2"></a>原型链练习<code>#2</code></h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> A = <span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;;</span><br><span class="line">A.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">n</span> = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> <span class="title function_">A</span>();</span><br><span class="line">A.<span class="property"><span class="keyword">prototype</span></span> = &#123;</span><br><span class="line">  <span class="attr">n</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">m</span>: <span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> c = <span class="keyword">new</span> <span class="title function_">A</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b.<span class="property">n</span>); <span class="comment">// ?</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b.<span class="property">m</span>); <span class="comment">// ?</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(c.<span class="property">n</span>); <span class="comment">// ?</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(c.<span class="property">m</span>); <span class="comment">// ?</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b.<span class="property">n</span>); <span class="comment">// 输出 1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b.<span class="property">m</span>); <span class="comment">// 输出 undefined</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(c.<span class="property">n</span>); <span class="comment">// 输出 2</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(c.<span class="property">m</span>); <span class="comment">// 输出 3</span></span><br></pre></td></tr></table></figure><h5 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a><p style='font-size: 14px'>解析</p></h5><p><code>A.prototype.n = 1</code></p><ul><li><code>A.prototype</code>初始化时，包含属性<code>n</code>，值为<code>1</code></li></ul><p><code>var b = new A()</code>, 创建实例<code>b</code></p><ul><li><code>b.__proto__</code>指向当前的<code>A.prototype</code>，即<code>&#123; n: 1 &#125;</code></li><li>通过<code>b.n</code>可以访问<code>A.prototype.n</code>，值为<code>1</code></li><li><code>b</code>的原型链为</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">b.<span class="property">__proto__</span> === A.<span class="property"><span class="keyword">prototype</span></span></span><br><span class="line">A.<span class="property"><span class="keyword">prototype</span></span> === &#123; <span class="attr">n</span>: <span class="number">1</span> &#125;</span><br></pre></td></tr></table></figure><p>重新赋值<code>A.prototype</code></p><ul><li><code>A.prototype</code>被重新赋值为一个新的对象<code>&#123; n: 2, m: 3 &#125;</code></li><li>注意: 这不会影响已经创建的实例<code>b</code>，因为<code>b.__proto__</code>指向的是旧的<code>A.prototype</code></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">A.<span class="property"><span class="keyword">prototype</span></span> === &#123; <span class="attr">n</span>: <span class="number">2</span>, <span class="attr">m</span>: <span class="number">3</span> &#125;</span><br></pre></td></tr></table></figure><p><code>var c = new A()</code>, 创建实例<code>c</code></p><ul><li><code>c.__proto__</code>指向当前的<code>A.prototype</code>，即<code>&#123; n: 2, m: 3 &#125;</code></li><li>通过<code>c.n</code>和<code>c.m</code>可以访问新<code>A.prototype</code>上的<code>n</code>和<code>m</code></li></ul><h5 id="原型链示意图-1"><a href="#原型链示意图-1" class="headerlink" title="原型链示意图"></a><p style='font-size: 14px'>原型链示意图</p></h5><ul><li>创建<code>b</code>后</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">b.<span class="property">__proto__</span> → &#123; <span class="attr">n</span>: <span class="number">1</span> &#125;</span><br></pre></td></tr></table></figure><ul><li>重新赋值<code>A.prototype</code>后</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">A.<span class="property"><span class="keyword">prototype</span></span> → &#123; <span class="attr">n</span>: <span class="number">2</span>, <span class="attr">m</span>: <span class="number">3</span> &#125;</span><br></pre></td></tr></table></figure><ul><li>创建<code>c</code>后</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">c.<span class="property">__proto__</span> → &#123; <span class="attr">n</span>: <span class="number">2</span>, <span class="attr">m</span>: <span class="number">3</span> &#125;</span><br></pre></td></tr></table></figure><hr><h4 id="原型链练习-3"><a href="#原型链练习-3" class="headerlink" title="原型链练习#3"></a>原型链练习<code>#3</code></h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = &#123;&#125;,</span><br><span class="line">    F = <span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;;</span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">a</span> = <span class="string">&#x27;value a&#x27;</span>;</span><br><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">b</span> = <span class="string">&#x27;value b&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(foo.<span class="property">a</span>); <span class="comment">// ?</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(foo.<span class="property">b</span>); <span class="comment">// ?</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(F.<span class="property">a</span>); <span class="comment">// ?</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(F.<span class="property">b</span>); <span class="comment">// ?</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(foo.<span class="property">a</span>); <span class="comment">// 输出 &#x27;value a&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(foo.<span class="property">b</span>); <span class="comment">// 输出 undefined</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(F.<span class="property">a</span>); <span class="comment">// 输出 &#x27;value a&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(F.<span class="property">b</span>); <span class="comment">// 输出 &#x27;value b&#x27;</span></span><br></pre></td></tr></table></figure><h5 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a><p style='font-size: 14px'>解析</p></h5><p><code>foo.a</code></p><ul><li><code>foo</code>是一个普通对象，其原型链如下</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">foo.<span class="property">__proto__</span> === <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">a</span> = <span class="string">&#x27;value a&#x27;</span></span><br></pre></td></tr></table></figure><ul><li>因此，<code>foo.a</code>可以通过原型链访问到<code>Object.prototype.a</code>，结果为<code>&#39;value a&#39;</code></li></ul><p><code>foo.b</code></p><ul><li><code>foo</code>的原型链中没有定义<code>b</code>方法或属性</li><li><code>foo.__proto__ === Object.prototype</code>中没有<code>b</code>属性</li><li>因此，<code>foo.b</code>返回<code>undefined</code></li></ul><p><code>F.a</code></p><ul><li><code>F</code>是一个函数，函数也是对象，因此它的原型链如下</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">F.<span class="property">__proto__</span> === <span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span></span><br><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">__proto__</span> === <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">a</span> = <span class="string">&#x27;value a&#x27;</span></span><br></pre></td></tr></table></figure><ul><li><code>F</code>可以通过原型链访问到<code>Object.prototype.a</code>，结果为<code>&#39;value a&#39;</code></li></ul><p><code>F.b</code></p><ul><li><code>F</code>是一个函数，而<code>b</code>是定义在<code>Function.prototype</code>上</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">F.<span class="property">__proto__</span> === <span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span></span><br><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">b</span> = <span class="string">&#x27;value b&#x27;</span></span><br></pre></td></tr></table></figure><ul><li>因此，<code>F.b</code>可以直接访问到<code>Function.prototype.b</code>，结果为<code>&#39;value b&#39;</code></li></ul><h5 id="原型链示意图-2"><a href="#原型链示意图-2" class="headerlink" title="原型链示意图"></a><p style='font-size: 14px'>原型链示意图</p></h5><ul><li><code>foo</code>的原型链</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">foo.<span class="property">__proto__</span> → <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span> → <span class="literal">null</span></span><br></pre></td></tr></table></figure><ul><li><code>F</code>的原型链</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">F.<span class="property">__proto__</span> → <span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span> → <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span> → <span class="literal">null</span></span><br></pre></td></tr></table></figure><hr><h4 id="原型链练习-4"><a href="#原型链练习-4" class="headerlink" title="原型链练习#4"></a>原型链练习<code>#4</code></h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">A</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">B</span>(<span class="params">a</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">a</span> = a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">C</span>(<span class="params">a</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (a) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">a</span> = a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">A.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">a</span> = <span class="number">1</span>;</span><br><span class="line">B.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">a</span> = <span class="number">1</span>;</span><br><span class="line">C.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">a</span> = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title function_">A</span>().<span class="property">a</span>); <span class="comment">// ?</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title function_">B</span>().<span class="property">a</span>); <span class="comment">// ?</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title function_">C</span>(<span class="number">2</span>).<span class="property">a</span>); <span class="comment">// ?</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title function_">A</span>().<span class="property">a</span>); <span class="comment">// 输出 1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title function_">B</span>().<span class="property">a</span>); <span class="comment">// 输出 undefined</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title function_">C</span>(<span class="number">2</span>).<span class="property">a</span>); <span class="comment">// 输出 2</span></span><br></pre></td></tr></table></figure><h5 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a><p style='font-size: 14px'>解析</p></h5><p><code>new A().a</code></p><ul><li>使用<code>new A()</code>创建实例</li><li><code>A</code>的构造函数中没有定义<code>a</code>属性</li><li>查找<code>a</code>时，沿原型链访问<code>A.prototype.a</code>，值为<code>1</code></li><li>输出: <code>1</code></li></ul><p><code>new B().a</code></p><ul><li>使用<code>new B()</code>创建实例</li><li><code>B</code>的构造函数有<code>this.a = a;</code>，此时<code>a</code>的值为<code>undefined</code>（没有传入参数）</li><li>因此，<code>this.a</code>被赋值为<code>undefined</code></li><li>因为实例自身的<code>a</code>属性已经定义了，优先于原型链上的属性</li><li>输出: <code>undefined</code></li></ul><p><code>new C(2).a</code></p><ul><li>使用<code>new C(2)</code>创建实例</li><li><code>C</code>的构造函数中有<code>if (a) &#123; this.a = a; &#125;</code>，传入参数<code>a = 2</code>，条件为<code>true</code></li><li>因此，<code>this.a</code>被赋值为<code>2</code></li><li>实例自身的<code>a</code>属性覆盖了原型链上的<code>C.prototype.a</code></li><li>输出: <code>2</code></li></ul><h5 id="原型链示意图-3"><a href="#原型链示意图-3" class="headerlink" title="原型链示意图"></a><p style='font-size: 14px'>原型链示意图</p></h5><ul><li><code>new A()</code>的原型链</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">instance → A.<span class="property"><span class="keyword">prototype</span></span> → <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span> → <span class="literal">null</span></span><br></pre></td></tr></table></figure><ul><li><code>new B()</code>的原型链</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">instance → B.<span class="property"><span class="keyword">prototype</span></span> → <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span> → <span class="literal">null</span></span><br></pre></td></tr></table></figure><ul><li><code>new C(2)</code>的原型链</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">instance → C.<span class="property"><span class="keyword">prototype</span></span> → <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span> → <span class="literal">null</span></span><br></pre></td></tr></table></figure><hr><h4 id="原型链练习-5"><a href="#原型链练习-5" class="headerlink" title="原型链练习#5"></a>原型链练习<code>#5</code></h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">123</span>[<span class="string">&#x27;toString&#x27;</span>].<span class="property">length</span> + <span class="number">123</span>)</span><br></pre></td></tr></table></figure><p>答案: <code>123</code>是数字，数字本质是<code>new Number()</code>，数字本身没有<code>toString</code>方法，则沿着<code>__proto__</code>去<code>function Number()</code>的<code>prototype</code>上找，找到<code>toString</code>方法，<code>toString</code>方法的<code>length</code>是<code>1</code>，<code>1 + 123 = 124</code>，至于为什么<code>length</code>是<code>1</code>，参考下面文章</p><blockquote><p>参考文章: <a href="https://juejin.cn/post/7003369591967596552">https://juejin.cn/post/7003369591967596552</a></p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">123</span>[<span class="string">&#x27;toString&#x27;</span>].<span class="property">length</span> + <span class="number">123</span>) <span class="comment">// 124</span></span><br></pre></td></tr></table></figure><hr><h3 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h3><blockquote><p>参考文章: <a href="https://juejin.cn/post/7007416743215759373">https://juejin.cn/post/7007416743215759373</a></p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>PostgreSQL 学习笔记</title>
      <link href="/posts/29dadae9.html"/>
      <url>/posts/29dadae9.html</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p>简介里的事真实发生, 第一次让我感受到了人生的大起大落 (原来感觉<code>70%</code>能<code>pass</code>的一下人蒙了, 而且还是公司面 😭) 不过还是有惊无险的过了 😤，吗? <a href="https://www.rockdata.net/zh-cn/tutorial/toc/">参考</a></p></blockquote><hr><h3 id="1-简单查询-SELECT"><a href="#1-简单查询-SELECT" class="headerlink" title="1. 简单查询 SELECT"></a>1. 简单查询 SELECT</h3><p>在<code>PostgreSQL</code>中，<code>SELECT</code>语句用于从数据库中检索数据。它是<code>SQL</code>查询语言的一个基本组成部分，允许你从一个或多个表中选择数据，并根据需要筛选、排序和操作这些数据。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column1, column2, ...</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">condition</span>;</span><br></pre></td></tr></table></figure><ul><li><code>SELECT</code>语句有以下子句<ul><li>使用<code>DISTINCT</code>运算符选择不同的行。</li><li>使用<code>ORDER BY</code>子句对行进行排序。</li><li>使用<code>WHERE</code>子句过滤行。</li><li>使用<code>LIMIT</code>或<code>FETCH</code>子句从表中选择行的子集。</li><li>使用<code>GROUP BY</code>子句将行分组。</li><li>使用<code>HAVING</code>子句过滤分组。</li><li>使用<code>INNER JOIN</code>, <code>LEFT JOIN</code>, <code>FULL OUTER JOIN</code>, <code>CROSS JOIN</code>等连接子句与其他表连接。</li><li>使用<code>UNION</code>、<code>INTERSECT</code>和<code>EXCEPT</code>执行集合运算。</li></ul></li></ul><p>不同的子句和函数（如<code>WHERE</code>、<code>ORDER BY</code>、<code>LIMIT</code>和聚合函数）使得<code>SELECT</code>语句在处理和分析数据时非常强大。</p><hr><h3 id="2-列别名"><a href="#2-列别名" class="headerlink" title="2. 列别名"></a>2. 列别名</h3><p>列别名<code>Column Alias</code>是<code>SQL</code>中的一种功能，用于为查询结果中的列指定临时名称。列别名在<code>SELECT</code>语句中使用，通常用于使输出结果更加清晰易懂，特别是在列名较长或不直观的情况下。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column_name <span class="keyword">AS</span> alias_name</span><br><span class="line"><span class="keyword">FROM</span> table_name;</span><br></pre></td></tr></table></figure><blockquote><p>关键字<code>AS</code>是可选的。</p></blockquote><hr><h3 id="3-排序-ORDER-BY"><a href="#3-排序-ORDER-BY" class="headerlink" title="3. 排序 ORDER BY"></a>3. 排序 ORDER BY</h3><p><code>ORDER BY</code>是<code>SQL</code>语句中的一个子句，用于对查询结果进行排序。通过<code>ORDER BY</code>，你可以指定一个或多个列，根据它们的值以升序（默认）或降序排列结果集。<code>ORDER BY</code>子句可以与<code>SELECT</code>语句一起使用，以确定查询结果的显示顺序。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column1, column2, ...</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> column1 [<span class="keyword">ASC</span><span class="operator">|</span><span class="keyword">DESC</span>], column2 [<span class="keyword">ASC</span><span class="operator">|</span><span class="keyword">DESC</span>], ...;</span><br></pre></td></tr></table></figure><hr><h3 id="4-去重查询-DISTINCT"><a href="#4-去重查询-DISTINCT" class="headerlink" title="4. 去重查询 DISTINCT"></a>4. 去重查询 DISTINCT</h3><p><code>SELECT DISTINCT</code>是<code>SQL</code>中的一种用法，用于从查询结果中去除重复的记录，仅返回唯一的结果行。它适用于希望从数据库表中获取不重复的值或组合的场景。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> column1, column2, ...</span><br><span class="line"><span class="keyword">FROM</span> table_name;</span><br></pre></td></tr></table></figure><ul><li>注意事项<ul><li>性能考虑: <code>SELECT DISTINCT</code>需要对结果进行去重处理，这在大数据集上可能会影响查询性能。使用时应注意查询效率，特别是在处理大表时。</li></ul></li></ul><hr><h3 id="5-分页查询"><a href="#5-分页查询" class="headerlink" title="5. 分页查询"></a>5. 分页查询</h3><p>分页查询 是数据库查询的一种技术，用于将查询结果分割成更小的部分（页），以方便数据的显示和管理，特别是在结果集非常大的情况下。分页能够提高应用的性能和用户体验，因为它可以减少一次性加载的数据量，并提供更快的响应时间。</p><ul><li>分页查询通常涉及两个参数<ul><li>偏移量 <code>Offset</code>: 从结果集中跳过的记录数。</li><li>限制 <code>Limit</code>: 每次查询返回的最大记录数。</li></ul></li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column1, column2, ...</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> column_name</span><br><span class="line">LIMIT limit_value <span class="keyword">OFFSET</span> offset_value;</span><br></pre></td></tr></table></figure><p>假设有一个名为<code>employees</code>的表，我们希望分页查询员工数据，每页显示<code>10</code>条记录</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span> 第一页数据</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> id</span><br><span class="line">LIMIT <span class="number">10</span> <span class="keyword">OFFSET</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 第二页数据</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> id</span><br><span class="line">LIMIT <span class="number">10</span> <span class="keyword">OFFSET</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure><ul><li><p><code>LIMIT 10</code>指定每页最多显示<code>10</code>条记录。</p></li><li><p><code>OFFSET 0</code>指定从结果集的第<code>0</code>条记录开始，也就是第一页的数据。</p></li><li><p>注意事项</p><ul><li>性能问题: 当<code>OFFSET</code>很大时，分页查询可能会变慢，因为数据库仍然需要扫描跳过的记录。对于大数据集，通常会使用更优化的分页技术，如基于主键或索引的分页。</li><li><code>ORDER BY</code>子句的重要性: 为了确保分页结果的稳定性和一致性，通常需要使用<code>ORDER BY</code>子句来明确指定排序顺序。这对于多次分页请求获取一致的结果非常重要。</li><li><code>COUNT</code>和分页: 通常在分页查询前，会先进行<code>COUNT</code>查询来确定总记录数，以便客户端计算总页数。</li></ul></li></ul><hr><h3 id="6-WHERE-子句"><a href="#6-WHERE-子句" class="headerlink" title="6. WHERE 子句"></a>6. WHERE 子句</h3><p><code>WHERE</code>子句是<code>SQL</code>中用于指定筛选条件的部分。它用于从数据库表中筛选出符合特定条件的行。<code>WHERE</code>子句可以用在<code>SELECT</code>、<code>UPDATE</code>、<code>DELETE</code>等<code>SQL</code>语句中，限制这些操作只应用于符合条件的行。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column1, column2, ...</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">condition</span>;</span><br></pre></td></tr></table></figure><ul><li>常见的运算符<ul><li>比较运算符: <code>=</code>，<code>&lt;&gt;</code> (这个是 <code>!=</code>)，<code>&gt;</code>，<code>&lt;</code>，<code>&gt;=</code>，<code>&lt;=</code></li><li>逻辑运算符: <code>AND</code>，<code>OR</code>，<code>NOT</code></li><li>其他运算符: <code>BETWEEN ... AND ...</code>，<code>IN (value1, value2, ...)</code>，<code>LIKE</code> (这个是匹配)，<code>IS NULL</code></li></ul></li></ul><hr><h3 id="7-LIMIT-子句"><a href="#7-LIMIT-子句" class="headerlink" title="7. LIMIT 子句"></a>7. LIMIT 子句</h3><p><code>LIMIT</code>子句是<code>SQL</code>中的一部分，用于限制查询结果中返回的行数。它通常与<code>SELECT</code>语句一起使用，以控制从数据库中提取的行数。<code>LIMIT</code>子句对于分页、性能优化和控制数据输出量非常有用。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column1, column2, ...</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> column_name</span><br><span class="line">LIMIT number_of_rows;</span><br></pre></td></tr></table></figure><ul><li>查询 employees 表中按工资从高到低排列的前 3 名员工</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> salary <span class="keyword">DESC</span></span><br><span class="line">LIMIT <span class="number">3</span>;</span><br></pre></td></tr></table></figure><hr><h3 id="8-FETCH-子句"><a href="#8-FETCH-子句" class="headerlink" title="8. FETCH 子句"></a>8. FETCH 子句</h3><p><code>FETCH</code>子句是<code>SQL</code>中的一部分，用于从查询结果中返回特定数量的行。它通常与<code>OFFSET</code>子句一起使用，以实现更加灵活和清晰的分页操作。在不同的数据库系统中，<code>FETCH</code>子句的支持和语法可能略有不同。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column1, column2, ...</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> column_name</span><br><span class="line"><span class="keyword">OFFSET</span> number_of_rows <span class="keyword">OFFSET</span> </span><br><span class="line"><span class="keyword">FETCH</span> &#123;<span class="keyword">FIRST</span> <span class="operator">|</span> NEXT&#125; number_of_rows &#123;<span class="type">ROW</span> <span class="operator">|</span> <span class="keyword">ROWS</span>&#125; <span class="keyword">ONLY</span>;</span><br></pre></td></tr></table></figure><ul><li><code>FIRST</code>: 表示从结果集的开头返回行数。</li><li><code>NEXT</code>: 表示从当前偏移量位置继续返回行数。</li><li><code>ROW / ROWS</code>: 用于指定返回行的单数或复数形式。两者在功能上没有差别。</li></ul><hr><h3 id="9-IN-运算符语法"><a href="#9-IN-运算符语法" class="headerlink" title="9. IN 运算符语法"></a>9. IN 运算符语法</h3><p><code>IN</code>运算符是<code>SQL</code>中用于指定多个可能值的一种条件操作符。它通常用于<code>WHERE</code>子句中，用来过滤那些列值在指定集合中的行。<code>IN</code>运算符允许你简洁地测试某个列的值是否匹配一组值中的任何一个，而无需使用多个 <code>OR</code>条件。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column1, column2, ...</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> column_name <span class="keyword">IN</span> (value1, value2, ...);</span><br></pre></td></tr></table></figure><ul><li><code>IN</code>运算符可以与<code>NOT</code>结合使用，表示不在指定集合中的值。</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> department <span class="keyword">NOT</span> <span class="keyword">IN</span> (<span class="string">&#x27;HR&#x27;</span>, <span class="string">&#x27;Engineering&#x27;</span>);</span><br></pre></td></tr></table></figure><hr><h3 id="10-BETWEEN-运算符"><a href="#10-BETWEEN-运算符" class="headerlink" title="10. BETWEEN 运算符"></a>10. BETWEEN 运算符</h3><p><code>BETWEEN</code>运算符是<code>SQL</code>中用于筛选范围内的值的一种条件操作符。它通常用于<code>WHERE</code>子句中，以测试某个列的值是否在指定的上下限之间。<code>BETWEEN</code>运算符包括指定的边界值（即包含上下限），它可以用于数字、日期、时间等类型的数据。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column1, column2, ...</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> column_name <span class="keyword">BETWEEN</span> value1 <span class="keyword">AND</span> value2;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span> 数值范围</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> salary <span class="keyword">BETWEEN</span> <span class="number">30000</span> <span class="keyword">AND</span> <span class="number">60000</span>;</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 日期和时间范围</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> orders</span><br><span class="line"><span class="keyword">WHERE</span> order_date <span class="keyword">BETWEEN</span> <span class="string">&#x27;2023-01-01&#x27;</span> <span class="keyword">AND</span> <span class="string">&#x27;2023-12-31&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 字母范围</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> name <span class="keyword">BETWEEN</span> <span class="string">&#x27;A&#x27;</span> <span class="keyword">AND</span> <span class="string">&#x27;M&#x27;</span>;</span><br></pre></td></tr></table></figure><hr><h3 id="11-LIKE-运算符"><a href="#11-LIKE-运算符" class="headerlink" title="11. LIKE 运算符"></a>11. LIKE 运算符</h3><p><code>LIKE</code>运算符是<code>SQL</code>中用于进行模式匹配的运算符。它通常用于<code>WHERE</code>子句中，以根据指定的模式筛选出符合条件的行。<code>LIKE</code>运算符可以匹配字符串中的部分内容，因此特别适合用于查找类似的字符串数据。<code>LIKE</code>运算符常与通配符一起使用，以定义要匹配的模式。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column1, column2, ...</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> column_name <span class="keyword">LIKE</span> <span class="keyword">pattern</span>;</span><br></pre></td></tr></table></figure><ul><li><code>LIKE</code>运算符支持两种主要的通配符<ul><li>百分号<code>%</code>: 匹配任意数量的字符，包括零个字符。</li><li>下划线<code>_</code>: 匹配单个字符。</li></ul></li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span> 查询 employees 表中所有名字以 &quot;A&quot; 开头的员工</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> name <span class="keyword">LIKE</span> <span class="string">&#x27;A%&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 查询 employees 表中所有名字以 &quot;son&quot; 结尾的员工</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> name <span class="keyword">LIKE</span> <span class="string">&#x27;%son&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 查询 employees 表中所有名字中包含 &quot;li&quot; 的员工</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> name <span class="keyword">LIKE</span> <span class="string">&#x27;%li%&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 查询 employees 表中所有名字中第二个字母是 &quot;a&quot; 的员工</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> name <span class="keyword">LIKE</span> <span class="string">&#x27;_a%&#x27;</span>;</span><br></pre></td></tr></table></figure><hr><h3 id="12-NULL-和-IS-NULL-运算符"><a href="#12-NULL-和-IS-NULL-运算符" class="headerlink" title="12. NULL 和 IS NULL 运算符"></a>12. NULL 和 IS NULL 运算符</h3><p><code>NULL</code>是<code>SQL</code>中用于表示数据的缺失或未知值的特殊标识符。它不同于零、空字符串或任何其他值，因为它表示没有数据或数据不可用。由于<code>NULL</code>代表未知值，因此它在逻辑运算和比较中有特殊的处理方式。</p><ul><li><p><code>NULL</code>的特性</p><ul><li>没有特定类型: <code>NULL</code>可以出现在任何数据类型的列中。</li><li>不可比较: <code>NULL</code>不等于任何值，包括它自己。因此，<code>NULL = NULL</code>的表达式结果为<code>FALSE</code>。正确的做法是使用<code>IS NULL</code>来检查<code>NULL</code>值。</li></ul></li><li><p><code>IS NULL</code>运算符</p><ul><li><code>IS NULL</code>运算符用于检查一个列的值是否为<code>NULL</code>。由于<code>NULL</code>不能通过常规的比较运算符（如<code>=</code>）进行比较，因此<code>IS NULL</code>是判断<code>NULL</code>值的唯一合法方式。</li></ul></li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column1, column2, ...</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> column_name <span class="keyword">IS</span> <span class="keyword">NULL</span>;</span><br></pre></td></tr></table></figure><hr><h3 id="13-表别名"><a href="#13-表别名" class="headerlink" title="13. 表别名"></a>13. 表别名</h3><p>表别名<code>Table Alias</code>是<code>SQL</code>中用于为表指定临时名称的功能。表别名通常用于简化查询语句，特别是在多表联接<code>JOIN</code>或子查询中，使得查询更加简洁和易读。表别名仅在查询的上下文中有效，不会影响数据库中表的实际名称。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column1, column2, ...</span><br><span class="line"><span class="keyword">FROM</span> table_name <span class="keyword">AS</span> alias_name</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">condition</span>;</span><br></pre></td></tr></table></figure><blockquote><p>在<code>SQL</code>中，<code>AS</code>是可选的。</p></blockquote><hr><h3 id="14-INNER-JOIN-内连接"><a href="#14-INNER-JOIN-内连接" class="headerlink" title="14. INNER JOIN 内连接"></a>14. INNER JOIN 内连接</h3><p><code>INNER JOIN</code>内连接是<code>SQL</code>中的一种联接操作，用于从多个表中查询相关联的数据。<code>INNER JOIN</code>只返回两个表中满足联接条件的行，也就是说，它只返回在两个表中都有匹配关系的记录。如果其中一个表没有匹配的记录，结果中不会包含该行。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column1, column2, ...</span><br><span class="line"><span class="keyword">FROM</span> table1</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> table2</span><br><span class="line"><span class="keyword">ON</span> table1.common_column <span class="operator">=</span> table2.common_column;</span><br></pre></td></tr></table></figure><p>假设有以下数据</p><ul><li><code>employees</code>表</li></ul><table><thead><tr><th align="left">id</th><th align="center">name</th><th align="right">department_id</th></tr></thead><tbody><tr><td align="left">1</td><td align="center">Alice</td><td align="right">1</td></tr><tr><td align="left">2</td><td align="center">Bob</td><td align="right">2</td></tr><tr><td align="left">3</td><td align="center">Charlie</td><td align="right">NULL</td></tr></tbody></table><ul><li><code>departments</code>表</li></ul><table><thead><tr><th align="left">id</th><th align="center">department_name</th></tr></thead><tbody><tr><td align="left">1</td><td align="center">HR</td></tr><tr><td align="left">2</td><td align="center">Engineering</td></tr><tr><td align="left">3</td><td align="center">Marketing</td></tr></tbody></table><ul><li>使用<code>INNER JOIN</code>查询</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> employees.name, departments.department_name</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> departments <span class="keyword">ON</span> employees.department_id <span class="operator">=</span> departments.id;</span><br></pre></td></tr></table></figure><ul><li>查询结果可能是</li></ul><table><thead><tr><th align="left">name</th><th align="center">department_name</th></tr></thead><tbody><tr><td align="left">Alice</td><td align="center">HR</td></tr><tr><td align="left">Bob</td><td align="center">Engineering</td></tr></tbody></table><hr><h3 id="15-LEFT-JOIN-左连接"><a href="#15-LEFT-JOIN-左连接" class="headerlink" title="15. LEFT JOIN 左连接"></a>15. LEFT JOIN 左连接</h3><p><code>LEFT JOIN</code>左连接是<code>SQL</code>中的一种联接操作，用于从两个表中查询相关的数据。与<code>INNER JOIN</code>不同，<code>LEFT JOIN</code>会返回左表中的所有记录，即使右表中没有匹配的记录。对于那些在右表中没有匹配的记录，结果集中相应右表的字段会显示为<code>NULL</code>。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column1, column2, ...</span><br><span class="line"><span class="keyword">FROM</span> table1</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> table2</span><br><span class="line"><span class="keyword">ON</span> table1.common_column <span class="operator">=</span> table2.common_column;</span><br></pre></td></tr></table></figure><ul><li><code>LEFT JOIN</code>的行为<ul><li>所有左表的行: 即使左表中的某一行在右表中没有匹配记录，该行也会包含在结果集中。</li><li>右表的匹配行: 如果有匹配的右表记录，这些记录会出现在结果集中。</li><li><code>NULL</code>值：对于在右表中没有匹配的左表记录，结果集中右表的列会显示为<code>NULL</code>。</li></ul></li></ul><p>假设有以下数据</p><ul><li><code>employees</code>表</li></ul><table><thead><tr><th align="left">id</th><th align="center">name</th><th align="right">department_id</th></tr></thead><tbody><tr><td align="left">1</td><td align="center">Alice</td><td align="right">1</td></tr><tr><td align="left">2</td><td align="center">Bob</td><td align="right">2</td></tr><tr><td align="left">3</td><td align="center">Charlie</td><td align="right">NULL</td></tr><tr><td align="left">4</td><td align="center">David</td><td align="right">3</td></tr></tbody></table><ul><li><code>departments</code>表</li></ul><table><thead><tr><th align="left">id</th><th align="center">department_name</th></tr></thead><tbody><tr><td align="left">1</td><td align="center">HR</td></tr><tr><td align="left">2</td><td align="center">Engineering</td></tr></tbody></table><ul><li>使用<code>LEFT JOIN</code>查询</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> employees.name, departments.department_name</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> departments <span class="keyword">ON</span> employees.department_id <span class="operator">=</span> departments.id;</span><br></pre></td></tr></table></figure><ul><li>查询结果可能是</li></ul><table><thead><tr><th align="left">name</th><th align="center">department_name</th></tr></thead><tbody><tr><td align="left">Alice</td><td align="center">HR</td></tr><tr><td align="left">Bob</td><td align="center">Engineering</td></tr><tr><td align="left">Charlie</td><td align="center">NULL</td></tr><tr><td align="left">David</td><td align="center">NULL</td></tr></tbody></table><hr><h3 id="16-SELF-JOIN-自连接"><a href="#16-SELF-JOIN-自连接" class="headerlink" title="16. SELF JOIN 自连接"></a>16. SELF JOIN 自连接</h3><p>自连接<code>Self Join</code>是<code>SQL</code>中的一种联接操作，其中一个表与自身进行联接。自连接用于将表中的一行与同一表中的另一行进行比较或关联。这在处理表中行与行之间的关系时非常有用，例如层次结构（如员工与经理的关系）或相邻行之间的比较。</p><ul><li>基本概念<ul><li>同一张表: 自连接涉及的表实际上是同一张表，只是在查询中使用了不同的别名，使得它们在逻辑上看起来像是两个不同的表。</li><li>表别名: 为了区分表的不同实例，通常使用表别名。这样可以在同一个查询中引用表中的不同行。</li></ul></li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> a.column1, b.column2, ...</span><br><span class="line"><span class="keyword">FROM</span> table_name a</span><br><span class="line"><span class="keyword">JOIN</span> table_name b</span><br><span class="line"><span class="keyword">ON</span> a.common_column <span class="operator">=</span> b.common_column;</span><br></pre></td></tr></table></figure><p>假设有以下数据</p><ul><li><code>employees</code>表</li></ul><table><thead><tr><th align="left">id</th><th align="center">name</th><th align="right">manager_id</th></tr></thead><tbody><tr><td align="left">1</td><td align="center">Alice</td><td align="right">NULL</td></tr><tr><td align="left">2</td><td align="center">Bob</td><td align="right">1</td></tr><tr><td align="left">3</td><td align="center">Charlie</td><td align="right">1</td></tr><tr><td align="left">4</td><td align="center">David</td><td align="right">2</td></tr></tbody></table><ul><li>使用自连接查询</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> e.name <span class="keyword">AS</span> employee_name, m.name <span class="keyword">AS</span> manager_name</span><br><span class="line"><span class="keyword">FROM</span> employees e</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> employees m <span class="keyword">ON</span> e.manager_id <span class="operator">=</span> m.id;</span><br></pre></td></tr></table></figure><ul><li>查询结果可能是</li></ul><table><thead><tr><th align="left">employee_name</th><th align="center">manager_name</th></tr></thead><tbody><tr><td align="left">Alice</td><td align="center">NULL</td></tr><tr><td align="left">Bob</td><td align="center">Alice</td></tr><tr><td align="left">Charlie</td><td align="center">Alice</td></tr><tr><td align="left">David</td><td align="center">Bob</td></tr></tbody></table><hr><h3 id="17-FULL-OUTER-JOIN-全外连接"><a href="#17-FULL-OUTER-JOIN-全外连接" class="headerlink" title="17. FULL OUTER JOIN 全外连接"></a>17. FULL OUTER JOIN 全外连接</h3><p><code>FULL OUTER JOIN</code>全外连接是<code>SQL</code>中的一种联接操作，它返回两个表中所有符合联接条件的记录，以及不符合联接条件的记录。与<code>INNER JOIN</code>只返回两个表中有匹配记录的行不同，<code>FULL OUTER JOIN</code>会返回两个表中的所有记录，如果在某一表中没有匹配的记录，则该表的列会返回<code>NULL</code>。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column1, column2, ...</span><br><span class="line"><span class="keyword">FROM</span> table1</span><br><span class="line"><span class="keyword">FULL</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> table2</span><br><span class="line"><span class="keyword">ON</span> table1.common_column <span class="operator">=</span> table2.common_column;</span><br></pre></td></tr></table></figure><p>假设有以下数据</p><ul><li><code>employees</code>表</li></ul><table><thead><tr><th align="left">id</th><th align="center">name</th><th align="right">department_id</th></tr></thead><tbody><tr><td align="left">1</td><td align="center">Alice</td><td align="right">1</td></tr><tr><td align="left">2</td><td align="center">Bob</td><td align="right">2</td></tr><tr><td align="left">3</td><td align="center">Charlie</td><td align="right">NULL</td></tr></tbody></table><ul><li><code>departments</code>表</li></ul><table><thead><tr><th align="left">id</th><th align="center">department_name</th></tr></thead><tbody><tr><td align="left">1</td><td align="center">HR</td></tr><tr><td align="left">2</td><td align="center">Engineering</td></tr><tr><td align="left">3</td><td align="center">Marketing</td></tr></tbody></table><ul><li>使用<code>FULL OUTER JOIN</code>查询</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> employees.name, departments.department_name</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">FULL</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> departments <span class="keyword">ON</span> employees.department_id <span class="operator">=</span> departments.id;</span><br></pre></td></tr></table></figure><ul><li>查询结果可能是</li></ul><table><thead><tr><th align="left">name</th><th align="center">department_name</th></tr></thead><tbody><tr><td align="left">Alice</td><td align="center">HR</td></tr><tr><td align="left">Bob</td><td align="center">Engineering</td></tr><tr><td align="left">Charlie</td><td align="center">NULL</td></tr><tr><td align="left">NULL</td><td align="center">Marketing</td></tr></tbody></table><hr><h3 id="18-CROSS-JOIN-交叉连接"><a href="#18-CROSS-JOIN-交叉连接" class="headerlink" title="18. CROSS JOIN 交叉连接"></a>18. CROSS JOIN 交叉连接</h3><p><code>CROSS JOIN</code>交叉连接是<code>SQL</code>中的一种联接操作，它返回两个表中所有可能的行组合，生成笛卡尔积<code>Cartesian Product</code>。<code>CROSS JOIN</code>不使用任何联接条件，因此会将左表的每一行与右表的每一行组合在一起。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column1, column2, ...</span><br><span class="line"><span class="keyword">FROM</span> table1</span><br><span class="line"><span class="keyword">CROSS</span> <span class="keyword">JOIN</span> table2;</span><br></pre></td></tr></table></figure><p>假设有以下数据</p><ul><li><code>products</code>表</li></ul><table><thead><tr><th align="left">id</th><th align="center">product_name</th></tr></thead><tbody><tr><td align="left">1</td><td align="center">Shirt</td></tr><tr><td align="left">2</td><td align="center">Pants</td></tr></tbody></table><ul><li><code>colors</code>表</li></ul><table><thead><tr><th align="left">id</th><th align="center">color_name</th></tr></thead><tbody><tr><td align="left">1</td><td align="center">Red</td></tr><tr><td align="left">2</td><td align="center">Blue</td></tr></tbody></table><ul><li>使用<code>CROSS JOIN</code>查询</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> products.product_name, colors.color_name</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">CROSS</span> <span class="keyword">JOIN</span> colors;</span><br></pre></td></tr></table></figure><ul><li>查询结果可能是</li></ul><table><thead><tr><th align="left">product_name</th><th align="center">color_name</th></tr></thead><tbody><tr><td align="left">Shirt</td><td align="center">Red</td></tr><tr><td align="left">Shirt</td><td align="center">Blue</td></tr><tr><td align="left">Pants</td><td align="center">Red</td></tr><tr><td align="left">Pants</td><td align="center">Blue</td></tr></tbody></table><hr><h3 id="19-NATURAL-JOIN-自然连接"><a href="#19-NATURAL-JOIN-自然连接" class="headerlink" title="19. NATURAL JOIN 自然连接"></a>19. NATURAL JOIN 自然连接</h3><p><code>NATURAL JOIN</code>自然连接是<code>SQL</code>中的一种联接操作，它根据两个表中同名的列自动进行联接。自然连接会自动比较两个表中所有同名的列，并返回这些列值相等的行。与<code>INNER JOIN</code>不同，<code>NATURAL JOIN</code>不需要显式指定联接条件，因为它会自动查找并使用同名列进行联接。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column1, column2, ...</span><br><span class="line"><span class="keyword">FROM</span> table1</span><br><span class="line"><span class="keyword">NATURAL</span> <span class="keyword">JOIN</span> table2;</span><br></pre></td></tr></table></figure><ul><li><code>NATURAL JOIN</code>的行为<ul><li>自动联接: <code>NATURAL JOIN</code>自动查找并使用两个表中所有同名的列来进行联接。</li><li>同名列值相等: 只有当两个表中同名列的值相等时，才会在结果集中返回这些行。</li><li>不返回重复列: 结果集中不会包含重复的同名列，只会返回一次。</li></ul></li></ul><p>假设有以下数据</p><ul><li><code>employees</code>表</li></ul><table><thead><tr><th align="left">id</th><th align="center">name</th><th align="right">department_id</th></tr></thead><tbody><tr><td align="left">1</td><td align="center">Alice</td><td align="right">1</td></tr><tr><td align="left">2</td><td align="center">Bob</td><td align="right">2</td></tr><tr><td align="left">3</td><td align="center">Charlie</td><td align="right">3</td></tr></tbody></table><ul><li><code>departments</code>表</li></ul><table><thead><tr><th align="left">id</th><th align="center">department_name</th></tr></thead><tbody><tr><td align="left">1</td><td align="center">HR</td></tr><tr><td align="left">2</td><td align="center">Engineering</td></tr><tr><td align="left">4</td><td align="center">Marketing</td></tr></tbody></table><ul><li>使用<code>NATURAL JOIN</code>查询</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> employees.id, employees.name, departments.department_name</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">NATURAL</span> <span class="keyword">JOIN</span> departments;</span><br></pre></td></tr></table></figure><ul><li>查询结果可能是</li></ul><table><thead><tr><th align="left">name</th><th align="center">department_name</th></tr></thead><tbody><tr><td align="left">Alice</td><td align="center">HR</td></tr><tr><td align="left">Bob</td><td align="center">Engineering</td></tr></tbody></table><hr><h3 id="20-LATERAL-JOIN-横向连接"><a href="#20-LATERAL-JOIN-横向连接" class="headerlink" title="20. LATERAL JOIN 横向连接"></a>20. LATERAL JOIN 横向连接</h3><p><code>LATERAL JOIN</code>横向连接是<code>SQL</code>中的一种高级联接操作，它允许联接的子查询可以引用来自连接左侧表的列。<code>LATERAL</code>子句使得每一行都可以独立地进行子查询，基于当前行的值进行计算或过滤。这使得<code>LATERAL JOIN</code>特别适用于那些需要处理依赖于当前行的复杂子查询的场景。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column1, column2, ...</span><br><span class="line"><span class="keyword">FROM</span> table1</span><br><span class="line"><span class="keyword">JOIN</span> <span class="keyword">LATERAL</span> (</span><br><span class="line">  <span class="keyword">SELECT</span> ...</span><br><span class="line">) alias <span class="keyword">ON</span> <span class="keyword">condition</span>;</span><br></pre></td></tr></table></figure><p>假设有以下数据</p><ul><li><code>employees</code>表</li></ul><table><thead><tr><th align="left">id</th><th align="center">name</th></tr></thead><tbody><tr><td align="left">1</td><td align="center">Alice</td></tr><tr><td align="left">2</td><td align="center">Bob</td></tr></tbody></table><ul><li><code>projects</code>表</li></ul><table><thead><tr><th align="left">employee_id</th><th align="center">project_name</th><th align="right">start_date</th></tr></thead><tbody><tr><td align="left">1</td><td align="center">Project X</td><td align="right">2023-01-01</td></tr><tr><td align="left">2</td><td align="center">Project Y</td><td align="right">2023-06-01</td></tr><tr><td align="left">3</td><td align="center">Project Z</td><td align="right">2022-09-01</td></tr></tbody></table><ul><li>使用<code>LATERAL JOIN</code>查询</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> e.name, p.project_name</span><br><span class="line"><span class="keyword">FROM</span> employees e</span><br><span class="line"><span class="keyword">JOIN</span> <span class="keyword">LATERAL</span> (</span><br><span class="line">  <span class="keyword">SELECT</span> project_name</span><br><span class="line">  <span class="keyword">FROM</span> projects p</span><br><span class="line">  <span class="keyword">WHERE</span> p.employee_id <span class="operator">=</span> e.id</span><br><span class="line">  <span class="keyword">ORDER</span> <span class="keyword">BY</span> start_date <span class="keyword">DESC</span></span><br><span class="line">  LIMIT <span class="number">1</span></span><br><span class="line">) p <span class="keyword">ON</span> <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><ul><li>查询结果可能是</li></ul><table><thead><tr><th align="left">name</th><th align="center">project_name</th></tr></thead><tbody><tr><td align="left">Alice</td><td align="center">Project Y</td></tr><tr><td align="left">Bob</td><td align="center">Project Z</td></tr></tbody></table><hr><h3 id="21-GROUP-BY-分组"><a href="#21-GROUP-BY-分组" class="headerlink" title="21. GROUP BY 分组"></a>21. GROUP BY 分组</h3><p><code>GROUP BY</code>是<code>SQL</code>中的一个子句，用于将查询结果按一个或多个列进行分组。分组操作通常与聚合函数（如<code>COUNT</code>、<code>SUM</code>、<code>AVG</code>、<code>MAX</code>、<code>MIN</code>等）结合使用，以便对每个分组进行汇总计算。<code>GROUP BY</code>允许你将数据按特定的维度进行聚合，进而对这些聚合后的数据进行分析。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column1, column2, ..., aggregate_function(<span class="keyword">column</span>)</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">condition</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> column1, column2, ...;</span><br></pre></td></tr></table></figure><ul><li>举个例子，按<code>product_id</code>对销售数量进行汇总，计算每个产品的总销售量。</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> product_id, <span class="built_in">SUM</span>(quantity) <span class="keyword">AS</span> total_quantity</span><br><span class="line"><span class="keyword">FROM</span> sales</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> product_id;</span><br></pre></td></tr></table></figure><hr><h3 id="22-HAVING-子句"><a href="#22-HAVING-子句" class="headerlink" title="22. HAVING 子句"></a>22. HAVING 子句</h3><p><code>HAVING</code>子句是<code>SQL</code>中的一部分，主要用于在分组后的结果集上进行过滤。它通常与<code>GROUP BY</code>子句一起使用，以便对聚合后的数据进行进一步的筛选。与<code>WHERE</code>子句不同，<code>HAVING</code>子句用于过滤基于聚合函数的结果，而<code>WHERE</code>子句是在数据分组之前对行进行过滤。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column1, column2, aggregate_function(column3)</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">condition</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> column1, column2</span><br><span class="line"><span class="keyword">HAVING</span> aggregate_condition;</span><br></pre></td></tr></table></figure><ul><li>举个例子，查询销售总量大于<code>100</code>的产品</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> product_id, <span class="built_in">SUM</span>(quantity) <span class="keyword">AS</span> total_quantity</span><br><span class="line"><span class="keyword">FROM</span> sales</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> product_id</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">SUM</span>(quantity) <span class="operator">&gt;</span> <span class="number">100</span>;</span><br></pre></td></tr></table></figure><hr><h3 id="23-PARTITION-BY-分区计算"><a href="#23-PARTITION-BY-分区计算" class="headerlink" title="23. PARTITION BY 分区计算"></a>23. PARTITION BY 分区计算</h3><p><code>PARTITION BY</code>是<code>SQL</code>中的一个子句，通常与窗口函数一起使用，用于将查询结果集划分为多个分区，然后在每个分区内执行特定的计算。它类似于<code>GROUP BY</code>，但<code>PARTITION BY</code>不会将数据聚合到单一行，而是保留所有行，并在每个分区内执行计算。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column1, column2, </span><br><span class="line">       window_function() <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> column_name <span class="keyword">ORDER</span> <span class="keyword">BY</span> column_name) <span class="keyword">AS</span> alias_name</span><br><span class="line"><span class="keyword">FROM</span> table_name;</span><br></pre></td></tr></table></figure><p>假设有以下数据</p><ul><li><code>sales</code>表</li></ul><table><thead><tr><th align="left">id</th><th align="center">employee_id</th><th align="center">sale_amount</th><th align="center">sale_date</th></tr></thead><tbody><tr><td align="left">1</td><td align="center">101</td><td align="center">500</td><td align="center">2023-08-01</td></tr><tr><td align="left">2</td><td align="center">101</td><td align="center">700</td><td align="center">2023-08-02</td></tr><tr><td align="left">3</td><td align="center">102</td><td align="center">300</td><td align="center">2023-08-01</td></tr><tr><td align="left">4</td><td align="center">101</td><td align="center">400</td><td align="center">2023-08-03</td></tr><tr><td align="left">5</td><td align="center">102</td><td align="center">800</td><td align="center">2023-08-02</td></tr></tbody></table><ul><li>使用<code>PARTITION BY</code>进行分区计算</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> employee_id, sale_date, sale_amount,</span><br><span class="line">       <span class="built_in">RANK</span>() <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> employee_id <span class="keyword">ORDER</span> <span class="keyword">BY</span> sale_amount <span class="keyword">DESC</span>) <span class="keyword">AS</span> sales_rank</span><br><span class="line"><span class="keyword">FROM</span> sales;</span><br></pre></td></tr></table></figure><ul><li>查询结果可能是</li></ul><table><thead><tr><th align="left">employee_id</th><th align="center">sale_date</th><th align="center">sale_amount</th><th align="center">sales_rank</th></tr></thead><tbody><tr><td align="left">101</td><td align="center">2023-08-02</td><td align="center">700</td><td align="center">1</td></tr><tr><td align="left">101</td><td align="center">2023-08-01</td><td align="center">500</td><td align="center">2</td></tr><tr><td align="left">101</td><td align="center">2023-08-03</td><td align="center">400</td><td align="center">3</td></tr><tr><td align="left">102</td><td align="center">2023-08-02</td><td align="center">800</td><td align="center">1</td></tr><tr><td align="left">102</td><td align="center">2023-08-01</td><td align="center">300</td><td align="center">2</td></tr></tbody></table><hr><h3 id="24-UNION-组合"><a href="#24-UNION-组合" class="headerlink" title="24. UNION 组合"></a>24. UNION 组合</h3><p><code>UNION</code>是<code>SQL</code>中的一个运算符，用于将两个或多个<code>SELECT</code>语句的结果组合成一个结果集。<code>UNION</code>运算符将多个查询的结果合并为一个，且默认情况下会去除重复的行。如果你希望保留重复行，可以使用<code>UNION ALL</code>。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column1, column2, ...</span><br><span class="line"><span class="keyword">FROM</span> table1</span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> column1, column2, ...</span><br><span class="line"><span class="keyword">FROM</span> table2;</span><br></pre></td></tr></table></figure><p>使用条件</p><ul><li>列数和数据类型必须一致: 参与<code>UNION</code>的每个<code>SELECT</code>语句中，列数必须相同，且对应列的数据类型应该兼容或相同。</li><li>列的顺序和名称: 在合并的结果集中，列的顺序以第一个<code>SELECT</code>语句中的列为准，列名也是根据第一个<code>SELECT</code>语句的列名。</li></ul><p>举个例子，查询两个表中的所有员工，并将结果合并为一个结果集</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> id, name, department</span><br><span class="line"><span class="keyword">FROM</span> employees_2023</span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> id, name, department</span><br><span class="line"><span class="keyword">FROM</span> employees_2024;</span><br></pre></td></tr></table></figure><hr><h3 id="25-INTERSECT-交集"><a href="#25-INTERSECT-交集" class="headerlink" title="25. INTERSECT 交集"></a>25. INTERSECT 交集</h3><p><code>INTERSECT</code>是<code>SQL</code>中的一个运算符，用于返回两个或多个<code>SELECT</code>语句结果集的交集。换句话说，它返回的是在所有参与查询的结果集中都存在的行。<code>INTERSECT</code>运算符在多个查询结果集中找出共有的行，而这些行必须在所有查询中都出现。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column1, column2, ...</span><br><span class="line"><span class="keyword">FROM</span> table1</span><br><span class="line"><span class="keyword">INTERSECT</span></span><br><span class="line"><span class="keyword">SELECT</span> column1, column2, ...</span><br><span class="line"><span class="keyword">FROM</span> table2;</span><br></pre></td></tr></table></figure><p><code>INTERSECT</code>的行为</p><ul><li>返回共有行: <code>INTERSECT</code>只返回在所有<code>SELECT</code>语句结果集中都存在的行。</li><li>自动去重: <code>INTERSECT</code>会自动去除结果中的重复行，类似于<code>DISTINCT</code>。</li></ul><p>举个例子，查询两个表中在<code>2023</code>年和<code>2024</code>年都存在的员工</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> id, name, department</span><br><span class="line"><span class="keyword">FROM</span> employees_2023</span><br><span class="line"><span class="keyword">INTERSECT</span></span><br><span class="line"><span class="keyword">SELECT</span> id, name, department</span><br><span class="line"><span class="keyword">FROM</span> employees_2024;</span><br></pre></td></tr></table></figure><hr><h3 id="26-EXCEPT-差集"><a href="#26-EXCEPT-差集" class="headerlink" title="26. EXCEPT 差集"></a>26. EXCEPT 差集</h3><p><code>EXCEPT</code>是<code>SQL</code>中的一个运算符，用于返回两个<code>SELECT</code>语句结果集的差集，即返回第一个查询的结果集中有但第二个查询的结果集中没有的行。<code>EXCEPT</code>通常用于比较两个结果集并找出其中一个结果集中独有的记录。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column1, column2, ...</span><br><span class="line"><span class="keyword">FROM</span> table1</span><br><span class="line"><span class="keyword">EXCEPT</span></span><br><span class="line"><span class="keyword">SELECT</span> column1, column2, ...</span><br><span class="line"><span class="keyword">FROM</span> table2;</span><br></pre></td></tr></table></figure><p><code>EXCEPT</code>的行为</p><ul><li>返回差集: <code>EXCEPT</code>返回第一个查询结果集中有，但第二个查询结果集中没有的行。</li><li>自动去重: <code>EXCEPT</code>会自动去除结果中的重复行，类似于<code>DISTINCT</code>。</li></ul><p>举个例子，查询那些在<code>2023</code>年存在但在<code>2024</code>年不存在的员工</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> id, name, department</span><br><span class="line"><span class="keyword">FROM</span> employees_2023</span><br><span class="line"><span class="keyword">EXCEPT</span></span><br><span class="line"><span class="keyword">SELECT</span> id, name, department</span><br><span class="line"><span class="keyword">FROM</span> employees_2024;</span><br></pre></td></tr></table></figure><hr><h3 id="27-GROUPING-SETS-分组"><a href="#27-GROUPING-SETS-分组" class="headerlink" title="27. GROUPING SETS 分组"></a>27. GROUPING SETS 分组</h3><p><code>GROUPING SETS</code>是<code>SQL</code>中的一种高级分组功能，用于在单个查询中实现多种分组方式。它允许你在一次查询中指定多个分组标准，并返回每个分组标准的聚合结果。<code>GROUPING SETS</code>本质上是<code>GROUP BY</code>子句的扩展，提供了更灵活的分组和聚合操作。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column1, column2, ..., aggregate_function(<span class="keyword">column</span>)</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">GROUPING</span> SETS ( (column1), (column2), ...);</span><br></pre></td></tr></table></figure><p>假设有以下数据</p><ul><li><code>sales</code>表</li></ul><table><thead><tr><th align="left">id</th><th align="center">employee_id</th><th align="center">product_id</th><th align="center">sale_amount</th></tr></thead><tbody><tr><td align="left">1</td><td align="center">101</td><td align="center">1</td><td align="center">100</td></tr><tr><td align="left">2</td><td align="center">102</td><td align="center">1</td><td align="center">200</td></tr><tr><td align="left">3</td><td align="center">101</td><td align="center">2</td><td align="center">150</td></tr><tr><td align="left">4</td><td align="center">103</td><td align="center">2</td><td align="center">250</td></tr></tbody></table><ul><li>我们希望在一个查询中得到以下几种分组的聚合结果<ul><li>按员工<code>employee_id</code>分组并计算销售总额。</li><li>按产品<code>product_id</code>分组并计算销售总额。</li><li>对所有销售记录计算总额（没有分组）。</li></ul></li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> employee_id, product_id, <span class="built_in">SUM</span>(sale_amount) <span class="keyword">AS</span> total_sales</span><br><span class="line"><span class="keyword">FROM</span> sales</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">GROUPING</span> SETS (</span><br><span class="line">    (employee_id),</span><br><span class="line">    (product_id),</span><br><span class="line">    ()</span><br><span class="line">);</span><br></pre></td></tr></table></figure><ul><li>查询结果可能是</li></ul><table><thead><tr><th align="left">employee_id</th><th align="center">product_id</th><th align="center">total_sales</th></tr></thead><tbody><tr><td align="left">101</td><td align="center">NULL</td><td align="center">250</td></tr><tr><td align="left">102</td><td align="center">NULL</td><td align="center">200</td></tr><tr><td align="left">103</td><td align="center">NULL</td><td align="center">250</td></tr><tr><td align="left">NULL</td><td align="center">1</td><td align="center">300</td></tr><tr><td align="left">NULL</td><td align="center">2</td><td align="center">400</td></tr><tr><td align="left">NULL</td><td align="center">NULL</td><td align="center">700</td></tr></tbody></table><hr><h3 id="28-CUBE-分组"><a href="#28-CUBE-分组" class="headerlink" title="28. CUBE 分组"></a>28. CUBE 分组</h3><p><code>CUBE</code>是<code>SQL</code>中的一个扩展分组功能，用于在单个查询中生成所有可能组合的分组和聚合结果。<code>CUBE</code>是<code>GROUP BY</code>子句的一部分，提供了一种多维分析的方式，特别适合在需要对数据进行多维度汇总的场景中使用。它通过计算所有可能的分组组合，帮助我们全面地了解数据的分布。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column1, column2, ..., aggregate_function(<span class="keyword">column</span>)</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">CUBE</span> (column1, column2, ...);</span><br></pre></td></tr></table></figure><p>假设有以下数据</p><ul><li><code>sales</code>表</li></ul><table><thead><tr><th align="left">region</th><th align="center">product</th><th align="center">sale_amount</th></tr></thead><tbody><tr><td align="left">North</td><td align="center">A</td><td align="center">100</td></tr><tr><td align="left">North</td><td align="center">B</td><td align="center">150</td></tr><tr><td align="left">South</td><td align="center">A</td><td align="center">200</td></tr><tr><td align="left">South</td><td align="center">B</td><td align="center">250</td></tr></tbody></table><ul><li>按区域和产品生成销售金额的所有可能组合的聚合结果</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> region, product, <span class="built_in">SUM</span>(sale_amount) <span class="keyword">AS</span> total_sales</span><br><span class="line"><span class="keyword">FROM</span> sales</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">CUBE</span> (region, product);</span><br></pre></td></tr></table></figure><ul><li>查询结果可能是</li></ul><table><thead><tr><th align="left">region</th><th align="center">product</th><th align="right">total_sales</th></tr></thead><tbody><tr><td align="left">North</td><td align="center">A</td><td align="right">100</td></tr><tr><td align="left">North</td><td align="center">B</td><td align="right">150</td></tr><tr><td align="left">North</td><td align="center">NULL</td><td align="right">250</td></tr><tr><td align="left">South</td><td align="center">A</td><td align="right">200</td></tr><tr><td align="left">South</td><td align="center">B</td><td align="right">250</td></tr><tr><td align="left">South</td><td align="center">NULL</td><td align="right">450</td></tr><tr><td align="left">NULL</td><td align="center">A</td><td align="right">300</td></tr><tr><td align="left">NULL</td><td align="center">B</td><td align="right">400</td></tr><tr><td align="left">NULL</td><td align="center">NULL</td><td align="right">700</td></tr></tbody></table><hr><h3 id="29-ROLLUP-分组"><a href="#29-ROLLUP-分组" class="headerlink" title="29. ROLLUP 分组"></a>29. ROLLUP 分组</h3><p><code>ROLLUP</code>是<code>SQL</code>中的一个扩展分组功能，用于生成基于层次结构的分组和聚合结果。它是<code>GROUP BY</code>子句的扩展，用于在一个查询中生成从详细到汇总的多个级别的聚合结果。<code>ROLLUP</code>常用于需要对数据进行层次分析的场景，例如销售数据按区域和时间进行汇总时。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column1, column2, ..., aggregate_function(<span class="keyword">column</span>)</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">ROLLUP</span> (column1, column2, ...);</span><br></pre></td></tr></table></figure><p>假设有以下数据</p><ul><li><code>sales</code>表</li></ul><table><thead><tr><th align="left">region</th><th align="center">product</th><th align="right">sale_amount</th></tr></thead><tbody><tr><td align="left">North</td><td align="center">A</td><td align="right">100</td></tr><tr><td align="left">North</td><td align="center">B</td><td align="right">150</td></tr><tr><td align="left">South</td><td align="center">A</td><td align="right">200</td></tr><tr><td align="left">South</td><td align="center">B</td><td align="right">250</td></tr></tbody></table><ul><li>按区域和产品生成从详细到汇总的销售金额数据</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> region, product, <span class="built_in">SUM</span>(sale_amount) <span class="keyword">AS</span> total_sales</span><br><span class="line"><span class="keyword">FROM</span> sales</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">CUBE</span> (region, product);</span><br></pre></td></tr></table></figure><ul><li>查询结果可能是</li></ul><table><thead><tr><th align="left">region</th><th align="center">product</th><th align="right">total_sales</th></tr></thead><tbody><tr><td align="left">North</td><td align="center">A</td><td align="right">100</td></tr><tr><td align="left">North</td><td align="center">B</td><td align="right">150</td></tr><tr><td align="left">North</td><td align="center">NULL</td><td align="right">250</td></tr><tr><td align="left">South</td><td align="center">A</td><td align="right">200</td></tr><tr><td align="left">South</td><td align="center">B</td><td align="right">250</td></tr><tr><td align="left">South</td><td align="center">NULL</td><td align="right">450</td></tr><tr><td align="left">NULL</td><td align="center">NULL</td><td align="right">700</td></tr></tbody></table><hr><h3 id="30"><a href="#30" class="headerlink" title="30."></a>30.</h3><hr><h3 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h3><blockquote><p>文件还未上传 Github</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PostgreSQL </tag>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GraphQL 学习笔记</title>
      <link href="/posts/69cd31bf.html"/>
      <url>/posts/69cd31bf.html</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p>参考文章: <a href="https://chenyitian.gitbooks.io/graphql/content/introduction.html">https://chenyitian.gitbooks.io/graphql/content/introduction.html</a><br>参考网站: <a href="https://www.howtographql.com/basics/0-introduction/">https://www.howtographql.com/basics/0-introduction/</a></p></blockquote><hr><h3 id="GraphQL基础"><a href="#GraphQL基础" class="headerlink" title="GraphQL基础"></a><code>GraphQL</code>基础</h3><h4 id="1-什么是GraphQL"><a href="#1-什么是GraphQL" class="headerlink" title="1. 什么是GraphQL"></a>1. 什么是<code>GraphQL</code></h4><p><code>GraphQL</code>是一种用于<code>API</code>的查询语言，同时也是一种运行在服务端的执行引擎。它使用基于类型系统的模式定义和验证查询结构（类型系统由你的数据定义）。<code>GraphQL</code>不依赖任何特定数据库或存储引擎，而是通过现有代码和数据来支持查询</p><h5 id="为什么使用GraphQL"><a href="#为什么使用GraphQL" class="headerlink" title="为什么使用GraphQL"></a><p style='font-size: 14px'>为什么使用<code>GraphQL</code></p></h5><ul><li>灵活的数据获取: 客户端可以请求确切的数据结构，避免数据过多或不足的问题</li><li>单一端点: 所有查询通过一个端点完成，简化了客户端与服务端的交互</li><li>强类型系统: 定义<code>API</code>时使用强类型，可以捕获开发错误，增强工具支持（如自动生成文档和代码）</li><li>实时更新: 通过订阅（<code>subscriptions</code>），支持实时数据更新，客户端在数据变化时能自动接收更新</li></ul><h5 id="与REST的对比"><a href="#与REST的对比" class="headerlink" title="与REST的对比"></a><p style='font-size: 14px'>与<code>REST</code>的对比</p></h5><ul><li><p>与<code>REST</code>的对比 (优点)</p><ul><li>避免多次请求: <code>REST</code>中可能需要多次请求不同资源才能获取所需数据，而<code>GraphQL</code>能通过单一查询获取所有相关数据</li><li>精确的数据获取: 客户端明确指定需要的字段，避免多余数据传输，适用于带宽有限或网络不稳定的环境</li></ul></li><li><p>与<code>REST</code>的对比 (缺点)</p><ul><li>查询解析复杂: 由于<code>GraphQL</code>查询的灵活性，解析和执行查询可能比<code>REST</code>更复杂，尤其在大规模数据集或复杂业务逻辑中</li><li>缓存困难: 与<code>REST</code>固定<code>URL</code>不同，<code>GraphQL</code>查询不是静态的，因此标准<code>HTTP</code>缓存机制难以直接应用，需要额外设计缓存策略</li><li>学习曲线: 😅</li></ul></li></ul><hr><h4 id="2-字段Fields"><a href="#2-字段Fields" class="headerlink" title="2. 字段Fields"></a>2. 字段<code>Fields</code></h4><p>在<code>GraphQL</code>中，字段 (<code>fields</code>) 是定义在类型 (<code>type</code>) 上的属性，表示类型包含的数据内容。字段有以下特点</p><ul><li>每个字段都有名称和返回类型，类型可以是标量（如<code>String</code>、<code>Int</code>）、对象、枚举、列表等</li><li>字段可以接受参数，用于传递附加信息或过滤数据</li></ul><h5 id="字段的基本定义"><a href="#字段的基本定义" class="headerlink" title="字段的基本定义"></a><p style='font-size: 14px'>字段的基本定义</p></h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type User &#123;</span><br><span class="line">  id: ID!</span><br><span class="line">  name: String!</span><br><span class="line">  age: Int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Query &#123;</span><br><span class="line">  user(id: ID!): User</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>User</code>类型</p><ul><li>包含<code>id</code>、<code>name</code>和<code>age</code>三个字段</li><li>每个字段定义了<code>User</code>类型的数据结构</li></ul></li><li><p><code>Query</code>类型</p><ul><li>定义了一个查询字段<code>user</code>，可以根据<code>id</code>获取一个<code>User</code></li></ul></li></ul><h5 id="什么是Schema"><a href="#什么是Schema" class="headerlink" title="什么是Schema"></a><p style='font-size: 14px'>什么是<code>Schema</code></p></h5><ul><li><code>Schema</code>是<code>GraphQL</code>的核心概念，用于描述<code>API</code>的结构，包括<ul><li>类型定义<code>Type</code>: 定义<code>API</code>中的类型，例如标量类型 (<code>String</code>、<code>Int</code>)、对象类型 (<code>User</code>)、枚举类型等</li><li>根类型<code>Root Types</code>: 包括<code>Query</code>、<code>Mutation</code>和<code>Subscription</code>，分别定义了查询、变更和订阅操作</li></ul></li></ul><h5 id="解析器Resolver"><a href="#解析器Resolver" class="headerlink" title="解析器Resolver"></a><p style='font-size: 14px'>解析器<code>Resolver</code></p></h5><ul><li>字段通常需要解析器来告诉<code>GraphQL</code>如何获取字段的值。当客户端请求某个字段时，<code>GraphQL</code>会调用对应的解析器来获取数据</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> resolvers = &#123;</span><br><span class="line">  <span class="title class_">Query</span>: &#123;</span><br><span class="line">    <span class="attr">user</span>: <span class="function">(<span class="params">parent, args, context, info</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> userId = args.<span class="property">id</span>; <span class="comment">// 从 args 获取用户 ID</span></span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">getUserById</span>(userId); <span class="comment">// 调用数据源函数获取用户数据</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="完整查询示例"><a href="#完整查询示例" class="headerlink" title="完整查询示例"></a><p style='font-size: 14px'>完整查询示例</p></h5><ul><li>客户端可以发送如下查询请求</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">query &#123;</span><br><span class="line">  <span class="title function_">user</span>(<span class="params">id: <span class="string">&quot;1&quot;</span></span>) &#123;</span><br><span class="line">    id</span><br><span class="line">    name</span><br><span class="line">    age</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>定义<code>Schema</code>: 描述数据类型和操作</li><li>编写<code>Resolver</code>: 实现具体的数据获取逻辑</li><li>客户端查询: 通过<code>Query</code>请求数据，<code>GraphQL</code>调用解析器返回结果</li></ul><h5 id="Mutation示例"><a href="#Mutation示例" class="headerlink" title="Mutation示例"></a><p style='font-size: 14px'><code>Mutation</code>示例</p></h5><ul><li>下面是一个使用变更操作 (<code>Mutation</code>) 创建用户的示例</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type User &#123;</span><br><span class="line">  id: ID!</span><br><span class="line">  name: String!</span><br><span class="line">  age: Int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Mutation &#123;</span><br><span class="line">  createUser(name: String!, age: Int): User</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>对应的解析器</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> resolvers = &#123;</span><br><span class="line">  <span class="title class_">Mutation</span>: &#123;</span><br><span class="line">    <span class="attr">createUser</span>: <span class="function">(<span class="params">parent, args, context, info</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> newUser = &#123;</span><br><span class="line">        <span class="attr">id</span>: <span class="title function_">generateUniqueId</span>(),</span><br><span class="line">        <span class="attr">name</span>: args.<span class="property">name</span>,</span><br><span class="line">        <span class="attr">age</span>: args.<span class="property">age</span>,</span><br><span class="line">      &#125;;</span><br><span class="line">      <span class="title function_">saveUserToDatabase</span>(newUser); <span class="comment">// 保存到数据库</span></span><br><span class="line">      <span class="keyword">return</span> newUser;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>客户端请求</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mutation &#123;</span><br><span class="line">  createUser(name: &quot;Alice&quot;, age: 30) &#123;</span><br><span class="line">    id</span><br><span class="line">    name</span><br><span class="line">    age</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="3-参数Arguments"><a href="#3-参数Arguments" class="headerlink" title="3. 参数Arguments"></a>3. 参数<code>Arguments</code></h4><p>在<code>GraphQL</code>中，参数 (<code>Arguments</code>) 用于向字段或操作（如查询<code>Query</code>和变更<code>Mutation</code>）传递输入数据。参数允许客户端在请求中提供额外信息，用于筛选、过滤或指定要操作的数据</p><h5 id="参数的定义"><a href="#参数的定义" class="headerlink" title="参数的定义"></a><p style='font-size: 14px'>参数的定义</p></h5><ul><li>参数可以定义在<code>GraphQL schema</code>中的字段上。参数可以是<ul><li>必需参数: 使用<code>!</code>符号表示，必须提供</li><li>可选参数: 没有<code>!</code>符号的参数，可以省略</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type User &#123;</span><br><span class="line">  id: ID!</span><br><span class="line">  name: String!</span><br><span class="line">  age: Int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Query &#123;</span><br><span class="line">  user(id: ID!): User</span><br><span class="line">  users(age: Int): [User]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>user</code>字段有一个必需的<code>id</code>参数，用于指定要查询的用户</li><li><code>users</code>字段有一个可选的<code>age</code>参数，用于筛选特定年龄的用户</li><li>方括号<code>[ ]</code>表示返回值是一个列表类型</li></ul><h5 id="解析器中的参数"><a href="#解析器中的参数" class="headerlink" title="解析器中的参数"></a><p style='font-size: 14px'>解析器中的参数</p></h5><ul><li>在解析器 (<code>Resolver</code>) 中，参数通过<code>args</code>对象传递，可以使用这些参数来筛选或操作数据</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> resolvers = &#123;</span><br><span class="line">  <span class="title class_">Query</span>: &#123;</span><br><span class="line">    <span class="attr">user</span>: <span class="function">(<span class="params">parent, args, context, info</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 根据 args.id 查询用户</span></span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">getUserById</span>(args.<span class="property">id</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">users</span>: <span class="function">(<span class="params">parent, args, context, info</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 如果提供了 age 参数，过滤用户</span></span><br><span class="line">      <span class="keyword">if</span> (args.<span class="property">age</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">getUsersByAge</span>(args.<span class="property">age</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">getAllUsers</span>();</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><code>args.id</code>和<code>args.age</code>是客户端请求中传递的参数</li><li>在<code>user</code>查询中，通过<code>id</code>获取单个用户</li><li>在<code>users</code>查询中，根据<code>age</code>筛选用户列表，如果未提供<code>age</code>参数，则返回所有用户</li></ul><h5 id="客户端查询"><a href="#客户端查询" class="headerlink" title="客户端查询"></a><p style='font-size: 14px'>客户端查询</p></h5><ul><li>客户端可以通过查询请求传递参数</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">query &#123;</span><br><span class="line">  user(id: &quot;1&quot;) &#123;</span><br><span class="line">    id</span><br><span class="line">    name</span><br><span class="line">    age</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  users(age: 30) &#123;</span><br><span class="line">    id</span><br><span class="line">    name</span><br><span class="line">    age</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>第一部分请求<code>id</code>为<code>&quot;1&quot;</code>的用户</li><li>第二部分请求所有<code>age</code>为<code>30</code>的用户</li></ul><h5 id="变更中的参数"><a href="#变更中的参数" class="headerlink" title="变更中的参数"></a><p style='font-size: 14px'>变更中的参数</p></h5><p>参数在变更操作（<code>Mutation</code>）中用于提供操作所需的输入数据，例如创建一个新用户</p><ul><li><code>Schema</code>定义</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type Mutation &#123;</span><br><span class="line">  createUser(name: String!, age: Int): User</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>解析器</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> resolvers = &#123;</span><br><span class="line">  <span class="title class_">Mutation</span>: &#123;</span><br><span class="line">    <span class="attr">createUser</span>: <span class="function">(<span class="params">parent, args, context, info</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> newUser = &#123;</span><br><span class="line">        <span class="attr">id</span>: <span class="title function_">generateUniqueId</span>(),</span><br><span class="line">        <span class="attr">name</span>: args.<span class="property">name</span>,</span><br><span class="line">        <span class="attr">age</span>: args.<span class="property">age</span>,</span><br><span class="line">      &#125;;</span><br><span class="line">      <span class="title function_">saveUserToDatabase</span>(newUser); <span class="comment">// 将用户数据保存到数据库</span></span><br><span class="line">      <span class="keyword">return</span> newUser;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>客户端请求</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mutation &#123;</span><br><span class="line">  createUser(name: &quot;Alice&quot;, age: 30) &#123;</span><br><span class="line">    id</span><br><span class="line">    name</span><br><span class="line">    age</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>客户端传递参数<code>name</code>和<code>age</code>，服务器根据参数创建用户并返回新增用户的数据</li></ul><hr><h3 id="GraphQL核心功能"><a href="#GraphQL核心功能" class="headerlink" title="GraphQL核心功能"></a><code>GraphQL</code>核心功能</h3><h4 id="4-别名Aliases"><a href="#4-别名Aliases" class="headerlink" title="4. 别名Aliases"></a>4. 别名<code>Aliases</code></h4><p>在<code>GraphQL</code>中，别名 (<code>Aliases</code>) 是一种用于重命名查询结果中字段名称的功能。它允许客户端</p><ul><li>避免命名冲突: 当查询结果包含多个同名字段时，使用别名区分不同的字段调用</li><li>自定义响应格式: 通过别名修改返回数据中的字段名称，使其更符合客户端的需求</li></ul><h5 id="避免命名冲突"><a href="#避免命名冲突" class="headerlink" title="避免命名冲突"></a><p style='font-size: 14px'>避免命名冲突</p></h5><ul><li>当需要多次查询同一个字段的不同实例时，别名可以为每个字段调用提供不同的名称。例如</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">query &#123;</span><br><span class="line">  user1: user(id: &quot;1&quot;) &#123;</span><br><span class="line">    id</span><br><span class="line">    name</span><br><span class="line">    age</span><br><span class="line">  &#125;</span><br><span class="line">  user2: user(id: &quot;2&quot;) &#123;</span><br><span class="line">    id</span><br><span class="line">    name</span><br><span class="line">    age</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>user1</code>和<code>user2</code>是别名，用于区分<code>user</code>字段的两次调用, 这避免了因字段名称重复而导致的命名冲突</li></ul><h5 id="定义响应格式"><a href="#定义响应格式" class="headerlink" title="定义响应格式"></a><p style='font-size: 14px'>定义响应格式</p></h5><ul><li>别名可以改变返回数据中的字段名称，使其更符合业务需求或提高可读性</li></ul><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;user1&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Alice&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;age&quot;</span><span class="punctuation">:</span> <span class="number">30</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;user2&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Bob&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;age&quot;</span><span class="punctuation">:</span> <span class="number">25</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><ul><li><code>user1</code>和<code>user2</code>成为响应数据中的字段名称，分别包含两个不同用户的信息</li></ul><hr><h4 id="5-片段Fragments"><a href="#5-片段Fragments" class="headerlink" title="5. 片段Fragments"></a>5. 片段<code>Fragments</code></h4><p>片段 (<code>Fragments</code>) 是<code>GraphQL</code>中的一种机制，用于在多个查询或操作中重用一组字段选择。通过定义片段，可以减少字段的重复定义，提高查询的可读性和可维护性</p><h5 id="片段的语法"><a href="#片段的语法" class="headerlink" title="片段的语法"></a><p style='font-size: 14px'>片段的语法</p></h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fragment FragmentName on TypeName &#123;</span><br><span class="line">  field1</span><br><span class="line">  field2</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>FragmentName</code>: 片段的名称，用于在查询中引用片段</li><li><code>TypeName</code>: 片段适用的类型，指定字段所属的对象类型</li><li><code>field1, field2, ...</code>: 片段中包含的字段集合</li></ul><h5 id="片段的使用示例"><a href="#片段的使用示例" class="headerlink" title="片段的使用示例"></a><p style='font-size: 14px'>片段的使用示例</p></h5><p>假设我们有一个<code>User</code>类型，包含<code>id</code>、<code>name</code>和<code>age</code>字段，以下示例展示了如何定义和使用片段</p><ul><li>片段定义</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fragment UserFields on User &#123;</span><br><span class="line">  id</span><br><span class="line">  name</span><br><span class="line">  age</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>查询中使用片段</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">query &#123;</span><br><span class="line">  user1: user(id: &quot;1&quot;) &#123;</span><br><span class="line">    ...UserFields</span><br><span class="line">  &#125;</span><br><span class="line">  user2: user(id: &quot;2&quot;) &#123;</span><br><span class="line">    ...UserFields</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>返回结果</li></ul><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;user1&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Alice&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;age&quot;</span><span class="punctuation">:</span> <span class="number">30</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;user2&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Bob&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;age&quot;</span><span class="punctuation">:</span> <span class="number">25</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h5 id="嵌套片段"><a href="#嵌套片段" class="headerlink" title="嵌套片段"></a><p style='font-size: 14px'>嵌套片段</p></h5><p>片段可以嵌套使用，在一个片段中引用另一个片段，从而灵活地组织字段</p><ul><li>定义嵌套片段</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fragment AddressFields on Address &#123;</span><br><span class="line">  street</span><br><span class="line">  city</span><br><span class="line">  country</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fragment UserFields on User &#123;</span><br><span class="line">  id</span><br><span class="line">  name</span><br><span class="line">  age</span><br><span class="line">  address &#123;</span><br><span class="line">    ...AddressFields</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>查询中使用嵌套片段</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">query &#123;</span><br><span class="line">  user(id: &quot;1&quot;) &#123;</span><br><span class="line">    ...UserFields</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>返回结果</li></ul><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;user&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Alice&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;age&quot;</span><span class="punctuation">:</span> <span class="number">30</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;address&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;street&quot;</span><span class="punctuation">:</span> <span class="string">&quot;123 Main St&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;city&quot;</span><span class="punctuation">:</span> <span class="string">&quot;New York&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;country&quot;</span><span class="punctuation">:</span> <span class="string">&quot;USA&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h5 id="内联片段"><a href="#内联片段" class="headerlink" title="内联片段"></a><p style='font-size: 14px'>内联片段</p></h5><p>内联片段 (<code>Inline Fragments</code>) 是<code>GraphQL</code>中的一种机制，用于在查询中根据对象的实际类型动态选择字段。它们主要用于处理接口 (<code>Interface</code>) 或联合类型 (<code>Union Type</code>)，当返回的数据类型不确定时，可以根据具体类型选择不同的字段</p><ul><li><p>使用场景</p><ul><li>接口和联合类型: 如果查询的字段返回的是接口或联合类型，内联片段允许根据每种可能的类型指定不同的字段选择</li><li>类型检查: 可用于在查询中执行类型检查，根据实际类型动态返回字段</li></ul></li><li><p>语法: 内联片段使用<code>...</code>后跟随<code>on TypeName</code>，然后在<code>&#123;&#125;</code>中指定该类型的字段</p></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">... on TypeName &#123;</span><br><span class="line">  field1</span><br><span class="line">  field2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>Schema</code>示例: 假设有一个<code>Person</code>接口，两个实现类型<code>Employee</code>和<code>Customer</code></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">interface Person &#123;</span><br><span class="line">  id: ID!</span><br><span class="line">  name: String!</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Employee implements Person &#123;</span><br><span class="line">  id: ID!</span><br><span class="line">  name: String!</span><br><span class="line">  salary: Int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Customer implements Person &#123;</span><br><span class="line">  id: ID!</span><br><span class="line">  name: String!</span><br><span class="line">  purchaseHistory: [String]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Query &#123;</span><br><span class="line">  persons: [Person]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>查询示例: 根据<code>Person</code>的具体类型选择不同的字段</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">query &#123;</span><br><span class="line">  persons &#123;</span><br><span class="line">    id</span><br><span class="line">    name</span><br><span class="line">    ... on Employee &#123;</span><br><span class="line">      salary</span><br><span class="line">    &#125;</span><br><span class="line">    ... on Customer &#123;</span><br><span class="line">      purchaseHistory</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;persons&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">      <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Alice&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;salary&quot;</span><span class="punctuation">:</span> <span class="number">50000</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Bob&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;purchaseHistory&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;item1&quot;</span><span class="punctuation">,</span> <span class="string">&quot;item2&quot;</span><span class="punctuation">]</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><hr><h4 id="6-操作名称"><a href="#6-操作名称" class="headerlink" title="6. 操作名称"></a>6. 操作名称</h4><p>在<code>GraphQL</code>中，操作名称 (<code>Operation Name</code>) 是一个可选的标识，用于明确标注特定的查询 (<code>Query</code>)、变更 (<code>Mutation</code>) 或订阅 (<code>Subscription</code>) 操作的名称。它有助于提高可读性、调试效率，以及在某些工具中实现特定功能</p><h5 id="操作名称特点"><a href="#操作名称特点" class="headerlink" title="操作名称特点"></a><p style='font-size: 14px'>操作名称特点</p></h5><ul><li>操作名称的位置<ul><li>紧跟在操作类型（如<code>query</code>、<code>mutation</code>或<code>subscription</code>）之后</li></ul></li><li>命名规则<ul><li>名称只能包含字母、数字和下划线<code>(_)</code></li><li>名称不能以数字开头</li></ul></li><li>用途<ul><li>提供查询的上下文，明确查询意图</li><li>在调试、日志记录和工具（如<code>Apollo Client</code>）中，用于识别特定的操作</li><li>当一个请求中包含多个操作时，必须使用操作名称</li></ul></li></ul><h5 id="操作名称示例"><a href="#操作名称示例" class="headerlink" title="操作名称示例"></a><p style='font-size: 14px'>操作名称示例</p></h5><ul><li>查询示例: <code>GetUser</code>是操作名称，用于标识此查询操作</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">query GetUser &#123;</span><br><span class="line">  user(id: &quot;1&quot;) &#123;</span><br><span class="line">    id</span><br><span class="line">    name</span><br><span class="line">    age</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>变更示例: <code>CreateUser</code>是操作名称，表明此变更的目的为创建用户</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mutation CreateUser &#123;</span><br><span class="line">  createUser(name: &quot;Alice&quot;, age: 30) &#123;</span><br><span class="line">    id</span><br><span class="line">    name</span><br><span class="line">    age</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>多操作示例: 当一个请求中包含多个操作时，必须使用操作名称进行区分</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">query GetUser &#123;</span><br><span class="line">  user(id: &quot;1&quot;) &#123;</span><br><span class="line">    id</span><br><span class="line">    name</span><br><span class="line">    age</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mutation UpdateUser &#123;</span><br><span class="line">  updateUser(id: &quot;1&quot;, name: &quot;Alice&quot;) &#123;</span><br><span class="line">    id</span><br><span class="line">    name</span><br><span class="line">    age</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>匿名操作: 如果操作名称被省略，该操作称为匿名操作, 但在一个请求中不能包含多个匿名操作，因为没有操作名称用于区分</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">query &#123;</span><br><span class="line">  user(id: &quot;1&quot;) &#123;</span><br><span class="line">    id</span><br><span class="line">    name</span><br><span class="line">    age</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="7-操作类型"><a href="#7-操作类型" class="headerlink" title="7. 操作类型"></a>7. 操作类型</h4><p>在<code>GraphQL</code>中，操作类型 (<code>Operation Type</code>) 是指客户端可以在<code>API</code>请求中执行的三种操作: 查询 (<code>Query</code>)、变更 (<code>Mutation</code>) 和 订阅 (<code>Subscription</code>)。每种操作类型对应不同的用途，分别用于读取数据、修改数据和监听实时数据更新</p><h5 id="操作类型介绍"><a href="#操作类型介绍" class="headerlink" title="操作类型介绍"></a><p style='font-size: 14px'>操作类型介绍</p></h5><ul><li>查询 <code>Query</code><ul><li>用途: 用于读取和获取数据</li><li>特点: 不会对服务器数据产生任何修改，仅返回请求的数据 (类似于<code>REST API</code>的<code>GET</code>请求)</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">query &#123;</span><br><span class="line">  user(id: &quot;1&quot;) &#123;</span><br><span class="line">    id</span><br><span class="line">    name</span><br><span class="line">    age</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;!-- 查询 user 数据，根据参数 id: &quot;1&quot; 获取特定用户的信息 --&gt;</span><br><span class="line">&lt;!-- 返回的字段包括 id、name 和 age --&gt;</span><br></pre></td></tr></table></figure><ul><li>变更 <code>Mutation</code><ul><li>用途: 用于修改服务器上的数据，包括创建、更新或删除操作</li><li>特点: 与查询不同，变更操作会改变服务器的数据状态 (类似于<code>REST API</code>的<code>POST</code>、<code>PUT</code>、<code>PATCH</code>和 <code>DELETE</code>请求)</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mutation &#123;</span><br><span class="line">  createUser(name: &quot;Alice&quot;, age: 30) &#123;</span><br><span class="line">    id</span><br><span class="line">    name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;!-- 调用 createUser 变更操作，创建一个新用户 --&gt;</span><br><span class="line">&lt;!-- 参数 name 和 age 提供新用户的基本信息 --&gt;</span><br><span class="line">&lt;!-- 返回结果包括新用户的 id 和 name --&gt;</span><br></pre></td></tr></table></figure><ul><li>订阅 <code>Subscription</code><ul><li>用途: 用于监听服务器上的事件，并在事件发生时实时接收更新</li><li>特点: 用于实时数据更新场景，如实时聊天、股票行情等。订阅操作会保持一个持久的连接（通常使用<code>WebSocket</code>），当事件发生时，服务器会主动推送更新给客户端</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">subscription &#123;</span><br><span class="line">  userAdded &#123;</span><br><span class="line">    id</span><br><span class="line">    name</span><br><span class="line">    age</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;!-- 订阅 userAdded 事件，当有新用户被添加时，服务器会推送更新数据 --&gt;</span><br><span class="line">&lt;!-- 返回结果包含新用户的 id、name 和 age --&gt;</span><br></pre></td></tr></table></figure><h5 id="三种操作类型的比较"><a href="#三种操作类型的比较" class="headerlink" title="三种操作类型的比较"></a><p style='font-size: 14px'>三种操作类型的比较</p></h5><table><thead><tr><th><strong>操作类型</strong></th><th><strong>用途</strong></th><th><strong>是否修改数据</strong></th><th><strong>使用场景</strong></th></tr></thead><tbody><tr><td><strong>查询</strong></td><td>读取和获取数据</td><td>否</td><td>获取用户、产品列表、详情页数据</td></tr><tr><td><strong>变更</strong></td><td>修改服务器数据</td><td>是</td><td>创建、更新、删除资源</td></tr><tr><td><strong>订阅</strong></td><td>监听事件并实时接收数据更新</td><td>否</td><td>实时聊天、通知、数据流</td></tr></tbody></table><hr><h4 id="8-查询Query"><a href="#8-查询Query" class="headerlink" title="8. 查询Query"></a>8. 查询<code>Query</code></h4><p>查询 (<code>Query</code>) 是<code>GraphQL</code>中的一种操作类型，用于从服务器获取数据。它与传统<code>REST API</code>的<code>GET</code>请求类似，但在灵活性和强大性方面超越了后者</p><h5 id="查询的定义"><a href="#查询的定义" class="headerlink" title="查询的定义"></a><p style='font-size: 14px'>查询的定义</p></h5><ul><li>在<code>GraphQL</code>中，查询类型通常在<code>schema</code>中定义为<code>Query</code>类型。<code>Query</code>类型描述了所有可执行的查询操作</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type Query &#123;</span><br><span class="line">  user(id: ID!): User</span><br><span class="line">  users: [User]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type User &#123;</span><br><span class="line">  id: ID!</span><br><span class="line">  name: String!</span><br><span class="line">  age: Int</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="查询解析器Resolver"><a href="#查询解析器Resolver" class="headerlink" title="查询解析器Resolver"></a><p style='font-size: 14px'>查询解析器<code>Resolver</code></p></h5><ul><li>解析器负责实现字段的具体逻辑，定义如何获取数据。以下是查询解析器的示例</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> users = [</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="string">&#x27;1&#x27;</span>, <span class="attr">name</span>: <span class="string">&#x27;Alice&#x27;</span>, <span class="attr">age</span>: <span class="number">30</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="string">&#x27;2&#x27;</span>, <span class="attr">name</span>: <span class="string">&#x27;Bob&#x27;</span>, <span class="attr">age</span>: <span class="number">25</span> &#125;,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> resolvers = &#123;</span><br><span class="line">  <span class="title class_">Query</span>: &#123;</span><br><span class="line">    <span class="attr">user</span>: <span class="function">(<span class="params">parent, args, context, info</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> users.<span class="title function_">find</span>(<span class="function"><span class="params">user</span> =&gt;</span> user.<span class="property">id</span> === args.<span class="property">id</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">users</span>: <span class="function">() =&gt;</span> users,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><code>user</code>: 根据传入的<code>id</code>参数，从<code>users</code>列表中查找并返回对应用户</li><li><code>users</code>: 直接返回所有用户</li></ul><h5 id="查询的特点"><a href="#查询的特点" class="headerlink" title="查询的特点"></a><p style='font-size: 14px'>查询的特点</p></h5><ul><li>精确的数据获取: 客户端可以指定所需字段，避免传输多余数据</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">query &#123;</span><br><span class="line">  user(id: &quot;1&quot;) &#123;</span><br><span class="line">    name</span><br><span class="line">    age</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;user&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Alice&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;age&quot;</span><span class="punctuation">:</span> <span class="number">30</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><ul><li>单一请求: 在一个请求中获取多个资源的数据</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">query &#123;</span><br><span class="line">  user(id: &quot;1&quot;) &#123;</span><br><span class="line">    id</span><br><span class="line">    name</span><br><span class="line">  &#125;</span><br><span class="line">  users &#123;</span><br><span class="line">    id</span><br><span class="line">    name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;user&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Alice&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;users&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">      <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Alice&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Bob&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><hr><h4 id="9-变更Mutations"><a href="#9-变更Mutations" class="headerlink" title="9. 变更Mutations"></a>9. 变更<code>Mutations</code></h4><p>变更 (<code>Mutations</code>) 是<code>GraphQL</code>中的一种操作类型，专门用于对服务器端的数据进行修改操作。与查询 (<code>Query</code>) 仅用于读取数据不同，变更支持创建、更新或删除数据。每个变更操作都可以定义所需的输入参数和返回结果的结构</p><h5 id="变更的定义"><a href="#变更的定义" class="headerlink" title="变更的定义"></a><p style='font-size: 14px'>变更的定义</p></h5><ul><li>在<code>GraphQL</code>的<code>schema</code>中，变更类型通常定义在<code>Mutation</code>类型中，用来描述所有支持的数据修改操作</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type Mutation &#123;</span><br><span class="line">  createUser(name: String!, age: Int!): User</span><br><span class="line">  updateUser(id: ID!, name: String, age: Int): User</span><br><span class="line">  deleteUser(id: ID!): Boolean</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type User &#123;</span><br><span class="line">  id: ID!</span><br><span class="line">  name: String!</span><br><span class="line">  age: Int</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>createUser</code>: 接收<code>name</code>和<code>age</code>参数，返回新创建的<code>User</code>对象</li><li><code>updateUser</code>: 接收<code>id</code>（必需）、<code>name</code>和<code>age</code>参数，用于更新用户信息，返回更新后的<code>User</code></li><li><code>deleteUser</code>: 接收<code>id</code>参数，用于删除指定用户，返回布尔值表示操作是否成功</li></ul><h5 id="变更的解析器"><a href="#变更的解析器" class="headerlink" title="变更的解析器"></a><p style='font-size: 14px'>变更的解析器</p></h5><ul><li>解析器定义了如何执行变更操作，通常与数据库或其他数据存储交互</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; <span class="attr">v4</span>: uuidv4 &#125; = <span class="built_in">require</span>(<span class="string">&#x27;uuid&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> users = [</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="string">&#x27;1&#x27;</span>, <span class="attr">name</span>: <span class="string">&#x27;Alice&#x27;</span>, <span class="attr">age</span>: <span class="number">30</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="string">&#x27;2&#x27;</span>, <span class="attr">name</span>: <span class="string">&#x27;Bob&#x27;</span>, <span class="attr">age</span>: <span class="number">25</span> &#125;,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> resolvers = &#123;</span><br><span class="line">  <span class="title class_">Mutation</span>: &#123;</span><br><span class="line">    <span class="attr">createUser</span>: <span class="function">(<span class="params">parent, args, context, info</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> newUser = &#123;</span><br><span class="line">        <span class="attr">id</span>: <span class="title function_">uuidv4</span>(), <span class="comment">// 生成唯一 ID</span></span><br><span class="line">        <span class="attr">name</span>: args.<span class="property">name</span>,</span><br><span class="line">        <span class="attr">age</span>: args.<span class="property">age</span>,</span><br><span class="line">      &#125;;</span><br><span class="line">      users.<span class="title function_">push</span>(newUser); <span class="comment">// 添加到用户列表</span></span><br><span class="line">      <span class="keyword">return</span> newUser;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">updateUser</span>: <span class="function">(<span class="params">parent, args, context, info</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> user = users.<span class="title function_">find</span>(<span class="function"><span class="params">user</span> =&gt;</span> user.<span class="property">id</span> === args.<span class="property">id</span>);</span><br><span class="line">      <span class="keyword">if</span> (!user) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;User not found&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (args.<span class="property">name</span> !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">        user.<span class="property">name</span> = args.<span class="property">name</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (args.<span class="property">age</span> !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">        user.<span class="property">age</span> = args.<span class="property">age</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> user;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">deleteUser</span>: <span class="function">(<span class="params">parent, args, context, info</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> userIndex = users.<span class="title function_">findIndex</span>(<span class="function"><span class="params">user</span> =&gt;</span> user.<span class="property">id</span> === args.<span class="property">id</span>);</span><br><span class="line">      <span class="keyword">if</span> (userIndex === -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;User not found&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      users.<span class="title function_">splice</span>(userIndex, <span class="number">1</span>); <span class="comment">// 从列表中移除用户</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="变更的使用"><a href="#变更的使用" class="headerlink" title="变更的使用"></a><p style='font-size: 14px'>变更的使用</p></h5><p>客户端可以通过以下查询发送变更请求</p><ul><li>创建用户</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mutation &#123;</span><br><span class="line">  createUser(name: &quot;Alice&quot;, age: 30) &#123;</span><br><span class="line">    id</span><br><span class="line">    name</span><br><span class="line">    age</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;createUser&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;c81e728d-59f2-4d16-9f02-fcad84756789&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Alice&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;age&quot;</span><span class="punctuation">:</span> <span class="number">30</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><ul><li>更新用户</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mutation &#123;</span><br><span class="line">  updateUser(id: &quot;1&quot;, name: &quot;Alice Updated&quot;) &#123;</span><br><span class="line">    id</span><br><span class="line">    name</span><br><span class="line">    age</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;updateUser&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Alice Updated&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;age&quot;</span><span class="punctuation">:</span> <span class="number">30</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><ul><li>删除用户</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mutation &#123;</span><br><span class="line">  deleteUser(id: &quot;2&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;deleteUser&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><hr><h4 id="10-订阅Subscription"><a href="#10-订阅Subscription" class="headerlink" title="10. 订阅Subscription"></a>10. 订阅<code>Subscription</code></h4><p>订阅 (<code>Subscription</code>) 是<code>GraphQL</code>中的一种操作类型，允许客户端订阅服务器上的事件，并在事件发生时实时接收更新数据。这种机制特别适合实时更新场景，如聊天消息、通知、股票价格等</p><h5 id="订阅的工作原理"><a href="#订阅的工作原理" class="headerlink" title="订阅的工作原理"></a><p style='font-size: 14px'>订阅的工作原理</p></h5><ul><li>建立订阅连接: 客户端发送订阅请求到服务器，指定要订阅的事件或数据</li><li>保持连接: 服务器与客户端之间通过<code>WebSocket</code>或其他双向通信协议维持持久连接</li><li>事件触发: 当服务器端的事件发生变化（如新增或更新数据）时，触发对应的订阅逻辑</li><li>数据推送: 服务器将更新的数据通过连接推送到订阅的客户端</li></ul><h5 id="订阅示例"><a href="#订阅示例" class="headerlink" title="订阅示例"></a><p style='font-size: 14px'>订阅示例</p></h5><ul><li><code>Schema</code>定义</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type User &#123;</span><br><span class="line">  id: ID!</span><br><span class="line">  name: String!</span><br><span class="line">  age: Int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Subscription &#123;</span><br><span class="line">  userAdded: User</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Mutation &#123;</span><br><span class="line">  createUser(name: String!, age: Int!): User</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>Resolvers</code>实现</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; <span class="title class_">PubSub</span> &#125; = <span class="built_in">require</span>(<span class="string">&#x27;graphql-subscriptions&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> pubsub = <span class="keyword">new</span> <span class="title class_">PubSub</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> resolvers = &#123;</span><br><span class="line">  <span class="title class_">Subscription</span>: &#123;</span><br><span class="line">    <span class="attr">userAdded</span>: &#123;</span><br><span class="line">      <span class="comment">// 定义订阅器，监听 USER_ADDED 事件</span></span><br><span class="line">      <span class="attr">subscribe</span>: <span class="function">() =&gt;</span> pubsub.<span class="title function_">asyncIterator</span>([<span class="string">&#x27;USER_ADDED&#x27;</span>]),</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title class_">Mutation</span>: &#123;</span><br><span class="line">    <span class="attr">createUser</span>: <span class="function">(<span class="params">parent, args, context, info</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> newUser = &#123;</span><br><span class="line">        <span class="attr">id</span>: <span class="title function_">generateUniqueId</span>(),</span><br><span class="line">        <span class="attr">name</span>: args.<span class="property">name</span>,</span><br><span class="line">        <span class="attr">age</span>: args.<span class="property">age</span>,</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 保存用户数据（模拟数据库操作）</span></span><br><span class="line">      <span class="title function_">saveUserToDatabase</span>(newUser);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 触发 USER_ADDED 事件</span></span><br><span class="line">      pubsub.<span class="title function_">publish</span>(<span class="string">&#x27;USER_ADDED&#x27;</span>, &#123; <span class="attr">userAdded</span>: newUser &#125;);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> newUser;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>客户端订阅示例</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">subscription &#123;</span><br><span class="line">  userAdded &#123;</span><br><span class="line">    id</span><br><span class="line">    name</span><br><span class="line">    age</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>当有新用户通过<code>createUser</code>变更操作添加时，服务器会触发<code>userAdded</code>事件，客户端将接收到用户信息</li></ul><h5 id="Apollo-Client订阅"><a href="#Apollo-Client订阅" class="headerlink" title="Apollo Client订阅"></a><p style='font-size: 14px'><code>Apollo Client</code>订阅</p></h5><ul><li>配置<code>Apollo Client</code>: 创建一个支持查询、变更和订阅的客户端</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">ApolloClient</span>, <span class="title class_">InMemoryCache</span>, split &#125; <span class="keyword">from</span> <span class="string">&#x27;@apollo/client&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">WebSocketLink</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;@apollo/client/link/ws&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">HttpLink</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;@apollo/client&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; getMainDefinition &#125; <span class="keyword">from</span> <span class="string">&#x27;@apollo/client/utilities&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置 HTTP 链接用于查询和变更</span></span><br><span class="line"><span class="keyword">const</span> httpLink = <span class="keyword">new</span> <span class="title class_">HttpLink</span>(&#123; <span class="attr">uri</span>: <span class="string">&#x27;http://localhost:4000/graphql&#x27;</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置 WebSocket 链接用于订阅</span></span><br><span class="line"><span class="keyword">const</span> wsLink = <span class="keyword">new</span> <span class="title class_">WebSocketLink</span>(&#123;</span><br><span class="line">  <span class="attr">uri</span>: <span class="string">&#x27;ws://localhost:4000/graphql&#x27;</span>,</span><br><span class="line">  <span class="attr">options</span>: &#123;</span><br><span class="line">    <span class="attr">reconnect</span>: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 split 根据操作类型分别选择链接</span></span><br><span class="line"><span class="keyword">const</span> splitLink = <span class="title function_">split</span>(</span><br><span class="line">  <span class="function">(<span class="params">&#123; query &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> definition = <span class="title function_">getMainDefinition</span>(query);</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      definition.<span class="property">kind</span> === <span class="string">&#x27;OperationDefinition&#x27;</span> &amp;&amp;</span><br><span class="line">      definition.<span class="property">operation</span> === <span class="string">&#x27;subscription&#x27;</span></span><br><span class="line">    );</span><br><span class="line">  &#125;,</span><br><span class="line">  wsLink,</span><br><span class="line">  httpLink,</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 Apollo 客户端</span></span><br><span class="line"><span class="keyword">const</span> client = <span class="keyword">new</span> <span class="title class_">ApolloClient</span>(&#123;</span><br><span class="line">  <span class="attr">link</span>: splitLink,</span><br><span class="line">  <span class="attr">cache</span>: <span class="keyword">new</span> <span class="title class_">InMemoryCache</span>(),</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li>订阅操作: 使用<code>Apollo Client</code>的<code>useSubscription Hook</code>实现订阅</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; gql, useSubscription &#125; <span class="keyword">from</span> <span class="string">&#x27;@apollo/client&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">USER_ADDED_SUBSCRIPTION</span> = gql<span class="string">`</span></span><br><span class="line"><span class="string">  subscription OnUserAdded &#123;</span></span><br><span class="line"><span class="string">    userAdded &#123;</span></span><br><span class="line"><span class="string">      id</span></span><br><span class="line"><span class="string">      name</span></span><br><span class="line"><span class="string">      age</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">`</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">UserList</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; data, loading, error &#125; = <span class="title function_">useSubscription</span>(<span class="variable constant_">USER_ADDED_SUBSCRIPTION</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (loading) <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Loading...<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>;</span><br><span class="line">  <span class="keyword">if</span> (error) <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Error: &#123;error.message&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h2</span>&gt;</span>New User Added:<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>ID: &#123;data.userAdded.id&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>Name: &#123;data.userAdded.name&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>Age: &#123;data.userAdded.age&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">UserList</span>;</span><br></pre></td></tr></table></figure><ul><li>总而言之，<code>GraphQL</code>的<code>Subscription</code>依赖于<code>WebSocket</code>来实现。<code>WebSocket</code>提供了双向持久连接的能力，使得服务器能够在事件发生时立即向客户端推送数据，而<code>Subscription</code>则定义了这些事件和数据的结构。因此，<code>Subscription</code>不是替代<code>WebSocket</code>，而是利用<code>WebSocket</code>来实现特定的功能和需求</li></ul><hr><h3 id="GraphQL进阶"><a href="#GraphQL进阶" class="headerlink" title="GraphQL进阶"></a><code>GraphQL</code>进阶</h3><h4 id="11-变量-Variables"><a href="#11-变量-Variables" class="headerlink" title="11. 变量 Variables"></a>11. 变量 Variables</h4><p>在<code>GraphQL</code>中，变量 (<code>Variables</code>) 是一种机制，用于动态传递参数到查询 (<code>Query</code>)、变更 (<code>Mutation</code>) 或订阅 (<code>Subscription</code>) 中。通过使用变量，可以使查询更加灵活、可重用，并且避免将用户输入直接嵌入到查询字符串中，从而提升安全性和可读性</p><h5 id="变量的定义与使用"><a href="#变量的定义与使用" class="headerlink" title="变量的定义与使用"></a><p style='font-size: 14px'>变量的定义与使用</p></h5><ul><li>查询中的变量: 变量需要在查询语句中定义，并在执行查询时传入实际的值</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">query GetUser($id: ID!) &#123;</span><br><span class="line">  user(id: $id) &#123;</span><br><span class="line">    id</span><br><span class="line">    name</span><br><span class="line">    age</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;!-- $id 是一个变量，表示用户的 ID --&gt;</span><br><span class="line">&lt;!-- 变量的类型为 ID!，! 表示这是一个必需字段 --&gt;</span><br></pre></td></tr></table></figure><ul><li>变量在<code>React</code>中的使用: 使用<code>Apollo Client</code>的<code>useQuery Hook</code>动态传递变量值</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; gql, useQuery &#125; <span class="keyword">from</span> <span class="string">&#x27;@apollo/client&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义查询和变量</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">GET_USER</span> = gql<span class="string">`</span></span><br><span class="line"><span class="string">  query GetUser($id: ID!) &#123;</span></span><br><span class="line"><span class="string">    user(id: $id) &#123;</span></span><br><span class="line"><span class="string">      id</span></span><br><span class="line"><span class="string">      name</span></span><br><span class="line"><span class="string">      age</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">`</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">User</span>(<span class="params">&#123; userId &#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; loading, error, data &#125; = <span class="title function_">useQuery</span>(<span class="variable constant_">GET_USER</span>, &#123;</span><br><span class="line">    <span class="attr">variables</span>: &#123; <span class="attr">id</span>: userId &#125;, <span class="comment">// 动态传递变量值</span></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (loading) <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Loading...<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>;</span><br><span class="line">  <span class="keyword">if</span> (error) <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Error: &#123;error.message&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h2</span>&gt;</span>User Details<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>ID: &#123;data.user.id&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>Name: &#123;data.user.name&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>Age: &#123;data.user.age&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">User</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 变量`$id`的值由组件的`props`动态传递</span></span><br><span class="line"><span class="comment">// 查询使用`useQuery Hook`，并通过`variables`选项传递实际的变量值</span></span><br></pre></td></tr></table></figure><ul><li>变更中的变量: 在变更操作中，变量同样可以动态传递参数</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mutation CreateUser($name: String!, $age: Int!) &#123;</span><br><span class="line">  createUser(name: $name, age: $age) &#123;</span><br><span class="line">    id</span><br><span class="line">    name</span><br><span class="line">    age</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>Apollo Client</code>示例</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; gql, useMutation &#125; <span class="keyword">from</span> <span class="string">&#x27;@apollo/client&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">CREATE_USER</span> = gql<span class="string">`</span></span><br><span class="line"><span class="string">  mutation CreateUser($name: String!, $age: Int!) &#123;</span></span><br><span class="line"><span class="string">    createUser(name: $name, age: $age) &#123;</span></span><br><span class="line"><span class="string">      id</span></span><br><span class="line"><span class="string">      name</span></span><br><span class="line"><span class="string">      age</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">`</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">CreateUserForm</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [createUser, &#123; data, loading, error &#125;] = <span class="title function_">useMutation</span>(<span class="variable constant_">CREATE_USER</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">handleSubmit</span> = <span class="keyword">async</span> (<span class="params">e</span>) =&gt; &#123;</span><br><span class="line">    e.<span class="title function_">preventDefault</span>();</span><br><span class="line">    <span class="keyword">const</span> name = e.<span class="property">target</span>.<span class="property">name</span>.<span class="property">value</span>;</span><br><span class="line">    <span class="keyword">const</span> age = <span class="built_in">parseInt</span>(e.<span class="property">target</span>.<span class="property">age</span>.<span class="property">value</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">createUser</span>(&#123; <span class="attr">variables</span>: &#123; name, age &#125; &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (loading) <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Submitting...<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>;</span><br><span class="line">  <span class="keyword">if</span> (error) <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Error: &#123;error.message&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">form</span> <span class="attr">onSubmit</span>=<span class="string">&#123;handleSubmit&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;Name&quot;</span> <span class="attr">required</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;Age&quot;</span> <span class="attr">type</span>=<span class="string">&quot;number&quot;</span> <span class="attr">required</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span>Create User<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;data &amp;&amp; <span class="tag">&lt;<span class="name">p</span>&gt;</span>Created User: &#123;data.createUser.name&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span>&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">CreateUserForm</span>;</span><br></pre></td></tr></table></figure><hr><h4 id="12-指令-Directives"><a href="#12-指令-Directives" class="headerlink" title="12. 指令 Directives"></a>12. 指令 Directives</h4><p>指令 (<code>Directives</code>) 是<code>GraphQL</code>中的一种强大功能，用于动态影响查询、变更 (<code>Mutation</code>) 或订阅 (<code>Subscription</code>) 的执行行为。指令可以应用于字段、片段等，帮助客户端或服务器灵活调整查询结果的生成逻辑。例如，可以根据条件决定是否包含某字段或动态修改返回结果</p><h5 id="内置指令"><a href="#内置指令" class="headerlink" title="内置指令"></a><p style='font-size: 14px'>内置指令</p></h5><p><code>GraphQL</code>规范中定义了两个常用的内置指令: <code>@include</code>和<code>@skip</code></p><ul><li><code>@include</code>: 条件包含<ul><li>用于根据条件动态包含字段或片段</li><li>接受一个名为<code>if</code>的参数，该参数的值为布尔类型</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">query GetUser($withAge: Boolean!) &#123;</span><br><span class="line">  user(id: &quot;1&quot;) &#123;</span><br><span class="line">    id</span><br><span class="line">    name</span><br><span class="line">    age @include(if: $withAge)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;!-- 如果变量 $withAge 为 true，则返回结果中包含 age 字段 --&gt;</span><br><span class="line">&lt;!-- 如果 $withAge 为 false，则排除 age 字段 --&gt;</span><br></pre></td></tr></table></figure><ul><li><code>@skip</code>: 条件跳过<ul><li>用于根据条件跳过字段或片段</li><li>同样接受一个名为<code>if</code>的布尔参数</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">query GetUser($withoutAge: Boolean!) &#123;</span><br><span class="line">  user(id: &quot;1&quot;) &#123;</span><br><span class="line">    id</span><br><span class="line">    name</span><br><span class="line">    age @skip(if: $withoutAge)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;!-- 如果变量 $withoutAge 为 true，则跳过 age 字段 --&gt;</span><br><span class="line">&lt;!-- 如果 $withoutAge 为 false，则包含 age 字段 --&gt;</span><br></pre></td></tr></table></figure><h5 id="自定义指令"><a href="#自定义指令" class="headerlink" title="自定义指令"></a><p style='font-size: 14px'>自定义指令</p></h5><p>除了内置指令，<code>GraphQL</code>还支持自定义指令。这些指令可以用于更复杂的场景，比如数据验证、字段格式化等。自定义指令需要在<code>schema</code>中声明，并提供对应的实现逻辑</p><ul><li>自定义指令声明</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">directive @upper on FIELD_DEFINITION</span><br><span class="line"></span><br><span class="line">type Query &#123;</span><br><span class="line">  greeting: String @upper</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;!-- @upper 是一个自定义指令，应用在字段定义上 --&gt;</span><br><span class="line">&lt;!-- on FIELD_DEFINITION 指定了该指令适用于字段定义 --&gt;</span><br></pre></td></tr></table></figure><ul><li>自定义指令的实现: 使用<code>graphql-tools</code>创建一个<code>@upper</code>指令，将字符串字段的返回值转换为大写</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; <span class="title class_">SchemaDirectiveVisitor</span> &#125; = <span class="built_in">require</span>(<span class="string">&#x27;graphql-tools&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; defaultFieldResolver &#125; = <span class="built_in">require</span>(<span class="string">&#x27;graphql&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UpperCaseDirective</span> <span class="keyword">extends</span> <span class="title class_ inherited__">SchemaDirectiveVisitor</span> &#123;</span><br><span class="line">  <span class="title function_">visitFieldDefinition</span>(<span class="params">field</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; resolve = defaultFieldResolver &#125; = field;</span><br><span class="line"></span><br><span class="line">    field.<span class="property">resolve</span> = <span class="keyword">async</span> <span class="keyword">function</span> (<span class="params">...args</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> result = <span class="keyword">await</span> resolve.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args);</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> result === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> result.<span class="title function_">toUpperCase</span>();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="title class_">UpperCaseDirective</span>;</span><br></pre></td></tr></table></figure><ul><li>整合指令到<code>Schema</code>: 自定义指令<code>@upper</code>应用于<code>greeting</code>字段，返回的值将自动转换为大写</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; gql &#125; = <span class="built_in">require</span>(<span class="string">&#x27;apollo-server&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">UpperCaseDirective</span> = <span class="built_in">require</span>(<span class="string">&#x27;./UpperCaseDirective&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> typeDefs = gql<span class="string">`</span></span><br><span class="line"><span class="string">  directive @upper on FIELD_DEFINITION</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  type Query &#123;</span></span><br><span class="line"><span class="string">    greeting: String @upper</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">`</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> resolvers = &#123;</span><br><span class="line">  <span class="title class_">Query</span>: &#123;</span><br><span class="line">    <span class="attr">greeting</span>: <span class="function">() =&gt;</span> <span class="string">&quot;hello world&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; makeExecutableSchema &#125; = <span class="built_in">require</span>(<span class="string">&#x27;graphql-tools&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> schema = <span class="title function_">makeExecutableSchema</span>(&#123;</span><br><span class="line">  typeDefs,</span><br><span class="line">  resolvers,</span><br><span class="line">  <span class="attr">schemaDirectives</span>: &#123;</span><br><span class="line">    <span class="attr">upper</span>: <span class="title class_">UpperCaseDirective</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = schema;</span><br></pre></td></tr></table></figure><ul><li>客户端使用示例</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">query &#123;</span><br><span class="line">  greeting</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;greeting&quot;</span><span class="punctuation">:</span> <span class="string">&quot;HELLO WORLD&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><hr><h3 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h3><blockquote><p>参考文章: <a href="https://chenyitian.gitbooks.io/graphql/content/introduction.html">https://chenyitian.gitbooks.io/graphql/content/introduction.html</a><br>参考网站: <a href="https://www.howtographql.com/basics/0-introduction/">https://www.howtographql.com/basics/0-introduction/</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GraphQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GCP Cloud Digital Leader</title>
      <link href="/posts/88b435e5.html"/>
      <url>/posts/88b435e5.html</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p>官网: <a href="https://cloud.google.com/learn/certification/cloud-digital-leader">https://cloud.google.com/learn/certification/cloud-digital-leader</a></p></blockquote><hr><h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><h3 id="1-Regions-and-Zones"><a href="#1-Regions-and-Zones" class="headerlink" title="1. Regions and Zones"></a>1. Regions and Zones</h3><h4 id="Regions-and-Zones"><a href="#Regions-and-Zones" class="headerlink" title="Regions and Zones"></a>Regions and Zones</h4><ul><li>Google provide 20+ regions around the world</li><li>High Availability, Low Latency, Global Footprint, Government Regulation</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img234835.png"></p><ul><li>Each Region has three or more Zones</li><li>Advantage of Zones: Increase availability and fault tolerance</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img235111.png"></p><hr><h3 id="2-Compute"><a href="#2-Compute" class="headerlink" title="2. Compute"></a>2. Compute</h3><h4 id="Compute-Engine"><a href="#Compute-Engine" class="headerlink" title="Compute Engine"></a>Compute Engine</h4><ul><li><code>Compute Engine (GCE)</code>: Provision &amp; Manage Virtual Machines</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img160151.png"></p><ul><li>Create and manage lifecycle of VM instances</li><li>Load balancing and auto scaling for VM instances</li><li>Can attach storage, manage network connectivity and configuration</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img160329.png"></p><hr><h4 id="VM-Setup"><a href="#VM-Setup" class="headerlink" title="VM Setup"></a>VM Setup</h4><ul><li><code>Startup Script</code>: For boostrapping<ul><li>Install OS patches or software when an VM instance is launched</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img204439.png"></p><ul><li><code>Instance Templates</code>: Specify VM instance details<ul><li>Used to create VM instances and managed instance groups</li><li>Cannot be updated, need to be deleted and modified</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img161137.png"></p><ul><li><code>Custom Image</code>: Prefered way than Startup Script (推荐的做法)<ul><li>Can have OS patches and software pre-installed</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img161427.png"></p><hr><h4 id="Use-Discount"><a href="#Use-Discount" class="headerlink" title="Use Discount"></a>Use Discount</h4><ul><li><code>Sustained Use Discounts</code><ul><li>Automatic discounts for running VM instances for significant portion of the billing month (意思就是在一个月内使用这个 instance 到一定程度就可以获得 discount)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img161648.png"></p><ul><li><code>Committed Use Discounts</code><ul><li>1 year or 3 year reservations for workloads with predictable resource needs</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img93550.png"></p><hr><h4 id="Preemptible-VM"><a href="#Preemptible-VM" class="headerlink" title="Preemptible VM"></a>Preemptible VM</h4><ul><li><code>Preemptible VM</code>: Short-lived cheaper (up to 80%) compute instances for non time-critical, fault-tolerant workloads (只能存在 24 小时)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img40072.png"></p><hr><h4 id="Spot-VM"><a href="#Spot-VM" class="headerlink" title="Spot VM"></a>Spot VM</h4><ul><li><code>Spot VM</code>: Latest version of preemptible VM (这个就是 Spot Instance)</li><li>Does not have a maximum runtime, 没有 24 小时限制</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img29088.png"></p><hr><h4 id="Sole-Tenant-Nodes"><a href="#Sole-Tenant-Nodes" class="headerlink" title="Sole Tenant Nodes"></a>Sole Tenant Nodes</h4><ul><li><code>Sole Tenant Nodes</code>: 类似 Dedicated Host 或者 Dedicated Instance</li><li>Virtualized instances on hardware dedicated to one customer</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img79164.png"></p><hr><h4 id="Custom-Machine-Types"><a href="#Custom-Machine-Types" class="headerlink" title="Custom Machine Types"></a>Custom Machine Types</h4><ul><li><code>Custom Machine Types</code>: 可以自定义 CPU, memory, GPU</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img34118.png"></p><hr><h4 id="VM-costs"><a href="#VM-costs" class="headerlink" title="VM costs"></a>VM costs</h4><ul><li>2 primary costs in running VMs using GCE</li><li><code>Infrastructure</code> cost (VM) &amp; <code>Licensing</code> cost (OS)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img96529.png"></p><hr><h4 id="Instance-Groups"><a href="#Instance-Groups" class="headerlink" title="Instance Groups"></a>Instance Groups</h4><ul><li><code>Instance Group</code>: Group of VM instances managed as a single entity</li><li>Two Types of Instance Groups<ul><li><code>Managed</code>: Identical VMs created using a template</li><li><code>Unmanaged</code>: Different configuration for VMs in same group</li></ul></li><li>Location can be Zonal or Regional (Regional gives higher availability)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img100636.png"></p><hr><h4 id="Managed-Instance-Groups"><a href="#Managed-Instance-Groups" class="headerlink" title="Managed Instance Groups"></a>Managed Instance Groups</h4><ul><li><code>Managed Instance Groups</code>: Maintain certain number of instances<ul><li>Detect application failures using health check (self healing)</li><li>Increase and decrease instances based on load (auto scaling)</li><li>Add load balancer to distribute load</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img101512.png"></p><hr><h4 id="Cloud-Load-balancing"><a href="#Cloud-Load-balancing" class="headerlink" title="Cloud Load balancing"></a>Cloud Load balancing</h4><ul><li><code>Cloud Load balancing</code>: Distribute traffic across VM instances in one or more regions</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img211502.png"></p><hr><h4 id="Bare-Metal-Solution"><a href="#Bare-Metal-Solution" class="headerlink" title="Bare Metal Solution"></a>Bare Metal Solution</h4><ul><li><code>Bare Metal Solution</code> allows customers to run specialized workloads on dedicated hardware provided by Google Cloud. It enables <code>leverage of existing software licenses</code> and configurations without any modifications</li></ul><hr><h3 id="3-Managed-Services"><a href="#3-Managed-Services" class="headerlink" title="3. Managed Services"></a>3. Managed Services</h3><h4 id="IAAS-Infrastructure-as-a-Service"><a href="#IAAS-Infrastructure-as-a-Service" class="headerlink" title="IAAS (Infrastructure as a Service)"></a>IAAS (Infrastructure as a Service)</h4><ul><li>Use only infrastructure from cloud provider<ul><li>Using VM to deploy your applications or databases</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img214516.png"></p><hr><h4 id="PAAS-Platform-as-a-Service"><a href="#PAAS-Platform-as-a-Service" class="headerlink" title="PAAS (Platform as a Service)"></a>PAAS (Platform as a Service)</h4><ul><li>Use a platform provided by cloud<ul><li>You are responsible for Configuration and Application code</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img214802.png"></p><hr><h4 id="SAAS-Software-as-a-Service"><a href="#SAAS-Software-as-a-Service" class="headerlink" title="SAAS (Software as a Service)"></a>SAAS (Software as a Service)</h4><ul><li>Centrally hosted software (mostly on the cloyd), minimize the level of management<ul><li>Offered on a subscription basis (pay-as-you-go)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img301129.png"></p><hr><h4 id="Containers"><a href="#Containers" class="headerlink" title="Containers"></a>Containers</h4><ul><li>Container ensure we have one way of deploying any microservices</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img228435PM.png"></p><ul><li>Create Docker images for each microservice, include<ul><li>Application Runtime</li><li>Application code and Dependencies</li></ul></li><li>Runs the same way on any infrastructure</li><li>Advantage: light weight (No Guest OS), isolation for containers, cloud neutral</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img228438.png"></p><ul><li>Container Orchestration (Many build upon Kubernetes)<ul><li>Feature: Auto Scaling, Load Balancing, Self Healing, Fast Deployment</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img228442.png"></p><hr><h4 id="Serverless"><a href="#Serverless" class="headerlink" title="Serverless"></a>Serverless</h4><ul><li>Focus on code and the cloud managed service take cares of other stuffs</li><li>Pay for use</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img301125.png"></p><hr><h4 id="Shared-Responsibility-Model"><a href="#Shared-Responsibility-Model" class="headerlink" title="Shared Responsibility Model"></a>Shared Responsibility Model</h4><ul><li>Securiet in cloud is a Shared Responsibility</li><li><code>SaaS</code>: Content + Access Policies + Usage</li><li><code>PaaS</code>: SaaS + Deployment + Web Application Security</li><li><code>IaaS</code>: PaaS + Operations + Network Security + Guest OS</li><li>Google Cloud is always responsible for Hardware, Network, Audit Logging etc</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img301149.png"></p><hr><h4 id="GCP-Service-Category"><a href="#GCP-Service-Category" class="headerlink" title="GCP Service Category"></a>GCP Service Category</h4><ul><li>Compute Engine: <code>IAAS</code> (provide customize OS)</li><li>Google Kubernetes Engine: <code>CAAS</code></li><li>App Engine: <code>PAAS</code></li><li>Cloud Functions: <code>FAAS</code></li><li>Cloud Run: <code>CAAS</code> (run one container quickly)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img301158.png"></p><hr><h3 id="4-Managed-Compute-Service-in-GCP"><a href="#4-Managed-Compute-Service-in-GCP" class="headerlink" title="4. Managed Compute Service in GCP"></a>4. Managed Compute Service in GCP</h3><h4 id="App-Engine"><a href="#App-Engine" class="headerlink" title="App Engine"></a>App Engine</h4><ul><li><code>App Engine</code>: Simplest way to deploy and scale your applications in GCP<ul><li>Automatic load balancing &amp; auto scaling</li><li>Managed platform update &amp; health monitoring</li><li>Application versioning</li><li>Traffic splitting</li></ul></li><li>No usage charges -&gt; pay for resources provisioned</li><li><code>App Engine</code> does <code>not provide</code> the granular control over the virtual machine infrastructure</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img301220.png"></p><ul><li><code>Compute Engine</code> vs. <code>App Engine</code><ul><li>Compute Engine is <code>IAAS</code>, App Engine is <code>PAAS</code></li><li>App Engine is <code>serverless</code></li><li>Compute Engine you have more Responsibility than App Engine</li><li>App Engine is lower flexibility</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img301222.png"></p><hr><h4 id="App-Engine-Environments"><a href="#App-Engine-Environments" class="headerlink" title="App Engine Environments"></a>App Engine Environments</h4><ul><li><p><code>Standard</code>: Applications run in language specific sandboxes</p><ul><li>Run in language specific sandbox</li><li>Supports scale down to Zero instances</li></ul></li><li><p><code>Flexible</code>: Application instances run within Docker containers</p><ul><li>Support ANY runtime</li><li>CANNOT scale down to Zero instances</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img301229.png"></p><hr><h4 id="Google-Kubernetes-Engine-GKE"><a href="#Google-Kubernetes-Engine-GKE" class="headerlink" title="Google Kubernetes Engine (GKE)"></a>Google Kubernetes Engine (GKE)</h4><ul><li><code>Google Kubernetes Engine</code>: Managed Kubernetes service</li><li>Minimize operations with <code>auto-repair</code> (repair failed nodes) and <code>auto-upgrade</code> (use latest version of K8S always) features</li><li>Provides Pod and Cluster Autoscaling</li><li>Two Modes: <code>Standard</code> (You manage) &amp; <code>Autopilot</code> (GKE manage)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img301247.png"></p><hr><h4 id="Cloud-Functions-GCF"><a href="#Cloud-Functions-GCF" class="headerlink" title="Cloud Functions (GCF)"></a>Cloud Functions (GCF)</h4><ul><li><code>Cloud Functions</code>: Excute some code when an event happen</li><li>Don’t worry about servers or scaling or availability (only worry about your code)</li><li>Pay only for what you use</li><li><code>Time Bound</code> - Default 1 min and MAX 60 minutes(3600 seconds)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img301310.png"></p><hr><h4 id="Cloud-Run-amp-Anthos"><a href="#Cloud-Run-amp-Anthos" class="headerlink" title="Cloud Run &amp; Anthos"></a>Cloud Run &amp; Anthos</h4><ul><li><p><code>Cloud Run</code>: “Container to Production in Seconds”</p><ul><li>Fully managed serverless platform for containerized applications</li></ul></li><li><p><code>Cloud Run for Anthos</code>: Deploy your workloads to <code>Anthos</code> clusters running on-premises or on Google Cloud</p></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img301319.png"></p><hr><h4 id="Compute-Service-in-GCP"><a href="#Compute-Service-in-GCP" class="headerlink" title="Compute Service in GCP"></a>Compute Service in GCP</h4><ul><li>Create Virtual Machines: <code>Compute Engine</code></li><li>Create a group of similar VMs: <code>Managed Image Group</code></li><li>Distribute load among VMs: <code>Cloud Load Balancing</code></li><li>Simplify setting up web application: <code>App Engine</code></li><li>Easiest way to run one container: <code>Google Cloud Run</code></li><li>Orchestrate containers: <code>Google Kubernetes Engine</code></li><li>Build serverless event driven functions: <code>Cloud Functions</code></li><li>Manage multi-cloud and on-premise Kubernetes clusters: <code>Anthos</code></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img301324.png"></p><hr><h3 id="5-Storage"><a href="#5-Storage" class="headerlink" title="5. Storage"></a>5. Storage</h3><h4 id="Block-Storage-amp-File-Storage"><a href="#Block-Storage-amp-File-Storage" class="headerlink" title="Block Storage &amp; File Storage"></a>Block Storage &amp; File Storage</h4><p><code>Block Storage</code></p><ul><li>Persistent Disk: Network Block Storage (Zonal or Regional)</li><li>Local SSDs: Local Block Storage</li></ul><p><code>File Storage</code></p><ul><li>Filestore: High performance file storage</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/image/221039.png"></p><hr><h4 id="Cloud-Storage"><a href="#Cloud-Storage" class="headerlink" title="Cloud Storage"></a>Cloud Storage</h4><ul><li>Most popular, very flexible &amp; inexpensive storage service</li><li>Store large objects using a key-value approach (Object Storage)</li><li>Provides REST API to access and modify objects</li><li>Store all file types - text, binary, backup &amp; archives</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/image/221435.png"></p><hr><h4 id="Storage-Classes"><a href="#Storage-Classes" class="headerlink" title="Storage Classes"></a>Storage Classes</h4><ul><li>Different kinds of data can be stored in Cloud Storage<ul><li>Can I pay a cheaper price for objects I access less frequently</li></ul></li><li>Storage classes help to optimize your costs based on your access needs</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img302211.png"></p><ul><li><code>Standard</code>: Frequently used data&#x2F;Short period of time</li><li><code>Nearline storage</code>: Read or modify once a month on average (30 天内读写一次)</li><li><code>Coldline storage</code>: Read or modify at most once a quarter (90 天内读写一次)</li><li><code>Archive storage</code>: Less than once a year (365 天内读写一次)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img302214.png"></p><hr><h4 id="Object-Lifecycle-Management"><a href="#Object-Lifecycle-Management" class="headerlink" title="Object Lifecycle Management"></a>Object Lifecycle Management</h4><ul><li><p>How do you save costs by moving files automatically between storage classes</p><ul><li><code>Object Lifecycle Management</code></li></ul></li><li><p>Identify objects using conditions based on</p><ul><li>Age, CreatedBefore, IsLive, MatchesStorageClass, NumberOfNewerVersions</li><li>Set multiple conditions: all conditions must be satisfied for action to happen</li></ul></li><li><p>Two kinds of actions</p><ul><li><code>SetStorageClass actions</code> (change from one storage class to another)</li><li><code>Deletion actions</code> (delete objects)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img302224.png"><br><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img3022226.png"></p><hr><h4 id="Transferring-data-from-On-Premises-to-Cloud"><a href="#Transferring-data-from-On-Premises-to-Cloud" class="headerlink" title="Transferring data from On-Premises to Cloud"></a>Transferring data from On-Premises to Cloud</h4><ul><li>Most popular data destination is Google Cloud Storage<ul><li><code>Online Transfer</code>: Use gsutil or API to transfer data to Google Cloud Storage (data &lt; 1 TB or from on-premise)</li><li><code>Storage Transfer Service</code>: Recommended for large-scale (petabytes) online data transfers from your private data centers, AWS, Azure, and Google Cloud (data &gt; 1 TB or from another cloud)</li><li><code>Transfer Appliance</code>: Physical transfer using an appliance (data &gt; 20 TB or time &gt; 1 week)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img302228.png"></p><hr><h4 id="Storage-in-GCP"><a href="#Storage-in-GCP" class="headerlink" title="Storage in GCP"></a>Storage in GCP</h4><ul><li>A shared space for collaborating on <code>media</code> projects that involve large files: <code>Filestore</code> (File Storage)</li><li>A cost-effective solution to store and serve a large amount of <code>unstructured data</code> (Videos, Music, Files) globally: <code>Cloud Storage</code> (Object Storage)</li><li>Data is automatically managed and transitioned between <code>storage classes</code> to reduce costs: <code>Object Lifecycle Management</code> in Cloud Storage</li><li>A massive, one-time migration of data to the cloud, where online transfer is not feasible: Using <code>Transfer Appliance</code> for large- scale, physical data migration</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img302235.png"></p><hr><h3 id="6-Database-Fundamentals"><a href="#6-Database-Fundamentals" class="headerlink" title="6. Database Fundamentals"></a>6. Database Fundamentals</h3><h4 id="Cloud-SQL-amp-Cloud-Spanner-OLTP"><a href="#Cloud-SQL-amp-Cloud-Spanner-OLTP" class="headerlink" title="Cloud SQL &amp; Cloud Spanner (OLTP)"></a><code>Cloud SQL</code> &amp; <code>Cloud Spanner</code> (OLTP)</h4><ul><li><p>Applications where large number of users make large number of small transactions</p><ul><li>Popular databases: MySQL, Oracle, SQL Server etc</li></ul></li><li><p>Recommended Google Managed Services</p><ul><li><code>Cloud SQL</code>: Supports PostgreSQL, MySQL, and SQL Server for regional relational databases</li><li><code>Cloud Spanner</code>: <code>Unlimited scale</code> (multiple PBs) and 99.999% availability for global applications with horizontal scaling</li><li>Cloud Spanner replicates data across regions in real time</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img30224.png"></p><hr><h4 id="BigQuery-OLAP"><a href="#BigQuery-OLAP" class="headerlink" title="BigQuery (OLAP)"></a><code>BigQuery</code> (OLAP)</h4><ul><li><p>Applications allowing users to analyze petabytes of data</p><ul><li>Reporting applications, Data ware houses, Business intelligence applications, Analytics systems</li></ul></li><li><p>Recommended Google Managed Services</p><ul><li><code>BigQuery</code>: Petabyte-scale distributed data ware house</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img302253.png"></p><hr><h4 id="OLAP-vs-OLTP"><a href="#OLAP-vs-OLTP" class="headerlink" title="OLAP vs OLTP"></a><code>OLAP</code> vs <code>OLTP</code></h4><ul><li>OLAP and OLTP use similar data structures, but different in how data is stored</li><li>OLTP databases use <code>row</code> storage<ul><li>Efficient for processing small transactions</li></ul></li><li>OLAP databases use <code>columnar</code> storage<ul><li>High compression, Distribute data, Execute single query across multiple nodes</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img302258.png"></p><hr><h4 id="Cloud-Firestore-vs-BigTable-NOSQL"><a href="#Cloud-Firestore-vs-BigTable-NOSQL" class="headerlink" title="Cloud Firestore vs BigTable (NOSQL)"></a><code>Cloud Firestore</code> vs <code>BigTable</code> (NOSQL)</h4><ul><li>NoSQL databases trade-off “Strong consistency and SQL features” to achieve “scalability and high-performance”</li><li>NoSQL &#x3D; not only SQL</li><li>Google Managed Services: <code>Cloud Firestore (Datastore)</code> &amp; <code>BigTable</code></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img302303.png"></p><ul><li><p><code>Cloud Datastore</code> - Managed serverless NoSQL document database</p><ul><li>Designed for <code>transactional</code> mobile and web applications</li></ul></li><li><p><code>BigTable</code> - Managed, scalable NoSQL wide column database</p><ul><li>Recommended for <code>large analytical</code> (&gt; 10 TB) and operational workloads (not serverless)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img302305.png"></p><hr><h4 id="Memory-Store-In-memory-Databases"><a href="#Memory-Store-In-memory-Databases" class="headerlink" title="Memory Store (In-memory Databases)"></a><code>Memory Store</code> (In-memory Databases)</h4><ul><li>Retrieving data from memory is much faster than retrieving data from disk (Redis)</li><li>Recommended GCP Managed Service: <code>Memory Store</code></li><li>Use cases: Caching, session management, gaming leader boards, geospatial applications</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img302315.png"></p><hr><h4 id="Database-in-GCP"><a href="#Database-in-GCP" class="headerlink" title="Database in GCP"></a>Database in GCP</h4><p>Relational OLTP databases: <code>Cloud SQL</code>, <code>Cloud Spanner</code></p><ul><li>Have <code>predefined schema</code> and very <code>strong transcational</code> capabilities (<code>Row storage</code>)</li></ul><p>Relational OLAP databases: <code>BigQuery</code></p><ul><li><code>Columnar storage</code> with predefined schema. <code>Datawarehouse</code> &amp; <code>BigData</code> workloads</li></ul><p>NoSQL Databases: <code>Cloud Firestore (Datastore)</code>, <code>BigTable</code></p><ul><li>Apps that need quickly evolving structure (<code>schema-less</code>)</li></ul><p>In memory databases&#x2F;caches: <code>Memory Store</code></p><ul><li>Applications needing microsecond responses</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img302320.png"></p><hr><h3 id="7-IAM"><a href="#7-IAM" class="headerlink" title="7. IAM"></a>7. IAM</h3><h4 id="Cloud-IAM"><a href="#Cloud-IAM" class="headerlink" title="Cloud IAM"></a>Cloud IAM</h4><ul><li>How do you identify users in GCP?<ul><li>Identity and Access Management (<code>Cloud IAM</code>) provides this service</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img214925.png"></p><hr><h4 id="IAM-Example"><a href="#IAM-Example" class="headerlink" title="IAM Example"></a>IAM Example</h4><ul><li>Provide access to manage a specific cloud storage bucket to a colleague<ul><li>Choose a Role with right permissions (Ex: Storage Object Admin)</li><li>Create Policy binding member (your friend) with role (permissions)</li></ul></li><li>Roles: A set of permissions (to perform specific actions on specific resources)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img225829.png"></p><hr><h4 id="IAM-Roles"><a href="#IAM-Roles" class="headerlink" title="IAM Roles"></a>IAM Roles</h4><ul><li><code>Roles are Permissions</code>: Perform some set of actions on some set of resources<ul><li><code>Basic Roles</code> - Owner &#x2F; Editor &#x2F; Viewer</li><li><code>Predefined Roles</code> - Fine grained roles predefined and managed by Google</li><li><code>Custom Roles</code> - When predefined roles are NOT sufficient, you can create your own custom roles</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img223152.png"></p><hr><h4 id="IAM-Policy"><a href="#IAM-Policy" class="headerlink" title="IAM Policy"></a>IAM Policy</h4><ul><li>Roles are assigned to users through <code>IAM Policy documents</code></li><li>Represented by a policy object</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img192908.png"><br><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img193029.png"></p><hr><h3 id="8-Encryption"><a href="#8-Encryption" class="headerlink" title="8. Encryption"></a>8. Encryption</h3><h4 id="Data-Lifecycle-States"><a href="#Data-Lifecycle-States" class="headerlink" title="Data Lifecycle States"></a>Data Lifecycle States</h4><ul><li>Data at rest: Stored on a device or a backup</li><li>Data in motion: Being transferred across a network</li><li>Data in use: Active data processed in a non-persistent state</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img213355.png"></p><hr><h4 id="Encryption"><a href="#Encryption" class="headerlink" title="Encryption"></a>Encryption</h4><ul><li><code>Symmetric</code> Key Encryption</li><li>Use the same key for encryption and decryption</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img213908.png"></p><ul><li><code>Asymmetric</code> Key Encryption </li><li>Encrypt data with Public Key and decrypt with Private Key</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img213915.png"></p><hr><h4 id="Cloud-KMS"><a href="#Cloud-KMS" class="headerlink" title="Cloud KMS"></a>Cloud KMS</h4><ul><li><code>Cloud KMS</code>: Create and manage cryptographic keys (symmetric and asymmetric)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img214128.png"></p><hr><h3 id="9-Organizing-GCP-Resources"><a href="#9-Organizing-GCP-Resources" class="headerlink" title="9. Organizing GCP Resources"></a>9. Organizing GCP Resources</h3><h4 id="Resource-Hierarchy"><a href="#Resource-Hierarchy" class="headerlink" title="Resource Hierarchy"></a>Resource Hierarchy</h4><ul><li><code>Organization &gt; Folder &gt; Project &gt; Resources</code></li><li>Resources are created in projects</li><li>A Folder can contain multiple projects</li><li>Organization can contain multiple Folders</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/image/205244.png"></p><hr><h4 id="Billing-Accounts"><a href="#Billing-Accounts" class="headerlink" title="Billing Accounts"></a>Billing Accounts</h4><ul><li>Billing Account is mandatory for creating resources in a project</li><li>Setup a <code>Cloud Billing Budget</code> to avoid surprises - Alerts</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img215548.png"></p><hr><h4 id="IAM-Best-Practices"><a href="#IAM-Best-Practices" class="headerlink" title="IAM Best Practices"></a>IAM Best Practices</h4><ul><li><code>Principle of Least Privilege</code>: Give least possible privilege needed for a role</li><li><code>Separation of Duties</code>: Involve atleast 2 people in sensitive tasks</li><li><code>Constant Monitoring</code>: Review Cloud Audit Logs to audit changes to IAM policies and access to Service Account keys</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img215956.png"></p><hr><h4 id="Public-Private-Hybrid-Cloud"><a href="#Public-Private-Hybrid-Cloud" class="headerlink" title="Public, Private, Hybrid Cloud"></a>Public, Private, Hybrid Cloud</h4><ul><li><code>Public Cloud</code>: You host everything in the cloud<ul><li>DO NOT need a data center，NO Capital Expenditure needed</li><li>Hardware resources are owned by Google Cloud</li></ul></li><li><code>Private Cloud</code>: You host everything in your own data center<ul><li>Needs Capital Expenditure</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img220218.png"></p><ul><li><code>Hybrid Cloud</code>: Combination of both (Public &amp; Private)<ul><li>Use Public Cloud for some workloads and Private cloud for others</li></ul></li><li><code>Multi Cloud</code>: Using Multiple Cloud Platforms with&#x2F;without on￾premise infrastructure<ul><li>Reduces the likelihood of system failure during high-demand events by distributing the load and services across multiple cloud providers</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img220429.png"></p><hr><h4 id="Cloud-VPN"><a href="#Cloud-VPN" class="headerlink" title="Cloud VPN"></a>Cloud VPN</h4><ul><li><code>Cloud VPN</code>: Connect <code>on-premise network to the GCP</code> network<ul><li>Encrypted</li><li>For low bandwidth, Cloud VPN is recommended</li><li>注意, Cloud VPN 还是会经过 Public Internet, 如果不想经过 Public Internet, 选择Partner Interconnect connection</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img221047.png"></p><hr><h4 id="Cloud-Interconnect"><a href="#Cloud-Interconnect" class="headerlink" title="Cloud Interconnect"></a>Cloud Interconnect</h4><ul><li><code>Cloud Interconnect</code>: High speed physical connection between on-premise and VPC networks<ul><li>Highly available with high throughput</li><li>Use only for high bandwidth needs</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img221231.png"></p><hr><h4 id="Private-Google-Access"><a href="#Private-Google-Access" class="headerlink" title="Private Google Access"></a>Private Google Access</h4><ul><li><code>Private Google Access</code> allows instances in your VPC <code>without external IP addresses</code> to reach Google APIs and services using private IP addresses</li></ul><hr><h4 id="Network-Service-Tier"><a href="#Network-Service-Tier" class="headerlink" title="Network Service Tier"></a>Network Service Tier</h4><ul><li><p><code>Standard network service tier</code> can help reduce data traffic costs, designed to be a cost-effective solution for services where performance and latency are less critical</p></li><li><p><code>Premium network service tier</code> provides better performance, reliability, and lower latency by using Google’s private global network, is more expensive</p></li></ul><hr><h4 id="Organization-Policy-Service"><a href="#Organization-Policy-Service" class="headerlink" title="Organization Policy Service"></a>Organization Policy Service</h4><ul><li>How to enable centralized constraints on all resources created in an Organization?<ul><li>Configure Organization Policy</li></ul></li><li>Needs a Role - Organization Policy Administrator</li><li>IAM focuses on WHO, Organization Policy focuses on WHAT</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img222036.png"></p><hr><h4 id="Corporate-Directory-Federation"><a href="#Corporate-Directory-Federation" class="headerlink" title="Corporate Directory Federation"></a>Corporate Directory Federation</h4><ul><li>Federate Cloud Identity or Google Workspace with your external identity provider (IdP) such as Active Directory or Azure Active Directory</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img222636.png"></p><hr><h4 id="Identity-Aware-Proxy-IAP"><a href="#Identity-Aware-Proxy-IAP" class="headerlink" title="Identity Aware Proxy (IAP)"></a>Identity Aware Proxy (IAP)</h4><ul><li><p><code>Identity-Aware Proxy</code> (IAP) in your Google Cloud VPC network is primarily used for controlling access to your applications running on Google Cloud.</p></li><li><p>It provides secure, identity-based access to applications and VMs without needing to configure a VPN or manage firewall rules.</p></li></ul><hr><h4 id="Identity-Platform"><a href="#Identity-Platform" class="headerlink" title="Identity Platform"></a>Identity Platform</h4><ul><li><code>Identity Platform</code>: Customer identity and access management, handle user authentication, authorization, and user management</li><li>Difference between <code>Cloud IAM</code> and <code>Identity Platform</code><ul><li><code>Cloud IAM</code>: Employees and Partners Authorization</li><li><code>Identity Platform</code>: Customer identity and access management</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img222236.png"></p><hr><h3 id="10-DevOps"><a href="#10-DevOps" class="headerlink" title="10. DevOps"></a>10. DevOps</h3><h4 id="CI-CD-Tools"><a href="#CI-CD-Tools" class="headerlink" title="CI, CD Tools"></a>CI, CD Tools</h4><ul><li><code>Cloud Source Repositories</code>: Fully-featured, private Git repository</li><li><code>Container Registry</code>: Store your Docker images</li><li><code>Cloud Build</code>: Build deployable artifacts from your source code and configuration</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/image/224404.png"></p><hr><h4 id="Cloud-Build"><a href="#Cloud-Build" class="headerlink" title="Cloud Build"></a>Cloud Build</h4><ul><li><p><code>Cloud Build</code> is a fully managed continuous integration and continuous delivery (CI&#x2F;CD) platform on Google Cloud</p></li><li><p>It automates the process of building, testing, and deploying applications</p></li></ul><hr><h4 id="Cloud-Deployment-Manager"><a href="#Cloud-Deployment-Manager" class="headerlink" title="Cloud Deployment Manager"></a>Cloud Deployment Manager</h4><ul><li><p><code>Cloud Deployment Manager</code> is an infrastructure management service that automates the deployment and management of Google Cloud resources using <code>templates</code></p></li><li><p>Cloud Deployment Manager is <code>not</code> designed to automate the build and test processes</p></li></ul><hr><h4 id="Container-Registry-and-Artifact-Registry"><a href="#Container-Registry-and-Artifact-Registry" class="headerlink" title="Container Registry and Artifact Registry"></a>Container Registry and Artifact Registry</h4><ul><li><code>Container Registry</code>: Uses GCS bucket to store images, supports Container images only</li><li><code>Artifact Registry</code>: Evolution of Container Registry, manage BOTH container images and non-container artifacts</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/image/224539.png"></p><hr><h4 id="Infrastructure-as-code"><a href="#Infrastructure-as-code" class="headerlink" title="Infrastructure as code"></a>Infrastructure as code</h4><ul><li>Treat infrastructure the same way as application code</li><li>Bring repeatability into your infrastructure</li><li>GCP service: <code>Google Cloud Deployment Manager</code></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img326721.png"></p><hr><h4 id="Cloud-Operations-amp-Insights"><a href="#Cloud-Operations-amp-Insights" class="headerlink" title="Cloud Operations &amp; Insights"></a>Cloud Operations &amp; Insights</h4><ul><li>Monitoring - Metrics and Alerts: <code>Cloud Monitoring</code></li><li>Centralized Logging: <code>Cloud Logging</code></li><li>Audit Logging: <code>Cloud Audit Logs</code></li><li>Real-time exception monitoring: <code>Error Reporting</code></li><li>Live Debugging: <code>Cloud Debugger</code></li><li>Distributed tracing: <code>Cloud Trace</code></li><li>Statistical, low-overhead profiler: <code>Cloud Profiler</code></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img326823.png"></p><hr><h4 id="Site-Reliability-Engineering-SRE"><a href="#Site-Reliability-Engineering-SRE" class="headerlink" title="Site Reliability Engineering (SRE)"></a>Site Reliability Engineering (SRE)</h4><ul><li>SRE teams focus on every aspect of an application<ul><li>Manage by Service Level Objectives (SLOs)</li><li>Minimize Toil</li><li>Move Fast by Reducing Cost of Failure</li><li>Share Ownership with Developers</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img326826.png"></p><hr><h4 id="SRE-Key-Metrics"><a href="#SRE-Key-Metrics" class="headerlink" title="SRE - Key Metrics"></a>SRE - Key Metrics</h4><ul><li>Service Level Indicator(SLI): Quantitative measure of an aspect of a service<ul><li>Categories: availability, latency, throughput, durability, correctness (error rate)</li></ul></li><li>Service Level Objective (SLO) - SLI + target<ul><li>99.99% Availability, 99.999999999% Durability</li></ul></li><li>Service Level Agreement (SLA): SLO + consequences (contract)<ul><li>What is the consequence of NOT meeting an SLO? (Defined in a contract)</li></ul></li><li>Error budgets: (100% – SLO)<ul><li>How well is a team meeting their reliability objectives?</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img326829.png"></p><hr><h4 id="SRE-Best-Practices"><a href="#SRE-Best-Practices" class="headerlink" title="SRE - Best Practices"></a>SRE - Best Practices</h4><ul><li><code>Handling Excess Loads</code>: Load Shedding, Reduced Quality of Service</li><li><code>Avoiding Cascading Failures</code>: Plan to avoid thrashing</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img326832.png"></p><ul><li><code>Penetration Testing</code> (Ethical Hacking)</li><li><code>Load Testing</code> (JMeter, LoadRunner, Locust, Gatling etc)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img326333.png"></p><ul><li><code>Resilience Testing</code> - “How does an application behaves under stress?”</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img326834.png"></p><hr><h4 id="Single-Sign-On-SSO"><a href="#Single-Sign-On-SSO" class="headerlink" title="Single Sign-On (SSO)"></a>Single Sign-On (SSO)</h4><ul><li>With SSO in place, when an employee’s Active Directory account is terminated, they will no longer be able to authenticate and, consequently, will lose access to Google Workspace tools automatically</li></ul><hr><h4 id="Google-Cloud-Directory-Sync"><a href="#Google-Cloud-Directory-Sync" class="headerlink" title="Google Cloud Directory Sync"></a>Google Cloud Directory Sync</h4><ul><li><code>Google Cloud Directory Sync</code> (GCDS) is specifically designed to synchronize your existing <code>LDAP</code> directory with Google Cloud</li></ul><hr><h3 id="11-Pub-x2F-Sub"><a href="#11-Pub-x2F-Sub" class="headerlink" title="11. Pub&#x2F;Sub"></a>11. Pub&#x2F;Sub</h3><ul><li><code>Synchronous</code> Communication: Applications makes synchronous calls to the logging service (What if the logging service goes down?)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img329122.png"></p><ul><li><code>Asynchronous</code> Communication: Create a topic and have applications put log messages on the topic. Logging service picks them up for processing when ready</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img329123.png"></p><hr><h4 id="Pub-x2F-Sub"><a href="#Pub-x2F-Sub" class="headerlink" title="Pub&#x2F;Sub"></a>Pub&#x2F;Sub</h4><ul><li><code>Pub/Sub</code>: Reliable, scalable, fully-managed <code>asynchronous messaging service</code></li><li>Backbone for Highly Available and Highly Scalable Solutions</li><li>Event ingestion and delivery for streaming analytics pipelines</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img329125.png"></p><ul><li><code>Publisher</code> - Sender of a message</li><li><code>Subscriber</code> - Receiver of the message<ul><li><code>Pull</code> - Subscriber pulls messages when ready</li><li><code>Push</code> - Messages are sent to subscribers</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img329127.png"></p><hr><h4 id="Cloud-Dataflow"><a href="#Cloud-Dataflow" class="headerlink" title="Cloud Dataflow"></a>Cloud Dataflow</h4><ul><li><code>Cloud Dataflow</code> is a difficult service to describe<ul><li>Pub&#x2F;Sub &gt; Dataflow &gt; BigQuery (Streaming)</li><li>Pub&#x2F;Sub &gt; Dataflow &gt; Cloud Storage (Streaming - files)</li><li>Cloud Storage &gt; Dataflow &gt; Bigtable&#x2F;CloudSpanner&#x2F;Datastore&#x2F;BigQuery (Batch - Load data into databases)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img329132.png"></p><hr><h3 id="12-Data-Architectures-in-GCP"><a href="#12-Data-Architectures-in-GCP" class="headerlink" title="12. Data Architectures in GCP"></a>12. Data Architectures in GCP</h3><h4 id="Loose-Coupling-with-Pub-x2F-Sub"><a href="#Loose-Coupling-with-Pub-x2F-Sub" class="headerlink" title="Loose Coupling with Pub&#x2F;Sub"></a>Loose Coupling with Pub&#x2F;Sub</h4><ul><li>Whenever you want to decouple a publisher from a subscriber, consider <code>Pub/Sub</code></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img329137.png"></p><hr><h4 id="Date-Formats"><a href="#Date-Formats" class="headerlink" title="Date Formats"></a>Date Formats</h4><ul><li>Structured: Tables, Rows and Columns (Relational)<ul><li><code>Cloud SQL</code>, <code>Cloud Spanner</code>, <code>BigQuery</code></li></ul></li><li>Semi Structured: Flexible Schema<ul><li><code>Cloud Firestore/Datastore</code></li></ul></li><li>Unstructured: Video, Audio, Image, Text, Binary files<ul><li><code>Cloud Storage</code></li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img329124.png"></p><hr><h4 id="Cloud-Dataproc"><a href="#Cloud-Dataproc" class="headerlink" title="Cloud Dataproc"></a>Cloud Dataproc</h4><ul><li><code>Cloud Dataproc</code>: Managed Spark and Hadoop service</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img329211.png"></p><hr><h4 id="Big-Data-Flow-Batch-Ingest"><a href="#Big-Data-Flow-Batch-Ingest" class="headerlink" title="Big Data Flow - Batch Ingest"></a>Big Data Flow - Batch Ingest</h4><ul><li>Use extract, transform, and load (ETL) to load data into BigQuery</li><li><code>Dataprep</code>: Clean and prepare data</li><li><code>Dataflow</code>: Create data pipelines (and ETL)</li><li><code>Dataproc</code>: Complex processing using Spark and Hadoop</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img329213.png"></p><hr><h4 id="Steaming-Data"><a href="#Steaming-Data" class="headerlink" title="Steaming Data"></a>Steaming Data</h4><ul><li><code>Pub/Sub</code>: Receive messages</li><li><code>Dataflow</code>: Analyze, aggregate andfilter data</li><li>For pre-defined time series analytics, storing data in <code>Bigtable</code></li><li>For ad hoc complex analysis, prefer <code>BigQuery</code></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img329215.png"></p><hr><h4 id="IOT"><a href="#IOT" class="headerlink" title="IOT"></a>IOT</h4><ul><li><code>IoT Core</code>: Manage IoT (registration, authentication, and authorization) devices</li><li><code>Pub/Sub</code>: Durable message ingestion service (allows buffering)</li><li><code>Dataflow</code>: Processing data (ETL &amp; more..)</li><li>Data Storage and Analytics:<ul><li>Make IOT data available to mobile or web apps &#x3D;&gt; <code>Datastore</code></li><li>Execute pre-defined time series queries &#x3D;&gt; <code>Bigtable</code></li><li>More complex or ad hoc analytics&#x2F;analysis &#x3D;&gt; <code>BigQuery</code></li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img329216.png"></p><hr><h4 id="Data-Lake"><a href="#Data-Lake" class="headerlink" title="Data Lake"></a>Data Lake</h4><ul><li>Single platform with combination of solutions for data storage, data management and data analytics</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img329228.png"></p><ul><li>Storage<ul><li><code>Cloud Storage</code> (low cost + durability + performance + flexible processing)</li></ul></li><li>Data Ingestion<ul><li>Streaming data - <code>Cloud Pub/Sub</code> + <code>Cloud Dataflow</code></li><li>Batch - Transfer Service + Transfer Appliance + gsutil</li></ul></li><li>Processing and analytics<ul><li>Run in-place querying using SQL queries using <code>BigQuery</code> or (Hive on Dataproc)</li></ul></li><li>Data Mining and Exploration<ul><li>Clean and transform raw data with <code>Dataprep</code></li><li>Use <code>Cloud Datalab</code> (data science libraries such as TensorFlow and NumPy) for exploring</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img329220.png"></p><hr><h4 id="Data-Governance"><a href="#Data-Governance" class="headerlink" title="Data Governance"></a>Data Governance</h4><ul><li>Bad data: Bad data leads to poor business decisions</li><li>Data leaks: Data leaks can lead to a reputation loss</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img329222.png"></p><hr><h4 id="Dataplex"><a href="#Dataplex" class="headerlink" title="Dataplex"></a>Dataplex</h4><ul><li><code>Dataplex</code> is a Data Mesh: Unified dashboard with visibility into all data assets (data lakes, data warehouses, ..)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img329224.png"></p><hr><h3 id="13-API-Management-in-GCP"><a href="#13-API-Management-in-GCP" class="headerlink" title="13. API Management in GCP"></a>13. API Management in GCP</h3><h4 id="API-Management"><a href="#API-Management" class="headerlink" title="API Management"></a>API Management</h4><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img329226.png"></p><ul><li><code>Apigee API Management</code>: Comprehensive API management platform</li><li><code>Cloud Endpoints</code>: Basic API Management for Google Cloud backends</li><li><code>API gateway</code>: Newer, Simpler API Management for Google Cloud backends</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img329229.png"></p><hr><h3 id="14-Trust-and-Security-with-GCP"><a href="#14-Trust-and-Security-with-GCP" class="headerlink" title="14. Trust and Security with GCP"></a>14. Trust and Security with GCP</h3><h4 id="Cloud-Security"><a href="#Cloud-Security" class="headerlink" title="Cloud Security"></a>Cloud Security</h4><ul><li><code>Control</code>: Decide who gets access</li><li><code>Compliance</code>: Follows legal rules</li><li><code>Confidentiality</code>: Keeps information secret</li><li><code>Integrity</code>: Ensures data stays accurate</li><li><code>Availability</code>: Ensure apps &amp; data are available always</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img329315.png"></p><hr><h4 id="Enhanced-Security-with-2SV"><a href="#Enhanced-Security-with-2SV" class="headerlink" title="Enhanced Security with 2SV"></a>Enhanced Security with 2SV</h4><ul><li>2 Step Verification (2SV): Add a 2nd step to verify user</li><li>Make 2SV Mandatory: For Google Cloud accounts</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img329317.png"></p><hr><h4 id="Security-Command-Center"><a href="#Security-Command-Center" class="headerlink" title="Security Command Center"></a>Security Command Center</h4><ul><li><p>·Security Command Center· (SCC) in Google Cloud Platform (GCP) is designed to provide a comprehensive view of the security state of your GCP resources, including virtual machines</p></li><li><p>It enables you to detect and respond to threats, ensures <code>compliance</code> by reporting on security findings, and offers insights into the security status of your resources across multiple projects</p></li></ul><hr><h4 id="Google-Cloud-Armor"><a href="#Google-Cloud-Armor" class="headerlink" title="Google Cloud Armor"></a>Google Cloud Armor</h4><ul><li><code>Google Cloud Armor</code> is a service designed to <code>protect web applications from DDoS</code> attacks and other web-based threats. It offers features like IP blacklisting&#x2F;whitelisting, rate limiting, and application-layer traffic monitoring</li></ul><hr><h4 id="Cloud-Data-Loss-Prevention"><a href="#Cloud-Data-Loss-Prevention" class="headerlink" title="Cloud Data Loss Prevention"></a>Cloud Data Loss Prevention</h4><ul><li><code>Cloud Data Loss Prevention</code> (DLP) is specifically designed to identify, classify, and help protect sensitive information, including <code>PII</code></li></ul><hr><h4 id="GCP-Security-Offerings"><a href="#GCP-Security-Offerings" class="headerlink" title="GCP Security Offerings"></a>GCP Security Offerings</h4><ul><li><code>KMS</code>: Create and manage cryptographic keys (symmetric and asymmetric). Control their use in your applications and GCP Services</li><li><code>Secret Manager</code>: Manage your database passwords, your API keys securely</li><li><code>Cloud Data Loss Prevention</code>: Discover, classify, &amp; mask sensitive data</li><li><code>Cloud Armor</code>: Protect your production apps (at run time) from denial of service and common web attacks</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img329326.png"></p><ul><li><code>Web Security Scanner</code>: Identify vulnerabilities by running security tests</li><li><code>Binary Authorization</code>: Ensure that only trusted container images are deployed to Google Cloud</li><li><code>Container Threat Detection</code>: Detects container runtime attacks</li><li><code>Security Command Center</code>: Get a consolidated picture of security in Google Cloud</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img329328.png"></p><hr><h4 id="Zero-Trust-Security-Model"><a href="#Zero-Trust-Security-Model" class="headerlink" title="Zero Trust Security Model"></a>Zero Trust Security Model</h4><ul><li>Zero Trust - “No person or device should be trusted by default, even if they are already inside an organization’s network”</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img329329.png"></p><hr><h3 id="15-ML-in-GCP"><a href="#15-ML-in-GCP" class="headerlink" title="15. ML in GCP"></a>15. ML in GCP</h3><h4 id="ML-in-GCP-Pre-Trained"><a href="#ML-in-GCP-Pre-Trained" class="headerlink" title="ML in GCP - Pre-Trained"></a>ML in GCP - Pre-Trained</h4><ul><li><code>Speech-to-Text API</code>: convert speech into text</li><li><code>Text-to-Speech API</code>: convert text into speech</li><li><code>Translation API</code>: Translate texts into more than one hundred languages</li><li><code>Natural Language API</code>: Derive insights from unstructured text</li><li><code>Cloud Vision API</code>: Recommended for generic usecases</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img329333.png"></p><hr><h4 id="ML-in-GCP-Custom-Models"><a href="#ML-in-GCP-Custom-Models" class="headerlink" title="ML in GCP - Custom Models"></a>ML in GCP - Custom Models</h4><ul><li><code>AutoML</code>: Build custom models with minimum ML expertise and effort<ul><li><code>AutoML Vision</code>: Build custom models based on Images</li><li><code>AutoML Video Intelligence</code>: Add labels to Video</li><li><code>AutoML Tables</code>: Automatically build models on structured data</li></ul></li><li><code>BigQuery ML</code>: Build ML models using Queries</li><li><code>Vertex AI</code>: Build &amp; deploy ML models faster</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img329325.png"></p><ul><li>AutoML Vision is ideal for scenarios where there is a <code>need to create specialized image recognition models</code> tailored to specific use cases</li></ul><hr><h3 id="16-Cloud-Native"><a href="#16-Cloud-Native" class="headerlink" title="16. Cloud Native"></a>16. Cloud Native</h3><h4 id="Cloud-Native-Pillars"><a href="#Cloud-Native-Pillars" class="headerlink" title="Cloud Native Pillars"></a>Cloud Native Pillars</h4><ul><li><code>Microservices</code>: Fix issues and deliver new features quickly</li><li><code>Containers</code>: Portable &amp; Lightweight</li><li><code>Container Orchestration</code>: Kubernetes (GKE) - Auto Scaling, Load Balancing, Self Healing, Zero Downtime Deployment etc</li><li><code>DevOps</code> (Dev + Ops, CI&#x2F;CD, IaC): Increased automation of processes</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img329342.png"></p><hr><h4 id="Container-Compute-Examples"><a href="#Container-Compute-Examples" class="headerlink" title="Container Compute Examples"></a>Container Compute Examples</h4><ul><li><code>Cloud Run</code>: Develop and deploy highly scalable containerized applications</li><li><code>Google Kubernetes Engine</code>: Orchestrate containerized microservices on Kubernetes</li><li><code>Anthos</code>: Manage Kubernetes Clusters in Multi-cloud and On-premises</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img329344.png"></p><hr><h4 id="Serverless-Examples"><a href="#Serverless-Examples" class="headerlink" title="Serverless Examples"></a>Serverless Examples</h4><ul><li><code>Cloud Functions</code>: Serverless compute for event-driven apps</li><li><code>Cloud Run</code>: Run isolated containers, without orchestration (Serverless)</li><li><code>Cloud Firestore</code>: Apps needing quickly evolving structure (schema-less)</li><li><code>Cloud Dataflow</code>: Serverless Stream and Batch processing using Apache Beam </li><li><code>Cloud Pub/Sub</code>: Realtime Messaging in the cloud. Pay for number of messages</li><li><code>BigQuery</code>: Relational OLAP, Data warehousing &amp; BigData workloads</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img329346.png"></p><hr><h3 id="17-Cost-Management-in-GCP"><a href="#17-Cost-Management-in-GCP" class="headerlink" title="17. Cost Management in GCP"></a>17. Cost Management in GCP</h3><h4 id="CapEx-vs-OpEx"><a href="#CapEx-vs-OpEx" class="headerlink" title="CapEx vs OpEx"></a>CapEx vs OpEx</h4><ul><li>Capital Expenditure (<code>CapEx</code>): Money spent to buy infrastructure</li><li>Operational Expenditure (<code>OpEx</code>): Money spent to use a service or a product</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img329400.png"></p><hr><h4 id="Pricing-Calculator"><a href="#Pricing-Calculator" class="headerlink" title="Pricing Calculator"></a>Pricing Calculator</h4><ul><li><code>Pricing Calculator</code>: Estimating the cost of a Google Cloud solution</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img329402.png"></p><hr><h4 id="GCP-Cost-Management"><a href="#GCP-Cost-Management" class="headerlink" title="GCP Cost Management"></a>GCP Cost Management</h4><ul><li><code>Cost Management</code>: Tools for monitoring, controlling, and optimizing your costs</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img329404.png"></p><hr><h4 id="Billing-dashboards"><a href="#Billing-dashboards" class="headerlink" title="Billing dashboards"></a>Billing dashboards</h4><ul><li>Billing dashboards in Google Cloud provide a comprehensive overview of cloud spending</li></ul><hr><h4 id="Resource-labels"><a href="#Resource-labels" class="headerlink" title="Resource labels"></a>Resource labels</h4><ul><li>Resource labels enable users to tag cloud resources with key-value pairs, which can then be used to filter and organize cost data</li></ul><hr><h3 id="18-GCP-review"><a href="#18-GCP-review" class="headerlink" title="18. GCP review"></a>18. GCP review</h3><h4 id="Basic-Compute-Services"><a href="#Basic-Compute-Services" class="headerlink" title="Basic Compute Services"></a>Basic Compute Services</h4><ul><li><code>Compute Engine</code>: Use VMs when you need control over OS OR you want to run custom software</li><li><code>Preemptible VMs</code>: Short lived VMs for non time-critical workloads</li><li><code>Sole-tenant Nodes </code>: Dedicated physical servers</li><li><code>VMware Engine</code>: Run VMware workloads in Google Cloud</li><li><code>Managed Instance Groups</code>: Create multiple Compute Engine VMs</li><li><code>Cloud Load Balancing</code>: Balance load to multiple instances of an application or a service</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img182332.png"></p><hr><h4 id="Firebase"><a href="#Firebase" class="headerlink" title="Firebase"></a>Firebase</h4><ul><li><code>Firebase</code> is a comprehensive cloud-based platform ideal for building web and mobile applications</li><li>Firebase is designed to handle dynamic content and user interactions seamlessly, providing an integrated backend-as-a-service (BaaS) solution that reduces the need for managing servers and infrastructure</li></ul><hr><h4 id="Managed-Compute-Services"><a href="#Managed-Compute-Services" class="headerlink" title="Managed Compute Services"></a>Managed Compute Services</h4><ul><li><code>App Engine</code>: PaaS. Deploy web apps and RESTful APIs quickly</li><li><code>Cloud Run</code>: Run isolated containers, without orchestration (Serverless)</li><li><code>Kubernetes Engine</code>: Managed Kubernetes Service. Provides container orchestration</li><li><code>Cloud Functions</code>: Serverless compute for event-driven apps</li><li><code>Anthos</code>: Manage Kubernetes Clusters in Multi-cloud and On-premises</li><li><code>Firebase</code>: Google’s mobile platform. Build Apps for iOS, Android, the web, C++, and Unity</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img182553.png"></p><hr><h4 id="Storage"><a href="#Storage" class="headerlink" title="Storage"></a>Storage</h4><ul><li><code>Persistent Disk</code>: Block Storage for your VMs</li><li><code>Local SSD</code>: Local ephemeral block storage for your VMs</li><li><code>Cloud Filestore</code>: File shares in the cloud</li><li><code>Cloud Storage</code>: Object storage in the cloud</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img182703.png"></p><hr><h4 id="Databases"><a href="#Databases" class="headerlink" title="Databases"></a>Databases</h4><ul><li><code>Cloud SQL</code>: Regional Relational OLTP database (MySQL, PostgreSQL, SQL server)</li><li><code>Cloud Spanner</code>: Global Relational OLTP database. Unlimited scale and 99.999% availability for global applications with horizontal scaling</li><li><code>Cloud Firestore</code>: Apps needing quickly evolving structure (schema-less)</li><li><code>Cloud BigTable</code>: Large databases(10 TB - PBs). Streaming (IOT), analytical &amp; operational workloads. NOT serverless</li><li><code>Cloud Memorystore</code>: In memory databases&#x2F;cache. Applications needing microsecond responses</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img182848.png"></p><hr><h4 id="Streams-Analytics-Big-Data"><a href="#Streams-Analytics-Big-Data" class="headerlink" title="Streams, Analytics, Big Data"></a>Streams, Analytics, Big Data</h4><ul><li><code>Cloud Pub/Sub</code>: Realtime Messaging in the cloud</li><li><code>BigQuery</code>: Relational OLAP databases. Datawarehousing &amp; BigData workloads</li><li><code>BigQuery ML</code>: Simplified Machine Learning using data in BigQuery</li><li><code>Cloud Dataflow</code>: Serverless Stream and Batch processing using Apache Beam (open-source)</li><li><code>Cloud Dataproc</code>: Managed Service for Spark and Hadoop. Not serverless</li><li><code>Cloud Data Fusion</code>: Visually manage your data pipelines</li><li><code>Data Studio</code>: Visualize data</li><li><code>Looker</code>: Enterprise Business Intelligence</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img185343.png"></p><hr><h4 id="Migration"><a href="#Migration" class="headerlink" title="Migration"></a>Migration</h4><ul><li><code>Database Migration Service</code>: Migrate to Cloud SQL</li><li><code>Storage Transfer Service</code>: Online Transfer to Cloud Storage</li><li><code>Transfer Appliance</code>: Physical transfer using an appliance</li><li><code>Migrate for Compute Engine</code>: Migrate VMs and VM storage to GCE</li><li><code>Migrate for Anthos</code>: Migrate VMs to GKE containers</li><li><code>BigQuery Data Transfer Service</code>: Migrate your analytics data</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img185525.png"></p>]]></content>
      
      
      <categories>
          
          <category> Certification </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GCP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS 学习笔记</title>
      <link href="/posts/eb0c992c.html"/>
      <url>/posts/eb0c992c.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>参考文章: <a href="https://juejin.cn/post/6941206439624966152">https://juejin.cn/post/6941206439624966152</a></p></blockquote><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><h3 id="CSS选择器"><a href="#CSS选择器" class="headerlink" title="CSS选择器"></a><code>CSS</code>选择器</h3><h4 id="基础选择器"><a href="#基础选择器" class="headerlink" title="基础选择器"></a>基础选择器</h4><ul><li>标签选择器: <code>h1</code></li><li>类选择器: <code>.checked</code></li><li><code>ID</code>选择器: <code>#picker</code></li><li>通配选择器: <code>*</code></li></ul><h4 id="属性选择器"><a href="#属性选择器" class="headerlink" title="属性选择器"></a>属性选择器</h4><blockquote><p>可以看看这篇文章: <a href="https://juejin.cn/post/6844903870171201549">https://juejin.cn/post/6844903870171201549</a></p></blockquote><ul><li><code>[attr]</code>: 选择包含某个属性的所有元素，而不关心属性值</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;Enter your name&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-tag">input</span><span class="selector-attr">[placeholder]</span> &#123; <span class="attribute">border</span>: <span class="number">2px</span> solid blue; &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 选中所有带有 placeholder 属性的 input 元素（第一个 input） --&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>[attr=val]</code>: 选择属性值完全等于指定值的所有元素</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;Enter your name&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;email&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-tag">input</span><span class="selector-attr">[type=<span class="string">&quot;password&quot;</span>]</span> &#123; <span class="attribute">background-color</span>: lightgray; &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 仅选中 type=&quot;password&quot; 的 input 元素 --&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>[attr*=val]</code>: 选择属性值中<ins>包含</ins>指定值的所有元素</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://google.com&quot;</span>&gt;</span>Google<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://github.com&quot;</span>&gt;</span>GitHub<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;mailto:support@example.com&quot;</span>&gt;</span>Email Support<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-tag">a</span><span class="selector-attr">[href*=<span class="string">&quot;google&quot;</span>]</span> &#123; <span class="attribute">color</span>: red; &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 选中 href 属性中包含 &quot;google&quot; 的 &lt;a&gt; 元素 --&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>[attr^=val]</code>: 选择属性值以指定字符串<ins>开头</ins>的所有元素</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://google.com&quot;</span>&gt;</span>Google<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://github.com&quot;</span>&gt;</span>GitHub<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://example.com&quot;</span>&gt;</span>Example<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-tag">a</span><span class="selector-attr">[href^=<span class="string">&quot;https&quot;</span>]</span> &#123; <span class="attribute">text-decoration</span>: underline; &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 选中 href 属性以 &quot;https&quot; 开头的 &lt;a&gt; 元素（Google 和 GitHub） --&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>[attr$=val]</code>: 选择属性值以指定字符串<ins>结尾</ins>的所有元素</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;index.html&quot;</span>&gt;</span>Home<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;about.html&quot;</span>&gt;</span>About<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;style.css&quot;</span>&gt;</span>Stylesheet<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-tag">a</span><span class="selector-attr">[href$=<span class="string">&quot;.html&quot;</span>]</span> &#123; <span class="attribute">color</span>: green; &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 选中 href 属性以 &quot;.html&quot; 结尾的 &lt;a&gt; 元素（Home 和 About） --&gt;</span></span><br></pre></td></tr></table></figure><h4 id="组合选择器"><a href="#组合选择器" class="headerlink" title="组合选择器"></a>组合选择器</h4><ul><li>相邻兄弟选择器: <code>A + B</code>, 选择<code>A</code>元素后紧跟的第一个<code>B</code>元素</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span>Box 1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span>Box 2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;text&quot;</span>&gt;</span>Text 1<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;text&quot;</span>&gt;</span>Text 2<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.box</span> + <span class="selector-class">.text</span> &#123; <span class="attribute">color</span>: red; &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 仅会选中紧挨着 .box 的第一个 .text（也就是 Text 1） --&gt;</span></span><br></pre></td></tr></table></figure><ul><li>普通兄弟选择器: <code>A ~ B</code>, 选择<code>A</code>元素后所有的<code>B</code>元素</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span>Box 1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;text&quot;</span>&gt;</span>Text 1<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;text&quot;</span>&gt;</span>Text 2<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span>Box 2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;text&quot;</span>&gt;</span>Text 3<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.box</span> ~ <span class="selector-class">.text</span> &#123; <span class="attribute">color</span>: blue; &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 选中 .box 后所有同一父级下的 .text 元素（Text 1 和 Text 2） --&gt;</span></span><br></pre></td></tr></table></figure><ul><li>子选择器: <code>A &gt; B</code>: 选择<code>A</code>的直接子元素<code>B</code></li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span>Box 1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;inner&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span>Box 2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.container</span> &gt; <span class="selector-class">.box</span> &#123; <span class="attribute">background-color</span>: yellow; &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 仅会选中 .container 的直接子元素 .box（Box 1），不包括嵌套的 Box 2 --&gt;</span></span><br></pre></td></tr></table></figure><ul><li>后代选择器: <code>A B</code>: 选择<code>A</code>元素内的所有<code>B</code>元素, 不论层级深度</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span>Box 1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;inner&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span>Box 2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.container</span> <span class="selector-class">.box</span> &#123; <span class="attribute">border</span>: <span class="number">1px</span> solid black; &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 会选中 .container 内的所有 .box 元素，包括 Box 1 和 Box 2 --&gt;</span></span><br></pre></td></tr></table></figure><h4 id="伪类"><a href="#伪类" class="headerlink" title="伪类"></a>伪类</h4><h5 id="条件伪类"><a href="#条件伪类" class="headerlink" title="条件伪类"></a><p style='font-size: 14px'>条件伪类</p></h5><ul><li><code>:lang()</code>: 基于元素语言来匹配页面元素</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span>Hello, world!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">lang</span>=<span class="string">&quot;fr&quot;</span>&gt;</span>Bonjour, le monde!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">lang</span>=<span class="string">&quot;zh&quot;</span>&gt;</span>你好，世界！<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-tag">p</span><span class="selector-pseudo">:lang</span>(en) &#123; <span class="attribute">color</span>: blue; &#125;</span></span><br><span class="line"><span class="language-css">  <span class="selector-tag">p</span><span class="selector-pseudo">:lang</span>(zh) &#123; <span class="attribute">color</span>: red; &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- lang=&quot;en&quot; 的段落文字变蓝, lang=&quot;zh&quot; 的段落文字变红 --&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>:dir()</code>: 匹配特定文字书写方向的元素</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">dir</span>=<span class="string">&quot;ltr&quot;</span>&gt;</span>Left to Right text.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">dir</span>=<span class="string">&quot;rtl&quot;</span>&gt;</span>من اليمين إلى اليسار.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-tag">p</span><span class="selector-pseudo">:dir</span>(ltr) &#123; <span class="attribute">background-color</span>: lightblue; &#125;</span></span><br><span class="line"><span class="language-css">  <span class="selector-tag">p</span><span class="selector-pseudo">:dir</span>(rtl) &#123; <span class="attribute">background-color</span>: lightgreen; &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 从左到右（ltr）的段落背景变蓝, 从右到左（rtl）的段落背景变绿 --&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>:has()</code>: 选择包含某个特定子元素的父元素</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;child&quot;</span>&gt;</span>This is a child paragraph.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>No child paragraph here.<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-tag">div</span><span class="selector-pseudo">:has</span>(<span class="selector-class">.child</span>) &#123; <span class="attribute">border</span>: <span class="number">2px</span> solid red; &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 包含类名为 child 的段落 &lt;p&gt; 的 &lt;div&gt; 会有红色边框 --&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>:is()</code>: 选择与列表中任意选择器匹配的元素</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Heading 1<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>Heading 2<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>Heading 3<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-pseudo">:is</span>(<span class="selector-tag">h1</span>, <span class="selector-tag">h2</span>) &#123; <span class="attribute">font-style</span>: italic; &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- h1 和 h2 元素的文字将变为斜体，而 h3 不受影响 --&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>:not()</code>: 选择不符合某些条件的元素</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span>Box 1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span>Container<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span>Box 2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-tag">div</span><span class="selector-pseudo">:not</span>(<span class="selector-class">.box</span>) &#123; <span class="attribute">background-color</span>: lightgray; &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 类名不是 box 的 &lt;div&gt;（即 Container）背景将变为浅灰色 --&gt;</span></span><br></pre></td></tr></table></figure><h5 id="行为伪类"><a href="#行为伪类" class="headerlink" title="行为伪类"></a><p style='font-size: 14px'>行为伪类</p></h5><ul><li><code>:active</code>: 当用户<ins>点击并按住</ins>一个元素时，该伪类会生效。一般用于按钮或链接</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span>&gt;</span>Click Me<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>Active Link<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-tag">button</span><span class="selector-pseudo">:active</span> &#123; <span class="attribute">background-color</span>: darkblue; <span class="attribute">color</span>: white;&#125;</span></span><br><span class="line"><span class="language-css">  <span class="selector-tag">a</span><span class="selector-pseudo">:active</span> &#123; <span class="attribute">color</span>: red; &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 按住按钮时，背景颜色变为深蓝，文字变为白色 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 点击并按住链接时，文字颜色变为红色 --&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>:hover</code>: 当用户将鼠标指针悬停在一个元素上时，该伪类会生效</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;hover-box&quot;</span>&gt;</span>Hover over me!<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>Hover Link<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.hover-box</span><span class="selector-pseudo">:hover</span> &#123; <span class="attribute">background-color</span>: lightgreen; <span class="attribute">cursor</span>: pointer; &#125;</span></span><br><span class="line"><span class="language-css">  <span class="selector-tag">a</span><span class="selector-pseudo">:hover</span> &#123; <span class="attribute">text-decoration</span>: underline; <span class="attribute">color</span>: orange; &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 鼠标悬停在 .hover-box 上时，背景变为浅绿色，鼠标变为手型 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 鼠标悬停在链接上时，文字加下划线，颜色变为橙色 --&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>::selection</code>: 当用户选中<ins>文本</ins>时，该伪类会生效。可以用于自定义文本选择时的样式（如背景颜色、文字颜色）</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">    This is a paragraph of text. Select some text to see the effect.</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-pseudo">::selection</span> &#123; <span class="attribute">background-color</span>: yellow; <span class="attribute">color</span>: black; &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 选中段落文本时，背景变为黄色，文字变为黑色 --&gt;</span></span><br></pre></td></tr></table></figure><h5 id="状态伪类"><a href="#状态伪类" class="headerlink" title="状态伪类"></a><p style='font-size: 14px'>状态伪类</p></h5><ul><li><code>:target</code>: 匹配当前<code>URL</code>锚点（<code>#</code>）对应的元素</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#section1&quot;</span>&gt;</span>Go to Section 1<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#section2&quot;</span>&gt;</span>Go to Section 2<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;section1&quot;</span>&gt;</span>Section 1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;section2&quot;</span>&gt;</span>Section 2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-id">#section1</span><span class="selector-pseudo">:target</span> &#123; <span class="attribute">background-color</span>: lightblue; &#125;</span></span><br><span class="line"><span class="language-css">  <span class="selector-id">#section2</span><span class="selector-pseudo">:target</span> &#123; <span class="attribute">background-color</span>: lightgreen; &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 点击链接 Go to Section 1，#section1 背景变为浅蓝色 --&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>:link</code>: 选择未访问的链接</li><li><code>:visited</code>: 选择已访问的链接</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://example.com&quot;</span>&gt;</span>Unvisited Link<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://google.com&quot;</span>&gt;</span>Visited Link<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-tag">a</span><span class="selector-pseudo">:link</span> &#123; <span class="attribute">color</span>: blue; &#125;</span></span><br><span class="line"><span class="language-css">  <span class="selector-tag">a</span><span class="selector-pseudo">:visited</span> &#123; <span class="attribute">color</span>: purple; &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 未访问的链接文字颜色为蓝色, 已访问的链接文字颜色为紫色 --&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>:focus</code>: 匹配当前聚焦的表单元素</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;Enter your name&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-tag">input</span><span class="selector-pseudo">:focus</span> &#123; <span class="attribute">border</span>: <span class="number">2px</span> solid green; <span class="attribute">outline</span>: none; &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 输入框聚焦时边框变为绿色 --&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>:required</code>: 匹配表单中被标记为必填的元素</li><li><code>:optional</code>: 匹配表单中未标记为必填的元素</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">required</span> <span class="attr">placeholder</span>=<span class="string">&quot;Required Field&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;Optional Field&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-tag">input</span><span class="selector-pseudo">:required</span> &#123; <span class="attribute">border</span>: <span class="number">2px</span> solid red; &#125;</span></span><br><span class="line"><span class="language-css">  <span class="selector-tag">input</span><span class="selector-pseudo">:optional</span> &#123; <span class="attribute">border</span>: <span class="number">2px</span> solid gray; &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 必填字段边框为红色, 可选字段边框为灰色 --&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>:valid</code>: 匹配输入值合法的表单元素</li><li><code>:invalid</code>: 匹配输入值不合法的表单元素</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;email&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;Enter your email&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-tag">input</span><span class="selector-pseudo">:valid</span> &#123; <span class="attribute">border</span>: <span class="number">2px</span> solid green; &#125;</span></span><br><span class="line"><span class="language-css">  <span class="selector-tag">input</span><span class="selector-pseudo">:invalid</span> &#123; <span class="attribute">border</span>: <span class="number">2px</span> solid red; &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 输入合法邮箱时，边框变绿, 输入不合法邮箱时，边框变红 --&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>:in-range</code>: 匹配输入值在设定范围内的元素</li><li><code>:out-of-range</code>: 匹配输入值在设定范围外的元素</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;number&quot;</span> <span class="attr">min</span>=<span class="string">&quot;10&quot;</span> <span class="attr">max</span>=<span class="string">&quot;100&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;Enter a number&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-tag">input</span><span class="selector-pseudo">:in-range</span> &#123; <span class="attribute">background-color</span>: lightgreen; &#125;</span></span><br><span class="line"><span class="language-css">  <span class="selector-tag">input</span><span class="selector-pseudo">:out-of-range</span> &#123; <span class="attribute">background-color</span>: lightcoral; &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 输入 10 到 100 之间的数字，背景变绿, 输入范围外的数字，背景变红 --&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>:checked</code>: 匹配选中的复选框或单选按钮</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">checked</span>&gt;</span> Checked<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span>&gt;</span> Not Checked<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-tag">input</span><span class="selector-pseudo">:checked</span> &#123; <span class="attribute">outline</span>: <span class="number">2px</span> solid blue; &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 选中的复选框有蓝色边框 --&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>:enabled</code>: 匹配启用的表单元素</li><li><code>:disabled</code>: 匹配禁用的表单元素</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">disabled</span> <span class="attr">placeholder</span>=<span class="string">&quot;Disabled&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;Enabled&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-tag">input</span><span class="selector-pseudo">:enabled</span> &#123; <span class="attribute">background-color</span>: white; &#125;</span></span><br><span class="line"><span class="language-css">  <span class="selector-tag">input</span><span class="selector-pseudo">:disabled</span> &#123; <span class="attribute">background-color</span>: lightgray; &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 启用的输入框背景为白色, 禁用的输入框背景为浅灰色 --&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>:read-only</code>: 匹配只读表单元素</li><li><code>:read-write</code>: 匹配可编辑表单元素</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">readonly</span> <span class="attr">value</span>=<span class="string">&quot;Read-only Field&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Editable Field&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-tag">input</span><span class="selector-pseudo">:read-only</span> &#123; <span class="attribute">color</span>: gray; &#125;</span></span><br><span class="line"><span class="language-css">  <span class="selector-tag">input</span><span class="selector-pseudo">:read-write</span> &#123; <span class="attribute">color</span>: black; &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 只读输入框文字为灰色, 可编辑输入框文字为黑色 --&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>:blank</code>: 匹配没有输入值的表单元素</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;Leave me blank&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-tag">input</span><span class="selector-pseudo">:blank</span> &#123; <span class="attribute">border</span>: <span class="number">2px</span> dashed orange; &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 未填写的输入框边框为橙色虚线 --&gt;</span></span><br></pre></td></tr></table></figure><h5 id="结构伪类"><a href="#结构伪类" class="headerlink" title="结构伪类"></a><p style='font-size: 14px'>结构伪类</p></h5><ul><li><code>:root</code>: 选择文档的根元素, 在<code>HTML</code>中一般是<code>&lt;html&gt;</code>标签</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello, World!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-pseudo">:root</span> &#123; <span class="attribute">font-size</span>: <span class="number">16px</span>; <span class="attr">--main-color</span>: blue; &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 设置根元素的字体大小和 CSS 自定义属性（变量） --&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>:empty</code>: 匹配没有子元素（包括文本节点）的元素</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box2&quot;</span>&gt;</span>Content<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-tag">div</span><span class="selector-pseudo">:empty</span> &#123; <span class="attribute">background-color</span>: lightgray; &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 没有内容的 &lt;div class=&quot;box1&quot;&gt; 背景变为浅灰色 --&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>:first-letter</code>: 选择元素的首字母，用于文本样式的特殊处理</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>This is a paragraph.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-tag">p</span><span class="selector-pseudo">:first</span>-letter &#123; <span class="attribute">font-size</span>: <span class="number">2em</span>; <span class="attribute">color</span>: red; &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 段落首字母 “T” 字体变大且颜色变红 --&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>:first-line</code>: 选择元素的首行内容，常用于段落样式的特殊处理</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>This is a long paragraph to demonstrate first-line styling in CSS.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-tag">p</span><span class="selector-pseudo">:first</span>-line &#123; <span class="attribute">font-weight</span>: bold; <span class="attribute">color</span>: blue; &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 段落的第一行文字加粗且变蓝 --&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>:nth-child(n)</code>: 匹配父元素中第<code>n</code>个子元素（从第一个开始计数）</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-tag">li</span><span class="selector-pseudo">:nth-child</span>(<span class="number">2</span>) &#123; <span class="attribute">color</span>: red; &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 第二个 &lt;li&gt; 的文字颜色变为红色 --&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>:nth-last-child(n)</code>: 匹配父元素中倒数第<code>n</code>个子元素</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-tag">li</span><span class="selector-pseudo">:nth-last-child</span>(<span class="number">1</span>) &#123; <span class="attribute">color</span>: green; &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 最后一个 &lt;li&gt; 的文字颜色变为绿色 --&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>:first-child</code>: 匹配父元素中的第一个子元素</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-tag">li</span><span class="selector-pseudo">:first</span>-child &#123; <span class="attribute">font-style</span>: italic; &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 第一个 &lt;li&gt; 的文字变为斜体 --&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>:last-child</code>: 匹配父元素中的最后一个子元素</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-tag">li</span><span class="selector-pseudo">:last-child</span> &#123; <span class="attribute">font-weight</span>: bold; &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 最后一个 &lt;li&gt; 的文字加粗 --&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>:only-child</code>: 匹配父元素中仅有的子元素</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;single&quot;</span>&gt;</span>I am the only child!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Child 1<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Child 2<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-tag">p</span><span class="selector-pseudo">:only-child</span> &#123; <span class="attribute">color</span>: purple; &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 仅有一个子元素的 &lt;p&gt;（I am the only child!）文字颜色变为紫色 --&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>:nth-of-type(n)</code>: 匹配同类型标签中的第<code>n</code>个</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Paragraph 1<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Paragraph 2<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>Span 1<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Paragraph 3<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-tag">p</span><span class="selector-pseudo">:nth-of-type</span>(<span class="number">2</span>) &#123; <span class="attribute">color</span>: orange; &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 第二个 &lt;p&gt;（Paragraph 2）文字颜色变为橙色 --&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>:nth-last-of-type(n)</code>: 匹配同类型标签中的倒数第<code>n</code>个</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Paragraph 1<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Paragraph 2<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Paragraph 3<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-tag">p</span><span class="selector-pseudo">:nth-last-of-type</span>(<span class="number">1</span>) &#123; <span class="attribute">color</span>: brown; &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 倒数第一个 &lt;p&gt;（Paragraph 3）文字颜色变为棕色 --&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>:first-of-type</code>: 匹配同类型标签中的第一个</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>First Paragraph<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Second Paragraph<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-tag">p</span><span class="selector-pseudo">:first</span>-of-type &#123; <span class="attribute">text-decoration</span>: underline; &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 第一个 &lt;p&gt; 的文字加下划线 --&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>:last-of-type</code>: 匹配同类型标签中的最后一个</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>First Paragraph<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Last Paragraph<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-tag">p</span><span class="selector-pseudo">:last-of-type</span> &#123; <span class="attribute">color</span>: teal; &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 最后一个 &lt;p&gt; 的文字颜色变为青色 --&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>:only-of-type</code>: 匹配父元素中仅有的某种类型的标签</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Unique Paragraph<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>Not Unique<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Another Paragraph<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-tag">p</span><span class="selector-pseudo">:only-of-type</span> &#123; <span class="attribute">background-color</span>: yellow; &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 父元素中仅有的 &lt;p&gt;（Unique Paragraph）背景变为黄色 --&gt;</span></span><br></pre></td></tr></table></figure><h5 id="伪元素"><a href="#伪元素" class="headerlink" title="伪元素"></a><p style='font-size: 14px'>伪元素</p></h5><ul><li><code>::before</code>: 在在元素内容<ins>之前</ins>插入内容<ul><li><code>::before</code>是一个伪元素，必须与<code>content</code>属性一起使用，否则不会生效</li></ul></li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;example&quot;</span>&gt;</span>This is a paragraph.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.example</span><span class="selector-pseudo">::before</span> &#123; <span class="attribute">content</span>: <span class="string">&quot;★ &quot;</span>; <span class="attribute">color</span>: gold; <span class="attribute">font-size</span>: <span class="number">1.5em</span>; &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 在段落内容之前插入一个金色的星星符号 --&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>::after</code>: 在元素内容<ins>之后</ins>插入内容<ul><li>和<code>::before</code>类似，必须与<code>content</code>属性一起使用</li></ul></li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;example&quot;</span>&gt;</span>This is a paragraph.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.example</span><span class="selector-pseudo">::after</span> &#123; <span class="attribute">content</span>: <span class="string">&quot; ✎&quot;</span>; <span class="attribute">color</span>: gray; <span class="attribute">font-size</span>: <span class="number">1.2em</span>; &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 在段落内容之后插入一个灰色的铅笔符号 --&gt;</span></span><br></pre></td></tr></table></figure><hr><h3 id="CSS优先级"><a href="#CSS优先级" class="headerlink" title="CSS优先级"></a><code>CSS</code>优先级</h3><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img4b226c55b87c426c840d2c70d51d3511%7Etplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.awebp"></p><p>优先级就是分配给指定的<code>CSS</code>声明的一个权重, 它由匹配的选择器中的每一种选择器类型的数值决定。可以把权重分成如下几个等级, 数值越大的权重越高</p><ul><li><code>10000</code>: <code>!important</code></li><li><code>01000</code>: 内联样式 (<code>inline style</code>)</li><li><code>00100</code>: <code>ID</code>选择器</li><li><code>00010</code>: 类选择器、伪类选择器、属性选择器</li><li><code>00001</code>: 元素选择器、伪元素选择器</li><li><code>00000</code>: 通配选择器、后代选择器、兄弟选择器</li></ul><p>可以看到内联样式（通过元素中<code>style</code>属性定义的样式）的优先级大于任何选择器。而给属性值加上<code>!important</code>又可以把优先级提至最高，就是因为它的优先级最高，所以需要谨慎使用它</p><hr><h3 id="CSS层叠性"><a href="#CSS层叠性" class="headerlink" title="CSS层叠性"></a><code>CSS</code>层叠性</h3><p>层叠样式表（<code>CSS</code>）中的“层叠”是其核心特性之一，它指的是当多个<code>CSS</code>声明可以作用于同一个<code>HTML</code>元素时，如何确定最终生效的样式。这是通过一套明确的算法来完成的，用于合并来自多个来源的属性值</p><ul><li>针对不同源的样式，将按照如下的顺序进行层叠，越往下优先级越高<ul><li>用户代理样式表: 浏览器自带的默认样式，如果我们不设置任何样式，浏览器会使用这些规则。例如，默认的段落<code>&lt;p&gt;</code>有一些上下边距</li><li>作者样式表: 开发者定义的样式，通常是我们编写的<code>CSS</code>文件或内联样式。这些样式会覆盖浏览器的默认样式</li><li>作者样式表中的<code>!important</code>声明: 如果开发者在样式中添加了<code>!important</code>，那么它的优先级最高，哪怕有其他规则覆盖，它也会生效</li></ul></li></ul><p>理解层叠性的时候需要结合<code>CSS</code>选择器的优先级以及继承性来理解。比如针对同一个选择器，定义在后面的声明会覆盖前面的, 作者定义的样式会比默认继承的样式优先级更高</p><hr><h3 id="规则"><a href="#规则" class="headerlink" title="@规则"></a><code>@</code>规则</h3><p><code>@</code>规则是一种特殊的<code>CSS</code>语句，用于在样式表中定义一些全局配置或条件规则，而不仅仅是常规的样式规则。以下是<code>CSS</code>中常用的<code>@</code>规则</p><ul><li><code>@namespace</code>: 用于定义<code>XML</code>命名空间（适用于特定的<code>XML</code>文件样式需求）</li></ul><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@namespace</span> svg <span class="string">&quot;http://www.w3.org/2000/svg&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 仅对 SVG 元素应用样式 */</span></span><br><span class="line">svg|circle &#123;</span><br><span class="line">    fill: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 作用：定义 svg 命名空间，并对 &lt;circle&gt; 元素应用样式 */</span></span><br></pre></td></tr></table></figure><ul><li><code>@media</code>: 用于为不同设备或屏幕条件设置样式</li></ul><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@media</span> (<span class="attribute">max-width</span>: <span class="number">600px</span>) &#123;</span><br><span class="line">    <span class="selector-tag">body</span> &#123;</span><br><span class="line">        <span class="attribute">background-color</span>: lightblue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@media</span> print &#123;</span><br><span class="line">    <span class="selector-tag">body</span> &#123;</span><br><span class="line">        <span class="attribute">font-size</span>: <span class="number">12px</span>;</span><br><span class="line">        <span class="attribute">color</span>: black;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 如果屏幕宽度小于或等于 600px，背景变为浅蓝色 */</span></span><br><span class="line"><span class="comment">/* 打印时，字体变小并使用黑色 */</span></span><br></pre></td></tr></table></figure><ul><li><code>@page</code>: 用于设置打印页面的布局（如页边距）</li></ul><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@page</span> &#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">1in</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@page</span> :first &#123;</span><br><span class="line">    <span class="attribute">margin-top</span>: <span class="number">2in</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设置默认打印页面的页边距为 1 英寸 */</span></span><br><span class="line"><span class="comment">/* 第一页的上边距增加到 2 英寸 */</span></span><br></pre></td></tr></table></figure><ul><li><code>@font-face</code>: 定义和加载自定义字体</li></ul><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@font-face</span> &#123;</span><br><span class="line">    <span class="attribute">font-family</span>: <span class="string">&quot;CustomFont&quot;</span>;</span><br><span class="line">    <span class="attribute">src</span>: <span class="built_in">url</span>(<span class="string">&quot;customfont.woff2&quot;</span>) <span class="built_in">format</span>(<span class="string">&quot;woff2&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">font-family</span>: <span class="string">&quot;CustomFont&quot;</span>, sans-serif;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 从外部加载名为 CustomFont 的字体并应用到页面 */</span></span><br></pre></td></tr></table></figure><ul><li><code>@keyframes</code>: 定义动画的关键帧</li></ul><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@keyframes</span> slide-in &#123;</span><br><span class="line">    <span class="selector-tag">from</span> &#123;</span><br><span class="line">        <span class="attribute">transform</span>: <span class="built_in">translateX</span>(-<span class="number">100%</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-tag">to</span> &#123;</span><br><span class="line">        <span class="attribute">transform</span>: <span class="built_in">translateX</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">animation</span>: slide-in <span class="number">1s</span> ease-out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 定义一个从左侧滑入的动画，并将其应用到 &lt;div&gt; 元素上 */</span></span><br></pre></td></tr></table></figure><ul><li><code>@import</code>: 用于导入外部<code>CSS</code>文件, 与<code>&lt;link&gt;</code>的区别如下<ul><li><code>&lt;link&gt;</code>是<code>HTML</code>标签，可导入<code>CSS</code>、图片、脚本等资源。<code>@import</code>是<code>CSS</code>规则，仅能导入<code>CSS</code>文件</li><li><code>&lt;link&gt;</code>会在页面加载时同时加载<code>CSS</code>。<code>@import</code>会等页面加载完成后再加载<code>CSS</code> (所以<code>@import</code>字体会在网页加载结束后才会被应用)</li></ul></li></ul><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@import</span> url(<span class="string">&quot;styles.css&quot;</span>);</span><br></pre></td></tr></table></figure><ul><li><code>@supports</code>: 用于检测浏览器是否支持某些<code>CSS</code>特性，从而有条件地应用样式。可以使用<code>not</code>、<code>and</code>、<code>or</code>逻辑操作符</li></ul><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 默认样式 */</span></span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: white;</span><br><span class="line">    <span class="attribute">color</span>: black;</span><br><span class="line">    <span class="attribute">transition</span>: all <span class="number">0.3s</span> ease;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 如果支持 color-scheme，则设置支持深色模式 */</span></span><br><span class="line"><span class="keyword">@supports</span> (<span class="attribute">color-scheme</span>: dark) &#123;</span><br><span class="line">    <span class="selector-tag">body</span> &#123;</span><br><span class="line">        <span class="attribute">color</span>-scheme: dark;</span><br><span class="line">        <span class="attribute">background-color</span>: <span class="built_in">var</span>(--background, black);</span><br><span class="line">        <span class="attribute">color</span>: <span class="built_in">var</span>(--text, white);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 如果用户偏好减少动画 */</span></span><br><span class="line"><span class="keyword">@supports</span> (<span class="attribute">prefers-reduced-motion</span>: reduce) &#123;</span><br><span class="line">    * &#123;</span><br><span class="line">        <span class="attribute">transition</span>: none;</span><br><span class="line">        <span class="attribute">animation</span>: none;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 如果浏览器支持 color-scheme，页面会启用深色模式的默认样式或定义的变量 */</span></span><br><span class="line"><span class="comment">/* 如果用户设置了减少动画偏好（通过系统设置），页面会禁用所有过渡和动画效果 */</span></span><br><span class="line"><span class="comment">/* 如果两者都不支持，则使用默认样式（浅色背景，黑色文字，带有过渡效果） */</span></span><br></pre></td></tr></table></figure><hr><h3 id="CSS继承性"><a href="#CSS继承性" class="headerlink" title="CSS继承性"></a><code>CSS</code>继承性</h3><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/imgf8bd1604b143463eb121c1f46d71c652%7Etplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.awebp"></p><p>继承性是<code>CSS</code>中的一个重要特性，指的是子元素可以继承父元素某些 属性计算后的值。例如，<code>html</code>元素的文本颜色默认是黑色，页面中的所有子元素会继承这个颜色属性，除非显式指定其他颜色。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: orange;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">h1</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: inherit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="继承的作用"><a href="#继承的作用" class="headerlink" title="继承的作用"></a>继承的作用</h4><ul><li>继承性可以减少样式代码的冗余，提高代码的可维护性<ul><li>如果<code>CSS</code>不支持继承，那么我们需要为每个文本标签都单独设置颜色或字体，导致样式代码冗长，文件体积变大，维护成本增加</li></ul></li></ul><h4 id="继承的默认行为"><a href="#继承的默认行为" class="headerlink" title="继承的默认行为"></a>继承的默认行为</h4><p><code>CSS</code>属性很多，但并不是所有的属性默认都是能继承父元素对应属性的，那哪些属性存在默认继承的行为呢？一定是那些不会影响到页面布局的属性，可以分为如下几类</p><ul><li>字体相关: <code>font-family</code>、<code>font-style</code>、<code>font-size</code>、<code>font-weight</code>等</li><li>文本相关: <code>text-align</code>、<code>text-indent</code>、<code>text-decoration</code>、<code>text-shadow</code>、<code>letter-spacing</code>、<code>word-spacing</code>、<code>white-space</code>、<code>line-height</code>、<code>color</code>等</li><li>列表相关: <code>list-style</code>、<code>list-style-image</code>、<code>list-style-type</code>、<code>list-style-position</code>等</li><li>其他属性: <code>visibility</code>、<code>cursor</code>等</li></ul><h4 id="显式控制继承行为"><a href="#显式控制继承行为" class="headerlink" title="显式控制继承行为"></a>显式控制继承行为</h4><p>对于其他默认不继承的属性也可以通过以下几个属性值来控制继承行为</p><ul><li><code>inherit</code>: 强制继承父元素对应属性的计算值</li></ul><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">    <span class="attribute">border</span>: inherit;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* p 的边框样式将继承自父元素 */</span></span><br></pre></td></tr></table></figure><ul><li><code>initial</code>: 将属性恢复为<code>CSS</code>的默认值</li></ul><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: initial;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* p 的颜色将恢复为默认值（如黑色 #000） */</span></span><br></pre></td></tr></table></figure><ul><li><code>unset</code><ul><li>如果属性默认可以继承，则效果等同于<code>inherit</code></li><li>如果属性默认不继承，则效果等同于<code>initial</code></li></ul></li></ul><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: unset;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="CSS文档流"><a href="#CSS文档流" class="headerlink" title="CSS文档流"></a><code>CSS</code>文档流</h3><p>在<code>CSS</code>的世界中，文档流是内容按照从左到右、从上到下的顺序排列和显示的一种默认布局方式。通常情况下，页面会被分割成一行一行的显示，每行可能包含多个元素。从视觉效果来看，文档流呈现为从上到下、从左到右的排列方式。这种布局也被称为<ins>流式布局</ins>，类似水流般灵活，可以自适应所在的容器</p><h4 id="什么是文档流"><a href="#什么是文档流" class="headerlink" title="什么是文档流"></a>什么是文档流</h4><ul><li>在没有额外样式（如<code>position</code>或<code>float</code>）的情况下，<code>HTML</code>元素会按照文档流的默认规则进行排列</li><li>块级元素: 占据一整行，从上到下垂直排列，例如 <code>&lt;div&gt;</code>、<code>&lt;p&gt;</code>等</li><li>行内元素: 按从左到右的顺序水平排列，例如 <code>&lt;span&gt;</code>、<code>&lt;a&gt;</code>、<code>&lt;strong&gt;</code>等</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>块级元素 1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>块级元素 2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>行内元素 1<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>行内元素 2<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">块级元素 1</span><br><span class="line">块级元素 2</span><br><span class="line">行内元素 1 行内元素 2</span><br></pre></td></tr></table></figure><h4 id="脱离文档流"><a href="#脱离文档流" class="headerlink" title="脱离文档流"></a>脱离文档流</h4><p>脱离文档流指的是将某个元素从正常文档流中移除后，其他元素将忽略该元素的存在，并填补其原先占据的空间。脱流的元素不会影响父容器的高度计算，即<ins>脱流元素不占据空间</ins></p><ul><li>有以下两种常见方式可以使元素脱离文档流</li></ul><h5 id="浮动float"><a href="#浮动float" class="headerlink" title="浮动float"></a><p style='font-size: 14px'>浮动<code>float</code></p></h5><p>浮动（<code>float</code>）属性最初在<code>CSS</code>中被引入是为了实现文字环绕图片的效果</p><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img46494deb72014dedbcaa64689d28bada%7Etplv-73owjymdk6-jj-mark-v1_0_0_0_0_5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5LmL6YGT5YmN56uv_q75.webp"></p><p>如果没有<code>float</code>，<code>img</code>默认是<code>inline</code>元素，那么文字图片的显示就会像这样</p><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/imgbed297a2758f4cca969dce9630c17c53%7Etplv-73owjymdk6-jj-mark-v1_0_0_0_0_5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5LmL6YGT5YmN56uv_q75.webp"></p><ul><li>使用<code>float</code>会让元素脱离正常文档流，移动到父容器的左&#x2F;右侧</li><li>后续的块级元素不会受到浮动元素的影响，但其他浮动或行内元素会受影响</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;float: left;&quot;</span>&gt;</span>浮动元素<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>普通元素<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 浮动元素在左侧，普通元素从浮动元素的下方开始排列 --&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>现代的<code>CSS</code>布局技术如<code>Flexbox</code>和<code>Grid</code>已经几乎完全取代了浮动布局，但在某些特定情况下，浮动仍然有其用武之地，比如文字环绕图片和简单的左对齐或右对齐</p></blockquote><h5 id="定位position"><a href="#定位position" class="headerlink" title=" 定位position"></a><p style='font-size: 14px'> 定位<code>position</code></p></h5><p>绝对定位 (<code>absolute</code>)</p><ul><li>使用<code>position: absolute;</code>脱离文档流</li><li>元素的位置由最近的非静态父容器决定，空出的位置会被后续节点填补</li></ul><p>固定定位 (<code>fixed</code>)</p><ul><li>使用<code>position: fixed;</code>脱离文档流</li><li>元素的位置固定在视口的某处，不受滚动影响</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;position: absolute; top: 50px; left: 100px;&quot;</span>&gt;</span>绝对定位元素<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>这是一段普通文本，将填补绝对定位元素的位置。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><h3 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h3><blockquote><p>文件还未上传 Github</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AWS DVA-C02</title>
      <link href="/posts/31e3742d.html"/>
      <url>/posts/31e3742d.html</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p>官网: <a href="https://aws.amazon.com/certification/certified-developer-associate/">https://aws.amazon.com/certification/certified-developer-associate/</a></p></blockquote><hr><h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><h3 id="1-AWS-Cloud-Overview"><a href="#1-AWS-Cloud-Overview" class="headerlink" title="1. AWS Cloud Overview"></a>1. AWS Cloud Overview</h3><h4 id="AWS-Regions"><a href="#AWS-Regions" class="headerlink" title="AWS Regions"></a>AWS Regions</h4><ul><li>A Region is a cluster of data centers</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img231130.png"></p><ul><li>To reuse SSH keys in AWS Region<ul><li>Generate a public SSH key from the private SSH key. Import the key to each AWS Region</li></ul></li></ul><hr><h4 id="AWS-Availability-Zone"><a href="#AWS-Availability-Zone" class="headerlink" title="AWS Availability Zone"></a>AWS Availability Zone</h4><ul><li>一个 Region 可以有 3 - 6 个 AZ, 每个 AZ 都是分开的</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img140727.png"></p><hr><h4 id="AWS-Edge-Locations"><a href="#AWS-Edge-Locations" class="headerlink" title="AWS Edge Locations"></a>AWS Edge Locations</h4><ul><li>Deliver content to user with low latency (离用户越近, deliver 速度越快)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img140903.png"></p><hr><h3 id="2-IAM"><a href="#2-IAM" class="headerlink" title="2. IAM"></a>2. IAM</h3><h4 id="AWS-IAM"><a href="#AWS-IAM" class="headerlink" title="AWS IAM"></a>AWS IAM</h4><ul><li>Root Account: Created by default, don’t share with others</li><li>Users: People within the organization</li><li>Groups: Only contain Users, not other Groups (User 可以属于多个 Group)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img145736.png"></p><ul><li>AWS 需要至少 5 weeks 来生成 budget forecasts</li><li>注意, User 默认无法 access AWS Billing and Cost Management console, 必须要 grant access 才行</li></ul><hr><h4 id="IAM-Permissions"><a href="#IAM-Permissions" class="headerlink" title="IAM Permissions"></a>IAM Permissions</h4><ul><li>定义了 User 或者 Group 的 Permissions<ul><li>要遵守 Least Privilege Principle</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img160124.png"></p><blockquote><p>As an AWS security best practice, you should not create an IAM user and pass the user’s credentials to the application or embed the credentials in the application</p></blockquote><hr><h4 id="IAM-Polices"><a href="#IAM-Polices" class="headerlink" title="IAM Polices"></a>IAM Polices</h4><ul><li>Statements 里面必须包含: Effect, Principal, Action, Resource<ul><li>Inline Policy 是 assign 给个人的</li></ul></li><li>注意, The only resource-based policy IAM support is Trust policy</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img175653.png"></p><blockquote><p>IAM policies define permissions for an action regardless of the method that used to perform the operation.</p></blockquote><hr><h4 id="IAM-MFA"><a href="#IAM-MFA" class="headerlink" title="IAM MFA"></a>IAM MFA</h4><ul><li>Protect Root Accounts and IAM Users</li><li>MFA options: Virtual MFA Device, U2F Sercurity Key (USB)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img180624.png"></p><hr><h4 id="IAM-CLI-amp-SDK"><a href="#IAM-CLI-amp-SDK" class="headerlink" title="IAM CLI &amp; SDK"></a>IAM CLI &amp; SDK</h4><ul><li>可以用 AWS Management Console, AWS CLI, AWS SDK 来访问 AWS<ul><li>Set the <code>DeleteOnTermination</code> attribute to False using the command line</li><li>如果考试遇到不会的就选 CLI</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img193342.png"></p><hr><h4 id="IAM-Roles"><a href="#IAM-Roles" class="headerlink" title="IAM Roles"></a>IAM Roles</h4><ul><li>授权 AWS 服务去做某些事</li><li>常见的 Role: EC2 Instance Role, Lambda Function Role 等等</li><li>IAM Instance Role: 为 EC2 实例分配 temporary credentials，以便实例能够安全地访问其他 AWS 服务</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img203306.png"></p><blockquote><p>An IAM entity that defines a set of permissions for making requests to AWS services, and will be used by an AWS service</p></blockquote><hr><h4 id="IAM-Security-Tools"><a href="#IAM-Security-Tools" class="headerlink" title="IAM Security Tools"></a>IAM Security Tools</h4><ul><li>IAM Credentials Report: 返回用户数据和 credentials</li><li>IAM Access Advisor: 显示当前用户被授权的服务和使用时间</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img203553.png"></p><hr><h3 id="3-EC2-Fundamentals"><a href="#3-EC2-Fundamentals" class="headerlink" title="3. EC2 Fundamentals"></a>3. EC2 Fundamentals</h3><h4 id="AWS-EC2"><a href="#AWS-EC2" class="headerlink" title="AWS EC2"></a>AWS EC2</h4><ul><li>EC2 &#x3D; Elastic Compute Cloud &#x3D; IaaS , 绑定 AZ</li><li>SSH 到 EC2 Instance 的 Public IP (记住 169, meta-data)<ul><li><code>http://169.254.169.254/latest/meta-data/public-ipv4</code></li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img214749.png"></p><ul><li>User Data: EC2 启动的时候运行的代码<ul><li>By default, user data runs only during boot cycle when first lauch instance</li><li>By default, scripts entered as user data are executed with root user privileges</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img214956.png"></p><ul><li>如果要 monitor 一个 EC2 Instance, <code>aws ec2 monitor-instances --instance-ids &#123;id&#125;</code></li><li>如果要解决 EC2 based web servers in high CPU utilization issue<ul><li>Configure an SSL&#x2F;TLS certificate on an Application Load Balancer via AWS Certificate Manager (ACM)</li><li>Create an HTTPS listener on the Application Load Balancer with SSL termination</li></ul></li></ul><hr><h4 id="EC2-Instance-Type"><a href="#EC2-Instance-Type" class="headerlink" title="EC2 Instance Type"></a>EC2 Instance Type</h4><ul><li>一共 7 种 EC2 Instance Type, 但 4 种用的最多<ul><li>General Purpose: Balanced (平衡的)</li><li>Compute Optimized: High performance (处理 Batch, 视频和 HPC)</li><li>Memory Optimized: Process data in memory (处理 cache)</li><li>Storage Optimized: Read and write data on local storage (OLTP)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img220941.png"></p><hr><h4 id="EC2-Security-Groups"><a href="#EC2-Security-Groups" class="headerlink" title="EC2 Security Groups"></a>EC2 Security Groups</h4><ul><li>Control how traffic is allowed in and out of EC2 instance<ul><li>Security groups only contain allow rules (EC2 出问题优先检查 Security Group)</li></ul></li><li>可以作为 Security Group 的 Inbound Rule 有 IP address, CIDR block, Security Group</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img222531.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img223020.png"></p><hr><h4 id="EC2-Instance-Purchasing-Options"><a href="#EC2-Instance-Purchasing-Options" class="headerlink" title="EC2 Instance Purchasing Options"></a>EC2 Instance Purchasing Options</h4><ul><li>On-Demand Intances: Short workload, pay by second (短期内紧急使用)</li><li>Reserved: 1 - 3 years (72% discount, reserve capacity in an AZ)<ul><li>Reserved Instance: Long workload (1 - 3 年, discount 随年份增加)</li><li>Convertible Reserved Instances (RI): Long workload with flexible instance (66% discount, 但是可以自由改变 Instance Type)</li></ul></li><li>Saving Plans: 1 - 3 years, commitment to an amount of usage (72% discount, 要定一个使用上限, 超过上限就变成 On-Demand)<ul><li>还有 Compute Saving Plan, 66% discount, work with Lambda and Fargate</li></ul></li><li>Spot Instance: Short workload, can lose instance (最便宜, 90% discount)</li><li>Dedicated Host: The physical server is yours (最贵, 可以控制 how Instance placed)</li><li>Dedicated Instance: Run hardware, but not lockdown to you (服务器大部分是你的)</li><li>Capacity Reservation: Reserve capacity in AZ (比如一天中只有几个小时需要 EC2)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img224149.png"></p><ul><li>Reserved Instance 有 Regional 和 Zonal, Zonal 提供 capacity reservation, Regional 不提供</li></ul><hr><h3 id="4-EC2-Instance-Storage"><a href="#4-EC2-Instance-Storage" class="headerlink" title="4. EC2 Instance Storage"></a>4. EC2 Instance Storage</h3><h4 id="AWS-EBS"><a href="#AWS-EBS" class="headerlink" title="AWS EBS"></a>AWS EBS</h4><ul><li>Block-level storage, 类似 network drive, 绑定 AZ, provisioned capacity<ul><li>可以从一个 EC2 Instance 取下来装到另一个上</li><li>记住 EBS 是绑定 AZ 的, 很重要</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img191440.png"></p><ul><li>EBS - Delete on Termination attribute<ul><li>By default, Root Volume will be deleted on termination (重要)</li><li>By default, other EBS volume will not be deleted on termination (重要)</li><li>Can be controled by AWS console &#x2F; AWS CLI</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img002840.png"></p><ul><li>关于 EBS Encryption 有 2 个知识点<ul><li>Encryption by default is a Region-specific setting. If you enable it for a Region, you cannot disable it for individual volumes or snapshots in that Region</li><li>A volume restored from an encrypted snapshot, or a copy of an encrypted snapshot is always encrypted</li></ul></li></ul><hr><h4 id="EBS-Snapshots"><a href="#EBS-Snapshots" class="headerlink" title="EBS Snapshots"></a>EBS Snapshots</h4><ul><li>Make a backup of EBS volume (备份 EBS)<ul><li>可以将这个 snapshot 用在其他 AZ 或者 Region 上</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img195715.png"></p><ul><li>EBS Snapchot Archive: 便宜 75%</li><li>Recycle Bin: Setup rules to retain deleted snapshots (可以 recover)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img195833.png"></p><hr><h4 id="AWS-AMI"><a href="#AWS-AMI" class="headerlink" title="AWS AMI"></a>AWS AMI</h4><ul><li>AMI: Amazon Machine Image, customization of an EC2 Instance<ul><li>可以更好的管理和启动 EC2 Instance</li></ul></li><li>Built for a specific region and can copy across regions (AMI 跨域复制)<ul><li>注意, AMIs are built for a specific AWS Region</li></ul></li></ul><blockquote><p>When the new AMI is copied from Region A into Region B, it automatically creates a snapshot in Region B (注意, 跨域 copy AMI 会产生 snapshot)</p></blockquote><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img200249.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img200341.png"></p><hr><h4 id="EC2-Instance-Store"><a href="#EC2-Instance-Store" class="headerlink" title="EC2 Instance Store"></a>EC2 Instance Store</h4><ul><li>Block-level storage, 物理硬盘 (Physical drive, temporary storage, 可以处理数据库)</li><li>High random I&#x2F;O performance, good for cache at low cost (重要)</li><li>EC2 Instance Store lose when stopped (Ephemeral, 数据在 Instance Store 关闭时消失)<ul><li>反正记住, Instance Store 不能复用, Instance Store 里的数据不会 preserve</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img203146.png"></p><hr><h4 id="EBS-Volume-Types"><a href="#EBS-Volume-Types" class="headerlink" title="EBS Volume Types"></a>EBS Volume Types</h4><ul><li>General Purpose (gp2 &#x2F; gp3): Balanced, cost-effective</li><li>Provisioned IOPS (io1 &#x2F; io2): High-performance, support Multi-Attach<ul><li>Low latency, high throughput</li><li>记住, io 的比 gp 的贵, 但是 io 的 IOPS 也比 gp 高</li><li>gp2 的 max IOPS 是 5.3 TiB</li></ul></li><li>Hard Disk Drives (HDD): Data intensive (st1) 或者 less frequent access (sc1)<ul><li>HDD 不可以用来创建 EC2</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img203437.png"></p><hr><h4 id="EBS-Multi-Attach"><a href="#EBS-Multi-Attach" class="headerlink" title="EBS Multi-Attach"></a>EBS Multi-Attach</h4><ul><li>Attach same EBS volume to multiple EC2 instance in same AZ (记住是相同的 AZ)</li><li>Only for io1 &#x2F; io2 family (Provisioned IOPS SSD, 重要)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img203956.png"></p><hr><h4 id="EBS-RAID"><a href="#EBS-RAID" class="headerlink" title="EBS RAID"></a>EBS RAID</h4><ul><li>RAID 0 (看重 I&#x2F;O performance)<ul><li>Use RAID 0 when I&#x2F;O performance is more important than fault tolerance</li><li>可以用来提高 EBS volume 的 performance</li></ul></li><li>RAID 1 (看重 falut tolerance)<ul><li>Use RAID 1 when fault tolerance is more important than I&#x2F;O performance</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/imgpt6-q37-i1.jpg"></p><hr><h4 id="AWS-EFS"><a href="#AWS-EFS" class="headerlink" title="AWS EFS"></a>AWS EFS</h4><ul><li>NFS (network file system), 可以 mount 到多个 EC2 Instance<ul><li>Scale automatically, highly availiable, no capacity planning</li></ul></li><li>EC2 Instances can access files on an EFS file system across AZs, Regions and VPCs<ul><li>重要, 可以从不同的 AZ, Region, VPC 来 access</li><li>可以用 VPC Security Group 或者 IAM Policy 来 control access to EFS</li></ul></li><li>EFS Infrequent Access (如果遇到 POSIX compliant file storage)<ul><li>因为 EFS 只能和 Linux Instance (POSIX) 一起用, Windows 不行</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img233415.png"></p><ul><li>EFS 有 2 种 Performance Mode (set at EFS creation time)<ul><li>General Purpose: Default (web server)</li><li>Max I&#x2F;O: High latency, throughput, parallel (big data, media process)</li></ul></li><li>EFS 有 3 种 Throughput Mode (重要)<ul><li>Bursting: 很快</li><li>Provisioned: 设置上限 (high throughput, 处理大量文件 migrate 时候使用)</li><li>Elastic: 根据 workload 来 scale</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img233732.png"></p><blockquote><p>EFS 并不是永远最贵的, 但 S3 永远是最便宜的。<br>在性能方面，AWS EBS 由于可以提供高 IOPS，速度最快。但是在共享和可弹性伸缩的文件系统方面，AWS EFS 是最好的选择。</p></blockquote><hr><h3 id="5-ELB-amp-ASG"><a href="#5-ELB-amp-ASG" class="headerlink" title="5. ELB &amp; ASG"></a>5. ELB &amp; ASG</h3><h4 id="Scalability-amp-High-Availability"><a href="#Scalability-amp-High-Availability" class="headerlink" title="Scalability &amp; High Availability"></a>Scalability &amp; High Availability</h4><ul><li>Vertical (竖直) Scale: Increase the size of the Instance (增加大小)</li><li>Horizontal (水平) Scale: Increase the number of the Instance (增加数量)</li><li>High Availability: Running application in at least 2 AZ (Disaster recovery, 重要)</li></ul><blockquote><p>high availability + high scalability 是 <code>ALB + ECS</code> 或者 <code>API Gateway + Lambda</code></p></blockquote><hr><h4 id="AWS-ELB"><a href="#AWS-ELB" class="headerlink" title="AWS ELB"></a>AWS ELB</h4><ul><li>Foward traffic to multiple EC2 Instances (流量控制)<ul><li>High availability across AZs, handle failures of downstream instances</li></ul></li><li>Health Check: 可以知道 EC2 Instance 是否是 Healthy 的<ul><li>ELB 在 public subnet, ASG 在 private subnet (重要)</li></ul></li><li>ELB cannot distribute traffic for targets deployed in different region</li><li>使用 ELB 的原因, 有 2 点<ul><li>Separate public traffic from private traffic</li><li>Build a highly available system</li></ul></li><li>Elastic Load Balancing use ports <code>1024-65535</code></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img141400.png"></p><ul><li>Application Load Balancer (HTTP &#x2F; HTTPS, Layer 7)</li><li>Network Load Balancer (TCP &#x2F; UDP, Layer 4)<ul><li>NLB provide static DNS and static IP, ALB only provide static DNS</li></ul></li><li>Gateway Load Balancer (Security, Layer 3, 要特别注意)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img090125.png"></p><ul><li>如果问到 ELB route traffic 到一个 instance 或者 AZ 更多, 有 2 种可能性<ul><li>Instances of a specific capacity type aren’t equally distributed across AZ</li><li>Sticky sessions are enabled for the load balancer</li></ul></li></ul><hr><h4 id="Application-Load-Balancer-ALB"><a href="#Application-Load-Balancer-ALB" class="headerlink" title="Application Load Balancer (ALB)"></a>Application Load Balancer (ALB)</h4><ul><li>Deal with Layer 7 (HTTP &#x2F; HTTPS, WebSocket)</li><li>Route base on Path <code>/Home</code> or Query <code>?Platform=Mobile</code></li><li>ALB adds an additional header called <code>X-Forwarded-For</code> contains the client’s IP</li><li>可以 configure ALB to redirect HTTP to HTTPS (重要)</li><li>ALB 无法被 assign Elstaic IP, NLB 可以</li><li>如果 ALB 没有 register 任何 target, 会造成 <code>HTTP 503: Service unavailable</code></li><li>可以使用 ALB access logs 来 analyze incoming requests for latencies and IP address</li><li>You cannot specify publicly routable IP addresses to an ALB</li><li>An ALB has three possible target types: Instance, IP, and Lambda</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img192523.png"></p><ul><li>Routing tables to different target groups<ul><li>Route based on path in URL</li><li>Route based on hostname in URL</li><li>Route based on Query String, Headers, Client IP</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img142631.png"></p><blockquote><p>To forward all requests to the website so that the requests will use HTTPS, a solutions architect can create a listener rule on the ALB that redirects HTTP traffic to HTTPS.</p></blockquote><hr><h4 id="Network-Load-Balancer-NLB"><a href="#Network-Load-Balancer-NLB" class="headerlink" title="Network Load Balancer (NLB)"></a>Network Load Balancer (NLB)</h4><ul><li>Deal with Layer 4 (TCP &#x2F; UDP), 很快, 处理有大量 request 的情况 (比如银行和游戏)<ul><li>NLB best suited for use-cases involving low latency and high throughput workloads</li></ul></li><li>One static IP per AZ or use Elastic IP</li><li>NLB supports HTTP health checks as well as TCP and HTTPS</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img144359.png"></p><blockquote><p>If you specify targets using an instance ID, traffic is routed to instances using the primary private IP address specified in the primary network interface for the instance.</p></blockquote><hr><h4 id="Gateway-Load-Balancer-GWLB"><a href="#Gateway-Load-Balancer-GWLB" class="headerlink" title="Gateway Load Balancer (GWLB)"></a>Gateway Load Balancer (GWLB)</h4><ul><li>Deal with Layer 3 (Security, 3rd Party)</li><li>GWLB allows perform inline inspection of traffic from multiple spoke VPCs in a simplified and scalable fashion</li><li>Use GENEVE protocol on port 6081</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img223042.png"></p><hr><h4 id="Sticky-Sessions-Session-Affinity"><a href="#Sticky-Sessions-Session-Affinity" class="headerlink" title="Sticky Sessions (Session Affinity)"></a>Sticky Sessions (Session Affinity)</h4><ul><li>Same client is always redirect to the same instance behind a load balancer</li><li>Make sure user doesn’t loss session data (比如用户登录)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img223425.png"></p><ul><li>Application-based Cookies: Don’t use AWSALB, AWSALBAPP, AWSALBTG</li><li>Duration-based Cookies: AWSALB for ALB, AWSELB for CLB</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img223604.png"></p><hr><h4 id="Cross-Zone-Load-Balancing"><a href="#Cross-Zone-Load-Balancing" class="headerlink" title="Cross Zone Load Balancing"></a>Cross Zone Load Balancing</h4><ul><li>ELB distributes traffic evenly across all registered EC2 instances in all AZs<ul><li>所有 Instance 分到的 traffic 一定是一样的</li><li>如果没有 enable, 那么 AZ 内部就是平均分</li></ul></li><li>ALB enabled by default, NLB disabled by default (重要)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img230059.png"></p><hr><h4 id="SSL-Certificates"><a href="#SSL-Certificates" class="headerlink" title="SSL Certificates"></a>SSL Certificates</h4><ul><li>Allow traffic between client and load balancer encrypted in transit (HTTPS)<ul><li>Manage SSL certificates using ACM (AWS Certificate Manager)</li></ul></li><li>如果问到需要管理很多个 SSL 或者 TSL, 选择 SNI (重要)</li><li>用来 deploy SSL&#x2F;TLS 的 AWS 服务是 AWS Certificate Manger 和 IAM (重要)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img230614.png"></p><ul><li>Could be used in ALB &amp; NLB, use SNI to make it work</li><li>SNI: Load multiple SSL certificates onto one web server (Server Name Indication)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img230910.png"></p><blockquote><p>Server Name Indication (SNI) allows you to expose multiple HTTPS applications each with its own SSL certificate on the same listener.</p></blockquote><hr><h4 id="Deregistration-Delay-Connection-Draining"><a href="#Deregistration-Delay-Connection-Draining" class="headerlink" title="Deregistration Delay (Connection Draining)"></a>Deregistration Delay (Connection Draining)</h4><ul><li>Waiting for existing connections to complete</li><li>Connection Draining enables the load balancer to complete in-flight requests made to instances that are de-registering or unhealthy</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img231418.png"></p><hr><h4 id="AWS-ASG"><a href="#AWS-ASG" class="headerlink" title="AWS ASG"></a>AWS ASG</h4><ul><li>ASG 可以和 ELB 一起用, 来 scale in 或者 out 基于服务器压力 (ASG 是免费的)</li><li>ASG 可以保证最少或最多有多少 EC2 Instance 在工作 (min, max)<ul><li>ASG 是在一个 Region 里面去根据 availiable 的 AZ 进行 scale</li><li>ASG 没有办法 span across multiple Regions</li></ul></li><li>当一个 Instance 是 unhealthy 的时候, ASG 会 terminate 这个 Instance<ul><li>ASG 在一个 AZ 里最早 terminate 的是那个最早被 launch 的 Instance</li><li>遇到 unbalanced 的情况, ASG 是先 launch new instance 然后 terminate old instance</li><li>在 unhealthy 的情况下是先 terminate unhealth Instance 然后 create new instance</li></ul></li><li>如果问到在某个节日前去 scale, 那就是 ASG Scheduled Action</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img232350.png"></p><ul><li>可以和 ELB 一起用, 来 scale out 或者 in 基于服务器压力</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img232615.png"></p><ul><li>Launch Template: 可以作为 template 来生成 EC2 Instance<ul><li>Launch Template 是管要生成什么 Instance 的 (eg. Spot, On-Demand)</li><li>Launch Configuration 是管生成的 Instance 的信息的 (eg. AMI, security group)</li></ul></li><li>如果要更新 Launch Template, 需要删掉旧的然后使用新的 (注意)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img232823.png"></p><ul><li>可以和 CloudWatch Alarm 一起根据服务器压力 scale out 或 scale in<ul><li>需要一个 CloudWatch custom metric</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img232959.png"></p><ul><li>ASG Scaling Cooldowns<ul><li>After a scaling activity, you are in the cooldown period (default 300 seconds)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img025149.png"></p><ul><li>ASG 不 terminate Instance 的情况<ul><li>The health check grace period for the instance has not expired</li><li>The instance maybe in Impaired status</li><li>The instance has failed the Elastic Load Balancing (ELB) health check status</li></ul></li><li>如果 ASG 没有 replace unhealthy EC2 Instance, 需要 change health check type from EC2 to ELB using configuration file</li></ul><hr><h4 id="Scaling-Policies"><a href="#Scaling-Policies" class="headerlink" title="Scaling Policies"></a>Scaling Policies</h4><ul><li>Target Tracking Scaling: 根据 CPU 用量或者 SQS 长度来 scale</li><li>Simple &#x2F; Step Scaling: 和 CloudWatch Alarm 关联</li><li>Scheduled Actions: 比如在感恩节那天进行 scale</li><li>Predictive Scaling: Forecast load and schedule scaling ahead</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img233532.png"></p><ul><li>注意, 对于 EC2 Scaling Policy 来说, 一定不可能超过 maximum capacity (重要)</li></ul><hr><h4 id="ASG-Instance-Refresh"><a href="#ASG-Instance-Refresh" class="headerlink" title="ASG Instance Refresh"></a>ASG Instance Refresh</h4><ul><li>Update launch template and then re-creating all EC2 Instance</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img212220.png"></p><hr><h3 id="6-AWS-Fundamentals"><a href="#6-AWS-Fundamentals" class="headerlink" title="6. AWS Fundamentals"></a>6. AWS Fundamentals</h3><h4 id="AWS-RDS"><a href="#AWS-RDS" class="headerlink" title="AWS RDS"></a>AWS RDS</h4><ul><li>使用 RDS 的好处 (对比将数据库存在 EC2 上)<ul><li>Automated provisioning, auto-scaling, backup</li><li>Read Replicas (最多 15 个) 和 Multi-AZ</li></ul></li><li>RDS Read Replica: If master database is encrypted, the replica is also encrypted<ul><li>注意, Read Replica 提高的是 read, 而不是 scale 数据库的 storage (而且 Replica 贵), 处理类似 report 或者 analytics 的就是 Read Replica</li><li>Read Replica 不是提高 High Availability, Multi-AZ 才是</li><li>Cross-Region Read Replica: 可以作为 DB backup (Replica in different Region)</li></ul></li><li>RDS Multi-AZ: RDS create a primary DB Instance and synchronously replicates the data to a standby instance in a different AZ (High Availability)<ul><li>RDS Multi-AZ update 是 standby 和 primary 一起 update (会有 downtime)</li></ul></li><li>Support MySQL, PostgreSQL, MariaDB, Oracle, MS SQL Server, and Amazon Aurora</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img161720.png"></p><ul><li>RDS - Storage Auto Scaling (重要)<ul><li>For application with unpredictable workloads</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img161952.png"></p><ul><li>RDS - Disaster Recovery<ul><li>Create a Read Replica in different region and enable Multi-AZ on Read Replica</li></ul></li><li>IAM Database Authentication: 可以用来访问 RDS</li><li>可以从 RDS Read Replica 迁移到 Aurora Read Replica, 这个做法可以 minimal change<ul><li>注意, 这只适用于 Read Replica 的情况下, 正常情况就直接开 auto scaling</li></ul></li><li>RDS OS update 是先 update standby, 然后把 standby promote 成 primary, 然后 update 原来的 primary, 最后原来的 primary 变成新的 standby (重要)</li></ul><hr><h4 id="Read-Replicas-vs-Multi-AZ"><a href="#Read-Replicas-vs-Multi-AZ" class="headerlink" title="Read Replicas vs. Multi AZ"></a>Read Replicas vs. Multi AZ</h4><ul><li>Read Replicas: Scalability, Async Replication<ul><li>Within AZ, Cross AZ or Cross Region</li></ul></li><li>Read Replicas in Same Region is free (Replication in AZs), Cross Region is not free</li><li>You can’t create encrypted Read Replicas from an unencrypted RDS DB instance.</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img173522.png"></p><ul><li>用 Production databse 处理日常, 用 Read Replica 来建一个副本处理数据分析</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img173820.png"></p><ul><li>Multi AZ: High Availability, Disaster Recovery, Sync Replication<ul><li>在 Multi-AZ 的情况下, 当 RDS 数据库 goes down, CNAME 会更新指向 standby</li><li>Multi AZ 不需要你去更改 SQL connection string</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img174148.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img174357.png"></p><hr><h4 id="AWS-Aurora"><a href="#AWS-Aurora" class="headerlink" title="AWS Aurora"></a>AWS Aurora</h4><ul><li>Support PostgreSQL and MySQL (不需要管理 storage)</li><li>Aurora 没有 standby database, Aurora Replica 可以作为 failover target</li><li>一般来说, Aurora 比 RDS 快</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img183915.png"></p><ul><li>High Availiability &amp; Read Scaling (Aurora Read Replica)<ul><li>One Master Write, Multiple Read Replicas (Up to 15 Replica), 一共 16 个</li><li>如果问到和 Aurora 有关, 且关于处理网络请求激增的问题, 选 Aurora Replica</li><li>Replica Tier 越高, failover 时就会先被 promote</li></ul></li><li>如果问到关于 Aurora 的 Auto-Scaling, 那就是 Aurora Serverless</li><li>如果问到 Aurora 而且是 test database, 选择 Aurora Database Cloning</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img184105.png"></p><hr><h4 id="RDS-Security"><a href="#RDS-Security" class="headerlink" title="RDS Security"></a>RDS Security</h4><ul><li>At-rest encryption: AWS KMS (Key Management Service)</li><li>In-flight encryption: AWS TLS Certificates</li><li>IAM Authentication: IAM roles to connect to database (重要)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img133048.png"></p><hr><h4 id="RDS-Proxy"><a href="#RDS-Proxy" class="headerlink" title="RDS Proxy"></a>RDS Proxy</h4><ul><li>Have a proxy for access RDS or Aurora, 缓解数据库压力, minimize open connections<ul><li>Allow apps to pool and share DB connections (提高 DB efficiency)</li><li>Reduced RDS &amp; Aurora failover time by up 66% (重要)</li><li>Enforce IAM authentication for DB</li></ul></li><li>Serverless, auto scaling, highly avaliable (Multi-AZ)</li><li>Not publicly accessible (Need to use VPC)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img184531.png"></p><hr><h4 id="AWS-ElastiCache"><a href="#AWS-ElastiCache" class="headerlink" title="AWS ElastiCache"></a>AWS ElastiCache</h4><ul><li>Manage Redis or Memcached (ElastiCache 可以解决数据库高频读取的问题, 重要)<ul><li>ElastiCache 不支持 relational database, 也不能用 SQL queries</li></ul></li><li>Cache are in-memory database with high performance and low latency (compute-intensive)</li><li>Cache helps reduce load off of database for read intensive workload (read heavy)</li><li>Help to make application stateless (AWS 负责大部分工作)</li><li>处理 S3 的是 CloudFront, 而不是 ElastiCache (记住)</li><li>支持 multi-threading 的是 ElastiCache for Memcached</li><li>关于 ElastiCache for Redis cluster 的 2 个知识点<ul><li>All the nodes in a Redis cluster must reside in the same region</li><li>While using Redis with cluster mode enabled, you cannot manually promote any of the replica nodes to primary</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img184841.png"></p><ul><li>DB Cache: Get data from ElastiCache<ul><li>If not avaliable, get from RDS and store in ElastiCache</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img185024.png"></p><ul><li>User Session: Write Session data into ElastiCache<ul><li>User in another instance could still be logged in</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img185153.png"></p><ul><li>Redis vs Memcahed<ul><li>Redis: Read Replicas, High Availiablity, Backup and restore (非常重要)</li><li>Memcached: Not High Availiablity, No Backup, risk to lose data, Multi-threaded</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img185310.png"></p><blockquote><p>The maximum number of Read Replicas you can add in an ElastiCache Redis Cluster with Cluster Mode Disabled is 5.</p></blockquote><hr><h4 id="ElastiCache-Strategies"><a href="#ElastiCache-Strategies" class="headerlink" title="ElastiCache Strategies"></a>ElastiCache Strategies</h4><ul><li>Lazy Loading &#x2F; Cache-Aside &#x2F; Lazy Population<ul><li>Pros: Only requested data is cached (重要, only requested data)</li><li>Cons: Cache miss penalty results in 3 round trips &amp; stale data (数据可能不是最新的)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img200816.png"></p><ul><li>Write Through (write 耗时, 但是 read 的 latency 很低)<ul><li>Pros: Data in cache is never stale, write penalty with 2 calls (数据一定是最新的)</li><li>Cons: Missing data until data is added &#x2F; updated in the DB</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img201308.png"></p><ul><li>Cache Evictions &amp; Time-to-live (TTL)<ul><li>Cache Evictions: 这里指的是缓存达到上限的情况, 需要用 TTL 去按时清理缓存</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img201512.png"></p><hr><h4 id="MemoryDB-for-Redis"><a href="#MemoryDB-for-Redis" class="headerlink" title="MemoryDB for Redis"></a>MemoryDB for Redis</h4><ul><li>Redis-compatible, durable, in-memory database service (为 Redis 服务)</li><li>Durable in-memory data storage with Multi-AZ transactional log</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img201727.png"></p><hr><h3 id="7-Route-53"><a href="#7-Route-53" class="headerlink" title="7. Route 53"></a>7. Route 53</h3><h4 id="What’s-DNS"><a href="#What’s-DNS" class="headerlink" title="What’s DNS"></a>What’s DNS</h4><ul><li>Translate hostname into IP address: <code>www.google.com = 172.217.18.36</code></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img213136.png"></p><hr><h4 id="AWS-Route-53"><a href="#AWS-Route-53" class="headerlink" title="AWS Route 53"></a>AWS Route 53</h4><ul><li>User can update the DNS records (High available, scalable)</li><li>Route 53 is a Domain Registrar</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img213527.png"></p><ul><li>Route 53 Records:<ul><li>Domain Name, Record Type, Value, Routing Policy, TTL</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img213613.png"></p><ul><li>Route 53 Record Types<ul><li>A: IPv4</li><li>AAAA: IPv6</li><li>CNAME: Map hostname to another hostname</li><li>NS: Name Servers for the Hosted Zone</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img213753.png"></p><ul><li>Route 53: Hosted Zones<ul><li>Public Hosted Zones: Public domain name</li><li>Private Hosted Zones: Private domain name (VPC)</li></ul></li></ul><blockquote><p>注意, DNS hostnames and DNS resolution are required settings for private hosted zones</p></blockquote><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img234126.png"></p><ul><li>GoDaddy + Route 53 (As DNS Service Provider)<ul><li>Create a Public Hosted Zone and update the 3rd party Registrar NS records</li></ul></li><li>Route 53 Health Check<ul><li>如果 ELB 出问题, 就去找 Route 53 Health Check</li></ul></li></ul><hr><h4 id="Route-53-TTL"><a href="#Route-53-TTL" class="headerlink" title="Route 53 TTL"></a>Route 53 TTL</h4><ul><li>TTL: Time To Live (生存时间)<ul><li>How long the value should be cached (后端更新不代表 cache 更新了)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img232659.png"></p><hr><h4 id="CNAME-vs-Alias"><a href="#CNAME-vs-Alias" class="headerlink" title="CNAME vs Alias"></a>CNAME vs Alias</h4><ul><li>CNAME: Point a hostname to another hostname<ul><li>从 <code>acme.example.com</code> 到 <code>zenith.example.org</code> 或者 <code>example.com</code> 到 <code>example.net</code></li></ul></li><li>Alias: Point a hostname to an AWS resource (对象是 CloudFront, S3 这些)<ul><li>从 <code>covid19survey.com</code> 到 <code>www.covid19survey.com</code></li><li>从 <code>app.mydomain.com</code> 到 <code>app.amazonaws.com</code></li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img233313.png"></p><hr><h4 id="Health-Checks"><a href="#Health-Checks" class="headerlink" title="Health Checks"></a>Health Checks</h4><ul><li>Health Checks are only for public resources</li><li>Health Check 检测: Endpoints, 其他 Health Checks, CloudWatch Alarms (重要)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img000106.png"></p><hr><h4 id="Routing-Policy-Simple"><a href="#Routing-Policy-Simple" class="headerlink" title="Routing Policy (Simple)"></a>Routing Policy (Simple)</h4><ul><li>Define how Route 53 responds to DNS queries (一共 7 种 Routing Policies)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img234623.png"></p><ul><li>Simple: Route traffic to a single resource<ul><li>If multiple values returned, a random one is chosen by client</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img234350.png"></p><hr><h4 id="Routing-Policy-Weighted"><a href="#Routing-Policy-Weighted" class="headerlink" title="Routing Policy (Weighted)"></a>Routing Policy (Weighted)</h4><ul><li>Weighted: Control the % of the request go to each resource</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img234856.png"></p><hr><h4 id="Routing-Policy-Latency"><a href="#Routing-Policy-Latency" class="headerlink" title="Routing Policy (Latency)"></a>Routing Policy (Latency)</h4><ul><li>Latency: Redirect to the resource that has the least latency close to us</li><li>Latency is based on traffic between users and AWS Regions</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img235654.png"></p><hr><h4 id="Routing-Policy-Failover"><a href="#Routing-Policy-Failover" class="headerlink" title="Routing Policy (Failover)"></a>Routing Policy (Failover)</h4><ul><li>Failover: Have a Primary Instance and a Secondary Instance (重要)<ul><li>When failover, switch to Secondary Instance</li></ul></li><li>注意, 当问到 failover 的时候, 选择的是 active-passive failover routing policy<ul><li>没有什么 active-active, 只有 active-passive</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img150940.png"></p><hr><h4 id="Routing-Policy-Geolocation"><a href="#Routing-Policy-Geolocation" class="headerlink" title="Routing Policy (Geolocation)"></a>Routing Policy (Geolocation)</h4><ul><li>Geolocation: Routing based on user location<ul><li>Need to create a “Default” record</li><li>Use cases: website localization, restrict content distribution 等等</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img151650.png"></p><hr><h4 id="Routing-Policy-Geoproximity"><a href="#Routing-Policy-Geoproximity" class="headerlink" title="Routing Policy (Geoproximity)"></a>Routing Policy (Geoproximity)</h4><ul><li>Geoproximity: Route traffic to resource based on geolocation<ul><li>But have the ability to shift more traffic to resource based on bias (重要)</li><li>可以做到 route more traffic or less</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img152310.png"></p><hr><h4 id="Routing-Policy-Traffic-Flow"><a href="#Routing-Policy-Traffic-Flow" class="headerlink" title="Routing Policy (Traffic Flow)"></a>Routing Policy (Traffic Flow)</h4><ul><li>Visual editor to manage complex routing decision trees<ul><li>Configuration can be saved as Traffic Flow Policy</li><li>Can be applied to different Route 53 Hosted Zone</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img224018.png"></p><hr><h4 id="Routing-Policy-IP-Based"><a href="#Routing-Policy-IP-Based" class="headerlink" title="Routing Policy (IP-Based)"></a>Routing Policy (IP-Based)</h4><ul><li>IP-Based: Routing based on client’s IP address<ul><li>Provide a list of CIDRs for your client</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img153711.png"></p><hr><h4 id="Routing-Policy-Multi-Value"><a href="#Routing-Policy-Multi-Value" class="headerlink" title="Routing Policy (Multi-Value)"></a>Routing Policy (Multi-Value)</h4><ul><li>Multi-Value: Route traffic to multiple resources<ul><li>Not a subsitute for ELB</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img153842.png"></p><hr><h3 id="8-VPC-Fundamentals"><a href="#8-VPC-Fundamentals" class="headerlink" title="8. VPC Fundamentals"></a>8. VPC Fundamentals</h3><h4 id="AWS-VPC"><a href="#AWS-VPC" class="headerlink" title="AWS VPC"></a>AWS VPC</h4><ul><li>VPC: Virtual Private Cloud, all AWS account have a default VPC</li><li>CIDR should not overlap, max CIDR size in AWS is &#x2F;16, min CIDR size in AWS is &#x2F;28</li><li>要让 VPC 使用 custom domain 需要 <code>enableDnsHostnames</code> 和 <code>enableDnsSupport</code></li><li>可以创建 Shared Service VPC, 这样每个 VPC 都可以 access 到需要的 services (重要)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img201530.png"></p><ul><li>Each Amazon EC2 instance that you launch into a VPC has a tenancy attribute (重要)<ul><li>可以在 dedicated 和 host 之间互相切换</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img042420.png"></p><hr><h4 id="VPC-Subnet"><a href="#VPC-Subnet" class="headerlink" title="VPC Subnet"></a>VPC Subnet</h4><ul><li>Allow you to partition your network inside the VPC (VPC 内划分网络)<ul><li>Can have Public Subnet and Private Subnet</li></ul></li><li>AWS reserves 5 IP addresses in each subnet (first 4 &amp; last 1, 重要)</li><li>Subnet is always associated with Route Table (重要)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img013421.png"></p><hr><h4 id="Internet-Gateway-IGW-amp-Route-Table"><a href="#Internet-Gateway-IGW-amp-Route-Table" class="headerlink" title="Internet Gateway (IGW) &amp; Route Table"></a>Internet Gateway (IGW) &amp; Route Table</h4><ul><li>IGW allow resource (eg. EC2 Instance) in a VPC connect to internet (重要)<ul><li>相当于让 VPC 里的 resource 可以连上网</li><li>IGW 需要 Route Table (重要)</li></ul></li><li>如果 IGW 出问题<ul><li>Need to also have Route Table (首先检查 Route Table, 因为 IGW 需要)</li><li>检查 Security Group 是否允许通过</li></ul></li><li>处理 Network Address Translation 的就是 Internet Gateway</li><li>Internet Gateway 无法直接在 private subnet 里面使用 (重要)</li><li>NAT 针对的是 Subnet 层面, IGW 针对的是 VPC 层面 (重要)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img202043.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img193121.png"></p><hr><h4 id="NAT-Gateway-NATGW"><a href="#NAT-Gateway-NATGW" class="headerlink" title="NAT Gateway (NATGW)"></a>NAT Gateway (NATGW)</h4><ul><li>AWS managed NAT, AZ specific, use Elastic IP (针对 IPv4, Egress 是 IPv6)<ul><li>Allow EC2 Instance in Private Subnet to connect to the Internet</li><li>Requires an IGW, NATGW 是处于 public subnet 的 (注意)</li></ul></li><li>NAT 针对的是 Subnet 层面, IGW 针对的是 VPC 层面</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img233648.png"></p><ul><li>Resilient within single AZ, Multiple-AZ need multiple NATGW<ul><li>每个 AZ 都要一个 NATGW, 用来 fault-tolerance (容错能力)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img203654.png"></p><hr><h4 id="NACL-amp-Security-Groups"><a href="#NACL-amp-Security-Groups" class="headerlink" title="NACL &amp; Security Groups"></a>NACL &amp; Security Groups</h4><ul><li>The request has to go over NACL before go to Subnet (Subnet level)<ul><li>NACL is stateless (inbound outbound 都要检测)</li></ul></li><li>The request has to go over Security Group before go to EC2 Instance (Instance level)<ul><li>Security Group (SG) is stateful (inbound accepted &#x3D; outbound accepted)</li></ul></li><li>反正记住 NACL 是 Subnet level (stateless), Security Group 是 Instance level (stateful)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img204310.png"></p><ul><li>Network Access Control List (NACL)<ul><li>NACL control traffic from and to subnets (eg. block IP)</li><li>One NACL per subnet, each subnet have default NACL (注意)<ul><li>Default NACL accept every inbound and outbound</li><li>但是 custom NACL 默认是 deny inbound 和 outbound 的 (注意)</li></ul></li><li>NACL Rules have number, higher precedence with lower number (越优先数字越低)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img204553.png"></p><hr><h4 id="VPC-Flow-Logs"><a href="#VPC-Flow-Logs" class="headerlink" title="VPC Flow Logs"></a>VPC Flow Logs</h4><ul><li>Capture information about IP traffic going into interfaces (监视 IP 流量的)<ul><li>Monitor &amp; troubleshoot connectivity issues (网络连接问题)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img231819.png"></p><hr><h4 id="VPC-Peering"><a href="#VPC-Peering" class="headerlink" title="VPC Peering"></a>VPC Peering</h4><ul><li>VPC Peering: Privately connect two VPCs using AWS network (只适合少量 VPC, 重要)<ul><li>每一对 VPC 都要 VPC Peering, 和 S3 Replication 类似</li></ul></li><li>Can create VPC Peering between VPCs in different AWS accounts &#x2F; regions</li><li>Need to update Route Table in each VPC subnet to make sure they can communicate<ul><li>出问题就检查 Route Table</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img205313.png"></p><hr><h4 id="VPC-Sharing"><a href="#VPC-Sharing" class="headerlink" title="VPC Sharing"></a>VPC Sharing</h4><ul><li>VPC Sharing: Allows multiple AWS accounts to create resources (eg. EC2, RDS) into shared and centrally-managed AWS VPC (重要)<ul><li>遇到 centrally managed 的就是 VPC Sharing</li><li>而且是 owner 需要 share one or more subnet (注意)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img824817.png"></p><hr><h4 id="VPC-Endpoints-AWS-PrivateLink"><a href="#VPC-Endpoints-AWS-PrivateLink" class="headerlink" title="VPC Endpoints (AWS PrivateLink)"></a>VPC Endpoints (AWS PrivateLink)</h4><ul><li>VPC Endpoints allow private access to AWS services within a VPC (重要)<ul><li>用 Private Network 连接 AWS 服务, 和 On-Premise 没有关系</li><li>Interface Endpoint 支持大部分 AWS 服务 (付费)</li><li>Gateway Endpoint 只支持 S3 和 DynamoDB (很容易考, 免费)</li></ul></li><li>注意, VPC Gateway Endpoint 专门处理 S3 和 DynamoDB (不要去选择 NAT 或者 IGW)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img205719.png"></p><ul><li>两种 Types of Endpoints (Interface &#x2F; Gateway)<ul><li>Interface Endpoints: Supports most AWS services (付费)</li><li>Gateway Endpoints: Must be used as a target in a route table (免费, 重要)<ul><li>Only support S3 and DynamoDB (只支持 S3 和 DynamoDB)</li></ul></li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img205939.png"></p><hr><h4 id="Site-to-Site-VPN-VPN-Connection"><a href="#Site-to-Site-VPN-VPN-Connection" class="headerlink" title="Site-to-Site VPN (VPN Connection)"></a>Site-to-Site VPN (VPN Connection)</h4><ul><li>Site-to-Site VPN: Connect AWS to Corporate Data Center over public internet (重点, public internet, On-Premise to AWS)<ul><li>Need a Virtual Private Gateway (VGW) on VPC (AWS 方)</li><li>Need a Customer Gateway (CGW) on DC (On-Premise 方)</li></ul></li><li>对比 DX, Site-to-Site VPN 没有提供 low latency, and high throughput connection</li><li>Site-to-Site VPN 有 encrypted network connectivity between On-Premise and VPC</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img232320.png"></p><ul><li>需要 VPN Gateway 和 Customer Gateway 来连接 VPC 和 On-Premise</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img232649.png"></p><hr><h4 id="Direct-Connect-DX"><a href="#Direct-Connect-DX" class="headerlink" title="Direct Connect (DX)"></a>Direct Connect (DX)</h4><ul><li>Provide a dedicated private connection from a remote network to VPC (重点, private internet, On-Premise to AWS)<ul><li>需要设置 VGW, 如果给 DX 找 backup, 那么就选择 Site-to-Site VPN (这两个服务类似)</li><li>对比 Site-to-Site VPN, DX provide low latency, and high throughput connection</li><li>DX 不支持 encrypted network connectivity, Site-to-Site VPN 可以, 但是如果需要 encrypt DX connection 可以和 AWS VPN 一起用 (注意)</li><li>DX 的 set up 时间很长 (所以 DX 不算什么 quick solution)</li></ul></li><li>All private, no public network involve (注意, 如果问到 all Private 就是 DX)<ul><li>Direct Connect does not involve the Internet</li></ul></li><li>可以 access public resources (S3) 和 private resources (EC2)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img233024.png"></p><ul><li>两种 Connection Type (带宽选项, Dedicated 最快)<ul><li>Dedicated Connections: 1Gbps 到 100Gbps</li><li>Hosted Connections: 50Mbps 到 10 Gbps</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img004140.png"></p><ul><li>Direct Connect Gateway (连接许多 VPC 在不同的 Region)<ul><li>Direct Connection to one or more VPC in many different regions</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img233531.png"></p><ul><li><p>PrivateLink vs DX</p><ul><li><p>AWS PrivateLink provides a connection between VPCs (Virtual Private Clouds) and AWS services while bypassing the public Internet. It is a private network connection that securely transfers data without leaving the AWS network</p></li><li><p>AWS Direct Connect is a dedicated, private connection between the customer’s on-premises infrastructure at a data center and an AWS location. The main features of the connection are ultra-fast data transfer rates, low latency, and improved security since it bypasses the public Internet</p></li></ul></li></ul><hr><h3 id="9-S3"><a href="#9-S3" class="headerlink" title="9. S3"></a>9. S3</h3><h4 id="AWS-S3"><a href="#AWS-S3" class="headerlink" title="AWS S3"></a>AWS S3</h4><ul><li>S3 Buckets (S3 是 Global 的, 但是 Bucket 是 Regional 的)<ul><li>Store objects (files) in “buckets”</li><li>Buckets must have globally unique name (名字必须独特)</li><li>Buckets are defined at region level</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img171839.png"></p><ul><li>Objects (files) have a key, max object size is 5TB</li><li>如果上传超过 5 GB, 就要用 Multi-Part Upload (还有 S3 Transfer Acceleration)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img172025.png"></p><ul><li>S3 sync command: Uses the <code>CopyObject</code> APIs to copy objects between S3 buckets</li><li>S3 always return the lastest version of the object (重要)</li><li>S3 没办法加密 metadata</li><li>S3 是 serverless 的</li><li>如果遇到需要处理 static content 的, 就一定是 S3 + CloudFront (重要)</li><li>如果问到 S3 而且是关于图片上传, 选择 S3 Event Notification, 不是 EventBridge (重要)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/imglifecycle-transitions-v2.png"></p><ul><li>如果发现 S3 的传输功能出问题, 那么就给 S3 bucket 加上 prefix (重要)</li><li>注意, S3 和 database 是不沾边的, S3 不是数据库</li><li>如果要 control access to data stored on AWS S3, 可以用下面 2 点<ul><li>Query String Authentication, Access Control List (ACLs)</li><li>Bucket policies, Identity and Access Management (IAM) policies</li></ul></li><li>In order to get object access log, the object owner also need to be bucket owner</li><li>S3 Object Ownership is a S3 bucket setting that control ownership of new objects that are uploaded to a bucket (重要)</li></ul><blockquote><p>By default, an Amazon S3 object is owned by the AWS account that uploaded it. This is true even when the bucket is owned by another account (重要)</p></blockquote><ul><li>关于 S3 data consistency model, 有 2 点<ul><li>A process deletes an existing object and immediately tries to read it. Amazon S3 will not return any data as the object has been deleted</li><li>If you delete a bucket and immediately list all buckets, the deleted bucket might still appear in the list</li></ul></li></ul><hr><h4 id="S3-Bucket-Policy"><a href="#S3-Bucket-Policy" class="headerlink" title="S3 Bucket Policy"></a>S3 Bucket Policy</h4><ul><li>User-Based Security<ul><li>IAM Policies: Which API calls should be allowed for a user from IAM (重要)</li></ul></li><li>Resource-Based Security<ul><li>Bucket Policies: Bucket rules (比如让 object public)</li></ul></li><li>注意, IAM Policy 的 precedence 是比 S3 Bucket Policy 要优先的</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img173050.png"></p><ul><li>S3 Bucket Policies (JSON based policies)<ul><li>Resoruces: buckets and objects</li><li>Effect: Allow &#x2F; Deny</li><li>Actions: API to Allow or Deny</li><li>Principal: The account or user to apply the policy to</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img173325.png"></p><hr><h4 id="S3-Website"><a href="#S3-Website" class="headerlink" title="S3 Website"></a>S3 Website</h4><ul><li>Host 在 S3 上面的网站一般是以下两种后缀 (dash Region 或者 dot Region)<ul><li>s3-website-Region: <code>http://bucket-name.s3-website-Region.amazonaws.com</code></li><li>s3-website.Region: <code>http://bucket-name.s3-website.Region.amazonaws.com</code></li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img043622.png"></p><hr><h4 id="S3-Versioning"><a href="#S3-Versioning" class="headerlink" title="S3 Versioning"></a>S3 Versioning</h4><ul><li>Enabled at the bucket level (Default is null)</li><li>Best pratice to version the buckets (可以 roll back, 可以防止误删, 重要)<ul><li>可以防止 accidental deletion of objects</li></ul></li><li>Once version-enable a bucket, it can never return to an unversioned state (重要)</li><li>Versioning 是针对这个 bucket 里面的所有 object, 所以不能指定 folder 来 versioning</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img174246.png"></p><hr><h4 id="S3-Replication-CRR-amp-SRR"><a href="#S3-Replication-CRR-amp-SRR" class="headerlink" title="S3 Replication (CRR &amp; SRR)"></a>S3 Replication (CRR &amp; SRR)</h4><ul><li>CRR: Cross Region Replication (compliance, lower latency access)</li><li>SRR: Same Region Replication (create test environment)<ul><li>Must enable Versioning</li><li>The Copying is asynchronous</li><li>Must give IAM permissions to S3</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img174840.png"></p><ul><li>Only new objects are replicated, existing objects need S3 Batch Replication<ul><li>也就是说只有新的 object 会被 Replicate, 老的 object 要 S3 Batch Replication</li></ul></li><li>No “chaining” in replication<ul><li>比如把 A 复制到 B 和 C, 需要 A 复制到 B 和 A 复制到 C</li></ul></li><li>S3 lifecycle actions are not replicated with S3 Replication</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img175004.png"></p><hr><h4 id="S3-Storage-Classes"><a href="#S3-Storage-Classes" class="headerlink" title="S3 Storage Classes"></a>S3 Storage Classes</h4><ul><li>一共 7 种 Storage Class: General + 2 IA + 3 Glacier + Intelligent</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img175742.png"></p><ul><li>S3 Standard - General Purpose<ul><li>Used for frequently accessed data (最常见)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img175932.png"></p><ul><li>S3 Infrequent Access (Standard IA &amp; One Zone IA)<ul><li>For data is less frequent access but require rapid access when needed (重要)</li><li>Lower cost than Standard</li><li>从 Standard 转到 One Zone IA 最少要 30 天</li><li>One Zone IA 不是 High Availability 的选择 (注意, 因为 AZ 会 down)</li><li>如果遇到 access is always required 就不能选 One Zone IA, 因为 AZ 可能会 down</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img180147.png"></p><ul><li>S3 Glacier Storage Classes (Archive 专用)<ul><li>Low-cost object storage for archiving &#x2F; backup</li><li>Price: storage + retrieval</li><li>S3 Glacier Instant Retrieval: Glacier 里最快但也最贵</li><li>S3 Glacier Flexible Retrieval: 三种模式 (Expedited 加急, Standard, Bulk 批量)</li><li>S3 Glacier Deep Archive: 存的时间最久, 两种模式 (Standard, Bulk), 48 小时 retrieval</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img180642.png"></p><ul><li>S3 Intelligent Tiering<ul><li>Move objects automatically between Access Tiers based on usage</li><li>就是自动帮你把 Object 移到不同的 Storage Class 里</li><li>Intelligent Tier 是在 Standard 和 Standard IA 下面的, 不能从下往上转移</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img180806.png"></p><hr><h3 id="10-AWS-CLI-SDK-IAM-Roles-amp-Policies"><a href="#10-AWS-CLI-SDK-IAM-Roles-amp-Policies" class="headerlink" title="10. AWS CLI, SDK, IAM Roles &amp; Policies"></a>10. AWS CLI, SDK, IAM Roles &amp; Policies</h3><h4 id="EC2-Instance-Metadata-IMDS"><a href="#EC2-Instance-Metadata-IMDS" class="headerlink" title="EC2 Instance Metadata (IMDS)"></a>EC2 Instance Metadata (IMDS)</h4><ul><li>Allow EC2 Instance to “learn about themselves” without using an IAM Role</li><li>AWS CLI 用 Instance Metadata 去拿 temporary credentials (在 Python 环境下)<ul><li>Metadata &#x3D; info about the EC2 Instance (没法拿到 IAM Policy)</li><li>Userdata &#x3D; launch script of the EC2 Instance</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img150522.png"></p><ul><li>IMDSv2 vs. IMDSv1<ul><li>IMDSv1 access <code>http://169.254.169.254/latest/meta-data</code> (不推荐)</li><li>IMDSv2 is more secure and done in two steps</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img150716.png"></p><hr><h4 id="MFA-with-CLI"><a href="#MFA-with-CLI" class="headerlink" title="MFA with CLI"></a>MFA with CLI</h4><ul><li>To use MFA with CLI, you must create a temporary session<ul><li>Run the <code>STS GetSession</code> API call</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img151057.png"></p><ul><li>如果是 check IAM permission, 用 <code>AWS CLI --dry-run</code></li></ul><hr><h4 id="AWS-SDK"><a href="#AWS-SDK" class="headerlink" title="AWS SDK"></a>AWS SDK</h4><ul><li>Perform actions on AWS directly from your application code</li><li>If not configure a default region, <code>us-east-1</code> will be chosen by default</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img151356.png"></p><hr><h4 id="AWS-Limits-Quotas"><a href="#AWS-Limits-Quotas" class="headerlink" title="AWS Limits (Quotas)"></a>AWS Limits (Quotas)</h4><ul><li>API Rate Limits<ul><li>For Intermittent Errors: implement Exponential Backoff</li><li>For Consistent Errors: request an API throttling limit increase (通过 AWS 申请)</li></ul></li><li>Service Quotas &#x2F; Limits<ul><li>Request a service limit increase by opening a ticket</li><li>Request a service quota increase by Service Quotas API</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img151813.png"></p><ul><li>Exponential Backoff<ul><li>If get <code>ThrottlingException</code> intermittently, use exponential backoff</li><li>It’s a retry mechanism included in AWS SDK API calls</li><li>Only retry for 5XX errors</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img152100.png"></p><hr><h4 id="AWS-CLI-Credentials-Provider-Chain"><a href="#AWS-CLI-Credentials-Provider-Chain" class="headerlink" title="AWS CLI Credentials Provider Chain"></a>AWS CLI Credentials Provider Chain</h4><ul><li>The CLI will look credentials in order<ul><li><code>Command Line Options -&gt; Environment Variables -&gt; EC2 Instance Profile</code></li></ul></li><li>The credentials chain could give priority to the environment variables</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img152316.png"></p><hr><h4 id="AWS-Sigv4"><a href="#AWS-Sigv4" class="headerlink" title="AWS Sigv4"></a>AWS Sigv4</h4><ul><li>AWS SigV4 是对 AWS 请求进行签名的身份验证方法，确保安全和完整性 (2 种选择)<ul><li>HTTP Header: Signature in Authorization header</li><li>Query String: Signature in <code>X-Amz-Signature</code></li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img153415.png"></p><hr><h3 id="11-Advanced-S3"><a href="#11-Advanced-S3" class="headerlink" title="11. Advanced S3"></a>11. Advanced S3</h3><h4 id="S3-Lifecycle-Rules"><a href="#S3-Lifecycle-Rules" class="headerlink" title="S3 Lifecycle Rules"></a>S3 Lifecycle Rules</h4><ul><li>Transition objects between storage classes (比如从 IA 到 Glacier)<ul><li>Transition 需要 Lifecycle Rules (重要)</li></ul></li><li>比如从 Snowball 到 Glacier 就需要 Lifecycle Rule</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img235516.png"></p><ul><li>Transition Actions: Configure objects to transition to another storage class (转移)</li><li>Expiration Actions: Configure objects to expire after some time (删除)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img235639.png"></p><ul><li>S3 Analytics: Help decide when to transition objects to the right storage class</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img000151.png"></p><hr><h4 id="S3-Event-Notifications"><a href="#S3-Event-Notifications" class="headerlink" title="S3 Event Notifications"></a>S3 Event Notifications</h4><ul><li>Automatically react to certain event happened in S3 (比如图片上传)<ul><li>Need to have IAM Permissions</li><li>S3 Event Notification 的 destination 是 SQS, SNS, Lambda (记住)</li></ul></li><li>大部分和 S3 事件相关的都是 S3 Event Notification, 而不是 EventBridge (重要)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img000725.png"></p><ul><li>If two writes are made to a single non-versioned object at the same time, it is possible that only a single event notification will be sent</li></ul><hr><h4 id="S3-Performance"><a href="#S3-Performance" class="headerlink" title="S3 Performance"></a>S3 Performance</h4><ul><li>For Upload 上传 (重要)<ul><li>Multi-Part Upload: 当上传文件大于 5 GB, 可以 parallelize uploads</li><li>S3 Transfer Acceleration: 将文件传到 AWS edge location, 可以和 Multi-Part 一起用</li><li>S3 Transfer Acceleration (S3TA) can speed up content transfers to and from S3</li><li>注意, S3 Transfer Acceleration 没办法 copy object between buckets</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img001645.png"></p><ul><li>For Download 下载<ul><li>S3 Byte-Range Fetches: Parallelize GETs, retrieve partial data (拿部分数据, 重要)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img001828.png"></p><hr><h4 id="S3-Select-amp-Glacier-Select"><a href="#S3-Select-amp-Glacier-Select" class="headerlink" title="S3 Select &amp; Glacier Select"></a>S3 Select &amp; Glacier Select</h4><ul><li>S3 Select 使用 SQL 来做 server-side filtering, 过滤从而减少数据量</li><li>Less network transfer, less CPU cost client-side</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img002050.png"></p><hr><h4 id="S3-Object-Tags-amp-Metadata"><a href="#S3-Object-Tags-amp-Metadata" class="headerlink" title="S3 Object Tags &amp; Metadata"></a>S3 Object Tags &amp; Metadata</h4><ul><li>S3 User-Defined Object Metadata: Must begin with <code>x-amz-meta-</code></li><li>S3 Object Tags: Useful for fine-grained permission or analytics purpose</li><li>You cannot search the object metadata or object tags (重要)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img194215.png"></p><hr><h3 id="12-S3-Security"><a href="#12-S3-Security" class="headerlink" title="12. S3 Security"></a>12. S3 Security</h3><h4 id="S3-Encryption"><a href="#S3-Encryption" class="headerlink" title="S3 Encryption"></a>S3 Encryption</h4><ul><li>Server-Side Encryption (SSE-S3 免费, SSE-KMS 要钱, SSE-C)</li><li>Client-Side Encryption (如果用户已经有 encryption method)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img223133.png"></p><ul><li>Server-Side Encryption with Amazon S3-Managed Keys (SSE-S3)<ul><li>Enabled by default for new buckets &amp; objects</li><li>SSE-S3 的 header 是 <code>x-amz-server-side-encryption:AES256</code></li><li>使用 SSE-S3, 每一个 Object 都是由 unique key 来 encrypt 的</li><li>SSE-S3 使用 256-bit Advanced Encryption Standard (AES-256)</li><li>SSE-S3 是没有 automatic key rotation 的, 要用 SSE-KMS (重要)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img223242.png"></p><ul><li>Server-Side Encryption with KMS Keys stored in AWS KMS (SSE-KMS)<ul><li>User control + audit key usage in CloudTrail (可以管理 key rotation)</li><li>SSE-KMS 的 header 是 <code>x-amz-server-side-encryption:aws:kms</code></li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img223417.png"></p><ul><li>Server-Side Encryption with Customer-Provided Keys (SSE-C)<ul><li>用户自己有 keys, AWS will not store the key, HTTPS must be used (重要)</li><li>当问题中提到用户需要使用自己的 key, 但是打算在 AWS 端做 encryption</li><li>S3 will reject any requests made over <code>HTTP</code> when using SSE-C (重要)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img223602.png"></p><ul><li>Client-Side Encryption<ul><li>User fully manages the keys and encryption cycle</li><li>数据在送到 AWS 之前就是加密好的</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img223715.png"></p><ul><li>Encryption in Transit (SSL&#x2F;TLS)<ul><li>可以用 <code>aws:SecureTransport</code> 来 enforce (不过有 SSL 基本上就是 HTTPS)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img223811.png"></p><hr><h4 id="S3-CORS"><a href="#S3-CORS" class="headerlink" title="S3 CORS"></a>S3 CORS</h4><ul><li>CORS: Cross-Origin Resource Sharing (跨域问题)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img224630.png"></p><ul><li>S3 CORS (重要)<ul><li>A client makes a cross-origin request on S3 bucket, need the correct CORS headers</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img224951.png"></p><hr><h4 id="S3-MFA-Delete"><a href="#S3-MFA-Delete" class="headerlink" title="S3 MFA Delete"></a>S3 MFA Delete</h4><ul><li>MFA Delete: 防止不小心删除文件, 用户需要先验证身份 (重要)<ul><li>To use MFA Delete: Versioning must be enabled</li></ul></li><li>Only the bucket owner (root user) can enable&#x2F;disable MFA Delete (重要)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img225415.png"></p><hr><h4 id="S3-Access-Logs"><a href="#S3-Access-Logs" class="headerlink" title="S3 Access Logs"></a>S3 Access Logs</h4><ul><li>Any request made to S3 will be logged to another S3 bucket (数据分析)<ul><li>可以作为 Data Analysis 的工具</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img230251.png"></p><hr><h4 id="S3-Pre-signed-URL"><a href="#S3-Pre-signed-URL" class="headerlink" title="S3 Pre-signed URL"></a>S3 Pre-signed URL</h4><ul><li>S3 Pre-signed URL 允许临时访问特定 S3 对象的 URL</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img230702.png"></p><hr><h4 id="S3-Access-Points"><a href="#S3-Access-Points" class="headerlink" title="S3 Access Points"></a>S3 Access Points</h4><ul><li>Access Points simplify security management for S3 Buckets (根据用户属性)</li><li>Each Access Point: DNS name + Access Point Policy</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img231500.png"></p><hr><h4 id="S3-Object-Lambda"><a href="#S3-Object-Lambda" class="headerlink" title="S3 Object Lambda"></a>S3 Object Lambda</h4><ul><li>Use AWS Lambda to change object before retrieve by caller (在到达 caller 之前)<ul><li>用途: 可以给图片打水印, 可以用来 Invoke remove PII 的 Lambda 方法 (重要)</li></ul></li><li>需要 S3 Access Point 和 S3 Object Lambda Access Points</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img231810.png"></p><hr><h3 id="13-CloudFront"><a href="#13-CloudFront" class="headerlink" title="13. CloudFront"></a>13. CloudFront</h3><h4 id="AWS-CloudFront"><a href="#AWS-CloudFront" class="headerlink" title="AWS CloudFront"></a>AWS CloudFront</h4><ul><li>Content Delivery Network (CDN), 可以 serve static &amp; dynamic content<ul><li>Improve read performance, content is cached at the edge</li></ul></li><li>可以防止 DDoS protection (搭配 AWS Shield), 可以根据 content type 来 route, 可以指定 primary &amp; secondary origins 来做 high availiability &amp; failover</li><li>CloudFront Origins: S3 Bucket (OAC) 或者 Custom Origin (HTTP)<ul><li>OAC: Origin Access Control (重要, 如果涉及到 S3 的问题)</li></ul></li><li>如果问到 CloudFront 而且需要 encryption, 选择 field level encryption (不是 KMS)<ul><li>Field-level encryption allows you to enable your users to securely upload sensitive information to your web servers.</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img232701.png"></p><ul><li>CloudFront vs S3 Cross Region Replication<ul><li>CloudFront: 使用 global edge network, 有 TTL, 用于 static content</li><li>S3 Cross Region Replication (CRR): 每个 Region 都要设置, 但是没有 TTL, 用于 dynamic content (updated in near real-time, 只读)</li><li>问到 S3 并且有关 high available 和 low latency 的就是 S3 Cross Region Replication</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img233016.png"></p><ul><li>CloudFront 允许 Proxy methods 和 Dynamic content 跳过 regional edge cache</li><li>除了 WAF 可以去 block IP, 还可以使用 OAI (origin access identity, 重要)<ul><li>OAI 也可以用来 secure communication between CloudFront &amp; S3</li></ul></li><li>可以用 CloudFront signed URLs 和 CloudFront signed cookies 来 restrict access to documents (比如 subscription)</li><li>Can configure CloudFront to require HTTPS from clients (可以用 CloudFront 要求 client 必须使用 HTTPS)</li><li>关于 CloudFront with Origin Groups 的 2 个点<ul><li>CloudFront routes all incoming requests to the primary origin, even when a previous request failed over to the secondary origin</li><li>CloudFront fails over to the secondary origin only when the HTTP method of the viewer request is GET, HEAD or OPTIONS</li></ul></li></ul><hr><h4 id="CloudFront-Caching"><a href="#CloudFront-Caching" class="headerlink" title="CloudFront Caching"></a>CloudFront Caching</h4><ul><li>The cache lives at each CloudFront Edge Location</li><li>CloudFront identifies each object in the cache using Cache Key</li><li>如果遇到 CloudFront 处理 language 配置出问题, 那么可以用 <code>Query string forwarding and caching</code> (这道题很长)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img144432.png"></p><ul><li>CloudFront Cache Key<ul><li>By default, consists of hostname + resource portion of the URL</li><li>Could add other elements to the Cache Key using CloudFront Cache Policies</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img144654.png"></p><ul><li>Cache Policy: 可以使用 HTTP Headers, Cookies, Query Strings (重要)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img444857.png"></p><ul><li>Origin Request Policy<ul><li>Values that you want to include in origin requests without including in the Cache Key</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img145256.png"></p><hr><h4 id="CloudFront-Cache-Invalidation"><a href="#CloudFront-Cache-Invalidation" class="headerlink" title="CloudFront Cache Invalidation"></a>CloudFront Cache Invalidation</h4><ul><li>让 CloudFront 跳过 TTL 立即更新<ul><li>比如你更新了后端, 但是 CloudFront 不会立即更新, 需要 CloudFront Invalidation 来跳过 TTL 来立即更新</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img234007.png"></p><hr><h4 id="CloudFront-Cache-Behaviors"><a href="#CloudFront-Cache-Behaviors" class="headerlink" title="CloudFront Cache Behaviors"></a>CloudFront Cache Behaviors</h4><ul><li>根据不同的 URL 结构做不同的 Cache Behaviors</li><li>Maximize cache hits by separating staic and dynamic distributions</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img150007.png"></p><hr><h4 id="CloudFront-Geo-Restriction"><a href="#CloudFront-Geo-Restriction" class="headerlink" title="CloudFront Geo Restriction"></a>CloudFront Geo Restriction</h4><ul><li>Allowlist &amp; Blocklist (针对 IP, 国家进行访问限制)<ul><li>CloudFront Geo Restriction 没办法和 VPC 一起使用</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img233638.png"></p><hr><h4 id="CloudFront-Signed-URL-x2F-Cookies"><a href="#CloudFront-Signed-URL-x2F-Cookies" class="headerlink" title="CloudFront Signed URL &#x2F; Cookies"></a>CloudFront Signed URL &#x2F; Cookies</h4><ul><li>类似 S3 Pre-Signed URL<ul><li>Signed URL: access to individual files (单个文件)</li><li>Signed Cookies: access to multiple files (多个文件)</li></ul></li><li>Recommend to use Trusted Key Group than CloudFront Key Pair (重要)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img484256.png"></p><ul><li>CloudFront Signed URL vs. S3 Pre-Signed URL<ul><li>Access CloudFront 的就是 CloudFront Signed URL</li><li>Access S3 的就是 S3 Pre-Signed URL</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img184528.png"></p><ul><li>与 CloudFront signer 有关的 2 个知识点<ul><li>When create a signer, the public key is CloudFront and private key is used to sign a portion of URL</li><li>When use the root user to manage CloudFront key pairs, you can only have up to two active CloudFront key pairs per AWS account</li></ul></li><li>CloudFront Key Pair 只能由 root user 来创建</li></ul><hr><h4 id="CloudFront-Advanced-Concepts"><a href="#CloudFront-Advanced-Concepts" class="headerlink" title="CloudFront Advanced Concepts"></a>CloudFront Advanced Concepts</h4><ul><li>Price Classes (一共 3 种)<ul><li>Price Class All: all regions - best performance</li><li>Price Class 200: most regions, but excludes the most expensive regions</li><li>Price Class 100: only the least expensive regions</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img185111.png"></p><ul><li>CloudFront - Origin Groups<ul><li>Increase high-availability and do failover</li><li>Origin Group: one primary and one secondary origin</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img185430.png"></p><ul><li>CloudFront - Field Level Encryption<ul><li>Protect user sensitive information through application stack (重要)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img185545.png"></p><hr><h4 id="CloudFront-Real-Time-Logs"><a href="#CloudFront-Real-Time-Logs" class="headerlink" title="CloudFront Real Time Logs"></a>CloudFront Real Time Logs</h4><ul><li>Get real-time requests received by CloudFront sent to Kinesis Data Stream</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img195222.png"></p><hr><h4 id="AWS-Global-Accelerator"><a href="#AWS-Global-Accelerator" class="headerlink" title="AWS Global Accelerator"></a>AWS Global Accelerator</h4><ul><li>利用 AWS internal network to route application<ul><li>Provide 2 global static anycast IPs (重要)</li><li>Improve availability and performance of the applications (globally)</li></ul></li><li>Global Accelerator improves performance for applications over TCP or UDP</li><li>Global Accelerator has automatic failover</li><li>Global Accelerator is more expensive as it adds an extra layer of infrastructure (对比 CloudFront 不是一个 cost-effective 的选择)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img234527.png"></p><ul><li>AWS Global Accelerator vs CloudFront<ul><li>CloudFront: Content is served at edge, 比如图片和视频 (cacheable), Dynamic content such as API acceleration &amp; dynamic site delivery</li><li>Global Accelerator: 适合 TCP 或者 UDP, 比如游戏和 IoT (static IP)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img000939.png"></p><blockquote><p>AWS Global Accelerator is a network service that can provide a global traffic management solution. By creating a standard accelerator in AWS Global Accelerator, you can guide user traffic to the endpoint closest to them, thereby improving the performance and availability of the application.</p></blockquote><hr><h3 id="14-ECS-ECR-amp-Fargate"><a href="#14-ECS-ECR-amp-Fargate" class="headerlink" title="14. ECS, ECR &amp; Fargate"></a>14. ECS, ECR &amp; Fargate</h3><h4 id="AWS-ECS"><a href="#AWS-ECS" class="headerlink" title="AWS ECS"></a>AWS ECS</h4><ul><li>Elastic Container Service (Manage Docker containers on AWS)</li><li>ECS 有两种 Launch Type: EC2 和 Fargate (Fargate 是 serverless 的)</li><li>EC2 Launch Type: Need Provision, 需要 ECS Agent (重点)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img212508.png"></p><ul><li>Fargate Launch Type: Serverless, No Provision (重点)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img212546.png"></p><ul><li>IAM Roles for ECS (重要, 是 IAM)<ul><li>EC2 Instance Profile: 只针对 EC2 Launch Type, used by ECS agent</li><li>ECS Task Role: 每个 Task 都有自己的 Role (负责)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img212709.png"></p><ul><li>ECS 可以和 Load Balancer 一起用 (ALB &#x2F; NLB)</li><li>ECS 可以和 EFS 一起用 (Fargate + EFS &#x3D; Serverless, 管理文件)</li><li>如果 terminate ECS 出现 synchronization issue, 那么 ECS 当前的状态一定是 <code>STOPPED</code></li><li>如果 ECS cluster launch 出问题, 那么先检查 <code>ecs.config</code> 有没有问题</li><li>可以用 awslogs log driver 来送 ECS 的 log 到 CloudWatch, 如果 ECS 是 Fargate 类型的, 还需要 <code>logConfiguration</code> parameter 在 task definition 里</li></ul><blockquote><p>Amazon ECS with EC2 launch type is charged based on EC2 instances and EBS volumes used. Amazon ECS with Fargate launch type is charged based on vCPU and memory resources that the containerized application requests</p></blockquote><hr><h4 id="ECS-Auto-Scaling"><a href="#ECS-Auto-Scaling" class="headerlink" title="ECS Auto Scaling"></a>ECS Auto Scaling</h4><ul><li>Automatically increase &#x2F; decrease the number of ECS tasks<ul><li>Target Scaling: Scale based on target value for CloudWatch metric</li><li>Step Scaling: Scale based on CloudWatch Alarm (重要)</li><li>Scheduled Scaling: Scale based on specific time (重要)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img222247.png"></p><ul><li>Auto Scaling EC2 Instances<ul><li>Accommodate ECS Service Scaling by adding underlying EC2 Instances</li><li>Auto Scaling Group Scaling &#x2F; ECS Cluster Capacity Provider</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img205104.png"></p><hr><h4 id="ECS-Rolling-Updates"><a href="#ECS-Rolling-Updates" class="headerlink" title="ECS Rolling Updates"></a>ECS Rolling Updates</h4><ul><li>Control how many tasks can be started and stopped when update from v1 to v2</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img205259.png"></p><hr><h4 id="ECS-Task-Definitions"><a href="#ECS-Task-Definitions" class="headerlink" title="ECS Task Definitions"></a>ECS Task Definitions</h4><ul><li>Task definitions are metadata in JSON form to tell ECS how to run Docker container</li><li>Environment Variable: Hardcoded, SSM Parameter Store, Secrets Manager, S3</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img210902.png"></p><ul><li>ECS Load Balancing - EC2 Launch Type<ul><li>Get a Dynamic Host Port Mapping if define only the container port in task definiton</li><li>Must allow EC2 Instance’s Security Group any port from the ALB’s Security Group (重要)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img211103.png"></p><ul><li>ECS Load Balancing - Fargate<ul><li>Each task has a unique private IP, only define the container port</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img211211.png"></p><ul><li>ECS Data Volumes (Bind Mounts)<ul><li>Share data between multiple containers in the same Task Definition</li><li>Work for both EC2 and Fargate</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img211542.png"></p><hr><h4 id="ECS-Task-Placements"><a href="#ECS-Task-Placements" class="headerlink" title="ECS Task Placements"></a>ECS Task Placements</h4><ul><li>For EC2 Launch Type, determine where to place the EC2, CPU, Memory 等等</li><li>ECS Task Placement Strategies could mixed together (Binpack, Random 和 Spread)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img212801.png"></p><ul><li>ECS Task Placement Strategies - Binpack<ul><li>Place tasks based on the least available amount of CPU or memory</li><li>This minimize the number of instances in use (cost saving, 重要)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img213429.png"></p><ul><li>ECS Task Placement Strategies - Random<ul><li>Place the task randomly</li><li>To enable random host port, set host <code>port = 0</code> or empty, which allow multiple containers of same type to launch on the same EC2 container instance</li><li>如果问到第一个 container 运行成功, 但第二个运行失败, 那就是 host port 的问题</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img213517.png"></p><ul><li>ECS Task Placement Strategies - Spread<ul><li>Place the task evenly based on the specified value</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img213603.png"></p><ul><li>ECS Task Placement Constraints<ul><li><code>distinctInstance</code>: Place each task on a different container instance</li><li><code>memberOf</code>: Place task on instances that satisfy an expression</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img213754.png"></p><hr><h4 id="AWS-ECR"><a href="#AWS-ECR" class="headerlink" title="AWS ECR"></a>AWS ECR</h4><ul><li>Elastic Container Registry (ECR, 管理 Docker Image, 不是 Docker Container)<ul><li>Store and manage Docker images on AWS</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img222836.png"></p><ul><li>How to use CLI to pull and push image to ECR<ul><li><code>$(aws ecr get-login --no-include-email)</code></li><li><code>docker pull 1234567890.dkr.ecr.eu-west-1.amazonaws.com/demo:latest</code></li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img214106.png"></p><hr><h4 id="AWS-CoPilot"><a href="#AWS-CoPilot" class="headerlink" title="AWS CoPilot"></a>AWS CoPilot</h4><ul><li>CLI tool to build, release, and operate production-ready containerized apps<ul><li>Run your apps on AppRunner, ECS, and Fargate</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img214226.png"></p><hr><h4 id="AWS-EKS"><a href="#AWS-EKS" class="headerlink" title="AWS EKS"></a>AWS EKS</h4><ul><li>Elastic Kubernetes Service (Manage Kubernetes clusters on AWS)<ul><li>Support 2 deployment mode: EC2 &amp; Fargate (和 ECS 一样)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img223132.png"></p><ul><li>EKS Data Volumes (需要 StorageClass)<ul><li>Leverages a Container Storage Interface (CSI) compliant driver</li><li>支持 EBS, EFS, FSx</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img223503.png"></p><hr><h3 id="15-Elastic-Beanstalk"><a href="#15-Elastic-Beanstalk" class="headerlink" title="15. Elastic Beanstalk"></a>15. Elastic Beanstalk</h3><h4 id="AWS-Elastic-Beanstalk"><a href="#AWS-Elastic-Beanstalk" class="headerlink" title="AWS Elastic Beanstalk"></a>AWS Elastic Beanstalk</h4><ul><li>Elastic Beanstalk is a developer centric view of deploying an application on AWS</li><li>Automatically handles capacity provisioning, load balancing, scaling 等等</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img150326.png"></p><ul><li>Web Server Tier vs. Worker Tier (重要)<ul><li>一个管 Web Server, 另一个处理 Process (SQS, SNS 等等)</li></ul></li><li>对于 Worker 或者 Web environment 来说, 需要一个 <code>cron.yaml</code> 文件</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img210711.png"></p><ul><li>如果选择 deploy 到 Elastic Beanstalk 上, 并且省钱, 选择 Single Instance Mode</li><li>如果需要用类似 Rust 这种不支持的 runtime, 可以用 Docker image 去跑 Elastic Beanstalk</li><li>如果 deploy 失败, 那么 EB 会 replace the failed instances with instances running in the application version from the most recent successful deployment (重要)</li><li>如果要 setup HTTPS on Beanstalk, 要在 <code>.ebextensions</code> folder 弄一个 config 来管 Load Balancer</li><li>如果要 migrate Beanstalk environment across Accounts<ul><li>Create a saved configuration download it to your local machine. Make the account-specific parameter changes and upload to the S3 bucket in another account. From Elastic Beanstalk console, create an application from ‘Saved Configurations’</li></ul></li></ul><hr><h4 id="Beanstalk-Deployment-Modes"><a href="#Beanstalk-Deployment-Modes" class="headerlink" title="Beanstalk Deployment Modes"></a>Beanstalk Deployment Modes</h4><ul><li>一共 6 种 Beanstalk Deployment Modes</li><li>这里面 Immutable 和 Traffic Splitting 可能会导致 EC2 burst balance lost (重要)</li><li>注意, Rolling 和 Rolling with additional batches 都会导致 reduce availability</li><li>All at once (直接全部更新, 但会有 downtime)<ul><li>Fastest, but have downtime</li></ul></li><li>Beanstalk 用来 avoid downtime 的选择 blue&#x2F;green deployment (重要)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img151200.png"></p><ul><li>Rolling (一批一批的更新)<ul><li>Update a few instances at a time (bucket), then move onto the next bucket</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img151311.png"></p><ul><li>Rolling with additional batches (类似 Rolling, 但是老版本仍然运行, 有部分额外费用)<ul><li>Like rolling, but spins up new instances to move the batch, old application still available</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img151443.png"></p><ul><li>Immutable (和 quick roll back 有关)<ul><li>Spin up new instances in a new ASG, deploys version to these instances, and then swaps all the instances when everything is healthy</li><li>如果需要 maintain at least the full capacity of the application and minimal impact of fail deployment, 选择 Immutable</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img151738.png"></p><ul><li>Blue Green (会先创造一个新的 environment)<ul><li>Create a new environment and switch over when ready</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img151838.png"></p><ul><li>Traffic Splitting (分一部分 traffic 到新环境)<ul><li>Canary testing, send a small % of traffic to new deployment</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img151935.png"></p><hr><h4 id="Beanstalk-Lifecycle-Policy"><a href="#Beanstalk-Lifecycle-Policy" class="headerlink" title="Beanstalk Lifecycle Policy"></a>Beanstalk Lifecycle Policy</h4><ul><li>Elastic Beanstalk can store at most 1000 application versions</li><li>To phase out old application versions, use a lifecycle policy (重要)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img152423.png"></p><hr><h4 id="Beanstalk-Extensions"><a href="#Beanstalk-Extensions" class="headerlink" title="Beanstalk Extensions"></a>Beanstalk Extensions</h4><ul><li>A zip file containing code must be deployed to Elastic Beanstalk<ul><li>In the <code>.ebextensions/</code> in the root directory (必须存在 <code>.ebextensions</code> 的文件夹下)</li><li><code>.config</code> extensions (必须以 <code>.config</code> 为文件后缀)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img155315.png"></p><hr><h4 id="Beanstalk-with-CloudFormation"><a href="#Beanstalk-with-CloudFormation" class="headerlink" title="Beanstalk with CloudFormation"></a>Beanstalk with CloudFormation</h4><ul><li>Under the hood, Elastic Beanstalk relies on CloudFormation</li><li>CloudFormation is used to provision other AWS services</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img161346.png"></p><hr><h4 id="Beanstalk-Cloning"><a href="#Beanstalk-Cloning" class="headerlink" title="Beanstalk Cloning"></a>Beanstalk Cloning</h4><ul><li>Clone an environment with the exact same configuration</li><li>Useful for deploying a <code>test</code> version of your application</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img161531.png"></p><hr><h3 id="16-AWS-CloudFormation"><a href="#16-AWS-CloudFormation" class="headerlink" title="16. AWS CloudFormation"></a>16. AWS CloudFormation</h3><h4 id="AWS-CloudFormation"><a href="#AWS-CloudFormation" class="headerlink" title="AWS CloudFormation"></a>AWS CloudFormation</h4><ul><li>A declarative way of outlining AWS Infrastructure (相当于有一个模板帮你生成你想要的)<ul><li>需要什么 (eg. EC2 Instance, S3), CloudFormation 给你 create 什么</li><li>CloudFormation 是 IaaS (Infrastructure as a Service)</li></ul></li><li>Can leverage existing templates on the web (可以用网上已经有的 template)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img003448.png"></p><ul><li>Templates must be uploaded in S3 and referenced in CloudFormation (重要)</li><li>To update a template, need to re-upload a new version of the template (重要)<ul><li>一般来说, 先在本地更新 CloudFormation template, 然后上传到 S3 并在 CloudFormation console 里面应用</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img193232.png"></p><ul><li>Deploying CloudFormation Templates (2 种方法)<ul><li>Manual way: Edit templates in Applcation Composer or code editor</li><li>Automated way: Edit templates in a YAML file</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img193404.png"></p><ul><li>注意, 依赖 CloudFormation 来 provision resource 的是 Elastic Beanstalk 和 SAM</li><li>CloudFormation 用来 upload Lambda 和 CloudFormation template 的是 <code>cloudformation package and cloudformation deploy</code></li><li>如果要 declare Lambda function in CloudFormation<ul><li>Write the AWS Lambda code inline in CloudFormation in the <code>AWS::Lambda::Function</code> block as long as there are no third-party dependencies</li><li>Upload all the code as a zip to S3 and refer the object in <code>AWS::Lambda::Function</code> block</li></ul></li></ul><hr><h4 id="CloudFormation-Resources"><a href="#CloudFormation-Resources" class="headerlink" title="CloudFormation Resources"></a>CloudFormation Resources</h4><ul><li>Resources represent different AWS Components that will be created and configured<ul><li>不需要定义 <code>Resource</code> 生成的 order</li><li><code>Resource</code> 是 mandatory 的 (重要)</li></ul></li><li>形式 <code>service-provider::service-name::data-type-name</code></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img194109.png"></p><hr><h4 id="CloudFormation-Parameters"><a href="#CloudFormation-Parameters" class="headerlink" title="CloudFormation Parameters"></a>CloudFormation Parameters</h4><ul><li>Parameters are a way to provide inputs to AWS CloudFormation Template<ul><li>Can reuse the templates, also don’t need to re-upload the template</li><li>Parameter type 有 <code>AWS::EC2::KeyPair::KeyName, CommaDelimitedList, String</code></li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img194424.png"></p><ul><li>Parameters Settings (记下面 2 个)<ul><li><code>AllowedValues</code>: 给用户选项, 比如选择 <code>t2.micro</code>, <code>t2.small</code>, <code>t2.medium</code></li><li><code>NoEcho</code>: 把 password 这种 secret 的东西从 log 里面移除</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img194757.png"></p><ul><li>Pseudo Parameters<ul><li>Can be used anytime and enabled by default</li><li><code>AccountId, Region, StackId, StackName, NotificationARNs, NoValue</code></li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img223040.png"></p><hr><h4 id="CloudFormation-Mappings"><a href="#CloudFormation-Mappings" class="headerlink" title="CloudFormation Mappings"></a>CloudFormation Mappings</h4><ul><li>Mappings are fixed variables within CloudFormation template<ul><li>Used to differentiate between environments (dev vs. prod), regions, AMI 等等</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img212000.png"></p><hr><h4 id="CloudFormation-Outputs-amp-Exports"><a href="#CloudFormation-Outputs-amp-Exports" class="headerlink" title="CloudFormation Outputs &amp; Exports"></a>CloudFormation Outputs &amp; Exports</h4><ul><li>Outputs declares optional ouputs values that can import into other stacks (重要)<ul><li>Outputs 可以申明资源让我们可以在其他 Stack 里面用 (前提是先 export 它们)</li><li>Exported output name 在 Region 内必须是 unique 的 (重要)</li></ul></li><li>如果我们要在第二个 template 里面去 leverage 前一个 template 的资源, 要用到 <code>Fn::ImportValue</code> (重要)</li><li>注意, <code>ImportValue</code> 是用来 reference value from other stack, <code>Export</code> 才是用来 export value to other stacks 的</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img212344.png"></p><ul><li>注意, 对于 CloudFormation 来说, All of the imports must be removed before you can delete the exporting stack or modify the output value, 所以如果遇到 Stack B, C 需要 reference Stack A, 那么 Stack A 一定是最后被删除的</li></ul><hr><h4 id="CloudFormation-Conditions"><a href="#CloudFormation-Conditions" class="headerlink" title="CloudFormation Conditions"></a>CloudFormation Conditions</h4><ul><li>Conditions are used to control the creation of resources or outputs based on a condition<ul><li>常见的有 Environment, AWS Region, Parameter value</li></ul></li><li>可以和 <code>Conditions</code> associate 有 <code>Resources, Conditions, Outputs</code></li><li>在 CloudFormation template 里面代表 invalid section 的是 <code>Dependencies</code></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img212731.png"></p><hr><h4 id="CloudFormation-Intrinsic-Functions"><a href="#CloudFormation-Intrinsic-Functions" class="headerlink" title="CloudFormation Intrinsic Functions"></a>CloudFormation Intrinsic Functions</h4><ul><li><code>Fn::Ref</code>: Reference Rarameters or Resources (只能在 Parameter 或者 Resource 里用)</li><li><code>Fn::GetAtt</code>: Returns the value of an attribute from a resource in the template</li><li><code>Fn::FindInMap</code>: Return a named value from a specific key (注意, 就 3 参数)</li><li><code>Fn::ImportValue</code>: Import values that are exported in other stacks</li><li><code>Fn::Base64</code>: Convert String to it’s Base64 representation</li><li>Condition Functions: <code>Fn::And/Equals/If/Not/Or</code></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img214211.png"></p><hr><h4 id="CloudFormation-Rollbacks"><a href="#CloudFormation-Rollbacks" class="headerlink" title="CloudFormation Rollbacks"></a>CloudFormation Rollbacks</h4><ul><li>Stack Creation Fails 和 Stack Update Fails 都会去 rollback, 但 rollback 也可能失败</li><li>Rollback 之后如果需要重新更新 Stack, 要先删除之前的 Stack, 然后 create 新的 Stack</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img215108.png"></p><hr><h4 id="CloudFormation-Service-Role"><a href="#CloudFormation-Service-Role" class="headerlink" title="CloudFormation Service Role"></a>CloudFormation Service Role</h4><ul><li>IAM role that allow CloudFormation to <code>create/update/delete</code> stack resources<ul><li>可以用 Stack Servie Role 去给 developer permission 去管理 resources (重要)</li></ul></li><li>Achieve least privilege principle, must have <code>iam::PassRole</code> permission</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img215347.png"></p><hr><h4 id="CloudFormation-DeletionPolicy"><a href="#CloudFormation-DeletionPolicy" class="headerlink" title="CloudFormation DeletionPolicy"></a>CloudFormation DeletionPolicy</h4><ul><li>DeletionPolicy &#x3D; Delete (默认)<ul><li>Control what happens when the CloudFormation template is deleted or when a resource is removed from a CloudFormation template</li></ul></li><li>Delete won’t work on S3 if bucket is not empty</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img220014.png"></p><ul><li>DeletionPolicy &#x3D; Retain (相当于申明什么要被保存)<ul><li>Specify on resources to preserve in case of CloudFormation deletes</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img220147.png"></p><ul><li>DeletionPolicy &#x3D; Snapshot (会在删除前生成一个备份)<ul><li>Create one final snapshot before deleting the resource</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img220302.png"></p><hr><h4 id="CloudFormation-Stack-Policy"><a href="#CloudFormation-Stack-Policy" class="headerlink" title="CloudFormation Stack Policy"></a>CloudFormation Stack Policy</h4><ul><li>A Stack Policy is a JSON document that defines the update actions that are allowed on specific resources during Stack updates</li><li>Protect resources from unintentional updates (重要)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img220535.png"></p><hr><h4 id="CloudFormation-Termination-Protection"><a href="#CloudFormation-Termination-Protection" class="headerlink" title="CloudFormation Termination Protection"></a>CloudFormation Termination Protection</h4><ul><li>To prevent accidental deletes of CloudFormation Stacks, use <code>TerminationProtection</code></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img220655.png"></p><hr><h4 id="CloudFormation-Custom-Resources"><a href="#CloudFormation-Custom-Resources" class="headerlink" title="CloudFormation Custom Resources"></a>CloudFormation Custom Resources</h4><ul><li>Used to define resources that are not supported or outside CloudFormation</li><li>Defined in template with <code>Custom::MyCustomResourceTypeName</code></li><li>可以处理之前提到的 S3 bucket 无法删除的问题</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img221103.png"></p><hr><h4 id="CloudFormation-StackSets"><a href="#CloudFormation-StackSets" class="headerlink" title="CloudFormation StackSets"></a>CloudFormation StackSets</h4><ul><li>Create, update, delete stacks across multiple accounts and regions<ul><li>注意, StackSets 是给多个账户, 或者多个 Region 去创造 CloudFormation stack</li><li>只有 Administrator 才可以创建 StackSets</li></ul></li><li>When update a stack set, all associated stack instance will be updated (重要)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img221509.png"></p><hr><h3 id="17-SQS-SNS-Kinesis"><a href="#17-SQS-SNS-Kinesis" class="headerlink" title="17. SQS, SNS, Kinesis"></a>17. SQS, SNS, Kinesis</h3><h4 id="AWS-SQS"><a href="#AWS-SQS" class="headerlink" title="AWS SQS"></a>AWS SQS</h4><ul><li>用来 decouple applications (比如处理视频, 属于多对多模型)</li><li>SQS scale automatically (unlimited throughput, unlimited message, can retry)</li><li>SQS 最多只能保存 message 14 天, SQS 一个 message 最大只有 256 KB (重要)</li><li>SQS 一次最多只能 retrieve 10 个 message (重要)</li><li>Standard SQS 允许将 S3 作为 event notification destination, SQS FIFO 则不行</li><li>处理 parallel 选 SQS 而不是 SNS</li><li>处理 decouple microservice (但是没有 3rd party 的) 就是 SQS</li><li>处理 high-throughput request-reponse message pattern 的, 选择 Temporary Queue</li><li>遇到要处理 workflows that take a long time to complete, 选择 Dedicated worker environment</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img231916.png"></p><ul><li>SQS - Producing Messages<ul><li>Message is persisted in SQS until a consumer delete it (重要)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img232217.png"></p><ul><li>SQS - Consuming Messages<ul><li>可以有很多 consumer 来同时 parallel 处理 messages (重要)</li><li>Consumer delete messages after processing them (处理完就删掉)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img232414.png"></p><ul><li>当遇到 SQS 而且需要 priority 的时候, Create two Amazon SQS standard queues, Set up Amazon EC2 instances to prioritize polling</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/imgpt6-q32-i1.jpg"></p><ul><li>关于 SQS <code>CreateQueue</code> API 的 2 个知识点</li><li>The visibility timeout value of the queue is in seconds, default is 30 seconds</li><li>You can’t change the queue type after create it</li><li>如果遇到 <code>ApproximateNumberOfMessagesVisible</code> 这个问题, 可以用 backlog per instance metric with target tracking scaling policy 来解决</li></ul><hr><h4 id="SQS-Message-Visibility-Timeout"><a href="#SQS-Message-Visibility-Timeout" class="headerlink" title="SQS Message Visibility Timeout"></a>SQS Message Visibility Timeout</h4><ul><li>Visibility Timeout is high: Consumer crash, re-process take time</li><li>Visibility Timeout is low: Get duplicate (防止 read duplicate, 增加 timeout, 重要)</li><li>Use the <code>ChangeMessageVisibility</code> API call to increase the visibility timeout (重要)</li><li>题目大部分针对的都是 Visibility Timeout low 的情况</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img020440.png"></p><hr><h4 id="SQS-Dead-Letter-Queues-DLQ"><a href="#SQS-Dead-Letter-Queues-DLQ" class="headerlink" title="SQS Dead Letter Queues (DLQ)"></a>SQS Dead Letter Queues (DLQ)</h4><ul><li>Fail to process message within Visibility Timeout, message goes back to queue<ul><li>问题在于这个 message 可能本身就是无法处理的</li><li>遇到 SQS message process failure, 选择 DLQ 来解决 (重要)</li></ul></li><li>Set a threshold of how many times a message can go back to queue<ul><li>After <code>MaximumReceives</code> threshold exceeded, message goes to DLQ</li><li>DLQ 很适合用来做 Debug</li></ul></li><li>DLQ of a FIFO queue must also be a FIFO queue, same with Standard (形式得相同)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img164418.png"></p><ul><li>DLQ - Redrive to Source (相当于从 DLQ 修复完返回原来的 Queue)<ul><li>Feature to help consume messages in DLQ to understand what is wrong</li><li>When the code is fixed, we can redrive the message from DLQ to source queue</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img164607.png"></p><hr><h4 id="SQS-Delay-Queues"><a href="#SQS-Delay-Queues" class="headerlink" title="SQS Delay Queues"></a>SQS Delay Queues</h4><ul><li>Delay a message up to 15 minutes (使用 <code>DelaySeconds</code> 参数)</li><li>遇到需要 SQS 去 postpone the delivery of new messages, 那么就是 Delay Queue</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img164931.png"></p><hr><h4 id="SQS-Long-Polling"><a href="#SQS-Long-Polling" class="headerlink" title="SQS Long Polling"></a>SQS Long Polling</h4><ul><li>Decrease latency &amp; decrease API call (减少 API 请求, 更好的 performance, 重要)<ul><li>Minimize the cost of using SQS (省钱)</li><li>Long Polling 不能处理 SQS duplicate, 还是要用 Visibility Timeout</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img003255.png"></p><hr><h4 id="SQS-Extended-Client"><a href="#SQS-Extended-Client" class="headerlink" title="SQS Extended Client"></a>SQS Extended Client</h4><ul><li>Handle send message greater than 256 KB (重要)<ul><li>这证明 SQS 的 message 也是有 size 的限制</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img165310.png"></p><hr><h4 id="SQS-FIFO-Queues"><a href="#SQS-FIFO-Queues" class="headerlink" title="SQS FIFO Queues"></a>SQS FIFO Queues</h4><ul><li>按 order 传递 message (SNS 也可以做到)<ul><li>By default, FIFO queues support up to 300 messages per second (重要)</li></ul></li><li>如果没有 GroupID, 那只能有 1 个 consumer, 如果有 GroupID, 可以有多个 consumer (重要)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img003507.png"></p><ul><li>把 SQS 转成 FIFO queue<ul><li>Delete the existing SQS and recreate it as FIFO queue</li><li>Make sure the name of the FIFO queue ends with .fifo suffix</li><li>Make sure the throughput for the FIFO queue not exceed 3000 meesage &#x2F; second</li></ul></li></ul><hr><h4 id="SQS-FIFO-Queues-Advanced"><a href="#SQS-FIFO-Queues-Advanced" class="headerlink" title="SQS FIFO Queues Advanced"></a>SQS FIFO Queues Advanced</h4><ul><li>De-duplication: (使用 <code>MessageDeduplicationID</code>)<ul><li>Send 2 same message within 5 minutes interval, the second will be refused</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img170023.png"></p><ul><li>Message Grouping (使用 <code>MessageGroupID</code>)<ul><li>Same <code>MessageGroupID</code> in the entire FIFO queue, then only have 1 consumer</li><li>Different MessageGroupID for a subset of message, have different consumers</li><li>对于 FIFO queues 来说, <code>MessageGroupID</code> 可以保证 same message group 是有 order 的</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img170254.png"></p><hr><h4 id="AWS-SNS"><a href="#AWS-SNS" class="headerlink" title="AWS SNS"></a>AWS SNS</h4><ul><li>Send one message to many receivers (可以给用户发 email)<ul><li>Publisher &amp; Subscriber 模型 (属于一对多模型)</li><li>Subscriber: SQS, Lambda, Kinesis Data Firehose, HTTPS endpoints, Email</li></ul></li><li>SNS Message Filtering: Could filter message based on topic (重要)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img010634.png"></p><hr><h4 id="Fan-Out-Pattern"><a href="#Fan-Out-Pattern" class="headerlink" title="Fan Out Pattern"></a>Fan Out Pattern</h4><ul><li>Push once in SNS, receive in all SQS (由 SNS 传递 message 给 SQS 来接收, 重要)<ul><li>Fully decoupled, no data loss (重要, 因为它 decouple)</li><li>可以用于 message filtering (信息过滤, 根据不同的 filter policy)</li></ul></li><li>Kinesis 也可以使用 Fan Out Pattern (使用 Shard)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img011026.png"></p><hr><h4 id="AWS-Kinesis"><a href="#AWS-Kinesis" class="headerlink" title="AWS Kinesis"></a>AWS Kinesis</h4><ul><li>Process, ingest, buffer streaming data in real-time (处理实时数据)</li><li>Kinesis Data Streams: Capture, process, store data streams</li><li>Kinesis Data Firehose: Load data streams into AWS data stores (S3, Redshift)</li><li>Kinesis Data Analytics: Analyze data streams with SQL or Apache Flink</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img150053.png"></p><blockquote><p>Kinesis Agent cannot write to Amazon Kinesis Firehose for which the delivery stream source is already set as Amazon Kinesis Data Streams</p></blockquote><ul><li>Kinesis Agent is a stand-alone Java software application that offers an easy way to collect and send data to Kinesis Data Streams</li></ul><hr><h4 id="Kinesis-Data-Streams"><a href="#Kinesis-Data-Streams" class="headerlink" title="Kinesis Data Streams"></a>Kinesis Data Streams</h4><ul><li>Have the ability to reprocess &amp; replay stream data (处理数据, 重要)<ul><li>对于 injest data 来说, Kinesis Data Firehose 比 Kinesis Data Streams 好</li><li>处理 real-time data stream, 比如 clickstreams, transactions, media (金融数据)</li><li>Consumer 有 Lambda, Kinesis Firehose, Kinesis Data Analytics</li><li>Kinesis Data Streams 有助于每秒从多个来源连续收集数 GB 的数据</li><li>Kinesis Data Streams 最多保存数据 1 年</li></ul></li><li>Once data is inserted in Kinesis, it can’t be deleted (没法删除)</li><li>如果问到 Kinesis Data Stream 加上 SQL, 那么答案里一定有 Kinesis Data Analytics</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img014850.png"></p><ul><li>Data share the same partition goes the same shard (有顺序的)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img151123.png"></p><ul><li>Capacity Mode (一共 2 种)<ul><li>Provisioned mode: Choose a number of shards provisioned (设置上限)</li><li>On-demand mode: No need to provision or manage capacity (自动 scale)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img151507.png"></p><hr><h4 id="Kinesis-Producers"><a href="#Kinesis-Producers" class="headerlink" title="Kinesis Producers"></a>Kinesis Producers</h4><ul><li>Put data records into data streams</li><li>Producers: AWS SDK, Kinesis Producer Library (KPL), Kinesis Agent</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img172002.png"></p><ul><li>Use Hash function to determine which message should go to which Shard</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img172126.png"></p><ul><li>如果遇到 <code>ProvisionedThroughputExceededException</code> 问题<ul><li>Over producing to a shard, get <code>ProvisionedThroughputExceededException</code></li><li>解决方案 1: Use highly distributed partition key</li><li>解决方案 2: Use error retry and exponential backoff mechanism</li><li>解决方案 3: Increase shards</li><li>解决方案 4: Decrease the frequency or size of the requests</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img172335.png"></p><hr><h4 id="Kinesis-Consumers"><a href="#Kinesis-Consumers" class="headerlink" title="Kinesis Consumers"></a>Kinesis Consumers</h4><ul><li>Get data records from data streams and process them</li><li>Consumers: Lambda, Kinesis Data Analytics, Kinesis Data Firehose, KCL 等等</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img190504.png"></p><ul><li>Kinesis Consumers - Custom Consumer (重要)<ul><li>Shared Fan-out Consumer: pull, low number of consuming applications, 省钱</li><li>Enhanced Fan-out Consumer: push, multiple consuming application, 贵</li><li>Enhanced Fan-out Consumer 可以 increase read throughput (重要)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img202712.png"></p><ul><li>Kinesis Consumers - AWS Lambda (重要)<ul><li>Supports Classic &amp; Enhanced fan-out consumers</li><li>Read records in batches, can configure batch size and window</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img203145.png"></p><hr><h4 id="Kinesis-Client-Library-KCL"><a href="#Kinesis-Client-Library-KCL" class="headerlink" title="Kinesis Client Library (KCL)"></a>Kinesis Client Library (KCL)</h4><ul><li>A Java library that helps read record from a Kinesis Data Stream</li><li>When using Kinesis Client Library, each shard is to be read-only by one KCL instance</li><li>Progress is checkpointed into DynamoDB (need IAM access)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img205645.png"></p><hr><h4 id="Kinesis-Operations"><a href="#Kinesis-Operations" class="headerlink" title="Kinesis Operations"></a>Kinesis Operations</h4><ul><li>Shard Splitting: Deal with <code>hot shard</code><ul><li>Used to increase the Stream capacity, divide a <code>hot shard</code></li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img205913.png"></p><ul><li>Merging Shards: Group two shards with low traffic<ul><li>Decrease the Stream capacity and save costs</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img210015.png"></p><hr><h4 id="Kinesis-Data-Firehose"><a href="#Kinesis-Data-Firehose" class="headerlink" title="Kinesis Data Firehose"></a>Kinesis Data Firehose</h4><ul><li>Kinesis Data Firehose load streaming data into data stores and analytics tools<ul><li>对于 injest data 来说, Kinesis Data Firehose 比 Kinesis Data Streams 好</li><li>Managed service, auto scaling, serverless, support data transformation</li><li>Kinesis Data Firehose 提供将数据流传进数据存储或者数据分析的功能</li></ul></li><li>Near Real Time, 而且 Firehose 只支持一个 consumer (dump data in a single data repo)<ul><li>但是不要被 Near Real Time 忽悠, 要根据题目选择 Data Stream 或者 Data Firehose</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img015040.png"></p><ul><li>Firehose 的对象是 S3, Redshift 这种 (Serverless, 专门处理 log 数据)<ul><li>Firehose 不支持 DynamoDB 的</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img151812.png"></p><ul><li>Kinesis Data Streams vs Firehose<ul><li>Data Streams: Write custom code, real-time, have data storage, have replay</li><li>Firehose: Fully managed, near real-time, no data storage, no replay</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img152247.png"></p><hr><h4 id="Kinesis-Data-Analytics"><a href="#Kinesis-Data-Analytics" class="headerlink" title="Kinesis Data Analytics"></a>Kinesis Data Analytics</h4><ul><li>Real-time analytics on Kinesis Data Streams &amp; Firehose using SQL (重要)<ul><li>Fully managed, auto-scaling, serverless</li><li>以 Kinesis Data Streams &amp; Firehose 作为目标使用 SQL 进行数据分析</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img225813.png"></p><ul><li>Amazon Managed Service for Apache Flink<ul><li>Use Flink to process and analyze streaming data</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img225906.png"></p><hr><h4 id="Data-ordering-for-Kinesis"><a href="#Data-ordering-for-Kinesis" class="headerlink" title="Data ordering for Kinesis"></a>Data ordering for Kinesis</h4><ul><li>Ordering data into Kinesis<ul><li>Same key (Partition) will always go to the same shard (有顺序)</li><li>适用于需要处理大量 data 的情况</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img154939.png"></p><ul><li>Ordering data into SQS<ul><li>相比之下 SQS 只有 FIFO (GroupID), 不然就没有 ordering</li><li>适用于需要 dynamic number of consumers 的情况</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img210807.png"></p><hr><h3 id="18-AWS-Mointoring-amp-Audit"><a href="#18-AWS-Mointoring-amp-Audit" class="headerlink" title="18. AWS Mointoring &amp; Audit"></a>18. AWS Mointoring &amp; Audit</h3><h4 id="CloudWatch-Metrics"><a href="#CloudWatch-Metrics" class="headerlink" title="CloudWatch Metrics"></a>CloudWatch Metrics</h4><ul><li>CloudWatch Metrics 用于收集、存储和分析 AWS 资源和应用程序的性能指标</li><li>可以用 <code>PutMetricData</code> 来 push custom metric data 到 CloudWatch 里</li><li>记住, 如果是处理第三方的 API, 用的一定是 CloudWatch custom metrics (重要)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img010357.png"></p><ul><li>CloudWatch - EC2 Detailed Monitoring (重要)<ul><li>With detailed monitoring, you get data every 1 minute</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img033959.png"></p><hr><h4 id="CloudWatch-Custom-Metrics"><a href="#CloudWatch-Custom-Metrics" class="headerlink" title="CloudWatch Custom Metrics"></a>CloudWatch Custom Metrics</h4><ul><li>Define your own custom metrics to CloudWatch</li><li>High-Resolution Custom Metrics can have a minimum resolution of 1 second (重要)</li><li>Accepts metric data points two weeks in the past and two hours in the future</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img010630.png"></p><hr><h4 id="CloudWatch-Logs"><a href="#CloudWatch-Logs" class="headerlink" title="CloudWatch Logs"></a>CloudWatch Logs</h4><ul><li>A place to store application logs in AWS (S3, Kinesis, Lambda, OpenSearch)<ul><li>CloudWatch Logs 可以自己定义 expire 的时间, 默认是 never expire</li><li>Log Retention Policy defined at Log Groups level (重要)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img010815.png"></p><ul><li>CloudWatch Logs Insights (query engine)<ul><li>Search and analyze log data stored in CloudWatch Logs (查询)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img150531.png"></p><ul><li>CloudWatch Logs Subscriptions<ul><li>Get a real-time log events from CloudWatch Logs for processing and analysis</li><li>Subscription Filter: Filter which logs are events delivered to destination (重要)</li><li>Cross-Account Subscription: Send log events to resources in different AWS account</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img150643.png"></p><hr><h4 id="CloudWatch-Agent"><a href="#CloudWatch-Agent" class="headerlink" title="CloudWatch Agent"></a>CloudWatch Agent</h4><ul><li>CloudWatch Logs Agent: Old version, only send to CloudWatch Logs</li><li>CloudWatch Unified Agent: 可以传递更多信息, 比如 CPU, RAM 等等<ul><li>CloudWatch Unified Agent 可以把 EC2 的 log 传递给 CloudWatch (重要)</li></ul></li><li>可以把 CloudWatch Agent 装在 on-premise 上来收集信息</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img151251.png"></p><hr><h4 id="CloudWatch-Logs-Metric-Filter"><a href="#CloudWatch-Logs-Metric-Filter" class="headerlink" title="CloudWatch Logs Metric Filter"></a>CloudWatch Logs Metric Filter</h4><ul><li>CloudWatch Logs Metric Filter 用于从日志数据中提取指标，以监控特定事件和模式</li><li>Filters only publish the metric data points for events that happen after the filter was created (只有 filter 生成后的 event 才会被 filter)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img011918.png"></p><hr><h4 id="CloudWatch-Alarms"><a href="#CloudWatch-Alarms" class="headerlink" title="CloudWatch Alarms"></a>CloudWatch Alarms</h4><ul><li>CloudWatch Alarms are used to trigger notifications for any metric</li><li>CloudWatch Alarms 主要对象是 EC2, ASG, SNS (重要)</li><li>High resolution custom metrics 的情况下 triggered 最快是 10 秒 (重要)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img012137.png"></p><ul><li>Composite Alarms (监视当前所有 Alarm 的情况)<ul><li>Composite Alarams are mointoring the states of multiple other alarms</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img151615.png"></p><ul><li>可以用 <code>set-alarm-state</code> CLI 来控制 CloudWatch Alarms, 这样是 cost-effective 的</li></ul><hr><h4 id="CloudWatch-Syntheics"><a href="#CloudWatch-Syntheics" class="headerlink" title="CloudWatch Syntheics"></a>CloudWatch Syntheics</h4><ul><li>Configurable script that monitor your APIs, URLs, Websites<ul><li>Can run once or on a regular schedule</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img012521.png"></p><hr><h4 id="AWS-EventBridge"><a href="#AWS-EventBridge" class="headerlink" title="AWS EventBridge"></a>AWS EventBridge</h4><ul><li>Schedule CRON jobs <code>CRON means jobs on a repeating schedule</code></li><li>React to events from SaaS application (AWS services)<ul><li>如果提到 3rd party application, 考虑 EventBridge</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img185605.png"></p><ul><li>Event Bus<ul><li>可以 archive rvents 并且 replay archived events, good for debugging</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img190403.png"></p><ul><li>Schema Registry: Generate code in advance for how data is structured in event bus<ul><li>Analyze events in Event Bus and infer schema</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img190004.png"></p><ul><li>Resource-based Policy<ul><li>Manage permissions (allow &#x2F; deny) for a specific Event Bus</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img190215.png"></p><hr><h4 id="AWS-X-Ray"><a href="#AWS-X-Ray" class="headerlink" title="AWS X-Ray"></a>AWS X-Ray</h4><ul><li>Automated Trace Analysis &amp; Central Service Map Visulization<ul><li>AWS X-Ray 是一个分布式跟踪系统，用于分析和调试生产和分布式应用程序的性能问题</li><li>X-Ray 可以 cross-account tracing and visualization (重要, tracing 和 visualization)</li></ul></li><li>如果问到要检查 microservices <code>5XX</code> 的报错, 选择 X-Ray service, 而不是 CloudTrail service</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img020641.png"></p><ul><li>How to enable X-Ray (两种方法)<ul><li>Import the AWS X-Ray SDK in your code</li><li>Install the X-Ray daemon or enable X-Ray AWS Integration</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img021009.png"></p><ul><li>X-Ray Troubleshooting (EC2 要在 Instance 上跑 X-Ray Daemon)<ul><li>EC2: IAM Role has proper permission 和 Instace running X-Ray Daemon (重要)</li><li>Lambda: IAM Role <code>RayWriteOnlyAccess</code> 和 Enable Lambda X-Ray Active Tracing</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img021323.png"></p><ul><li>如果要在 Farget deployed 的 Docker 上跑 X-Ray daemon<ul><li>Deploy the X-Ray daemon agent as a sidecar container</li><li>Provide the correct IAM task role to the X-Ray container</li></ul></li><li>如果要验证 X-Ray daemon 在 ECS 上跑, 用 <code>AWS_XRAY_DAEMON_ADDRESS</code></li></ul><hr><h4 id="X-Ray-Advance"><a href="#X-Ray-Advance" class="headerlink" title="X-Ray Advance"></a>X-Ray Advance</h4><ul><li>Instrumentation: Measure of product’s performance and write trace information<ul><li>检测应用程序涉及发送传入和传出请求以及应用程序内其他事件的跟踪数据</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img021538.png"></p><ul><li>X-Ray Concepts (记下面 2 个)<ul><li><code>Sampling</code>: Decrease the amount of requests sent to X-Ray, reduce cost (省钱)</li><li><code>Annotations</code>: Index traces and use with filters (重要, 有 filter)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img021924.png"></p><ul><li>X-Ray Sampling Rules (可以控制 record data 的数量, 重要)<ul><li>With sampling rules, you control the amount of data that you record</li><li>X-Ray records first request each second, and five percent for additional requests</li><li>上面重要的点: first request <code>each second</code>, addition requests <code>5 percent</code></li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img022256.png"></p><hr><h4 id="X-Ray-APIs"><a href="#X-Ray-APIs" class="headerlink" title="X-Ray APIs"></a>X-Ray APIs</h4><ul><li>X-Ray Write APIs<ul><li><code>PutTraceSegments</code>: Upload segment documents to AWS X-Ray</li><li><code>PutTelemetryRecords</code>: Used by AWS X-Ray daemon to upload telemetry</li><li><code>GetSamplingRules</code>: Retrieve all sampling rules</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img022650.png"></p><ul><li>X-Ray Read APIs: 全都都带有 <code>Get</code><ul><li><code>GetServiceGraph</code>: Main graph</li><li><code>BatchGetTrace</code>: Retrieve a list of traces specified by ID</li><li><code>GetTraceSummaries</code>: Retrieve IDs and annotations for trace in a time frame</li><li><code>GetTraceGraph</code>: Retrieve a service graph for one or more trace IDs</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img022934.png"></p><hr><h4 id="X-Ray-with-Beanstalk"><a href="#X-Ray-with-Beanstalk" class="headerlink" title="X-Ray with Beanstalk"></a>X-Ray with Beanstalk</h4><ul><li>可以在 Elastic Beanstalk 使用 X-Ray daemon (用 console 或者 config file)<ul><li>需要 <code>.ebextensions/xray-daemon.config</code> 文件</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img023148.png"></p><hr><h4 id="AWS-Distro-for-OpenTelemetry"><a href="#AWS-Distro-for-OpenTelemetry" class="headerlink" title="AWS Distro for OpenTelemetry"></a>AWS Distro for OpenTelemetry</h4><ul><li>AWS supported distribution of open-source project OpenTelemetry</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img023636.png"></p><hr><h4 id="AWS-CloudTrail"><a href="#AWS-CloudTrail" class="headerlink" title="AWS CloudTrail"></a>AWS CloudTrail</h4><ul><li>AWS CloudTrail 是一项日志记录服务，记录和监控 AWS 账户中的 API 调用和相关活动</li><li>CloudTrail 是 Global Service, 如果东西被误删, 第一时间看 CloudTrail</li><li>CloudTrail 可以和 EventBridge 一起用去 Intercept API Calls</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img023929.png"></p><ul><li>CloudTrail Events (一共 3 种)<ul><li>Management Events: Performed on resources in AWS account</li><li>Data Events: S3 object-level activity</li><li>CloudTrail Insigths Events: Detect unusual activity (安全)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img023847.png"></p><ul><li>CloudTrail Insights (重要, 监控 unusual activity)<ul><li>CloudTrail Insights to detect unusual activity in account</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img192157.png"></p><ul><li>CloudTrail Event Retention (重要, 和 S3, Athena 有关)<ul><li>Keep events to S3 after they stored 90 days and use Athena to analyze</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img163847.png"></p><hr><h3 id="19-Lambda"><a href="#19-Lambda" class="headerlink" title="19. Lambda"></a>19. Lambda</h3><h4 id="AWS-Lambda"><a href="#AWS-Lambda" class="headerlink" title="AWS Lambda"></a>AWS Lambda</h4><ul><li>Virtual functions, serverless, limited by time (short execution of 15 min)<ul><li>Run on-demand, scaling is automated</li></ul></li><li>Could be Event-Driven, could handle CRON job<ul><li>Use EventBridge to trigger Lambda every hour</li></ul></li><li>Lambda 是有 account quota (配额限制) 的, 需要联系 AWS 来提高上限</li><li>Lambda environment variable 最大限制是 4KB, 没有数量的限制</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img162057.png"></p><ul><li>可以用 Lambda 去 connect private subnets in a VPC in your account (重要)</li><li>大部分题目都是通过增加 memory 来 improve CPU-bound Lambda function peformance (重要)</li><li>API caching 是用来 reduce calls 的, 要 faster initialization 选择 provisioned concurrency</li></ul><hr><h4 id="Lambda-Synchronous-Invocations"><a href="#Lambda-Synchronous-Invocations" class="headerlink" title="Lambda Synchronous Invocations"></a>Lambda Synchronous Invocations</h4><ul><li>Synchronous: CLI, SDK, API Gateway, Application Load Balancer<ul><li>Results is returned right away</li><li>Error handling must happen client side</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img164039.png"></p><hr><h4 id="Lambda-with-ALB"><a href="#Lambda-with-ALB" class="headerlink" title="Lambda with ALB"></a>Lambda with ALB</h4><ul><li>Expose a Lambda function as an HTTPs endpoint, use ALB or API Gateway<ul><li>The Lambda function must be registered in a Target Group (重要)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img163555.png"></p><ul><li>ALB Multi-Header Values<ul><li>HTTP headers and query string parameters are shown as arrays</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img163757.png"></p><hr><h4 id="Lambda-Asynchronous-Invocations"><a href="#Lambda-Asynchronous-Invocations" class="headerlink" title="Lambda Asynchronous Invocations"></a>Lambda Asynchronous Invocations</h4><ul><li>Asynchronous: S3, SNS, CloudWatch, EventBridge<ul><li>The events are placed in a Event Queue</li><li>Lambda attemps to retry on errors (3 tries total)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img164249.png"></p><hr><h4 id="Lambda-Event-Source-Mapping"><a href="#Lambda-Event-Source-Mapping" class="headerlink" title="Lambda Event Source Mapping"></a>Lambda Event Source Mapping</h4><ul><li>Work with Kinesis Data Streams, SQS (FIFO), DynamoDB Streams (重要)<ul><li>Lambda function is invoked synchronously, 所以 SNS 就不能用 Event Source Mapping</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img165403.png"></p><ul><li>Streasm &amp; Lambda (Kinesis &amp; DynamoDB)<ul><li>An event source mapping creates an iterator for each shard, process items in order</li><li>Low traffic: Use batch window</li><li>High traffic: Multiple batches in parallel</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img165631.png"></p><ul><li>Streasm &amp; Lambda Error Handling<ul><li>By default, if function returns an error, the entire batch is reprocessed until the function succeeds, or the items in the batch expire</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img165758.png"></p><ul><li>Queue &amp; Lambda (SQS &amp; FIFO)<ul><li>Event Source Mapping will poll SQS (Long Polling)</li><li>If use FIFO queues, Lambda will scale up to the number of active message groups</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img165931.png"></p><hr><h4 id="Lambda-Event-and-Context-Objects"><a href="#Lambda-Event-and-Context-Objects" class="headerlink" title="Lambda Event and Context Objects"></a>Lambda Event and Context Objects</h4><ul><li>简单来说就是 lambda_hander 里面的参数 event 和 context</li><li><code>event</code>: JSON document contains data for the function to process</li><li><code>context</code>: Provides information about the invocation, function, runtime environment</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img170535.png"></p><hr><h4 id="Lambda-Destinations"><a href="#Lambda-Destinations" class="headerlink" title="Lambda Destinations"></a>Lambda Destinations</h4><ul><li>Can configure to send result to a destination (重要)<ul><li>Asynchronous invocations: Define destinations for successful and failed event</li><li>Event Source Mapping: For discarded event batches</li></ul></li><li>注意, Lambda Destionation 可以是 DLQ, 这样可以直接用 SQS (重要)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img170912.png"></p><hr><h4 id="Lambda-Permissions"><a href="#Lambda-Permissions" class="headerlink" title="Lambda Permissions"></a>Lambda Permissions</h4><ul><li>Lambda Execution Role (重要, 大部分 Lambda 的问题都和 Execution Role 有关)<ul><li>Grant Lambda function permissions to AWS services (IAM Role)</li><li>Best practice: Create one Lambda Execution Role per function</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img171158.png"></p><ul><li>Lambda Resource Based Policies<ul><li>Use resource-based policies to give other accounts and AWS services permission to use your Lambda resources (感觉 Resource Base Policy 都是给跨账号权限的)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img171329.png"></p><hr><h4 id="Lambda-Environment-Variables"><a href="#Lambda-Environment-Variables" class="headerlink" title="Lambda Environment Variables"></a>Lambda Environment Variables</h4><ul><li>存 secrets 和 api keys 的</li><li>可以用来 inject dynamic variables into Lambda function (重要)</li><li>注意, 像 token 这种就不能放在 Environment Variable, 要在 deployment package <code>.zip</code> 里</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img173203.png"></p><hr><h4 id="Lambda-Logging-amp-Monitoring"><a href="#Lambda-Logging-amp-Monitoring" class="headerlink" title="Lambda Logging &amp; Monitoring"></a>Lambda Logging &amp; Monitoring</h4><ul><li>Lambda execution logs are stored in AWS CloudWatch Logs</li><li>Lambda metrices are displayed in AWS CloudWatch Metrices</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img173409.png"></p><ul><li>Lambda Tracing with X-Ray<ul><li>Enable in Lambda configuration (Active Tracing)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img173520.png"></p><hr><h4 id="CloudFront-Functions-amp-Lambda-Edge"><a href="#CloudFront-Functions-amp-Lambda-Edge" class="headerlink" title="CloudFront Functions &amp; Lambda@Edge"></a>CloudFront Functions &amp; Lambda@Edge</h4><ul><li>Execute logic at the edge (Edge Function, serverless)</li><li>两种方法: CloudFront Functions, Lambda@Edge (它们支持的语言不同)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img173715.png"></p><ul><li>CloudFront Functions<ul><li>For high-scale, latency-sensitive CDN customizations (millions 级别的)</li><li>Used to change Viewer requestes and responses, short execution time</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img173900.png"></p><ul><li>Lambda@Edge<ul><li>Scales to 1000s of requests&#x2F;second (thousands 级别的)</li><li>Used to change Viewer requestes and responses, longer execution time</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img214545.png"></p><hr><h4 id="Lambda-in-VPC"><a href="#Lambda-in-VPC" class="headerlink" title="Lambda in VPC"></a>Lambda in VPC</h4><ul><li>正常情况下, Lambda 无法访问 VPC (所以要 Lambda in VPC)</li><li>需要 VPC ID, Subnet 和 Security Groups, Lambda will create an ENI</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img174359.png"></p><ul><li>Lambda in VPC - Internet Access (2 种方法)<ul><li>Lambda function in your VPC does not have internet access</li><li>Deploying a Lambda function in public subnet does not give internet access</li></ul></li><li>Need to deploy Lambda function in private subnet and give a NAT Gateway &#x2F; Instance</li><li>Also can use VPC endpoints to privately access AWS services without NAT</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img174704.png"></p><hr><h4 id="Lambda-Function-Performance"><a href="#Lambda-Function-Performance" class="headerlink" title="Lambda Function Performance"></a>Lambda Function Performance</h4><ul><li>Lambda Function Configuration<ul><li>RAM: If application is CPU-bound (computation heavy), increase RAM</li><li>Timeout: Default 3 seconds, maximum is 900 seconds (15 minutes)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img174946.png"></p><ul><li>Lambda Execution Context<ul><li>The execution context is a temporary runtime environment that initializes any external dependencies of your lambda code</li><li>The execution context includes the <code>/tmp</code> directory (重要)</li><li><code>/tmp</code> directory 的最大容量是 <code>10240</code> MB, default 是 <code>512</code> MB</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img175158.png"></p><ul><li>Initialize outside the handler (重要)<ul><li>防止 DB connection 被多次建立</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img175513.png"></p><hr><h4 id="Lambda-Layers"><a href="#Lambda-Layers" class="headerlink" title="Lambda Layers"></a>Lambda Layers</h4><ul><li>Create Custom Runtime &amp; Externalize Dependencies to re-use them</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img192245.png"></p><hr><h4 id="Lambda-File-Systems-Mounting"><a href="#Lambda-File-Systems-Mounting" class="headerlink" title="Lambda File Systems Mounting"></a>Lambda File Systems Mounting</h4><ul><li>Lambda functions can access EFS file systems if they are running in a VPC<ul><li>Leaverage EFS Access Points</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img192513.png"></p><hr><h4 id="Lambda-Concurrency"><a href="#Lambda-Concurrency" class="headerlink" title="Lambda Concurrency"></a>Lambda Concurrency</h4><ul><li>Can set a <code>reserved concurrency</code> to limit the number of concurrent execution</li><li>Each invocation over the concurrency limit will trigger a <code>Throttle</code><ul><li>If need a higher limit, open a support ticket</li></ul></li><li>对于处理 Asynchronous 的情况, Lambda 会把 event 返回到 queue 里</li><li>可以 configure Auto Scaling to manage Lambda provisioned concurrency on a schedule<ul><li>比如要应对圣诞节这种情况</li></ul></li><li>如果是要解决 Lambda exceed concurrency limits, 选择 reserved concurrency</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img193032.png"></p><ul><li>Cold Starts &amp; Provisioned Concurrency<ul><li>Cold Start: First request served by new instances has higher latency than rest</li><li>Provisioned Concurrency: Allocate concurrency before the function is invoked</li><li>Provisioned Concurrency 解决了 Cold Start 的问题 (重要)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img224130.png"></p><hr><h4 id="Lambda-External-Dependencies"><a href="#Lambda-External-Dependencies" class="headerlink" title="Lambda External Dependencies"></a>Lambda External Dependencies</h4><ul><li>If Lambda function depends on external libraries<ul><li>You need to install the packages alongside your code and zip together</li></ul></li><li>注意, 这里是把 functions 和 dependencies zip 在一起, 而不是分开 zip (重要)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img224459.png"></p><hr><h4 id="Lambda-Container-Image"><a href="#Lambda-Container-Image" class="headerlink" title="Lambda Container Image"></a>Lambda Container Image</h4><ul><li>Deploy Lambda function as container images (也就是说 Lambda 和 Docker 是可以一起用的)</li><li>Pack complex dependencies, large dependencies in a container</li><li>To deploy a container image to Lambda, the container image must implement Lambda Runtime API</li><li>AWS Lambda service does not support Lambda functions that use multi-architecture container image</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img000324.png"></p><hr><h4 id="Lambda-Versions-and-Aliases"><a href="#Lambda-Versions-and-Aliases" class="headerlink" title="Lambda Versions and Aliases"></a>Lambda Versions and Aliases</h4><ul><li>Lambda Versions (重要)<ul><li>When work on a Lambda function, work on $LATEST</li><li>When publish a Lambda function, create a version</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img000644.png"></p><ul><li>Lambda Aliases (重要)<ul><li>Aliases are <code>pointers</code> to Lambda function versions</li><li>Aliases enable Canary deployment by assigning weights to Lambda functions</li><li>Aliases cannot reference aliases</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img000912.png"></p><hr><h4 id="Lambda-with-CodeDeploy"><a href="#Lambda-with-CodeDeploy" class="headerlink" title="Lambda with CodeDeploy"></a>Lambda with CodeDeploy</h4><ul><li>CodeDeploy can help automate traffic shift for Lambda aliases<ul><li>Linear: Grow traffic every <code>N minutes</code> until <code>100%</code></li><li>Canary: Try <code>X</code> percent then <code>100%</code></li><li>AllAtOnce: Immediate</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img001338.png"></p><hr><h4 id="Lambda-Function-URL"><a href="#Lambda-Function-URL" class="headerlink" title="Lambda Function URL"></a>Lambda Function URL</h4><ul><li>Dedicated HTTPS endpoint for Lambda function (不用 API Gateway 的做法)<ul><li>形式 <code>https://&lt;url-id&gt;.lambda-url.&lt;region&gt;.on.aws</code></li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img001532.png"></p><hr><h4 id="Lambda-with-CodeGuru"><a href="#Lambda-with-CodeGuru" class="headerlink" title="Lambda with CodeGuru"></a>Lambda with CodeGuru</h4><ul><li>Gain insights into runtime performance of your Lambda function</li><li>CodeGuru creates a Profiler Group for your Lambda function</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img001843.png"></p><hr><h3 id="20-DynamoDB"><a href="#20-DynamoDB" class="headerlink" title="20. DynamoDB"></a>20. DynamoDB</h3><h4 id="AWS-DynamoDB"><a href="#AWS-DynamoDB" class="headerlink" title="AWS DynamoDB"></a>AWS DynamoDB</h4><ul><li>NoSQL database, with replication across multiple AZs, auto scaling, no provision</li><li>两种 Class: Standard &amp; Infrequent Access (IA)</li><li>如果问到 DynamoDB 而且是处理 Email 的, 就是 DynamoDB Stream</li><li>如果问到 DynamoDB 而且是处理 unpredictable 数据的时候, 选择 On-Demand table</li><li>By default, DynamoDB tables are encrypted with AWS owned key (重要)</li><li>DynamoDB 没办法用 resource policy, 所以必须要用 IAM role + AssumeRole (重要)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img012414.png"></p><ul><li>Each table has a Primary Key, must be decided at creation time (2 种选择)<ul><li>Partition Key (HASH): Partition Key must be unique for each item</li><li>Partition Key + Sort Key (HASH + RANGE): The combination must be unique</li></ul></li><li>Item 的最大大小是 400 KB</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img012627.png"></p><ul><li>DynamoDB 有 2 种 backup 方法, On-demand 和 Point-in-time recovery, 但它们只能把数据写到 S3 里, 没办法从 backup 里面去 access S3 buckets</li><li>不要用 DynamoDB 去保存图片, 因为 DynamoDB 最大 item 大小是 400 KB</li><li>如果要给 DynamoDB ready-only access, 用 IAM Role <code>AmazonDynamoDBReadOnlyAccess</code></li><li>如果要 reduce DynamoDB latency, 可以用下面 2 点<ul><li>Consider using Global tables if your application is accessed by globally distributed users</li><li>Use eventually consistent reads in place of strongly consistent reads whenever possible</li></ul></li></ul><hr><h4 id="DynamoDB-WCU-amp-RCU"><a href="#DynamoDB-WCU-amp-RCU" class="headerlink" title="DynamoDB WCU &amp; RCU"></a>DynamoDB WCU &amp; RCU</h4><ul><li>Read &#x2F; Write Capacity Mode (2 种 Mode)<ul><li>Provisioned Mode: 自己定义需要多少 RCU 和 WCU (默认)</li><li>On-Demand Mode: 自动 scale 需要的 RCU 和 WCU (贵)</li></ul></li><li>RCU 和 WCU 没有关联吗, 可以只加 RCU 不加 WCU</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img014420.png"></p><ul><li>R&#x2F;W Capacity Modes - Provisioned<ul><li>Read Capacity Units (RCU): throughput for reads</li><li>Write Capacity Units (WCU): throughput for writes</li><li>Throughput can be exceeded temporarily using <code>Burst Capacity</code></li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img014716.png"></p><ul><li>Write Capacity Units (WCU)<ul><li>One Write Capacity Unit represents <code>one write per second</code> for an item up to <code>1KB</code></li><li>非常重要, 记住 WCU 是 1 比 1 的, size 需要 round up 到整数</li><li>例子: 6 items with item size 4.5KB: <code>6 * 5 / 1 = 30 WCU</code></li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img014951.png"></p><ul><li>Strongly Consistent Read vs. Eventually Consistent Read (重要)<ul><li>Eventually Consistent Read: might get stale data because of duplication (默认)</li><li>Strongly Consistent Read: will always get the correct data (贵)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img015146.png"></p><ul><li>Read Capacity Units (RCU)<ul><li>One Read Capacity Unit represents one Strongly Consistent Read per second, or two Eventually Consistent Read per second, for an item up to 4 KB in size (重要)</li><li>非常重要, 对于 Strongly Consistent Read 来说是 1 比 4 的, size 要 round up 到 4 的倍数</li><li>非常重要, 对于 Eventually Consistent Read 来说是 2 比 4 的, size 要 round up 到 4 的倍数</li><li>例子: 10 Strongly Consistent Reads with item size 4 KB: <code>10 * 4 / 4 = 10 RCU</code></li><li>例子: 16 Eventually Consistent Reads with item size 12 KB: <code>16 /2 * 12 / 4 = 24 RCU</code></li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img015532.png"></p><ul><li>DynamoDB - Partitions Internal<ul><li>Data is stored in partitions, use Partition Key to know which partition should go</li><li>WCUs and RCUs are spread evenly across partitions</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img015726.png"></p><ul><li>DynamoDB - Throttling (重要)<ul><li>Exceeded provisioned RCUs or WCUs, get <code>ProvisionedThroughputExceededException</code></li><li>原因: Hot Keys, Hot Paritions, Very large items (重要)</li><li>解决方案: Exponential backoff, Distribute partition keys, use DynamoDB DAX (重要)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img015936.png"></p><ul><li>R&#x2F;W Capacity Modes - On-Demand<ul><li>Read &#x2F; writes automatically scale up &#x2F; down with workloads</li><li>Read Request Units (RRU): throughput for reads (same as RCU)</li><li>Write Request Units (WRU): throughput for writes (same as WCU)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img020318.png"></p><hr><h4 id="DynamoDB-Basic-Operations"><a href="#DynamoDB-Basic-Operations" class="headerlink" title="DynamoDB Basic Operations"></a>DynamoDB Basic Operations</h4><ul><li>注意, DynamoDB <code>UpdateItem</code> 是更新 attribute 或者新创建一个 (如果不存在)</li><li>Writing Data<ul><li><code>PutItem</code>: Create a new item or fully replace an old item</li><li><code>UpdateItem</code>: Edit an existing item’s attributes or add new items if not exist (注意)</li><li><code>Conditional Writes:</code> Accept a <code>write/update/delete</code> only if condition met</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img020700.png"></p><ul><li>Reading Data<ul><li><code>GetItem</code>: Read based on Primary key</li><li><code>Query</code>: Return items based on <code>KeyConditionExpression</code>, <code>FilterExpression</code></li><li><code>Scan</code>: Scan the entire table and then filter out data (可以 parallel, 重要)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img020844.png"></p><ul><li>Deleting Data<ul><li><code>DeleteItem</code>: Delete an individual item</li><li><code>DeleteTable</code>: Delete the whole table and all its items</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img021027.png"></p><ul><li>DynamoDB Batch Operations<ul><li>Allow yout to save in latency by reducing the number of API cals</li><li><code>BatchWriteItem</code> 和 <code>BatchGetItem</code></li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img021208.png"></p><ul><li>Table Cleanup (2 种方法)<ul><li><code>Scan + DeleteItem</code> 或者 <code>Drop Table + Recreate Table</code></li></ul></li><li>Copying a DynamoDB Table (3 种方法)<ul><li>AWS Data Pipeline 或者 Backup + Restore 或者 <code>Scan + PutItem or BatchWriteItem</code></li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img033405.png"></p><hr><h4 id="DynamoDB-Conditional-Writes"><a href="#DynamoDB-Conditional-Writes" class="headerlink" title="DynamoDB Conditional Writes"></a>DynamoDB Conditional Writes</h4><ul><li>For <code>PutItem, UpdateItem, DeleteItem, BatchWriteItem</code></li><li>Specify a conditional expression to determine which item should be modified</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img022327.png"></p><hr><h4 id="DynamoDB-Indexes"><a href="#DynamoDB-Indexes" class="headerlink" title="DynamoDB Indexes"></a>DynamoDB Indexes</h4><ul><li>Local Secondary Index (LSI, 重要)<ul><li>Alternative Sort Key for your table (注意这里是 Partition Key)</li><li>Must be defined at table creation time (重要)</li><li>Attribute Projections: Contain some or all attributes of the base table</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img025528.png"></p><ul><li>Global Secondary Index (GSI, 重要)<ul><li>Alternative Primary Key from the base table (注意这里是 Primary Key)</li><li>Must provision RCUs &amp; WCUs for the index</li><li>Can be added or modified after table creation</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img025824.png"></p><ul><li>Indexes and Throttling<ul><li>GSI: If writes are throttled on the GSI, then the main table will be throttled</li><li>LSI: Use WCUs and RCUs of the main table, no throttling consideration</li><li>重要, 是 GSI 会造成 throttling, LSI 不用考虑 throttling</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img025950.png"></p><hr><h4 id="DynamoDB-PartiQL"><a href="#DynamoDB-PartiQL" class="headerlink" title="DynamoDB PartiQL"></a>DynamoDB PartiQL</h4><ul><li>Use a SQL-like syntax to manipulate DynamoDB tables (重要)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img030113.png"></p><hr><h4 id="DynamoDB-Optimistic-Locking"><a href="#DynamoDB-Optimistic-Locking" class="headerlink" title="DynamoDB Optimistic Locking"></a>DynamoDB Optimistic Locking</h4><ul><li>A strategy to ensure an item hasn’t changed before update or delete it (重要)</li><li>DynamoDB Optimistic Locking 是 Concurrency Model, 而且它用 Conditional Writes (重要)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img030304.png"></p><hr><h4 id="DynamoDB-DAX"><a href="#DynamoDB-DAX" class="headerlink" title="DynamoDB DAX"></a>DynamoDB DAX</h4><ul><li>DynamoDB Accelerator (DAX, 可以处理 cache, 但是 DAX 不是 relational 的)<ul><li>Help solve read congestion by caching (microseconds latency, 缓存)</li><li>DAX 不支持 SQL query caching</li><li>可以提高 DynamoDB 的 performance (提高的是 read 而不是 write, 重要)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img233440.png"></p><hr><h4 id="DynamoDB-Stream"><a href="#DynamoDB-Stream" class="headerlink" title="DynamoDB Stream"></a>DynamoDB Stream</h4><ul><li>DynamoDB Stream: 目标是 Lambda 和 Kinesis Data Streams, 没有 SQS (注意)<ul><li>Ordered stream of item-level modifications in table (重要)</li><li>用来处理 Stream 的, 可以 Invoke Lambda function (比如发邮件)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img030626.png"></p><ul><li>DynamoDB Streams are made of shards, like Kinesis Data Streams</li><li>Records are not retroactively populated in a stream after enabling it</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img030940.png"></p><hr><h4 id="DynamoDB-TTL"><a href="#DynamoDB-TTL" class="headerlink" title="DynamoDB TTL"></a>DynamoDB TTL</h4><ul><li>Automatic delete items after an expiry timestamp (定时删除 DynamoDB 里的 item)</li><li>Expired items deleted within 48 hours of expiration</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img031135.png"></p><hr><h4 id="DynamoDB-CLI"><a href="#DynamoDB-CLI" class="headerlink" title="DynamoDB CLI"></a>DynamoDB CLI</h4><ul><li><code>projection-expression</code>: Select a subset of attribute to retrieve (subset of attribute)</li><li><code>filter-expression</code>: Filter items to retrieve a subset of the items (subset of items)</li><li>Minimize the items returned in CLI: <code>max-items &amp; starting-token</code></li><li>注意, 如果问到和 attribute 有关的就是 <code>projection-expression</code></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img031324.png"></p><hr><h4 id="DynamoDB-Transcations"><a href="#DynamoDB-Transcations" class="headerlink" title="DynamoDB Transcations"></a>DynamoDB Transcations</h4><ul><li>Coordinated operations to multiple items across one or more tables (金融, 游戏)</li><li>Provides Atomcity, Consistency, Isolation, and Durability (ACID)</li><li>Consume 2 times of WCUs &amp; RCUs (注意, DynamoDB Transcation 消耗 2 倍 WCU 和 RCU)</li><li>Two operations: <code>TransactGetItems</code> 和 <code>TransactWriteItems</code></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img031646.png"></p><ul><li>DynamoDB Transactions Capacity Computation<ul><li>3 Transcational writes with item size 5 KB: need 3 _ 5 &#x2F; 1 _ 2 &#x3D; 30 WCUs</li><li>5 Transcation reads with items size 5 KB: need 5 _ 8 &#x2F; 4 _ 2 &#x3D; 20 RCUs</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img032052.png"></p><hr><h4 id="DynamoDB-Session-State"><a href="#DynamoDB-Session-State" class="headerlink" title="DynamoDB Session State"></a>DynamoDB Session State</h4><ul><li>To use DynamoDB to store the session state</li><li>ElastiCache is in-memory, DynamoDB is serverless (both are key&#x2F;value pair)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img032422.png"></p><hr><h4 id="DynamoDB-Write-Sharding"><a href="#DynamoDB-Write-Sharding" class="headerlink" title="DynamoDB Write Sharding"></a>DynamoDB Write Sharding</h4><ul><li>A strategy that allow better distribution of items evenly across partitions<ul><li>To solve the issue of <code>Hot Partition</code></li></ul></li><li>Add a suffix to Partition Key value</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img032640.png"></p><hr><h4 id="DynamoDB-Other-Features"><a href="#DynamoDB-Other-Features" class="headerlink" title="DynamoDB Other Features"></a>DynamoDB Other Features</h4><ul><li>Backup and Restore: Point-in-time recovery (PITR) like RDS</li><li>Global Tables: Multi-region, fully replicated, high performance</li><li>DynamoDB Local: Develop and test app locally with out accessing internet</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img033717.png"></p><ul><li>DynamoDB Fine-Grained Access Control<ul><li>Assign IAM Role to users with a Condition to limit their API access DynamoDB</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img033855.png"></p><hr><h3 id="21-API-Gateway"><a href="#21-API-Gateway" class="headerlink" title="21. API Gateway"></a>21. API Gateway</h3><h4 id="AWS-API-Gateway"><a href="#AWS-API-Gateway" class="headerlink" title="AWS API Gateway"></a>AWS API Gateway</h4><ul><li>Invoke Lambda function, expose REST API (stateless client-server communication)</li><li>Lambda + API Gateway &#x3D; No infrastructure to manage</li><li>API Gateway 可以防止 API overwhelmed by too many requests (防抖)</li><li>API Gateway Caching (可以 improve latency, 重要)<ul><li>With caching, you can reduce the number of calls made to your endpoint and also improve the latency of requests to your API</li></ul></li><li>注意, API Gateway 不 support STS, 可以用 Congito User Pool, IAM permissions with sigv4 和 Lambda Authorizer</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img164125.png"></p><ul><li>API Gateway Endpoint Types<ul><li>Edge-Optimized (默认): For global clients, API Gateway live in one region</li><li>Regional: For client in same region</li><li>Private: Can only be accessed from VPC using ENI</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img164338.png"></p><ul><li>API Gateway 可以用 Cognito User Pools, AWS IAM roles and policies 和 Lambda Authorizer 来进行 authenticate</li></ul><hr><h4 id="API-Gateway-Stages"><a href="#API-Gateway-Stages" class="headerlink" title="API Gateway Stages"></a>API Gateway Stages</h4><ul><li>Making changes in the API Gateway does not mean they’re effective (重要)<ul><li>You need to make a “deployment” for them to be in effect</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img173311.png"></p><ul><li>API Gateway - Stage Variables<ul><li>Stage variables are like environment variables for API Gateway</li><li>Use case: Create a stage variable to indicate the Lambda alias (重要)</li><li>如果要把 test promote 成 prod, 而且当前 prod 存在, 直接 update stage variable 就行</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img190149.png"></p><hr><h4 id="API-Gateway-Canary-Deployment"><a href="#API-Gateway-Canary-Deployment" class="headerlink" title="API Gateway Canary Deployment"></a>API Gateway Canary Deployment</h4><ul><li>Choose the <code>%</code> of traffic the canary channel receives<ul><li>Canary deployment: 逐步发布新版本，先小规模测试，再全面推广的策略</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img190857.png"></p><hr><h4 id="API-Gateway-Integration-Tyeps"><a href="#API-Gateway-Integration-Tyeps" class="headerlink" title="API Gateway Integration Tyeps"></a>API Gateway Integration Tyeps</h4><ul><li><code>MOCK</code><ul><li>API Gateway returns a response without sending the request to backend</li></ul></li><li><code>HTTP / AWS</code><ul><li>Configure both the integration request and integration response</li><li>Set up data mapping using mapping templates for request &amp; response</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img191239.png"></p><ul><li><code>AWS_PROXY</code> (Lambda Proxy)<ul><li>Incoming request from the client is the input to Lambda</li><li>No mapping template, headers, query string parameters are passed as arguments</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img191413.png"></p><ul><li><code>HTTP_PROXY</code><ul><li>No mapping template, the HTTP request is passed to the backend</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img191520.png"></p><hr><h4 id="API-Gateway-Mapping-Templates"><a href="#API-Gateway-Mapping-Templates" class="headerlink" title="API Gateway Mapping Templates"></a>API Gateway Mapping Templates</h4><ul><li>Mapping templates can be used to modify request &#x2F; responses<ul><li>可以用来屏蔽 output data 中的某些字段</li></ul></li><li>Modify query string parameters, modify body content, add headers</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img191718.png"></p><hr><h4 id="API-Gateway-OpenAPI"><a href="#API-Gateway-OpenAPI" class="headerlink" title="API Gateway OpenAPI"></a>API Gateway OpenAPI</h4><ul><li>Common way to define REST APIs, using API defintion as code</li><li>Request Validation: reduce unnecessary calls to the backend</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img201259.png"></p><hr><h4 id="API-Gateway-Caching"><a href="#API-Gateway-Caching" class="headerlink" title="API Gateway Caching"></a>API Gateway Caching</h4><ul><li>Caching reduces the number of calls made to the backend</li><li>Caches are defined per <code>stage</code>, default TTL is <code>300</code> sec, max TTL is <code>3600</code> sec (重要)</li><li>Client can invalidate the cache with header: <code>Cache-Control:max-age=0</code> (重要)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img201709.png"></p><hr><h4 id="API-Gateway-Usage-Plans-amp-API-Keys"><a href="#API-Gateway-Usage-Plans-amp-API-Keys" class="headerlink" title="API Gateway Usage Plans &amp; API Keys"></a>API Gateway Usage Plans &amp; API Keys</h4><ul><li>Make an API availiable as an offering to your customers (重要)</li><li>Usage Plan: who can access, how much and how fast can access, use API keys to identify</li><li>API Keys: use with usage plans to control access</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img202109.png"></p><ul><li>To configure a usage plan<ul><li>Create one or more APIs, configure methods to require API key, deploy API to stage</li><li>Generate or import API keys to distribute to application developer</li><li>Create the usage plan with desired throttle and quota limits</li><li>Associate API stages and API keys with the usage plan</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img202324.png"></p><hr><h4 id="API-Gateway-Monitoring"><a href="#API-Gateway-Monitoring" class="headerlink" title="API Gateway Monitoring"></a>API Gateway Monitoring</h4><ul><li><code>CacheHitCount &amp; CacheMissCount</code>: efficiency of the cache</li><li><code>IntegrationLatency &amp; Latency</code>: 用来测 timeout issue</li><li><code>4XX</code> means Client errors, <code>5XX </code>means Server errors, <code>429</code> 是 too many requests</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img202658.png"></p><hr><h4 id="API-Gateway-CORS"><a href="#API-Gateway-CORS" class="headerlink" title="API Gateway CORS"></a>API Gateway CORS</h4><ul><li>CORS must be enabled when you receive API calls from another domain</li><li>CORS 也可以用来限制一些 domain 来防止它们 access API</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img202855.png"></p><hr><h4 id="API-Gateway-Security"><a href="#API-Gateway-Security" class="headerlink" title="API Gateway Security"></a>API Gateway Security</h4><ul><li>IAM Permissions (for within your AWS account)<ul><li>Authentication is IAM, Authorization is IAM Policy</li><li>Create an IAM policy authorization and attch to User or Role</li><li>If need Cross Account Access, use Resource Policies</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img203055.png"></p><ul><li>Cognito User Pools (for your own user pool, 重要)<ul><li>Authentication is Cognito User Pools, Authorization is API Gateway Methods</li><li>API Gateway verifies identity automatically from AWS Cognito</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img203446.png"></p><ul><li>Lambda Authorizer (use 3rd party tokens, 重要)<ul><li>Authentication is External, Authorization is Lambda function</li><li>Token-based authorizer, JWT or Oauth</li><li>Lambda Authorizer 也可以用来 implement authorization scheme that uses request parameters to determine the caller’s identity (重要)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img203612.png"></p><hr><h4 id="API-Gateway-WebSocket-API"><a href="#API-Gateway-WebSocket-API" class="headerlink" title="API Gateway WebSocket API"></a>API Gateway WebSocket API</h4><ul><li>WebSocket APIs are often used in real time applications such as chat or trading<ul><li>WebSocket is two ways commmunication</li></ul></li><li>形式 <code>wss://[uniqueid].execute-api.[region].amazonaws.com/[stage-name]</code></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img204056.png"></p><ul><li>WebSocket API - Routing<ul><li>Request a route selection expression to select the field on JSON to route from</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img204735.png"></p><hr><h3 id="22-AWS-CICD"><a href="#22-AWS-CICD" class="headerlink" title="22. AWS CICD"></a>22. AWS CICD</h3><h4 id="AWS-CodeCommit"><a href="#AWS-CodeCommit" class="headerlink" title="AWS CodeCommit"></a>AWS CodeCommit</h4><ul><li>A version control tool that helps to understand the changes happened to the code</li><li>CodeCommit is a Private Git repository (就是个 Github, 但是私人的)</li><li>如果问到 migrate repository 到 CodeCommit 使用 HTTPS, 那么用到的是 Git credentials generated from IAM (重要)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img213239.png"></p><ul><li>CodeCommit 可以使用 Git credentials, SSH Keys, AWS Access Keys</li><li>Data in AWS CodeCommit repositories is encrypted in transit and at rest</li></ul><hr><h4 id="AWS-CodePipeline"><a href="#AWS-CodePipeline" class="headerlink" title="AWS CodePipeline"></a>AWS CodePipeline</h4><ul><li>CodePipeline 是一种自动化 CICD 服务, 用于构建、测试和部署应用程序和基础设施<ul><li>如果看到 orchestrate CICD, 就是 CodePipeline</li></ul></li><li>可以 create one CodePipline for entire flow and add a manual approval step</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img215659.png"></p><ul><li>Each pipeline stage can create artifacts</li><li>Artifaces stored in an S3 bucket and passed on to the next stage</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img215817.png"></p><hr><h4 id="AWS-CodeBuild"><a href="#AWS-CodeBuild" class="headerlink" title="AWS CodeBuild"></a>AWS CodeBuild</h4><ul><li>CodeBuild 是一种完全托管的持续集成服务, 用于自动化构建、测试和生成软件包</li><li>CodeBuild 算是 Jenkins 的替代品</li><li>Build instructions: Code file <code>buildspec.yml</code> (重要) or insert manually in Console</li><li>Automated tests on application before the deployment process (遇到需要 test 的就是 CodeBuild, 重要)</li><li>CodeBuild scales automatically, 所以遇到什么 scaling 和 run build parallel 都不用担心</li><li>如果需要 troubleshoot CodeBuild, 可以 run CodeBuild locally using CodeBuild Agent</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img220508.png"></p><ul><li><code>buildspec.yml</code> file must be at the root of your code (重要)</li><li>记住, CodeBuild 可以用 KMS key 来加密 build artifacts (重要)</li><li>可以使用 CodeBuild timeouts 去防止过长的 building process</li><li>We bundle dependencies in the source code during the build stage of CodeBuild</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img220651.png"></p><hr><h4 id="AWS-CodeDeploy"><a href="#AWS-CodeDeploy" class="headerlink" title="AWS CodeDeploy"></a>AWS CodeDeploy</h4><ul><li>CodeDeploy 是一种自动化部署服务, 用于在各种计算环境中部署应用程序代码</li><li>Automated rollback in case failed deployment (可以自动 roll back 如果部署失败)<ul><li>If a rollback happens, CodeDeploy redeploys the last good revision</li></ul></li><li>A file named <code>appspec.yml</code> defines how the deployment happens</li><li>如果问到 CodeDeploy 和 EC2, 那么就只有 <code>in-place</code> 和 <code>blue/green</code><ul><li><code>blue/green</code> 可以 re-route traffic from original environment to new environment</li></ul></li><li>如果遇到要 archive number of applicaiton revision, 用 CodeDeploy Agent</li><li>如果 CodeDeploy 失败并且 rollback, A new deployment of the last known working version of the application is deployed with a new deployment ID</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img220850.png"></p><ul><li>CodeDeploy - EC2 &#x2F; On-premises Platform (需要 Agent)<ul><li>Perform <code>in-place</code> deployment or <code>blue/green</code> deployments (非常重要)</li><li>Must run the CodeDeploy Agent on the target instances (重要)</li><li>Order of Lifecycle Events: <code>ApplicationStop, DownloadBundle, BeforeInstall, Install, AfterInstall, ApplicationStart, ValidateService</code></li><li>四种 deployment speed: <code>AllAtOnce, HalfAtATime, OneAtATime, Custom</code></li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img221100.png"></p><ul><li>CodeDeploy - Lambda Platform<ul><li>Automate traffic shift for Lambda aliases</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img221326.png"></p><ul><li>CodeDeploy - ECS Platform<ul><li>Automate the deployment of a new ECS Task Definition</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img221501.png"></p><ul><li>如果要 deploy application to different EC2 Instance at different time, 用<br>CodeDeploy Deployment Groups</li></ul><hr><h4 id="AWS-CodeStar-CodeCatalyst"><a href="#AWS-CodeStar-CodeCatalyst" class="headerlink" title="AWS CodeStar (CodeCatalyst)"></a>AWS CodeStar (CodeCatalyst)</h4><ul><li>Quickly create <code>CICD-ready</code> projects for EC2, Lambda, Elastic Beanstalk</li><li>One dashboard to view all your componenets (重要, 和 dashboard 有关)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img224413.png"></p><hr><h4 id="AWS-CodeArtifact"><a href="#AWS-CodeArtifact" class="headerlink" title="AWS CodeArtifact"></a>AWS CodeArtifact</h4><ul><li>CodeArtifact is a secure and cost-effective artifact management for software development (类似 npm)</li><li>Developers and CodeBuild can retrieve dependencies straight from CodeArtifact</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img221957.png"></p><ul><li>CodeArtifact Resource Policy (Resource Policy 就是允许别人访问)<ul><li>Authorize another account to access CodeArtifact</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img222141.png"></p><hr><h4 id="AWS-CodeGuru"><a href="#AWS-CodeGuru" class="headerlink" title="AWS CodeGuru"></a>AWS CodeGuru</h4><ul><li>An ML-powered service for code reviews and performance recommendations (重要)</li><li>CodeGuru Reviewer: Automated code reviews for static code analysis (development)</li><li>CodeGuru Profiler: Recommendations about application performance (production)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img222415.png"></p><hr><h4 id="AWS-Cloud9"><a href="#AWS-Cloud9" class="headerlink" title="AWS Cloud9"></a>AWS Cloud9</h4><ul><li>Cloud-based IDE, 类似 VSCode</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img222601.png"></p><hr><h3 id="23-AWS-Serverless-Application-Model-SAM"><a href="#23-AWS-Serverless-Application-Model-SAM" class="headerlink" title="23. AWS Serverless Application Model (SAM)"></a>23. AWS Serverless Application Model (SAM)</h3><h4 id="AWS-SAM"><a href="#AWS-SAM" class="headerlink" title="AWS SAM"></a>AWS SAM</h4><ul><li>SAM &#x3D; Serverless Application Model</li><li>A framework for developing and deploying serverless applications</li><li>可以将 AWS SAM 模板直接部署到 AWS CloudFormation</li><li>使用 AWS Serverless Application Repository (SAR) 来共享 SAM 和其他 AWS 账户 (重要)<ul><li>如果想找 pre-built serverless applications 就用 SAR</li></ul></li><li>Develop the SAM template locally &#x3D;&gt; upload the template to S3 &#x3D;&gt; deploy your application to the cloud (注意)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img153636.png"></p><ul><li>SAM Recipe<ul><li><code>Transform</code> Header for SAM template: <code>AWS::Serverless-2016-10-31</code></li><li>注意, <code>Transform</code> 对于 SAM 来说是 mandatory 的</li><li>SAM supports the following resource types: <code>Function, Api, SimpleTable</code> (重要)</li><li>Upload SAM 到 AWS 用到的是 <code>sam deploy</code></li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img155435.png"></p><ul><li>SAM Accelerate <code>sam sync</code><ul><li>A set of features to reduce latency while deploying resources to AWS</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img154010.png"></p><hr><h4 id="SAM-Policy-Templates"><a href="#SAM-Policy-Templates" class="headerlink" title="SAM Policy Templates"></a>SAM Policy Templates</h4><ul><li>List of templates to apply permissions to Lambda Functions<ul><li><code>S3ReadPolicy</code>: Give read only permission to objects in S3</li><li><code>SQSPollerPolicy</code>: Allow to poll an SQS queue</li><li><code>DynamoDBCrudPolicy</code>: create, read, update, delete</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img154539.png"></p><hr><h4 id="SAM-Local-Capabilities"><a href="#SAM-Local-Capabilities" class="headerlink" title="SAM Local Capabilities"></a>SAM Local Capabilities</h4><ul><li>SAM Local 用于本地模拟、测试和调试无服务器应用程序, 支持 Lambda 和 API Gateway</li><li>Locally start AWS Lambda (记住这里都是 SAM CLI + AWS Toolkits)</li><li>Locally invoke Lambda Function</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img154914.png"></p><ul><li>Locally start an API Gateway Endpoint</li><li>Generate AWS Events for Lambda Functions</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img155003.png"></p><hr><h3 id="24-Cloud-Deployment-Kit-CDK"><a href="#24-Cloud-Deployment-Kit-CDK" class="headerlink" title="24. Cloud Deployment Kit (CDK)"></a>24. Cloud Deployment Kit (CDK)</h3><h4 id="AWS-Cloud-Development-Kit"><a href="#AWS-Cloud-Development-Kit" class="headerlink" title="AWS Cloud Development Kit"></a>AWS Cloud Development Kit</h4><ul><li>Define your cloud infrastructure using a familiar language (Java, Python)</li><li>Can deploy infrastructure and application runtime code together</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img160250.png"></p><ul><li>CDK 和 SAM 的不同 (虽然它们都用 CloudFormation)<ul><li>SAM 主要关注的是 Serverless 和 Lambda, 而且只能用 JSON 或者 YAML 的形式</li><li>CDK 可以用在所有 AWS services 上, 可以用所有编程语言</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img160532.png"></p><ul><li>注意, CDK 才会提供 app template, 而不是 CloudFormation (重要)</li></ul><hr><h3 id="25-Cognito"><a href="#25-Cognito" class="headerlink" title="25. Cognito"></a>25. Cognito</h3><h4 id="AWS-Cognito"><a href="#AWS-Cognito" class="headerlink" title="AWS Cognito"></a>AWS Cognito</h4><ul><li>AWS Cognito 是一种用户身份管理服务, 用于安全地添加用户注册、登录和访问控制功能<ul><li>Cognito User Pools: Sign in for app, integraet with API Gateway &amp; ALB</li><li>Cognito Identity Pools: Integrate with Cognito User Pools as identity provider</li></ul></li><li>CUP + CIP &#x3D; authentication + authorization</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img181012.png"></p><ul><li>Cognito Sync: Enable cross-device syncing of application related user data</li></ul><hr><h4 id="Cognito-User-Pools-CUP"><a href="#Cognito-User-Pools-CUP" class="headerlink" title="Cognito User Pools (CUP)"></a>Cognito User Pools (CUP)</h4><ul><li>与 API Gateway 和 Application Load Balancer 集成 (重要)<ul><li>注意, 是和 ALB 集成, 而不是 CloudFront (重要)</li></ul></li><li>After a successful login using Cognito User Pools, it sends a JWT token (重要)</li><li>Adaptive Authentication<ul><li>Block sign-ins or require MFA if the login appears suspicious (重要)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img181142.png"></p><hr><h4 id="Cognito-Identity-Pools-CIP"><a href="#Cognito-Identity-Pools-CIP" class="headerlink" title="Cognito Identity Pools (CIP)"></a>Cognito Identity Pools (CIP)</h4><ul><li>Get identities for <code>users</code> so they obtain temporary AWS credentials</li><li>如果需要 integrate user-specific file upload and download feature, 使用 IAM policy with AWS Cognito identity prefix to restrict users to use their own folders in S3</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img20555%EF%BC%95.png"></p><hr><h3 id="26-Step-Functions-amp-AppSync"><a href="#26-Step-Functions-amp-AppSync" class="headerlink" title="26. Step Functions &amp; AppSync"></a>26. Step Functions &amp; AppSync</h3><h4 id="AWS-Step-Functions"><a href="#AWS-Step-Functions" class="headerlink" title="AWS Step Functions"></a>AWS Step Functions</h4><ul><li>AWS Step Functions 是一种可视化工作流服务, 用于协调和管理分布式应用程序和微服务</li><li>有两种 Workflows: Standard 和 Express (Express 里有 Sync 和 Async)<ul><li>Standard 适合 long-running, durable, and auditable workflow</li><li>Express 适合 high event rates and short duration workflow</li></ul></li><li>Task States: Do some work in the state machine (比如 invoke Lambda function)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img215042.png"></p><ul><li>Parallel State: Begin parallel branches of execution</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img215355.png"></p><ul><li>A Task state <code>(&quot;Type&quot;: &quot;Task&quot;)</code> represents a single unit of work performed by a state machine (重要)</li></ul><hr><h4 id="Step-Functions-Error-Handling"><a href="#Step-Functions-Error-Handling" class="headerlink" title="Step Functions Error Handling"></a>Step Functions Error Handling</h4><ul><li>Any state can encounter runtime errors for various reasons</li><li>Use <code>Retry</code> and <code>Catch</code> in the State Machine to handle error instead of application code</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img215654.png"></p><hr><h4 id="Step-Functions-Wait-for-Task-Token"><a href="#Step-Functions-Wait-for-Task-Token" class="headerlink" title="Step Functions Wait for Task Token"></a>Step Functions Wait for Task Token</h4><ul><li>Allow to pause Step Functions during a Task until a Task Token is returned</li><li>Append <code>.waitForTaskToken</code> to the Resource field</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img220013.png"></p><hr><h4 id="Step-Functions-Activity-Tasks"><a href="#Step-Functions-Activity-Tasks" class="headerlink" title="Step Functions Activity Tasks"></a>Step Functions Activity Tasks</h4><ul><li>Task performed by an Activity Worker (Acitvity Worker 可以在 EC2, Lambda 上跑)</li><li>After Activity Worker complete its work, it sends a response back to Step Functions</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img220441.png"></p><hr><h4 id="AWS-AppSync"><a href="#AWS-AppSync" class="headerlink" title="AWS AppSync"></a>AWS AppSync</h4><ul><li>AppSync is a managed service that use GraphQL (重要)</li><li>Retrieve data in real-time with WebSocket or MQTT on WebSocket (重要)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img221024.png"></p><hr><h4 id="AWS-Amplify"><a href="#AWS-Amplify" class="headerlink" title="AWS Amplify"></a>AWS Amplify</h4><ul><li>A set of tools to create mobile and web applications (就类似 firebase, 重要)<ul><li>Authentication: leverage AWS Cognito</li><li>Datastore: leverage AWS AppSync and DynamoDB</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img22%EF%BC%96024.png"></p><hr><h3 id="27-Advanced-Identity"><a href="#27-Advanced-Identity" class="headerlink" title="27. Advanced Identity"></a>27. Advanced Identity</h3><h4 id="AWS-STS"><a href="#AWS-STS" class="headerlink" title="AWS STS"></a>AWS STS</h4><ul><li>AWS STS (Security Token Service) 是一种用于临时生成访问密钥以访问 AWS 资源的服务<ul><li>Allow to grant limited and temporary access to AWS up to 1 hour</li></ul></li><li>注意, 遇到 <code>decode-authorization-message</code> 的就是 STS</li><li>STS 的有效期从 15 分钟到 1 小时, 有效期过后需要 renew</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img230636.png"></p><hr><h4 id="Advanced-IAM"><a href="#Advanced-IAM" class="headerlink" title="Advanced IAM"></a>Advanced IAM</h4><ul><li>Evaluation of Policies (重要)<ul><li>先查是不是 Deny, 是就直接 Deny,不是就查是不是 Allow, 是就直接 Allow, 否则直接 Deny</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img231838.png"></p><ul><li>IAM Policies &amp; S3 Bucket Policies<ul><li>需要同时 evaluate IAM 和 S3 的 Polciy, 只要两个里面没有 Deny 就行</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img232221.png"></p><ul><li>Dynamic Policies with IAM (重要)<ul><li>Give IAM policy to a specific user, using <code>$&#123;aws:username&#125; </code>(dynamic variable)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img232539.png"></p><hr><h4 id="IAM-Access-Analyzer"><a href="#IAM-Access-Analyzer" class="headerlink" title="IAM Access Analyzer"></a>IAM Access Analyzer</h4><ul><li>IAM Access Analyzer simplifies inspecting unused access to guide you toward least privilege (重要, 可以 remove 一些不需要的 IAM Roles)</li><li>IAM Access Analyzer also lets you identify unintended access to your resources and data, which is a security risk (减少 security issues)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img012837.png"></p><hr><h4 id="AWS-Directory-Services-AD"><a href="#AWS-Directory-Services-AD" class="headerlink" title="AWS Directory Services (AD)"></a>AWS Directory Services (AD)</h4><ul><li>AWS Directory Services (AD) 是一种托管服务, 用于在 AWS 云中运行 Microsoft Active Directory,简化身份验证和资源管理<ul><li>AWS Managed Microsoft AD: AD in AWS, supports MFA (重要，AD 在 AWS )</li><li>AD Connector: Redirect to on-premise AD, supports MFA (重要, AD 在 on premise)</li><li>Simple AD: AD-compatible managed directory on AWS</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img232910.png"></p><hr><h3 id="28-AWS-Security-amp-Encryption"><a href="#28-AWS-Security-amp-Encryption" class="headerlink" title="28. AWS Security &amp; Encryption"></a>28. AWS Security &amp; Encryption</h3><h4 id="Encryption-101"><a href="#Encryption-101" class="headerlink" title="Encryption 101"></a>Encryption 101</h4><ul><li>Encryption in flight<ul><li>Data is encrypted before sending and decrypted after receive (重要)</li></ul></li><li>Server-side encryption<ul><li>Both encryption and decryption happen on the server (重要)</li></ul></li><li>Client-side encryption<ul><li>Data is encrypted by client and never decrypted by the server (重要)</li></ul></li></ul><blockquote><p>IAM policy to enforce SSL request to objects stored in S3: <code>aws:SecureTransport</code></p></blockquote><hr><h4 id="AWS-KMS"><a href="#AWS-KMS" class="headerlink" title="AWS KMS"></a>AWS KMS</h4><ul><li>Anytime you hear <code>encryption</code> for an AWS service, it’s most likely KMS</li><li>AWS managed encryption keys for us, 比如 EBS, S3, RDS, SSM (不需要自己创建)</li><li>KMS Keys are scoped per Region, Automatic Key Rotation is 1 year</li><li>注意, KMS 并不适合保存 secret, 加密的东西不一定是 secret</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img175137.png"></p><ul><li>Types of KMS Keys (3 种): AWS Owned, AWS Managed, CMK (Custom Managed)<ul><li>KMS stores the CMK and receives data from client, which it encrypt and send back</li></ul></li><li>两种 Key 的形式: Symmetric (Single) &amp; Asymmetric (Public &amp; Private)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img171058.png"></p><ul><li>KMS Key Policies<ul><li>KMS Key Policy 可以用来管理 KMS CMK (重要)</li><li>Custom KMS Key Policy: Define who can access the key (Cross Account Access)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img175606.png"></p><blockquote><p>Deleting an AWS KMS key in AWS Key Management Service (AWS KMS) is destructive and potentially dangerous. Therefore, AWS KMS enforces a waiting period. (Pending state)</p></blockquote><hr><h4 id="KMS-Envelope-Encryption"><a href="#KMS-Envelope-Encryption" class="headerlink" title="KMS Envelope Encryption"></a>KMS Envelope Encryption</h4><ul><li>KMS <code>Encrypt</code> API call has a limit of 4 KB (重要)</li><li>If <code>encrypt &gt; 4 KM</code>, we need to use Envelope Encryption (<code>GenerateDataKey</code> API)</li><li>Envelope Encryption 是 reference data as file within the code</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img175943.png"></p><ul><li>KMS Symmetric API Summary<ul><li><code>Encrypt</code>: encrypt up to 4KB of data through KMS</li><li><code>GenerateDataKey</code>: generates a unique symmetric data key (DEK)</li><li><code>GemerateDataKeyWithoutPlaintext</code>: generate a DEK to use later</li><li><code>Decrypt</code>: decrypt up to 4 KB of data</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img180803.png"></p><hr><h4 id="KMS-Limits"><a href="#KMS-Limits" class="headerlink" title="KMS Limits"></a>KMS Limits</h4><ul><li>KMS Request Quotas: Exceed a request quota, get a <code>ThrottlingException</code></li><li>Request a Requst Quotas increase through API or AWS support</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img184019.png"></p><hr><h4 id="AWS-CloudHSM"><a href="#AWS-CloudHSM" class="headerlink" title="AWS CloudHSM"></a>AWS CloudHSM</h4><ul><li>AWS CloudHSM 是一种托管硬件安全模块服务, 用于安全存储和管理加密密钥<ul><li>We have to manage the encryption keys entirely</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img184859.png"></p><hr><h4 id="SSM-Parameter-Store"><a href="#SSM-Parameter-Store" class="headerlink" title="SSM Parameter Store"></a>SSM Parameter Store</h4><ul><li>SSM Parameter Store 是一种安全的存储服务, 管理配置数据和密钥, 如密码和数据库字符串<ul><li>比起 Secrets Manager 有更广的用途, 比如 URLs, AMI IDs, License keys 等等</li><li>SSM 没有 Automatic key rotation (非常重要)</li></ul></li><li>Have built-in verion tracking (每次 edit secret 都会被记录, 重要)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img173611.png"></p><ul><li>可以将 secret 储存成 SecureString 在 SSM Parameter Store 里 (重要)</li></ul><hr><h4 id="AWS-Secrets-Manager"><a href="#AWS-Secrets-Manager" class="headerlink" title="AWS Secrets Manager"></a>AWS Secrets Manager</h4><ul><li>Store secrets, integrated with RDS &amp; Aurora (非常重要, 存数据库 secrets 的)<ul><li>是给 confidential information (like database credentials, API keys) 用的</li><li>比起 SSM Parameter Store, Secrets Manager 支持 Key 的轮换 (90 天)</li><li>注意, Secrets Manager 的 Key Rotateion 是 90 天, KMS 的 Key Rotateion 是一年</li></ul></li><li>比起 KMS, Secrets Manager 更适合去保存 secret, 比如 database credential, 而且 Secrets Manager 也有 Automatic key rotation</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img185726.png"></p><ul><li>Multi-Region Secrets (和 Multi-Region Key 类似)<ul><li>Replicate Secrets across multiple AWS Regions (disaster recovery)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img174258.png"></p><hr><h4 id="CloudWatch-Logs-Encryption"><a href="#CloudWatch-Logs-Encryption" class="headerlink" title="CloudWatch Logs Encryption"></a>CloudWatch Logs Encryption</h4><ul><li>Encrypt CloudWatch Logs with KMS keys<ul><li>Encryption is enabled at the log group level, by associating a CMK</li></ul></li><li><code>associate-kms-key</code>: if log group already exists (重要, CloudWatch 存在的情况)</li><li><code>create-log-group</code>: if the log group doesn’t exist</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img190545.png"></p><hr><h4 id="AWS-Nitro-Enclaves"><a href="#AWS-Nitro-Enclaves" class="headerlink" title="AWS Nitro Enclaves"></a>AWS Nitro Enclaves</h4><ul><li>Process highly sensitive data in an isolated compute environment</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img190809.png"></p><hr><h3 id="29-Other-AWS-Services"><a href="#29-Other-AWS-Services" class="headerlink" title="29. Other AWS Services"></a>29. Other AWS Services</h3><h4 id="AWS-SES-Simple-Email-Service"><a href="#AWS-SES-Simple-Email-Service" class="headerlink" title="AWS SES (Simple Email Service)"></a>AWS SES (Simple Email Service)</h4><ul><li>Managed service to send email securely (发邮件的)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img004334.png"></p><hr><h4 id="AWS-OpenSearch"><a href="#AWS-OpenSearch" class="headerlink" title="AWS OpenSearch"></a>AWS OpenSearch</h4><ul><li>With OpenSearch, you can search any field, even partially matches<ul><li>原来叫做 ElasticSearch (就是做查询的)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img192053.png"></p><hr><h4 id="AWS-Athena"><a href="#AWS-Athena" class="headerlink" title="AWS Athena"></a>AWS Athena</h4><ul><li>Athena is an query service that analyze data in Amazon S3 using standard SQL<ul><li>Athena 支持 SQL query 去处理 S3 数据的</li><li>Athena cannot be used to analyze data in real time (没办法实时处理数据, 重要)</li></ul></li><li>Use Athena to process logs, perform ad-hoc analysis, and run interactive queries (重要)</li><li>Use columnar data for cost-saving (省钱, less scan)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img192218.png"></p><ul><li>Federated Query<ul><li>Allow to run SQL queries across data stored on AWS or On-Premise</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img200427.png"></p><hr><h4 id="AWS-MSK"><a href="#AWS-MSK" class="headerlink" title="AWS MSK"></a>AWS MSK</h4><ul><li>Managed Apache Kafka on AWS (Have Serverless)<ul><li>Kinesis 的代替 (同样处理 Stream data), 但是针对 Apache Kafka</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img230056.png"></p><hr><h4 id="AWS-Certificate-Manager-ACM"><a href="#AWS-Certificate-Manager-ACM" class="headerlink" title="AWS Certificate Manager (ACM)"></a>AWS Certificate Manager (ACM)</h4><ul><li>AWS Certificate Manager (ACM) 是一种管理 SSL&#x2F;TLS 证书的服务, 用于安全地保护和管理网站和应用程序的通信<ul><li>如果是 third party SSL 就没办法使用 automatic certificate rotation</li></ul></li><li>可以用 EventBridge 来检查 ACM Certificates 是否过期 (过期 Invoke SNS)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img174451.png"></p><hr><h4 id="AWS-Macie"><a href="#AWS-Macie" class="headerlink" title="AWS Macie"></a>AWS Macie</h4><ul><li>Use ML to protect sensitive data (PII) in AWS (用 ML 保护敏感信息)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img192617.png"></p><hr><h4 id="AWS-AppConfig"><a href="#AWS-AppConfig" class="headerlink" title="AWS AppConfig"></a>AWS AppConfig</h4><ul><li>Configurate, validate, and deploy dynamic configurations</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img192722.png"></p><hr><h3 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h3><blockquote><p>请勿随意修改, 谢谢</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Certification </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AWS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AWS SAA-C03</title>
      <link href="/posts/fa4ed4d8.html"/>
      <url>/posts/fa4ed4d8.html</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p>官网: <a href="https://aws.amazon.com/certification/certified-solutions-architect-associate/">https://aws.amazon.com/certification/certified-solutions-architect-associate/</a></p></blockquote><hr><h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><h3 id="1-AWS-Cloud-Overview"><a href="#1-AWS-Cloud-Overview" class="headerlink" title="1. AWS Cloud Overview"></a>1. AWS Cloud Overview</h3><ul><li>Global Services: IAM, Route53, CloudFront, WAF 等等</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img140948.png"></p><h4 id="AWS-Regions"><a href="#AWS-Regions" class="headerlink" title="AWS Regions"></a>AWS Regions</h4><ul><li>A Region is a cluster of data centers</li><li>考虑 Compliance (合规), Proximity (临近用户), Available Services 和 Pricing</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img231130.png"></p><hr><h4 id="AWS-Availability-Zone-AZ"><a href="#AWS-Availability-Zone-AZ" class="headerlink" title="AWS Availability Zone (AZ)"></a>AWS Availability Zone (AZ)</h4><ul><li>一个 Region 可以有 3 - 6 个 AZ (每个 AZ 都是分开的)</li><li>To coordinate Availability Zones across accounts, you must use the AZ ID (注意)<ul><li>A 在 us-west-2a 和 B 在 us-west-2a 是不一样的</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img140727.png"></p><hr><h4 id="AWS-Edge-Locations"><a href="#AWS-Edge-Locations" class="headerlink" title="AWS Edge Locations"></a>AWS Edge Locations</h4><ul><li>Deliver content to user with low latency (离用户越近, deliver 速度越快)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img140903.png"></p><hr><h3 id="2-IAM"><a href="#2-IAM" class="headerlink" title="2. IAM"></a>2. IAM</h3><h4 id="AWS-IAM"><a href="#AWS-IAM" class="headerlink" title="AWS IAM"></a>AWS IAM</h4><ul><li>Root Account: Created by default, 不要和别人分享</li><li>Users: People within the organization</li><li>Groups: Only contain Users, not other Groups (User 可以属于多个 Group)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img145736.png"></p><hr><h4 id="IAM-Permissions"><a href="#IAM-Permissions" class="headerlink" title="IAM Permissions"></a>IAM Permissions</h4><ul><li>定义了 User 或者 Group 的 Permission</li><li>记得遵守 Least Privilege Principle</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img160124.png"></p><hr><h4 id="IAM-Polices"><a href="#IAM-Polices" class="headerlink" title="IAM Polices"></a>IAM Polices</h4><blockquote><p>IAM policies define permissions for an action regardless of the method that you use to perform the operation.</p></blockquote><ul><li>Statements 里面必须包含: Effect, Principal, Action, Resource<ul><li>Inline Policy 是 assign 给个人的</li></ul></li><li>注意, The only resource-based policy IAM support is Trust policy</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img175653.png"></p><hr><h4 id="IAM-MFA"><a href="#IAM-MFA" class="headerlink" title="IAM MFA"></a>IAM MFA</h4><ul><li>Protect Root Accounts and IAM Users</li><li>MFA options: Virtual MFA Device, U2F Sercurity Key (USB)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img180624.png"></p><hr><h4 id="IAM-CLI-amp-SDK"><a href="#IAM-CLI-amp-SDK" class="headerlink" title="IAM CLI &amp; SDK"></a>IAM CLI &amp; SDK</h4><ul><li>可以用 AWS Management Console, AWS CLI, AWS SDK 来访问 AWS</li><li>AWS CLI, AWS SDK 由 Access Keys 保护<ul><li>Set the DeleteOnTermination attribute to False using the command line</li><li>如果考试遇到不会的就选 CLI</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img193342.png"></p><hr><h4 id="IAM-Roles"><a href="#IAM-Roles" class="headerlink" title="IAM Roles"></a>IAM Roles</h4><ul><li>授权 AWS 服务去做某些事 (比如 EB 需要 EC2 Role 和 Service Role)</li><li>常见的 Role: EC2 Instance Role, Lambda Function Role 等等</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img203306.png"></p><hr><h4 id="IAM-Security-Tools"><a href="#IAM-Security-Tools" class="headerlink" title="IAM Security Tools"></a>IAM Security Tools</h4><ul><li>IAM Credentials Report: 返回用户数据和他们的 credentials (凭据)</li><li>IAM Access Advisor: 显示当前用户被授权的服务和使用时间</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img203553.png"></p><hr><h4 id="IAM-Extra"><a href="#IAM-Extra" class="headerlink" title="IAM Extra"></a>IAM Extra</h4><ul><li>Trust Policy (唯一的 resource-based policy)<ul><li>Trust policies define which principal entities can assume the role.</li></ul></li><li>AWS Organizations Service Control Policies (SCP, 针对 Organization 的)<ul><li>SCPs are JSON policies that specify the maximum permissions for an organization or organizational unit (OU)</li></ul></li><li>Access Control List (ACL, 管理别人的 account 的)<ul><li>Access control lists (ACLs) are service policies that allow you to control which principals in another account can access a resource</li></ul></li><li>Permissions Boundary (管理一个 account 最多有什么权限)<ul><li>A permissions boundary is an advanced feature for using a managed policy to set the maximum permissions that an identity-based policy can grant to an IAM entity.</li></ul></li></ul><hr><h3 id="3-EC2-Fundamentals"><a href="#3-EC2-Fundamentals" class="headerlink" title="3. EC2 Fundamentals"></a>3. EC2 Fundamentals</h3><h4 id="AWS-EC2"><a href="#AWS-EC2" class="headerlink" title="AWS EC2"></a>AWS EC2</h4><ul><li>属于 Infrastructure as Service (IaaS) , 绑定 AZ</li><li>User Data: EC2 启动的时候运行的代码 (比如往 EC2 Instance 里面装 Appache)<ul><li>By default, user data runs only during boot cycle when first lauch instance</li><li>By default, scripts entered as user data are executed with root user privileges</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img214749.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img214956.png"></p><ul><li>SSH 到 EC2 Instance 的 public IP (记住, 169, meta-data)<ul><li><a href="http://169.254.169.254/latest/meta-data/public-ipv4">http://169.254.169.254/latest/meta-data/public-ipv4</a></li></ul></li></ul><hr><h4 id="EC2-Instance-Type"><a href="#EC2-Instance-Type" class="headerlink" title="EC2 Instance Type"></a>EC2 Instance Type</h4><ul><li>一共 7 种 EC2 Instance Type, 但 4 种用的最多<ul><li>General Purpose, Compute Optimized, Memory Optimized, Storage Optimized</li></ul></li><li>General Purpose: Balanced (平衡的)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img221846.png"></p><ul><li>Compute Optimized: High performance (处理 Batch, 视频和 HPC)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img221936.png"></p><ul><li>Memory Optimized: Process data in memory (处理 In memory database, cache)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img222020.png"></p><ul><li>Storage Optimized: Read and write data on local storage (OLTP)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img222129.png"></p><hr><h4 id="EC2-Security-Groups"><a href="#EC2-Security-Groups" class="headerlink" title="EC2 Security Groups"></a>EC2 Security Groups</h4><ul><li>Control how traffic is allowed into or out of EC2 instance (类似防火墙)<ul><li>Can be attached to multiple instances (可以复用)</li><li>Locked down to Region &#x2F; VPC</li></ul></li><li>可以作为 Security Group 的 Inbound Rule 有<ul><li>IP address, CIDR block, Security Group</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img222531.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img223020.png"></p><hr><h4 id="EC2-Instance-Purchasing-Options"><a href="#EC2-Instance-Purchasing-Options" class="headerlink" title="EC2 Instance Purchasing Options"></a>EC2 Instance Purchasing Options</h4><ul><li>On-Demand Intances: Short workload, pay by second (短期内紧急使用)</li><li>Reserved: 1 - 3 years (72% discount, reserve capacity in an AZ)<ul><li>Reserved Instance: Long workload (1 - 3 年, discount 随年份增加)</li><li>Convertible Reserved Instances (RI): Long workload with flexible instance (66% discount, 但是可以自由改变 Instance Type)</li></ul></li><li>Saving Plans: 1 - 3 years, commitment to an amount of usage (72% discount, 要定一个使用上限, 超过上限就变成 On-Demand)<ul><li>还有 Compute Saving Plan, 66% discount, work with Lambda and Fargate</li></ul></li><li>Spot Instance: Short workload, can lose instance (最便宜, 90% discount)</li><li>Dedicated Host: The physical server is yours (最贵, 可以控制 how Instance placed)</li><li>Dedicated Instance: Run hardware, but not lockdown to you (服务器大部分是你的)</li><li>Capacity Reservation: Reserve capacity in AZ (比如一天中只有几个小时需要 EC2)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img224149.png"></p><hr><h4 id="EC2-Spot-Instance"><a href="#EC2-Spot-Instance" class="headerlink" title="EC2 Spot Instance"></a>EC2 Spot Instance</h4><ul><li>只能在 open, active 或者 disabled 的状态下 cancel Spot Instance</li><li>需要先 cancel Spot Instance, 然后再 terminate (Cancel 不代表 Terminate)</li><li>Spot Instance 有 one-time 和 persistent 两种 request type</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img225943.png"></p><ul><li>Spot Fleets: Automatically request Spot Instance with lowest price (Spot + On-Demand)<ul><li>拿到最便宜的 Spot Instances</li></ul></li><li>Spot Fleets are set to maintain target capacity (可以保证一定数量的 Instance)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img230258.png"></p><hr><h3 id="4-EC2-SAA-Level"><a href="#4-EC2-SAA-Level" class="headerlink" title="4. EC2 SAA Level"></a>4. EC2 SAA Level</h3><h4 id="Elastic-IP"><a href="#Elastic-IP" class="headerlink" title="Elastic IP"></a>Elastic IP</h4><ul><li>Public IP: Unique across the whole web</li><li>Private IP: Unique across the private network</li><li>Elastic IP: Fixed Public IP for EC2 instance (不会改变)<ul><li>为什么要 Elastic IP, 因为 EC2 的 Public IP 会在重启后改变</li><li>而且 Elastic IP 可以节省 EC2 的开支, Private IP 也可以 (在 private internet 条件下)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img165706.png"></p><hr><h4 id="EC2-Placement-Groups"><a href="#EC2-Placement-Groups" class="headerlink" title="EC2 Placement Groups"></a>EC2 Placement Groups</h4><ul><li>Cluster: Low-latency, single AZ, 网速快但 AZ 可能 fail (处理 HPC)</li><li>Spread: High availability, critical application, 风险小但有限制, 每个 AZ 最多 7 个实例<ul><li>处理 small number of critical instances that need seperate from each other</li></ul></li><li>Partition: Partition instances across many partitions within an AZ, 7 partitions per AZ, up to 100 instances, span multiple region (Big Data, 风险小, 限制低)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img170342.png"></p><ul><li>Cluster: Low-latency, single AZ, 网速快但 AZ 可能 fail (适合 HPC)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img170525.png"></p><ul><li>Spread: High availability, critical application, 风险小但有限制, 每个 AZ 最多 7 个实例</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img170652.png"></p><ul><li>Partition: Spreads instances across many partitions within an AZ, 7 partitions per AZ, up to 100 instances, span multiple region (Big Data, 风险小, 限制低)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img170936.png"></p><hr><h4 id="Elatic-Network-Interfaces-ENI"><a href="#Elatic-Network-Interfaces-ENI" class="headerlink" title="Elatic Network Interfaces (ENI)"></a>Elatic Network Interfaces (ENI)</h4><ul><li>Virtual network card in a VPC</li><li>处理 EC2 Instance failover (故障转移), 绑定 AZ (不可以 attach 到其他 AZ 上)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img182407.png"></p><hr><h4 id="EC2-Hibernate"><a href="#EC2-Hibernate" class="headerlink" title="EC2 Hibernate"></a>EC2 Hibernate</h4><ul><li>EC2 Hibernate: Make EC2 instance boot faster (不是 stoped, 而是 hibernated)</li><li>EC2 Instance Root Volume type must be an EBS volume</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img183846.png"></p><hr><h3 id="5-EC2-Instance-Storage"><a href="#5-EC2-Instance-Storage" class="headerlink" title="5. EC2 Instance Storage"></a>5. EC2 Instance Storage</h3><h4 id="AWS-EBS"><a href="#AWS-EBS" class="headerlink" title="AWS EBS"></a>AWS EBS</h4><ul><li>Block-level storage, 类似 network drive, 绑定 AZ, provisioned capacity<ul><li>By default, Root Volume will be deleted on termination (重要)</li><li>By default, other EBS volume will not be deleted on termination (重要)</li></ul></li><li>可以从一个 EC2 Instance 取下来装到另一个上</li><li>EBS 是绑定 AZ 的 (重要)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img191440.png"></p><hr><h4 id="EBS-Snapshots"><a href="#EBS-Snapshots" class="headerlink" title="EBS Snapshots"></a>EBS Snapshots</h4><ul><li>Make a backup of EBS volume (备份 EBS)</li><li>可以将这个 snapshot 用在其他 AZ 或者 Region 上</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img195715.png"></p><ul><li>EBS Snapchot Archive: 便宜 75%</li><li>Recycle Bin: Setup rules to retain deleted snapshots (可以 recover)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img195833.png"></p><hr><h4 id="AWS-AMI"><a href="#AWS-AMI" class="headerlink" title="AWS AMI"></a>AWS AMI</h4><ul><li>AMI: Amazon Machine Image (Customization of an EC2 Instance)<ul><li>可以更好的管理和启动 EC2 Instance</li></ul></li><li>Built for a specific region and can copy across regions (AMI 跨域复制)</li></ul><blockquote><p>When the new AMI is copied from Region A into Region B, it automatically creates a snapshot in Region B (注意, 跨域 copy AMI 会产生 snapshot)</p></blockquote><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img200249.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img200341.png"></p><hr><h4 id="EC2-Instance-Store"><a href="#EC2-Instance-Store" class="headerlink" title="EC2 Instance Store"></a>EC2 Instance Store</h4><ul><li>Block-level storage, 物理硬盘 (Physical drive, temporary storage)</li><li>High random I&#x2F;O performance, good for cache &amp; buffer at low cost (重要)</li><li>EC2 Instance Store lose when stopped (Ephemeral, 数据在 Instance Store 关闭时消失)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img203146.png"></p><ul><li>You can’t detach an Instance Store volume from one instance and attach it to a different instance</li><li>If you create an Amazon Machine Image (AMI) from an instance, the data on its instance store volumes isn’t preserved</li></ul><hr><h4 id="EBS-Volume-Types"><a href="#EBS-Volume-Types" class="headerlink" title="EBS Volume Types"></a>EBS Volume Types</h4><ul><li>General Purpose (gp2 &#x2F; gp3): Balanced, cost-effective</li><li>Provisioned IOPS (io1 &#x2F; io2): High-performance, support Multi-Attach<ul><li>记住, io 的比 gp 的贵, 但是 io 的 IOPS 也比 gp 高</li></ul></li><li>Hard Disk Drives (HDD): Data intensive (st1) 或者 less frequent access (sc1)<ul><li>HDD 不可以用来创建 EC2</li></ul></li><li>上面这些都没有超过 300,000 IOPS</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img203437.png"></p><hr><h4 id="EBS-Multi-Attach"><a href="#EBS-Multi-Attach" class="headerlink" title="EBS Multi-Attach"></a>EBS Multi-Attach</h4><ul><li>Attach same EBS volume to multiple EC2 instance in same AZ (记住是相同的 AZ)</li><li>Only for io1 &#x2F; io2 family (Provisioned IOPS SSD, 重要)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img203956.png"></p><hr><h4 id="EBS-Encryption"><a href="#EBS-Encryption" class="headerlink" title="EBS Encryption"></a>EBS Encryption</h4><ul><li>EBS Encryption (所有环节都是 encrypted 的)<ul><li>Data at rest is encrypted &amp; Data in flight is encrypted &amp; Snapshot is encrypted</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img204137.png"></p><ul><li>首先 create snapshot, 然后 encrypt snapshot, 然后创建一个新的 EBS Volume (从 encrypted snapshot), 然后将这个 volume 加入到原来的 Instance 上</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img204208.png"></p><hr><h4 id="EBS-RAID"><a href="#EBS-RAID" class="headerlink" title="EBS RAID"></a>EBS RAID</h4><ul><li>RAID 0 (看重 I&#x2F;O performance)<ul><li>Use RAID 0 when I&#x2F;O performance is more important than fault tolerance</li></ul></li><li>RAID 1 (看重 falut tolerance)<ul><li>Use RAID 1 when fault tolerance is more important than I&#x2F;O performance</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/imgpt6-q37-i1.jpg"></p><hr><h4 id="AWS-EFS"><a href="#AWS-EFS" class="headerlink" title="AWS EFS"></a>AWS EFS</h4><ul><li>NFS (Network file system), 可以 mount 到多个 EC2 Instance<ul><li>Scale automatically, no capacity planning</li></ul></li><li>EC2 Instances can access files on an EFS file system across AZs, Regions and VPCs<ul><li>重要, 可以从不同的 AZ, Region, VPC 来 access</li></ul></li><li>可以用 VPC Security Group 或者 IAM Policy 来 control access to EFS</li><li>EFS Infrequent Access (如果遇到 POSIX compliant file storage)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img233415.png"></p><ul><li>NFS 有 2 种 Performance Mode<ul><li>General Purpose: Default (web server)</li><li>Max I&#x2F;O: High latency, throughput, parallel (Big Data, media process, 重要)</li></ul></li><li>NFS 有 3 种 Throughput Mode (重要)<ul><li>Bursting: 很快</li><li>Provisioned: 设置上限 (high throughput, 处理大量文件 migrate 时候使用)</li><li>Elastic: 根据 workload 来 scale</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img233732.png"></p><blockquote><p>EFS 适合存储大型文件, 从价格的角度来看, 存 100 GB 的文件, EBS &gt; EFS &gt; S3 (价格)<br>EFS 并不是永远最贵的, 但 S3 永远是最便宜的</p></blockquote><hr><h3 id="6-ELB-amp-ASG"><a href="#6-ELB-amp-ASG" class="headerlink" title="6. ELB &amp; ASG"></a>6. ELB &amp; ASG</h3><h4 id="Scalability-amp-High-Availability"><a href="#Scalability-amp-High-Availability" class="headerlink" title="Scalability &amp; High Availability"></a>Scalability &amp; High Availability</h4><ul><li>Vertical (竖直) Scale: Increase the size of the Instance (但是有 hardware limit)</li><li>Horizontal (水平) Scale: Increase the number of the Instance</li><li>High Availability: Rrunning application in at least 2 AZ (Disaster recovery, DR, 重要)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img080120.png"></p><hr><h4 id="AWS-ELB"><a href="#AWS-ELB" class="headerlink" title="AWS ELB"></a>AWS ELB</h4><ul><li>Foward traffic to multiple EC2 Instances (流量控制)<ul><li>High Availability across AZs, handle failures of downstream instances</li></ul></li><li>Health Check: 可以知道 EC2 Instance 是否是 Healthy 的<ul><li>ASG 是用 EC2 based health check, ALB 用的是 ALB based health check</li><li>ELB 应该在 public subnet, ASG 应该在 private subnet (重要)</li></ul></li><li>ELB cannot distribute traffic for targets deployed in different region</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img141400.png"></p><ul><li>Application Load Balancer (HTTP &#x2F; HTTPS, Layer 7)</li><li>Network Load Balancer (TCP &#x2F; UDP, Layer 4)<ul><li>NLB provide static DNS and static IP, ALB only provide static DNS</li></ul></li><li>Gateway Load Balancer (Security, Layer 3, 要特别注意)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img090125.png"></p><hr><h4 id="Application-Load-Balancer-ALB"><a href="#Application-Load-Balancer-ALB" class="headerlink" title="Application Load Balancer (ALB)"></a>Application Load Balancer (ALB)</h4><ul><li>Deal with Layer 7 (HTTP &#x2F; HTTPS)</li><li>Route base on Path (&#x2F;Home) or Query (?Platform&#x3D;Mobile)</li><li>ALB adds an additional header called “X-Forwarded-For” contains the client’s IP</li><li>可以 configure ALB to redirect HTTP to HTTPS (重要)</li><li>ALB 无法被 assign Elstaic IP</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img192523.png"></p><ul><li>Routing tables to different target groups<ul><li>Route based on path in URL</li><li>Route based on hostname in URL</li><li>Route based on Query String, Headers, Client IP</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img142631.png"></p><ul><li>ALB Target Groups:<ul><li>EC2 Instance, ECS, Lambda, IP Address</li></ul></li></ul><blockquote><p>To forward all requests to the website so that the requests will use HTTPS, a solutions architect can create a listener rule on the ALB that redirects HTTP traffic to HTTPS.</p></blockquote><hr><h4 id="Network-Load-Balancer-NLB"><a href="#Network-Load-Balancer-NLB" class="headerlink" title="Network Load Balancer (NLB)"></a>Network Load Balancer (NLB)</h4><ul><li>Deal with Layer 4 (TCP &#x2F; UDP), 很快, 处理有大量 request 的情况</li><li>One static IP per AZ or use Elastic IP</li><li>NLB supports HTTP health checks as well as TCP and HTTPS</li><li>注意, NLB best suited for use-cases involving low latency and high throughput workloads, 比如银行, 游戏</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img144359.png"></p><blockquote><p>If you specify targets using an instance ID, traffic is routed to instances using the primary private IP address specified in the primary network interface for the instance.</p></blockquote><hr><h4 id="Gateway-Load-Balancer-GWLB"><a href="#Gateway-Load-Balancer-GWLB" class="headerlink" title="Gateway Load Balancer (GWLB)"></a>Gateway Load Balancer (GWLB)</h4><ul><li>Deal with Layer 3 (Security, 3rd Party)</li><li>GWLB allows perform inline inspection of traffic from multiple spoke VPCs in a simplified and scalable fashion</li><li>Use GENEVE protocol on port 6081</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img223042.png"></p><hr><h4 id="Sticky-Sessions-Session-Affinity"><a href="#Sticky-Sessions-Session-Affinity" class="headerlink" title="Sticky Sessions (Session Affinity)"></a>Sticky Sessions (Session Affinity)</h4><ul><li>Same client is always redirect to the same instance behind a load balancer</li><li>Make sure user doesn’t loss session data (比如用户登录)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img223425.png"></p><ul><li>Application-based Cookies: Don’t use AWSALB, AWSALBAPP, AWSALBTG</li><li>Duration-based Cookies: AWSALB for ALB, AWSELB for CLB</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img223604.png"></p><hr><h4 id="Cross-Zone-Load-Balancing"><a href="#Cross-Zone-Load-Balancing" class="headerlink" title="Cross Zone Load Balancing"></a>Cross Zone Load Balancing</h4><ul><li>ELB distributes traffic evenly across all registered EC2 instances in all AZs<ul><li>所有 Instance 分到的 traffic 一定是一样的</li><li>如果没有 enable, 那么 AZ 内部就是平均分</li></ul></li><li>ALB enabled by default, NLB disabled by default (重要)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img230059.png"></p><hr><h4 id="SSL-Certificates"><a href="#SSL-Certificates" class="headerlink" title="SSL Certificates"></a>SSL Certificates</h4><ul><li>Allow traffic between client and load balancer encrypted in transit (HTTPS)<ul><li>Manage SSL certificates using ACM (AWS Certificate Manager)</li></ul></li><li>如果问到需要管理很多个 SSL 或者 TSL, 选择 SNI (重要)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img230614.png"></p><ul><li>Could be used in ALB &amp; NLB, use SNI to make it work</li><li>SNI: Load multiple SSL certificates onto one web server (Server Name Indication)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img230910.png"></p><hr><h4 id="Connection-Draining"><a href="#Connection-Draining" class="headerlink" title="Connection Draining"></a>Connection Draining</h4><ul><li>Waiting for existing connections to complete</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img231418.png"></p><blockquote><p>Connection Draining enables the load balancer to complete in-flight requests made to instances that are de-registering or unhealthy</p></blockquote><hr><h4 id="AWS-ASG"><a href="#AWS-ASG" class="headerlink" title="AWS ASG"></a>AWS ASG</h4><ul><li>ASG 可以和 ELB 一起用, 来 scale out 或者 in 基于服务器压力 (免费)</li><li>ASG 可以保证最少或最多有多少 EC2 Instance 在工作 (min, max)<ul><li>ASG 是在一个 Region 里面去根据 availiable 的 AZ 进行 scale</li></ul></li><li>当一个 Instance 是 unhealthy 的时候, ASG 会 terminate 这个 Instance<ul><li>ASG 在一个 AZ 里最早 terminate 的是那个最早被 launch 的 Instance</li><li>遇到 unbalanced 的情况, ASG 是先 launch new instance 然后 terminate old instance</li><li>但是在 unhealthy 的情况下是先 terminate unhealth Instance 然后 create new</li></ul></li><li>如果问到在某个节日前去 scale, 那就是 ASG scheduled action</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img232350.png"></p><ul><li>可以和 ELB 一起用, 来 scale out 或者 in 基于服务器压力</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img232615.png"></p><ul><li>Launch Template: 可以作为 template 来生成 EC2 Instance<ul><li>Launch Template 是管要生成什么 Instance 的 (eg. Spot, On-Demand)</li><li>Launch Configuration 是管生成的 Instance 的信息的 (eg. AMI, security group)</li></ul></li><li>如果要更新 Launch Template, 需要删掉旧的然后使用新的 (注意)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img232823.png"></p><ul><li>可以和 CloudWatch Alarm 一起根据服务器压力 scale out 或 scale in</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img232959.png"></p><ul><li>ASG 不 terminate Instance 的情况<ul><li>The health check grace period for the instance has not expired</li><li>The instance maybe in Impaired status</li><li>The instance has failed the Elastic Load Balancing (ELB) health check status</li></ul></li></ul><hr><h4 id="Scaling-Policies"><a href="#Scaling-Policies" class="headerlink" title="Scaling Policies"></a>Scaling Policies</h4><ul><li>Dynamic Scaling<ul><li>Target Tracking Scaling: 根据 CPU 用量或者 SQS 长度来 scale</li><li>Simple &#x2F; Step Scaling: 和 CloudWatch Alarm 关联</li><li>Scheduled Actions: 比如在感恩节那天进行 scale</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img233532.png"></p><ul><li>Predictive Scaling<ul><li>Forecast load and schedule scaling ahead</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img233711.png"></p><hr><h3 id="7-AWS-Fundamentals"><a href="#7-AWS-Fundamentals" class="headerlink" title="7. AWS Fundamentals"></a>7. AWS Fundamentals</h3><h4 id="AWS-RDS"><a href="#AWS-RDS" class="headerlink" title="AWS RDS"></a>AWS RDS</h4><ul><li>使用 RDS 的好处 (对比将数据库存在 EC2 上)<ul><li>Automated provisioning, auto-scaling, backup</li><li>Read Replicas (最多 15 个) 和 Multi-AZ</li></ul></li><li>RDS RIs: 类似 EC2 RIs</li><li>RDS Read Replica: If master database is encrypted, the replica is also encrypted<ul><li>注意, Read Replica 提高的是 read, 而不是 scale 数据库的 storage (而且 Replica 贵), 处理类似 report 或者 analytics 的就是 Read Replica</li><li>Read Replica 不是提高 High Availability, Multi-AZ 才是</li><li>Cross-Region Read Replica: 当 disaster 发生, 可以作为 DB backup</li></ul></li><li>RDS Multi-AZ: RDS create a primary DB Instance and synchronously replicates the data to a standby instance in a different AZ (High Availability)<ul><li>RDS Multi-AZ update 是 standby 和 primary 一起 update (会有 downtime)</li></ul></li><li>Support MySQL, PostgreSQL, MariaDB, Oracle, MS SQL Server, and Amazon Aurora</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img161720.png"></p><ul><li>Storage Auto Scaling (自动 scale)<ul><li>For application with unpredictable workloads</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img161952.png"></p><ul><li>Disaster Recovery<ul><li>Create a Read Replica in different region and enable Multi-AZ on Read Replica</li></ul></li><li>IAM Database Authentication: 可以用来访问 RDS</li><li>可以从 RDS Read Replica 迁移到 Aurora Read Replica, 这个做法可以 minimal change</li></ul><hr><h4 id="Read-Replicas-vs-Multi-AZ"><a href="#Read-Replicas-vs-Multi-AZ" class="headerlink" title="Read Replicas vs. Multi AZ"></a>Read Replicas vs. Multi AZ</h4><ul><li>Read Replicas: Scalability, Async Replication<ul><li>Within AZ, Cross AZ or Cross Region</li></ul></li><li>Read Replicas in Same Region is free (Replication in AZs), Cross Region is not free</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img173522.png"></p><ul><li>用 Production databse 处理日常, 用 Read Replica 来建一个副本处理数据分析</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img173820.png"></p><ul><li>Multi AZ: High Availability, Disaster Recovery, Sync Replication<ul><li>在 Multi-AZ 的情况下, 当 RDS 数据库 goes down, CNAME 会更新指向 standby</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img174148.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img174357.png"></p><hr><h4 id="RDS-Custom"><a href="#RDS-Custom" class="headerlink" title="RDS Custom"></a>RDS Custom</h4><ul><li>Could access the underlying database and OS<ul><li>只有 Oracle 和 Microsoft SQL Server 可以</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img174702.png"></p><hr><h4 id="AWS-Aurora"><a href="#AWS-Aurora" class="headerlink" title="AWS Aurora"></a>AWS Aurora</h4><ul><li>Support PostgreSQL and MySQL (不需要管理 storage)</li><li>Aurora 没有 standby database, Aurora Replica 可以作为 failover target</li><li>一般来说, Aurora 比 RDS 快</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img183915.png"></p><ul><li>High Availiability &amp; Read Scaling (Aurora Read Replica)<ul><li>One Master Write, Multiple Read Replicas (Up to 15 Replica), 一共 16 个</li><li>如果问到和 Aurora 有关, 且关于处理网络请求激增的问题, 选 Aurora Replica</li><li>Replica Tier 越高, failover 时被 promote</li></ul></li><li>如果问到关于 Aurora 的 Auto-Scaling, 那就是 Aurora Serverless</li><li>如果问到 Aurora 而且是 test database, 选择 Aurora Database Cloning</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img184105.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img184221.png"></p><hr><h4 id="Aurora-Advanced"><a href="#Aurora-Advanced" class="headerlink" title="Aurora Advanced"></a>Aurora Advanced</h4><ul><li>Aurora Replicas Auto Scaling: 和 EC2 的 Auto Scaling 类似</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img184516.png"></p><ul><li>Aurora Custom Endpoints: 可以在上面跑数据分析</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img184559.png"></p><ul><li>Aurora Serverless: Automated database instantiation and auto scaling (重要)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img184700.png"></p><ul><li>Aurora Global: Cross Region replication takes less than 1 second<ul><li>同时保证至少有一个 Replica 可以用 (重要)</li><li>Designed for globally distributed application, with fast local reads with low latency</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img184847.png"></p><ul><li>Aurora Machine Learning: ML prediction</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img184942.png"></p><ul><li>Aurora Database Cloning<ul><li>可以快速 access Aurora DB, 比 snapshot &amp; retore 快</li><li>当需要制作 test database 的时候选 Aurora Database Cloning</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img185556.png"></p><hr><h4 id="Backup-amp-Monitoring"><a href="#Backup-amp-Monitoring" class="headerlink" title="Backup &amp; Monitoring"></a>Backup &amp; Monitoring</h4><ul><li>RDS Backups (有两种)<ul><li>Automated backups: 每天自动 backup</li><li>Manual DB Snapshots: 手动 backup</li></ul></li><li>注意, 如果是为了省钱, 可以在用完数据库后制作数据库 snapshot, 然后 terminate 数据库, 在需要的时候再把数据库 snapshot restore 回去</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img185223.png"></p><ul><li>Aurora Backups (和上面一样)<ul><li>Automated backups: 每天自动 backup</li><li>Manual DB Snapshots: 手动 backup</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img185353.png"></p><ul><li>RDS &amp; Aurora Restore options<ul><li>最基本的就是用 snapshot 来 restore</li><li>如果是从 On-Premise, 可以做一个 backup 然后存到 S3, 再从 S3 来 restore</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img185459.png"></p><hr><h4 id="RDS-Security"><a href="#RDS-Security" class="headerlink" title="RDS Security"></a>RDS Security</h4><ul><li>At-rest encryption: AWS KMS (Key Management Service)</li><li>In-flight encryption: AWS TLS Certificates</li><li>IAM Authentication: IAM roles to connect to database</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img133048.png"></p><hr><h4 id="RDS-Proxy"><a href="#RDS-Proxy" class="headerlink" title="RDS Proxy"></a>RDS Proxy</h4><ul><li>Have a proxy for access RDS or Aurora, 缓解数据库压力, minimize open connections<ul><li>Allow apps to pool and share DB connections (提高 DB efficiency)</li><li>Reduced RDS &amp; Aurora failover time by up 66%</li><li>No code change (重要)</li></ul></li><li>Serverless, auto scaling, Highly Avaliable (Multi-AZ)</li><li>Not publicly accessible (Need to use VPC)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img184531.png"></p><hr><h4 id="AWS-ElastiCache"><a href="#AWS-ElastiCache" class="headerlink" title="AWS ElastiCache"></a>AWS ElastiCache</h4><ul><li>Manage Redis or Memcached (ElastiCache 解决的是数据库高频读取的问题, 重要)<ul><li>ElastiCache 也是 in-memory data store, 而且支持 SQL query caching</li></ul></li><li>Cache are in-memory database with high performance and low latency (compute-intensive)</li><li>Cache helps reduce load off of database for read intensive workload (read heavy)</li><li>Help to make application stateless (AWS 负责大部分工作)</li><li>处理 S3 的是 CloudFront, 而不是 ElastiCache (记住)</li><li>支持 multi-threading 的是 ElastiCache for Memcached</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img184841.png"></p><ul><li>DB Cache: Get data from ElastiCache<ul><li>If not avaliable, get from RDS and store in ElastiCache</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img185024.png"></p><ul><li>User Session: Write Session data into ElastiCache<ul><li>User in another instance could still be logged in</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img185153.png"></p><ul><li>Redis vs Memcahed<ul><li>Redis: Read Replicas, High Availiablity, Backup and restore (非常重要)</li><li>Memcached: Not High Availiablity, No Backup, Have Risk to Lose Data, Multi-threaded</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img185310.png"></p><hr><h4 id="ElastiCache-SAA"><a href="#ElastiCache-SAA" class="headerlink" title="ElastiCache SAA"></a>ElastiCache SAA</h4><ul><li>ElastiCache supports IAM Authentication for Redis</li><li>Memcached supports SASL-based authentication</li><li>IAM Database Authentication does not support Oracle</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img200638.png"></p><ul><li>Patterns for ElastiCache<ul><li>Lazy Loading, Write Through, Session Store</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img200822.png"></p><ul><li>ElastiCache Use Case<ul><li>Gaming Leaderboards (用 Redis 的 Sorted Sets, 重要)</li><li>Manage and store session data</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img200907.png"></p><hr><h3 id="8-Route-53"><a href="#8-Route-53" class="headerlink" title="8. Route 53"></a>8. Route 53</h3><h4 id="What’s-DNS"><a href="#What’s-DNS" class="headerlink" title="What’s DNS"></a>What’s DNS</h4><ul><li>Translate hostname into IP address<ul><li><a href="http://www.google.com/">www.google.com</a> &#x3D; 172.217.18.36</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img213136.png"></p><hr><h4 id="AWS-Route-53"><a href="#AWS-Route-53" class="headerlink" title="AWS Route 53"></a>AWS Route 53</h4><ul><li>User can update the DNS records (High available, scalable)</li><li>Route 53 is a Domain Registrar</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img213527.png"></p><ul><li>Route 53 Records:<ul><li>Domain Name, Record Type, Value, Routing Policy, TTL</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img213613.png"></p><ul><li>Route 53 Record Types<ul><li>A: IPv4</li><li>AAAA: IPv6</li><li>CNAME: Map hostname to another hostname</li><li>NS: Name Servers for the Hosted Zone</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img213753.png"></p><ul><li>Route 53: Hosted Zones<ul><li>Public Hosted Zones: Public domain name</li><li>Private Hosted Zones: Private domain name (VPC)</li></ul></li></ul><blockquote><p>注意, DNS hostnames and DNS resolution are required settings for private hosted zones</p></blockquote><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img234126.png"></p><ul><li>GoDaddy + Route 53 (As DNS Service Provider)<ul><li>Create a Public Hosted Zone and update the 3rd party Registrar NS records</li></ul></li><li>Route 53 Health Check<ul><li>如果 ELB 出问题, 就去找 Route 53 Health Check</li></ul></li></ul><hr><h4 id="Route-53-TTL"><a href="#Route-53-TTL" class="headerlink" title="Route 53 TTL"></a>Route 53 TTL</h4><ul><li>TTL: Time To Live (生存时间)<ul><li>How long the value should be cached (后端更新不代表 cache 更新了)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img232659.png"></p><hr><h4 id="CNAME-vs-Alias"><a href="#CNAME-vs-Alias" class="headerlink" title="CNAME vs Alias"></a>CNAME vs Alias</h4><ul><li>CNAME: Point a hostname to another hostname<ul><li>从 acme.example.com 到 zenith.example.org 或者 example.com 到 example.net</li></ul></li><li>Alias: Point a hostname to an AWS Resource (对象是 CloudFront, S3 这些)<ul><li>从 covid19survey.com 到 <a href="http://www.covid19survey.com/">www.covid19survey.com</a></li><li>从 app.mydomain.com 到 app.amazonaws.com</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img233313.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img233425.png"></p><hr><h4 id="Health-Checks"><a href="#Health-Checks" class="headerlink" title="Health Checks"></a>Health Checks</h4><ul><li>Health Checks are only for public resources</li><li>Health Check 检测: Endpoints, 其他 Health Checks, CloudWatch Alarms</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img000106.png"></p><hr><h4 id="Routing-Policy-Simple"><a href="#Routing-Policy-Simple" class="headerlink" title="Routing Policy (Simple)"></a>Routing Policy (Simple)</h4><ul><li>Define how Route 53 responds to DNS queries</li><li>一共 7 种 Routing Policies</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img234623.png"></p><ul><li>Simple: Route traffic to a single resource<ul><li>If multiple values returned, a random one is chosen by client</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img234350.png"></p><hr><h4 id="Routing-Policy-Weighted"><a href="#Routing-Policy-Weighted" class="headerlink" title="Routing Policy (Weighted)"></a>Routing Policy (Weighted)</h4><ul><li>Weighted: Control the % of the request go to each resource</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img234856.png"></p><hr><h4 id="Routing-Policy-Latency"><a href="#Routing-Policy-Latency" class="headerlink" title="Routing Policy (Latency)"></a>Routing Policy (Latency)</h4><ul><li>Latency: Redirect to the resource that has the least latency close to us</li><li>Latency is based on traffic between users and AWS Regions</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img235654.png"></p><hr><h4 id="Routing-Policy-Failover"><a href="#Routing-Policy-Failover" class="headerlink" title="Routing Policy (Failover)"></a>Routing Policy (Failover)</h4><ul><li>Failover: Have a Primary Instance and a Secondary Instance (重要)<ul><li>When failover, switch to Secondary Instance</li></ul></li><li>注意, 当问到 failover 的时候, 选择的是 active-passive failover routing policy<ul><li>没有什么 active-active, 只有 active-passive</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img150940.png"></p><hr><h4 id="Routing-Policy-Geolocation"><a href="#Routing-Policy-Geolocation" class="headerlink" title="Routing Policy (Geolocation)"></a>Routing Policy (Geolocation)</h4><ul><li>Geolocation: Routing based on user location<ul><li>Need to create a “Default” record</li><li>Use cases: website localization, restrict content distribution 等等</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img151650.png"></p><hr><h4 id="Routing-Policy-Geoproximity"><a href="#Routing-Policy-Geoproximity" class="headerlink" title="Routing Policy (Geoproximity)"></a>Routing Policy (Geoproximity)</h4><ul><li>Geoproximity: Route traffic to resource based on geolocation<ul><li>But have the ability to shift more traffic to resource based on bias (重要)</li><li>可以做到 route more traffic or less</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img152310.png"></p><hr><h4 id="Routing-Policy-IP-Based"><a href="#Routing-Policy-IP-Based" class="headerlink" title="Routing Policy (IP-Based)"></a>Routing Policy (IP-Based)</h4><ul><li>IP-Based: Routing based on client’s IP address<ul><li>Provide a list of CIDRs for your client</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img153711.png"></p><hr><h4 id="Routing-Policy-Multi-Value"><a href="#Routing-Policy-Multi-Value" class="headerlink" title="Routing Policy (Multi-Value)"></a>Routing Policy (Multi-Value)</h4><ul><li>Multi-Value: Route traffic to multiple resources<ul><li>Not a subsitute for ELB</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img153842.png"></p><hr><h3 id="9-Beanstalk"><a href="#9-Beanstalk" class="headerlink" title="9. Beanstalk"></a>9. Beanstalk</h3><h4 id="Instantiate-App"><a href="#Instantiate-App" class="headerlink" title="Instantiate App"></a>Instantiate App</h4><ul><li>EC2 Instance<ul><li>Golden AMI: Install all applications beforehand and launch EC2 Instance</li><li>User Data: Dynamic configuration (记住是 dynamic)</li></ul></li><li>RDS Database: Restore from a snapshot (Data &amp; Schema ready)</li><li>EBS Volume: Restore from a snapshot</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img173401.png"></p><hr><h4 id="Elastic-Beanstalk"><a href="#Elastic-Beanstalk" class="headerlink" title="Elastic Beanstalk"></a>Elastic Beanstalk</h4><ul><li>只需要负责 Code, 其他都由 AWS 负责</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img210323.png"></p><ul><li>Web Server Tier vs. Worker Tier<ul><li>一个管 Web Server, 另一个处理 Process (SQS, SNS 等等)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img210711.png"></p><hr><h3 id="10-AWS-S3"><a href="#10-AWS-S3" class="headerlink" title="10. AWS S3"></a>10. AWS S3</h3><h4 id="AWS-S3"><a href="#AWS-S3" class="headerlink" title="AWS S3"></a>AWS S3</h4><ul><li>S3 Buckets (S3 是 Global 的, 但是 Bucket 是 Regional 的)<ul><li>Store objects (files) in “buckets”</li><li>Buckets must have globally unique name (名字必须独特)</li><li>Buckets are defined at region level</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img171839.png"></p><ul><li>Objects (files) have a key, max object size is 5TB</li><li>The key is the FULL path (prefix + object name)</li><li>如果上传超过 5 GB, 就要用 Multi-Part Upload (还有 S3 Transfer Acceleration)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img172025.png"></p><ul><li>S3 sync command: Uses the CopyObject APIs to copy objects between S3 buckets</li><li>S3 always return the lastest version of the object (重要)</li><li>S3 没办法加密 metadata</li><li>S3 是 serverless 的</li><li>如果遇到需要处理 static content 的, 就一定是 S3 + CloudFront (重要)</li><li>如果问到 S3 而且是关于图片上传, 选择 S3 Event Notification, 不是 EventBridge (重要)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/imglifecycle-transitions-v2.png"></p><ul><li>如果发现 S3 的传输功能出问题, 那么就给 S3 bucket 加上 prefix</li><li>注意, S3 和 Database 是不沾边的, S3 不是数据库</li></ul><blockquote><p>By default, an Amazon S3 object is owned by the AWS account that uploaded it. This is true even when the bucket is owned by another account (重要)</p></blockquote><ul><li>Host 在 S3 上面的网站一般是以下两种后缀 (dash Region 或者 dot Region)<ul><li>s3-website dash (-) Region ‐ <a href="http://bucket-name.s3-website.region.amazonaws.com/">http://bucket-name.s3-website.Region.amazonaws.com</a></li><li>s3-website dot (.) Region ‐ <a href="http://bucket-name.s3-website-region.amazonaws.com/">http://bucket-name.s3-website-Region.amazonaws.com</a></li></ul></li></ul><hr><h4 id="S3-Bucket-Policy"><a href="#S3-Bucket-Policy" class="headerlink" title="S3 Bucket Policy"></a>S3 Bucket Policy</h4><ul><li>User-Based Security<ul><li>IAM Policies: Which API calls should be allowed for a user from IAM (重要)</li></ul></li><li>Resource-Based Security<ul><li>Bucket Policies: Bucket rules (比如让 Object public, 重要)</li><li>Object Access Control List (ACL)</li><li>Bucket Access Control List (ACL)</li></ul></li><li>Encryption: Encrypt objects in S3 with encryption keys</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img173050.png"></p><ul><li>S3 Bucket Policies (JSON based policies)<ul><li>Resoruces: buckets and objects</li><li>Effect: Allow &#x2F; Deny</li><li>Actions: API to Allow or Deny</li><li>Principal: The account or user to apply the policy to</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img173325.png"></p><hr><h4 id="S3-Versioning"><a href="#S3-Versioning" class="headerlink" title="S3 Versioning"></a>S3 Versioning</h4><ul><li>Enabled at the bucket level (Default is null)</li><li>Best pratice to version the buckets (可以 roll back, 可以防止误删, 重要)<ul><li>可以防止 accidental deletion of objects</li></ul></li><li>Once version-enable a bucket, it can never return to an unversioned state (重要)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img174246.png"></p><hr><h4 id="S3-Replication-CRR-amp-SRR"><a href="#S3-Replication-CRR-amp-SRR" class="headerlink" title="S3 Replication (CRR &amp; SRR)"></a>S3 Replication (CRR &amp; SRR)</h4><ul><li>CRR: Cross Region Replication (compliance, lower latency access)</li><li>SRR: Same Region Replication (create test environment)<ul><li>Must enable Versioning</li><li>The Copying is asynchronous</li><li>Must give IAM permissions to S3</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img174840.png"></p><ul><li>Only new objects are replicated, existing objects need S3 Batch Replication<ul><li>也就是说只有新的 object 会被 Replicate, 老的 object 要 S3 Batch Replication</li></ul></li><li>No “chaining” in replication<ul><li>比如把 A 复制到 B 和 C, 需要 A 复制到 B 和 A 复制到 C</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img175004.png"></p><hr><h4 id="S3-Storage-Classes"><a href="#S3-Storage-Classes" class="headerlink" title="S3 Storage Classes"></a>S3 Storage Classes</h4><ul><li>一共 7 种 Storage Class: General + 2 IA + 3 Glacier + Intelligent</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img175742.png"></p><ul><li>S3 Standard - General Purpose<ul><li>Used for frequently accessed data (最常见)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img175932.png"></p><ul><li>S3 Infrequent Access (Standard IA &amp; One Zone IA)<ul><li>For data is less frequent access but require rapid access when needed (重要)</li><li>Lower cost than Standard</li><li>从 Standard 转到 One Zone IA 最少要 30 天</li><li>One Zone IA 不是 High Availability 的选择 (注意, 因为 AZ 会 down)</li><li>如果遇到 access is always required 就不能选 One Zone IA, 因为 AZ 可能会 down</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img180147.png"></p><ul><li>S3 Glacier Storage Classes (Archive 专用)<ul><li>Low-cost object storage for archiving &#x2F; backup</li><li>Price: storage + retrieval</li><li>S3 Glacier Instant Retrieval: Glacier 里最快但也最贵</li><li>S3 Glacier Flexible Retrieval: 三种模式 (Expedited 加急, Standard, Bulk 批量)</li><li>S3 Glacier Deep Archive: 存的时间最久, 两种模式 (Standard, Bulk), 48 小时 retrieval</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img180642.png"></p><ul><li>S3 Intelligent Tiering<ul><li>Move objects automatically between Access Tiers based on usage</li><li>就是自动帮你把 Object 移到不同的 Storage Class 里</li><li>Intelligent Tier 是在 Standard 和 Standard IA 下面的, 不能从下往上转移</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img180806.png"></p><hr><h3 id="11-AWS-S3-Advance"><a href="#11-AWS-S3-Advance" class="headerlink" title="11. AWS S3 Advance"></a>11. AWS S3 Advance</h3><h4 id="S3-Lifecycle-Rules"><a href="#S3-Lifecycle-Rules" class="headerlink" title="S3 Lifecycle Rules"></a>S3 Lifecycle Rules</h4><ul><li>Transition objects between storage classes (比如从 IA 到 Glacier)<ul><li>Transition 需要 Lifecycle Rules (重要)</li></ul></li><li>比如从 Snowball 到 Glacier 就需要 Lifecycle Rule</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img235516.png"></p><ul><li>Transition Actions: Configure objects to transition to another storage class (转移)</li><li>Expiration Actions: Configure objects to expire after some time (删除)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img235639.png"></p><ul><li>S3 Analytics: Help decide when to transition objects to the right storage class</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img000151.png"></p><hr><h4 id="S3-Requester-Pays"><a href="#S3-Requester-Pays" class="headerlink" title="S3 Requester Pays"></a>S3 Requester Pays</h4><ul><li>The requester pays the cost of the request intead of the bucket owner<ul><li>反而是用户付钱, 但是用户得是 AWS 用户</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img000532.png"></p><hr><h4 id="S3-Event-Notifications"><a href="#S3-Event-Notifications" class="headerlink" title="S3 Event Notifications"></a>S3 Event Notifications</h4><ul><li>Automatically react to certain event happened in S3 (比如图片上传)<ul><li>Need to have IAM Permissions</li><li>S3 Event Notification 的 destination 是 SQS, SNS, Lambda (记住)</li></ul></li><li>大部分和 S3 事件相关的都是 S3 Event Notification, 而不是 EventBridge (重要)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img000725.png"></p><hr><h4 id="S3-Performance"><a href="#S3-Performance" class="headerlink" title="S3 Performance"></a>S3 Performance</h4><ul><li>For Upload 上传 (重要)<ul><li>Multi-Part Upload: 当上传文件大于 5 GB, 可以 parallelize uploads</li><li>S3 Transfer Acceleration: 将文件传到 AWS edge location, 可以和 Multi-Part 一起用</li><li>S3 Transfer Acceleration (S3TA) can speed up content transfers to and from S3 (针对关于 S3 的上传和下载)</li><li>注意, S3 Transfer Acceleration 没办法 copy object between buckets</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img001645.png"></p><ul><li>For Download 下载<ul><li>S3 Byte-Range Fetches: Parallelize GETs, retrieve partial data (拿部分数据, 重要)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img001828.png"></p><hr><h4 id="S3-Select-amp-Glacier-Select"><a href="#S3-Select-amp-Glacier-Select" class="headerlink" title="S3 Select &amp; Glacier Select"></a>S3 Select &amp; Glacier Select</h4><ul><li>S3 Select 使用 SQL 来做 server-side filtering, 过滤从而减少数据量</li><li>400% Faster, 80% Cheaper (性能优化)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img002050.png"></p><hr><h4 id="S3-Batch-Operations"><a href="#S3-Batch-Operations" class="headerlink" title="S3 Batch Operations"></a>S3 Batch Operations</h4><ul><li>Perform bulk operations (批量操作) on existing S3 objects<ul><li>例如 encrypt all un-encrypted objects (加密所有没有加密的文件)</li></ul></li><li>在处理 Batch 之前, 用 S3 Inventory to get object list and use S3 Select to filter objects</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img022334.png"></p><hr><h3 id="12-AWS-S3-Security"><a href="#12-AWS-S3-Security" class="headerlink" title="12. AWS S3 Security"></a>12. AWS S3 Security</h3><h4 id="S3-Encryption"><a href="#S3-Encryption" class="headerlink" title="S3 Encryption"></a>S3 Encryption</h4><ul><li>一共有 4 种方法 (SSE-S3 免费, SSE-KMS 要钱)<ul><li>Server-Side Encryption (SSE-S3, SSE-KMS, SSE-C)</li><li>Client-Side Encryption (如果用户已经有 encryption method)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img223133.png"></p><ul><li>Server-Side Encryption with Amazon S3-Managed Keys (SSE-S3)<ul><li>Enabled by default for new buckets &amp; objects</li><li>SSE-S3 的 header 是 x-amz-server-side-encryption</li><li>使用 SSE-S3, 每一个 Object 都是由 unique key 来 encrypt 的</li><li>SSE-S3 使用 256-bit Advanced Encryption Standard (AES-256)</li><li>SSE-S3 是没有 automatic key rotation 的, 要用 SSE-KMS (重要)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img223242.png"></p><ul><li>Server-Side Encryption with KMS Keys stored in AWS KMS (SSE-KMS)<ul><li>User control + audit key usage in CloudTrail (可以管理 key rotation)</li><li>SSE-KMS 的 header 是 x-amz-server-side-encryption + aws:kms</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img223417.png"></p><ul><li>Server-Side Encryption with Customer-Provided Keys (SSE-C)<ul><li>用户自己有 keys, AWS will not store the key, HTTPS must be used</li><li>当问题中提到用户需要使用自己的 key, 但是打算在 AWS 端做 encryption</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img223602.png"></p><ul><li>Client-Side Encryption<ul><li>User fully manages the keys and encryption cycle</li><li>数据在送到 AWS 之前就是加密好的</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img223715.png"></p><ul><li>Encryption in Transit (SSL&#x2F;TLS)<ul><li>可以用 aws:SecureTransport 来 enforce (不过有 SSL 基本上就是 HTTPS)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img223811.png"></p><hr><h4 id="S3-CORS"><a href="#S3-CORS" class="headerlink" title="S3 CORS"></a>S3 CORS</h4><ul><li>CORS: Cross-Origin Resource Sharing (跨域问题)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img224630.png"></p><ul><li>S3 CORS (重要)<ul><li>A client makes a cross-origin request on S3 bucket, need the correct CORS headers</li><li>Can allow specific origin or *</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img224951.png"></p><hr><h4 id="S3-MFA-Delete"><a href="#S3-MFA-Delete" class="headerlink" title="S3 MFA Delete"></a>S3 MFA Delete</h4><ul><li>MFA Delete: 防止不小心删除文件, 用户需要先验证身份 (重要)<ul><li>To use MFA Delete: Versioning must be enabled</li></ul></li><li>Only the bucket owner (root user) can enable&#x2F;disable MFA Delete (重要)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img225415.png"></p><hr><h4 id="S3-Access-Logs"><a href="#S3-Access-Logs" class="headerlink" title="S3 Access Logs"></a>S3 Access Logs</h4><ul><li>Any request made to S3 will be logged to another S3 bucket (数据分析)<ul><li>可以作为 Data Analysis 的工具</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img230251.png"></p><hr><h4 id="S3-Pre-signed-URLs"><a href="#S3-Pre-signed-URLs" class="headerlink" title="S3 Pre-signed URLs"></a>S3 Pre-signed URLs</h4><ul><li>Have URL expiration (过期)<ul><li>用在 Private Bucket 上, 一段时间后 URL 过期</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img230702.png"></p><hr><h4 id="Glacier-Vault-Lock-amp-S3-Object-Lock"><a href="#Glacier-Vault-Lock-amp-S3-Object-Lock" class="headerlink" title="Glacier Vault Lock &amp; S3 Object Lock"></a>Glacier Vault Lock &amp; S3 Object Lock</h4><ul><li>S3 Glacier Vault Lock<ul><li>Adopt a WORM (Write Once Read Many), 信息一旦写入就无法修改</li><li>The object can’t be deleted (无法修改)</li></ul></li><li>可以用 Glacier Vault Lock 储存 sensitive 数据, 然后用 Vault Lock Policy 去管理</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img230941.png"></p><ul><li>S3 Object Lock (Must have Versioning, 重要)<ul><li>Block an object version deletion for an amount of time (有时限)</li><li>两个 Retention mode (重要)<ul><li>Compliance: 所有人都没法删, Root user 也不行</li><li>Governance: 有些人可以删, 有权限的人可以</li></ul></li><li>Legal Hold: 防止 Object Version 被改, 除非你自己把 Legal Hold 移除 (重要)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img231203.png"></p><hr><h4 id="S3-Access-Points"><a href="#S3-Access-Points" class="headerlink" title="S3 Access Points"></a>S3 Access Points</h4><ul><li>Access Points simplify security management for S3 Buckets (根据用户属性)</li><li>Each Access Point: DNS name + Access Point Policy</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img231500.png"></p><hr><h4 id="S3-Object-Lambda"><a href="#S3-Object-Lambda" class="headerlink" title="S3 Object Lambda"></a>S3 Object Lambda</h4><ul><li>Use AWS Lambda to change object before retrieve by caller (在到达 caller 之前)<ul><li>用途: 可以给图片打水印</li></ul></li><li>需要 S3 Access Point 和 S3 Object Lambda Access Points</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img231810.png"></p><hr><h3 id="13-CloudFront-amp-AWS-Global-Accelerator"><a href="#13-CloudFront-amp-AWS-Global-Accelerator" class="headerlink" title="13. CloudFront &amp; AWS Global Accelerator"></a>13. CloudFront &amp; AWS Global Accelerator</h3><h4 id="AWS-CloudFront"><a href="#AWS-CloudFront" class="headerlink" title="AWS CloudFront"></a>AWS CloudFront</h4><ul><li>Content Delivery Network (CDN), 可以 serve static &amp; dynamic content<ul><li>Improve read performance, content is cached at the edge</li></ul></li><li>可以防止 DDoS protection (搭配 AWS Shield), 可以根据 content type 来 route, 可以指定 primary &amp; secondary origins 来做 High Availiability &amp; Failover</li><li>CloudFront Origins: S3 Bucket (OAC) 或者 Custom Origin (HTTP)<ul><li>OAC: Origin Access Control (重要, 如果涉及到 S3 的问题)</li></ul></li><li>如果问到 CloudFront 而且需要 encryption, 选择 field level encryption (不是 KMS)<ul><li>Field-level encryption allows you to enable your users to securely upload sensitive information to your web servers.</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img232701.png"></p><ul><li>CloudFront vs S3 Cross Region Replication<ul><li>CloudFront: 使用 global edge network, 有 TTL, 用于 static content</li><li>S3 Cross Region Replication (CRR): 每个 Region 都要设置, 但是没有 TTL, 用于 dynamic content (updated in near real-time, 只读)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img233016.png"></p><ul><li>Price Classes: 不同地区的价格不一样<ul><li>可以用来 cost reduction (降低价格)</li></ul></li><li>CloudFront 允许 Proxy methods 和 Dynamic content 跳过 regional edge cache</li><li>除了 WAF 可以去 block IP, 还可以使用 OAI (origin access identity, 重要)<ul><li>OAI 也可以用来 secure communication between CloudFront &amp; S3</li></ul></li><li>可以用 CloudFront signed URLs 和 CloudFront signed cookies 来 restrict access to documents (比如 subscription)</li><li>Can configure CloudFront to require HTTPS from clients (可以用 CloudFront 要求 client 必须使用 HTTPS)</li></ul><hr><h4 id="CloudFront-Geo-Restriction"><a href="#CloudFront-Geo-Restriction" class="headerlink" title="CloudFront Geo Restriction"></a>CloudFront Geo Restriction</h4><ul><li>Allowlist &amp; Blocklist (针对 IP, 国家进行访问限制)<ul><li>CloudFront Geo Restriction 没办法和 VPC 一起使用</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img233638.png"></p><hr><h4 id="CloudFront-Cache-Invalidation"><a href="#CloudFront-Cache-Invalidation" class="headerlink" title="CloudFront Cache Invalidation"></a>CloudFront Cache Invalidation</h4><ul><li>让 CloudFront 跳过 TTL 立即更新<ul><li>比如你更新了后端, 但是 CloudFront 不会立即更新, 需要 CloudFront Invalidation 来跳过 TTL 来立即更新</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img234007.png"></p><hr><h4 id="AWS-Global-Accelerator"><a href="#AWS-Global-Accelerator" class="headerlink" title="AWS Global Accelerator"></a>AWS Global Accelerator</h4><ul><li>利用 AWS internal network to route application<ul><li>Provide 2 global static anycast IPs (重要)</li><li>Improve availability and performance of the applications (globally)</li></ul></li><li>Global Accelerator improves performance for applications over TCP or UDP</li><li>Global Accelerator has automatic failover</li><li>Global Accelerator is more expensive as it adds an extra layer of infrastructure (对比 CloudFront 不是一个 cost-effective 的选择)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img234527.png"></p><ul><li>AWS Global Accelerator vs CloudFront<ul><li>CloudFront: Content is served at edge, 比如图片和视频 (cacheable), Dynamic content such as API acceleration &amp; dynamic site delivery</li><li>Global Accelerator: 适合 TCP 或者 UDP, 比如游戏和 IoT (static IP)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img000939.png"></p><blockquote><p>AWS Global Accelerator is a network service that can provide a global traffic management solution. By creating a standard accelerator in AWS Global Accelerator, you can guide user traffic to the endpoint closest to them, thereby improving the performance and availability of the application.</p></blockquote><hr><h3 id="14-AWS-Storage-Extra"><a href="#14-AWS-Storage-Extra" class="headerlink" title="14. AWS Storage Extra"></a>14. AWS Storage Extra</h3><h4 id="AWS-Snow-Family"><a href="#AWS-Snow-Family" class="headerlink" title="AWS Snow Family"></a>AWS Snow Family</h4><ul><li>整个 Snow Family 都是硬件形式</li><li>Data migration (in &amp; out AWS) &amp; Edge Computing (process data at edge)<ul><li>Snowcone (体积小, 适合带到特殊环境, 没有 Snowball 内存大)</li><li>Snowball Edge (Storage Optimized 和 Compute Optimized, 推荐处理 10 - 100 TB)<ul><li>Compute Optimized 是支持 storage clustering 的</li><li>Terabytes, low costs, limited time &#x3D; AWS Snowball devices</li></ul></li><li>Snowmobile (不算在 Edge Computing 里, 数据传输最大, 推荐处理 10 PB 以上)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img200544.png"></p><ul><li>Edge Location: 比如海上或者矿洞里, 没有网络的情况下<ul><li>所以需要 Edge Computing 和 Snow Family</li></ul></li><li>AWS OpsHub: 用来管理 AWS Snow Family</li><li>Snowball to Glacier: Use S3 lifecycle policy (Snowball 兼容 S3 但是 Glacier 不行, 重要)<ul><li>注意, 这里的 Glacier 指的是整个 Glacier Family (eg. Glacier Deep Archive)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img201918.png"></p><hr><h4 id="AWS-FSx"><a href="#AWS-FSx" class="headerlink" title="AWS FSx"></a>AWS FSx</h4><ul><li>Third party high-performance file systems on AWS (第三方文件系统)<ul><li>FSx for Windows: Window file system, support SMB &amp; Windows NTFS</li><li>FSx for Lustre (Linux): 可以 maximize IOPS, 适合 HPC, 可以和 S3 Integrate</li><li>FSx for NetApp ONTAP: File system for NFS, SMB, iSCSI</li><li>FSx for OpenZFS: OpenZFS file system (和它名字一样)</li></ul></li></ul><blockquote><p>FSx for Lustre provides the ability to both process the ‘hot data’ in a parallel and distributed fashion as well as easily store the ‘cold data’ on Amazon S3.</p></blockquote><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img202205.png"></p><ul><li>两种 Deployment Options<ul><li>Scratch File System: Temporary storage, data not replicated</li><li>Persistent File System: Long term storage, data replicated (Same AZ, 重要)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img202555.png"></p><hr><h4 id="AWS-Storage-Gateway"><a href="#AWS-Storage-Gateway" class="headerlink" title="AWS Storage Gateway"></a>AWS Storage Gateway</h4><ul><li>Bridge between On-Premise data and cloud data (Hybrid cloud, 重要)<ul><li>On-Premise 和 AWS Cloud 之间的桥梁 (保留从 On-Premise 去访问 AWS 数据的能力)</li><li>重点, Hybrid Cloud, give On-Premise ability to access cloud storage</li></ul></li><li>提到 NFS 的就是 File Gateway, 问 S3 大部分都是 File Gateway</li><li>DataSync 是用来移数据的, File Gateway 是用来维持 access 的 (重要)</li><li>File Gateway 是 file storage, Volume Gateway 是 block storage (重要)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img203211.png"></p><ul><li>一共有 4 种 Gateway (注意, Storage Gateway 泛指下面这 4 个 Gateway)<ul><li>S3 File Gateway: 从 On-Premise 访问 S3 Buckets (NFS, SMB), file storage</li><li>FSx File Gateway: 从 On-Premise 访问 FSx (SMB, NTFS)</li><li>Volume Gateway: 从 On-Premise 访问 S3 和 EBS (iSCSI), block storage<ul><li>Cached volumes: Access most recent data (eg. logs) 如果问到 S3 的话</li><li>Stored volumes: Entire dataset is On-Premise, backup at S3</li></ul></li><li>Tap Gateway: 从 On-Premise 访问 Archieved Taps stored in AWS Glacier<ul><li>如果问题里面有 Tap 就是 Tap Gateway</li></ul></li></ul></li></ul><hr><h4 id="AWS-Transfer-Family"><a href="#AWS-Transfer-Family" class="headerlink" title="AWS Transfer Family"></a>AWS Transfer Family</h4><ul><li>Use FTP protocol to transfer files into or out S3 或 EFS<ul><li>有三种 Protocols: FTP, FTPS, SFTP (重要, 如果问到关于 FTP 或者 SFTP 的问题)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img203933.png"></p><hr><h4 id="AWS-DataSync"><a href="#AWS-DataSync" class="headerlink" title="AWS DataSync"></a>AWS DataSync</h4><ul><li>可以从 On-Premise 或者 AWS 转移大量数据 (to &amp; from)<ul><li>On-Premise 到 AWS S3, EFS, FSx 等等 (need agent)</li><li>AWS 到 AWS (no agent)</li></ul></li><li>Scheduled replication tasks (比如每周五都会 replicate 一次)</li><li>File permissions and metadata are perserved (重要)</li><li>DataSync 是用来移数据的, File Gateway 是用来维持 access 的</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img204155.png"></p><blockquote><p>AWS DataSync is an online data transfer service that simplifies, automates, and accelerates copying large amounts of data between on-premises storage systems and AWS Storage services, as well as between AWS Storage services.</p></blockquote><hr><h3 id="15-SQS-SNS-Kinesis-Active-MQ"><a href="#15-SQS-SNS-Kinesis-Active-MQ" class="headerlink" title="15. SQS, SNS, Kinesis, Active MQ"></a>15. SQS, SNS, Kinesis, Active MQ</h3><h4 id="AWS-SQS"><a href="#AWS-SQS" class="headerlink" title="AWS SQS"></a>AWS SQS</h4><ul><li>用来 decouple applications (比如处理视频, 属于多对多模型)</li><li>SQS scale automatically (Unlimited throughput, unlimited message, can retry)<ul><li>遇到说 decouple microservice (但是没有 3rd party 的) 就是 SQS</li></ul></li><li>Standard SQS 允许将 S3 作为 event notification destination, SQS FIFO 则不行</li><li>如果遇到 SQS message process failure, 选择 DLQ 来解决 (重要)</li><li>如果遇到需要处理 high-throughput request-reponse message pattern 的, 选择 temporary queue (重要)</li><li>如果遇到需要 SQS 去 postpone the delivery of new messages, 那么就是 delay queue</li><li>遇到 parallel 选 SQS 而不是 SNS</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img235912.png"></p><ul><li>可以有很多 consumer 来同时 parallel 处理 messages<ul><li>Consumer delete messages after processing them (处理完就删掉)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img000504.png"></p><ul><li>SQS Message Visibility Timeout (重要)<ul><li>Visibility Timeout is high: Consumer crash, re-process take time</li><li>Visibility Timeout is low: Get duplicate (防止 read duplicate, 增加 Timeout, 重要)</li><li>Use the ChangeMessageVisibility API call to increase the visibility timeout</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img020440.png"></p><ul><li>当遇到 SQS 而且需要 priority 的时候, Create two Amazon SQS standard queues, Set up Amazon EC2 instances to prioritize polling</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/imgpt6-q32-i1.jpg"></p><ul><li>把 SQS 转成 FIFO queue<ul><li>Delete the existing SQS and recreate it as FIFO queue</li><li>Make sure the name of the FIFO queue ends with .fifo suffix</li><li>Make sure the throughput for the FIFO queue not exceed 3000 meesage &#x2F; second</li></ul></li></ul><hr><h4 id="SQS-Long-Polling"><a href="#SQS-Long-Polling" class="headerlink" title="SQS Long Polling"></a>SQS Long Polling</h4><ul><li>Decrease latency &amp; decrease API call (减少 API 请求, 更好的 performance)<ul><li>Minimize the cost of using SQS (省钱)</li><li>Long Polling 不能处理 SQS duplicate, 还是要用 Visibility Timeout</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img003255.png"></p><hr><h4 id="SQS-FIFO-Queue"><a href="#SQS-FIFO-Queue" class="headerlink" title="SQS FIFO Queue"></a>SQS FIFO Queue</h4><ul><li>按顺序传递 message (SNS 也可以做到)<ul><li>By default, FIFO queues support up to 300 messages per second</li></ul></li><li>如果没有 GroupID, 那只能有 1 个 consumer, 如果有 GroupID, 可以有多个 consumer</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img003507.png"></p><hr><h4 id="AWS-SNS"><a href="#AWS-SNS" class="headerlink" title="AWS SNS"></a>AWS SNS</h4><ul><li>Send one message to many receivers (可以给用户发 email)<ul><li>Publisher &amp; Subscriber 模型 (属于一对多模型)</li><li>Subscriber: SQS, Lambda, Kinesis Data Firehose, HTTPS endpoints, Email</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img010634.png"></p><hr><h4 id="Fan-Out-Pattern"><a href="#Fan-Out-Pattern" class="headerlink" title="Fan Out Pattern"></a>Fan Out Pattern</h4><ul><li>Push once in SNS, receive in all SQS (由 SNS 传递 message 给 SQS 来接收)<ul><li>Fully decoupled, no data loss</li><li>可以用于 message filtering (信息过滤, 根据不同的 filter policy)</li></ul></li><li>Kinesis 也可以使用 Fan Out Pattern (使用 Shard)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img011026.png"></p><hr><h4 id="AWS-Kinesis"><a href="#AWS-Kinesis" class="headerlink" title="AWS Kinesis"></a>AWS Kinesis</h4><ul><li>Process, ingest, buffer streaming data in real-time (处理实时数据)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img150053.png"></p><ul><li>Kinesis Data Streams: Capture, process, store data streams</li><li>Kinesis Data Firehose: Load data streams into AWS data stores (S3, Redshift)</li><li>当 Kinesis Data Streams 作为数据源写数据到 Kinesis Data Firehose 是不用 agent 的</li></ul><blockquote><p>Kinesis Agent cannot write to Amazon Kinesis Firehose for which the delivery stream source is already set as Amazon Kinesis Data Streams</p></blockquote><hr><h4 id="Kinesis-Data-Streams"><a href="#Kinesis-Data-Streams" class="headerlink" title="Kinesis Data Streams"></a>Kinesis Data Streams</h4><ul><li>Have the ability to reprocess &amp; replay stream data (replay, 处理数据, 重要)<ul><li>处理 real-time data stream, 比如 clickstreams, transactions, media (金融数据)</li><li>Consumer 有 Lambda, Kinesis Firehose, Kinesis Data Analytics</li><li>Kinesis Data Streams 有助于每秒从多个来源连续收集数 GB 的数据</li></ul></li><li>Once data is inserted in Kinesis, it can’t be deleted (immutability)</li><li>如果问到 Kinesis Data Stream 加上 SQL, 那么答案里一定有 Kinesis Data Analytics</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img014850.png"></p><ul><li>Data share the same partition goes the same shard (有顺序的)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img151123.png"></p><ul><li>Capacity Mode (Provisioned 设置上限, On-Demand 自动 scale)<ul><li>Provisioned mode: Choose a number of shards provisioned, scale manually</li><li>On-demand mode: No need to provision or manage capacity (自动)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img151507.png"></p><blockquote><p>如果遇到 ProvisionedThroughputExceededException 问题, 选择 batch messages 解决</p></blockquote><hr><h4 id="Kinesis-Data-Firehose"><a href="#Kinesis-Data-Firehose" class="headerlink" title="Kinesis Data Firehose"></a>Kinesis Data Firehose</h4><ul><li>Kinesis Data Firehose load streaming data into data stores and analytics tools<ul><li>Managed service, auto scaling, serverless, support data transformation</li><li>Kinesis Data Firehose 提供将数据流传进数据存储或者数据分析的功能</li></ul></li><li>Firehose 的对象是 S3, Redshift 这种 (Serverless, 专门处理 log 数据)<ul><li>Firehose 不支持 DynamoDB 的</li></ul></li><li>Near Real Time, 而且 Firehose 只支持一个 consumer (dump data in a single data repo)<ul><li>但是不要被 Near Real Time 忽悠, 要根据题目选择 Data Stream 或者 Data Firehose</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img015040.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img151812.png"></p><ul><li>Kinesis Data Streams vs Firehose<ul><li>Data Streams: Write custom code, real-time, have data storage, have replay</li><li>Firehose: Fully managed, near real-time, no data storage, no replay</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img152247.png"></p><hr><h4 id="Data-ordering-for-Kinesis"><a href="#Data-ordering-for-Kinesis" class="headerlink" title="Data ordering for Kinesis"></a>Data ordering for Kinesis</h4><ul><li>Same key (Partition) will always go to the same shard (有顺序)</li><li>相比之下 SQS 只有 FIFO (针对于需要大量 consumer)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img154939.png"></p><hr><h4 id="AWS-MQ"><a href="#AWS-MQ" class="headerlink" title="AWS MQ"></a>AWS MQ</h4><ul><li>管理第三方消息代理 (Message Broker) 软件<ul><li>RabbitMQ and ActiveMQ</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img170638.png"></p><hr><h3 id="16-Containers-on-AWS"><a href="#16-Containers-on-AWS" class="headerlink" title="16. Containers on AWS"></a>16. Containers on AWS</h3><h4 id="AWS-ECS"><a href="#AWS-ECS" class="headerlink" title="AWS ECS"></a>AWS ECS</h4><ul><li>Elastic Container Service (Manage Docker containers on AWS)</li><li>ECS 有两种 Launch Type: EC2 和 Fargate (Fargate 是 serverless 的)</li><li>EC2 Launch Type: Need Provision, 需要 ECS Agent (重点)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img212508.png"></p><ul><li>Fargate Launch Type: Serverless, No Provision (重点)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img212546.png"></p><ul><li>IAM Roles for ECS (重要, 是 IAM)<ul><li>EC2 Instance Profile: 只针对 EC2 Launch Type</li><li>ECS Task Role: 每个 Task 都有自己的 Role (负责)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img212709.png"></p><ul><li>ECS 可以和 Load Balancer 一起用</li><li>ECS 可以和 EFS 一起用 (Fargate + EFS &#x3D; Serverless, 管理文件)</li></ul><blockquote><p>Amazon ECS with EC2 launch type is charged based on EC2 instances and EBS volumes used. Amazon ECS with Fargate launch type is charged based on vCPU and memory resources that the containerized application requests</p></blockquote><hr><h4 id="ECS-Auto-Scaling"><a href="#ECS-Auto-Scaling" class="headerlink" title="ECS Auto Scaling"></a>ECS Auto Scaling</h4><ul><li>Automatically increase &#x2F; decrease the number of ECS tasks<ul><li>Target Scaling: Scale based on target value for CloudWatch metric</li><li>Step Scaling: Scale based on CloudWatch Alarm</li><li>Scheduled Scaling: Scale based on specific time (重要)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img222247.png"></p><hr><h4 id="AWS-ECR"><a href="#AWS-ECR" class="headerlink" title="AWS ECR"></a>AWS ECR</h4><ul><li>Elastic Container Registry (ECR, 管理 Docker Image, 不是 Docker Container)<ul><li>Store and manage Docker images on AWS</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img222836.png"></p><hr><h4 id="AWS-EKS"><a href="#AWS-EKS" class="headerlink" title="AWS EKS"></a>AWS EKS</h4><ul><li>Elastic Kubernetes Service (Manage Kubernetes clusters on AWS)<ul><li>Support 2 deployment mode: EC2 &amp; Fargate (和 ECS 一样)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img223132.png"></p><ul><li>EKS Data Volumes (需要 StorageClass)<ul><li>Leverages a Container Storage Interface (CSI) compliant driver</li><li>支持 EBS, EFS, FSx</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img223503.png"></p><ul><li>EKS Node Type (一共三种)<ul><li>Managed Node Groups (针对 EC2 Instance)</li><li>Self-Managed Nodes (自己创建)</li><li>AWS Fargate (不需要管理)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img022321.png"></p><hr><h4 id="AWS-App-Runner"><a href="#AWS-App-Runner" class="headerlink" title="AWS App Runner"></a>AWS App Runner</h4><ul><li>Deploy web application and APIs (Build 和 Deploy)</li><li>No infrasture experience required (不需要 AWS 经验)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img223649.png"></p><hr><h3 id="17-Serverless"><a href="#17-Serverless" class="headerlink" title="17. Serverless"></a>17. Serverless</h3><h4 id="AWS-Lambda"><a href="#AWS-Lambda" class="headerlink" title="AWS Lambda"></a>AWS Lambda</h4><ul><li>Virtual functions, Serverless, limited by time (short executions, 15 mins)<ul><li>Run on-demand, scaling is automated</li></ul></li><li>Could be Event-Driven, could handle CRON job (Jobs on a repeating schedule)<ul><li>Use EventBridge to trigger Lambda every hour</li></ul></li><li>Lambda 是有 account quota (配额限制) 的, 需要联系 AWS 来提高上限</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img212846.png"></p><ul><li>Lambda Limits (限制)<ul><li>Execution: Memory, Execution Time</li><li>Deployment: Size</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img213554.png"></p><blockquote><p>By default, AWS Lambda functions always operate from an AWS-owned VPC and hence have access to any public internet address or public AWS APIs. Once an AWS Lambda function is VPC-enabled, it will need a route through a Network Address Translation gateway (NAT gateway) in a public subnet to access public resources</p></blockquote><hr><h4 id="Lambda-SnapStart"><a href="#Lambda-SnapStart" class="headerlink" title="Lambda SnapStart"></a>Lambda SnapStart</h4><ul><li>对于 Java 11 以上, Function is invoked from a pre-initialized state</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img213945.png"></p><hr><h4 id="CloudFront-Functions-amp-Lambda-Edge"><a href="#CloudFront-Functions-amp-Lambda-Edge" class="headerlink" title="CloudFront Functions &amp; Lambda@Edge"></a>CloudFront Functions &amp; Lambda@Edge</h4><ul><li>Execute logic at the edge (Edge Function, Serverless)</li><li>两种方法: CloudFront Functions, Lambda@Edge (它们支持的语言不同)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img214215.png"></p><ul><li>CloudFront Functions (Javascript)<ul><li>Native feature of CloudFront, short execution time</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img214350.png"></p><ul><li>Lambda@Edge (NodeJS or Python)<ul><li>Longer execution time</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img214545.png"></p><ul><li>CloudFront Functions vs Lambda@Edge</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img214716.png"></p><hr><h4 id="Lambda-in-VPC"><a href="#Lambda-in-VPC" class="headerlink" title="Lambda in VPC"></a>Lambda in VPC</h4><ul><li>正常情况下, Lambda 无法访问 VPC (所以要 Lambda in VPC)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img214940.png"></p><hr><h4 id="RDS-with-Lambda"><a href="#RDS-with-Lambda" class="headerlink" title="RDS with Lambda"></a>RDS with Lambda</h4><ul><li>Invoke Lambda functions from DB instance<ul><li>RDS for PostgreSQL, Aurora for MySQL, 需要 permission</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img215442.png"></p><hr><h4 id="AWS-DynamoDB"><a href="#AWS-DynamoDB" class="headerlink" title="AWS DynamoDB"></a>AWS DynamoDB</h4><ul><li>NoSQL database, with replication across multiple AZs, auto-scaling, no provision</li><li>两种 Class: Standard &amp; Infrequent Access (IA)</li><li>如果问到 DynamoDB 而且是处理 Email 的, 就是 DynamoDB Stream<ul><li>如果问到关于 Stream 的, 也要去考虑 DynamoDB Stream</li></ul></li><li>如果问到 DynamoDB 而且是处理 unpredictable 数据的时候, 选择 On-Demand table</li><li>By default, DynamoDB tables are encrypted with AWS owned key</li><li>不要用 DB 去存 Image (不知道为啥)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img224558.png"></p><ul><li>Read &#x2F; Write Capacity Mode<ul><li>RCU 和 WCU 没有关联 (可以只加 RCU 不加 WCU)</li><li>Provisioned Mode: 自己定义需要多少 RCU 和 WCU</li><li>On-Demand Mode: 自动 Scale 需要的 RCU 和 WCU (贵)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img225117.png"></p><ul><li>Point-In-Time Recovery (PITR, 重要)<ul><li>When enable PITR, DynamoDB backs up table data automatically with per-second granularity so that you can restore to any given second in the preceding 35 days.</li></ul></li></ul><hr><h4 id="DynamoDB-Advance"><a href="#DynamoDB-Advance" class="headerlink" title="DynamoDB Advance"></a>DynamoDB Advance</h4><ul><li>DynamoDB Accelerator (DAX, 可以处理 cache, 但是 DAX 不是 relational 的)<ul><li>Help solve read congestion by caching (microseconds latency, 缓存)</li><li>DAX 不支持 SQL query caching</li><li>可以提高 DynamoDB 的 performance (提高的是 read 而不是 write, 重要)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img233440.png"></p><ul><li>DynamoDB Stream Processing (处理 Stream)<ul><li>Ordered stream of item-level modifications in table</li><li>用来处理 Stream 的, 可以 Invoke Lambda function (比如发邮件)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img233610.png"></p><ul><li>DynamoDB Global Tables (重要)<ul><li>Make DynamoDB table accessible with low latency in multiple regions</li><li>需要先有 DynamoDB Stream 作为前提</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img233729.png"></p><ul><li>DynamoDB Time To Live (TTL, 重要)<ul><li>Automatic delete items after an expiry timestamp (定时删除 DynamoDB 里的 item)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img233830.png"></p><hr><h4 id="AWS-API-Gateway"><a href="#AWS-API-Gateway" class="headerlink" title="AWS API Gateway"></a>AWS API Gateway</h4><ul><li>Invoke Lambda function, expose REST API (Stateless client-server communication)</li><li>Lambda + API Gateway &#x3D; No infrastructure to manage</li><li>API Gateway 可以防止 API overwhelmed by too many requests (防抖)</li><li>API Gateway Caching (可以 improve latency)<ul><li>With caching, you can reduce the number of calls made to your endpoint and also improve the latency of requests to your API</li><li>反正记住, Read Replica 是要加钱的</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img234222.png"></p><ul><li>API Gateway Endpoint Types<ul><li>Edge-Optimized (default): For global clients, API Gateway live in one region</li><li>Regional: For client in same region</li><li>Private: 针对 VPC</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img174118.png"></p><hr><h4 id="AWS-Step-Functions"><a href="#AWS-Step-Functions" class="headerlink" title="AWS Step Functions"></a>AWS Step Functions</h4><ul><li>Build serverless visual workflow to orchestrate Lambda functions<ul><li>搭建 Serverless 可视化 Workflow (重要)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img234352.png"></p><hr><h4 id="AWS-Cognito"><a href="#AWS-Cognito" class="headerlink" title="AWS Cognito"></a>AWS Cognito</h4><ul><li>Give users identity to interact with web or mobile application<ul><li>Cognito User Pools: 负责用户登录, have built-in user management</li><li>Cognito Identity Pools: 给临时 AWS credentials 来 access AWS 服务</li></ul></li><li>注意, ALB + Cognito User Pool 才是做 Auth 的, 而不是 CloudFront</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img234512.png"></p><hr><h3 id="18-Database-Summary"><a href="#18-Database-Summary" class="headerlink" title="18. Database Summary"></a>18. Database Summary</h3><h4 id="AWS-RDS-SM"><a href="#AWS-RDS-SM" class="headerlink" title="AWS RDS (SM)"></a>AWS RDS (SM)</h4><ul><li>Manage PostgreSQL, MySQL, Oracle, SQL Server 等等</li><li>Provisioned, Auto Scaling, Backup</li><li>Have Read Replica &amp; Multi-AZ (回去看第七章)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img151151.png"></p><hr><h4 id="AWS-Aurora-SM"><a href="#AWS-Aurora-SM" class="headerlink" title="AWS Aurora (SM)"></a>AWS Aurora (SM)</h4><ul><li>Manage PostgreSQL &amp; MySQL (只有这两个, 回去看第七章)</li><li>Data stored in 6 replias, across 3 AZ, high available, auto-scaling</li><li>Aurora Serverless: For unpredictable workloads (Auto Scaling)</li><li>Aurora Global: Less than 1 second storage replication (保证至少有一个 Replica 可以用)</li><li>Aurora Database Cloning: 快速 access Aurora DB, 适合 test database 生成</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img151441.png"></p><hr><h4 id="AWS-ElastiCache-SM"><a href="#AWS-ElastiCache-SM" class="headerlink" title="AWS ElastiCache (SM)"></a>AWS ElastiCache (SM)</h4><ul><li>Manage Redis &#x2F; Memcached (In-memory data store, 回去看第七章)</li><li>Support Clustering (Redis), Multi-AZ and Read Replicas (Shard)</li><li>Require some application code change to be leveraged (重点)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img151732.png"></p><hr><h4 id="AWS-DynamoDB-SM"><a href="#AWS-DynamoDB-SM" class="headerlink" title="AWS DynamoDB (SM)"></a>AWS DynamoDB (SM)</h4><ul><li>Severless, NoSQL database (For rapidly evolve schemas, 回去看第十七章)</li><li>Capacity modes: Provisioned capacity or On-Demand capacity</li><li>DAX cluster for read cache, microsecond read latency (缓存)</li><li>Event Processing: DynamoDB Stream with Lambda or Kinesis Data Streams</li><li>Export to S3 without using RCU, Import from S3 without WCU</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img152140.png"></p><hr><h4 id="AWS-S3-SM"><a href="#AWS-S3-SM" class="headerlink" title="AWS S3 (SM)"></a>AWS S3 (SM)</h4><ul><li>S3 is a key &#x2F; value store for objects (适合文件体积大的, 回去看第十章)</li><li>Tiers: Standard, IA, Glacier 等等</li><li>Features: Versioning, Encryption, Replication 等等</li><li>Encryption: SSE-S3, SSE-KMS, SSE-C</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img152526.png"></p><hr><h4 id="AWS-DocumentDB"><a href="#AWS-DocumentDB" class="headerlink" title="AWS DocumentDB"></a>AWS DocumentDB</h4><ul><li>DocumentDB is for MongoDB (Also a NoSQL database, 但是只负责 MongoDB)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img152629.png"></p><hr><h4 id="AWS-Neptune"><a href="#AWS-Neptune" class="headerlink" title="AWS Neptune"></a>AWS Neptune</h4><ul><li>Graph database (For social network, 图数据库)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img152726.png"></p><hr><h4 id="AWS-Keyspaces"><a href="#AWS-Keyspaces" class="headerlink" title="AWS Keyspaces"></a>AWS Keyspaces</h4><ul><li>Manage Apache Cassandra (also NoSQL) database (阿帕奇卡桑德拉)</li><li>Use cases: Store IoT devices info, time-series data</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img153058.png"></p><hr><h4 id="AWS-QLDB"><a href="#AWS-QLDB" class="headerlink" title="AWS QLDB"></a>AWS QLDB</h4><ul><li>QLDB: Quantum Ledger Database (Immutable, 无法删除)<ul><li>For recording financial transactions (Serverless, 加密资产)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img153301.png"></p><hr><h4 id="AWS-Timestream"><a href="#AWS-Timestream" class="headerlink" title="AWS Timestream"></a>AWS Timestream</h4><ul><li>Serverless Time series database (时间序列数据库)</li><li>Use cases: IoT apps, real-time analytics</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img153436.png"></p><hr><h3 id="19-Data-amp-Analytics"><a href="#19-Data-amp-Analytics" class="headerlink" title="19. Data &amp; Analytics"></a>19. Data &amp; Analytics</h3><h4 id="AWS-Athena"><a href="#AWS-Athena" class="headerlink" title="AWS Athena"></a>AWS Athena</h4><ul><li>Athena is an interactive query service that makes it easy to analyze data directly in Amazon S3 using standard SQL (Athena is Serverless)<ul><li>Athena 支持 SQL query 去处理 S3 数据的</li><li>Athena cannot be used to analyze data in real time (没办法实时处理数据, 重要)</li></ul></li><li>Use Athena to process logs, perform ad-hoc analysis, and run interactive queries (重要)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img200048.png"></p><ul><li>Performance Improvement<ul><li>Use columnar data for cost-saving (可以有更少的 scan)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img200302.png"></p><ul><li>Federated Query<ul><li>Allow to run SQL queries across data stored on AWS or On-Premise</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img200427.png"></p><hr><h4 id="AWS-Redshift"><a href="#AWS-Redshift" class="headerlink" title="AWS Redshift"></a>AWS Redshift</h4><ul><li>Based on PostgreSQL, but it’s OLAP (Online analytical processing)</li><li>处理 BI 数据, 和 AWS Quicksight 或者 Tableau 一起用<ul><li>Petabyte scale - Redshift (重要)</li></ul></li><li>如果问到 Redshift 且和 S3 有关, 就是 Redshift Spectrum (重要)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img201036.png"></p><ul><li>Snapshots &amp; DR<ul><li>Redshift has “Multi-AZ” mode for clusters</li><li>Enable Automated Snapshots, copy the Redshift cluster to another AWS region</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img201212.png"></p><ul><li>Load data into Redshift (将数据存到 Redshift 里)<ul><li>Kinesis Data Firehose, S3 with Enhanced VPC Routing (注意), EC2 Instance</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img230656.png"></p><ul><li>Redshift Spectrum (和 S3 有关)<ul><li>Query data that is already in S3 without loading it (重要)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img201418.png"></p><hr><h4 id="AWS-OpenSearch"><a href="#AWS-OpenSearch" class="headerlink" title="AWS OpenSearch"></a>AWS OpenSearch</h4><ul><li>With OpenSearch, you can search any field, even partially matches<ul><li>原来叫做 ElasticSearch (就是做查询的)</li></ul></li><li>可以用 OpenSearch 实时处理和搜索 Logs</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img203117.png"></p><hr><h4 id="AWS-EMR"><a href="#AWS-EMR" class="headerlink" title="AWS EMR"></a>AWS EMR</h4><ul><li>EMR: Elastic MapReduce (处理大数据的)<ul><li>EMR helps to creating Hadoop clusters (Big Data, 大数据)</li><li>有 Hadoop, Apache Spark 啥的就是 EMR</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img203405.png"></p><ul><li>Node types &amp; purchasing<ul><li>Node: Master, Core, Task</li><li>Purchasing options: On-Demand, Reserved, Spot Instance</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img203545.png"></p><hr><h4 id="AWS-QuickSight"><a href="#AWS-QuickSight" class="headerlink" title="AWS QuickSight"></a>AWS QuickSight</h4><ul><li>Serverless machine learning business intelligence service to create dashboard<ul><li>简单来说就是用 ML 来分析商业数据并搭建 Dashboard</li></ul></li><li>In-memory computation using SPICE engine</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img203724.png"></p><ul><li>Dashboard &amp; Analysis<ul><li>Share analysis or dashboard with Users or Groups (可以选择性的分享数据)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img203954.png"></p><hr><h4 id="AWS-Glue"><a href="#AWS-Glue" class="headerlink" title="AWS Glue"></a>AWS Glue</h4><ul><li>Managed extract, transform and load (ETL) service (Serverless)<ul><li>For customers to prepare and load their data for analytics</li><li>遇到处理 ETL 的就是 Glue, 用到 Apache Spark</li><li>Use AWS Glue to process the raw data in Amazon S3 (重要)</li></ul></li></ul><blockquote><p>AWS Glue ETL jobs can use Amazon S3, data stores in a VPC, or on-premises JDBC data stores as a source. AWS Glue jobs extract data, transform it, and load the resulting data back to S3, data stores in a VPC, or on-premises JDBC data stores as a target.</p></blockquote><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img224509.png"></p><ul><li>Convert data into Apache Parquet format (转数据格式, 很奇怪, 但是会考)<ul><li>看到这个 Apache Parquet 就要想起 Glue</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img224817.png"></p><ul><li>Glue Job Bookmarks: 防止 re-process 旧数据 (重要)</li><li>Glue Elastic Views: Combine and replicate data accross multiple data stores with SQL</li><li>Glue DataBrew: Clean and normalize data</li></ul><hr><h4 id="AWS-Lake-Formation"><a href="#AWS-Lake-Formation" class="headerlink" title="AWS Lake Formation"></a>AWS Lake Formation</h4><ul><li>Managed services to setup Data Lake (数据湖)<ul><li>Central place to have all data for analytics purpose</li><li>注意, 如果题目里提到 Fine-grained Access Control for application, 就要想起 Lake Foramtion</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img224948.png"></p><hr><h4 id="Kinesis-Data-Analytics"><a href="#Kinesis-Data-Analytics" class="headerlink" title="Kinesis Data Analytics"></a>Kinesis Data Analytics</h4><ul><li>Real-time analytics on Kinesis Data Streams &amp; Firehose using SQL (重要)<ul><li>Fully managed, auto-scaling, serverless</li><li>以 Kinesis Data Streams &amp; Firehose 作为目标使用 SQL 进行数据分析</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img225813.png"></p><ul><li>Amazon Managed Service for Apache Flink</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img225906.png"></p><hr><h4 id="AWS-MSK"><a href="#AWS-MSK" class="headerlink" title="AWS MSK"></a>AWS MSK</h4><ul><li>Managed Apache Kafka on AWS (Have Serverless)<ul><li>Kinesis 的代替 (同样处理 Stream data), 但是针对 Apache Kafka</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img230056.png"></p><ul><li>Kinesis Data Streams (第十五章) vs AWS MSK</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img230216.png"></p><hr><h3 id="20-Machine-Learning"><a href="#20-Machine-Learning" class="headerlink" title="20. Machine Learning"></a>20. Machine Learning</h3><h4 id="AWS-Rekognition"><a href="#AWS-Rekognition" class="headerlink" title="AWS Rekognition"></a>AWS Rekognition</h4><ul><li>Find object, people, text, scenes in images and videos using ML (识别物品)</li><li>Facial analysis and facial search</li><li>Content Moderation: Detect content that is inappropriate (重要)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img004131.png"></p><hr><h4 id="AWS-Transcribe"><a href="#AWS-Transcribe" class="headerlink" title="AWS Transcribe"></a>AWS Transcribe</h4><ul><li>Convert speech to text (语音转文字, Transcribe 是转录的意思)</li><li>Automatically remove Personally Identifiable Information (PII, 重要)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img004337.png"></p><hr><h4 id="AWS-Polly"><a href="#AWS-Polly" class="headerlink" title="AWS Polly"></a>AWS Polly</h4><ul><li>Convert text to speech (文字转语音)</li><li>Pronunciation Lexicons: Customize the pronunciation of words</li><li>Speech Synthesis Markup Language (SSML): Emphasize words (小声)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img004547.png"></p><hr><h4 id="AWS-Translate"><a href="#AWS-Translate" class="headerlink" title="AWS Translate"></a>AWS Translate</h4><ul><li>Language translation (翻译)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img004816.png"></p><hr><h4 id="AWS-Lex-amp-Connect"><a href="#AWS-Lex-amp-Connect" class="headerlink" title="AWS Lex &amp; Connect"></a>AWS Lex &amp; Connect</h4><ul><li>AWS Lex: Build chatbot (所有和 chatbot 有关的都是 Lex)</li><li>AWS Connect: Build cloud contact center</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img004954.png"></p><hr><h4 id="AWS-Comprehend"><a href="#AWS-Comprehend" class="headerlink" title="AWS Comprehend"></a>AWS Comprehend</h4><ul><li>Natural Language Processing (NLP)</li><li>Comprehend Medical: for clinical text (医疗方面, 非常重要)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img005107.png"></p><hr><h4 id="AWS-SageMaker"><a href="#AWS-SageMaker" class="headerlink" title="AWS SageMaker"></a>AWS SageMaker</h4><ul><li>Build ML models (建 ML 模型)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img005342.png"></p><hr><h4 id="AWS-Forecast"><a href="#AWS-Forecast" class="headerlink" title="AWS Forecast"></a>AWS Forecast</h4><ul><li>Use ML to deliver highly accurate forecasts (做预测用的)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img012641.png"></p><hr><h4 id="AWS-Kendra"><a href="#AWS-Kendra" class="headerlink" title="AWS Kendra"></a>AWS Kendra</h4><ul><li>Managed document search service (文档查找)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img012746.png"></p><hr><h4 id="AWS-Personalize"><a href="#AWS-Personalize" class="headerlink" title="AWS Personalize"></a>AWS Personalize</h4><ul><li>ML with real-time personalized recommendations (做推荐用的)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img012921.png"></p><hr><h4 id="AWS-Textract"><a href="#AWS-Textract" class="headerlink" title="AWS Textract"></a>AWS Textract</h4><ul><li>ML to extract text (提取文字用的, 重要)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img013008.png"></p><hr><h3 id="21-AWS-Mointoring-amp-Audit"><a href="#21-AWS-Mointoring-amp-Audit" class="headerlink" title="21. AWS Mointoring &amp; Audit"></a>21. AWS Mointoring &amp; Audit</h3><h4 id="CloudWatch-Metrics"><a href="#CloudWatch-Metrics" class="headerlink" title="CloudWatch Metrics"></a>CloudWatch Metrics</h4><ul><li>CloudWatch Metrics helps to monitor every services in AWS</li><li>可以用 CloudWatch Metrics 处理 CloudTrail logs 来监视异常</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img150021.png"></p><ul><li>CloudWatch Metric Streams<ul><li>Stream CloudWatch Metrics with near-real-time delivery (注意)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img150150.png"></p><hr><h4 id="CloudWatch-Logs"><a href="#CloudWatch-Logs" class="headerlink" title="CloudWatch Logs"></a>CloudWatch Logs</h4><ul><li>A place to store application logs in AWS (S3, Kinesis, Lambda)<ul><li>Logs are encrypted by default</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img150343.png"></p><ul><li>CloudWatch Logs Insights<ul><li>Search and analyze log data stored in CloudWatch Logs</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img150531.png"></p><ul><li>CloudWatch Logs Subscriptions (可以 Export 给 S3)<ul><li>Get a real-time log events from CloudWatch Logs for processing and analysis</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img150643.png"></p><blockquote><p>You can configure a CloudWatch Logs log group to stream data it receives to your Amazon OpenSearch Service cluster in NEAR REAL-TIME through a CloudWatch Logs subscription</p></blockquote><hr><h4 id="CloudWatch-Agent"><a href="#CloudWatch-Agent" class="headerlink" title="CloudWatch Agent"></a>CloudWatch Agent</h4><ul><li>可以把 EC2 的 log 传递给 CloudWatch (By default, EC2 不传递 log, 重要)</li><li>CloudWatch Logs Agent: 传递给 CloudWatch</li><li>CloudWatch Unified Agent: 可以传递更多信息, 比如 CPU, RAM 等等</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img151251.png"></p><hr><h4 id="CloudWatch-Alarms"><a href="#CloudWatch-Alarms" class="headerlink" title="CloudWatch Alarms"></a>CloudWatch Alarms</h4><ul><li>CloudWatch Alarms are used to trigger notifications for any metric (用 SNS 发消息)<ul><li>比如 EC2 的 Health 出问题</li><li>Target: EC2, ASG, SNS</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img151423.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img151514.png"></p><ul><li>Composite Alarams (监视当前所有 Alarm 的情况)<ul><li>Composite Alarams are mointoring the states of multiple other alarms</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img151615.png"></p><hr><h4 id="AWS-EventBridge"><a href="#AWS-EventBridge" class="headerlink" title="AWS EventBridge"></a>AWS EventBridge</h4><ul><li>Schedule CRON jobs (Jobs on a repeating schedule, event-driven)</li><li>React to events from SaaS application (AWS services)<ul><li>如果提到 3rd party application, 考虑 EventBridge</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img185605.png"></p><ul><li>基本上所有 event 都要经过 EventBridge</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img185712.png"></p><ul><li>Event Bus (Replay archived events, 注意)<ul><li>有 Default Event Bus 和 Partner Event Bus (Datadog)</li><li>可以 Archive Events 并且 Replay (Good for debug)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img190403.png"></p><ul><li>Schema Registry<ul><li>Analyze events in Event Bus and infer schema</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img190004.png"></p><ul><li>Resource-based Policy<ul><li>Manage permissions (allow &#x2F; deny) for a specific Event Bus</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img190215.png"></p><hr><h4 id="CloudWatch-Insights"><a href="#CloudWatch-Insights" class="headerlink" title="CloudWatch Insights"></a>CloudWatch Insights</h4><ul><li>这里的 CloudWatch Insights 有好几种不同的 Insights (4 种)<ul><li>Container, Lambda, Contributor, Application</li></ul></li><li>CloudWatch Container Insights (处理 Container 容器的)<ul><li>Collect, aggregate, summarize metrics and logs from container</li><li>ECS, EKS, Kubernetes, Fargate 等等</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img190651.png"></p><ul><li>CloudWatch Lambda Insights<ul><li>Monitoring solutions for serverless application running on Lambda</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img190750.png"></p><ul><li>CloudWatch Contributor Insights (注意, 可以查 IP)<ul><li>Analyze log data and display contributor data (for system performance)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img190854.png"></p><ul><li>CloudWatch Application Insights<ul><li>Provide dashboard to show the potential application issue related to AWS service</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img191050.png"></p><hr><h4 id="AWS-CloudTrail"><a href="#AWS-CloudTrail" class="headerlink" title="AWS CloudTrail"></a>AWS CloudTrail</h4><ul><li>Provide governance, compliance and audit for AWS account (审计 events 和 API call)<ul><li>比如 History of events 或者 API calls</li></ul></li><li>CloudTrail 是 Global Service, 如果东西被误删, 第一时间看 CloudTrail</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img191802.png"></p><ul><li>CloudTrail Events<ul><li>Management Events: Performed on resources in AWS account</li><li>Data Events: S3 object-level activity (GetObject, DeleteObject)</li><li>CloudTrail Insigths Events: Detect unusual activity (安全)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img192042.png"></p><ul><li>CloudTrail Insights (重要)<ul><li>CloudTaril Insights to detect unusual activity in account</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img192157.png"></p><ul><li>CloudTrail Event Retention (保存 events)<ul><li>Keep events to S3 after they stored 90 days</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img192301.png"></p><hr><h4 id="AWS-Config"><a href="#AWS-Config" class="headerlink" title="AWS Config"></a>AWS Config</h4><ul><li>AWS Config provides a detailed view of the configuration of AWS resources (重要)<ul><li>Record configurations and changes over time (记录 config 是否被修改)</li></ul></li><li>可以用 Config 去检查 ACM 的 certificate 有没有临近过期</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img192656.png"></p><ul><li>Config Rules: 可以自定义 Rule 来检查 (也有 AWS managed rules, 比如下面两个)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img045705.png"></p><ul><li>Config Remediations<ul><li>Automate remediation (纠正) of non-compliant resource using SSM Automation Documents (eg. unrestricted SSH access)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img192951.png"></p><ul><li>Config Notifications<ul><li>Use EventBridge to trigger notifications when AWS resources are noncompliant</li><li>相当于当有不合规的 Resource 出现时, 可以 Trigger Notifications</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img193119.png"></p><hr><h3 id="22-IAM-Advanced"><a href="#22-IAM-Advanced" class="headerlink" title="22. IAM Advanced"></a>22. IAM Advanced</h3><h4 id="AWS-Organizations"><a href="#AWS-Organizations" class="headerlink" title="AWS Organizations"></a>AWS Organizations</h4><ul><li>Manage multiple AWS accounts, global service</li><li>Consolidated Billing across all accounts (合并账单, 重要)<ul><li>如果问到和 Shield Advance 有关的钱的问题, 那就是没有设置 Consolidated Billing</li></ul></li><li>Shared reserved instance and Saving Plans discounts across accounts (重要)</li><li>如果要把一个 Account 转到另一个 Organization, 要先把它从原来的 Organization 移除</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img235557.png"></p><ul><li>Service Control Policies (SCP, 限制用户)<ul><li>IAM policies applied to OU (Organization Unit) or Accounts to restrict Users and Roles (Blocklist and Allowlist)</li><li>IAM Roles 是针对 Service, SCP 针对 Organization</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img013921.png"></p><ul><li><p>IAM Permission Boundary (回去看第二章)</p><ul><li>A permissions boundary is an advanced feature for using a managed policy to set the maximum permissions that an identity-based policy can grant to an IAM entity.</li></ul></li><li><p>Service Control Policies (SCPs)</p><ul><li>If a user or role has an IAM permission policy that grants access to an action that is either not allowed or explicitly denied by the applicable service control policy (SCP), the user or role can’t perform that action</li><li>Service control policy (SCP) affects all users and roles in the member accounts, including root user of the member accounts</li><li>Service control policy (SCP) does not affect service-linked role</li></ul></li></ul><hr><h4 id="IAM-Conditions"><a href="#IAM-Conditions" class="headerlink" title="IAM Conditions"></a>IAM Conditions</h4><ul><li>要分清楚 bucket level permissions 和 object level permissions (&#x2F;*)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img022652.png"></p><hr><h4 id="IAM-Roles-vs-Resource-Based-Policies"><a href="#IAM-Roles-vs-Resource-Based-Policies" class="headerlink" title="IAM Roles vs Resource Based Policies"></a>IAM Roles vs Resource Based Policies</h4><ul><li>Role: Give up original permissions and take the permissions assigned to the Role</li><li>Resource Based Policy: The principal doesn’t have to give up permissions</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img015940.png"></p><ul><li>EventBridge 例子<ul><li>Resource based policy: Lambda, SNS, SQS 等等</li><li>IAM Roles: Kinesis stream, ECS 等等</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img023321.png"></p><hr><h4 id="Policy-Evaluation-Logic"><a href="#Policy-Evaluation-Logic" class="headerlink" title="Policy Evaluation Logic"></a>Policy Evaluation Logic</h4><ul><li>IAM Permission Boundaries<ul><li>A feature to set the maximum permissions an IAM entity can get</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img020209.png"></p><ul><li>答案 No, No, No (Evaluate 逻辑是先来后到, 先 Deny 就算后面 Allow 也没有用)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img161535.png"></p><hr><h4 id="IAM-Identity-Center"><a href="#IAM-Identity-Center" class="headerlink" title="IAM Identity Center"></a>IAM Identity Center</h4><ul><li>One login for all (SSO)<ul><li>AWS accounts in AWS Organizations</li><li>Business cloud applications (Salesforce)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img020909.png"></p><ul><li>Fine-grained Permissions and Assignments<ul><li>Multi-Account Permissions: Manage access across AWS accounts</li><li>Application Assignments: SSO access to business applications</li><li>Attribute-Based Access Control (ABAC): Permission based on user’s attribute (tags)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img021246.png"></p><hr><h4 id="AWS-Directory-Services"><a href="#AWS-Directory-Services" class="headerlink" title="AWS Directory Services"></a>AWS Directory Services</h4><ul><li>Create Active Directory (AD, 目录服务) in AWS (重要)<ul><li>AWS Managed Microsoft AD: Create own AD in AWS</li><li>AD Connector: Proxy to redirect to On-Premise AD</li><li>Simple AD: AD-compatible managed directory on AWS</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img021607.png"></p><hr><h4 id="AWS-Control-Tower"><a href="#AWS-Control-Tower" class="headerlink" title="AWS Control Tower"></a>AWS Control Tower</h4><ul><li>Set up and govern a secure and compliant multi-account AWS environment (重要)<ul><li>管理 AWS 多账户环境, 而且是 Best Practice</li></ul></li><li>ControlTower use AWS Organizations to create accounts</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img021857.png"></p><ul><li>ControlTower - Guardrails (管理 ControlTower)<ul><li>Preventive Guardrail: Use SCPs (Restrict REgions across all accounts)</li><li>Detective Guardrail: Use AWS Config (identify untagged resources)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img022019.png"></p><hr><h3 id="23-AWS-Security-amp-Encryption"><a href="#23-AWS-Security-amp-Encryption" class="headerlink" title="23. AWS Security &amp; Encryption"></a>23. AWS Security &amp; Encryption</h3><h4 id="AWS-KMS"><a href="#AWS-KMS" class="headerlink" title="AWS KMS"></a>AWS KMS</h4><ul><li>Anytime you hear “encryption” for an AWS service, it’s most likely KMS</li><li>AWS managed encryption keys for us (Integrated with most AWS services)<ul><li>比如 EBS, S3, RDS, SSM (AWS managed keys),</li></ul></li><li>KMS Keys are scoped per Region</li><li>注意, KMS 并不适合保存 secret, 加密的东西不一定是 secret</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img170646.png"></p><ul><li>Types of KMS Keys (3 种): AWS Owned, AWS Managed, CMK (Custom Managed)</li><li>两种 Key 的形式: Symmetric (Single) &amp; Asymmetric (Public &amp; Private)</li><li>Automatic Key Rotation: 1 year</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img171058.png"></p><ul><li>KMS Key Policies (Control access to KMS keys)<ul><li>Default KMS Key Policy: Entire AWS account</li><li>Custom KMS Key Policy: Define who can access the key (Cross Account Access)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img171356.png"></p><blockquote><p>Deleting an AWS KMS key in AWS Key Management Service (AWS KMS) is destructive and potentially dangerous. Therefore, AWS KMS enforces a waiting period. (Pending state)</p></blockquote><hr><h4 id="KMS-Multi-Region-Keys"><a href="#KMS-Multi-Region-Keys" class="headerlink" title="KMS Multi-Region Keys"></a>KMS Multi-Region Keys</h4><ul><li>Identical KMS keys in different AWS Regions (在其他 Region 也能用同样的 KMS Key)<ul><li>Encrypt in one Region and decrypt in other Regions</li></ul></li><li>Use cases: DynamoDB Global Tables &amp; Global Aurora</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img172433.png"></p><hr><h4 id="S3-Replication-with-Encryption"><a href="#S3-Replication-with-Encryption" class="headerlink" title="S3 Replication with Encryption"></a>S3 Replication with Encryption</h4><ul><li>Unencrypted objects and objects encrypted with SSE-S3 are replicated by default</li><li>For objects encrypted with SSE-KMS, you need more options<ul><li>也就是说 SSE-S3 在复制的时候会保持, 但是 SSE-KMS 需要设置</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img172816.png"></p><hr><h4 id="Encrypted-AMI-Sharing-Process"><a href="#Encrypted-AMI-Sharing-Process" class="headerlink" title="Encrypted AMI Sharing Process"></a>Encrypted AMI Sharing Process</h4><ul><li>需要 Launch Permission, 需要 Share KMS Keys, 需要 Permission to decrypte<ul><li>反正只要知道 AMI 也是可以 Encrypt 并 Share 的</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img173020.png"></p><hr><h4 id="SSM-Parameter-Store"><a href="#SSM-Parameter-Store" class="headerlink" title="SSM Parameter Store"></a>SSM Parameter Store</h4><ul><li>Secure storage for configuration and secrets<ul><li>比起 Secrets Manager 有更广的用途, 比如 URLs, AMI IDs, License keys 等等</li></ul></li><li>Have built-in verion tracking (每次 edit secret 都会被记录)</li><li>SSM 没有 Automatic key rotation (重要)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img173611.png"></p><hr><h4 id="AWS-Secrets-Manager"><a href="#AWS-Secrets-Manager" class="headerlink" title="AWS Secrets Manager"></a>AWS Secrets Manager</h4><ul><li>Store secrets, integrated with RDS &amp; Aurora (非常重要, 存数据库 secrets 的)<ul><li>是给 confidential information (like database credentials, API keys) 用的</li><li>比起 SSM Parameter Store, Secrets Manager 支持 Key 的轮换 (90 天)</li><li>注意, Secret Manager 的 Key Rotateion 是 90 天, KMS 的 Key Rotateion 是一年</li></ul></li><li>比起 KMS, Secrets Manager 更适合去保存 secret, 比如 database credential, 而且 Secrets Manager 也有 Automatic key rotation</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img174132.png"></p><ul><li>Multi-Region Secrets (和 Multi-Region Key 类似)<ul><li>Replicate Secrets across multiple AWS Regions (disaster recovery)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img174258.png"></p><hr><h4 id="AWS-Certificate-Manager-ACM"><a href="#AWS-Certificate-Manager-ACM" class="headerlink" title="AWS Certificate Manager (ACM)"></a>AWS Certificate Manager (ACM)</h4><ul><li>Easily provision, manage, and deploy TLS Certificates (HTTPS)<ul><li>如果你要给 EB 上 HTTPS 就要用到 ACM</li><li>如果是 third party SSL 就没办法使用 automatic certificate rotation</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img174451.png"></p><ul><li>可以用 EventBridge 来检查 ACM Certificates 是否过期 (过期 Invoke SNS)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img172923.png"></p><hr><h4 id="AWS-WAF"><a href="#AWS-WAF" class="headerlink" title="AWS WAF"></a>AWS WAF</h4><ul><li>WAF: Web Application Firewall (防火墙)</li><li>Protect web application in Layer 7 (HTTP &#x2F; HTTPS)<ul><li>Layer 4 是 TCP &#x2F; UDP, Layer 3 处理 VPC 之类的</li></ul></li><li>如果要 block countries, 可以用 WAF Geo Match 或者 WAF IP Set Statement (重要)</li><li>WAF 可以设置 rate-based rules, Shield 不可以</li><li>如果需要在不同的 accout 或者 region 用 WAF, 考虑 Firewall Manager (重要)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img174857.png"></p><ul><li>Web ACL: 可以根据 IP, HTTP Headers, Size 来决定谁可以 Access<ul><li>也就是说, WAF 可以 block access from certain countries</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img175006.png"></p><blockquote><p>If you want to use AWS WAF across accounts, accelerate WAF configuration, automate the protection of new resources, use Firewall Manager with AWS WAF</p></blockquote><hr><h4 id="AWS-Shield"><a href="#AWS-Shield" class="headerlink" title="AWS Shield"></a>AWS Shield</h4><ul><li>Protect from DDoS attack (WAF 也可以, 但是考试遇到 DDoS 的时候选 Shield)</li><li>有 Shield Standard (免费) 和 Shield Advanced (付费)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img175302.png"></p><hr><h4 id="AWS-Firewall-Manager"><a href="#AWS-Firewall-Manager" class="headerlink" title="AWS Firewall Manager"></a>AWS Firewall Manager</h4><ul><li>Manage security rules in all accounts of an AWS Organization<ul><li>比如 WAF rules, AWS Shield Advanced, Security Group for EC2 &amp; VPC 等等</li></ul></li><li>Rules are applied to new resources as they are created</li><li>如果需要在不同的 accout 或者 region 用 WAF, 考虑 Firewall Manager (重要)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img175531.png"></p><ul><li>WAF vs Firewall Manager vs Shield<ul><li>它们一起用来做大型安全保护 (WAF + Firewall Manager + Shield)</li><li>如果只是日常保护, 就用 WAF</li><li>如果遇到 DDoS 攻击, 考虑使用 Shield</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img175631.png"></p><hr><h4 id="AWS-GuardDuty"><a href="#AWS-GuardDuty" class="headerlink" title="AWS GuardDuty"></a>AWS GuardDuty</h4><ul><li>Intelligent threat discovery (ML) to protect AWS account (用 ML 防止加密攻击)<ul><li>Input data: CloudTrail, VPC, DNS (重要)</li></ul></li><li>Use case: CryptoCurrency attacks</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img175935.png"></p><hr><h4 id="AWS-Inspector"><a href="#AWS-Inspector" class="headerlink" title="AWS Inspector"></a>AWS Inspector</h4><ul><li>Automated Security Assessments (自动安全评估)<ul><li>EC2 Instance &amp; Container Images (ECR) &amp; Lambda Functions</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img180110.png"></p><hr><h4 id="AWS-Macie"><a href="#AWS-Macie" class="headerlink" title="AWS Macie"></a>AWS Macie</h4><ul><li>Use ML to protect sensitive data (PII) in AWS (用 ML 保护敏感信息)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img180224.png"></p><hr><h3 id="24-Networking-VPC"><a href="#24-Networking-VPC" class="headerlink" title="24. Networking VPC"></a>24. Networking VPC</h3><ul><li>CIDR &#x3D; Base IP + Subnet Mask<ul><li>例子: CIDR 10.0.4.0&#x2F;28, &#x2F;28 代表 16 IPs &#x3D; (2^(32-28) &#x3D; 2^4), 8 的倍数大过 28 只有 32, 所以答案是 10.0.4.0 到 10.0.4.15 (0-15 一共有 16 个)</li></ul></li><li>CIDR should not overlap, max CIDR size in AWS is &#x2F;16, min CIDR size in AWS is &#x2F;28</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img002822.png"></p><hr><h4 id="AWS-VPC"><a href="#AWS-VPC" class="headerlink" title="AWS VPC"></a>AWS VPC</h4><ul><li>VPC: Virtual Private Cloud<ul><li>All new AWS account have a default VPC</li></ul></li><li>CIDR should not overlap, max CIDR size in AWS is &#x2F;16, min CIDR size in AWS is &#x2F;28</li><li>要让 VPC 使用 custom domain 需要 enableDnsHostnames 和 enableDnsSupport</li><li>可以创建 Shared Service VPC, 这样每个 VPC 都可以 access 到需要的 services (重要)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img201530.png"></p><ul><li>Each Amazon EC2 instance that you launch into a VPC has a tenancy attribute (重要)<ul><li>可以在 dedicated 和 host 之间互相切换</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img042420.png"></p><hr><h4 id="VPC-Subnet"><a href="#VPC-Subnet" class="headerlink" title="VPC Subnet"></a>VPC Subnet</h4><ul><li>Can have Public Subnet and Private Subnet</li><li>AWS reserves 5 IP addresses in each subnet (first 4 &amp; last 1, 重要)<ul><li>记得前四个是从 0 开始算的, 也就是 0 - 3</li><li>比如我要做一个可以处理 28 个的, 我需要 28 + 5 + 26 + 5 &#x3D; 64</li></ul></li><li>Subnet is always associated with Route Table (重要)<ul><li>问关于 Subnet 的问题就和 Route Table 没有关系</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img201819.png"></p><hr><h4 id="Internet-Gateway-IGW-amp-Route-Table"><a href="#Internet-Gateway-IGW-amp-Route-Table" class="headerlink" title="Internet Gateway (IGW) &amp; Route Table"></a>Internet Gateway (IGW) &amp; Route Table</h4><ul><li>IGW allow resource (eg. EC2 Instance) in a VPC connect to internet<ul><li>相当于让 VPC 里的 resource 可以连上网</li><li>IGW 需要 Route Table (重要)</li></ul></li><li>如果 IGW 出问题<ul><li>Need to also have Route Table (首先检查 Route Table, 因为 IGW 需要)</li><li>检查 Security Group 是否允许通过</li></ul></li><li>处理 Network Address Translation 的就是 Internet Gateway</li><li>Internet Gateway 无法直接在 private subnet 里面使用 (重要)</li><li>NAT 针对的是 Subnet 层面, IGW 针对的是 VPC 层面 (重要)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img202043.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img193121.png"></p><hr><h4 id="Bastion-Hosts"><a href="#Bastion-Hosts" class="headerlink" title="Bastion Hosts"></a>Bastion Hosts</h4><ul><li>Use Bastion Host to SSH into private EC2 instance (SSH 进入 EC2)</li><li>Bastion Host is in the public subnet and is connected to the private subnet<ul><li>简单来说就是 Public Internet 到 Private Subnet</li></ul></li><li>Bastion Host security group must restrict internet access (port 22)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img202553.png"></p><blockquote><p>Create a public Network Load Balancer that links to Amazon EC2 instances that are bastion hosts managed by an Auto Scaling Group</p></blockquote><hr><h4 id="NAT-Instances-Outdated"><a href="#NAT-Instances-Outdated" class="headerlink" title="NAT Instances (Outdated)"></a>NAT Instances (Outdated)</h4><ul><li>NAT: Network Address Translation</li><li>Allow EC2 Instance in Private Subnet to connect to the Internet<ul><li>但现在都是用 NAT Gateway (NAT Gateway is the prefered solution now)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img202940.png"></p><ul><li>NAT instance can be used as a bastion server</li><li>Security Groups can be associated with a NAT instance</li><li>NAT instance supports port forwarding</li></ul><hr><h4 id="NAT-Gateway-NATGW"><a href="#NAT-Gateway-NATGW" class="headerlink" title="NAT Gateway (NATGW)"></a>NAT Gateway (NATGW)</h4><ul><li>AWS managed NAT, AZ specific, use Elastic IP (针对 IPv4, Egress 是 IPv6)<ul><li>Allow EC2 Instance in Private Subnet to connect to the Internet</li><li>Requires an IGW, NATGW 是处于 public subnet 的 (注意)</li></ul></li><li>NAT 针对的是 Subnet 层面, IGW 针对的是 VPC 层面</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img203409.png"></p><ul><li>Resilient within single AZ, Multiple-AZ need multiple NATGW<ul><li>每个 AZ 都要一个 NATGW, 用来 fault-tolerance (容错能力)</li></ul></li><li>Highly availiable within AZ (create in another AZ)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img203654.png"></p><hr><h4 id="NACL-amp-Security-Groups"><a href="#NACL-amp-Security-Groups" class="headerlink" title="NACL &amp; Security Groups"></a>NACL &amp; Security Groups</h4><ul><li>The request has to go over NACL before go to Subnet (Subnet level)<ul><li>NACL is stateless (inbound outbound 都要检测)</li></ul></li><li>The request has to go over Security Group before go to EC2 Instance (Instance level)<ul><li>Security Group (SG) is stateful (inbound accepted &#x3D; outbound accepted)</li></ul></li><li>反正记住 NACL 是 Subnet level (stateless), Security Group 是 Instance level (stateful)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img204310.png"></p><ul><li>Network Access Control List (NACL)<ul><li>NACL control traffic from and to subnets (eg. block IP)</li><li>One NACL per subnet, each subnet have default NACL (注意)<ul><li>Default NACL accept every inbound and outbound</li></ul></li><li>NACL Rules have number, higher precedence with lower number (越优先数字越低)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img204553.png"></p><hr><h4 id="VPC-Peering-amp-Sharing"><a href="#VPC-Peering-amp-Sharing" class="headerlink" title="VPC Peering &amp; Sharing"></a>VPC Peering &amp; Sharing</h4><ul><li>VPC Peering: Privately connect two VPCs using AWS network (只适合少量 VPC, 重要)<ul><li>每一对 VPC 都要 VPC Peering, 和 S3 Replication 类似</li></ul></li><li>Can create VPC Peering between VPCs in different AWS accounts &#x2F; regions</li><li>Need to update Route Table in each VPC subnet to make sure they can communicate<ul><li>出问题就检查 Route Table</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img205313.png"></p><ul><li>VPC Sharing: Allows multiple AWS accounts to create resources (eg. EC2, RDS) into shared and centrally-managed AWS VPC (重要)<ul><li>遇到 centrally managed 的就是 VPC Sharing</li><li>而且是 owner 需要 share one or more subnet (注意)</li></ul></li></ul><hr><h4 id="VPC-Endpoints-AWS-PrivateLink"><a href="#VPC-Endpoints-AWS-PrivateLink" class="headerlink" title="VPC Endpoints (AWS PrivateLink)"></a>VPC Endpoints (AWS PrivateLink)</h4><ul><li>VPC Endpoints allow private access to AWS services within a VPC (重要)<ul><li>用 Private Network 连接 AWS 服务, 和 On-Premise 没有关系</li><li>Interface Endpoint 支持大部分 AWS 服务 (付费)</li><li>Gateway Endpoint 只支持 S3 和 DynamoDB (很容易考, 免费)</li></ul></li><li>注意, VPC Gateway Endpoint 专门处理 S3 和 DynamoDB (不要去选择 NAT 或者 IGW)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img205719.png"></p><ul><li>两种 Types of Endpoints (Interface &#x2F; Gateway)<ul><li>Interface Endpoints: Supports most AWS services (付费)</li><li>Gateway Endpoints: Must be used as a target in a route table (免费, 重要)<ul><li>Only support S3 and DynamoDB (只支持 S3 和 DynamoDB)</li></ul></li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img205939.png"></p><hr><h4 id="VPC-Flow-Logs"><a href="#VPC-Flow-Logs" class="headerlink" title="VPC Flow Logs"></a>VPC Flow Logs</h4><ul><li>Capture information about IP traffic going into interfaces (监视 IP 流量的)<ul><li>Monitor &amp; troubleshoot connectivity issues (网络连接问题)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img231819.png"></p><hr><h4 id="Site-to-Site-VPN-VPN-Connection"><a href="#Site-to-Site-VPN-VPN-Connection" class="headerlink" title="Site-to-Site VPN (VPN Connection)"></a>Site-to-Site VPN (VPN Connection)</h4><ul><li>Site-to-Site VPN: Connect AWS to Corporate Data Center over public internet (重点, public internet, On-Premise to AWS)<ul><li>Need a Virtual Private Gateway (VGW) on VPC (AWS 方)</li><li>Need a Customer Gateway (CGW) on DC (On-Premise 方)</li></ul></li><li>对比 DX, Site-to-Site VPN 没有提供 low latency, and high throughput connection</li><li>Site-to-Site VPN 有 encrypted network connectivity between On-Premise and VPC</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img232320.png"></p><ul><li>需要 VPN Gateway 和 Customer Gateway 来连接 VPC 和 On-Premise</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img232649.png"></p><hr><h4 id="VPN-CloudHub"><a href="#VPN-CloudHub" class="headerlink" title="VPN CloudHub"></a>VPN CloudHub</h4><ul><li>Provide secure communication for multiple VPN Connections (Site-to-Site VPN)<ul><li>在需要管理多个 Site-to-Site VPN 的时候</li><li>可以作为 backup connection 使用 public internet 去防止 failover</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img202141.png"></p><blockquote><p>If you have multiple AWS Site-to-Site VPN connections, you can provide secure communication between sites using the AWS VPN CloudHub.</p></blockquote><hr><h4 id="Direct-Connect-DX"><a href="#Direct-Connect-DX" class="headerlink" title="Direct Connect (DX)"></a>Direct Connect (DX)</h4><ul><li>Provide a dedicated private connection from a remote network to VPC (重点, private internet, On-Premise to AWS)<ul><li>需要设置 VGW, 如果给 DX 找 backup, 那么就选择 Site-to-Site VPN (这两个服务类似)</li><li>对比 Site-to-Site VPN, DX provide low latency, and high throughput connection</li><li>DX 不支持 encrypted network connectivity, Site-to-Site VPN 可以, 但是如果需要 encrypt DX connection 可以和 AWS VPN 一起用 (注意)</li><li>DX 的 set up 时间很长 (所以 DX 不算什么 quick solution)</li></ul></li><li>All private, no public network involve (注意, 如果问到 all Private 就是 DX)<ul><li>Direct Connect does not involve the Internet</li></ul></li><li>可以 access public resources (S3) 和 private resources (EC2)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img233024.png"></p><ul><li>两种 Connection Type (带宽选项, Dedicated 最快)<ul><li>Dedicated Connections: 1Gbps 到 100Gbps</li><li>Hosted Connections: 50Mbps 到 10 Gbps</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img004140.png"></p><ul><li>Direct Connect Gateway (连接许多 VPC 在不同的 Region)<ul><li>Direct Connection to one or more VPC in many different regions</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img233531.png"></p><ul><li><p>PrivateLink vs DX</p><ul><li><p>AWS PrivateLink provides a connection between VPCs (Virtual Private Clouds) and AWS services while bypassing the public Internet. It is a private network connection that securely transfers data without leaving the AWS network</p></li><li><p>AWS Direct Connect is a dedicated, private connection between the customer’s on-premises infrastructure at a data center and an AWS location. The main features of the connection are ultra-fast data transfer rates, low latency, and improved security since it bypasses the public Internet</p></li></ul></li></ul><hr><h4 id="Transite-Gateway"><a href="#Transite-Gateway" class="headerlink" title="Transite Gateway"></a>Transite Gateway</h4><ul><li>Have transitive peering between thousands of VPCs, On-Premise 等等 (重要)<ul><li>Regional resource, 可以 Cross-Region (Transite Gateway 连接了大量的 VPC)</li><li>可以通过 ECMP 去 maximize the VPN throughput (重要)</li></ul></li><li>Support IP Multicast, IP 多播可以在单次传输中向一组感兴趣的接收者发送互联网协议</li><li>如果问到关于 star network 或者 hub-and-spoke 的就是 Transite Gateway</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img334237.png"></p><ul><li>Site-to-Site VPN ECMP (重要)<ul><li>ECMP &#x3D; Equal-cost multi-path routing (increase bandwidth)</li><li>路由策略, 将数据包转发到单个目的地可以通过具有相同路由优先级的多条最佳路径</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img234354.png"></p><hr><h4 id="VPC-Traffic-Mirroring"><a href="#VPC-Traffic-Mirroring" class="headerlink" title="VPC Traffic Mirroring"></a>VPC Traffic Mirroring</h4><ul><li>Capture and inspect network traffic in VPC (监测 VPC 网络流量)</li><li>Use cases: content inspection, threat monitoring 等等</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img002627.png"></p><hr><h4 id="IPv6-in-VPC"><a href="#IPv6-in-VPC" class="headerlink" title="IPv6 in VPC"></a>IPv6 in VPC</h4><ul><li>IPv4 cannot be disabled for VPC and subnets</li><li>Eg. EC2 Instance get at least 1 private IPv4 and a public IPv6<ul><li>所以如果无法启动 EC2 Instance, 那么 IPv4 一定有问题</li><li>Create a new IPv4 CIDR in subnet (注意)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img001017.png"></p><hr><h4 id="Egress-only-Internet-Gateway"><a href="#Egress-only-Internet-Gateway" class="headerlink" title="Egress-only Internet Gateway"></a>Egress-only Internet Gateway</h4><ul><li>Use for IPv6 only (Similar to NAT Gateway, but NATGW only for IPv4)<ul><li>只允许 outbound connection 从 VPC 到 Internet, 不允许 inbound 从 Internt 到 VPC</li><li>也需要 Update Route Table</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img001334.png"></p><hr><h4 id="AWS-Network-Firewall"><a href="#AWS-Network-Firewall" class="headerlink" title="AWS Network Firewall"></a>AWS Network Firewall</h4><ul><li>Protect entire AWS VPC (相当于 VPC 的防火墙, 千万要记住)<ul><li>From Layer 3 to Layer 7 protection (全方面, 重要)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img002037.png"></p><ul><li>Have traffic filtering: Allow, drop, or alert traffic that match the rules</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img002200.png"></p><ul><li>AWS Network Firewall is a managed firewall service that provides filtering for both inbound and outbound network traffic. It allows you to create rules for traffic inspection and filtering, which can help protect your production VPC</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img234322.png"></p><hr><h3 id="25-Disaster-Recovery-amp-Migrations"><a href="#25-Disaster-Recovery-amp-Migrations" class="headerlink" title="25. Disaster Recovery &amp; Migrations"></a>25. Disaster Recovery &amp; Migrations</h3><h4 id="Disaster-Recovery"><a href="#Disaster-Recovery" class="headerlink" title="Disaster Recovery"></a>Disaster Recovery</h4><ul><li>RPO: Recovery Point Objective (这段时间的数据丢失)</li><li>RTO: Recovery Time Objective (这段时间 App 停机)</li><li>遇到 DR 就应该去想 Multi-Region 的处理方法 (注意)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img002206.png"></p><ul><li>Disaster Recovery Startegies<ul><li>Backup and Restore: High RPO &amp; RTO, 将 On-Premise 数据备份在 Cloud 上</li><li>Pilot Light: 一部分 app 在 Cloud 上跑 (Only the critical infrastructure)<ul><li>注意, 遇到有提到 DR (Disaster Recovery) with minimum 的就是 Pilot Light</li></ul></li><li>Warm Standby: 一部分 app 在 Cloud 上跑 (Scale-down version, scale-up quickly)<ul><li>注意, 遇到有提到 DR (Disaster Recovery) with scale-down 的就是 Warm Standby</li></ul></li><li>Multi-Site: Every Low RTO &amp; RPO, 全部 app 在 Cloud 上跑 (最贵)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img142543.png"></p><hr><h4 id="Database-Migration-Service-DMS"><a href="#Database-Migration-Service-DMS" class="headerlink" title="Database Migration Service (DMS)"></a>Database Migration Service (DMS)</h4><ul><li>Migrate database to AWS (将数据库迁移到 AWS, 非常重要)</li><li>Support Homogeneous migration &amp; Heterogeneous migration<ul><li>Homogeneous 就是相同的数据库类型, Heterogeneous 就是不同的数据库类型</li></ul></li><li>Need to have an EC2 Instance to perform DMS to make it work</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img143551.png"></p><ul><li>AWS Schema Conversion Tool (SCT, 重要)<ul><li>Covert Database Schema from one engine to another (如果要迁移的数据库类型不同)</li><li>If same DB engine, don’t need SCT (比如 PostgreSQL 到 AWS RDS PostgreSQL)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img143914.png"></p><ul><li>DMS Multi-AZ Deployement<ul><li>DMS provisions and maintains a synchronously stand replica in different AZ</li><li>相当于你在数据库迁移的时候可以在另外一个 AZ 有一个备份</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img144109.png"></p><hr><h4 id="RDS-amp-Aurora-Migration"><a href="#RDS-amp-Aurora-Migration" class="headerlink" title="RDS &amp; Aurora Migration"></a>RDS &amp; Aurora Migration</h4><ul><li>RDS MySQL to Aurora MySQL (PostgreSQL 也是一样的道理)<ul><li>Op1. DB Snapshots from RDS MySQL restored as Aurora MySQL</li><li>Op2. Create Aurora Read Replica from RDS MySQL</li></ul></li><li>External MySQL to Aurora MySQL<ul><li>Op1. Create backup file in S3, and create Aurora MySQL from S3</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img144459.png"></p><hr><h4 id="On-Premise-Strategy-with-AWS"><a href="#On-Premise-Strategy-with-AWS" class="headerlink" title="On-Premise Strategy with AWS"></a>On-Premise Strategy with AWS</h4><ul><li>AWS Application Discovery Service (DS)</li><li>AWS Database Migration Service (DMS)</li><li>AWS Server Migration Service (SMS)</li><li>VM Import &amp; Export (以上这些都要依赖 On-Premise)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img145118.png"></p><hr><h4 id="AWS-Backup"><a href="#AWS-Backup" class="headerlink" title="AWS Backup"></a>AWS Backup</h4><ul><li>Fully managed service to automate backups across AWS services (做备份的, 重要)<ul><li>支持 EC2, EBS, S3, RDS, EFS 等等</li></ul></li><li>Support Cross-Region backups and Cross-Account backups</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img145310.png"></p><ul><li>AWS Backup Valut Lock (相当于给 backup 上锁)<ul><li>Enforce a WORM state for all backups (意思就是所有 backup 都删不了)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img145549.png"></p><hr><h4 id="Application-Migration-Service-MGN"><a href="#Application-Migration-Service-MGN" class="headerlink" title="Application Migration Service (MGN)"></a>Application Migration Service (MGN)</h4><ul><li>AWS Application Discovery Service (相当于在 MGN 之前要先做计划)<ul><li>Plan migration projects by gathering information about On-Premise data centers</li><li>有 Agentless Discovery 和 Agent-based Discovery</li></ul></li><li>Result is viewed in AWS Migration Hub</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img145820.png"></p><ul><li>AWS Application Migration Service (MGN)<ul><li>Simplify migrating applications to AWS (将 App 迁移到 AWS)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img145954.png"></p><hr><h4 id="VMware-Cloud-on-AWS"><a href="#VMware-Cloud-on-AWS" class="headerlink" title="VMware Cloud on AWS"></a>VMware Cloud on AWS</h4><ul><li>Use VMware Cloud to manage and extend On-Premise Data Center</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img150508.png"></p><hr><h3 id="26-More-SAA"><a href="#26-More-SAA" class="headerlink" title="26. More SAA"></a>26. More SAA</h3><h4 id="Event-Processing"><a href="#Event-Processing" class="headerlink" title="Event Processing"></a>Event Processing</h4><ul><li>Fan Out Pattern: Have SNS in the middle and subscribe to multiple SQS (重要)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img185229.png"></p><ul><li>S3 Event Notifications: Trigger Lambda or SNS when S3 event happen (在第十一章)<ul><li>如果遇到需要 set up DLQ (Dead Letter Queue), 选择 Lambda</li><li>DLQ 是处理当 message 没有办法被 processed (consumed) successfully</li></ul></li><li>也可以和 EventBridge 一起用, 有 advanced filtering<ul><li>EventBridge 可以和 CloudTrail 一起用来 Intercept API call</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img185348.png"></p><hr><h4 id="Caching-Strategies"><a href="#Caching-Strategies" class="headerlink" title="Caching Strategies"></a>Caching Strategies</h4><ul><li>Cache: 离用户越近越快, 但是可能 outdated, 所以需要 TTL (Time to Live)</li><li>API Gateway: Regional Caching (因为 API Gateway 是 Regional 的)</li><li>App Logic: 防止频繁调用数据库</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img185932.png"></p><hr><h4 id="Block-IP-Address"><a href="#Block-IP-Address" class="headerlink" title="Block IP Address"></a>Block IP Address</h4><ul><li>NACL: Decline the client IP</li><li>WAF: IP address filtering</li><li>总之, 可以用 NACL 在处理, 也可以用 WAF 处理 (二者选一, 但是一般选择 WAF)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img190513.png"></p><hr><h4 id="HPC-in-AWS"><a href="#HPC-in-AWS" class="headerlink" title="HPC in AWS"></a>HPC in AWS</h4><ul><li>Cloud is the perfect place to perform HPC (High Performance Computing)</li><li>Data Management &amp; Transfer (数据处理和迁移)<ul><li>AWS Direct Connect, Snowball, AWS DataSync</li></ul></li><li>提到 HPC 就应该想到 EFA, Cluster Placement, FSx Lustre</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img190820.png"></p><ul><li>Compute &amp; Networking<ul><li>EC2 Instance + EC2 Placement Group (Cluster, 因为 network 快)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img190944.png"></p><ul><li>Compute &amp; Networking (Cont.)<ul><li>EC2 Enhanced Networking (SR-IOV): 需要 Elastic Network Adapter (ENA)</li><li>Elastic Fabric Adapter (EFA): Improved ENA for HPC, only work for Linux</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img191112.png"></p><ul><li>Storage<ul><li>Instance-attached storage: EBS, Instance Store</li><li>Network storage: S3, EFS, FSx</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img191328.png"></p><ul><li>Automation &amp; Orchestration<ul><li>AWS Batch: Run multi-node pararllel jobs in multiple EC2 instances</li><li>AWS ParallelCluster: Deploy HPC on AWS, can enable EFA on cluster</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img191502.png"></p><hr><h4 id="EC2-Instance-High-Availability"><a href="#EC2-Instance-High-Availability" class="headerlink" title="EC2 Instance High Availability"></a>EC2 Instance High Availability</h4><ul><li>Elastic IP + Standby EC2 Instance + CloudWatch + Lambda<ul><li>当 failover, 转到 standby EC2 Instance</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img191841.png"></p><ul><li>Elastic IP + Auto Scaling Group (min, max)<ul><li>当 failover, 有 replacement EC2 Instance (不需要 CloudWatch 了)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img192115.png"></p><hr><h3 id="27-Other-AWS-Services"><a href="#27-Other-AWS-Services" class="headerlink" title="27. Other AWS Services"></a>27. Other AWS Services</h3><h4 id="AWS-CloudFormation"><a href="#AWS-CloudFormation" class="headerlink" title="AWS CloudFormation"></a>AWS CloudFormation</h4><ul><li>A declarative way of outlining AWS Infrastructure (相当于有一个模板帮你生成你想要的)<ul><li>需要什么 (eg. EC2 Instance, S3), CloudFormation 给你 create 什么</li><li>CloudFormation 是 IaaS (Infrastructure as a Service)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img003448.png"></p><ul><li>Infrastructure as a Service (IaaS, no need to manually create)</li><li>Good if we need to repeat architecture in different environment</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img003657.png"></p><hr><h4 id="CloudFormation-StackSets"><a href="#CloudFormation-StackSets" class="headerlink" title="CloudFormation StackSets"></a>CloudFormation StackSets</h4><ul><li>使用 StackSets, 如果需要 cross account 或者 region 去使用 CloudFormation</li><li>AWS CloudFormation StackSet extends the functionality of stacks by enabling you to create, update, or delete stacks across multiple accounts and regions with a single operation</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img013227.png"></p><hr><h4 id="CloudFormation-Service-Role"><a href="#CloudFormation-Service-Role" class="headerlink" title="CloudFormation Service Role"></a>CloudFormation Service Role</h4><ul><li>Service Role: IAM role that allows CloudFormation to create &#x2F; update &#x2F; delete resource</li><li>Give ability to user to do the above (安全方面)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img004103.png"></p><hr><h4 id="AWS-SES-Simple-Email-Service"><a href="#AWS-SES-Simple-Email-Service" class="headerlink" title="AWS SES (Simple Email Service)"></a>AWS SES (Simple Email Service)</h4><ul><li>Managed service to send email securely (发邮件的)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img004334.png"></p><hr><h4 id="AWS-Pinpoint"><a href="#AWS-Pinpoint" class="headerlink" title="AWS Pinpoint"></a>AWS Pinpoint</h4><ul><li>Scalable 2-way (outbound &#x2F; inbound) marketing communication serivce (重要)<ul><li>给客户发消息用的</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img004519.png"></p><hr><h4 id="AWS-SSM-Session-Manager"><a href="#AWS-SSM-Session-Manager" class="headerlink" title="AWS SSM Session Manager"></a>AWS SSM Session Manager</h4><ul><li>SSM Session Manager: Systems Manager Session Manager</li><li>Allow to start a secure shell on EC2 and On-Premise (更好的从 On-Premise access EC2)<ul><li>No need SSH access (Better security)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img004759.png"></p><hr><h4 id="AWS-Cost-Explorer"><a href="#AWS-Cost-Explorer" class="headerlink" title="AWS Cost Explorer"></a>AWS Cost Explorer</h4><ul><li>Visualize &amp; manage AWS costs and usage over time (可以生成消费报告)</li><li>Can choose a optimal Saving Plan</li><li>如果问和钱相关的很大程度就是 Cost Explorer (重要)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img005425.png"></p><hr><h4 id="AWS-Compute-Optimizer"><a href="#AWS-Compute-Optimizer" class="headerlink" title="AWS Compute Optimizer"></a>AWS Compute Optimizer</h4><ul><li>简单来说, Cost Explorer + Compute Optimizer 一起就是来省钱的</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img173241.png"></p><blockquote><p>AWS Compute Optimizer recommends optimal AWS Compute resources for your workloads to reduce costs and improve performance by using machine learning to analyze historical utilization metrics.</p></blockquote><hr><h4 id="AWS-Batch"><a href="#AWS-Batch" class="headerlink" title="AWS Batch"></a>AWS Batch</h4><ul><li>Managed batch processing at any scale (批量处理)<ul><li>Batch can dynamically launch EC2 Instance or Spot Instance</li></ul></li><li>Batch jobs are defined as Docker images and run on ECS</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img005610.png"></p><ul><li>Batch vs Lambda<ul><li>Lambda: Time limit, Serverless</li><li>Batch: No time limit, Not Serverless</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img005741.png"></p><hr><h4 id="AWS-AppFlow"><a href="#AWS-AppFlow" class="headerlink" title="AWS AppFlow"></a>AWS AppFlow</h4><ul><li>Transfer data between Software-as-a-Service (SaaS) applications and AWS (重要)<ul><li>如果题目问到 SaaS 就要想起 AppFlow</li><li>Source: Salesforce, Slack 等等 (遇到 SaaS 就是 AppFlow)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img005910.png"></p><hr><h4 id="AWS-Amplify"><a href="#AWS-Amplify" class="headerlink" title="AWS Amplify"></a>AWS Amplify</h4><ul><li>A set of tools to develop and deploy full stack web and mobile application<ul><li>搭建全栈项目的</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img010043.png"></p><hr><h4 id="AWS-Resource-Access-Manager-RAM"><a href="#AWS-Resource-Access-Manager-RAM" class="headerlink" title="AWS Resource Access Manager (RAM)"></a>AWS Resource Access Manager (RAM)</h4><ul><li>RAM is a service that enables easily and securely share AWS resources with any AWS account or within AWS Organization. (eg. Transite Gateway, Subnets)<ul><li>选择 RAM 的主要原因是它便宜</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img043006.png"></p><hr><h4 id="AWS-Systems-Manager"><a href="#AWS-Systems-Manager" class="headerlink" title="AWS Systems Manager"></a>AWS Systems Manager</h4><ul><li>AWS Systems Manager is an AWS service that you can use to view and control your infrastructure on AWS (比如 group resources, eg. EC2, S3 等等)</li><li>Use AWS Systems Manager Run Command to run a custom command that applies the patch to all EC2 instances</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img013522.png"></p><hr><h3 id="28-WhitePapers"><a href="#28-WhitePapers" class="headerlink" title="28. WhitePapers"></a>28. WhitePapers</h3><ul><li>Well Architected Framework: 有 6 个 Pillars 要记</li><li>Operational Excellence (运营) + Security (安全) + Reliability (可靠) + Performance Efficiency (性能效率) + Cost Optimization (省钱) + Sustainability (持续发展)</li><li>Maximum resilience is achieved by separate connections terminating on separate devices in more than one location</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img911011.png"></p><ul><li>AWS Well-Architected Tool<ul><li>Review architectures against 6 pillars (best practice)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img010508.png"></p><hr><h4 id="AWS-Trusted-Advisor"><a href="#AWS-Trusted-Advisor" class="headerlink" title="AWS Trusted Advisor"></a>AWS Trusted Advisor</h4><ul><li>High level AWS account assessment (AWS 账户评估)<ul><li>Learn the best practices on cost optimization, performance, and security</li></ul></li><li>根据上面的 6 Pillars 来判断 (要记住)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img010724.png"></p><hr><h3 id="29-Extra"><a href="#29-Extra" class="headerlink" title="29. Extra"></a>29. Extra</h3><ul><li><p>DNS queries</p><ul><li>To resolve any DNS queries for resources in the AWS VPC from the on-premises network, you can create an inbound endpoint on Amazon Route 53 Resolver and then DNS resolvers on the on-premises network can forward DNS queries to Amazon Route 53 Resolver via this endpoint.</li><li>To resolve DNS queries for any resources in the on-premises network from the AWS VPC, you can create an outbound endpoint on Amazon Route 53 Resolver and then Amazon Route 53 Resolver can conditionally forward queries to resolvers on the on-premises network via this endpoint.</li></ul></li><li><p>EC2 Instance recover from impaired state</p><ul><li>A recovered instance is identical to the original instance, including the instance ID, private IP addresses, Elastic IP addresses, and all instance metadata</li><li>If your instance has a public IPv4 address, it retains the public IPv4 address after recovery</li></ul></li><li><p>Spot Instance &amp; Spot Fleet</p><ul><li>If a spot request is persistent, then it is opened again after your Spot Instance is interrupted</li><li>Spot Fleets can maintain target capacity by launching replacement instances after Spot Instances in the fleet are terminated</li><li>When you cancel an active spot request, it does not terminate the associated instance</li></ul></li><li><p>Improve the security at the authentication level by leveraging short-lived credentials</p><ul><li>Use IAM authentication from AWS Lambda to Amazon RDS PostgreSQL</li><li>Attach an AWS Identity and Access Management (IAM) role to AWS Lambda</li></ul></li><li><p>Only root user account can do</p><ul><li>Some of the AWS tasks that only a root account user can do are as follows: change account name or root password or root email address, change AWS support plan, close AWS account, enable AWS Multi-Factor Authentication (AWS MFA) on S3 bucket delete, create Cloudfront key pair, register for GovCloud.</li></ul></li></ul><hr><h3 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h3><blockquote><p>请勿随意修改, 谢谢</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Certification </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AWS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AWS CLF-C02</title>
      <link href="/posts/ced5b880.html"/>
      <url>/posts/ced5b880.html</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><ul><li>官网: <a href="https://aws.amazon.com/certification/certified-cloud-practitioner/">https://aws.amazon.com/certification/certified-cloud-practitioner/</a></li></ul></blockquote><hr><h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><p>重点: Pay-as-you-go，on-demand delivery<br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img105337.png"></p><ul><li>There are three fundamental drivers of cost with AWS: compute, storage, and outbound data transfer. In most cases, there is no charge for inbound data transfer or data transfer between other AWS services within the same region.</li></ul><hr><h4 id="Types-of-Cloud-Computing"><a href="#Types-of-Cloud-Computing" class="headerlink" title="Types of Cloud Computing"></a>Types of Cloud Computing</h4><p>重点: 3 types of cloud computing</p><ul><li>IaaS: 比如 EC2</li><li>PaaS: 比如 Elastic Beanstalk</li><li>SaaS: 比如 Rekognition</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img110812.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img110945.png"></p><hr><h4 id="Six-Advantages-of-Cloud-Computing"><a href="#Six-Advantages-of-Cloud-Computing" class="headerlink" title="Six Advantages of Cloud Computing"></a>Six Advantages of Cloud Computing</h4><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img084401.png"></p><hr><h4 id="AWS-Global-Infrastructure"><a href="#AWS-Global-Infrastructure" class="headerlink" title="AWS Global Infrastructure"></a>AWS Global Infrastructure</h4><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img114544.png"></p><p>AWS Region</p><ul><li>A region is a cluster of data centers</li><li>一个 Region 至少有三个 AZ</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img114639.png"></p><p>AWS Availability Zones</p><ul><li>Each availiablity zone (AZ) is one or more discrete data centers in the same location</li><li>AZ 组合起来就是 Region</li><li>All traffic between Availability Zones (AZ) is encrypted</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img114958.png"></p><p>AWS Points of Presence (Edge Locations)</p><ul><li>Content is delivered to end users with low latency</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img115255.png"></p><hr><h4 id="AWS-Shared-Responsibility-Model"><a href="#AWS-Shared-Responsibility-Model" class="headerlink" title="AWS Shared Responsibility Model"></a>AWS Shared Responsibility Model</h4><ul><li>AWS 负责什么，Customer 负责什么</li><li>AWS is responsible for Security “of” the Cloud</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img120115.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img103332.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img103410.png"></p><hr><h3 id="1-Identity-and-Access-Management"><a href="#1-Identity-and-Access-Management" class="headerlink" title="1. Identity and Access Management"></a>1. Identity and Access Management</h3><h4 id="IAM-Users-amp-Group"><a href="#IAM-Users-amp-Group" class="headerlink" title="IAM Users &amp; Group"></a>IAM Users &amp; Group</h4><ul><li>Global service</li><li>Root account: don’t share with others</li><li>Root user access credentials are the email address and password used to create the AWS account</li><li>Users: people within organization</li><li>Groups: a group of people</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img134540.png"></p><p>IAM Permissions</p><ul><li>least privilege principle</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img134928.png"></p><h4 id="IAM-Policies"><a href="#IAM-Policies" class="headerlink" title="IAM Policies"></a>IAM Policies</h4><ul><li>Inline Policy 是 Attach 给个人的 Policy</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img135808.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img140013.png"></p><p>IAM Password Policy &amp; MFA</p><ul><li>MFA 是 Root Account 的 Best Practice</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img142523.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img142218.png"></p><p>AWS Access Keys &amp; CLI &amp; SDK</p><ul><li>有 3 种方法 Access AWS: AWS Management Console，AWS CLI，AWS SDK</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img143439.png"></p><h4 id="IAM-Roles"><a href="#IAM-Roles" class="headerlink" title="IAM Roles"></a>IAM Roles</h4><ul><li>Assign permissions to AWS services with IAM Roles</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img150558.png"></p><p>IAM Guildlines &amp; Best Parctices</p><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img153158.png"></p><p>Shared Responsibility Model for IAM</p><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img153447.png"></p><h4 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h4><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img154627.png"></p><hr><h3 id="2-Elastic-Compute-Cloud"><a href="#2-Elastic-Compute-Cloud" class="headerlink" title="2. Elastic Compute Cloud"></a>2. Elastic Compute Cloud</h3><h4 id="AWS-EC2"><a href="#AWS-EC2" class="headerlink" title="AWS EC2"></a>AWS EC2</h4><ul><li>60 seconds - There is a one-minute minimum charge for Linux based EC2 instances</li><li>Convertible reserved instance (RI): Purchase convertible reserved instance (RI) if you need additional flexibility, such as the ability to use different instance families, operating systems, or tenancies over the reserved instance (RI) term.</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img193350.png"></p><p>User Data:</p><ul><li>EC2 Instance 第一次跑的时候会 Run，用来做 Task (比如安装 Apache)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img194029.png"></p><h4 id="EC2-Instance-Types"><a href="#EC2-Instance-Types" class="headerlink" title="EC2 Instance Types"></a>EC2 Instance Types</h4><ul><li>General Purpose: Balance between Compute，Memory，Networking</li><li>Compute Optimized: Great for compute-intensive tasks</li><li>Memory Optimized: Fast performance for workloads that process large data sets</li><li>Storage Optimized: Great for storage-intensive tasks</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img195856.png"></p><h4 id="Security-Groups"><a href="#Security-Groups" class="headerlink" title="Security Groups"></a>Security Groups</h4><ul><li>Security Group 就是 EC2 的防火墙</li><li>Security Group 可以 Attach 给多个 Instances</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img200755.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img201255.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img201629.png"></p><h4 id="EC2-Instances-Purchasing-Options"><a href="#EC2-Instances-Purchasing-Options" class="headerlink" title="EC2 Instances Purchasing Options"></a>EC2 Instances Purchasing Options</h4><ul><li>On-Demand Instances: Pay for what you use</li><li>Reserved: 长期使用 (1-3 年)</li><li>Saving Plans: 有固定的 Billing，超过的进入 On-Demand</li><li>Spot Instances: 最便宜，但是可能 Lose Instance</li><li>Dedicated Hosts: 完全 Control 一个 Server</li><li>Capacity Reservations: 短期内保证有 Instance 可以使用，即使不使用</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img024118.png"></p><p>Shared Responsibility Model for EC2</p><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img025826.png"></p><h4 id="Summary-1"><a href="#Summary-1" class="headerlink" title="Summary"></a>Summary</h4><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img025957.png"></p><hr><h3 id="3-EC2-Instance-Storage"><a href="#3-EC2-Instance-Storage" class="headerlink" title="3. EC2 Instance Storage"></a>3. EC2 Instance Storage</h3><h4 id="AWS-EBS"><a href="#AWS-EBS" class="headerlink" title="AWS EBS"></a>AWS EBS</h4><ul><li>Attach EBS to EC2 instance like a USB drive</li><li>EBS Volume tied to AZ</li><li>Persist data even after termination</li><li>Block-level storage</li><li>Charge for EBS Volumes: Provisioned IOPS，Volume type</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img030842.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img032719.png"></p><p>EBS Snapshots (备份)</p><ul><li>Make a backup (snapshot) of EBS volume</li><li>Recycle Bin 可以防止 Accidental Delete</li><li>Amazon Elastic Block Store (Amazon EBS) Snapshots are stored incrementally, which means you are billed only for the changed blocks stored</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img035925.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img040322.png"></p><p>EC2 Instance Store</p><ul><li>物理硬盘</li><li>Block-level storage</li><li>Fast I&#x2F;O performance</li><li>Good for cache</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img054643.png"></p><p>Shared Responsibility Model for EC2 Storage</p><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img055927.png"></p><hr><h4 id="AWS-EFS"><a href="#AWS-EFS" class="headerlink" title="AWS EFS"></a>AWS EFS</h4><ul><li>可以 Mount 到多个 EC2 Instance</li><li>Provides a simple, scalable, fully managed elastic NFS file system for use with AWS Cloud services and on-premises resources.</li><li>EBS volume can be attached to a single instance in the same Availability Zone (AZ) whereas EFS file system can be mounted on instances across multiple Availability Zones (AZ)</li><li>EC2 instances can access files on an Amazon Elastic File System (Amazon EFS) file system across many Availability Zones (AZ), Regions and VPCs</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img055110.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img055536.png"></p><p>EFS Infrequent Access (EFS-IA)</p><ul><li>Storing files in an accessible location to satisfy audit requirements</li><li>You will pay a fee each time you read from or write data stored on the Amazon Elastic File System (Amazon EFS) - Infrequent Access storage class</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img055437.png"></p><hr><h4 id="AWS-AMI"><a href="#AWS-AMI" class="headerlink" title="AWS AMI"></a>AWS AMI</h4><ul><li>Amazon Machine Image</li><li>可以更好的 Configure 和 Launch EC2 Instance (比如不需要重装 Apache)</li><li>Region specific</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img053649.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img053738.png"></p><p>EC2 Image Builder</p><ul><li>Automatically build，test and distribute AMIs</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img054433.png"></p><hr><h4 id="AWS-FSx"><a href="#AWS-FSx" class="headerlink" title="AWS FSx"></a>AWS FSx</h4><ul><li>第三方文件管理系统</li><li>FSx for Windows</li><li>FSx for Lustre</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img060300.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img060312.png"></p><hr><h4 id="Summary-2"><a href="#Summary-2" class="headerlink" title="Summary"></a>Summary</h4><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img060513.png"></p><hr><h3 id="4-ELB-amp-ASG"><a href="#4-ELB-amp-ASG" class="headerlink" title="4. ELB &amp; ASG"></a>4. ELB &amp; ASG</h3><h4 id="Scalability-amp-High-Availability"><a href="#Scalability-amp-High-Availability" class="headerlink" title="Scalability &amp; High Availability"></a>Scalability &amp; High Availability</h4><ul><li>Vertical Scale: increase the size of the instance</li><li>Horizontal Scale: increase the number of instances (elastic)</li><li>High Availability: running application in at least 2 AZ (disaster recovery)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img065903.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img080120.png"></p><hr><h4 id="AWS-ELB"><a href="#AWS-ELB" class="headerlink" title="AWS ELB"></a>AWS ELB</h4><ul><li>Spread load across multiple downstream instances</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img085521.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img085832.png"></p><ul><li>Application Load Balancer (HTTP&#x2F;HTTPS)</li><li>Network Load Balancer (Allow TCP&#x2F;UDP)</li><li>Gateway Load Balancer (Security)</li><li>Classic Load Balancer (retired in 2023)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img090125.png"></p><hr><h4 id="AWS-ASG"><a href="#AWS-ASG" class="headerlink" title="AWS ASG"></a>AWS ASG</h4><ul><li>可以作为 Template 来生成 EC2 Instance (Launch Template)</li><li>可以和 ELB 一起用，来 Scale Up or Down 基于服务器压力</li><li>可以自动 Replace Unhealth Instance (Meet desired Instances)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img091045.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img091228.png"></p><p>Scaling Strategies</p><ul><li>Manual Scaling</li><li>Dynamic Scaling</li><li>Predictive Scaling (Use ML)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img092355.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img092454.png"></p><hr><h4 id="Summary-3"><a href="#Summary-3" class="headerlink" title="Summary"></a>Summary</h4><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img092733.png"></p><hr><h3 id="5-Simple-Storage-Service"><a href="#5-Simple-Storage-Service" class="headerlink" title="5. Simple Storage Service"></a>5. Simple Storage Service</h3><h4 id="AWS-S3"><a href="#AWS-S3" class="headerlink" title="AWS S3"></a>AWS S3</h4><ul><li><p>Buckets have a globally unique name</p></li><li><p>Buckets are defined at the region level</p></li><li><p>All Amazon S3 buckets have encryption configured by default, and objects are automatically encrypted by using server-side encryption with Amazon S3 managed keys (SSE-S3).</p></li><li><p>Amazon Simple Storage Service (Amazon S3) is a key value based object storage service</p></li><li><p>Amazon Simple Storage Service (Amazon S3) stores data in a flat non-hierarchical structure</p></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img093348.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img093802.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img093849.png"></p><p>Bucket Policies</p><ul><li>User Access to S3: Use IAM permission</li><li>EC2 Instance Access: Use IAM Roles</li><li>Cross-Account Access: Use Bucket Policy</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img102509.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img102630.png"></p><p>S3 Website (Static Website Hosting)</p><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img104755.png"></p><p>S3 Versioning</p><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img105035.png"></p><p>S3 Replication (CRR &amp; SRR)</p><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img105607.png"></p><p>S3 Storage Classes</p><ul><li>Standard</li><li>Infrequent Access (IA)</li><li>Glacier</li><li>Intelligent Tiering</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img110113.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img110226.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img110336.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img110708.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img110810.png"></p><p>S3 Encryption</p><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img111248.png"></p><p>Shared Responsibility Model for S3</p><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img111547.png"></p><hr><h4 id="AWS-Snow-Family"><a href="#AWS-Snow-Family" class="headerlink" title="AWS Snow Family"></a>AWS Snow Family</h4><ul><li>Snowcone，Snowball (TB &amp; Petabyte-scale)，Snowmobile (Exabytes-scale)</li><li>Transfer data to AWS physically</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img122700.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img175223.png"></p><p>Edge Computing</p><ul><li>在任何地方处理数据</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img123338.png"></p><hr><h4 id="AWS-OpsHub"><a href="#AWS-OpsHub" class="headerlink" title="AWS OpsHub"></a>AWS OpsHub</h4><ul><li>Manage Snow Family Device</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img123604.png"></p><hr><h4 id="AWS-Storage-Gateway"><a href="#AWS-Storage-Gateway" class="headerlink" title="AWS Storage Gateway"></a>AWS Storage Gateway</h4><ul><li>处理 Hybrid Storage on Cloud</li><li>Automatically enabled data encryption</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img132624.png"></p><hr><h4 id="Summary-4"><a href="#Summary-4" class="headerlink" title="Summary"></a>Summary</h4><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img132831.png"></p><hr><h3 id="6-Database-amp-Analytics"><a href="#6-Database-amp-Analytics" class="headerlink" title="6. Database &amp; Analytics"></a>6. Database &amp; Analytics</h3><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img134205.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img242377.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img134415.png"></p><hr><h4 id="AWS-RDS"><a href="#AWS-RDS" class="headerlink" title="AWS RDS"></a>AWS RDS</h4><ul><li>负责 Relational Database</li><li>Amazon RDS RIs: Like Amazon EC2 RIs</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img124658.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img134210.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img134849.png"></p><p>AWS Aurora</p><ul><li>AWS 开发的数据库</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img134956.png"></p><p>RDS Deployments Options</p><ul><li>Read Replicas: Scale</li><li>Multi-AZ: Failover</li><li>Multi-Region: Disaster recovery</li><li>You can use both read replicas and multi-AZ deployment for disaster recovery</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img140045.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img148104.png"></p><hr><h4 id="AWS-Elastic-Cache"><a href="#AWS-Elastic-Cache" class="headerlink" title="AWS Elastic Cache"></a>AWS Elastic Cache</h4><ul><li>In-memory database (类似 Redis)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img140153.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img140242.png"></p><hr><h4 id="AWS-DynamoDB"><a href="#AWS-DynamoDB" class="headerlink" title="AWS DynamoDB"></a>AWS DynamoDB</h4><ul><li>NoSQL Database</li><li>DynamoDB Reserved Capacity</li><li>Support High Availability by default</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img142315.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img143342.png"></p><p>DynamoDB Accelerator (DAX)</p><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img142430.png"></p><p>DynamoDB Global Tables</p><ul><li>Low latency in multiple-regions</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img142815.png"></p><hr><h4 id="AWS-Redshift"><a href="#AWS-Redshift" class="headerlink" title="AWS Redshift"></a>AWS Redshift</h4><ul><li>Analytics and data warehousing</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img143251.png"></p><p>Redshift Serverless</p><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img123392.png"></p><hr><h4 id="AWS-EMR"><a href="#AWS-EMR" class="headerlink" title="AWS EMR"></a>AWS EMR</h4><ul><li>Help creating Hadoop clusters (Big Data) to analyze vast amount of data</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img242278.png"></p><hr><h4 id="AWS-Athena"><a href="#AWS-Athena" class="headerlink" title="AWS Athena"></a>AWS Athena</h4><ul><li>Perform analytics against S3 objects</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img144857.png"></p><hr><h4 id="AWS-QuickSight"><a href="#AWS-QuickSight" class="headerlink" title="AWS QuickSight"></a>AWS QuickSight</h4><ul><li>生成 Visualization Dashboard (处理 BI)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img145053.png"></p><hr><h4 id="AWS-DocumentDB"><a href="#AWS-DocumentDB" class="headerlink" title="AWS DocumentDB"></a>AWS DocumentDB</h4><ul><li>For MongoDB，NoSQL</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img145305.png"></p><hr><h4 id="AWS-Neptune"><a href="#AWS-Neptune" class="headerlink" title="AWS Neptune"></a>AWS Neptune</h4><ul><li>Graph database</li><li>NoSQL</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img145437.png"></p><hr><h4 id="AWS-Timestream"><a href="#AWS-Timestream" class="headerlink" title="AWS Timestream"></a>AWS Timestream</h4><ul><li>Time series database</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img145616.png"></p><hr><h4 id="AWS-QLDB"><a href="#AWS-QLDB" class="headerlink" title="AWS QLDB"></a>AWS QLDB</h4><ul><li>Immutable，for financial transcations</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img122316.png"></p><hr><h4 id="AWS-Managed-Blockchain"><a href="#AWS-Managed-Blockchain" class="headerlink" title="AWS Managed Blockchain"></a>AWS Managed Blockchain</h4><ul><li>Decentralized</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img150042.png"></p><hr><h4 id="AWS-Glue"><a href="#AWS-Glue" class="headerlink" title="AWS Glue"></a>AWS Glue</h4><ul><li>AWS Glue is a fully managed extract, transform, and load (ETL) service that makes it easy for customers to prepare and load their data for analytics.</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img150226.png"></p><hr><h4 id="AWS-DMS"><a href="#AWS-DMS" class="headerlink" title="AWS DMS"></a>AWS DMS</h4><ul><li>Database Migration Service</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img120404.png"></p><hr><h4 id="Summary-5"><a href="#Summary-5" class="headerlink" title="Summary"></a>Summary</h4><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img622313.png"></p><hr><h3 id="7-Other-Compute-Services"><a href="#7-Other-Compute-Services" class="headerlink" title="7. Other Compute Services"></a>7. Other Compute Services</h3><h4 id="AWS-ECS"><a href="#AWS-ECS" class="headerlink" title="AWS ECS"></a>AWS ECS</h4><ul><li>Launch Docker containers on AWS</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img185536.png"></p><hr><h4 id="AWS-Fargate"><a href="#AWS-Fargate" class="headerlink" title="AWS Fargate"></a>AWS Fargate</h4><ul><li>Launch Docker containers on AWS (Serverless)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img185649.png"></p><hr><h4 id="AWS-ECR"><a href="#AWS-ECR" class="headerlink" title="AWS ECR"></a>AWS ECR</h4><ul><li>Docker Registry on AWS</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img185752.png"></p><hr><h4 id="AWS-Lambda"><a href="#AWS-Lambda" class="headerlink" title="AWS Lambda"></a>AWS Lambda</h4><ul><li>Could be Event-Driven</li><li>Could use EventBridge trigger Lambda every hour (CRON)</li><li>You pay for the compute time you consume for AWS Lambda</li><li>Serverless</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img190238.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img022933.png"></p><hr><h4 id="AWS-API-Gateway"><a href="#AWS-API-Gateway" class="headerlink" title="AWS API Gateway"></a>AWS API Gateway</h4><ul><li>Expose Lambda as HTTP API</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img031238.png"></p><hr><h4 id="AWS-Batch"><a href="#AWS-Batch" class="headerlink" title="AWS Batch"></a>AWS Batch</h4><ul><li>A job with a start and an end</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img035927.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img040028.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img040129.png"></p><hr><h4 id="AWS-Lightsail"><a href="#AWS-Lightsail" class="headerlink" title="AWS Lightsail"></a>AWS Lightsail</h4><ul><li>For people with little cloud experience</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img042248.png"></p><hr><h4 id="Summary-6"><a href="#Summary-6" class="headerlink" title="Summary"></a>Summary</h4><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img042816.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img042914.png"></p><hr><h3 id="8-Deployment-amp-Manage-Infrastructure"><a href="#8-Deployment-amp-Manage-Infrastructure" class="headerlink" title="8. Deployment &amp; Manage Infrastructure"></a>8. Deployment &amp; Manage Infrastructure</h3><h4 id="AWS-CloudFormation"><a href="#AWS-CloudFormation" class="headerlink" title="AWS CloudFormation"></a>AWS CloudFormation</h4><ul><li>Infrastructure as code (不需要手动 Config EC2 之类的)</li><li>作为 Template 来生成各种 Services</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img044630.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img044747.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img044837.png"></p><hr><h4 id="AWS-CDK"><a href="#AWS-CDK" class="headerlink" title="AWS CDK"></a>AWS CDK</h4><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img045950.png"></p><hr><h4 id="AWS-Elastic-Beanstalk"><a href="#AWS-Elastic-Beanstalk" class="headerlink" title="AWS Elastic Beanstalk"></a>AWS Elastic Beanstalk</h4><ul><li>PaaS (只负责写 Application，其他都由 EB 来处理)</li><li>Free of cost</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img064808.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img064855.png"></p><hr><h4 id="AWS-CodeDeploy"><a href="#AWS-CodeDeploy" class="headerlink" title="AWS CodeDeploy"></a>AWS CodeDeploy</h4><ul><li>Deploy application automatically</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img074724.png"></p><hr><h4 id="AWS-CodeCommit"><a href="#AWS-CodeCommit" class="headerlink" title="AWS CodeCommit"></a>AWS CodeCommit</h4><ul><li>类似 Github</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img074839.png"></p><hr><h4 id="AWS-CodeBuild"><a href="#AWS-CodeBuild" class="headerlink" title="AWS CodeBuild"></a>AWS CodeBuild</h4><ul><li>Automatically build and test</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img075430.png"></p><hr><h4 id="AWS-CodePipeline"><a href="#AWS-CodePipeline" class="headerlink" title="AWS CodePipeline"></a>AWS CodePipeline</h4><ul><li>CICD</li><li>AWS CodePipeline uses Amazon CloudWatch Events to detect changes in CodeCommit repositories used as a source for a pipeline</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img081356.png"></p><hr><h4 id="AWS-CodeArtifact"><a href="#AWS-CodeArtifact" class="headerlink" title="AWS CodeArtifact"></a>AWS CodeArtifact</h4><ul><li>Manage packages (dependencies)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img082203.png"></p><hr><h4 id="AWS-CodeStar"><a href="#AWS-CodeStar" class="headerlink" title="AWS CodeStar"></a>AWS CodeStar</h4><ul><li>Each AWS CodeStar project includes development tools, including AWS CodePipeline, AWS CodeCommit, AWS CodeBuild, and AWS CodeDeploy, that can be used on their own and with existing AWS applications</li><li>You can use AWS CodeStar and AWS Cloud9 to develop, build, and deploy a serverless web application</li></ul><hr><h4 id="AWS-Cloud9"><a href="#AWS-Cloud9" class="headerlink" title="AWS Cloud9"></a>AWS Cloud9</h4><ul><li>Cloud IDE</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img082707.png"></p><hr><h4 id="AWS-SSM"><a href="#AWS-SSM" class="headerlink" title="AWS SSM"></a>AWS SSM</h4><ul><li>Manage a fleet of EC2 Instances</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img135524.png"></p><hr><h4 id="Summary-7"><a href="#Summary-7" class="headerlink" title="Summary"></a>Summary</h4><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img140426.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img140520.png"></p><hr><h3 id="9-AWS-Global-Infrastructure"><a href="#9-AWS-Global-Infrastructure" class="headerlink" title="9. AWS Global Infrastructure"></a>9. AWS Global Infrastructure</h3><p>Why make a global application?</p><ul><li>Decreased Latency</li><li>Disaster Recovery (DR)</li></ul><p>Global Applications in AWS</p><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img142534.png"></p><hr><h4 id="AWS-Route53"><a href="#AWS-Route53" class="headerlink" title="AWS Route53"></a>AWS Route53</h4><ul><li>DNS (Domain Name System)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img142637.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img142729.png"></p><p>Routing Policies</p><ul><li>Simple Routing Policy (No health check)</li><li>Weighted Routing Policy (Distribute traffic)</li><li>Latency Routing Policy (Minimize Latency)</li><li>Failover Routing Policy (Disaster recovery，active-passive)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img142821.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img142907.png"></p><hr><h4 id="AWS-CloudFront"><a href="#AWS-CloudFront" class="headerlink" title="AWS CloudFront"></a>AWS CloudFront</h4><ul><li>Global service</li><li>CDN</li><li>Cached in edged location</li><li>Integrated with WAF (Network Firewall) and Shield (DDoS)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img144056.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img144157.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img144238.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img144434.png"></p><hr><h4 id="AWS-Global-Accelerator"><a href="#AWS-Global-Accelerator" class="headerlink" title="AWS Global Accelerator"></a>AWS Global Accelerator</h4><ul><li>AWS Internal Network (No cache)</li><li>AWS Global Accelerator is a good fit for non-HTTP use cases</li><li>AWS Global Accelerator provides static IP addresses that act as a fixed entry point to your applications</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img184614.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img184642.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img184736.png"></p><hr><h4 id="AWS-Outposts"><a href="#AWS-Outposts" class="headerlink" title="AWS Outposts"></a>AWS Outposts</h4><ul><li>Server Rack (物理层面)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img185046.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img185126.png"></p><hr><h4 id="AWS-WaveLength"><a href="#AWS-WaveLength" class="headerlink" title="AWS WaveLength"></a>AWS WaveLength</h4><ul><li>5G</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img185306.png"></p><hr><h4 id="AWS-Local-Zones"><a href="#AWS-Local-Zones" class="headerlink" title="AWS Local Zones"></a>AWS Local Zones</h4><ul><li>AWS Local Zones allow you to use select AWS services, like compute and storage services, closer to more end-users, providing them very low latency access to the applications running locally.</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img185415.png"></p><hr><h4 id="Global-Applications-Architecture"><a href="#Global-Applications-Architecture" class="headerlink" title="Global Applications Architecture"></a>Global Applications Architecture</h4><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img185706.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img185814.png"></p><hr><h4 id="Summary-8"><a href="#Summary-8" class="headerlink" title="Summary"></a>Summary</h4><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img185939.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img190014.png"></p><hr><h3 id="10-Cloud-Integration"><a href="#10-Cloud-Integration" class="headerlink" title="10.Cloud Integration"></a>10.Cloud Integration</h3><ul><li>SQS，SNS，Kinesis</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img191712.png"></p><hr><h4 id="AWS-SQS"><a href="#AWS-SQS" class="headerlink" title="AWS SQS"></a>AWS SQS</h4><ul><li>Decouple application</li><li>Message deleted after Customer read</li><li>Guarantee message will be processed</li><li>Queue Model</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img192002.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img192052.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img192138.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img192214.png"></p><hr><h4 id="AWS-Kinesis"><a href="#AWS-Kinesis" class="headerlink" title="AWS Kinesis"></a>AWS Kinesis</h4><ul><li>Real-time big data streaming</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img200432.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img200512.png"></p><hr><h4 id="AWS-SNS"><a href="#AWS-SNS" class="headerlink" title="AWS SNS"></a>AWS SNS</h4><ul><li>Send one message to many receivers</li><li>Pub&#x2F;Sub Model</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img200634.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img200723.png"></p><hr><h4 id="AWS-MQ"><a href="#AWS-MQ" class="headerlink" title="AWS MQ"></a>AWS MQ</h4><ul><li>管理第三方软件</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img201142.png"></p><hr><h4 id="Summary-9"><a href="#Summary-9" class="headerlink" title="Summary"></a>Summary</h4><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img201319.png"></p><hr><h3 id="11-Cloud-Monitoring"><a href="#11-Cloud-Monitoring" class="headerlink" title="11. Cloud Monitoring"></a>11. Cloud Monitoring</h3><h4 id="AWS-CloudWatch"><a href="#AWS-CloudWatch" class="headerlink" title="AWS CloudWatch"></a>AWS CloudWatch</h4><ul><li>Application performance</li><li>Resource utilization</li></ul><p>CloudWatch Metric</p><ul><li>Billing metric data is stored in the US East (N. Virginia) Region and represents worldwide charges.</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img202020.png"></p><p>CloudWatch Alarms</p><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img202259.png"></p><p>CloudWatch Logs</p><ul><li>Use CloudWatch Logs for both the EC2 instance and the on-premises servers</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img203214.png"></p><hr><h4 id="AWS-EventBridge"><a href="#AWS-EventBridge" class="headerlink" title="AWS EventBridge"></a>AWS EventBridge</h4><ul><li>定制 Event 来触发某些功能 (Lambda，SNS)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img203642.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img203712.png"></p><hr><h4 id="AWS-CloudTrail"><a href="#AWS-CloudTrail" class="headerlink" title="AWS CloudTrail"></a>AWS CloudTrail</h4><ul><li>Governance，compliance and audit for AWS account</li><li>AWS CloudTrail Insights helps AWS users identify and respond to unusual activity associated with write API calls by continuously analyzing CloudTrail management events.</li><li>By default, AWS CloudTrail logs all management events and does not include data events or Insights events.</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img064634.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img064712.png"></p><hr><h4 id="AWS-X-Ray"><a href="#AWS-X-Ray" class="headerlink" title="AWS X-Ray"></a>AWS X-Ray</h4><ul><li>You can use AWS X-Ray to analyze and debug serverless and distributed applications such as those built using a microservices architecture.</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img070456.png"></p><hr><h4 id="AWS-CodeGuru"><a href="#AWS-CodeGuru" class="headerlink" title="AWS CodeGuru"></a>AWS CodeGuru</h4><ul><li>ML for code review</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img073052.png"></p><hr><h4 id="AWS-Health-Dashboard"><a href="#AWS-Health-Dashboard" class="headerlink" title="AWS Health Dashboard"></a>AWS Health Dashboard</h4><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img073557.png"></p><hr><h4 id="Summary-10"><a href="#Summary-10" class="headerlink" title="Summary"></a>Summary</h4><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img074126.png"></p><hr><h3 id="12-VPC-amp-Networking"><a href="#12-VPC-amp-Networking" class="headerlink" title="12. VPC &amp; Networking"></a>12. VPC &amp; Networking</h3><h4 id="AWS-VPC"><a href="#AWS-VPC" class="headerlink" title="AWS VPC"></a>AWS VPC</h4><p>IP Address in AWS</p><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img075533.png"></p><p>VPC &amp; Subnets</p><ul><li>VPC: Virtual Private Network</li><li>Subnets: Partition network inside VPC</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img075637.png"></p><p>Internet Gateway &amp; NAT Gateways</p><ul><li>IGW: Public</li><li>NAT: Private</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img075859.png"></p><p>Security Groups &amp; Network Access Control List (NACL)</p><ul><li>NACL: Firewall for Allow and Deny rules</li><li>Security Group: Firewall for Allow rules</li><li>A security group is stateful, that is, it automatically allows the return traffic</li><li>Security Group acts as a firewall at the instance level whereas Network Access Control List (Network ACL) acts as a firewall at the subnet level</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img080543.png"></p><p>VPC Flow Logs</p><ul><li>Capture log information</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img080849.png"></p><p>VPC Peering</p><ul><li>Connect two VPC</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img080936.png"></p><p>VPC Endpoints</p><ul><li>Access services privately</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img101047.png"></p><hr><h4 id="AWS-PrivateLink"><a href="#AWS-PrivateLink" class="headerlink" title="AWS PrivateLink"></a>AWS PrivateLink</h4><ul><li>第三方 VPC 连接到 AWS VPC</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img101255.png"></p><hr><h4 id="Site-to-Site-VPN-amp-Direct-Connect"><a href="#Site-to-Site-VPN-amp-Direct-Connect" class="headerlink" title="Site to Site VPN &amp; Direct Connect"></a>Site to Site VPN &amp; Direct Connect</h4><ul><li>AWS Direct Connect is a cloud service solution that makes it easy to establish a dedicated network connection from your premises to AWS.</li><li>Components of AWS Site to Site VPN: Virtual private gateway (VGW)，Customer gateway</li><li>A customer gateway device is a physical or software appliance on your side of a Site-to-Site VPN connection. You or your network administrator must configure the device to work with the Site-to-Site VPN connection.</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img101436.png"></p><hr><h4 id="AWS-ClientVPN"><a href="#AWS-ClientVPN" class="headerlink" title="AWS ClientVPN"></a>AWS ClientVPN</h4><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img101635.png"></p><hr><h4 id="AWS-Transit-Gateway"><a href="#AWS-Transit-Gateway" class="headerlink" title="AWS Transit Gateway"></a>AWS Transit Gateway</h4><ul><li>AWS Transit Gateway connects Amazon Virtual Private Clouds (Amazon VPC) and on-premises networks through a central hub.</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img101746.png"></p><hr><h4 id="AWS-VPN"><a href="#AWS-VPN" class="headerlink" title="AWS VPN"></a>AWS VPN</h4><ul><li>AWS Virtual Private Network (VPN) solutions establish secure connections between on-premises networks, remote offices, client devices, and the AWS global network.</li></ul><hr><h4 id="Summary-11"><a href="#Summary-11" class="headerlink" title="Summary"></a>Summary</h4><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img101912.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img102013.png"></p><hr><h3 id="13-Security-amp-Compliance"><a href="#13-Security-amp-Compliance" class="headerlink" title="13. Security &amp; Compliance"></a>13. Security &amp; Compliance</h3><h4 id="AWS-WAF-amp-Shield"><a href="#AWS-WAF-amp-Shield" class="headerlink" title="AWS WAF &amp; Shield"></a>AWS WAF &amp; Shield</h4><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img103546.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img103621.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img103650.png"></p><p>AWS Shield</p><ul><li>防止 DDoS 攻击</li><li>Shield Advance 用在 Route53 和 AWS Global Accelerator 上</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img103738.png"></p><p>AWS WAF</p><ul><li>Define Web ACL (Access Control List)</li><li>Can be deployed on Amazon CloudFront, Application Load Balancer, Amazon API Gateway, AWS AppSync</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img103839.png"></p><hr><h4 id="AWS-Network-Firewall"><a href="#AWS-Network-Firewall" class="headerlink" title="AWS Network Firewall"></a>AWS Network Firewall</h4><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img103945.png"></p><hr><h4 id="AWS-Firewall-Manager"><a href="#AWS-Firewall-Manager" class="headerlink" title="AWS Firewall Manager"></a>AWS Firewall Manager</h4><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img105934.png"></p><hr><h4 id="AWS-KMS-amp-CloudHSM"><a href="#AWS-KMS-amp-CloudHSM" class="headerlink" title="AWS KMS &amp; CloudHSM"></a>AWS KMS &amp; CloudHSM</h4><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img120236.png"></p><p>KMS: Manage Encryption keys</p><ul><li>Use AWS managed master keys that are automatically created in your account for each service</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img120343.png"></p><p>CloudHSM: Encryption Hardware (物理层面)</p><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img120433.png"></p><hr><h4 id="AWS-ACM"><a href="#AWS-ACM" class="headerlink" title="AWS ACM"></a>AWS ACM</h4><ul><li>Manage certificates</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img124350.png"></p><hr><h4 id="AWS-Secrets-Manager"><a href="#AWS-Secrets-Manager" class="headerlink" title="AWS Secrets Manager"></a>AWS Secrets Manager</h4><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img124445.png"></p><hr><h4 id="AWS-Artifact"><a href="#AWS-Artifact" class="headerlink" title="AWS Artifact"></a>AWS Artifact</h4><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img124706.png"></p><hr><h4 id="AWS-GuardDuty"><a href="#AWS-GuardDuty" class="headerlink" title="AWS GuardDuty"></a>AWS GuardDuty</h4><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img125533.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img125621.png"></p><hr><h4 id="AWS-Inspector"><a href="#AWS-Inspector" class="headerlink" title="AWS Inspector"></a>AWS Inspector</h4><ul><li>Amazon Inspector is an automated security assessment service that helps improve the security and compliance of applications deployed on AWS.</li><li>Only for EC2, Container Image &amp; Lambda</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img125801.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img125844.png"></p><hr><h4 id="AWS-Config"><a href="#AWS-Config" class="headerlink" title="AWS Config"></a>AWS Config</h4><ul><li>AWS Config is a service that enables you to assess, audit, and evaluate the configurations of your AWS resources.</li><li>Think resource-specific history, audit, and compliance; think Config.</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img125948.png"></p><hr><h4 id="AWS-Macie"><a href="#AWS-Macie" class="headerlink" title="AWS Macie"></a>AWS Macie</h4><ul><li>Find sensitive data</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img130515.png"></p><hr><h4 id="AWS-Security-Hub"><a href="#AWS-Security-Hub" class="headerlink" title="AWS Security Hub"></a>AWS Security Hub</h4><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img131533.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img131605.png"></p><hr><h4 id="AWS-Detective"><a href="#AWS-Detective" class="headerlink" title="AWS Detective"></a>AWS Detective</h4><ul><li>Analyze AWS CloudTrail logs, Amazon VPC Flow Logs, and Amazon GuardDuty findings</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img132824.png"></p><hr><h4 id="IAM-Access-Analyzer"><a href="#IAM-Access-Analyzer" class="headerlink" title="IAM Access Analyzer"></a>IAM Access Analyzer</h4><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img133559.png"></p><hr><h4 id="Summary-12"><a href="#Summary-12" class="headerlink" title="Summary"></a>Summary</h4><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img152124.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img155139.png"></p><hr><h3 id="14-Machine-Learning"><a href="#14-Machine-Learning" class="headerlink" title="14. Machine Learning"></a>14. Machine Learning</h3><h4 id="AWS-Rekognition"><a href="#AWS-Rekognition" class="headerlink" title="AWS Rekognition"></a>AWS Rekognition</h4><ul><li>Find text or image using ML</li><li>Regional in scope</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img164327.png"></p><hr><h4 id="AWS-Transcribe"><a href="#AWS-Transcribe" class="headerlink" title="AWS Transcribe"></a>AWS Transcribe</h4><ul><li>Convert speech to text</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img164826.png"></p><hr><h4 id="Amazon-Elastic-Transcoder"><a href="#Amazon-Elastic-Transcoder" class="headerlink" title="Amazon Elastic Transcoder"></a>Amazon Elastic Transcoder</h4><ul><li>Amazon Elastic Transcoder lets you convert media files that you have stored in Amazon Simple Storage Service (Amazon S3) into media files in the formats required by consumer playback devices.</li></ul><hr><h4 id="AWS-Polly"><a href="#AWS-Polly" class="headerlink" title="AWS Polly"></a>AWS Polly</h4><ul><li>Convert text to speech</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img165059.png"></p><hr><h4 id="AWS-Translate"><a href="#AWS-Translate" class="headerlink" title="AWS Translate"></a>AWS Translate</h4><ul><li>Translate language</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img171433.png"></p><hr><h4 id="AWS-Lex-amp-Connect"><a href="#AWS-Lex-amp-Connect" class="headerlink" title="AWS Lex &amp; Connect"></a>AWS Lex &amp; Connect</h4><p>Lex: Conversational bots<br>Connect: Cloud contact center</p><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img171703.png"></p><hr><h4 id="AWS-Comprehend"><a href="#AWS-Comprehend" class="headerlink" title="AWS Comprehend"></a>AWS Comprehend</h4><ul><li>NLP</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img171904.png"></p><hr><h4 id="AWS-SageMaker"><a href="#AWS-SageMaker" class="headerlink" title="AWS SageMaker"></a>AWS SageMaker</h4><ul><li>Build ML</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img175503.png"></p><hr><h4 id="AWS-Forecast"><a href="#AWS-Forecast" class="headerlink" title="AWS Forecast"></a>AWS Forecast</h4><ul><li>Forecast things using ML</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img180029.png"></p><hr><h4 id="AWS-Kendra"><a href="#AWS-Kendra" class="headerlink" title="AWS Kendra"></a>AWS Kendra</h4><ul><li>Document search service</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img180235.png"></p><hr><h4 id="AWS-Personalize"><a href="#AWS-Personalize" class="headerlink" title="AWS Personalize"></a>AWS Personalize</h4><ul><li>Personal Recommendation</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img180943.png"></p><hr><h4 id="AWS-Textract"><a href="#AWS-Textract" class="headerlink" title="AWS Textract"></a>AWS Textract</h4><ul><li>Extract text</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img181533.png"></p><hr><h4 id="Summary-13"><a href="#Summary-13" class="headerlink" title="Summary"></a>Summary</h4><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img181025.png"></p><hr><h3 id="15-Account-Management，Billing-amp-Support"><a href="#15-Account-Management，Billing-amp-Support" class="headerlink" title="15. Account Management，Billing &amp; Support"></a>15. Account Management，Billing &amp; Support</h3><h4 id="AWS-Organization"><a href="#AWS-Organization" class="headerlink" title="AWS Organization"></a>AWS Organization</h4><ul><li>Manage multiple AWS accounts</li><li>Consolidated Billing</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img215935.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img220144.png"></p><hr><h4 id="AWS-Control-Tower"><a href="#AWS-Control-Tower" class="headerlink" title="AWS Control Tower"></a>AWS Control Tower</h4><ul><li>Running on top of AWS Organization</li><li>AWS Control Tower is an AWS native service providing a pre-defined set of blueprints and guardrails to help customers implement a landing zone for new AWS accounts</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img230602.png"></p><hr><h4 id="AWS-Service-Catalog"><a href="#AWS-Service-Catalog" class="headerlink" title="AWS Service Catalog"></a>AWS Service Catalog</h4><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img230820.png"></p><hr><h4 id="Pricing-Models-in-AWS"><a href="#Pricing-Models-in-AWS" class="headerlink" title="Pricing Models in AWS"></a>Pricing Models in AWS</h4><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img231117.png"></p><hr><h4 id="AWS-Compute-Optimizer"><a href="#AWS-Compute-Optimizer" class="headerlink" title="AWS Compute Optimizer"></a>AWS Compute Optimizer</h4><ul><li>Reduce cost and improve performance</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img232258.png"></p><hr><h4 id="Cost-Allocation-Tags"><a href="#Cost-Allocation-Tags" class="headerlink" title="Cost Allocation Tags"></a>Cost Allocation Tags</h4><ul><li>For each resource, each tag key must be unique, and each tag key can have only one value</li><li>You must activate both AWS generated tags and user-defined tags separately before they can appear in Cost Explorer or on a cost allocation report</li></ul><hr><h4 id="AWS-Budgets"><a href="#AWS-Budgets" class="headerlink" title="AWS Budgets"></a>AWS Budgets</h4><ul><li>Create alarm when exceed budget</li><li>Budget Types: Cost budget，Usage budget，Reservation budget</li><li>AWS Budgets gives you the ability to set custom budgets that alert you when your costs or usage exceed (or are forecasted to exceed) your budgeted amount.</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img233133.png"></p><hr><h4 id="AWS-Pricing-Calculator"><a href="#AWS-Pricing-Calculator" class="headerlink" title="AWS Pricing Calculator"></a>AWS Pricing Calculator</h4><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img075527.png"></p><hr><h4 id="Cost-and-Usage-Reports"><a href="#Cost-and-Usage-Reports" class="headerlink" title="Cost and Usage Reports"></a>Cost and Usage Reports</h4><ul><li>AWS Cost &amp; Usage Report (AWS CUR) contains the most comprehensive set of cost and usage data available.</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img075737.png"></p><hr><h4 id="Cost-Explorer"><a href="#Cost-Explorer" class="headerlink" title="Cost Explorer"></a>Cost Explorer</h4><ul><li>AWS Cost Explorer has an easy-to-use interface that lets you visualize, understand, and manage your AWS costs and usage over time.</li><li>Can be used to forecast your AWS account usage and costs</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img075833.png"></p><hr><h4 id="AWS-Trusted-Advisor"><a href="#AWS-Trusted-Advisor" class="headerlink" title="AWS Trusted Advisor"></a>AWS Trusted Advisor</h4><ul><li>AWS Trusted Advisor is an online tool that provides you real-time guidance to help you provision your resources following AWS best practices on cost optimization</li><li>Identify unattached or underutilized EBS volumes</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img233600.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img175558.png"></p><hr><h4 id="AWS-Service-Quotas"><a href="#AWS-Service-Quotas" class="headerlink" title="AWS Service Quotas"></a>AWS Service Quotas</h4><ul><li>Service Quotas enables you to view and manage your quotas for AWS services from a central location.</li></ul><hr><h4 id="AWS-Support-Plans-Pricing"><a href="#AWS-Support-Plans-Pricing" class="headerlink" title="AWS Support Plans Pricing"></a>AWS Support Plans Pricing</h4><ul><li>Free，Developer，Business，Enterprise On-Ramp，Enterprise</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img233819.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img234952.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img235020.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img235048.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img235117.png"></p><hr><h4 id="Summary-14"><a href="#Summary-14" class="headerlink" title="Summary"></a>Summary</h4><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img234240.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img234349.png"></p><hr><h3 id="16-Adavanced-Identity"><a href="#16-Adavanced-Identity" class="headerlink" title="16. Adavanced Identity"></a>16. Adavanced Identity</h3><h4 id="AWS-STS"><a href="#AWS-STS" class="headerlink" title="AWS STS"></a>AWS STS</h4><ul><li>Security Token Service</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img072649.png"></p><hr><h4 id="AWS-Cognito"><a href="#AWS-Cognito" class="headerlink" title="AWS Cognito"></a>AWS Cognito</h4><ul><li>处理用户登录 (Google，Facebook)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img072756.png"></p><hr><h4 id="AWS-IAM-Identity-Center"><a href="#AWS-IAM-Identity-Center" class="headerlink" title="AWS IAM Identity Center"></a>AWS IAM Identity Center</h4><ul><li>One login for multiple accounts</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img073056.png"></p><hr><h4 id="Summary-15"><a href="#Summary-15" class="headerlink" title="Summary"></a>Summary</h4><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img073540.png"></p><hr><h3 id="17-Other-AWS-Services"><a href="#17-Other-AWS-Services" class="headerlink" title="17. Other AWS Services"></a>17. Other AWS Services</h3><h4 id="AWS-WorkSpace"><a href="#AWS-WorkSpace" class="headerlink" title="AWS WorkSpace"></a>AWS WorkSpace</h4><ul><li>Global cloud-based products</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img083303.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img083335.png"></p><hr><h4 id="AWS-AppStream"><a href="#AWS-AppStream" class="headerlink" title="AWS AppStream"></a>AWS AppStream</h4><ul><li>Deliver application within web</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img083422.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img083502.png"></p><hr><h4 id="AWS-IoT"><a href="#AWS-IoT" class="headerlink" title="AWS IoT"></a>AWS IoT</h4><ul><li>物联网</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img083607.png"></p><hr><h4 id="AWS-AppSync"><a href="#AWS-AppSync" class="headerlink" title="AWS AppSync"></a>AWS AppSync</h4><ul><li>GraphQL</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img083702.png"></p><hr><h4 id="AWS-Amplify"><a href="#AWS-Amplify" class="headerlink" title="AWS Amplify"></a>AWS Amplify</h4><ul><li>Deploy fullstack web or mobile app</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img085244.png"></p><hr><h4 id="AWS-Application-Composer"><a href="#AWS-Application-Composer" class="headerlink" title="AWS Application Composer"></a>AWS Application Composer</h4><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img085340.png"></p><hr><h4 id="AWS-Device-Farm"><a href="#AWS-Device-Farm" class="headerlink" title="AWS Device Farm"></a>AWS Device Farm</h4><ul><li>Test web app in different devices</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img085508.png"></p><hr><h4 id="AWS-Backup"><a href="#AWS-Backup" class="headerlink" title="AWS Backup"></a>AWS Backup</h4><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img085539.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img085603.png"></p><hr><h4 id="Disaster-Recovery-Strategies"><a href="#Disaster-Recovery-Strategies" class="headerlink" title="Disaster Recovery Strategies"></a>Disaster Recovery Strategies</h4><ul><li>最便宜: Back and Restore</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img085705.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img085729.png"></p><hr><h4 id="AWS-DRS"><a href="#AWS-DRS" class="headerlink" title="AWS DRS"></a>AWS DRS</h4><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img085904.png"></p><hr><h4 id="AWS-DataSync"><a href="#AWS-DataSync" class="headerlink" title="AWS DataSync"></a>AWS DataSync</h4><ul><li>Incremental</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img085958.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img090038.png"></p><hr><h4 id="AWS-Application-Discovery-Service"><a href="#AWS-Application-Discovery-Service" class="headerlink" title="AWS Application Discovery Service"></a>AWS Application Discovery Service</h4><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img090147.png"></p><hr><h4 id="AWS-Application-Migration-Service"><a href="#AWS-Application-Migration-Service" class="headerlink" title="AWS Application Migration Service"></a>AWS Application Migration Service</h4><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img090259.png"></p><hr><h4 id="AWS-Migration-Hub"><a href="#AWS-Migration-Hub" class="headerlink" title="AWS Migration Hub"></a>AWS Migration Hub</h4><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img090459.png"></p><hr><h4 id="AWS-Migration-Evaluator"><a href="#AWS-Migration-Evaluator" class="headerlink" title="AWS Migration Evaluator"></a>AWS Migration Evaluator</h4><ul><li>AWS Migration Evaluator (Formerly TSO Logic) is a complimentary service to create data-driven business cases for AWS Cloud planning and migration.</li></ul><hr><h4 id="AWS-FIS"><a href="#AWS-FIS" class="headerlink" title="AWS FIS"></a>AWS FIS</h4><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img090535.png"></p><hr><h4 id="AWS-Step-Functions"><a href="#AWS-Step-Functions" class="headerlink" title="AWS Step Functions"></a>AWS Step Functions</h4><ul><li>Serverless</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img090614.png"></p><hr><h4 id="AWS-Ground-Station"><a href="#AWS-Ground-Station" class="headerlink" title="AWS Ground Station"></a>AWS Ground Station</h4><ul><li>Satellite</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img090709.png"></p><hr><h4 id="AWS-Pinpoint"><a href="#AWS-Pinpoint" class="headerlink" title="AWS Pinpoint"></a>AWS Pinpoint</h4><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img090818.png"></p><hr><h4 id="AWS-Systems-Manager"><a href="#AWS-Systems-Manager" class="headerlink" title="AWS Systems Manager"></a>AWS Systems Manager</h4><ul><li>AWS Systems Manager allows you to centralize operational data from multiple AWS services and automate tasks across your AWS resources.</li><li>Get operational insights of its resources to quickly identify any issues that might impact applications using those resources</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img075954.png"></p><hr><h4 id="AWS-Systems-Manager-Session-Manager-SSM"><a href="#AWS-Systems-Manager-Session-Manager-SSM" class="headerlink" title="AWS Systems Manager Session Manager (SSM)"></a>AWS Systems Manager Session Manager (SSM)</h4><ul><li>AWS SSM Session Manager is a fully-managed service that provides you with an interactive browser-based shell and CLI experience.</li><li>Runs on a fleet of Amazon EC2 instances</li></ul><hr><h4 id="AWS-SSO"><a href="#AWS-SSO" class="headerlink" title="AWS SSO"></a>AWS SSO</h4><ul><li>AWS SSO is an AWS service that enables you to makes it easy to centrally manage access to multiple AWS accounts and business applications and provide users with single sign-on access to all their assigned accounts and applications from one place.</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img080225.png"></p><hr><h4 id="AWS-Quick-Starts-references"><a href="#AWS-Quick-Starts-references" class="headerlink" title="AWS Quick Starts references"></a>AWS Quick Starts references</h4><ul><li>Quick Starts are built by AWS solutions architects and partners to help you deploy popular technologies on AWS, based on AWS best practices for security and high availability.</li></ul><hr><h4 id="APN-Consulting-Partner"><a href="#APN-Consulting-Partner" class="headerlink" title="APN Consulting Partner"></a>APN Consulting Partner</h4><ul><li>APN Consulting Partners are professional services firms that help customers of all types and sizes design, architect, build, migrate, and manage their workloads and applications on AWS, accelerating their migration to AWS cloud.</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img080758.png"></p><hr><h4 id="Penetration-Testing"><a href="#Penetration-Testing" class="headerlink" title="Penetration Testing"></a>Penetration Testing</h4><ul><li>AWS customers can carry out security assessments or penetration tests against their AWS infrastructure without prior approval for few common AWS services.</li></ul><hr><h4 id="AWS-Personal-Health-Dashboard"><a href="#AWS-Personal-Health-Dashboard" class="headerlink" title="AWS Personal Health Dashboard"></a>AWS Personal Health Dashboard</h4><ul><li>AWS Personal Health Dashboard provides alerts and remediation guidance when AWS is experiencing events that may impact you.</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img083000.png"></p><hr><h4 id="AWS-Service-Health-Dashboard"><a href="#AWS-Service-Health-Dashboard" class="headerlink" title="AWS Service Health Dashboard"></a>AWS Service Health Dashboard</h4><ul><li>AWS Service Health Dashboard publishes most up-to-the-minute information on the status and availability of all AWS services in tabular form for all Regions that AWS is present in.</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img083127.png"></p><hr><h4 id="AWS-Marketplace"><a href="#AWS-Marketplace" class="headerlink" title="AWS Marketplace"></a>AWS Marketplace</h4><ul><li>Sell Software as a Service (SaaS) solutions to AWS customers</li><li>AWS customer can buy software that has been bundled into customized AMIs by the AWS Marketplace sellers</li></ul><hr><h4 id="AWS-Service-Catalog-1"><a href="#AWS-Service-Catalog-1" class="headerlink" title="AWS Service Catalog"></a>AWS Service Catalog</h4><ul><li>AWS Service Catalog allows organizations to create and manage catalogs of IT services that are approved for use on AWS.</li></ul><hr><h4 id="AWS-Well-Architected-Tool"><a href="#AWS-Well-Architected-Tool" class="headerlink" title="AWS Well-Architected Tool"></a>AWS Well-Architected Tool</h4><ul><li>The AWS Well-Architected Tool helps you review the state of your workloads and compares them to the latest AWS architectural best practices.</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img175558.png"></p><hr><h4 id="AWS-Resource-Groups"><a href="#AWS-Resource-Groups" class="headerlink" title="AWS Resource Groups"></a>AWS Resource Groups</h4><ul><li>You can use AWS Resource Groups to organize your AWS resources. Resource groups make it easier to manage and automate tasks on large numbers of resources at a time.</li></ul><hr><h4 id="AWS-Cloud-Foundations"><a href="#AWS-Cloud-Foundations" class="headerlink" title="AWS Cloud Foundations"></a>AWS Cloud Foundations</h4><ul><li>Cloud Foundations provides a guided path to help customers deploy, configure, and secure their new workloads while ensuring they are ready for on-going operations in the cloud.</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img170401.png"></p><hr><h4 id="Credentials-Report"><a href="#Credentials-Report" class="headerlink" title="Credentials Report"></a>Credentials Report</h4><ul><li>You can generate and download a credentials report that lists all users in your account and the status of their various credentials, including passwords, access keys, and MFA devices.</li></ul><hr><h4 id="CloudEndure-Disaster-Recovery"><a href="#CloudEndure-Disaster-Recovery" class="headerlink" title="CloudEndure Disaster Recovery"></a>CloudEndure Disaster Recovery</h4><ul><li>CloudEndure Disaster Recovery enables you to use AWS Cloud as a disaster recovery Region for an on-premises workload and its environment.</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img091100.png"></p><hr><h3 id="18-AWS-Architecting-amp-Ecosystem"><a href="#18-AWS-Architecting-amp-Ecosystem" class="headerlink" title="18. AWS Architecting &amp; Ecosystem"></a>18. AWS Architecting &amp; Ecosystem</h3><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img091239.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img091320.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img091347.png"></p><hr><h4 id="Operation-Excellence"><a href="#Operation-Excellence" class="headerlink" title="Operation Excellence"></a>Operation Excellence</h4><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img091439.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img091513.png"></p><hr><h4 id="Security"><a href="#Security" class="headerlink" title="Security"></a>Security</h4><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img091656.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img091735.png"></p><hr><h4 id="Reliability"><a href="#Reliability" class="headerlink" title="Reliability"></a>Reliability</h4><ul><li>AWS Config，AWS CloudTrail，Amazon CloudWatch</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img091813.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img091848.png"></p><hr><h4 id="Performance-Efficiency"><a href="#Performance-Efficiency" class="headerlink" title="Performance Efficiency"></a>Performance Efficiency</h4><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img091927.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img091956.png"></p><hr><h4 id="Cost-Optimization"><a href="#Cost-Optimization" class="headerlink" title="Cost Optimization"></a>Cost Optimization</h4><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img092031.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img092058.png"></p><hr><h4 id="Sustainability"><a href="#Sustainability" class="headerlink" title="Sustainability"></a>Sustainability</h4><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img092133.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img092201.png"></p><hr><h4 id="Cloud-Adoption-Framework-CAF"><a href="#Cloud-Adoption-Framework-CAF" class="headerlink" title="Cloud Adoption Framework (CAF)"></a>Cloud Adoption Framework (CAF)</h4><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img092346.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img092416.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img092445.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img151051.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img151120.png"></p><hr><h4 id="AWS-IQ"><a href="#AWS-IQ" class="headerlink" title="AWS IQ"></a>AWS IQ</h4><ul><li>找人帮忙</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img092907.png"></p><hr><h4 id="AWS-AMS"><a href="#AWS-AMS" class="headerlink" title="AWS AMS"></a>AWS AMS</h4><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img093104.png"></p><hr><h3 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h3><blockquote><p>请勿随意修改，谢谢</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Certification </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AWS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端切图仔</title>
      <link href="/posts/bfacd5b7.html"/>
      <url>/posts/bfacd5b7.html</url>
      
        <content type="html"><![CDATA[<hr><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><ul><li>正经人谁写<code>CSS</code>啊 😅 (<code>https://jsfiddle.net/user/fiddles/all/1/</code>)</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Hongda-OSU/PicGo/image/76d443f8f92e4e8eaeb8c4d368cdfe81~tplv-k3u1fbpfcp-jj-mark_3024_0_0_0_q75.awebp"></p><hr><h3 id="滚动视差"><a href="#滚动视差" class="headerlink" title="滚动视差"></a>滚动视差</h3><ul><li><code>Scroll Parallax</code></li></ul><iframe width="100%" height="400px" src="//jsfiddle.net/HDL52/ekg7nrs1/84/embedded/result/dark/" frameborder="0" loading="lazy" allowtransparency="true" allowfullscreen="true"></iframe><iframe width="100%" height="400px" src="//jsfiddle.net/HDL52/28rnshqx/88/embedded/result/dark/" rameborder="0" loading="lazy" allowfullscreen="allowfullscreen" allowpaymentrequest frameborder="0"></iframe><hr><h3 id="鼠标视差"><a href="#鼠标视差" class="headerlink" title="鼠标视差"></a>鼠标视差</h3><ul><li><code>Mouse Parallax</code></li></ul><iframe width="100%" height="400px" src="//jsfiddle.net/HDL52/18uedakg/331/embedded/result/dark/" frameborder="0" loading="lazy" allowtransparency="true" allowfullscreen="true"></iframe><hr><h3 id="打字机效果"><a href="#打字机效果" class="headerlink" title="打字机效果"></a>打字机效果</h3><ul><li>也可以叫做 <code>typing effect</code></li></ul><iframe width="100%" height="400px" src="//jsfiddle.net/HDL52/qgaywfs8/55/embedded/result/dark/" allowfullscreen="allowfullscreen" allowpaymentrequest frameborder="0"></iframe><iframe src="https://codesandbox.io/embed/fw94fg?view=preview&module=%2Fpublic%2Findex.html&hidenavigation=1"     style="width:100%; height: 500px; border:0; border-radius: 4px; overflow:hidden;"     title="Typing"     allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"     sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"   ></iframe><hr><h3 id="3D-卡片效果"><a href="#3D-卡片效果" class="headerlink" title="3D 卡片效果"></a>3D 卡片效果</h3><p><code>https://www.cnblogs.com/coco1s/p/17979602</code></p><iframe width="100%" height="400px" src="//jsfiddle.net/HDL52/cswk73b2/205/embedded/result/dark/" frameborder="0" loading="lazy" allowtransparency="true" allowfullscreen="true"></iframe><iframe src="https://codesandbox.io/embed/cwy6d7?view=preview&module=%2Fpublic%2Findex.html&hidenavigation=1"     style="width:100%; height: 500px; border:0; border-radius: 4px; overflow:hidden;"     title="3D 卡片"     allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"     sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"   ></iframe><iframe src="https://codesandbox.io/embed/9nldjd?view=preview&module=%2Fpublic%2Findex.html&hidenavigation=1"     style="width:100%; height: 500px; border:0; border-radius: 4px; overflow:hidden;"     title="卡片"     allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"     sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"   ></iframe><iframe width="100%" height="400px" src="//jsfiddle.net/HDL52/e01vtrpc/18/embedded/result/dark/" frameborder="0" loading="lazy" allowtransparency="true" allowfullscreen="true"></iframe><iframe width="100%" height="400px" src="//jsfiddle.net/HDL52/0wh5zu9s/6/embedded/result/dark/" frameborder="0" loading="lazy" allowtransparency="true" allowfullscreen="true"></iframe><hr><h3 id="卡片效果"><a href="#卡片效果" class="headerlink" title="卡片效果"></a>卡片效果</h3><iframe width="100%" height="400px" src="//jsfiddle.net/HDL52/9czbrops/46/embedded/result/dark/" frameborder="0" loading="lazy" allowtransparency="true" allowfullscreen="true"></iframe><iframe width="100%" height="400px" src="//jsfiddle.net/HDL52/cugLmsv3/354/embedded/result/dark/" frameborder="0" loading="lazy" allowtransparency="true" allowfullscreen="true"></iframe><iframe width="100%" height="400px" src="//jsfiddle.net/HDL52/ha8o2v65/143/embedded/result/dark/" frameborder="0" loading="lazy" allowtransparency="true" allowfullscreen="true"></iframe><hr><h3 id="下划线特效"><a href="#下划线特效" class="headerlink" title="下划线特效"></a>下划线特效</h3><iframe width="100%" height="400px" src="//jsfiddle.net/HDL52/xpq1g3eu/63/embedded/result/dark/" allowfullscreen="allowfullscreen" allowpaymentrequest frameborder="0"></iframe><hr><h3 id="Zoom-效果"><a href="#Zoom-效果" class="headerlink" title="Zoom 效果"></a>Zoom 效果</h3><ul><li><code>https://css-tricks.com/re-creating-the-porky-pig-animation-from-looney-tunes-in-css/</code></li></ul><iframe width="100%" height="400px" src="//jsfiddle.net/HDL52/cpuLzsfm/143/embedded/result/dark/" frameborder="0" loading="lazy" allowtransparency="true" allowfullscreen="true"></iframe><iframe width="100%" height="400px" src="//jsfiddle.net/HDL52/ugwzj47x/39/embedded/result/dark/" frameborder="0" loading="lazy" allowtransparency="true" allowfullscreen="true"></iframe><hr><h3 id="视频背景"><a href="#视频背景" class="headerlink" title="视频背景"></a>视频背景</h3><iframe width="100%" height="400px" src="//jsfiddle.net/HDL52/wdehmqgp/50/embedded/result/dark/" allowfullscreen="allowfullscreen" allowpaymentrequest frameborder="0"></iframe><hr><h3 id="头像特效"><a href="#头像特效" class="headerlink" title="头像特效"></a>头像特效</h3><iframe width="100%" height="400px" src="//jsfiddle.net/HDL52/56y0gqzw/37/embedded/result/dark/" frameborder="0" loading="lazy" allowtransparency="true" allowfullscreen="true"></iframe><iframe width="100%" height="400px" src="//jsfiddle.net/HDL52/c6uph9ab/69/embedded/result/dark/" frameborder="0" loading="lazy" allowtransparency="true" allowfullscreen="true"></iframe><hr><h3 id="鼠标效果"><a href="#鼠标效果" class="headerlink" title="鼠标效果"></a>鼠标效果</h3><iframe width="100%" height="400px" src="//jsfiddle.net/HDL52/qxndvehu/21/embedded/result/dark/" allowfullscreen="allowfullscreen" allowpaymentrequest frameborder="0"></iframe><iframe width="100%" height="400px" src="//jsfiddle.net/HDL52/8trua6n4/16/embedded/result/dark/" allowfullscreen="allowfullscreen" allowpaymentrequest frameborder="0"></iframe><iframe src="https://codesandbox.io/embed/fgrc6y?view=preview&module=%2Fsrc%2Fstyles.css"     style="width:100%; height: 500px; border:0; border-radius: 4px; overflow:hidden;"     title="鼠标特效"     allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"     sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"   ></iframe><iframe width="100%" height="400px" src="//jsfiddle.net/HDL52/ua5hfbwr/47/embedded/result/dark/" frameborder="0" loading="lazy" allowtransparency="true" allowfullscreen="true"></iframe><ul><li>动态鼠标效果</li></ul><iframe width="100%" height="400px" src="//jsfiddle.net/HDL52/fwbL130q/4/embedded/result/dark/" frameborder="0" loading="lazy" allowtransparency="true" allowfullscreen="true"></iframe><iframe width="100%" height="400px" src="//jsfiddle.net/HDL52/y93shdxv/9/embedded/result/dark/" frameborder="0" loading="lazy" allowtransparency="true" allowfullscreen="true"></iframe><hr><h3 id="图片倒影"><a href="#图片倒影" class="headerlink" title="图片倒影"></a>图片倒影</h3><iframe width="100%" height="400px" src="//jsfiddle.net/HDL52/v5Loj9b1/74/embedded/result/dark/" allowfullscreen="allowfullscreen" allowpaymentrequest frameborder="0"></iframe><hr><h3 id="噪音特效"><a href="#噪音特效" class="headerlink" title="噪音特效"></a>噪音特效</h3><iframe width="100%" height="400px" src="//jsfiddle.net/HDL52/ksyx497p/4/embedded/result/dark/" allowfullscreen="allowfullscreen" allowpaymentrequest frameborder="0"></iframe><hr><h3 id="图片堆叠"><a href="#图片堆叠" class="headerlink" title="图片堆叠"></a>图片堆叠</h3><iframe width="100%" height="400px" src="//jsfiddle.net/HDL52/sfc0anmu/86/embedded/result/dark/" allowfullscreen="allowfullscreen" allowpaymentrequest frameborder="0"></iframe><iframe width="100%" height="400px" src="//jsfiddle.net/HDL52/y41krcn9/58/embedded/result/dark/" allowfullscreen="allowfullscreen" allowpaymentrequest frameborder="0"></iframe><hr><h3 id="人潮汹涌"><a href="#人潮汹涌" class="headerlink" title="人潮汹涌"></a>人潮汹涌</h3><p><code>https://codepen.io/zadvorsky/pen/xxwbBQV</code></p><iframe src="https://codesandbox.io/embed/r327rm?view=preview&module=%2Fsrc%2FApp.js&hidenavigation=1"     style="width:100%; height: 500px; border:0; border-radius: 4px; overflow:hidden;"     title="人潮汹涌"     allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"     sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"   ></iframe><hr><h3 id="文字特效"><a href="#文字特效" class="headerlink" title="文字特效"></a>文字特效</h3><iframe width="100%" height="400px" src="//jsfiddle.net/HDL52/0ezmgf81/253/embedded/result/dark/" allowfullscreen="allowfullscreen" allowpaymentrequest frameborder="0"></iframe><iframe src="https://codesandbox.io/embed/yh5272?view=preview&module=%2Fpublic%2Findex.html"     style="width:100%; height: 500px; border:0; border-radius: 4px; overflow:hidden;"     title="名字"     allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"     sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"   ></iframe>   <hr><h3 id="图片消失"><a href="#图片消失" class="headerlink" title="图片消失"></a>图片消失</h3><iframe width="100%" height="400px" src="//jsfiddle.net/HDL52/e9kzqtop/228/embedded/result/dark/" allowfullscreen="allowfullscreen" allowpaymentrequest frameborder="0"></iframe><hr><h3 id="奇怪的特效"><a href="#奇怪的特效" class="headerlink" title="奇怪的特效"></a>奇怪的特效</h3><iframe width="100%" height="400px" src="//jsfiddle.net/HDL52/cyL2t579/34/embedded/result/dark/" frameborder="0" loading="lazy" allowtransparency="true" allowfullscreen="true"></iframe><iframe width="100%" height="400px" src="//jsfiddle.net/HDL52/tm3o4ncj/8/embedded/result/dark/" frameborder="0" loading="lazy" allowtransparency="true" allowfullscreen="true"></iframe><iframe width="100%" height="400px" src="//jsfiddle.net/HDL52/gmydz8ew/11/embedded/result/dark/" frameborder="0" loading="lazy" allowtransparency="true" allowfullscreen="true"></iframe><iframe width="100%" height="400px" src="//jsfiddle.net/HDL52/twL2a3nk/106/embedded/result/dark/" frameborder="0" loading="lazy" allowtransparency="true" allowfullscreen="true"></iframe><hr><h3 id="Hover-效果"><a href="#Hover-效果" class="headerlink" title="Hover 效果"></a>Hover 效果</h3><iframe width="100%" height="400px" src="//jsfiddle.net/HDL52/bf476zy1/11/embedded/result/dark/" allowfullscreen="allowfullscreen" allowpaymentrequest frameborder="0"></iframe><iframe width="100%" height="400px" src="//jsfiddle.net/HDL52/ok27hLs1/8/embedded/result/dark/" allowfullscreen="allowfullscreen" allowpaymentrequest frameborder="0"></iframe><iframe width="100%" height="400px" src="//jsfiddle.net/HDL52/fw9reojc/105/embedded/result/dark/" allowfullscreen="allowfullscreen" allowpaymentrequest frameborder="0"></iframe><iframe width="100%" height="400px" src="//jsfiddle.net/HDL52/anumv6g4/87/embedded/result/dark/" allowfullscreen="allowfullscreen" allowpaymentrequest frameborder="0"></iframe><hr><h3 id="无限图片"><a href="#无限图片" class="headerlink" title="无限图片"></a>无限图片</h3><iframe src="https://codesandbox.io/embed/k98xf4?view=preview&hidenavigation=1"     style="width:100%; height: 500px; border:0; border-radius: 4px; overflow:hidden;"     title="无限滑动"     allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"     sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"   ></iframe><iframe width="100%" height="400px" src="//jsfiddle.net/HDL52/y9gmv76d/64/embedded/result/dark/" frameborder="0" loading="lazy" allowtransparency="true" allowfullscreen="true"></iframe><hr><h3 id="神光效果"><a href="#神光效果" class="headerlink" title="神光效果"></a>神光效果</h3><iframe width="100%" height="400px" src="//jsfiddle.net/HDL52/cLmaf6tu/66/embedded/result/dark/" frameborder="0" loading="lazy" allowtransparency="true" allowfullscreen="true"></iframe><iframe width="100%" height="400px" src="//jsfiddle.net/HDL52/4wcd6th1/113/embedded/result/dark/" frameborder="0" loading="lazy" allowtransparency="true" allowfullscreen="true"></iframe><iframe width="100%" height="400px" src="//jsfiddle.net/HDL52/aLujzrpe/8/embedded/result/dark/" frameborder="0" loading="lazy" allowtransparency="true" allowfullscreen="true"></iframe><hr><h3 id="kokomi-js-用例"><a href="#kokomi-js-用例" class="headerlink" title="kokomi.js 用例"></a>kokomi.js 用例</h3><iframe src="https://codesandbox.io/embed/p4xxc9?view=preview&module=%2Ffrag.glsl&hidenavigation=1"     style="width:100%; height: 500px; border:0; border-radius: 4px; overflow:hidden;"     title="GL 效果"     allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"     sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"   ></iframe><hr><h3 id="跑马灯效果"><a href="#跑马灯效果" class="headerlink" title="跑马灯效果"></a>跑马灯效果</h3><ul><li>也叫做 <code>Marquee</code></li></ul><iframe width="100%" height="400px" src="//jsfiddle.net/HDL52/s8r6qtmg/153/embedded/result/dark/" frameborder="0" loading="lazy" allowtransparency="true" allowfullscreen="true"></iframe><iframe src="https://codesandbox.io/embed/kny9r5?view=preview&module=%2Fsrc%2FApp.js&hidenavigation=1"     style="width:100%; height: 400px; border:0; border-radius: 4px; overflow:hidden;"     title="focused-diffie"     allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"     sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"   ></iframe><iframe width="100%" height="400px" src="//jsfiddle.net/HDL52/zfvc9uqd/9/embedded/result/dark/" frameborder="0" loading="lazy" allowtransparency="true" allowfullscreen="true"></iframe><hr><h3 id="文字-Hover-翻转"><a href="#文字-Hover-翻转" class="headerlink" title="文字 Hover 翻转"></a>文字 Hover 翻转</h3><iframe src="https://codesandbox.io/embed/xhs6ws?view=preview&module=%2Fsrc%2FApp.js&hidenavigation=1"     style="width:100%; height: 500px; border:0; border-radius: 4px; overflow:hidden;"     title="翻转"     allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"     sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"   ></iframe><hr><h3 id="手电筒效果"><a href="#手电筒效果" class="headerlink" title="手电筒效果"></a>手电筒效果</h3><iframe width="100%" height="400px" src="//jsfiddle.net/HDL52/y5vo3kgp/57/embedded/result/dark/" allowfullscreen="allowfullscreen" allowpaymentrequest frameborder="0"></iframe><hr><h3 id="SVG-滤波器"><a href="#SVG-滤波器" class="headerlink" title="SVG 滤波器"></a>SVG 滤波器</h3><iframe width="100%" height="400px" src="//jsfiddle.net/HDL52/f4um57ns/73/embedded/result/dark/" allowfullscreen="allowfullscreen" allowpaymentrequest frameborder="0"></iframe><iframe width="100%" height="400px" src="//jsfiddle.net/HDL52/yfon0cp4/27/embedded/result/dark/" frameborder="0" loading="lazy" allowtransparency="true" allowfullscreen="true"></iframe><iframe width="100%" height="400px" src="//jsfiddle.net/HDL52/quyLpxzm/88/embedded/result/dark/" frameborder="0" loading="lazy" allowtransparency="true" allowfullscreen="true"></iframe><hr><h3 id="我的名字"><a href="#我的名字" class="headerlink" title="我的名字"></a>我的名字</h3><iframe width="100%" height="400px" src="//jsfiddle.net/HDL52/rdnx8m71/19/embedded/result/dark/" frameborder="0" loading="lazy" allowtransparency="true" allowfullscreen="true"></iframe><iframe width="100%" height="400px" src="//jsfiddle.net/HDL52/xmbL8eka/13/embedded/result/dark/" frameborder="0" loading="lazy" allowtransparency="true" allowfullscreen="true"></iframe><iframe width="100%" height="400px" src="//jsfiddle.net/HDL52/tfqcp70b/30/embedded/result/dark/" frameborder="0" loading="lazy" allowtransparency="true" allowfullscreen="true"></iframe><hr><h3 id="横向滑动"><a href="#横向滑动" class="headerlink" title="横向滑动"></a>横向滑动</h3><iframe src="https://codesandbox.io/embed/pm4cpy?view=preview"     style="width:100%; height: 500px; border:0; border-radius: 4px; overflow:hidden;"     title="H-Scroll"     allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"     sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"   ></iframe><ul><li>下面这个是纯原生实现</li></ul><iframe src="https://codesandbox.io/embed/98mlvg?view=preview&module=%2Fsrc%2Fscrollable.css&hidenavigation=1"     style="width:100%; height: 500px; border:0; border-radius: 4px; overflow:hidden;"     title="H-Scroll-2"     allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"     sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"   ></iframe><hr><h3 id="签名特效"><a href="#签名特效" class="headerlink" title="签名特效"></a>签名特效</h3><iframe width="100%" height="400px" src="//jsfiddle.net/HDL52/5bhxLd16/embedded/result/dark/" frameborder="0" loading="lazy" allowtransparency="true" allowfullscreen="true"></iframe><iframe width="100%" height="400px" src="//jsfiddle.net/HDL52/aozhc9k2/124/embedded/result/dark/" frameborder="0" loading="lazy" allowtransparency="true" allowfullscreen="true"></iframe><hr><h3 id="3D-菜单"><a href="#3D-菜单" class="headerlink" title="3D 菜单"></a>3D 菜单</h3><iframe width="100%" height="400px" src="//jsfiddle.net/HDL52/14am63yv/101/embedded/result/dark/" frameborder="0" loading="lazy" allowtransparency="true" allowfullscreen="true"></iframe><hr><h3 id="电影文字特效"><a href="#电影文字特效" class="headerlink" title="电影文字特效"></a>电影文字特效</h3><iframe width="100%" height="400px" src="//jsfiddle.net/HDL52/8m21o0bd/13/embedded/result/dark/" frameborder="0" loading="lazy" allowtransparency="true" allowfullscreen="true"></iframe><hr><h3 id="暖色背景"><a href="#暖色背景" class="headerlink" title="暖色背景"></a>暖色背景</h3><iframe width="100%" height="400px" src="//jsfiddle.net/HDL52/2p09ko8w/57/embedded/result/dark/" frameborder="0" loading="lazy" allowtransparency="true" allowfullscreen="true"></iframe><hr><h3 id="图片通过滑动展出"><a href="#图片通过滑动展出" class="headerlink" title="图片通过滑动展出"></a>图片通过滑动展出</h3><iframe width="100%" height="400px" src="//jsfiddle.net/HDL52/uf42ortp/17/embedded/result/dark/" frameborder="0" loading="lazy" allowtransparency="true" allowfullscreen="true"></iframe><hr><h3 id="原生划入动效"><a href="#原生划入动效" class="headerlink" title="原生划入动效"></a>原生划入动效</h3><iframe width="100%" height="400px" src="//jsfiddle.net/HDL52/w9L0cq3g/177/embedded/result/dark/" frameborder="0" loading="lazy" allowtransparency="true" allowfullscreen="true"></iframe><hr><h3 id="Rellax-js-用例"><a href="#Rellax-js-用例" class="headerlink" title="Rellax.js 用例"></a>Rellax.js 用例</h3><iframe width="100%" height="400px" src="//jsfiddle.net/HDL52/yabeLhsc/8/embedded/result/dark/" frameborder="0" loading="lazy" allowtransparency="true" allowfullscreen="true"></iframe><hr><h3 id="文字展示视频"><a href="#文字展示视频" class="headerlink" title="文字展示视频"></a>文字展示视频</h3><iframe width="100%" height="400px" src="//jsfiddle.net/HDL52/2zvc8La6/18/embedded/result/dark/" frameborder="0" loading="lazy" allowtransparency="true" allowfullscreen="true"></iframe><hr><h3 id="故障特效"><a href="#故障特效" class="headerlink" title="故障特效"></a>故障特效</h3><iframe width="100%" height="400px" src="//jsfiddle.net/HDL52/mavrgsu6/46/embedded/result/dark/" frameborder="0" loading="lazy" allowtransparency="true" allowfullscreen="true"></iframe><hr><h3 id="菜单特效"><a href="#菜单特效" class="headerlink" title="菜单特效"></a>菜单特效</h3><iframe width="100%" height="400px" src="//jsfiddle.net/HDL52/d5romxb3/34/embedded/result/dark/" frameborder="0" loading="lazy" allowtransparency="true" allowfullscreen="true"></iframe><hr><h3 id="原生导航栏"><a href="#原生导航栏" class="headerlink" title="原生导航栏"></a>原生导航栏</h3><iframe width="100%" height="400px" src="//jsfiddle.net/HDL52/7jxotqu1/5/embedded/result/dark/" frameborder="0" loading="lazy" allowtransparency="true" allowfullscreen="true"></iframe><hr><h3 id="创意列表交互"><a href="#创意列表交互" class="headerlink" title="创意列表交互"></a>创意列表交互</h3><iframe width="100%" height="400px" src="//jsfiddle.net/HDL52/o6n78gak/24/embedded/result/dark/" frameborder="0" loading="lazy" allowtransparency="true" allowfullscreen="true"></iframe><iframe width="100%" height="400px" src="//jsfiddle.net/HDL52/dzbf2wva/64/embedded/result/dark/" frameborder="0" loading="lazy" allowtransparency="true" allowfullscreen="true"></iframe><hr><h3 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h3><blockquote><p>请勿随意修改，谢谢</p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C# 关键字解析</title>
      <link href="/posts/cd5cb147.html"/>
      <url>/posts/cd5cb147.html</url>
      
        <content type="html"><![CDATA[<h2 id="C-中的关键字解析"><a href="#C-中的关键字解析" class="headerlink" title="C# 中的关键字解析"></a>C# 中的关键字解析</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><ul><li><p>结合<a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/">微软文档</a>，对<code>C#</code>中的关键字进行解析。</p></li><li><p>文章中，派生类默认为子类，基类默认为父类。</p></li><li><p>部分常见关键字省略: <a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/builtin-types/bool">bool</a>，<a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/statements/jump-statements#the-break-statement">break</a>，<a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/statements/selection-statements#the-switch-statement">case</a>，<a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/builtin-types/char">char</a>，<a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/statements/jump-statements#the-continue-statement">continue</a>，<a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/default">default</a>，<a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/statements/iteration-statements#the-do-statement">do</a>，<a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/builtin-types/floating-point-numeric-types">double</a>，<a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/statements/selection-statements#the-if-statement">else</a>，<a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/builtin-types/bool">false</a>，<a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/builtin-types/floating-point-numeric-types">float</a>，<a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/statements/iteration-statements#the-for-statement">for</a>，<a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/statements/selection-statements#the-if-statement">if</a>，<a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/builtin-types/integral-numeric-types">int</a>，<a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/builtin-types/integral-numeric-types">long</a>，<a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/new-operator">new</a>，<a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/public">public</a>，<a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/statements/jump-statements#the-return-statement">return</a>，<a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/sizeof">sizeof</a>，<a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/builtin-types/reference-types">string</a>，<a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/builtin-types/bool">true</a>，<a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/statements/exception-handling-statements">try</a>，<a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/type-testing-and-cast#typeof-operator">typeof</a>，<a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/builtin-types/void">void</a>，<a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/statements/iteration-statements#the-while-statement">while</a></p></li><li><p>关键字省略 (感觉可能用不到, 这里指的是日常哈): <a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/statements/checked-and-unchecked">checked</a>，<a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/extern">extern</a>，<a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/statements/fixed">fixed</a>，<a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/statements/jump-statements#the-goto-statement">goto</a>，<a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/user-defined-conversion-operators">implicit</a>，<a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/in">in</a>，<a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/statements/lock">lock</a>，<a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/programming-guide/types/boxing-and-unboxing">object</a>，<a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/operator-overloading">operator</a>，<a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/builtin-types/integral-numeric-types">sbyte</a>，<a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/builtin-types/integral-numeric-types">short</a>，<a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/stackalloc">stackalloc</a>，<a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/builtin-types/integral-numeric-types">uint</a>，<a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/builtin-types/integral-numeric-types">ulong</a>，<a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/statements/checked-and-unchecked">unchecked</a>，<a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/unsafe">unsafe</a>，<a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/builtin-types/integral-numeric-types">ushort</a>，<a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/volatile">volatile</a></p></li></ul><hr><h3 id="1-abstract-关键字"><a href="#1-abstract-关键字" class="headerlink" title="1. abstract 关键字"></a>1. abstract 关键字</h3><p>在<code>C#</code>中，关键字<a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/abstract"><code>abstract</code></a>用于<ins>声明抽象类或类中的抽象成员</ins>。</p><p>抽象类特点:</p><ol><li>抽象类不能实例化 (不能使用<code>new</code>关键字)。</li><li>抽象类可能包含抽象成员（方法、属性）和非抽象成员的实现。</li><li>只有抽象类中才允许抽象方法声明。</li><li>抽象类通常作为基类被子类继承，子类必须使用<code>override</code>实现抽象类中声明的抽象成员。</li></ol><p>抽象方法特点:</p><ol><li>凡是包含抽象方法的类都是抽象类。</li><li>抽象方法声明不提供实际的实现，因此没有方法主体。（抽象属性同理）</li><li>在抽象方法声明中不能使用<code>static</code>或<code>virtual</code>关键字。<ul><li>抽象方法没有具体实现，所以不能使用<code>static</code>关键字来声明为静态方法。</li><li>抽象方法是隐式的虚拟方法，所以不需要<code>virtual</code>关键字。</li></ul></li></ol><p>举个例子:</p><ul><li>枪（抽象基类）是可以 <code>Shoot</code> 和 <code>Reload</code>（抽象方法）。</li><li>比如<code>AK47</code>和<code>M4</code> (非抽象类子类)，它们拥有 <code>Shoot</code> 和 <code>Reload</code> 的功能。</li><li>但具体是怎么 <code>Shoot</code> 和 <code>Reload</code>，<code>AK47</code>和<code>M4</code>是不一样的（具体实现）。</li></ul><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 抽象类：Firearms</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Firearms</span></span><br><span class="line"> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">Shoot</span>()</span>; <span class="comment">// 抽象方法</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">Reload</span>()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">Init</span>()</span> &#123;...&#125; <span class="comment">// 非抽象方法</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="built_in">string</span> FireRate &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; <span class="comment">// 抽象属性</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类：AK47</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">AK47</span> : <span class="title">Firearms</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> fireRate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Shoot</span>()</span> &#123;...&#125; <span class="comment">// 具体实现</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Reload</span>()</span> &#123;...&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">override</span> <span class="built_in">string</span> FireRate</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> fireRate; &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123; fireRate = <span class="keyword">value</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么要用抽象类，而不是使用一般类<code>class</code>或者接口<code>interface</code>？</p><ol><li>共享代码：<ins>抽象类可以定义一组相关类的通用行为和属性，并提供默认的实现。通过继承抽象类，子类可以继承和重用抽象类中的代码</ins>，减少代码的重复编写。这样可以提高代码的可维护性和扩展性。(这里指的是在 <code>abstract class</code> 里声明的非抽象方法)</li><li>代码扩展性：抽象类可以包含抽象方法，这些方法在抽象类中没有具体的实现。通过继承抽象类并实现这些抽象方法，子类可以在具体的业务逻辑中实现自己的代码。这种方式使得代码具有扩展性，可以适应未来需求的变化。</li><li>部分实现：抽象类既可以包含抽象方法，也可以包含具体的实现。这使得抽象类可以提供一些默认的行为，同时也给子类提供了一定的灵活性。子类可以选择性地覆盖抽象类中的方法，或者直接使用抽象类中的实现。</li><li>（待补充）</li></ol><blockquote><p>注意, 从 <code>C# 8.0</code> 开始 <code>interface</code> 就可以在接口里提供默认的实现</p></blockquote><hr><h3 id="2-as-关键字"><a href="#2-as-关键字" class="headerlink" title="2. as 关键字"></a>2. as 关键字</h3><p>在<code>C#</code>中，关键字<a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/type-testing-and-cast#as-operator"><code>as</code></a>用于类型转换。</p><ul><li>在实际应用中，通常会与<code>null</code>检查一起使用<code>as</code>关键字。这是因为，如果转换不成功，<code>as</code>会返回<code>null</code>，而不是抛出异常。这使得<code>as</code>关键字在面对类型转换失败时的行为更加温和。</li></ul><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Animal</span> &#123; ... &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Dog</span> : <span class="title">Animal</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">Animal animal = <span class="keyword">new</span> Dog();</span><br><span class="line">Dog dog = animal <span class="keyword">as</span> Dog;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (dog != <span class="literal">null</span>)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Successful&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Failed&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>as</code>关键字尝试将<code>animal</code>转换为<code>Dog</code>类型。由于<code>animal</code>对象实际上是一个<code>Dog</code>类型的对象，所以转换成功。如果<code>animal</code>对象是<code>Animal</code>类型的对象，则上面代码会转换失败。</p><hr><h3 id="3-base-关键字"><a href="#3-base-关键字" class="headerlink" title="3. base 关键字"></a>3. base 关键字</h3><p>在<code>C#</code>中，<code>base</code>关键字用于<ins>在子类中引用基类的成员或调用基类的构造函数</ins>。</p><ul><li><code>base</code>关键字只能用于子类，而不是基类中。</li><li>如果基类成员是私有的，即使使用<code>base</code>关键字也无法访问。</li><li>在静态方法中使用 <code>base</code> 关键字将产生错误。</li><li>如果基类中有多个构造函数重载，子类在使用<code>base</code>关键字调用父类构造函数时，需要选择要调用的具体构造函数，并且提供与所选基类构造函数匹配的参数列表。</li></ul><p>下面是<code>base</code>关键字的几种常见用法</p><ul><li>调用基类的构造函数</li></ul><p>在派生类的构造函数中，可以使用<code>base</code>关键字调用基类的构造函数。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BaseClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 基类的构造函数 1</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BaseClass</span>(<span class="params"><span class="built_in">int</span> x</span>)</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 基类的构造函数 2</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BaseClass</span>(<span class="params"><span class="built_in">int</span> x, <span class="built_in">int</span> y</span>)</span> &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DerivedClass</span> : <span class="title">BaseClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 派生类的构造函数</span></span><br><span class="line">    <span class="comment">// 执行其他派生类的构造逻辑</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DerivedClass</span>(<span class="params"><span class="built_in">int</span> x</span>) : <span class="title">base</span>(<span class="params">x</span>)</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DerivedClass</span>(<span class="params"><span class="built_in">int</span> x, <span class="built_in">int</span> y</span>) : <span class="title">base</span>(<span class="params">x, y</span>)</span> &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x = <span class="keyword">new</span> DerivedClass(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">var</span> y = <span class="keyword">new</span> DerivedClass(<span class="number">1</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>上面代码中，<code>DerivedClass</code>继承自<code>BaseClass</code>。在<code>DerivedClass</code>的构造函数中，使用<code>base(x)</code>调用了基类<code>BaseClass</code>的构造函数，并传递参数<code>x</code>。</p><ul><li>引用基类的成员</li></ul><p>当<ins>派生类中定义了一个与基类相同名称的成员变量或方法</ins>时，可以使用<code>base</code>关键字来访问它。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BaseClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 基类的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SomeMethod</span>()</span> &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DerivedClass</span> : <span class="title">BaseClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 调用基类的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SomeMethod</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">base</span>.SomeMethod();</span><br><span class="line">        <span class="comment">// ... 其他逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>DerivedClass</code>继承自<code>BaseClass</code>。在<code>DerivedClass</code>中的<code>SomeMethod</code>方法中，使用<code>base.SomeMethod()</code>调用了基类<code>BaseClass</code>的方法。</p><p>为什么要使用<code>base</code>去调用基类的构造函数？</p><ol><li>继承基类的行为和状态: 通过调用基类的构造函数，子类可以继承基类的行为和状态。基类可能包含一些重要的初始化逻辑，以确保它的成员和属性处于正确的状态。</li><li>提供基类所需的初始化参数: 如果基类的构造函数需要接收参数来进行初始化，派生类可以通过调用基类构造函数并传递适当的参数，来提供必要的信息。</li><li>避免冗余代码: 如果基类的构造函数已经包含了一些通用的、所有派生类都需要的初始化代码，那么在派生类中通过使用<code>base</code>关键字调用基类构造函数，可以避免重复编写这些初始化代码。</li><li>（待补充）</li></ol><hr><h3 id="4-byte-关键字"><a href="#4-byte-关键字" class="headerlink" title="4. byte 关键字"></a>4. byte 关键字</h3><p>在<code>C#</code>中，<code>byte</code>关键字用于声明一个<code>8</code>位无符号（<code>unsigned</code>）整数类型的变量。</p><p><code>byte</code>关键字在<code>C#</code>中具有多种用途和应用场景</p><ul><li>存储和处理二进制数据: <code>byte</code>类型是一个<code>8</code>位无符号整数，范围从<code>0</code>到<code>255</code>。因此，它非常适合用于存储和处理二进制数据，如图像、音频、视频、文件等。</li><li>网络编程: 在网络编程中，常常需要使用<code>byte</code>类型来读取和写入数据流、处理网络字节序等。</li><li>数据序列化和反序列化: 序列化是将对象转换为字节序列的过程，而反序列化则是将字节序列转换回对象。在数据序列化和反序列化过程中，<code>byte</code>类型通常用于表示和操作字节数据。</li><li>…</li></ul><p>举个例子：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 读取图像文件的字节数据</span></span><br><span class="line"><span class="built_in">byte</span>[] imageData = File.ReadAllBytes(<span class="string">&quot;image.jpg&quot;</span>);</span><br><span class="line"><span class="comment">// 对数据进行压缩，返回压缩后的字节数据</span></span><br><span class="line"><span class="built_in">byte</span>[] compressedData = CompressData(originalData);</span><br></pre></td></tr></table></figure><hr><h3 id="5-异常处理关键字"><a href="#5-异常处理关键字" class="headerlink" title="5. 异常处理关键字"></a>5. 异常处理关键字</h3><p>在<code>C#</code>中，<code>try</code>关键字用于定义一个<code>try</code>块，表示其中可能会出现异常。</p><ul><li><code>try</code>块后面通常跟随一个或多个<code>catch</code>块，用于处理可能抛出的特定异常。最后还可以选择性地包含一个<code>finally</code>块，它包含的代码无论是否抛出异常都会被执行。</li></ul><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.IO;</span><br><span class="line"></span><br><span class="line">StreamReader reader = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    reader = <span class="keyword">new</span> StreamReader(<span class="string">&quot;nonexistent_file.txt&quot;</span>);</span><br><span class="line">    Console.WriteLine(reader.ReadToEnd());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (FileNotFoundException ex)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 处理文件找不到的异常</span></span><br><span class="line">    Console.WriteLine(<span class="string">&quot;File not found: &quot;</span> + ex.FileName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Exception ex)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 处理其他类型的异常</span></span><br><span class="line">    Console.WriteLine(<span class="string">&quot;An error occurred: &quot;</span> + ex.Message);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 确保关闭StreamReader对象，释放系统资源</span></span><br><span class="line">    <span class="keyword">if</span> (reader != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        reader.Close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，如果<code>try</code>块中的代码引发了异常，程序会立即跳转到<code>catch</code>块，寻找与异常类型匹配的<code>catch</code>块，并执行相应的代码块。每个<code>catch</code>块可以捕获并处理特定类型的异常。</p><ul><li>处理异步函数的异常<br>异步函数通常返回一个<code>Task</code>或<code>Task&lt;T&gt;</code>对象。可以在<code>try</code>块中<code>await</code>这个任务，并在<code>catch</code>块中处理可能的异常。</li></ul><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 有可能抛出异常的异步操作</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">SomeAsyncOperation</span>()</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">HandleAsyncOperation</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">await</span> SomeAsyncOperation();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Exception ex)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;An exception occurred: <span class="subst">&#123;ex.Message&#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外，不是所有的异常都应该被捕获。在大多数情况下，只应该捕获知道如何处理的异常。对于不知道如何处理的异常，最好让它们传播出去，这样调用者或者全局异常处理器可以捕获并处理它们。</p><p>（这里暂时省略处理迭代器方法中的异常，待补充）</p><hr><h3 id="6-class-关键字"><a href="#6-class-关键字" class="headerlink" title="6. class 关键字"></a>6. class 关键字</h3><p>在<code>C#</code>中，<a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/class"><code>class</code></a>关键字用于定义一个类。</p><ul><li>类是一种引用类型，它定义了一组属性（字段、常量和事件）、方法和索引器的组合。类可以直接实例化，也可以作为基类继承。</li></ul><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 类的成员变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> myInt;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 类的构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyClass</span>(<span class="params"><span class="built_in">int</span> <span class="keyword">value</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        myInt = <span class="keyword">value</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 类的成员方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PrintValue</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;MyInt = &quot;</span> + myInt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><ins><code>C#</code> 中仅允许单一继承，即一个类仅能从一个基类继承实现。但是，一个类可拥有多个接口</ins> (重要)。</p><table><thead><tr><th align="left">继承</th><th align="left">示例</th></tr></thead><tbody><tr><td align="left">无</td><td align="left">class ClassA { }</td></tr><tr><td align="left">单一</td><td align="left">class DerivedClass : BaseClass { }</td></tr><tr><td align="left">无，实现两个接口</td><td align="left">class ImplClass : IFace1, IFace2 { }</td></tr><tr><td align="left">单一，实现一个接口</td><td align="left">class ImplDerivedClass : BaseClass, IFace1 { }</td></tr></tbody></table><ul><li><p>下面是一些类的使用方法</p></li><li><p>(1) 访问修饰符: 类的访问修饰符决定了它在代码中的可见性。默认情况下，类是<code>internal</code>的，意味着它只在同一程序集中可见。类的成员默认是<code>private</code>的，只能在类的内部访问。</p></li><li><p>(2) 静态类: 使用<code>static</code>关键字可以定义静态类和静态成员。静态类不能实例化，不能被继承，且只能包含静态成员。静态成员只有一份，属于类本身，而不属于类的任何实例。</p></li></ul><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">MathUtils</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">Add</span>(<span class="params"><span class="built_in">int</span> a, <span class="built_in">int</span> b</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">double</span> <span class="title">SquareRoot</span>(<span class="params"><span class="built_in">double</span> <span class="keyword">value</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> Math.Sqrt(<span class="keyword">value</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MathUtils.Add(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">MathUtils.SquareRoot(<span class="number">4.0</span>)</span><br></pre></td></tr></table></figure><ul><li><p>(3) 构造函数: 类可以有一个或多个构造函数，用于创建类的实例。构造函数的名称必须与类名相同，且不返回任何值。</p></li><li><p>(4) 静态构造函数: <ins>用于初始化静态成员或执行静态初始化代码</ins>。它没有参数列表，也不能直接调用。<ins>静态构造函数在类的第一个实例或静态成员被访问之前自动调用，并且只执行一次</ins>。</p></li></ul><p>访问静态成员时调用</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">int</span> myStaticField;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">readonly</span> <span class="built_in">int</span> myStaticReadOnlyField;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="title">MyClass</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 静态构造函数用于初始化静态成员</span></span><br><span class="line">        myStaticField = <span class="number">10</span>;</span><br><span class="line">        myStaticReadOnlyField = <span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">MyMethod</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;MyStaticField: &quot;</span> + myStaticField);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;MyStaticReadOnlyField: &quot;</span> + myStaticReadOnlyField);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用静态方法，静态构造函数会在此时自动执行</span></span><br><span class="line">MyClass.MyMethod();</span><br><span class="line"></span><br><span class="line"><span class="comment">// MyStaticField: 10</span></span><br><span class="line"><span class="comment">// MyStaticReadOnlyField: 20</span></span><br></pre></td></tr></table></figure><p>创建类的实例时调用</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">int</span> myStaticField;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">readonly</span> <span class="built_in">int</span> myStaticReadOnlyField;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="title">MyClass</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        myStaticField = <span class="number">10</span>;</span><br><span class="line">        myStaticReadOnlyField = <span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyClass</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;MyStaticField: &quot;</span> + myStaticField);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;MyStaticReadOnlyField: &quot;</span> + myStaticReadOnlyField);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建类的第一个实例，静态构造函数会在此时自动调用</span></span><br><span class="line">MyClass obj = <span class="keyword">new</span> MyClass();</span><br><span class="line"></span><br><span class="line"><span class="comment">// MyStaticField: 10</span></span><br><span class="line"><span class="comment">// MyStaticReadOnlyField: 20</span></span><br></pre></td></tr></table></figure><ul><li>(5) 内部类: 内部类是定义在另一个类内部的类。内部类拥有访问外部类成员的特权，可以用于实现更复杂的逻辑和封装。（注意，虽然内部类可以访问其外部类的所有成员，但反过来不成立。）</li></ul><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">OuterClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> outerField = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">InnerClass</span></span><br><span class="line">    &#123;</span><br><span class="line">        OuterClass outer;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构造函数，通过参数将外部类实例传入</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">InnerClass</span>(<span class="params">OuterClass outer</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>.outer = outer;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">InnerMethod</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(outer.outerField);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> InnerClass <span class="title">CreateInnerClass</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> InnerClass(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">OuterClass outer = <span class="keyword">new</span> OuterClass();</span><br><span class="line">OuterClass.InnerClass inner = outer.CreateInnerClass();</span><br><span class="line">inner.InnerMethod(); <span class="comment">// 10</span></span><br></pre></td></tr></table></figure><ul><li>(6) 泛型类: 泛型类具有在实例化时可以指定参数类型的特性，从而提供了更灵活和类型安全的代码重用方式。</li></ul><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyGenericClass</span>&lt;<span class="title">T</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> T myField;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyGenericClass</span>(<span class="params">T <span class="keyword">value</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        myField = <span class="keyword">value</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">MyMethod</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> myField;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyGenericClass&lt;<span class="built_in">int</span>&gt; intObj = <span class="keyword">new</span> MyGenericClass&lt;<span class="built_in">int</span>&gt;(<span class="number">10</span>);</span><br><span class="line"><span class="built_in">int</span> <span class="keyword">value</span> = intObj.MyMethod(); <span class="comment">// 返回值为 10</span></span><br><span class="line"></span><br><span class="line">MyGenericClass&lt;<span class="built_in">string</span>&gt; stringObj = <span class="keyword">new</span> MyGenericClass&lt;<span class="built_in">string</span>&gt;(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"><span class="built_in">string</span> text = stringObj.MyMethod(); <span class="comment">// 返回值为 &quot;Hello&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>C#</code>还有许多其他不同的类，比如之前介绍的抽象类，还有接口，密封类，枚举类，部分类，特性类，委托类等等。（待补充）</p><hr><h3 id="7-const-关键字"><a href="#7-const-关键字" class="headerlink" title="7. const 关键字"></a>7. const 关键字</h3><p>在<code>C#</code>中，<code>const</code>关键字来声明某个常量字段或局部变量。常量字段和常量局部变量不是变量并且不能修改。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">int</span> X = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">const</span> <span class="built_in">double</span> GravitationalConstant = <span class="number">6.673e-11</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">const</span> <span class="built_in">string</span> ProductName = <span class="string">&quot;Visual C#&quot;</span>;</span><br></pre></td></tr></table></figure><hr><h3 id="8-decimal-关键字"><a href="#8-decimal-关键字" class="headerlink" title="8. decimal 关键字"></a>8. decimal 关键字</h3><p>在<code>C#</code>中，当所需的精度由小数点右侧的位数决定时，<a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/builtin-types/floating-point-numeric-types"><code>decimal</code></a>关键字是合适的。</p><ul><li>它是一种数据类型，用于存储精确的十进制数值（支持小数点后<code>28</code>的精确度），适用于需要高精度计算的场景，例如财务和货币计算。</li></ul><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">decimal</span> myDecimal = <span class="number">3.14</span>m; <span class="comment">// 使用后缀 &quot;m&quot; 表示 decimal 类型</span></span><br><span class="line"><span class="built_in">float</span> myFloat = <span class="number">3.14f</span>; <span class="comment">// 使用后缀 &quot;f&quot; 表示 float 类型</span></span><br><span class="line"><span class="built_in">double</span> myDouble = <span class="number">3.14</span>; <span class="comment">// 默认为 double 类型</span></span><br></pre></td></tr></table></figure><p>注意，<code>decimal</code>类型虽然具有较高的精度和准确性，它的计算速度通常比其他浮点类型，比如 <code>float</code> 和 <code>double</code>，慢。</p><hr><h3 id="9-delegate-关键字"><a href="#9-delegate-关键字" class="headerlink" title="9. delegate 关键字"></a>9. delegate 关键字</h3><p>在<code>C#</code>中，<a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/programming-guide/delegates/"><code>delegate</code></a>关键字用于声明和使用委托。</p><p>它类似于一个装着方法的容器，可以将方法（实例方法，静态方法）作为对象进行传递，但<ins>前提是委托和对应传递方法的签名得是相同的，签名指的是他们的参数类型和返回值类型</ins>。（类似回调函数或者<code>Thunk</code>函数）</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 委托的声明，指定了返回值类型为 int，接收两个 int 类型的参数。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="built_in">int</span> <span class="title">MyDelegate</span>(<span class="params"><span class="built_in">int</span> num1, <span class="built_in">int</span> num2</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Calculator</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 使用委托的一个方法，这里的 method 参数是一个 Operation 类型的委托</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">Calculate</span>(<span class="params"><span class="built_in">int</span> num1, <span class="built_in">int</span> num2, MyDelegate callback</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 在Calculate方法中调用委托</span></span><br><span class="line">        <span class="keyword">return</span> callback(num1, num2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 两个符合 Operation 委托签名的方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">Add</span>(<span class="params"><span class="built_in">int</span> num1, <span class="built_in">int</span> num2</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">Subtract</span>(<span class="params"><span class="built_in">int</span> num1, <span class="built_in">int</span> num2</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 - num2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Calculator calculator = <span class="keyword">new</span> Calculator();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用委托将 Add 方法作为参数传入</span></span><br><span class="line"><span class="built_in">int</span> result = calculator.Calculate(<span class="number">10</span>, <span class="number">5</span>, Add);</span><br><span class="line">Console.WriteLine(result);  <span class="comment">// 输出：15</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用委托将 Subtract 方法作为参数传入</span></span><br><span class="line">result = calculator.Calculate(<span class="number">10</span>, <span class="number">5</span>, Subtract);</span><br><span class="line">Console.WriteLine(result);  <span class="comment">// 输出：5</span></span><br></pre></td></tr></table></figure><p>注意，在<code>C#</code>中创建委托对象时，并不一定需要使用<code>new</code>关键字来实例化委托。</p><ul><li>使用<code>new</code>关键字和委托类型的构造函数创建委托对象</li></ul><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">MyDelegate myDelegate = <span class="keyword">new</span> MyDelegate(ShowMessage);</span><br></pre></td></tr></table></figure><p>在这种情况下，我们使用<code>new MyDelegate</code>语法创建了一个委托对象<code>myDelegate</code>，并将<code>ShowMessage</code>方法绑定到委托上。</p><ul><li>使用隐式方法组转换来创建委托对象</li></ul><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">MyDelegate myDelegate = ShowMessage;</span><br></pre></td></tr></table></figure><p>在这种情况下，我们直接将方法名<code>ShowMessage</code>赋值给委托对象<code>myDelegate</code>，编译器会自动进行隐式方法组转换，将方法转换为委托对象。</p><ul><li>使用匿名方法创建委托对象</li></ul><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">MyDelegate myDelegate = <span class="built_in">delegate</span>(<span class="built_in">string</span> message)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(message);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>匿名方法的语法是使用关键字<code>delegate</code>后跟一个参数列表和方法体。</p><ul><li>使用<code>Lambda</code>表达式创建委托对象</li></ul><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Lambda表达式的参数部分只使用了参数名&quot;message&quot;，而没有指定参数类型。</span></span><br><span class="line"><span class="comment">// 编译器会根据委托类型推断出参数类型。</span></span><br><span class="line">MyDelegate myDelegate = (message) =&gt; Console.WriteLine(message);</span><br></pre></td></tr></table></figure><p>在这种情况下，我们使用<code>Lambda</code>表达式定义了一个匿名方法，将其赋值给委托对象<code>myDelegate</code>。</p><ul><li><p>那什么情况下应该使用委托<code>delegate</code>？</p></li><li><p>(1) 事件处理: 委托广泛用于事件处理模型中。通过定义委托类型和事件，可以将事件与特定的处理方法关联起来。当事件发生时，委托会调用绑定的方法，从而实现事件的处理和响应。</p></li></ul><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明一个委托</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">EventHandler</span>(<span class="params"><span class="built_in">string</span> message</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">EventPublisher</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 声明一个事件，使用之前定义的委托</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">event</span> EventHandler Event;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TriggerEvent</span>(<span class="params"><span class="built_in">string</span> message</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 触发事件</span></span><br><span class="line">        Event?.Invoke(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">EventSubscriber</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Subscribe</span>(<span class="params">EventPublisher publisher</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 订阅事件</span></span><br><span class="line">        publisher.Event += HandleEvent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">HandleEvent</span>(<span class="params"><span class="built_in">string</span> message</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 处理事件</span></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Event received: &quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建事件发布者和订阅者</span></span><br><span class="line">EventPublisher publisher = <span class="keyword">new</span> EventPublisher();</span><br><span class="line">EventSubscriber subscriber = <span class="keyword">new</span> EventSubscriber();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 订阅事件</span></span><br><span class="line">subscriber.Subscribe(publisher);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 触发事件</span></span><br><span class="line">publisher.TriggerEvent(<span class="string">&quot;Hello, World!&quot;</span>);</span><br></pre></td></tr></table></figure><ul><li>(2) 回调函数: 委托可用作回调函数的一种方式。当一个方法需要在完成后通知另一个方法时，可以将委托作为参数传递给该方法，并在适当的时候调用委托以执行回调操作。</li></ul><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">MyCallbackDelegate</span>(<span class="params"><span class="built_in">string</span> message</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Processor</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> MyCallbackDelegate callback;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Processor</span>(<span class="params">MyCallbackDelegate callback</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.callback = callback;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Process</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Processing...</span></span><br><span class="line">        <span class="comment">// Once processing is done, callback is called:</span></span><br><span class="line">        callback(<span class="string">&quot;Processing completed!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a new processor, passing it a callback function:</span></span><br><span class="line">Processor processor = <span class="keyword">new</span> Processor(MyCallback);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Start the processing:</span></span><br><span class="line">processor.Process();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">MyCallback</span>(<span class="params"><span class="built_in">string</span> message</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>(3) 多播委托 (委托链): 委托还支持多播（<code>multicast</code>）的功能，即一个委托可以绑定多个方法。这使得可以将多个方法作为委托的调用列表，并按顺序依次调用它们。</li></ul><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">MyDelegate</span>()</span>;</span><br><span class="line"></span><br><span class="line">MyDelegate myDelegate = Method1;</span><br><span class="line">myDelegate += Method2;</span><br><span class="line">myDelegate += Method3;</span><br><span class="line">myDelegate -= Method4; <span class="comment">// 删除调用列表中的方法</span></span><br><span class="line">myDelegate();  <span class="comment">// 调用委托，依次执行绑定的方法</span></span><br></pre></td></tr></table></figure><ul><li>(4) 泛型委托: <code>C#</code>中的委托支持泛型，可以更好地支持类型安全性和代码重用。</li></ul><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">delegate</span> T <span class="title">MyGenericDelegate</span>&lt;<span class="title">T</span>&gt;(<span class="params">T <span class="keyword">value</span></span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="built_in">int</span> <span class="title">Square</span>(<span class="params"><span class="built_in">int</span> x</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyGenericDelegate&lt;<span class="built_in">int</span>&gt; squareDelegate = Square;</span><br><span class="line"><span class="built_in">int</span> result = squareDelegate(<span class="number">5</span>);</span><br></pre></td></tr></table></figure><ul><li>(5) <code>LINQ</code> 和 <code>Lambda</code> 表达式: 在<code>LINQ</code>中，委托用于定义查询操作。而<code>Lambda</code>表达式实质上是一种特殊的委托，以一种更简洁和强大的方式定义匿名函数。</li></ul><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        List&lt;<span class="built_in">int</span>&gt; numbers = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt; &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span> &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义一个委托，检查一个数是否为偶数</span></span><br><span class="line">        Func&lt;<span class="built_in">int</span>, <span class="built_in">bool</span>&gt; isEven = x =&gt; x % <span class="number">2</span> == <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用LINQ和委托找出所有偶数</span></span><br><span class="line">        IEnumerable&lt;<span class="built_in">int</span>&gt; evens = numbers.Where(isEven);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印所有的偶数</span></span><br><span class="line">        <span class="keyword">foreach</span> (<span class="built_in">int</span> number <span class="keyword">in</span> evens)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(number);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，在<code>C#</code>中，不一定非要使用<code>delegate</code>关键字来定义委托。其实，<code>Func&lt;T, TResult&gt;</code>、<code>Action&lt;T&gt;</code>等都是内置的委托类型，你可以直接使用它们，而无需使用<code>delegate</code>关键字。（<code>C#</code>中内置的委托类型）</p><ul><li>(6) 定制或扩展方法: 在<code>C#</code>中，可以利用委托去定制或扩展方法，改变其行为或增加新的功能。例如，可以使用委托来定制比较方法，从而对集合进行自定义排序。</li></ul><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="built_in">int</span> <span class="title">Comparison</span>&lt;<span class="keyword">in</span> <span class="title">T</span>&gt;(<span class="params">T x, T y</span>)</span>;</span><br><span class="line"></span><br><span class="line">List&lt;<span class="built_in">int</span>&gt; numbers = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt; &#123; <span class="number">5</span>, <span class="number">10</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">6</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个委托实例，传入一个比较方法</span></span><br><span class="line">Comparison&lt;<span class="built_in">int</span>&gt; comparison = (x, y) =&gt; y.CompareTo(x);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 List&lt;T&gt; 类的 Sort 方法，将委托作为参数传入</span></span><br><span class="line">numbers.Sort(comparison);</span><br><span class="line"></span><br><span class="line"><span class="comment">// numbers: &#123; 10, 8, 6, 5, 3 &#125;</span></span><br></pre></td></tr></table></figure><ul><li>(7)（待补充）</li></ul><hr><h3 id="10-enum-关键字"><a href="#10-enum-关键字" class="headerlink" title="10. enum 关键字"></a>10. enum 关键字</h3><p>在 <code>C#</code> 中，<a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/builtin-types/enum"><code>enum</code></a> 关键字用于声明枚举类型。</p><ul><li><p>枚举是一种值类型，它表示一个固定的值集合。这些值被称为枚举成员，并且每一个都有一个关联的常量值。默认情况下，第一个枚举成员的值是<code>0</code>，后续的成员值依次递增<code>1</code>，但是可以显式地改变这个顺序。</p></li><li><p>假设有一个枚举类型定义了一周的天数</p></li></ul><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">enum</span> DayOfWeek</span><br><span class="line">&#123;</span><br><span class="line">    Sunday = <span class="number">0</span>,</span><br><span class="line">    Monday = <span class="number">1</span>,</span><br><span class="line">    Tuesday = <span class="number">2</span>,</span><br><span class="line">    Wednesday = <span class="number">3</span>,</span><br><span class="line">    Thursday = <span class="number">4</span>,</span><br><span class="line">    Friday = <span class="number">5</span>,</span><br><span class="line">    Saturday = <span class="number">6</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>可以创建一个变量来存储当前的星期几</li></ul><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">DayOfWeek today = DayOfWeek.Monday;</span><br></pre></td></tr></table></figure><ul><li>可以将枚举值转换为其他类型，例如整数或字符串</li></ul><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> dayNumber = (<span class="built_in">int</span>)DayOfWeek.Friday;  <span class="comment">// 5</span></span><br><span class="line"><span class="built_in">string</span> dayName = DayOfWeek.Friday.ToString();  <span class="comment">// &quot;Friday&quot;</span></span><br></pre></td></tr></table></figure><ul><li>反过来，也可以将其他类型转换为枚举值</li></ul><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">DayOfWeek day = (DayOfWeek)<span class="number">5</span>;  <span class="comment">// DayOfWeek.Friday</span></span><br><span class="line">DayOfWeek day = Enum.Parse&lt;DayOfWeek&gt;(<span class="string">&quot;Friday&quot;</span>);  <span class="comment">// DayOfWeek.Friday</span></span><br><span class="line"></span><br><span class="line">DayOfWeek day;</span><br><span class="line"><span class="built_in">bool</span> success = Enum.TryParse&lt;DayOfWeek&gt;(<span class="string">&quot;Sunday&quot;</span>, <span class="keyword">out</span> day); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>如果枚举表示的是一组位标志，那么应该使用<code>[Flags]</code>属性，并为枚举成员指定<code>2</code>的幂次方值。这样就可以使用位运算符来组合、添加或移除枚举值。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">Flags</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">enum</span> AccessRights</span><br><span class="line">&#123;</span><br><span class="line">    None = <span class="number">0</span>,     <span class="comment">// 0000</span></span><br><span class="line">    Read = <span class="number">1</span>,     <span class="comment">// 0001</span></span><br><span class="line">    Write = <span class="number">2</span>,    <span class="comment">// 0010</span></span><br><span class="line">    Execute = <span class="number">4</span>,  <span class="comment">// 0100</span></span><br><span class="line">    FullControl = Read | Write | Execute <span class="comment">// 0111</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>AccessRights</code>枚举定义了一组访问权限，每个权限是二进制位的一个标志。这允许我们将不同的权限组合到一起，然后通过位运算检查特定的权限是否存在。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置读和写权限</span></span><br><span class="line">AccessRights rights = AccessRights.Read | AccessRights.Write;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查是否有写权限</span></span><br><span class="line"><span class="keyword">if</span> ((rights &amp; AccessRights.Write) == AccessRights.Write)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;有写权限&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;无写权限&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了位运算符的使用，也可以直接使用<code>HasFlag</code>方法来检查特定的权限是否存在。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">AccessRights rights = AccessRights.Read | AccessRights.Write;</span><br><span class="line"></span><br><span class="line">rights.HasFlag(AccessRights.Write) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><hr><h3 id="11-event-关键字"><a href="#11-event-关键字" class="headerlink" title="11. event 关键字"></a>11. event 关键字</h3><p>在<code>C#</code>中，<a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/event"><code>event</code></a>关键字用于声明一个事件。（<a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/programming-guide/events/how-to-publish-events-that-conform-to-net-framework-guidelines">如何发布符合 .NET 准则的事件</a>）</p><ul><li>事件是由对象在特殊情况下触发的一种机制，例如用户点击了一个按钮，或者某个操作已经完成。对象可以订阅这个事件，这样当事件发生时，就会调用订阅者定义的事件处理程序。</li></ul><p>在事件的定义中，通常会有两部分组成。一部分是声明事件的委托（<code>delegate</code>），另一部分是事件本身。下面是一个简单的<code>event</code>使用例子</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个委托</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">MyEventHandler</span>(<span class="params"><span class="built_in">string</span> message</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Publisher</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 声明一个事件</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">event</span> MyEventHandler MyEvent;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">RaiseEvent</span>(<span class="params"><span class="built_in">string</span> message</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 触发事件</span></span><br><span class="line">        MyEvent?.Invoke(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Subscriber</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Subscribe</span>(<span class="params">Publisher publisher</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 订阅事件</span></span><br><span class="line">        publisher.MyEvent += HandleEvent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">HandleEvent</span>(<span class="params"><span class="built_in">string</span> message</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;收到了来自Publisher的消息： <span class="subst">&#123;message&#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> publisher = <span class="keyword">new</span> Publisher();</span><br><span class="line">        <span class="keyword">var</span> subscriber = <span class="keyword">new</span> Subscriber();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 订阅事件</span></span><br><span class="line">        subscriber.Subscribe(publisher);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发布事件</span></span><br><span class="line">        publisher.RaiseEvent(<span class="string">&quot;Hello, World!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面例子可以看出，事件帮助了事件发布者和订阅者之间的解耦。发布者并不需要知道谁订阅了它的事件，也不需要知道事件将如何被处理。这使得我们可以独立地修改发布者和订阅者的代码，而不需要担心它们之间的依赖关系。</p><ul><li><p><code>event</code>关键字使用注意点</p></li><li><p>(1) 避免内存泄漏</p><ul><li>如果一个对象订阅了另一个对象的事件，那么在不需要订阅事件时应当及时取消订阅，以避免发生内存泄漏。（只要事件发布者还在内存中，订阅者就不会被垃圾回收，即使订阅者已经不再使用）</li></ul></li></ul><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Subscriber</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Subscribe</span>(<span class="params">Publisher publisher</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        publisher.MyEvent += HandleEvent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Unsubscribe</span>(<span class="params">Publisher publisher</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        publisher.MyEvent -= HandleEvent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">HandleEvent</span>(<span class="params"><span class="built_in">object</span> sender, MyEventArgs e</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;收到了来自Publisher的消息： <span class="subst">&#123;e.Message&#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>(2) 委托类型<ul><li><code>System.EventHandler</code> 和 <code>System.EventHandler&lt;T&gt;</code> 是标准的事件委托类型，推荐在事件定义中使用这些类型以提高代码的可读性和一致性。</li></ul></li></ul><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Publisher</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 使用标准的EventHandler</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">event</span> EventHandler MyEvent;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用泛型的EventHandler</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">event</span> EventHandler&lt;MyEventArgs&gt; MyEventWithArgs;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnMyEvent</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        MyEvent?.Invoke(<span class="keyword">this</span>, EventArgs.Empty);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnMyEventWithArgs</span>(<span class="params">MyEventArgs e</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        MyEventWithArgs?.Invoke(<span class="keyword">this</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyEventArgs</span> : <span class="title">EventArgs</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Message &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>(3) 事件访问器<ul><li>事件访问器允许在事件被添加或移除时执行自定义的逻辑。这对于调试或管理订阅者列表非常有用。</li></ul></li></ul><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyEventArgs</span> : <span class="title">EventArgs</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Message &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Publisher</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> EventHandler&lt;MyEventArgs&gt; myEvent;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">event</span> EventHandler&lt;MyEventArgs&gt; MyEvent</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">add</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;添加事件处理程序&quot;</span>);</span><br><span class="line">            myEvent += <span class="keyword">value</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">remove</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;移除事件处理程序&quot;</span>);</span><br><span class="line">            myEvent -= <span class="keyword">value</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnMyEvent</span>(<span class="params">MyEventArgs e</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        myEvent?.Invoke(<span class="keyword">this</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">RaiseEvent</span>(<span class="params"><span class="built_in">string</span> message</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        OnMyEvent(<span class="keyword">new</span> MyEventArgs &#123; Message = message &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Subscriber</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Subscribe</span>(<span class="params">Publisher publisher</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        publisher.MyEvent += HandleEvent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Unsubscribe</span>(<span class="params">Publisher publisher</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        publisher.MyEvent -= HandleEvent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">HandleEvent</span>(<span class="params"><span class="built_in">object</span> sender, MyEventArgs e</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;收到了来自Publisher的消息： <span class="subst">&#123;e.Message&#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Publisher publisher = <span class="keyword">new</span> Publisher();</span><br><span class="line">        Subscriber subscriber = <span class="keyword">new</span> Subscriber();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 订阅事件</span></span><br><span class="line">        subscriber.Subscribe(publisher);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 触发事件</span></span><br><span class="line">        publisher.RaiseEvent(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 取消订阅事件</span></span><br><span class="line">        subscriber.Unsubscribe(publisher);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="12-explicit-关键字"><a href="#12-explicit-关键字" class="headerlink" title="12. explicit 关键字"></a>12. explicit 关键字</h3><p>在<code>C#</code>中，<a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/user-defined-conversion-operators"><code>explicit</code></a>关键字用于类型转换。</p><ul><li><p><code>explicit</code>关键字通常用在用户定义的类型转换操作中，允许从一种数据类型转换到另一种数据类型，例如从类到接口，或者从父类到子类等等。</p></li><li><p>在某些情况下，转换操作可能导致数据丢失或抛出异常。使用<code>explicit</code>关键字可以强制开发者明确地处理转换，从而减少在转换过程中出现错误的可能性。</p></li></ul><p>下面是一个<code>explicit</code>关键字的例子</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Fahrenheit</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> Temperature &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 推荐用 lambda 表达式写</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">Celsius</span>(<span class="params">Fahrenheit f</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> ConvertToFahrenheit(f);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Celsius <span class="title">ConvertToFahrenheit</span>(<span class="params">Fahrenheit f</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">float</span> celsiusTemperature = (<span class="number">5.0f</span> / <span class="number">9.0f</span>) * (f.Temperature - <span class="number">32</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Celsius(celsiusTemperature);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Celsius</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> Temperature &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Celsius</span>(<span class="params"><span class="built_in">float</span> temp</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Temperature = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Fahrenheit f = <span class="keyword">new</span> Fahrenheit &#123; Temperature = <span class="number">100</span> &#125;;</span><br><span class="line">Celsius c = (Celsius)f;  <span class="comment">// 显式转换</span></span><br></pre></td></tr></table></figure><p>上面例子中，不能直接将<code>Fahrenheit</code>对象转换为<code>Celsius</code>，必须明确地进行转换。</p><hr><h3 id="13-foreach-关键字"><a href="#13-foreach-关键字" class="headerlink" title="13. foreach 关键字"></a>13. foreach 关键字</h3><p>在<code>C#</code>中，<code>foreach</code>关键字用于遍历集合（如数组，列表等）中的元素。</p><ul><li>它的工作原理是通过调用集合对象的<code>GetEnumerator</code>方法来获取<code>IEnumerator</code>或<code>IEnumerator&lt;T&gt;</code>对象，然后在每次迭代中调用<code>MoveNext</code>方法和<code>Current</code>属性。</li></ul><blockquote><p>注意，后面<code>IEnumerator</code>和<code>IEnumerator&lt;T&gt;</code>统称为枚举器</p></blockquote><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fibNumbers = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt; &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">13</span> &#125;;</span><br><span class="line"><span class="keyword">foreach</span> (<span class="built_in">int</span> element <span class="keyword">in</span> fibNumbers)</span><br><span class="line">&#123;</span><br><span class="line">    Console.Write(<span class="string">$&quot;<span class="subst">&#123;element&#125;</span> &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// 0 1 1 2 3 5 8 13</span></span><br></pre></td></tr></table></figure><p>下面是一些<code>foreach</code>关键字的使用方法</p><ul><li>(1) 实现枚举器接口的集合<br>在<code>C#</code>中，许多内置集合类型都实现了枚举器接口，这使得它们可以使用<code>foreach</code>循环进行迭代。</li></ul><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Dictionary&lt;<span class="built_in">string</span>, <span class="built_in">int</span>&gt; dictionary = <span class="keyword">new</span> Dictionary&lt;<span class="built_in">string</span>, <span class="built_in">int</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    &#123; <span class="string">&quot;One&quot;</span>, <span class="number">1</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;Two&quot;</span>, <span class="number">2</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;Three&quot;</span>, <span class="number">3</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span> (KeyValuePair&lt;<span class="built_in">string</span>, <span class="built_in">int</span>&gt; item <span class="keyword">in</span> dictionary)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">$&quot;Key: <span class="subst">&#123;item.Key&#125;</span>, Value: <span class="subst">&#123;item.Value&#125;</span>&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>(2) 实现枚举器接口的自定义类<br>如果想要自定义类能够被<code>foreach</code>循环遍历，需要实现枚举器接口。这个接口定义了一个方法，<code>GetEnumerator</code>，返回一个实现了枚举器接口的对象。</li></ul><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyCollection</span> : <span class="title">IEnumerable</span>&lt;<span class="title">int</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span>[] data = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IEnumerator&lt;<span class="built_in">int</span>&gt; <span class="title">GetEnumerator</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; data.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">return</span> data[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    IEnumerator IEnumerable.GetEnumerator()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> GetEnumerator();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用自定义集合</span></span><br><span class="line">MyCollection collection = <span class="keyword">new</span> MyCollection();</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span> (<span class="built_in">int</span> number <span class="keyword">in</span> collection)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(number);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>(3) 异步流的迭代<br>异步流的迭代是<code>C# 8.0</code>新增的特性，这使得我们能够在处理异步操作时，写出更高效和更易于理解的代码。异步流的迭代通过<code>await foreach</code>关键字实现。它能够异步地迭代这样的序列，而不会阻塞主线程。</li></ul><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">async</span> IAsyncEnumerable&lt;<span class="built_in">int</span>&gt; <span class="title">GenerateSequence</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">await</span> Task.Delay(<span class="number">100</span>);  <span class="comment">// 模拟异步操作</span></span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">TestAsyncStream</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="keyword">foreach</span> (<span class="function"><span class="keyword">var</span> number <span class="keyword">in</span> <span class="title">GenerateSequence</span>())</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(number);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述示例中，<code>GenerateSequence</code>方法生成了一个异步序列。每个元素都是在等待一段时间后生成的，以模拟异步操作。<code>TestAsyncStream</code>方法使用<code>await foreach</code>语句来异步地迭代这个序列。每次迭代都会异步地等待下一个元素。</p><hr><h3 id="14-interface-关键字"><a href="#14-interface-关键字" class="headerlink" title="14. interface 关键字"></a>14. interface 关键字</h3><p>在 <code>C#</code> 中，接口<code>interface</code>是一种定义行为契约的类型。接口声明一组方法、属性、事件或索引器，但不提供其实现。类<code>class</code>或结构体<code>struct</code>可以实现一个或多个接口，并提供接口中定义的成员的具体实现。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IAnimal</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Speak</span>()</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Move</span>()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>类或结构体实现接口时，必须提供接口中定义的所有成员的具体实现。</li></ul><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title">IPoint</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Property signatures:</span></span><br><span class="line">    <span class="built_in">int</span> X &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">int</span> Y &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">double</span> Distance &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Point</span> : <span class="title">IPoint</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Constructor:</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Point</span>(<span class="params"><span class="built_in">int</span> x, <span class="built_in">int</span> y</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        X = x;</span><br><span class="line">        Y = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Property implementation:</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> X &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Y &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Property implementation</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">double</span> Distance =&gt;</span><br><span class="line">       Math.Sqrt(X * X + Y * Y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">MainClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">PrintPoint</span>(<span class="params">IPoint p</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;x=&#123;0&#125;, y=&#123;1&#125;&quot;</span>, p.X, p.Y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        IPoint p = <span class="keyword">new</span> Point(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">        Console.Write(<span class="string">&quot;My Point: &quot;</span>);</span><br><span class="line">        PrintPoint(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Output: My Point: x=2, y=3</span></span><br></pre></td></tr></table></figure><ul><li>接口可以从一个或多个其他接口继承。实现该接口的类必须实现所有继承的接口成员。</li></ul><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IDrawable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Draw</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IResizable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Resize</span>(<span class="params"><span class="built_in">double</span> factor</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Shape</span> : <span class="title">IDrawable</span>, <span class="title">IResizable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">double</span> Width &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">double</span> Height &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Shape</span>(<span class="params"><span class="built_in">double</span> width, <span class="built_in">double</span> height</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Width = width;</span><br><span class="line">        Height = height;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实现 IDrawable 接口的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Draw</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;Drawing a shape with width <span class="subst">&#123;Width&#125;</span> and height <span class="subst">&#123;Height&#125;</span>.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实现 IResizable 接口的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Resize</span>(<span class="params"><span class="built_in">double</span> factor</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Width *= factor;</span><br><span class="line">        Height *= factor;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;Resized shape to width <span class="subst">&#123;Width&#125;</span> and height <span class="subst">&#123;Height&#125;</span>.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>接口与抽象类的区别<ul><li>实现: 接口中不能包含任何实现(<code>C# 8.0</code> 的默认接口方法除外)，而抽象类可以包含实现。</li><li>多重继承: 一个类可以实现多个接口，但只能继承一个抽象类。</li><li>构造函数: 接口不能有构造函数，而抽象类可以。</li><li>成员类型: 接口中不能包含字段（成员变量），而抽象类可以。</li></ul></li></ul><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IShape</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 接口不能有构造函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Shape</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Shape</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 构造函数逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IShape</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 接口中不能包含字段</span></span><br><span class="line">    <span class="function"><span class="built_in">double</span> <span class="title">CalculateArea</span>(<span class="params"><span class="built_in">double</span> size</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Shape</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="built_in">double</span> area;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="built_in">double</span> <span class="title">CalculateArea</span>(<span class="params"><span class="built_in">double</span> size</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">double</span> <span class="title">GetArea</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> area;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="15-internal-关键字"><a href="#15-internal-关键字" class="headerlink" title="15. internal 关键字"></a>15. internal 关键字</h3><p>在<code>C#</code>中，<code>internal</code>关键字用于指定成员的可访问性。<code>internal</code>修饰符使成员在同一程序集<code>assembly</code>内可访问，但在程序集外不可访问。(这里的程序集不是指同一个文件, 也不是指<code>namespace</code>)</p><ul><li><p>程序集<code>Assembly</code>: 程序集是<code>.NET</code>中的基本部署单元，可以是一个<code>DLL</code>或<code>EXE</code>文件。一个程序集包含一个或多个命名空间和类型，包含了元数据和代码。程序集是<code>.NET</code>中的物理边界。</p></li><li><p>类的<code>internal</code>可访问性</p><ul><li>在以下示例中，<code>MyClass</code>类被声明为<code>internal</code>，因此它只能在同一程序集内访问。</li></ul></li></ul><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 文件1：MyClass.cs</span></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Display</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Hello from MyClass!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件2：Program.cs</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        MyClass myClass = <span class="keyword">new</span> MyClass();</span><br><span class="line">        myClass.Display();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的示例中，<code>MyClass</code>类和它的<code>Display</code>方法都可以在<code>Program</code>类中访问，因为它们在同一个程序集内。</p><ul><li>方法的<code>internal</code>可访问性<ul><li>在以下示例中，<code>MyClass</code>类是<code>public</code>的，但其中的<code>InternalMethod</code>方法被声明为<code>internal</code>，因此它只能在同一程序集内访问。</li></ul></li></ul><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 文件1：MyClass.cs</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">internal</span> <span class="keyword">void</span> <span class="title">InternalMethod</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Hello from InternalMethod!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件2：Program.cs</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        MyClass myClass = <span class="keyword">new</span> MyClass();</span><br><span class="line">        myClass.InternalMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的示例中，<code>MyClass</code>的<code>InternalMethod</code>方法可以在<code>Program</code>类中访问，因为它们在同一个程序集内。</p><ul><li>跨程序集访问<ul><li>如果尝试从另一个程序集访问<code>internal</code>成员，会导致编译错误。例如，假设有两个项目: <code>ProjectA</code>和<code>ProjectB</code>。<code>ProjectA</code>定义了一个<code>internal</code>类，而<code>ProjectB</code>试图访问它。</li></ul></li></ul><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ProjectA - 文件1：MyClass.cs</span></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Display</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Hello from MyClass!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ProjectB - 文件1：Program.cs</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        MyClass myClass = <span class="keyword">new</span> MyClass(); <span class="comment">// 编译错误：&#x27;MyClass&#x27; is inaccessible due to its protection level</span></span><br><span class="line">        myClass.Display();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个示例中，由于<code>MyClass</code>被声明为<code>internal</code>，所以它不能在<code>ProjectB</code>中访问，会导致编译错误。</p><ul><li>选择<code>internal</code>而不选择<code>public</code>的原因<ul><li>封装实现细节: 当你希望封装类、方法或其他成员，只让它们在同一个程序集内使用，而不暴露给外部程序集时，可以使用<code>internal</code>修饰符。</li><li>控制<code>API</code>公开性: 在设计库或框架时，<code>internal</code>修饰符可以帮助控制哪些类型和成员应暴露给库的使用者，哪些应保持内部使用。</li></ul></li></ul><hr><h3 id="16-is-关键字"><a href="#16-is-关键字" class="headerlink" title="16. is 关键字"></a>16. is 关键字</h3><p><code>is</code>关键字在<code>C#</code>中用于检查对象是否是特定类型的实例。</p><ul><li>类型检查<ul><li>使用<code>is</code>可以检查对象是否是特定类型的实例。如果是，则返回<code>true</code>，否则返回<code>false</code>。</li></ul></li></ul><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">object</span> obj = <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (obj <span class="keyword">is</span> <span class="built_in">string</span>)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;obj is a string.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;obj is not a string.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>模式匹配<ul><li>从<code>C# 7.0</code>开始，<code>is</code>关键字还支持模式匹配。这使得检查类型和转换类型可以在一个操作中完成。</li></ul></li></ul><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">object</span> obj = <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (obj <span class="keyword">is</span> <span class="built_in">string</span> s)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">$&quot;obj is a string with value: <span class="subst">&#123;s&#125;</span>&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;obj is not a string.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个示例中，如果<code>obj</code>是<code>string</code>类型，<code>is</code>关键字不仅检查类型，还将<code>obj</code>转换为<code>string</code>并赋值给变量<code>s</code>。然后可以直接使用<code>s</code>。</p><ul><li>使用<code>is</code>进行<code>null</code>检查<ul><li><code>is</code>关键字还可以用来检查对象是否为<code>null</code>。</li></ul></li></ul><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">object</span> obj = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">if</span> (obj <span class="keyword">is</span> <span class="literal">null</span>)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;obj is null.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;obj is not null.&quot;</span>); <span class="comment">// 相当于 is not</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>检查接口实现<ul><li><code>is</code>关键字也可以用于检查对象是否实现了某个接口。</li></ul></li></ul><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IAnimal</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Speak</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Dog</span> : <span class="title">IAnimal</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Speak</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Woof!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">object</span> obj = <span class="keyword">new</span> Dog();</span><br><span class="line"><span class="keyword">if</span> (obj <span class="keyword">is</span> IAnimal animal)</span><br><span class="line">&#123;</span><br><span class="line">    animal.Speak(); <span class="comment">// Outputs: Woof!</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;obj does not implement IAnimal.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="17-namespace-关键字"><a href="#17-namespace-关键字" class="headerlink" title="17. namespace 关键字"></a>17. namespace 关键字</h3><p>在<code>C#</code>中，<code>namespace</code>(命名空间) 是用于组织代码和防止命名冲突的一种机制。命名空间提供了一种逻辑上的分组方式，使得开发者可以更容易地管理和维护代码。</p><ul><li>定义命名空间</li></ul><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">MyApplication</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyClass</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">MyMethod</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Hello from MyMethod!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个示例中，<code>MyClass</code>类被定义在<code>MyApplication</code>命名空间中。</p><ul><li>使用命名空间<ul><li>要使用某个命名空间中的类型，可以通过<code>using</code>关键字导入命名空间。</li></ul></li></ul><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> MyApplication;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        MyClass myClass = <span class="keyword">new</span> MyClass();</span><br><span class="line">        myClass.MyMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>命名空间的好处<ul><li>组织代码: 通过使用命名空间，可以将相关的类、接口、枚举等进行分组，增加代码的可读性和维护性。</li><li>避免命名冲突: 在大型项目中，不同模块或库中可能会有同名的类型，通过使用命名空间，可以避免这些冲突。</li></ul></li></ul><hr><h3 id="18-null-关键字"><a href="#18-null-关键字" class="headerlink" title="18. null 关键字"></a>18. null 关键字</h3><p><code>null</code>关键字在<code>C#</code>中表示对象引用不指向任何实例。它是引用类型的默认值，意味着变量不引用任何对象。</p><ul><li>常见用途 (省略部分常见情况)</li><li>(1) 空合并运算符<ul><li>空合并运算符<code>(??)</code>提供了简洁的语法来处理<code>null</code>值。如果左操作数为<code>null</code>，则返回右操作数。</li></ul></li></ul><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> str = <span class="literal">null</span>;</span><br><span class="line"><span class="built_in">string</span> result = str ?? <span class="string">&quot;default value&quot;</span>;</span><br><span class="line">Console.WriteLine(result); <span class="comment">// 输出 &quot;default value&quot;</span></span><br></pre></td></tr></table></figure><ul><li>(2) 空条件运算符<ul><li>空条件运算符<code>(?.)</code>在访问成员或调用方法时检查<code>null</code>。如果对象为<code>null</code>，表达式返回<code>null</code>而不引发异常。</li></ul></li></ul><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">MyClass obj = <span class="literal">null</span>;</span><br><span class="line">obj?.DoSomething(); <span class="comment">// 不会引发 NullReferenceException</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span>[] arr = <span class="literal">null</span>;</span><br><span class="line"><span class="built_in">int</span>? <span class="keyword">value</span> = arr?[<span class="number">0</span>]; <span class="comment">// value 为 null</span></span><br></pre></td></tr></table></figure><ul><li>(3) 处理值类型的<code>null</code><ul><li>对于值类型，不能直接赋值<code>null</code>。但是，可以使用可空类型（<code>Nullable&lt;T&gt;</code> 或 <code>T?</code>）来表示可以为<code>null</code>的值类型。</li></ul></li></ul><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span>? nullableInt = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">if</span> (nullableInt.HasValue)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(nullableInt.Value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;nullableInt is null&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="19-out-关键字"><a href="#19-out-关键字" class="headerlink" title="19. out 关键字"></a>19. out 关键字</h3><p>在<code>C#</code>中，<code>out</code>关键字用于方法参数，表示该参数将由方法初始化并返回给调用方。<code>out</code>参数在方法调用时不需要被初始化，但在方法返回之前必须被赋值。</p><ul><li>定义和使用<code>out</code>参数<ul><li>在方法声明中使用<code>out</code>关键字，并在方法调用时也使用<code>out</code>关键字。</li></ul></li></ul><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> result;</span><br><span class="line">        <span class="built_in">bool</span> success = TryParse(<span class="string">&quot;123&quot;</span>, <span class="keyword">out</span> result);</span><br><span class="line">        <span class="keyword">if</span> (success)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">$&quot;Parsed number: <span class="subst">&#123;result&#125;</span>&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Failed to parse number.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">bool</span> <span class="title">TryParse</span>(<span class="params"><span class="built_in">string</span> input, <span class="keyword">out</span> <span class="built_in">int</span> number</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">int</span>.TryParse(input, <span class="keyword">out</span> number);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用<code>out</code>返回多个值<ul><li>通过<code>out</code>参数，可以让方法返回多个值。</li></ul></li></ul><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">double</span> area, perimeter;</span><br><span class="line">        CalculateCircle(<span class="number">5</span>, <span class="keyword">out</span> area, <span class="keyword">out</span> perimeter);</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;Area: <span class="subst">&#123;area&#125;</span>, Perimeter: <span class="subst">&#123;perimeter&#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">CalculateCircle</span>(<span class="params"><span class="built_in">double</span> radius, <span class="keyword">out</span> <span class="built_in">double</span> area, <span class="keyword">out</span> <span class="built_in">double</span> perimeter</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        area = Math.PI * radius * radius;</span><br><span class="line">        perimeter = <span class="number">2</span> * Math.PI * radius;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>out</code>与<code>ref</code>的区别</p><ul><li>初始化要求: 使用<code>out</code>参数的方法不要求在调用前初始化该参数，而<code>ref</code>参数必须在调用前初始化。</li><li>赋值要求: 使用<code>out</code>参数的方法必须在方法返回之前为该参数赋值，而<code>ref</code>参数不强制要求在方法内赋值。</li></ul></li><li><p>以下限制适用于使用<code>out</code>关键字</p><ul><li>异步方法中不允许使用<code>out</code>参数。</li><li>迭代器方法中不允许使用<code>out</code>参数。</li><li>属性不能作为<code>out</code>参数传递。</li></ul></li></ul><hr><h3 id="20-override-关键字"><a href="#20-override-关键字" class="headerlink" title="20. override 关键字"></a>20. override 关键字</h3><p><code>override</code>关键字在<code>C#</code>中用于方法、属性、索引器或事件，表示派生类中重写基类的虚方法、虚属性、虚索引器或虚事件。通过使用<code>override</code>，派生类可以提供基类成员的新实现。</p><ul><li>定义基类和派生类<ul><li>在基类中，使用<code>virtual</code>关键字定义可以被重写的成员。在派生类中，使用<code>override</code>关键字重写这些成员。</li></ul></li></ul><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BaseClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Display</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;BaseClass Display method&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DerivedClass</span> : <span class="title">BaseClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Display</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;DerivedClass Display method&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用<code>override</code>重写属性和方法<ul><li>可以使用<code>override</code>关键字重写基类中的虚属性。(重写方法如上)</li></ul></li></ul><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BaseClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">virtual</span> <span class="built_in">int</span> Number &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">ShowNumber</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Number: &quot;</span> + Number);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DerivedClass</span> : <span class="title">BaseClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> _number;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">int</span> Number</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> _number; &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123; _number = <span class="keyword">value</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">ShowNumber</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Derived Number: &quot;</span> + Number);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>注意事项<ul><li>虚成员: 只有基类中标记为<code>virtual</code>或<code>abstract</code>的成员才能被重写。</li><li>访问修饰符: 重写的成员的访问级别必须与基类中的成员一致，或者更严格。例如，如果基类中的虚方法是<code>public</code>，则派生类中的重写方法也必须是<code>public</code>，不能是<code>protected</code>或<code>private</code>。</li></ul></li></ul><hr><h3 id="21-params-关键字"><a href="#21-params-关键字" class="headerlink" title="21. params 关键字"></a>21. params 关键字</h3><p><code>params</code>关键字在<code>C#</code>中用于指定一个方法参数数组，使得方法可以接受可变数量的参数。</p><ul><li>使用<code>params</code>关键字的参数必须是方法的最后一个参数，并且它可以接受任意数量的参数，包括零个参数。</li></ul><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PrintNumbers</span>(<span class="params"><span class="keyword">params</span> <span class="built_in">int</span>[] numbers</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="built_in">int</span> number <span class="keyword">in</span> numbers)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(number);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PrintNumbers(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);  <span class="comment">// 输出: 1 2 3 4</span></span><br><span class="line">PrintNumbers(<span class="number">5</span>, <span class="number">6</span>);        <span class="comment">// 输出: 5 6</span></span><br><span class="line">PrintNumbers();            <span class="comment">// 输出: （空）</span></span><br></pre></td></tr></table></figure><ul><li>使用<code>params</code>的理由</li><li>(1) 灵活性和简洁性<ul><li><code>params</code>关键字提供了在方法调用时的灵活性和简洁性。它允许调用者传递任意数量的参数，而不需要显式地创建一个数组。这使得方法调用更简洁、更直观。</li></ul></li></ul><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PrintNumbers</span>(<span class="params"><span class="built_in">int</span>[] numbers</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="built_in">int</span> number <span class="keyword">in</span> numbers)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(number);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用方法时需要创建数组</span></span><br><span class="line">PrintNumbers(<span class="keyword">new</span> <span class="built_in">int</span>[] &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;);</span><br><span class="line">PrintNumbers(<span class="keyword">new</span> <span class="built_in">int</span>[] &#123; <span class="number">10</span>, <span class="number">20</span> &#125;);</span><br><span class="line">PrintNumbers(<span class="keyword">new</span> <span class="built_in">int</span>[] &#123; &#125;);  <span class="comment">// 传递一个空数组</span></span><br></pre></td></tr></table></figure><p>如果不使用<code>params</code>关键字，则需要显式地创建数组</p><ul><li>(2) 支持多参数重载<ul><li><code>params</code>关键字允许方法支持多种参数重载，这在需要处理多个不同参数数量的情况下非常有用。它避免了为每种可能的参数数量定义多个重载方法。</li></ul></li></ul><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DisplayItems</span>(<span class="params"><span class="keyword">params</span> <span class="built_in">string</span>[] items</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> item <span class="keyword">in</span> items)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(item);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用方法时</span></span><br><span class="line">DisplayItems(<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Cherry&quot;</span>);</span><br><span class="line">DisplayItems(<span class="string">&quot;Dog&quot;</span>, <span class="string">&quot;Cat&quot;</span>);</span><br><span class="line">DisplayItems();  <span class="comment">// 传递零个参数</span></span><br></pre></td></tr></table></figure><hr><h3 id="22-private-关键字"><a href="#22-private-关键字" class="headerlink" title="22. private 关键字"></a>22. private 关键字</h3><p><code>private</code>关键字是<code>C#</code>中的访问修饰符，用于控制类或结构体成员的可访问性。标记为<code>private</code>的成员只能在定义它们的类或结构体内部访问。</p><ul><li>使用<code>private</code>关键字可以隐藏类的实现细节，限制对类内部数据的直接访问，从而提高代码的封装性和安全性。</li></ul><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Employee2</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> <span class="built_in">string</span> _name = <span class="string">&quot;FirstName, LastName&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> <span class="built_in">double</span> _salary = <span class="number">100.0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">GetName</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> _name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">double</span> Salary</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> _salary; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">PrivateTest</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> e = <span class="keyword">new</span> Employee2();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// The data members are inaccessible (private), so</span></span><br><span class="line">        <span class="comment">// they can&#x27;t be accessed like this:</span></span><br><span class="line">        <span class="comment">//    string n = e._name;</span></span><br><span class="line">        <span class="comment">//    double s = e._salary;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// &#x27;_name&#x27; is indirectly accessed via method:</span></span><br><span class="line">        <span class="built_in">string</span> n = e.GetName();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// &#x27;_salary&#x27; is indirectly accessed via property</span></span><br><span class="line">        <span class="built_in">double</span> s = e.Salary;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>注意事项<ul><li><code>private</code>是<code>C#</code>中最严格的访问修饰符，仅限于在类或结构体内部访问。</li><li><code>private</code>成员不能在派生类中访问，即使是通过继承。</li><li>在结构体中，所有成员默认为<code>private</code>，而在类中，成员默认为<code>private</code>。</li></ul></li></ul><hr><h3 id="23-protected-关键字"><a href="#23-protected-关键字" class="headerlink" title="23. protected 关键字"></a>23. protected 关键字</h3><p><code>protected</code>关键字是<code>C#</code>中的访问修饰符，用于控制类或结构体成员的可访问性。标记为<code>protected</code>的成员只能在以下两种情况下访问: </p><ul><li>在定义该成员的类内部访问</li><li>在派生类中访问</li></ul><p>这种访问修饰符允许你在保持数据封装的同时，为派生类提供访问基类成员的能力。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Animal</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 受保护的字段</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="built_in">string</span> name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 公共方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetName</span>(<span class="params"><span class="built_in">string</span> name</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 受保护的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">DisplayInfo</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;Animal Name: <span class="subst">&#123;name&#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Dog</span> : <span class="title">Animal</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 公共方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ShowDetails</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 访问基类的受保护成员</span></span><br><span class="line">        DisplayInfo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Dog dog = <span class="keyword">new</span> Dog();</span><br><span class="line">        dog.SetName(<span class="string">&quot;Buddy&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 访问派生类的公共方法</span></span><br><span class="line">        dog.ShowDetails();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 直接访问基类的受保护成员会导致编译错误</span></span><br><span class="line">        <span class="comment">// dog.name = &quot;Buddy&quot;;  // 错误</span></span><br><span class="line">        <span class="comment">// dog.DisplayInfo();   // 错误</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用<code>protected</code>的原因<ul><li>继承与扩展: <code>protected</code>关键字允许派生类访问基类的成员，从而支持类的继承和扩展。</li><li>数据封装: 通过限制成员的访问权限，<code>protected</code>关键字有助于保护类的内部状态，同时允许派生类进行必要的访问。</li></ul></li></ul><p>以下是对<code>protected internal</code>和<code>private protected</code>访问修饰符的详细解释</p><ul><li><code>protected internal</code>关键字结合了<code>protected</code>和<code>internal</code>的特性，成员可以在以下两种情况下访问<ul><li>同一程序集: <code>internal</code>允许同一程序集中的任何代码访问。</li><li>派生类: <code>protected</code>允许派生类访问，即使它们在不同的程序集中。</li></ul></li></ul><p>因此，<code>protected internal</code>的成员可以被同一程序集中的所有代码访问，也可以被其他程序集中派生类访问。下面是一个例子</p><ul><li>图形库 <code>Assembly: GraphicsLibrary.dll</code>: <code>Shape.cs</code></li></ul><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">GraphicsLibrary</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Shape</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 受保护的内部成员</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">internal</span> <span class="built_in">double</span> Area &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">internal</span> <span class="keyword">void</span> <span class="title">CalculateArea</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 默认的计算逻辑，可能被派生类覆盖</span></span><br><span class="line">            Area = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>图形库 <code>Assembly: GraphicsLibrary.dll</code>: <code>Circle.cs</code></li></ul><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">GraphicsLibrary</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Circle</span> : <span class="title">Shape</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">double</span> Radius &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Circle</span>(<span class="params"><span class="built_in">double</span> radius</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Radius = radius;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">CalculateArea</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 覆盖基类的计算逻辑</span></span><br><span class="line">            Area = Math.PI * Radius * Radius;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DisplayArea</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">$&quot;The area of the circle is: <span class="subst">&#123;Area&#125;</span>&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用图形库的应用程序 <code>Assembly: GraphicsApp.exe</code>: <code>Program.cs</code></li></ul><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> GraphicsLibrary;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">GraphicsApp</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Circle circle = <span class="keyword">new</span> Circle(<span class="number">5</span>);</span><br><span class="line">            circle.CalculateArea();</span><br><span class="line">            circle.DisplayArea();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 在同一程序集中可以访问 protected internal 成员</span></span><br><span class="line">            <span class="built_in">double</span> area = circle.Area;</span><br><span class="line">            Console.WriteLine(<span class="string">$&quot;Accessing area directly: <span class="subst">&#123;area&#125;</span>&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总而言之，<code>protected internal</code>允许灵活地在同一程序集内访问共享的实现细节，同时保留跨程序集继承的能力。</p><ul><li><code>private protected</code>关键字结合了<code>private</code>和<code>protected</code>的特性，成员只能在以下两种情况下访问<ul><li>同一类内部: <code>private</code>允许在同一类内部访问。</li><li>同一程序集中派生类: <code>protected</code>允许在派生类中访问，但前提是这些派生类在同一程序集中。</li></ul></li></ul><p>因此，<code>private protected</code>的成员只能被定义它们的类及其同一程序集中的派生类访问，不能被其他程序集的派生类访问。下面是一个例子</p><ul><li>订单系统 <code>Assembly: OrderSystem.dll</code>: <code>Order.cs</code></li></ul><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">OrderSystem</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Order</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 受保护的私有成员</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">protected</span> <span class="built_in">string</span> OrderId &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">protected</span> <span class="built_in">decimal</span> Amount &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Order</span>(<span class="params"><span class="built_in">string</span> orderId, <span class="built_in">decimal</span> amount</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            OrderId = orderId;</span><br><span class="line">            Amount = amount;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">DisplayOrderDetails</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">$&quot;Order ID: <span class="subst">&#123;OrderId&#125;</span>, Amount: <span class="subst">&#123;Amount&#125;</span>&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>订单系统 <code>Assembly: OrderSystem.dll</code>: <code>SpecialOrder.cs</code></li></ul><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">OrderSystem</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SpecialOrder</span> : <span class="title">Order</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">SpecialOrder</span>(<span class="params"><span class="built_in">string</span> orderId, <span class="built_in">decimal</span> amount</span>) : <span class="title">base</span>(<span class="params">orderId, amount</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ShowSpecialOrderDetails</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 可以访问基类的 private protected 成员</span></span><br><span class="line">            DisplayOrderDetails();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>外部应用程序 <code>Assembly: ExternalApp.dll</code>: <code>Program.cs</code></li></ul><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> OrderSystem;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ExternalApp</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            SpecialOrder specialOrder = <span class="keyword">new</span> SpecialOrder(<span class="string">&quot;SO123&quot;</span>, <span class="number">1000.00</span>m);</span><br><span class="line">            specialOrder.ShowSpecialOrderDetails();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 不能在其他程序集访问 private protected 成员</span></span><br><span class="line">            <span class="comment">// specialOrder.OrderId = &quot;SO456&quot;; // 编译错误</span></span><br><span class="line">            <span class="comment">// specialOrder.DisplayOrderDetails(); // 编译错误</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总而言之，<code>private protected</code>提供了一种更严格的访问控制，防止不同程序集中的类访问某些内部细节，这在保护敏感数据或内部实现细节时特别有用。</p><hr><h3 id="24-readonly-关键字"><a href="#24-readonly-关键字" class="headerlink" title="24. readonly 关键字"></a>24. readonly 关键字</h3><p><code>readonly</code>关键字在<code>C#</code>中用于修饰字段，表示该字段在初始化后不能被更改。<code>readonly</code>字段只能在以下情况下赋值</p><ul><li>字段声明时: 可以在声明字段时直接赋值。</li><li>构造函数中: 可以在类的构造函数中赋值，包括实例构造函数和静态构造函数。</li></ul><p><code>readonly</code>字段与<code>const</code>常量的不同之处在于，<code>const</code>是编译时常量，必须在声明时赋值，并且其值在编译时就确定，而<code>readonly</code>字段可以在运行时被赋值，并且可以根据构造函数的逻辑赋予不同的值。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">readonly</span> <span class="built_in">string</span> Name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">readonly</span> <span class="built_in">int</span> Age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 字段声明时赋值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">readonly</span> <span class="built_in">string</span> Country = <span class="string">&quot;USA&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数中赋值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span>(<span class="params"><span class="built_in">string</span> name, <span class="built_in">int</span> age</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Name = name;</span><br><span class="line">        Age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Display</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;Name: <span class="subst">&#123;Name&#125;</span>, Age: <span class="subst">&#123;Age&#125;</span>, Country: <span class="subst">&#123;Country&#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Person person = <span class="keyword">new</span> Person(<span class="string">&quot;Alice&quot;</span>, <span class="number">30</span>);</span><br><span class="line">        person.Display();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 试图修改 readonly 字段会导致编译错误</span></span><br><span class="line">        <span class="comment">// person.Name = &quot;Bob&quot;; // 编译错误</span></span><br><span class="line">        <span class="comment">// person.Age = 35;     // 编译错误</span></span><br><span class="line">        <span class="comment">// person.Country = &quot;Canada&quot;; // 编译错误</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>const</code>和<code>readonly</code>的区别<ul><li><code>const</code>适用于值在编译时就确定不变的情况，如数学常量<code>pi</code>。</li><li><code>readonly</code>适用于值在运行时确定且一旦初始化后不再改变的情况，如配置文件中的某些设置。</li></ul></li></ul><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Constants</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">const</span> <span class="built_in">double</span> Pi = <span class="number">3.14159</span>; <span class="comment">// 编译时常量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">readonly</span> DateTime CreationTime; <span class="comment">// 运行时常量</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Constants</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        CreationTime = DateTime.Now; <span class="comment">// 可以在构造函数中赋值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="25-ref-关键字"><a href="#25-ref-关键字" class="headerlink" title="25. ref 关键字"></a>25. ref 关键字</h3><p><code>ref</code>关键字在<code>C#</code>中用于方法参数，表示参数以引用方式传递。这意味着在方法内对参数的任何修改都会影响到调用方传递的实际变量。使用<code>ref</code>关键字的要求</p><ul><li>在方法声明中使用: 必须在方法的参数列表中使用<code>ref</code>关键字。</li><li>在方法调用时使用: 调用方法时也必须在实际参数前加上<code>ref</code>关键字。</li><li>初始化要求: 传递给<code>ref</code>参数的变量必须在调用方法之前初始化。</li></ul><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Increment</span>(<span class="params"><span class="keyword">ref</span> <span class="built_in">int</span> number</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        number++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> <span class="keyword">value</span> = <span class="number">5</span>;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;Before: <span class="subst">&#123;<span class="keyword">value</span>&#125;</span>&quot;</span>); <span class="comment">// 输出: Before: 5</span></span><br><span class="line">        Increment(<span class="keyword">ref</span> <span class="keyword">value</span>);</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;After: <span class="subst">&#123;<span class="keyword">value</span>&#125;</span>&quot;</span>);  <span class="comment">// 输出: After: 6</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果上面的示例中没有使用<code>ref</code>，那么第二个<code>Console</code>的输出就还会是<code>5</code>。原因是方法接收参数的副本，方法内对参数的修改不会影响到外部的实际变量。</p><ul><li>使用<code>ref</code>的场景<ul><li>需要修改调用方变量的场景: 当你希望在方法内修改调用方传递的变量时，可以使用<code>ref</code>关键字。例如，交换两个变量的值。</li><li>需要返回多个值的场景: 虽然方法本身只能返回一个值，但可以通过<code>ref</code>或<code>out</code>参数返回多个值。</li></ul></li></ul><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Swap</span>(<span class="params"><span class="keyword">ref</span> <span class="built_in">int</span> a, <span class="keyword">ref</span> <span class="built_in">int</span> b</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> temp = a;</span><br><span class="line">        a = b;</span><br><span class="line">        b = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> x = <span class="number">10</span>;</span><br><span class="line">        <span class="built_in">int</span> y = <span class="number">20</span>;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;Before Swap: x = <span class="subst">&#123;x&#125;</span>, y = <span class="subst">&#123;y&#125;</span>&quot;</span>); <span class="comment">// 输出: Before Swap: x = 10, y = 20</span></span><br><span class="line">        Swap(<span class="keyword">ref</span> x, <span class="keyword">ref</span> y);</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;After Swap: x = <span class="subst">&#123;x&#125;</span>, y = <span class="subst">&#123;y&#125;</span>&quot;</span>);  <span class="comment">// 输出: After Swap: x = 20, y = 10</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>ref</code>与<code>out</code>的区别<ul><li>初始化要求: 传递给<code>ref</code>参数的变量必须在调用方法之前初始化。传递给<code>out</code>参数的变量可以在方法调用之前未初始化，但必须在方法内部赋值。</li><li>主要用途: <code>ref</code>用于传递数据给方法，并且希望方法内部修改该数据。<code>out</code>用于方法返回多个值。</li></ul></li></ul><hr><h3 id="26-sealed-关键字"><a href="#26-sealed-关键字" class="headerlink" title="26. sealed 关键字"></a>26. sealed 关键字</h3><p><code>sealed</code>关键字在<code>C#</code>中用于类和方法，提供了不同的功能</p><ul><li>用于类: 防止其他类从它派生。也就是说，<code>sealed</code>类不能作为基类，无法被继承。</li><li>用于方法: 当用在基类中的虚方法上时，防止派生类进一步重写该方法。</li></ul><p>当一个类被标记为<code>sealed</code>时，它不能被继承。这通常用于防止不希望的继承，或者当类的设计不需要被扩展时。使用<code>sealed</code>类可以提高性能，因为它的成员在编译时可以进行更多的优化。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">FinalClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Display</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;This is a sealed class.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下代码将会导致编译错误，因为不能继承一个 sealed 类</span></span><br><span class="line"><span class="comment">// public class DerivedClass : FinalClass</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure><p>当一个类继承自基类，并且重写了基类中的虚方法时，可以使用<code>sealed</code>关键字阻止进一步的重写。这种情况下，<code>sealed</code>关键字必须与<code>override</code>一起使用。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BaseClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Display</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;BaseClass Display method.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DerivedClass</span> : <span class="title">BaseClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Display</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;DerivedClass Display method.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下代码将会导致编译错误，因为 Display 方法被 sealed</span></span><br><span class="line"><span class="comment">// public class FurtherDerivedClass : DerivedClass</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//     public override void Display()</span></span><br><span class="line"><span class="comment">//     &#123;</span></span><br><span class="line"><span class="comment">//         Console.WriteLine(&quot;FurtherDerivedClass Display method.&quot;);</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure><ul><li>使用<code>sealed</code>的场景<ul><li>提高安全性: 通过防止类的继承，可以保护类的实现细节，防止子类意外地改变类的行为。</li><li>性能优化: 标记为<code>sealed</code>的类和方法可以进行更多的编译时优化，因为编译器知道这些类和方法不会被重写。</li><li>限制扩展性: 当一个类的设计不适合扩展时，可以使用<code>sealed</code>防止进一步的继承。</li></ul></li></ul><hr><h3 id="27-static-关键字"><a href="#27-static-关键字" class="headerlink" title="27. static 关键字"></a>27. static 关键字</h3><p><code>static</code>关键字在<code>C#</code>中用于声明类成员和类本身。它表示这些成员或类与具体实例无关，而是属于类型本身。</p><ul><li>静态类 <code>static class</code><ul><li>定义: 静态类是不能被实例化的类，所有成员都必须是静态的。</li><li>特性: 静态类通常用于组织一组相关的静态方法和常量，不允许创建静态类的实例。</li><li>用途: 常用于实用类<code>Utility class</code>或库，提供静态方法进行通用操作。</li></ul></li></ul><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">MathUtilities</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">Add</span>(<span class="params"><span class="built_in">int</span> a, <span class="built_in">int</span> b</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">Multiply</span>(<span class="params"><span class="built_in">int</span> a, <span class="built_in">int</span> b</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> a * b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>静态类 <code>static</code> 成员<ul><li>静态成员包括静态字段、静态属性、静态方法、静态事件等。它们属于类本身，而不是类的具体实例。</li><li>静态字段: 所有实例共享的字段，可以用于存储全局状态或常量。</li><li>静态属性: 提供对静态字段的访问，通常用于封装。</li><li>静态方法: 可以在不创建类实例的情况下调用，用于执行与类实例无关的操作。</li><li>静态构造函数: 用于初始化静态字段或执行其他静态初始化，只在类首次被访问时调用一次。</li></ul></li></ul><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Counter</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> Count &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Increment</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Count++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用静态成员</span></span><br><span class="line">Counter.Increment();</span><br><span class="line">Console.WriteLine(Counter.Count); <span class="comment">// 输出: 1</span></span><br></pre></td></tr></table></figure><ul><li>静态构造函数 <code>static constructor</code><ul><li>静态构造函数用于初始化静态字段或执行类级别的初始化。它在类的第一次使用时被调用，且只调用一次。</li><li>特性: 没有访问修饰符，因为它不能由外部代码调用；不接受参数，因为它是自动调用的。</li><li>用途: 通常用于初始化静态数据。</li></ul></li></ul><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Example</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> Value;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="title">Example</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Value = <span class="number">42</span>; <span class="comment">// 静态初始化</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用静态成员</span></span><br><span class="line">Console.WriteLine(Example.Value); <span class="comment">// 输出: 42</span></span><br></pre></td></tr></table></figure><p><code>static</code>关键字在<code>C#</code>中非常重要，用于定义不依赖于具体对象实例的类和成员。它提供了一个全局的、共享的访问点，适用于需要统一管理状态或提供通用操作的场景。</p><hr><h3 id="28-struct-关键字"><a href="#28-struct-关键字" class="headerlink" title="28. struct 关键字"></a>28. struct 关键字</h3><p><code>struct</code>关键字在<code>C#</code>中用于定义值类型。值类型与引用类型（如类）不同，值类型在内存中直接存储其数据，而不是存储对数据的引用。结构体是一种轻量级的数据结构，通常用于表示小型数据对象。</p><ul><li>内存分配: 值类型的数据通常分配在栈上，而不是堆上。</li><li>数据存储: 值类型直接包含其数据，而引用类型包含对数据的引用。</li><li>无继承: 结构体不能继承自其他结构体或类，也不能被继承。但它们可以实现接口。</li><li>无参数的构造函数: 不能定义无参数的构造函数，因为默认的无参数构造函数始终存在，用于初始化字段为其默认值。</li></ul><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> Point</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> X &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Y &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Point</span>(<span class="params"><span class="built_in">int</span> x, <span class="built_in">int</span> y</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        X = x;</span><br><span class="line">        Y = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Display</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;Point at (<span class="subst">&#123;X&#125;</span>, <span class="subst">&#123;Y&#125;</span>)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Point p1 = <span class="keyword">new</span> Point(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">        p1.Display(); <span class="comment">// 输出: Point at (10, 20)</span></span><br><span class="line"></span><br><span class="line">        Point p2 = p1; <span class="comment">// 结构体的值复制</span></span><br><span class="line">        p2.X = <span class="number">30</span>;</span><br><span class="line">        p2.Display(); <span class="comment">// 输出: Point at (30, 20)</span></span><br><span class="line">        p1.Display(); <span class="comment">// 输出: Point at (10, 20) - p1 未受影响</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>struct</code> 的适用场景<ul><li>轻量级数据结构: 结构体适合用于表示轻量级的数据对象，如二维坐标、颜色、时间等。</li><li>不可变对象: 因为结构体是值类型，通常可以设计成不可变对象，提供更高的安全性和一致性。</li><li>性能考虑: 由于结构体在栈上分配，访问速度较快，适合于频繁分配和释放的小型对象。</li></ul></li></ul><hr><h3 id="29-switch-关键字"><a href="#29-switch-关键字" class="headerlink" title="29. switch 关键字"></a>29. switch 关键字</h3><blockquote><p>这里主要介绍<code>switch</code>表达式</p></blockquote><p><code>switch</code>表达式是<code>C# 8.0</code>引入的一种简洁且功能强大的分支选择机制。与传统的<code>switch</code>语句不同，<code>switch</code>表达式不仅能根据输入值进行分支，而且更灵活地结合了模式匹配的特性。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> result = expression <span class="keyword">switch</span></span><br><span class="line">&#123;</span><br><span class="line">    pattern1 =&gt; result1,</span><br><span class="line">    pattern2 =&gt; result2,</span><br><span class="line">    pattern3 =&gt; result3,</span><br><span class="line">    _ =&gt; defaultResult</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>switch</code>表达式提供了一种简洁且灵活的方式来进行条件分支选择，与传统<code>switch</code>语句相比，它不仅减少了代码量，还提高了代码的可读性和维护性。</p><hr><h3 id="30-this-关键字"><a href="#30-this-关键字" class="headerlink" title="30. this 关键字"></a>30. this 关键字</h3><p><code>this</code>关键字在<code>C#</code>中用于引用当前实例的成员，包括字段、方法、属性、事件和索引器。它在类的非静态成员中非常有用。此外，<code>this</code>关键字还有其他特定用途，如调用构造函数和扩展方法。</p><ul><li>引用当前实例的成员<ul><li>在类的实例方法或属性中，可以使用<code>this</code>关键字引用当前实例的成员，尤其是在成员名称与方法参数名称相同时。</li></ul></li></ul><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span>(<span class="params"><span class="built_in">string</span> name</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 使用 this 引用当前实例的 name 字段</span></span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Display</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;Name: <span class="subst">&#123;<span class="keyword">this</span>.name&#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Person person = <span class="keyword">new</span> Person(<span class="string">&quot;Alice&quot;</span>);</span><br><span class="line">        person.Display(); <span class="comment">// 输出: Name: Alice</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>调用其他构造函数<ul><li><code>this</code>关键字可以在构造函数中调用同一个类的其他构造函数，称为构造函数重载。</li></ul></li></ul><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Rectangle</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Width &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Height &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Rectangle</span>() : <span class="title">this</span>(<span class="params"><span class="number">0</span>, <span class="number">0</span></span>) <span class="comment">// 调用具有两个参数的构造函数</span></span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Rectangle</span>(<span class="params"><span class="built_in">int</span> width, <span class="built_in">int</span> height</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.Width = width;</span><br><span class="line">        <span class="keyword">this</span>.Height = height;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Display</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;Width: <span class="subst">&#123;Width&#125;</span>, Height: <span class="subst">&#123;Height&#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Rectangle rect1 = <span class="keyword">new</span> Rectangle();</span><br><span class="line">        rect1.Display(); <span class="comment">// 输出: Width: 0, Height: 0</span></span><br><span class="line"></span><br><span class="line">        Rectangle rect2 = <span class="keyword">new</span> Rectangle(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">        rect2.Display(); <span class="comment">// 输出: Width: 10, Height: 20</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>扩展方法的调用<ul><li><code>this</code>关键字在扩展方法的定义中用于指示被扩展的类型。</li></ul></li></ul><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">StringExtensions</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">bool</span> <span class="title">IsNullOrEmpty</span>(<span class="params"><span class="keyword">this</span> <span class="built_in">string</span> <span class="keyword">value</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">string</span>.IsNullOrEmpty(<span class="keyword">value</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span> str = <span class="literal">null</span>;</span><br><span class="line">        <span class="built_in">bool</span> result = str.IsNullOrEmpty(); <span class="comment">// 使用扩展方法</span></span><br><span class="line">        Console.WriteLine(result); <span class="comment">// 输出: True</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个示例中，<code>IsNullOrEmpty</code>方法是一个扩展方法，它使用<code>this</code>关键字将<code>string</code>类型扩展为包含该方法的类型。<code>this</code>关键字指示<code>value</code>参数为被扩展的类型的实例。</p><hr><h3 id="31-throw-关键字"><a href="#31-throw-关键字" class="headerlink" title="31. throw 关键字"></a>31. throw 关键字</h3><p><code>throw</code>关键字在<code>C#</code>中用于引发异常。异常是一种在程序执行过程中出现的错误或意外情况，使用<code>throw</code>可以中断程序的正常执行流程，并转到相关的异常处理代码。</p><ul><li>引发异常<ul><li>使用<code>throw</code>关键字可以显式引发一个异常，通常在检测到程序状态不合法或出现错误时使用。</li></ul></li></ul><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> divisor = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">int</span> result = Divide(<span class="number">10</span>, divisor);</span><br><span class="line">            Console.WriteLine(result);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (DivideByZeroException ex)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">$&quot;Caught an exception: <span class="subst">&#123;ex.Message&#125;</span>&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">Divide</span>(<span class="params"><span class="built_in">int</span> dividend, <span class="built_in">int</span> divisor</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (divisor == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> DivideByZeroException(<span class="string">&quot;Divisor cannot be zero.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dividend / divisor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>重新引发异常<ul><li>在捕获异常后，可能希望重新引发异常以允许外部代码进一步处理。在<code>catch</code>块中使用<code>throw</code>可以重新引发当前捕获的异常。</li></ul></li></ul><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.IO;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">FileProcessor</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ProcessFile</span>(<span class="params"><span class="built_in">string</span> filePath</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">string</span> content = ReadFile(filePath);</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;File content:&quot;</span>);</span><br><span class="line">            Console.WriteLine(content);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IOException ex)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;An I/O error occurred while processing the file.&quot;</span>);</span><br><span class="line">            <span class="keyword">throw</span>; <span class="comment">// 重新引发异常</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception ex)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;An unexpected error occurred.&quot;</span>);</span><br><span class="line">            <span class="keyword">throw</span>; <span class="comment">// 重新引发异常</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="built_in">string</span> <span class="title">ReadFile</span>(<span class="params"><span class="built_in">string</span> filePath</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">string</span>.IsNullOrWhiteSpace(filePath))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentNullException(<span class="keyword">nameof</span>(filePath), <span class="string">&quot;File path cannot be null or empty.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!File.Exists(filePath))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> FileNotFoundException(<span class="string">&quot;The specified file does not exist.&quot;</span>, filePath);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> File.ReadAllText(filePath);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        FileProcessor processor = <span class="keyword">new</span> FileProcessor();</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            processor.ProcessFile(<span class="string">&quot;nonexistentfile.txt&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception ex)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 在这里可以进一步处理异常，例如记录日志或显示用户友好的错误消息</span></span><br><span class="line">            Console.WriteLine(<span class="string">$&quot;Exception caught in Main: <span class="subst">&#123;ex.Message&#125;</span>&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>注意事项<ul><li>使用异常类型: <code>throw</code>关键字后面必须跟一个异常对象。异常对象通常是从<code>System.Exception</code>类派生的类实例。</li><li>重新引发的正确方式: 在<code>catch</code>块中重新引发异常时，使用<code>throw</code>; 而不是<code>throw ex</code>;。前者保留了原始异常的堆栈跟踪信息，而后者会重置堆栈跟踪。</li></ul></li></ul><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">catch</span> (Exception ex)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 不推荐，因为会丢失原始异常的堆栈跟踪</span></span><br><span class="line">    <span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">catch</span> (Exception ex)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 推荐的方式，保留原始异常的堆栈跟踪</span></span><br><span class="line">    <span class="keyword">throw</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="32-using-关键字"><a href="#32-using-关键字" class="headerlink" title="32. using 关键字"></a>32. using 关键字</h3><p><code>using</code>关键字在<code>C#</code>中有两种主要的用法</p><ul><li>资源管理 (<code>using</code>语句): 用于定义一个范围，在该范围结束时会自动释放特定的资源。通常用于处理非托管资源，如文件、数据库连接等，需要显式释放的资源。</li><li>命名空间导入 (<code>using</code>指令): 用于导入命名空间，以便在代码中可以简化对命名空间内类型的引用。</li></ul><p>资源管理 (<code>using</code>语句)</p><ul><li><code>using</code>语句用于确保实现了<code>IDisposable</code>接口的对象在使用完后被正确地释放。<code>IDisposable</code>接口包含一个<code>Dispose</code>方法，用于释放资源。</li></ul><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.IO;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">using</span> (StreamReader reader = <span class="keyword">new</span> StreamReader(<span class="string">&quot;example.txt&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">string</span> content = reader.ReadToEnd();</span><br><span class="line">            Console.WriteLine(content);</span><br><span class="line">        &#125; <span class="comment">// reader 对象在此处被释放</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>命名空间导入 (<code>using</code>指令)</p><ul><li><code>using</code>指令用于在文件的顶部导入命名空间，以便在代码中简化对该命名空间内类型的引用。这可以减少代码中的冗长类型名称，并提高代码的可读性。</li></ul><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        List&lt;<span class="built_in">int</span>&gt; numbers = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt; &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line">        Console.WriteLine(<span class="built_in">string</span>.Join(<span class="string">&quot;, &quot;</span>, numbers));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>别名: 可以使用<code>using</code>指令为类型或命名空间创建别名。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> Project = MyCompany.ProjectNamespace;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Project.MyClass obj = <span class="keyword">new</span> Project.MyClass();</span><br><span class="line">        obj.MyMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="33-virtual-关键字"><a href="#33-virtual-关键字" class="headerlink" title="33. virtual 关键字"></a>33. virtual 关键字</h3><p><code>virtual</code>关键字在<code>C#</code>中用于修饰方法、属性、事件或索引器，表示这些成员可以在派生类中被重写。</p><ul><li><p>使用<code>virtual</code>关键字定义的成员提供了一个默认的实现，但允许派生类通过<code>override</code>关键字提供新的实现，从而改变基类的行为。</p></li><li><p>虚方法 <code>Virtual Methods</code></p><ul><li>虚方法是指在基类中定义，并允许派生类重写的方法。虚方法在基类中提供了默认实现，但派生类可以通过重写它来提供新的行为。</li></ul></li></ul><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BaseClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Display</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;BaseClass Display&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DerivedClass</span> : <span class="title">BaseClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Display</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;DerivedClass Display&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>虚属性 <code>Virtual Properties</code><ul><li>虚属性类似于虚方法，它们允许在派生类中重写基类中的属性。</li></ul></li></ul><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BaseClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> _name;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">virtual</span> <span class="built_in">string</span> Name</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> _name; &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123; _name = <span class="keyword">value</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DerivedClass</span> : <span class="title">BaseClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> _name;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">string</span> Name</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> _name; &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123; _name = <span class="keyword">value</span>.ToUpper(); &#125; <span class="comment">// 强制将名字转换为大写</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>虚事件 <code>Virtual Events</code><ul><li>虚事件与虚方法类似，允许派生类重写事件的订阅<code>add</code>和取消订阅<code>remove</code>行为。</li></ul></li></ul><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BaseClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">event</span> EventHandler MyEvent;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnMyEvent</span>(<span class="params">EventArgs e</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 检查是否有订阅者，然后引发事件</span></span><br><span class="line">        MyEvent?.Invoke(<span class="keyword">this</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TriggerEvent</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 调用 OnMyEvent 方法来引发事件</span></span><br><span class="line">        OnMyEvent(EventArgs.Empty);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DerivedClass</span> : <span class="title">BaseClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> EventHandler _eventHandlers;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">event</span> EventHandler MyEvent</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">add</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Adding event handler&quot;</span>);</span><br><span class="line">            _eventHandlers += <span class="keyword">value</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">remove</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Removing event handler&quot;</span>);</span><br><span class="line">            _eventHandlers -= <span class="keyword">value</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnMyEvent</span>(<span class="params">EventArgs e</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;DerivedClass specific event handling&quot;</span>);</span><br><span class="line">        _eventHandlers?.Invoke(<span class="keyword">this</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        DerivedClass obj = <span class="keyword">new</span> DerivedClass();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 添加事件处理程序</span></span><br><span class="line">        obj.MyEvent += (sender, e) =&gt; Console.WriteLine(<span class="string">&quot;Event Handler 1&quot;</span>);</span><br><span class="line">        obj.MyEvent += (sender, e) =&gt; Console.WriteLine(<span class="string">&quot;Event Handler 2&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 触发事件</span></span><br><span class="line">        obj.TriggerEvent();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 移除事件处理程序</span></span><br><span class="line">        obj.MyEvent -= (sender, e) =&gt; Console.WriteLine(<span class="string">&quot;Event Handler 2&quot;</span>);</span><br><span class="line">        obj.TriggerEvent();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>virtual</code>的使用场景<ul><li>多态性: 虚方法和属性允许派生类重写基类的实现，从而实现多态性。基类的方法可以调用派生类的实现，而无需了解派生类的具体类型。</li><li>默认行为: 虚方法和属性可以提供基类的默认行为，派生类可以选择接受默认行为或提供自己的实现。</li></ul></li></ul><p>为什么选择<code>virtual</code>而不是<code>abstract</code></p><ul><li><p>(1) <code>virtual</code>关键字</p><ul><li>定义: <code>virtual</code>关键字用于定义可以在派生类中重写的成员。虚成员在基类中有一个默认的实现，派生类可以选择重写该实现。</li><li>用途: 当基类提供一个默认的实现，但派生类可以根据需要覆盖该实现时，使用<code>virtual</code>。它允许提供一个基础行为，并在派生类中进行扩展或修改。</li></ul></li><li><p>(2) <code>abstract</code>关键字</p><ul><li>定义: <code>abstract</code>关键字用于定义一个没有实现的成员，派生类必须提供该成员的具体实现。抽象成员没有方法体，类本身也必须是抽象的<code>abstract class</code>。</li><li>用途: 当基类强制派生类实现某些方法或属性时，使用<code>abstract</code>。它用于定义一个抽象的接口或行为规范，所有的派生类都必须实现这些行为。</li></ul></li></ul><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Animal</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">Speak</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Dog</span> : <span class="title">Animal</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Speak</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Bark&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Cat</span> : <span class="title">Animal</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Speak</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Meow&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="34-get-和-set-关键字"><a href="#34-get-和-set-关键字" class="headerlink" title="34. get 和 set 关键字"></a>34. get 和 set 关键字</h3><p><code>get</code>和<code>set</code>关键字在<code>C#</code>中用于定义属性的访问器。</p><ul><li><code>get</code>访问器用于返回属性的值，而<code>set</code>访问器用于为属性分配新值。</li></ul><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> _name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> _name; <span class="comment">// 返回字段的值</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span></span><br><span class="line">        &#123;</span><br><span class="line">            _name = <span class="keyword">value</span>; <span class="comment">// 设置字段的值</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Person person = <span class="keyword">new</span> Person();</span><br><span class="line">        person.Name = <span class="string">&quot;Alice&quot;</span>; <span class="comment">// 调用 set 访问器</span></span><br><span class="line">        Console.WriteLine(person.Name); <span class="comment">// 调用 get 访问器</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>自动属性<ul><li>自动属性是一种简化语法，它让编译器自动生成私有的后备字段。使用自动属性时，不需要显式定义 <code>get</code>和<code>set</code>访问器的实现。</li></ul></li></ul><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; <span class="comment">// 自动属性</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Person person = <span class="keyword">new</span> Person();</span><br><span class="line">        person.Name = <span class="string">&quot;Alice&quot;</span>; <span class="comment">// 自动属性的 set 访问器</span></span><br><span class="line">        Console.WriteLine(person.Name); <span class="comment">// 自动属性的 get 访问器</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>只读和写入属性<ul><li>只读属性: 只定义<code>get</code>访问器的属性。</li><li>写入属性: 只定义<code>set</code>访问器的属性。</li></ul></li></ul><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 只读属性</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> _name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> _name; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span>(<span class="params"><span class="built_in">string</span> name</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写入属性</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> _name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">set</span> &#123; _name = <span class="keyword">value</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">GetName</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> _name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>属性的访问控制<ul><li>可以为属性的<code>get</code>和<code>set</code>访问器指定不同的访问修饰符，以控制它们的访问级别。</li></ul></li></ul><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> _name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> _name; &#125;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">set</span> &#123; _name = <span class="keyword">value</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span>(<span class="params"><span class="built_in">string</span> name</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Name = name; <span class="comment">// 可以在类内部设置值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个示例中，<code>Name</code>属性的<code>set</code>访问器是私有的，因此只能在<code>Person</code>类内部设置<code>Name</code>的值，而<code>get</code> 访问器是公有的，允许从外部读取<code>Name</code>的值。</p><hr><h3 id="35-add-和-remove-关键字"><a href="#35-add-和-remove-关键字" class="headerlink" title="35. add 和 remove 关键字"></a>35. add 和 remove 关键字</h3><p><code>add</code>和<code>remove</code>关键字在<code>C#</code>中用于自定义事件的访问器。这两个关键字允许你定义事件处理程序的添加和移除逻辑，它们通常与<code>event</code>关键字一起使用。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyEventPublisher</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> EventHandler _myEvent;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">event</span> EventHandler MyEvent</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">add</span> =&gt; _myEvent += <span class="keyword">value</span>;</span><br><span class="line">        <span class="keyword">remove</span> =&gt; _myEvent -= <span class="keyword">value</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">RaiseEvent</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        _myEvent?.Invoke(<span class="keyword">this</span>, EventArgs.Empty);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        MyEventPublisher publisher = <span class="keyword">new</span> MyEventPublisher();</span><br><span class="line">        </span><br><span class="line">        EventHandler handler = (sender, e) =&gt; Console.WriteLine(<span class="string">&quot;Event triggered&quot;</span>);</span><br><span class="line">        publisher.MyEvent += handler; <span class="comment">// 触发 add 访问器</span></span><br><span class="line">        publisher.RaiseEvent(); <span class="comment">// 输出 &quot;Event triggered&quot;</span></span><br><span class="line">        </span><br><span class="line">        publisher.MyEvent -= handler; <span class="comment">// 触发 remove 访问器</span></span><br><span class="line">        publisher.RaiseEvent(); <span class="comment">// 没有输出</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过自定义<code>add</code>和<code>remove</code>访问器，开发者可以完全控制事件的订阅和取消订阅过程，使得事件系统更加灵活和可控。</p><hr><h3 id="36-yield-语句"><a href="#36-yield-语句" class="headerlink" title="36. yield 语句"></a>36. yield 语句</h3><p><code>yield</code>语句在<code>C#</code>中用于实现迭代器，该语句使一个方法、<code>get</code>访问器或<code>operator</code>返回一个序列的元素而不必创建临时的集合。这对于在需要延迟执行或处理大数据集合时非常有用，因为它允许按需生成序列中的元素。</p><ul><li><p>基本概念</p><ul><li>迭代器: 一个对象，它实现了<code>IEnumerable</code>或<code>IEnumerator</code>接口，提供一种逐一访问序列中元素的方法，而无需暴露底层表示。</li><li>延迟执行: <code>yield</code>语句使得方法的执行在每次返回一个元素后可以暂停，并在下一次需要元素时恢复。这种特性被称为延迟执行。</li></ul></li><li><p>基本用法 <code>yield return</code> 和 <code>yield break</code></p><ul><li><code>yield return</code>: 用于返回一个序列中的下一个元素，并暂停方法的执行，直到序列中的下一个元素被请求。</li><li><code>yield break</code>: 用于终止迭代，立即退出迭代器块。</li></ul></li></ul><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">FibonacciGenerator</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IEnumerable&lt;<span class="built_in">int</span>&gt; <span class="title">GenerateFibonacci</span>(<span class="params"><span class="built_in">int</span> maxTermCount</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> previous = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">int</span> current = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (count &lt; maxTermCount)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">return</span> previous;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">int</span> next = previous + current;</span><br><span class="line">            previous = current;</span><br><span class="line">            current = next;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Fibonacci Sequence (first 10 terms):&quot;</span>);</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="built_in">int</span> number <span class="keyword">in</span> FibonacciGenerator.GenerateFibonacci(<span class="number">10</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(number);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>yield</code>的优点<ul><li>简化代码: 使用<code>yield</code>可以轻松地创建返回多个值的迭代器，而无需创建临时集合或手动实现 <code>IEnumerable</code>或<code>IEnumerator</code>接口。</li><li>节省内存: 由于<code>yield</code>语句支持延迟执行，它只在需要时生成元素，避免了一次性加载所有数据，节省了内存。</li><li>提高性能: 在处理大数据集或耗时的计算时，<code>yield</code>可以提高性能，因为它允许在序列中逐一访问元素，而不是一次性生成所有元素。</li></ul></li></ul><hr><h3 id="37-async-关键字"><a href="#37-async-关键字" class="headerlink" title="37. async 关键字"></a>37. async 关键字</h3><p><code>async</code>关键字在<code>C#</code>中用于标识一个方法、<code>lambda</code>表达式或匿名方法是异步的。异步方法允许你在不阻塞调用线程的情况下执行长时间运行的操作（如<code>I/O</code>操作、网络请求等）。这种机制使得应用程序可以保持响应，而不需要为每个长时间运行的任务创建新线程。</p><ul><li>基本概念<ul><li>异步方法: 使用<code>async</code>关键字修饰的方法，它可以包含一个或多个<code>await</code>表达式。当异步方法执行到 <code>await</code>表达式时，它会异步地等待操作完成，而不阻塞当前线程。</li><li>返回类型: 异步方法通常返回<code>Task</code>或<code>Task&lt;T&gt;</code>对象，表示一个异步操作的结果。如果方法没有返回值，则返回<code>Task</code>；如果方法有返回值，则返回<code>Task&lt;T&gt;</code>，其中<code>T</code>是返回值的类型。</li></ul></li></ul><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Net.Http;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">async</span> Task <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span> url = <span class="string">&quot;https://jsonplaceholder.typicode.com/posts&quot;</span>;</span><br><span class="line">        <span class="built_in">string</span> result = <span class="keyword">await</span> FetchDataAsync(url);</span><br><span class="line">        Console.WriteLine(result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">async</span> Task&lt;<span class="built_in">string</span>&gt; <span class="title">FetchDataAsync</span>(<span class="params"><span class="built_in">string</span> url</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">using</span> (HttpClient client = <span class="keyword">new</span> HttpClient())</span><br><span class="line">        &#123;</span><br><span class="line">            HttpResponseMessage response = <span class="keyword">await</span> client.GetAsync(url);</span><br><span class="line">            response.EnsureSuccessStatusCode();</span><br><span class="line">            <span class="built_in">string</span> responseData = <span class="keyword">await</span> response.Content.ReadAsStringAsync();</span><br><span class="line">            <span class="keyword">return</span> responseData;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>重要注意事项<ul><li>异步所有: 异步方法内部调用的所有可能阻塞的操作也应尽可能使用异步版本。</li><li>错误处理: 在异步方法中，可以像处理同步代码中的异常一样使用<code>try-catch</code>进行异常处理。未处理的异常会在返回的<code>Task</code>对象上引发。</li></ul></li></ul><hr><h3 id="38-lambda-表达式"><a href="#38-lambda-表达式" class="headerlink" title="38. lambda 表达式"></a>38. lambda 表达式</h3><p><code>Lambda</code>表达式是<code>C#</code>中的一种匿名函数，它可以包含表达式或语句块，并且可以用来创建委托或表达式树类型。<code>Lambda</code>表达式提供了一种简洁的语法，用于定义内联的函数或将函数作为参数传递给方法。<code>Lambda</code>表达式通常用于<code>LINQ</code>查询、事件处理程序和函数式编程。</p><ul><li>使用单行表达式的<code>Lambda</code>表达式</li></ul><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Func&lt;<span class="built_in">int</span>, <span class="built_in">int</span>, <span class="built_in">int</span>&gt; multiply = (x, y) =&gt; x * y;</span><br><span class="line">Console.WriteLine(multiply(<span class="number">2</span>, <span class="number">3</span>)); <span class="comment">// 输出: 6</span></span><br></pre></td></tr></table></figure><p>在这个示例中，<code>multiply</code>是一个<code>Func&lt;int, int, int&gt;</code>类型的委托，它接受两个<code>int</code>参数并返回一个 <code>int</code>。<code>Lambda</code>表达式<code>(x, y) =&gt; x * y</code>定义了这个委托的实现。</p><ul><li>使用语句块的<code>Lambda</code>表达式</li></ul><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Action&lt;<span class="built_in">string</span>&gt; greet = name =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> greeting = <span class="string">$&quot;Hello, <span class="subst">&#123;name&#125;</span>!&quot;</span>;</span><br><span class="line">    Console.WriteLine(greeting);</span><br><span class="line">&#125;;</span><br><span class="line">greet(<span class="string">&quot;World&quot;</span>); <span class="comment">// 输出: Hello, World!</span></span><br></pre></td></tr></table></figure><p>在这个示例中，<code>greet</code>是一个<code>Action&lt;string&gt;</code>类型的委托，它接受一个<code>string</code>参数并返回<code>void</code>。<code>Lambda</code>表达式<code>name =&gt; &#123; ... &#125;</code>使用了语句块来执行多行操作。</p><ul><li>无参数的<code>Lambda</code>表达式</li></ul><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Func&lt;<span class="built_in">int</span>&gt; getRandomNumber = () =&gt; <span class="keyword">new</span> Random().Next(<span class="number">1</span>, <span class="number">100</span>);</span><br><span class="line">Console.WriteLine(getRandomNumber()); <span class="comment">// 输出一个随机数</span></span><br></pre></td></tr></table></figure><p>在这个示例中，<code>getRandomNumber</code>是一个<code>Func&lt;int&gt;</code>类型的委托，它不接受任何参数并返回一个<code>int</code>。<code>Lambda</code>表达式<code>() =&gt; new Random().Next(1, 100)</code>定义了一个没有参数的函数。</p><ul><li>单个参数的简写形式</li></ul><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Func&lt;<span class="built_in">int</span>, <span class="built_in">int</span>&gt; square = x =&gt; x * x;</span><br><span class="line">Console.WriteLine(square(<span class="number">5</span>)); <span class="comment">// 输出: 25</span></span><br></pre></td></tr></table></figure><p>在这个示例中，<code>square</code>是一个<code>Func&lt;int, int&gt;</code>类型的委托，它接受一个<code>int</code>参数并返回一个<code>int</code>。<code>Lambda</code>表达式<code>x =&gt; x * x</code>省略了参数类型和括号。</p><ul><li><code>LINQ</code>查询<ul><li><code>Lambda</code>表达式广泛用于<code>LINQ</code>查询中，作为查询表达式的条件和投影。</li></ul></li></ul><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> numbers = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt; &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> evenNumbers = numbers.Where(n =&gt; n % <span class="number">2</span> == <span class="number">0</span>);</span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> number <span class="keyword">in</span> evenNumbers)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(number); <span class="comment">// 输出: 2, 4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>委托和事件处理<ul><li><code>Lambda</code>表达式可以用来简洁地定义委托和事件处理程序。</li></ul></li></ul><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Button btn = <span class="keyword">new</span> Button();</span><br><span class="line">btn.Click += (sender, e) =&gt; Console.WriteLine(<span class="string">&quot;Button clicked!&quot;</span>);</span><br></pre></td></tr></table></figure><hr><h3 id="39-匿名方法"><a href="#39-匿名方法" class="headerlink" title="39. 匿名方法"></a>39. 匿名方法</h3><p>匿名方法<code>Anonymous Methods</code>是<code>C#</code>中的一种定义委托实例的方式，它允许你在代码中直接声明一个没有名称的方法。匿名方法提供了一种简洁的方式来创建内联的委托，而不必显式地定义一个单独的方法。</p><ul><li>匿名方法使用<code>delegate</code>关键字，并且可以包含参数和方法体。</li></ul><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">DisplayMessage</span>(<span class="params"><span class="built_in">string</span> message</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 使用匿名方法定义委托实例</span></span><br><span class="line">        DisplayMessage display = <span class="built_in">delegate</span>(<span class="built_in">string</span> message)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(message);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用匿名方法</span></span><br><span class="line">        display(<span class="string">&quot;Hello, World!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>匿名方法和<code>Lambda</code>表达式比较</li></ul><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 匿名方法</span></span><br><span class="line">Func&lt;<span class="built_in">int</span>, <span class="built_in">int</span>&gt; square1 = <span class="built_in">delegate</span>(<span class="built_in">int</span> x) &#123; <span class="keyword">return</span> x * x; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Lambda 表达式</span></span><br><span class="line">Func&lt;<span class="built_in">int</span>, <span class="built_in">int</span>&gt; square2 = x =&gt; x * x;</span><br></pre></td></tr></table></figure><ul><li>何时使用匿名方法<ul><li>复杂逻辑: 当方法体包含复杂逻辑或多行代码时，可以选择使用匿名方法。</li><li>捕获多个变量: 需要捕获多个外部变量或参数时，匿名方法可以提供更清晰的语法结构。</li></ul></li></ul><hr><h3 id="40-泛型函数"><a href="#40-泛型函数" class="headerlink" title="40. 泛型函数"></a>40. 泛型函数</h3><p>泛型函数<code>Generic Functions</code>是指可以接受不同类型参数的函数。<code>C#</code>中的泛型函数通过在函数的定义中使用类型参数，使得函数可以独立于具体的数据类型来编写。在调用泛型函数时，具体的类型会被替换为实际使用的类型。这样，泛型函数可以在不重复编写代码的情况下适应多种数据类型。</p><ul><li>定义泛型函数<ul><li>在<code>C#</code>中，泛型函数通过在方法名称后使用尖括号<code>&lt;T&gt;</code>形式的类型参数来定义，其中<code>T</code>是类型参数的占位符。可以有多个类型参数，例如<code>&lt;T, U&gt;</code>等。</li></ul></li></ul><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Print&lt;<span class="built_in">int</span>&gt;(<span class="number">123</span>);        <span class="comment">// 输出: 123</span></span><br><span class="line">        Print&lt;<span class="built_in">string</span>&gt;(<span class="string">&quot;Hello&quot;</span>); <span class="comment">// 输出: Hello</span></span><br><span class="line">        Print&lt;<span class="built_in">double</span>&gt;(<span class="number">3.14</span>);    <span class="comment">// 输出: 3.14</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Print</span>&lt;<span class="title">T</span>&gt;(<span class="params">T <span class="keyword">value</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="keyword">value</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>多个类型参数<ul><li>泛型函数可以有多个类型参数，使用逗号分隔。</li></ul></li></ul><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Swap</span>&lt;<span class="title">T</span>, <span class="title">U</span>&gt;(<span class="params"><span class="keyword">ref</span> T first, <span class="keyword">ref</span> U second</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    T temp = first;</span><br><span class="line">    first = (T)(<span class="built_in">object</span>)second;</span><br><span class="line">    second = (U)(<span class="built_in">object</span>)temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个示例中，<code>Swap</code>方法使用了两个类型参数<code>T</code>和<code>U</code>，可以交换不同类型的变量。</p><ul><li>类型约束<ul><li>可以对泛型类型参数施加约束，以限制可用的类型。例如，限制类型参数必须实现某个接口或继承自某个类。</li></ul></li></ul><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Display</span>&lt;<span class="title">T</span>&gt;(<span class="params">T <span class="keyword">value</span></span>) <span class="keyword">where</span> T : IComparable&lt;T&gt;</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="keyword">value</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个示例中，<code>Display&lt;T&gt;</code>方法只能接受实现了<code>IComparable&lt;T&gt;</code>接口的类型。</p><ul><li>泛型函数的优点<ul><li>代码重用: 泛型函数允许编写通用的代码，可以与不同的数据类型一起使用，而无需为每种类型编写重复的代码。</li><li>类型安全: 使用泛型可以在编译时检查类型一致性，避免运行时错误。</li><li>性能: 泛型函数不会像非泛型集合类那样引入装箱和拆箱操作（对于值类型），因此可以提高性能。</li></ul></li></ul><hr><h3 id="41-LINQ-语言集成查询"><a href="#41-LINQ-语言集成查询" class="headerlink" title="41. LINQ (语言集成查询)"></a>41. LINQ (语言集成查询)</h3><p><code>LINQ</code>（语言集成查询）是<code>C#</code>提供的一种功能，使得开发者可以使用类似<code>SQL</code>的语法来查询和操作各种数据源，如对象集合、数据库、<code>XML</code>等。<code>LINQ</code>提供了一种统一的查询语法和机制，使得数据查询和操作更加简洁、类型安全和可维护。</p><ul><li><p><code>LINQ</code>的基本概念</p><ul><li>统一的查询语法: 无论数据来源是什么，<code>LINQ</code>提供了统一的查询语法，简化了数据访问和操作的过程。</li><li>延迟执行: <code>LINQ</code>查询通常是延迟执行的，即只有在查询结果被真正访问时，才会执行查询。这可以提高性能，尤其是在处理大型数据集时。</li></ul></li><li><p><code>LINQ</code>查询语法</p><ul><li>查询语法类似<code>SQL</code>，是一种声明式的语法，描述我们希望从数据源中提取什么样的数据。</li></ul></li></ul><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span>[] numbers = &#123; <span class="number">5</span>, <span class="number">10</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">12</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> numQuery = <span class="keyword">from</span> num <span class="keyword">in</span> numbers</span><br><span class="line">               <span class="keyword">where</span> num % <span class="number">2</span> == <span class="number">0</span></span><br><span class="line">               <span class="keyword">orderby</span> num</span><br><span class="line">               <span class="keyword">select</span> num;</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span> (<span class="built_in">int</span> num <span class="keyword">in</span> numQuery)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>LINQ</code>方法语法<ul><li>方法语法使用标准查询运算符方法，这些方法是静态方法，可以像链条一样连接起来。</li></ul></li></ul><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span>[] numbers = &#123; <span class="number">5</span>, <span class="number">10</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">12</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> numQuery = numbers.Where(num =&gt; num % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">                      .OrderBy(num =&gt; num)</span><br><span class="line">                      .Select(num =&gt; num);</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span> (<span class="built_in">int</span> num <span class="keyword">in</span> numQuery)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>LINQ</code>的核心概念之一就是它可以作用于实现了<code>IEnumerable&lt;T&gt;</code>接口的任何数据源。</li></ul><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        List&lt;<span class="built_in">int</span>&gt; numbers = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt; &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用 LINQ 查询</span></span><br><span class="line">        IEnumerable&lt;<span class="built_in">int</span>&gt; evenNumbers = numbers.Where(n =&gt; n % <span class="number">2</span> == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 枚举查询结果</span></span><br><span class="line">        <span class="keyword">foreach</span> (<span class="built_in">int</span> num <span class="keyword">in</span> evenNumbers)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(num); <span class="comment">// 输出: 2, 4</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总而言之，<code>LINQ</code>是<code>C#</code>中的一个强大功能，它提供了一个统一的方式来查询和操作各种数据源。通过 <code>LINQ</code>，开发者可以使用简单、清晰且类型安全的代码来执行复杂的数据操作。</p><hr><h3 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h3><blockquote><p>文件还未上传 Github</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ES6学习笔记 • 下</title>
      <link href="/posts/461e57d3.html"/>
      <url>/posts/461e57d3.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>本读书笔记节是针对阮一峰编写的 <a href="https://es6.ruanyifeng.com/">《ECMAScript 6 入门教程》</a>的总结。适合已经掌握 <code>ES5</code> 的读者，用来了解这门语言的最新发展。笔记内容仅包括日常开发中可能会用到的概念。</p></blockquote><hr><h2 id="20-async-函数"><a href="#20-async-函数" class="headerlink" title="20. async 函数"></a>20. async 函数</h2><h3 id="20-1-含义"><a href="#20-1-含义" class="headerlink" title="20.1 含义"></a>20.1 含义</h3><p><code>ES6</code>引入的 <code>async</code> 函数，使得异步操作变得更加方便。简单来说，<code>async</code> 函数就是 <code>Generator</code> 函数的语法糖。它将 <code>Generator</code>函数的星号<code>*</code>替换成<code>async</code>，<code>yield</code>替换成<code>await</code>。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> readFile = <span class="keyword">function</span> (<span class="params">fileName</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">    fs.<span class="title function_">readFile</span>(fileName, <span class="keyword">function</span> (<span class="params">error, data</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (error) <span class="keyword">return</span> <span class="title function_">reject</span>(error);</span><br><span class="line">      <span class="title function_">resolve</span>(data);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> gen = <span class="keyword">function</span>* () &#123;</span><br><span class="line">  <span class="keyword">const</span> f1 = <span class="keyword">yield</span> <span class="title function_">readFile</span>(<span class="string">&quot;/etc/fstab&quot;</span>);</span><br><span class="line">  <span class="keyword">const</span> f2 = <span class="keyword">yield</span> <span class="title function_">readFile</span>(<span class="string">&quot;/etc/shells&quot;</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(f1.<span class="title function_">toString</span>());</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(f2.<span class="title function_">toString</span>());</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面代码中，函数<code>gen</code>依次读取两个文件，如果写成<code>async</code>函数，就是下面这样。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> asyncReadFile = <span class="keyword">async</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> f1 = <span class="keyword">await</span> <span class="title function_">readFile</span>(<span class="string">&quot;/etc/fstab&quot;</span>);</span><br><span class="line">  <span class="keyword">const</span> f2 = <span class="keyword">await</span> <span class="title function_">readFile</span>(<span class="string">&quot;/etc/shells&quot;</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(f1.<span class="title function_">toString</span>());</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(f2.<span class="title function_">toString</span>());</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>async</code>函数对 <code>Generator</code> 函数的改进，体现在以下四点</p><ol><li>内置执行器: <code>Generator</code> 函数的执行必须靠执行器（<code>co</code>模块），而<code>async</code>函数自带执行器。也就是说，<code>async</code>函数的执行，与普通函数一模一样。</li><li>更好的语义: <code>async</code>和<code>await</code>，比起星号和<code>yield</code>，语义更清楚了。<code>async</code>表示函数里有异步操作，<code>await</code>表示紧跟在后面的表达式需要等待结果。</li><li>更广的适用性: <code>co</code>模块约定，<code>yield</code>命令后面只能是 <code>Thunk</code> 函数或 <code>Promise</code> 对象，而<code>async</code>函数的<code>await</code>命令后面，可以是 <code>Promise</code> 对象和原始类型的值。（数值、字符串和布尔值，但会自动转成立即 <code>resolved</code> 的 <code>Promise</code> 对象）</li><li>返回值是 Promise: <ins><code>async</code>函数的返回值是 <code>Promise</code> 对象</ins>，这比 <code>Generator</code> 函数的返回值是 <code>Iterator</code> 对象方便，可以用<code>then</code>方法指定下一步的操作。</li></ol><p>进一步说，<code>async</code>函数可以看作多个异步操作，包装成的一个 <code>Promise</code> 对象，而<code>await</code>命令就是可以替代<code>then</code>的语法糖。下面的 <code>Promise</code> 链可以被重写为一个 <code>async</code> 函数。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">fetch</span>(<span class="string">&quot;https://api.example.com/data&quot;</span>)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">response</span>) =&gt;</span> response.<span class="title function_">json</span>())</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">data</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(data))</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function">(<span class="params">error</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&quot;Error:&quot;</span>, error));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">fetchData</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> response = <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="string">&quot;https://api.example.com/data&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> data = <span class="keyword">await</span> response.<span class="title function_">json</span>();</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&quot;Error:&quot;</span>, error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="20-2-基本用法"><a href="#20-2-基本用法" class="headerlink" title="20.2 基本用法"></a>20.2 基本用法</h3><p><ins><code>async</code>函数返回一个 <code>Promise</code> 对象，可以使用<code>then</code>方法添加回调函数</ins>。当函数执行的时候，<ins>遇到<code>await</code>就会暂停当前的<code>async</code>函数执行，等到异步操作完成，再接着执行函数体内后面的语句</ins>。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">fetchUserData</span>(<span class="params">userId</span>) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 这里假设我们有一个返回Promise的fetch函数</span></span><br><span class="line">    <span class="keyword">const</span> response = <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="string">`https://api.example.com/user/<span class="subst">$&#123;userId&#125;</span>`</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 需要检查响应是否ok，如果不ok则抛出错误</span></span><br><span class="line">    <span class="keyword">if</span> (!response.<span class="property">ok</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">`HTTP error! status: <span class="subst">$&#123;response.status&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> user = <span class="keyword">await</span> response.<span class="title function_">json</span>(); <span class="comment">// 假设服务器响应的是JSON数据</span></span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(</span><br><span class="line">      <span class="string">`There was a problem with the fetch operation: <span class="subst">$&#123;error.message&#125;</span>`</span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用这个函数</span></span><br><span class="line"><span class="title function_">fetchUserData</span>(<span class="number">123</span>)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">user</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(user))</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function">(<span class="params">error</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">error</span>(error));</span><br></pre></td></tr></table></figure><p>上面代码中，<code>fetchUserData</code>是一个异步函数，它使用<code>fetchAPI</code>从服务器获取数据，然后使用<code>await</code>关键字等待<code>Promise</code>解决。注意，在异步函数中，我们应该始终使用<code>try/catch</code>来捕获可能出现的错误。<br><br></p><p><code>async</code>函数有多种使用形式。它可以作为声明，作为表达式，还可以用来定义对象或类的方法。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数表达式</span></span><br><span class="line"><span class="keyword">const</span> foo = <span class="keyword">async</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象的方法</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123; <span class="keyword">async</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;&#125; &#125;;</span><br><span class="line">obj.<span class="title function_">foo</span>().<span class="title function_">then</span>(...)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Class 的方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Storage</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">cachePromise</span> = caches.<span class="title function_">open</span>(<span class="string">&#x27;avatars&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">async</span> <span class="title function_">getAvatar</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> cache = <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="property">cachePromise</span>;</span><br><span class="line">    <span class="keyword">return</span> cache.<span class="title function_">match</span>(<span class="string">`/avatars/<span class="subst">$&#123;name&#125;</span>.jpg`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> storage = <span class="keyword">new</span> <span class="title class_">Storage</span>();</span><br><span class="line">storage.<span class="title function_">getAvatar</span>(<span class="string">&#x27;jake&#x27;</span>).<span class="title function_">then</span>(…);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 箭头函数</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">foo</span> = <span class="keyword">async</span> (<span class="params"></span>) =&gt; &#123;&#125;;</span><br></pre></td></tr></table></figure><hr><h3 id="20-3-语法"><a href="#20-3-语法" class="headerlink" title="20.3 语法"></a>20.3 语法</h3><p><code>async</code>函数的语法规则总体上比较简单，难点是错误处理机制。<br><br></p><p><strong>（1）返回 Promise 对象</strong></p><p><ins><code>async</code>函数返回一个 <code>Promise</code> 对象</ins>（不管有没有<code>return</code>语句，总是返回一个 <code>Promise</code> 对象）。<ins><code>async</code>函数内部<code>return</code>语句返回的值，会成为<code>then</code>方法回调函数的参数</ins>。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">f</span>().<span class="title function_">then</span>(<span class="function">(<span class="params">v</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(v));</span><br><span class="line"><span class="comment">// &quot;hello world&quot;</span></span><br></pre></td></tr></table></figure><p>上面代码中，函数<code>f</code>内部<code>return</code>命令返回的值，会被<code>then</code>方法回调函数接收到。<br><br></p><p><ins><code>async</code>函数内部抛出错误，会导致返回的 <code>Promise</code> 对象变为<code>reject</code>状态</ins>。抛出的错误对象会被<code>catch</code>方法回调函数接收到。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;出错了&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">f</span>()</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">v</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;resolve&quot;</span>, v))</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function">(<span class="params">e</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;reject&quot;</span>, e));</span><br></pre></td></tr></table></figure><p><strong>（2）Promise 对象的状态变化</strong></p><p><code>async</code>函数返回的 <code>Promise</code> 对象，必须等到内部所有<code>await</code>命令后面的 <code>Promise</code> 对象执行完，才会发生状态改变，除非遇到<code>return</code>语句或者抛出错误。也就是说，<ins>只有<code>async</code>函数内部的异步操作执行完，才会执行<code>then</code>方法指定的回调函数</ins>。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">asyncFunc</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> response = <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="string">&quot;https://api.example.com/data&quot;</span>);</span><br><span class="line">  <span class="keyword">const</span> data = <span class="keyword">await</span> response.<span class="title function_">json</span>();</span><br><span class="line">  <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">asyncFunc</span>()</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">data</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(data))</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function">(<span class="params">error</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">error</span>(error));</span><br></pre></td></tr></table></figure><p>上面代码中，<code>then</code>方法的回调函数会等到<code>asyncFunc</code>函数内部的两个<code>await</code>操作都完成后才会被调用。<br><br></p><p><strong>（3）await 命令</strong></p><p>正常情况下，<ins><code>await</code>命令后面是一个 <code>Promise</code> 对象，返回该对象的结果。如果不是 <code>Promise</code> 对象，就直接返回对应的值</ins>。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 等同于</span></span><br><span class="line">  <span class="comment">// return 123;</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">await</span> <span class="number">123</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">f</span>().<span class="title function_">then</span>(<span class="function">(<span class="params">v</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(v));</span><br><span class="line"><span class="comment">// 123</span></span><br></pre></td></tr></table></figure><p>另一种情况是，<code>await</code>命令后面是一个<code>thenable</code>对象（即定义了<code>then</code>方法的对象，详细请看<code>Promise</code>章节的<code>resolve()</code>方法），那么<code>await</code>会将其等同于 <code>Promise</code> 对象。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> thenable = &#123;</span><br><span class="line">  <span class="attr">then</span>: <span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="string">&quot;Resolved!&quot;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">asyncFunc</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="keyword">await</span> thenable;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(result); <span class="comment">// &#x27;Resolved!&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">asyncFunc</span>();</span><br><span class="line"><span class="comment">// 1000</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>thenable</code>对象有一个<code>then</code>方法，所以可以在<code>asyncFunc</code>函数中使用<code>await</code>来等待它。<ins>当<code>JS</code>引擎看到我们试图等待一个<code>thenable</code>对象时，它会自动调用该对象的<code>then</code>方法</ins>，并等待该方法调用其<code>resolve</code>参数所传入的值。<br><br></p><p>如果<ins><code>await</code>命令后面的 <code>Promise</code> 对象如果变为<code>reject</code>状态，则<code>reject</code>的参数会被<code>catch</code>方法的回调函数接收到</ins>。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="string">&quot;出错了&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">f</span>()</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">v</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(v))</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function">(<span class="params">e</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(e));</span><br><span class="line"><span class="comment">// 出错了</span></span><br></pre></td></tr></table></figure><p>注意，上面代码中<code>await</code>语句前面没有<code>return</code>，但是<code>reject</code>方法的参数依然传入了<code>catch</code>方法的回调函数。这里如果在<code>await</code>前面加上<code>return</code>，效果是一样的。<br><br></p><p><ins>任何一个<code>await</code>语句后面的 <code>Promise</code> 对象变为<code>reject</code>状态，不会导致整个 <code>async</code> 函数立即停止执行，而是会抛出异常。我们可以用 <code>try/catch</code> 语句来捕获这个异常并处理它。</ins>（如果没有错误处理机制，<code>async</code>函数会中断执行）<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 情况 1</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="string">&quot;出错了&quot;</span>);</span><br><span class="line">  <span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&quot;hello world&quot;</span>); <span class="comment">// 不会执行</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 情况 2</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">asyncFunc</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> response = <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="string">&quot;https://api.example.com/data&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> data = <span class="keyword">await</span> response.<span class="title function_">json</span>();</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&quot;Error:&quot;</span>, error);</span><br><span class="line">    <span class="comment">// 这里可以处理错误，并决定如何继续执行</span></span><br><span class="line">    <span class="comment">// 比如可以重新抛出错误，或者返回一个默认值，等等</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有时我们希望<ins>即使前一个异步操作失败，也不要中断后面的异步操作</ins>。我们可以将<code>await</code>放在<code>try...catch</code>结构里面，这样不管这个异步操作是否成功，下一个<code>await</code>都会执行。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="string">&quot;出错了&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(e);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">f</span>().<span class="title function_">then</span>(<span class="function">(<span class="params">v</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(v));</span><br><span class="line"><span class="comment">// 出错了</span></span><br><span class="line"><span class="comment">// hello world</span></span><br></pre></td></tr></table></figure><p>另一种方法是<code>await</code>后面的 <code>Promise</code> 对象再跟一个<code>catch</code>方法，处理前面可能出现的错误。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="string">&quot;出错了&quot;</span>).<span class="title function_">catch</span>(<span class="function">(<span class="params">e</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(e));</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">f</span>().<span class="title function_">then</span>(<span class="function">(<span class="params">v</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(v));</span><br><span class="line"><span class="comment">// 出错了</span></span><br><span class="line"><span class="comment">// hello world</span></span><br></pre></td></tr></table></figure><p>这种方法的优点是它更加紧凑，不需要显式地使用<code>try/catch</code>。但它的缺点是需要确保每个可能产生错误的<code>await</code>都有一个<code>catch</code>方法，否则错误可能会被忽视。<br><br></p><p><strong>（4）错误处理</strong></p><p>如果<ins><code>await</code>后面的异步操作出错，那么等同于<code>async</code>函数返回的 <code>Promise</code> 对象被<code>reject</code></ins>。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">asyncFunc</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> response = <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="string">&quot;https://api.example.com/data&quot;</span>);</span><br><span class="line">  <span class="comment">// 如果 fetch 出错（例如，由于网络问题），那么下面的代码将不会被执行</span></span><br><span class="line">  <span class="keyword">let</span> data = <span class="keyword">await</span> response.<span class="title function_">json</span>();</span><br><span class="line">  <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">asyncFunc</span>()</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">data</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(data))</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function">(<span class="params">error</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&quot;Error:&quot;</span>, error));</span><br><span class="line"><span class="comment">// 如果 asyncFunc 在任何地方抛出了一个错误，那么这个 .catch 将会捕获到</span></span><br></pre></td></tr></table></figure><p>上面代码中，如果<code>fetch</code>函数抛出一个错误，那么<code>asyncFunc</code>会立即停止执行并抛出一个错误，导致它返回的<code>Promise</code>变为<code>rejected</code>状态。这个错误然后被<code>catch</code>捕获并处理。<br><br></p><p>防止出错的方法，就是将其放在<code>try...catch</code>代码块之中。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;出错了&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(e);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">await</span> <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果有多个<code>await</code>命令，可以统一放在<code>try...catch</code>结构中。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> val1 = <span class="keyword">await</span> <span class="title function_">firstStep</span>();</span><br><span class="line">    <span class="keyword">const</span> val2 = <span class="keyword">await</span> <span class="title function_">secondStep</span>(val1);</span><br><span class="line">    <span class="keyword">const</span> val3 = <span class="keyword">await</span> <span class="title function_">thirdStep</span>(val1, val2);</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Final: &quot;</span>, val3);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(err);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，上面三个异步操作是串行处理，即<code>secondStep</code>将在<code>firstStep</code>完成后开始。如果这三个操作之间没有依赖关系，可以使用<code>Promise.all()</code>并行执行以提高效率。<br><br></p><p><strong>（5）使用注意点</strong></p><p>第一点，<code>await</code>命令后面的<code>Promise</code>对象，运行结果可能是<code>rejected</code>，所以<ins>最好把<code>await</code>命令放在<code>try...catch</code>代码块中</ins>。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">myFunction</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">somethingThatReturnsAPromise</span>();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(err);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 另一种写法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">myFunction</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="title function_">somethingThatReturnsAPromise</span>().<span class="title function_">catch</span>(<span class="keyword">function</span> (<span class="params">err</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(err);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二点，<ins>多个<code>await</code>命令后面的异步操作，如果不存在继发关系，最好让它们同时触发</ins>。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> foo = <span class="keyword">await</span> <span class="title function_">getFoo</span>();</span><br><span class="line"><span class="keyword">let</span> bar = <span class="keyword">await</span> <span class="title function_">getBar</span>();</span><br></pre></td></tr></table></figure><p>上面代码中，<code>getFoo</code>和<code>getBar</code>是两个独立的异步操作（即互不依赖），被写成继发关系。这样比较耗时，因为只有<code>getFoo</code>完成以后，才会执行<code>getBar</code>，完全可以让它们同时触发。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="keyword">let</span> [foo, bar] = <span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">all</span>([<span class="title function_">getFoo</span>(), <span class="title function_">getBar</span>()]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="keyword">let</span> fooPromise = <span class="title function_">getFoo</span>();</span><br><span class="line"><span class="keyword">let</span> barPromise = <span class="title function_">getBar</span>();</span><br><span class="line"><span class="keyword">let</span> foo = <span class="keyword">await</span> fooPromise;</span><br><span class="line"><span class="keyword">let</span> bar = <span class="keyword">await</span> barPromise;</span><br></pre></td></tr></table></figure><p>上面两种写法，<code>getFoo</code>和<code>getBar</code>都是同时触发，这样就会缩短程序的执行时间。<br><br></p><p>第三点，<code>await</code>命令只能用在<code>async</code>函数之中，如果用在普通函数，就会报错。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">dbFuc</span>(<span class="params">db</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 报错</span></span><br><span class="line">  docs.<span class="title function_">forEach</span>(<span class="keyword">function</span> (<span class="params">doc</span>) &#123;</span><br><span class="line">    <span class="keyword">await</span> db.<span class="title function_">post</span>(doc);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码会报错，因为<code>await</code>用在普通函数之中。但是，就算将<code>forEach</code>方法的参数改成<code>async</code>函数也有问题。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">dbFuc</span>(<span class="params">db</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 可能得到错误结果</span></span><br><span class="line">  docs.<span class="title function_">forEach</span>(<span class="keyword">async</span> <span class="keyword">function</span> (<span class="params">doc</span>) &#123;</span><br><span class="line">    <span class="keyword">await</span> db.<span class="title function_">post</span>(doc);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码可能不会正常工作，原因是这时三个<code>db.post()</code>操作将是并发执行（<code>forEach</code> 不会等待回调函数），也就是同时执行，而不是继发执行。正确的写法是采用<code>for</code>循环。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">dbFuc</span>(<span class="params">db</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> doc <span class="keyword">of</span> docs) &#123;</span><br><span class="line">    <span class="keyword">await</span> db.<span class="title function_">post</span>(doc);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一种方法是使用数组的<a href="https://www.javascripttutorial.net/javascript-array-reduce/"><code>reduce()</code></a>方法来逐个顺序处理数组中的元素。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">dbFunc</span>(<span class="params">db</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">await</span> docs.<span class="title function_">reduce</span>(<span class="keyword">async</span> (prevPromise, doc) =&gt; &#123;</span><br><span class="line">    <span class="keyword">await</span> prevPromise;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">await</span> db.<span class="title function_">post</span>(doc);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&quot;An error occurred: &quot;</span>, error);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, <span class="title class_">Promise</span>.<span class="title function_">resolve</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，传递给<code>reduce()</code>的函数返回一个<code>Promise</code>，这个<code>Promise</code>在前一个 <code>Promise</code>解析之后开始另一项数据库操作。我们使用<code>Promise.resolve()</code>作为初始值，以开始 <code>Promise</code>链。<br><br></p><p>如果希望<ins>多个请求并发执行，可以使用<code>Promise.all()</code>方法</ins>。下面两种写法效果相同。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">dbFuc</span>(<span class="params">db</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];</span><br><span class="line">  <span class="keyword">let</span> promises = docs.<span class="title function_">map</span>(<span class="function">(<span class="params">doc</span>) =&gt;</span> db.<span class="title function_">post</span>(doc));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> results = <span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">all</span>(promises);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(results);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者使用下面的写法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">dbFuc</span>(<span class="params">db</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];</span><br><span class="line">  <span class="keyword">let</span> promises = docs.<span class="title function_">map</span>(<span class="function">(<span class="params">doc</span>) =&gt;</span> db.<span class="title function_">post</span>(doc));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> results = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> promise <span class="keyword">of</span> promises) &#123;</span><br><span class="line">    results.<span class="title function_">push</span>(<span class="keyword">await</span> promise);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(results);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第四点，<code>async</code> 函数可以保留运行堆栈。它会在等待<code>Promise</code>解析期间暂停函数的执行，而不是在全局范围内阻止执行，这使得调试工具能够在可能发生错误的地方停下来。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">a</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="title function_">b</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="title function_">c</span>());</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面代码中，假定函数<code>a</code>内部运行了一个异步任务<code>b()</code>。当<code>b()</code>运行的时候，函数<code>a()</code>不会中断，而是继续执行。<ins>等到<code>b()</code>运行结束，可能<code>a()</code>早就运行结束了，<code>b()</code>所在的上下文环境已经消失了</ins>。如果<code>b()</code>或<code>c()</code>报错，<a href="https://zhuanlan.zhihu.com/p/26637923">错误堆栈</a>将不包括<code>a()</code>。<br><br></p><p>现在将这个例子改成<code>async</code>函数。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">a</span> = <span class="keyword">async</span> (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="title function_">b</span>();</span><br><span class="line">  <span class="title function_">c</span>();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>b()</code>运行的时候，<code>a()</code>是暂停执行，上下文环境都保存着。一旦<code>b()</code>或<code>c()</code>报错，错误堆栈将包括<code>a()</code>。</p><hr><h3 id="20-4-async-函数实现原理"><a href="#20-4-async-函数实现原理" class="headerlink" title="20.4 async 函数实现原理"></a>20.4 async 函数实现原理</h3><p><code>async</code> 函数的实现原理，就是将 <code>Generator</code> 函数和自动执行器，包装在一个函数里。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">args</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">args</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">spawn</span>(<span class="keyword">function</span>* () &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所有的<code>async</code>函数都可以写成上面的第二种形式，其中的<code>spawn</code>函数就是自动执行器。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">spawn</span>(<span class="params">genF</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> gen = <span class="title function_">genF</span>(); <span class="comment">// 建立 Generater 函数</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">step</span>(<span class="params">nextF</span>) &#123;</span><br><span class="line">      <span class="comment">// nextF 是一个 Generater 函数</span></span><br><span class="line">      <span class="keyword">let</span> next;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        next = <span class="title function_">nextF</span>(); <span class="comment">// 启动 Generater，返回当前状态，运行至下一个 yield</span></span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">reject</span>(e);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (next.<span class="property">done</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">resolve</span>(next.<span class="property">value</span>); <span class="comment">// 结束执行器</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(next.<span class="property">value</span>).<span class="title function_">then</span>(</span><br><span class="line">        <span class="keyword">function</span> (<span class="params">v</span>) &#123;</span><br><span class="line">          <span class="title function_">step</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> gen.<span class="title function_">next</span>(v);</span><br><span class="line">          &#125;); <span class="comment">// 开始递归</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">          <span class="title function_">step</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> gen.<span class="keyword">throw</span>(e);</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 传递一个 function，用来启动 Generater，第一次传参是无效的</span></span><br><span class="line">    <span class="title function_">step</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> gen.<span class="title function_">next</span>(<span class="literal">undefined</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="20-5-异步处理方法的比较"><a href="#20-5-异步处理方法的比较" class="headerlink" title="20.5 异步处理方法的比较"></a>20.5 异步处理方法的比较</h3><p>通过一个例子，我们来看看 <code>async</code> 函数与 <code>Promise</code>、<code>Generator</code> 函数的比较。</p><ul><li>假定某个 <code>DOM</code> 元素上面，部署了一系列的动画，前一个动画结束，才能开始后一个。如果当中有一个动画出错，就不再往下执行，返回上一个成功执行的动画的返回值。</li></ul><p>首先是 <code>Promise</code> 的写法。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">chainAnimationsPromise</span>(<span class="params">elem, animations</span>) &#123;</span><br><span class="line">  <span class="comment">// 变量 ret 用来保存上一个动画的返回值</span></span><br><span class="line">  <span class="keyword">let</span> ret = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始化一个已解决的 Promise</span></span><br><span class="line">  <span class="keyword">let</span> p = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 遍历 animations 数组中的每个动画</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> anim <span class="keyword">of</span> animations) &#123;</span><br><span class="line">    <span class="comment">// 将每个动画链接到 Promise 链</span></span><br><span class="line">    p = p.<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">val</span>) &#123;</span><br><span class="line">      <span class="comment">// 保存前一个动画的解决值</span></span><br><span class="line">      ret = val;</span><br><span class="line">      <span class="comment">// 执行当前动画并返回新的 Promise</span></span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">anim</span>(elem);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 任何一个动画的 Promise 被拒绝，将被 catch 捕捉</span></span><br><span class="line">  <span class="keyword">return</span> p</span><br><span class="line">    .<span class="title function_">catch</span>(<span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">      <span class="comment">/* 忽略错误，继续执行 */</span></span><br><span class="line">    &#125;)</span><br><span class="line">    .<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然 <code>Promise</code> 的写法比回调函数的写法大大改进，但是一眼看上去，代码完全都是 <code>Promise</code> 的 <code>API</code>，操作本身的语义反而不容易看出来。<br><br></p><p>接着是 <code>Generator</code> 函数的写法。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">chainAnimationsGenerator</span>(<span class="params">elem, animations</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">spawn</span>(<span class="keyword">function</span>* () &#123;</span><br><span class="line">    <span class="keyword">let</span> ret = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> anim <span class="keyword">of</span> animations) &#123;</span><br><span class="line">        ret = <span class="keyword">yield</span> <span class="title function_">anim</span>(elem);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="comment">/* 忽略错误，继续执行 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码使用 <code>Generator</code> 函数遍历了每个动画，语义比 <code>Promise</code> 写法更清晰，用户定义的操作全部都写在<code>spawn</code>函数的内部。但是，这个写法必须提供一个任务运行器，自动执行 <code>Generator</code> 函数，而且必须保证<code>yield</code>语句后面的表达式返回一个 <code>Promise</code>。<br><br></p><p>最后是 <code>async</code> 函数的写法。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">chainAnimationsAsync</span>(<span class="params">elem, animations</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> ret = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> anim <span class="keyword">of</span> animations) &#123;</span><br><span class="line">      ret = <span class="keyword">await</span> <span class="title function_">anim</span>(elem);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="comment">/* 忽略错误，继续执行 */</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到 <code>Async</code> 函数的实现最简洁，最符合语义。它将 <code>Generator</code> 写法中的自动执行器，改在语言层面提供，不暴露给用户，因此代码量最少。</p><hr><h3 id="20-6-按顺序完成异步操作"><a href="#20-6-按顺序完成异步操作" class="headerlink" title="20.6 按顺序完成异步操作"></a>20.6 按顺序完成异步操作</h3><p>实际开发中，会遇到一组异步操作需要按照顺序完成的情况。比如，依次远程读取一组 <code>URL</code>，然后按照读取的顺序输出结果。<br><br></p><p><code>Promise</code> 的写法如下。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">logInOrder</span>(<span class="params">urls</span>) &#123;</span><br><span class="line">  <span class="comment">// 远程读取所有URL</span></span><br><span class="line">  <span class="keyword">const</span> textPromises = urls.<span class="title function_">map</span>(<span class="function">(<span class="params">url</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">fetch</span>(url).<span class="title function_">then</span>(<span class="function">(<span class="params">response</span>) =&gt;</span> response.<span class="title function_">text</span>());</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 按次序输出</span></span><br><span class="line">  <span class="comment">// chain 代表当前的 Promise 链，初始值是 Promise.resolve()</span></span><br><span class="line">  textPromises.<span class="title function_">reduce</span>(<span class="function">(<span class="params">chain, textPromise</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 返回的是一个新的 Promise</span></span><br><span class="line">    <span class="keyword">return</span> chain</span><br><span class="line">      .<span class="title function_">then</span>(<span class="function">() =&gt;</span> textPromise) <span class="comment">// 返回当前正在处理的 textPromise</span></span><br><span class="line">      .<span class="title function_">then</span>(<span class="function">(<span class="params">text</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(text));</span><br><span class="line">  &#125;, <span class="title class_">Promise</span>.<span class="title function_">resolve</span>()); <span class="comment">// 初始化 Promise 链</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码使用<code>fetch</code>方法，同时远程读取一组 <code>URL</code>。每个<code>fetch</code>操作都返回一个 <code>Promise</code> 对象，放入<code>textPromises</code>数组。然后，<code>reduce</code>方法依次处理每个 <code>Promise</code> 对象，然后使用<code>then</code>，将所有 <code>Promise</code> 对象连起来，因此就可以依次输出结果。<br><br></p><p>这种写法可读性比较差。下面是 <code>async</code> 函数实现。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">logInOrder</span>(<span class="params">urls</span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> url <span class="keyword">of</span> urls) &#123;</span><br><span class="line">    <span class="keyword">const</span> response = <span class="keyword">await</span> <span class="title function_">fetch</span>(url);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">await</span> response.<span class="title function_">text</span>());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码确实大大简化，<ins>问题是所有远程操作都是继发。只有前一个 <code>URL</code> 返回结果，才会去读取下一个 <code>URL</code></ins>，这样做效率很差，我们需要的是并发发出远程请求。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">logInOrder</span>(<span class="params">urls</span>) &#123;</span><br><span class="line">  <span class="comment">// 并发读取远程URL</span></span><br><span class="line">  <span class="keyword">const</span> textPromises = urls.<span class="title function_">map</span>(<span class="keyword">async</span> (url) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> response = <span class="keyword">await</span> <span class="title function_">fetch</span>(url);</span><br><span class="line">    <span class="keyword">return</span> response.<span class="title function_">text</span>();</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 按次序输出</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> textPromise <span class="keyword">of</span> textPromises) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">await</span> textPromise);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>urls.map</code> 方法会对 <code>urls</code> 数组的每个元素执行一个异步函数，这个异步函数会远程读取<code>URL</code>，然后等待响应。所有的这些操作都在 <code>map</code> 方法调用的同时开始，所以这些操作是并发的。<br><br></p><p>注意，在这个异步函数中，<code>await fetch(url)</code> 会暂停函数的执行，直到 <code>fetch</code> 操作完成。但是，这并不会阻止其他操作，因为每个元素都在自己的异步函数中处理。因此，<code>textPromises</code> 是一个包含<code>Promise</code>的数组，每个<code>Promise</code>都代表一个正在进行的异步操作。</p><hr><h3 id="20-7-异步操作继发与并发"><a href="#20-7-异步操作继发与并发" class="headerlink" title="20.7 异步操作继发与并发"></a>20.7 异步操作继发与并发</h3><p>继发执行异步操作意味着等待一个操作完成后再执行下一个操作。<br><br></p><p>（1）使用 Promise 链<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>();</span><br><span class="line"></span><br><span class="line">[func1, func2, func3].<span class="title function_">forEach</span>(<span class="function">(<span class="params">func</span>) =&gt;</span> &#123;</span><br><span class="line">  promise = promise.<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="title function_">func</span>());</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise.<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;All async operations finished.&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，<code>func1</code>, <code>func2</code> 和 <code>func3</code> 是返回<code>Promise</code>的异步函数。这个代码段创建了一个<code>Promise</code>链，依次调用每个函数，并在所有函数都完成后输出一条消息。<br><br></p><p>（2）使用 Promise 链 II<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">doAsyncOperation1</span>()</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">result1</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(result1);</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">doAsyncOperation2</span>();</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">result2</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(result2);</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">doAsyncOperation3</span>();</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">result3</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(result3);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(error);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，每一个 <code>then</code> 里面返回一个新的 <code>Promise</code>，这样只有前一个 <code>Promise</code> 状态变为 <code>resolved</code>，后一个 <code>Promise</code> 才会开始执行。<br><br></p><p>（3）使用 async&#x2F;await<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">runInSequence</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="title function_">func1</span>();</span><br><span class="line">  <span class="keyword">await</span> <span class="title function_">func2</span>();</span><br><span class="line">  <span class="keyword">await</span> <span class="title function_">func3</span>();</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;All async operations finished.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">runInSequence</span>();</span><br></pre></td></tr></table></figure><p>上面代码中，<code>func1</code>, <code>func2</code> 和 <code>func3</code>也是返回<code>Promise</code>的异步函数。<code>runInSequence</code>函数使用<code>await</code>关键字依次等待每个函数完成，然后输出一条消息。<br><br></p><p>（4）使用 for…of 循环<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">runInSequence</span>(<span class="params">functions</span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> func <span class="keyword">of</span> functions) &#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">func</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;All async operations finished.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">runInSequence</span>([func1, func2, func3]);</span><br></pre></td></tr></table></figure><p>这个例子和前一个例子类似，但是<code>runInSequence</code>函数接受一个函数数组，并使用<code>for...of</code>循环来依次调用它们。<br><br></p><p>并发执行异步操作是指同时开始多个异步操作，并在它们都完成后进行下一步。<br><br></p><p>（1）使用 Promise.all()<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> promise1 = <span class="title function_">doAsyncOperation1</span>();</span><br><span class="line"><span class="keyword">let</span> promise2 = <span class="title function_">doAsyncOperation2</span>();</span><br><span class="line"><span class="keyword">let</span> promise3 = <span class="title function_">doAsyncOperation3</span>();</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">all</span>([promise1, promise2, promise3])</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">[result1, result2, result3]</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(result1, result2, result3);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(err);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，三个<code>promise</code>会同时开始，并行执行。只有当这三个操作都成功完成，<code>Promise.all()</code> 才会解决。如果任何一个操作失败，那么 <code>Promise.all()</code> 也会立即被 <code>reject</code>，不再等待其他操作。<br><br></p><p>（2）使用 Promise.allSettled()<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> promise1 = <span class="title function_">doAsyncOperation1</span>();</span><br><span class="line"><span class="keyword">let</span> promise2 = <span class="title function_">doAsyncOperation2</span>();</span><br><span class="line"><span class="keyword">let</span> promise3 = <span class="title function_">doAsyncOperation3</span>();</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">allSettled</span>([promise1, promise2, promise3]).<span class="title function_">then</span>(<span class="function">(<span class="params">results</span>) =&gt;</span> &#123;</span><br><span class="line">  results.<span class="title function_">forEach</span>(<span class="function">(<span class="params">result, index</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (result.<span class="property">status</span> === <span class="string">&quot;fulfilled&quot;</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Operation <span class="subst">$&#123;index + <span class="number">1</span>&#125;</span> succeeded with <span class="subst">$&#123;result.value&#125;</span>`</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Operation <span class="subst">$&#123;index + <span class="number">1</span>&#125;</span> failed with <span class="subst">$&#123;result.reason&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>Promise.allSettled()</code> 的行为与 <code>Promise.all()</code> 类似，但是它会等待所有操作完成，无论成功还是失败。这对于希望了解所有操作的结果，而不仅仅是第一个失败的操作很有用。<br><br></p><p>（3）使用 async&#x2F;await 结合 for..of<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> urls = [<span class="string">&quot;url1&quot;</span>, <span class="string">&quot;url2&quot;</span>, <span class="string">&quot;url3&quot;</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> requests = urls.<span class="title function_">map</span>(<span class="function">(<span class="params">url</span>) =&gt;</span> <span class="title function_">fetch</span>(url));</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> request <span class="keyword">of</span> requests) &#123;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="keyword">await</span> request;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方法可以并发启动多个异步操作，但等待结果的顺序依然是串行的。也就是说，这种方法不会阻止异步操作的启动，但会按顺序等待每个异步操作的结果。</p><hr><h3 id="20-8-顶层-await"><a href="#20-8-顶层-await" class="headerlink" title="20.8 顶层 await"></a>20.8 顶层 await</h3><p>早期的语法规定，<code>await</code>命令只能出现在 <code>async</code> 函数内部，否则报错。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">const</span> data = <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="string">&quot;https://api.example.com&quot;</span>);</span><br></pre></td></tr></table></figure><p>上面代码中，<code>await</code>命令独立使用，没有放在 <code>async</code> 函数里面，就会报错。<br><br></p><p>从 <a href="https://github.com/tc39/proposal-top-level-await">ES6</a> 开始，允许在模块的顶层独立使用<code>await</code>命令，使得上面那行代码不会报错了。它的主要目的是使用<code>await</code>解决模块异步加载的问题。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// awaiting.js</span></span><br><span class="line"><span class="keyword">let</span> output;</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> dynamic = <span class="keyword">await</span> <span class="keyword">import</span>(someMission);</span><br><span class="line">  <span class="keyword">const</span> data = <span class="keyword">await</span> <span class="title function_">fetch</span>(url);</span><br><span class="line">  output = <span class="title function_">someProcess</span>(dynamic.<span class="property">default</span>, data);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">main</span>();</span><br><span class="line"><span class="keyword">export</span> &#123; output &#125;;</span><br></pre></td></tr></table></figure><p>上面代码中，模块<code>awaiting.js</code>的输出值<code>output</code>，取决于异步操作。我们把异步操作包装在一个 <code>async</code> 函数里面，然后调用这个函数，只有等里面的异步操作都执行，变量<code>output</code>才会有值，否则就返回<code>undefined</code>。<br><br></p><p>下面是加载这个模块的写法。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// usage.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; output &#125; <span class="keyword">from</span> <span class="string">&quot;./awaiting.js&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">outputPlusValue</span>(<span class="params">value</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> output + value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">outputPlusValue</span>(<span class="number">100</span>));</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">outputPlusValue</span>(<span class="number">100</span>)), <span class="number">1000</span>);</span><br></pre></td></tr></table></figure><p>上面代码中，<ins><code>outputPlusValue()</code>的执行结果，完全取决于执行的时间。如果<code>awaiting.js</code>里面的异步操作没执行完，加载进来的<code>output</code>的值就是<code>undefined</code></ins>。<br><br></p><p>目前的解决方法，就是让原始模块输出一个 <code>Promise</code> 对象，从这个 <code>Promise</code> 对象判断异步操作有没有结束（检查当前状态是否为<code>resolved</code>，即使用<code>then</code>的回调函数）。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// awaiting.js</span></span><br><span class="line"><span class="keyword">let</span> output;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> (<span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> dynamic = <span class="keyword">await</span> <span class="keyword">import</span>(someMission);</span><br><span class="line">  <span class="keyword">const</span> data = <span class="keyword">await</span> <span class="title function_">fetch</span>(url);</span><br><span class="line">  output = <span class="title function_">someProcess</span>(dynamic.<span class="property">default</span>, data);</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="keyword">export</span> &#123; output &#125;;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>awaiting.js</code>除了输出<code>output</code>，还默认输出一个 <code>Promise</code> 对象（<code>async</code> 函数立即执行后，返回一个 <code>Promise</code> 对象），从这个对象判断异步操作是否结束。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// usage.js</span></span><br><span class="line"><span class="keyword">import</span> promise, &#123; output &#125; <span class="keyword">from</span> <span class="string">&quot;./awaiting.js&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">outputPlusValue</span>(<span class="params">value</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> output + value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">promise.<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">outputPlusValue</span>(<span class="number">100</span>));</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">outputPlusValue</span>(<span class="number">100</span>)), <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，将<code>awaiting.js</code>对象的输出，放在<code>promise.then()</code>里面，这样就能保证异步操作完成以后，才去读取<code>output</code>。<br><br></p><p>这种写法比较麻烦，<ins>等于要求模块的使用者遵守一个额外的使用协议</ins>，按照特殊的方法使用这个模块。一旦忘记使用 <code>Promise</code> 加载，这个模块的代码就可能出错。<br><br></p><p><ins>顶层的<code>await</code>命令，就是为了解决这个问题。它保证只有异步操作完成，模块才会输出值</ins>。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// awaiting.js</span></span><br><span class="line"><span class="keyword">const</span> dynamic = <span class="keyword">import</span>(someMission);</span><br><span class="line"><span class="keyword">const</span> data = <span class="title function_">fetch</span>(url);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> output = <span class="title function_">someProcess</span>((<span class="keyword">await</span> dynamic).<span class="property">default</span>, <span class="keyword">await</span> data);</span><br></pre></td></tr></table></figure><p>上面代码中，<ins>两个异步操作在输出的时候，都加上了<code>await</code>命令。只有等到异步操作完成，这个模块才会输出值</ins>。加载这个模块的写法如下。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// usage.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; output &#125; <span class="keyword">from</span> <span class="string">&quot;./awaiting.js&quot;</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">outputPlusValue</span>(<span class="params">value</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> output + value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">outputPlusValue</span>(<span class="number">100</span>));</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">outputPlusValue</span>(<span class="number">100</span>)), <span class="number">1000</span>);</span><br></pre></td></tr></table></figure><p>上面代码的写法，与普通的模块加载完全一样。也就是说，模块的使用者完全不用关心，依赖模块的内部有没有异步操作，正常加载即可。<br><br></p><p>这时，模块的加载会等待依赖模块的异步操作完成，才执行后面的代码。所以，它总是会得到正确的<code>output</code>，不会因为加载时机的不同，而得到不一样的值。<br><br></p><p>注意，顶层<code>await</code>只能用在 <code>ES6</code> 模块。</p><hr><h2 id="21-Class-的基本语法"><a href="#21-Class-的基本语法" class="headerlink" title="21. Class 的基本语法"></a>21. Class 的基本语法</h2><h3 id="21-1-类的由来"><a href="#21-1-类的由来" class="headerlink" title="21.1 类的由来"></a>21.1 类的由来</h3><p>在<code>JS</code>中，生成实例对象的传统方法是通过构造函数。下面是一个例子。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Point</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">x</span> = x;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">y</span> = y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Point</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;(&quot;</span> + <span class="variable language_">this</span>.<span class="property">x</span> + <span class="string">&quot;, &quot;</span> + <span class="variable language_">this</span>.<span class="property">y</span> + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="title class_">Point</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>上面这种写法跟传统的面向对象语言（比如 <code>C++</code> 和 <code>Java</code>）差异很大，很容易感到困惑。<br><code>ES6</code> 引入了 <code>Class</code>（类）这个概念。通过<code>class</code>关键字，可以定义类。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">x</span> = x;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">y</span> = y;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">toString</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;(&quot;</span> + <span class="variable language_">this</span>.<span class="property">x</span> + <span class="string">&quot;, &quot;</span> + <span class="variable language_">this</span>.<span class="property">y</span> + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码定义了一个“类”，<ins>可以看到里面有一个<code>constructor()</code>方法，这就是构造方法，而<code>this</code>关键字则代表实例对象</ins>。新的<code>class</code>写法让对象原型的写法更加清晰、更像面向对象编程。<br><br></p><p><code>Point</code>类除了构造方法，还定义了一个<code>toString()</code>方法。注意，定义<code>toString()</code>方法的时候，前面不需要加上<code>function</code>这个关键字，直接把函数定义放进去了就可以了。<br><br></p><p>使用的时候，也是直接对类使用<code>new</code>命令，跟构造函数的用法完全一致。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">x</span> = x;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">y</span> = y;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">toString</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;(&quot;</span> + <span class="variable language_">this</span>.<span class="property">x</span> + <span class="string">&quot;, &quot;</span> + <span class="variable language_">this</span>.<span class="property">y</span> + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> point = <span class="keyword">new</span> <span class="title class_">Point</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">point.<span class="title function_">toString</span>();</span><br></pre></td></tr></table></figure><p>事实上，类的所有方法都定义在类的<code>prototype</code>属性上面（也称为原型对象）。因此，在类的实例上面调用方法，其实就是调用原型上的方法。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Car</span>(<span class="params">make, model, year</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">make</span> = make;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">model</span> = model;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">year</span> = year;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Car</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">start</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">make</span> + <span class="string">&quot; &quot;</span> + <span class="variable language_">this</span>.<span class="property">model</span> + <span class="string">&quot; engine started.&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> car1 = <span class="keyword">new</span> <span class="title class_">Car</span>(<span class="string">&quot;Eagle&quot;</span>, <span class="string">&quot;Talon TSi&quot;</span>, <span class="number">1993</span>);</span><br><span class="line">car1.<span class="title function_">start</span>(); <span class="comment">// 输出：&quot;Eagle Talon TSi engine started.&quot;</span></span><br></pre></td></tr></table></figure><p>由于类的方法都定义在<code>prototype</code>对象上面，所以类的新方法可以添加在<code>prototype</code>对象上面。<code>Object.assign()</code>方法可以很方便地一次向类添加多个方法。（<code>class</code> 直接添加就行）<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Car</span>(<span class="params">make, model, year</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">make</span> = make;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">model</span> = model;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">year</span> = year;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">assign</span>(<span class="title class_">Car</span>.<span class="property"><span class="keyword">prototype</span></span>, &#123;</span><br><span class="line">  <span class="attr">start</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">make</span> + <span class="string">&quot; &quot;</span> + <span class="variable language_">this</span>.<span class="property">model</span> + <span class="string">&quot; engine started.&quot;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">stop</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">make</span> + <span class="string">&quot; &quot;</span> + <span class="variable language_">this</span>.<span class="property">model</span> + <span class="string">&quot; engine stopped.&quot;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> car1 = <span class="keyword">new</span> <span class="title class_">Car</span>(<span class="string">&quot;Eagle&quot;</span>, <span class="string">&quot;Talon TSi&quot;</span>, <span class="number">1993</span>);</span><br><span class="line">car1.<span class="title function_">start</span>(); <span class="comment">// 输出：&quot;Eagle Talon TSi engine started.&quot;</span></span><br><span class="line">car1.<span class="title function_">stop</span>(); <span class="comment">// 输出：&quot;Eagle Talon TSi engine stopped.&quot;</span></span><br></pre></td></tr></table></figure><p>在<code>JS</code>中，每一个函数（包括类，因为在<code>JS</code>中类也是函数）都有一个<code>prototype</code>属性，它是一个对象，这个对象有一个<code>constructor</code>属性，默认指向函数本身。也就是说，<code>prototype</code>对象的 <code>constructor</code>属性直接指向“类”的本身。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">make, model, year</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">make</span> = make;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">model</span> = model;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">year</span> = year;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Car</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> === <span class="title class_">Car</span>); <span class="comment">// 输出：true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> car = <span class="keyword">new</span> <span class="title class_">Car</span>(<span class="string">&quot;Eagle&quot;</span>, <span class="string">&quot;Talon TSi&quot;</span>, <span class="number">1993</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(car.<span class="property">constructor</span> === <span class="title class_">Car</span>); <span class="comment">// 输出：true</span></span><br></pre></td></tr></table></figure><hr><h3 id="21-2-constructor-方法"><a href="#21-2-constructor-方法" class="headerlink" title="21.2 constructor 方法"></a>21.2 constructor 方法</h3><p><code>constructor()</code>方法是类的默认方法，<ins>通过<code>new</code>命令生成对象实例时，自动调用该方法</ins>。一个类必须有<code>constructor()</code>方法，如果没有显式定义，一个空的<code>constructor()</code>方法会被默认添加。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果想在创建对象时进行一些初始化操作，比如设置对象的属性，那么需要显式定义你自己的 <code>constructor()</code>方法。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">make, model, year</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">make</span> = make;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">model</span> = model;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">year</span> = year;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">start</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">make</span> + <span class="string">&quot; &quot;</span> + <span class="variable language_">this</span>.<span class="property">model</span> + <span class="string">&quot; engine started.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> car = <span class="keyword">new</span> <span class="title class_">Car</span>(<span class="string">&quot;Eagle&quot;</span>, <span class="string">&quot;Talon TSi&quot;</span>, <span class="number">1993</span>);</span><br><span class="line">car.<span class="title function_">start</span>(); <span class="comment">// 输出：&quot;Eagle Talon TSi engine started.&quot;</span></span><br></pre></td></tr></table></figure><p><code>constructor()</code>方法默认返回实例对象（即<code>this</code>），但完全可以指定返回另外一个对象。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">make, model, year</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">make</span> = make;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">model</span> = model;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">year</span> = year;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个新对象，并返回它</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">make</span>: <span class="string">&quot;Ford&quot;</span>,</span><br><span class="line">      <span class="attr">model</span>: <span class="string">&quot;F-150&quot;</span>,</span><br><span class="line">      <span class="attr">year</span>: <span class="number">2020</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> car = <span class="keyword">new</span> <span class="title class_">Car</span>(<span class="string">&quot;Eagle&quot;</span>, <span class="string">&quot;Talon TSi&quot;</span>, <span class="number">1993</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(car.<span class="property">make</span>); <span class="comment">// 输出：&quot;Ford&quot;</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>constructor()</code>方法返回了一个完全不同的对象。因此，当我们打印<code>car.make</code>时，输出的是<code>&#39;Ford&#39;</code>而不是<code>&#39;Eagle&#39;</code>。</p><hr><h3 id="21-3-类的实例"><a href="#21-3-类的实例" class="headerlink" title="21.3 类的实例"></a>21.3 类的实例</h3><p>生成类的实例的写法，与<code>ES5</code>完全一样，也是使用<code>new</code>命令。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">let</span> point = <span class="title class_">Point</span>(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">let</span> point = <span class="keyword">new</span> <span class="title class_">Point</span>(<span class="number">2</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure><p><ins>类的属性和方法，除非显式定义在其本身（即定义在<code>this</code>对象上，通过实例访问），否则都是定义在原型上（即定义在<code>class</code>上，静态属性或者静态方法）</ins>。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">make, model, year</span>) &#123;</span><br><span class="line">    <span class="comment">// 实例属性</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">make</span> = make;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">model</span> = model;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">year</span> = year;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 原型方法</span></span><br><span class="line">  <span class="title function_">start</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">make</span> + <span class="string">&quot; &quot;</span> + <span class="variable language_">this</span>.<span class="property">model</span> + <span class="string">&quot; engine started.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 静态方法</span></span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">isCar</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> obj <span class="keyword">instanceof</span> <span class="title class_">Car</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态属性</span></span><br><span class="line"><span class="title class_">Car</span>.<span class="property">manu</span> = <span class="string">&quot;Unknown&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> car = <span class="keyword">new</span> <span class="title class_">Car</span>(<span class="string">&quot;Eagle&quot;</span>, <span class="string">&quot;Talon TSi&quot;</span>, <span class="number">1993</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(car.<span class="property">make</span>); <span class="comment">// 输出：&quot;Eagle&quot;</span></span><br><span class="line">car.<span class="title function_">start</span>(); <span class="comment">// 输出：&quot;Eagle Talon TSi engine started.&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Car</span>.<span class="title function_">isCar</span>(car)); <span class="comment">// 输出：true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Car</span>.<span class="property">manu</span>); <span class="comment">// 输出：&quot;Unknown&quot;</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>make</code>、<code>model</code>和<code>year</code>是实例属性，<code>start</code>是原型方法，<code>isCar</code>是静态方法，<code>manu</code>是静态属性。可以看到，<code>make</code>和<code>start</code>可以通过实例<code>car</code>访问，而<code>isCar</code>和<code>manu</code>只能通过类名<code>Car</code>访问。<br><br></p><p>与<code>ES5</code>一样，<ins>类的所有实例共享一个原型对象</ins>。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="title class_">Point</span>(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="title class_">Point</span>(<span class="number">3</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">p1.<span class="property">__proto__</span> === p2.<span class="property">__proto__</span>;</span><br><span class="line"><span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>p1</code>和<code>p2</code>都是<code>Point</code>的实例，它们的原型都是<code>Point.prototype</code>，所以<code>__proto__</code>属性是相等的。这也意味着，可以通过实例的<code>__proto__</code>属性为“类”添加方法。<br><br></p><p>然而，使用 <code>__proto__</code> 通常是不推荐的，因为这并不是语言的一个标准特性，而且在不同的 <code>JS</code> 环境中可能表现不同。更好的方式是直接使用 <code>Object.getPrototypeOf(obj)</code> 函数获取一个对象的原型，或者使用 <code>Object.setPrototypeOf(obj, prototype)</code> 函数设置一个对象的原型。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="title class_">Point</span>(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="title class_">Point</span>(<span class="number">3</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">p1.<span class="property">__proto__</span>.<span class="property">printName</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;Oops&quot;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">p1.<span class="title function_">printName</span>(); <span class="comment">// &quot;Oops&quot;</span></span><br><span class="line">p2.<span class="title function_">printName</span>(); <span class="comment">// &quot;Oops&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p3 = <span class="keyword">new</span> <span class="title class_">Point</span>(<span class="number">4</span>, <span class="number">2</span>);</span><br><span class="line">p3.<span class="title function_">printName</span>(); <span class="comment">// &quot;Oops&quot;</span></span><br></pre></td></tr></table></figure><p>上面代码在<code>p1</code>的原型上添加了一个<code>printName()</code>方法，由于<code>p1</code>的原型就是<code>p2</code>的原型，因此<code>p2</code>也可以调用这个方法。而且，此后新建的实例<code>p3</code>也可以调用这个方法。<ins>这意味着，使用实例的<code>__proto__</code>属性改写原型，必须相当谨慎，不推荐使用，因为这会改变“类”的原始定义，影响到所有实例</ins>。</p><hr><h3 id="21-4-实例属性的新写法"><a href="#21-4-实例属性的新写法" class="headerlink" title="21.4 实例属性的新写法"></a>21.4 实例属性的新写法</h3><p><a href="https://github.com/tc39/proposal-class-fields">ES6</a> 为类的实例属性，又规定了一种新写法。实例属性现在除了可以定义在<code>constructor()</code>方法里面的<code>this</code>上面，<ins>也可以定义在类内部的最顶层</ins>。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 原来的写法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IncreasingCounter</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_count</span> = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">value</span>() &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Getting the current value!&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_count</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">increment</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_count</span>++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面示例中，实例属性<code>_count</code>定义在<code>constructor()</code>方法里面的<code>this</code>上面。现在的新写法是，这个属性也可以定义在类的最顶层，其他都不变。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">IncreasingCounter</span> &#123;</span><br><span class="line">  _count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">value</span>() &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Getting the current value!&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_count</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">increment</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_count</span>++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，实例属性<code>_count</code>与取值函数<code>value()</code>和<code>increment()</code>方法，处于同一个层级。这时，不需要在实例属性前面加上<code>this</code>。<br><br></p><p>注意，<ins>新写法定义的属性是实例对象自身的属性，而不是定义在实例对象的原型<code>prototype</code>上面</ins>。因为如果原型变了，比如这里的<code>_count</code>我们做计数处理，那么所有实例的<code>_count</code>属性都会改变，这就会出现与我们预期不同的结果。<br><br></p><p>这种新写法的好处是，所有实例对象自身的属性都定义在类的头部，看上去比较整齐，一眼就能看出这个类有哪些实例属性。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">foo</span> &#123;</span><br><span class="line">  bar = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">  baz = <span class="string">&quot;world&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码，<code>foo</code>类有两个实例属性，一目了然。另外，写起来也比较简洁。</p><hr><h3 id="21-5-取值函数-getter-和存值函数-setter"><a href="#21-5-取值函数-getter-和存值函数-setter" class="headerlink" title="21.5 取值函数 getter 和存值函数 setter"></a>21.5 取值函数 getter 和存值函数 setter</h3><p>与<code>ES5</code>一样，<ins>在“类”的内部可以使用<code>get</code>和<code>set</code>关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为</ins>。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_myProperty</span> = <span class="string">&quot;Default value&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Getter</span></span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">myProperty</span>() &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Getting myProperty&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_myProperty</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Setter</span></span><br><span class="line">  <span class="keyword">set</span> <span class="title function_">myProperty</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Setting myProperty&quot;</span>);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_myProperty</span> = value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">myProperty</span>); <span class="comment">// 输出：&quot;Getting myProperty&quot; 和 &quot;Default value&quot;</span></span><br><span class="line">obj.<span class="property">myProperty</span> = <span class="string">&quot;New value&quot;</span>; <span class="comment">// 输出：&quot;Setting myProperty&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">myProperty</span>); <span class="comment">// 输出：&quot;Getting myProperty&quot; 和 &quot;New value&quot;</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>myProperty</code>属性有对应的存值函数和取值函数，因此赋值和读取行为都被自定义了。注意，<ins>存值函数和取值函数是设置在属性的 <code>Descriptor</code> 对象上的</ins>。</p><hr><h3 id="21-6-Class-表达式"><a href="#21-6-Class-表达式" class="headerlink" title="21.6 Class 表达式"></a>21.6 Class 表达式</h3><p>与函数一样，类也可以使用表达式的形式定义。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 命名类表达式</span></span><br><span class="line"><span class="keyword">let</span> <span class="title class_">User</span> = <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">sayHello</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hello, my name is <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> user = <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Alice&quot;</span>);</span><br><span class="line">user.<span class="title function_">sayHello</span>(); <span class="comment">// 输出 &quot;Hello, my name is Alice&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">MyClass</span>); <span class="comment">// 报错，MyClass 在类外部不可用</span></span><br></pre></td></tr></table></figure><p>上面代码使用表达式定义了一个类。<ins>需要注意的是，这个类的名字是<code>MyClass</code>，但是<code>MyClass</code>只在 <code>Class</code> 的内部可用，指代当前类。在 <code>Class</code> 外部，这个类只能用<code>User</code>引用</ins>。<br><br></p><p>如果类的内部没用到的话，可以省略<code>MyClass</code>，也就是可以写成下面的形式。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 匿名类表达式</span></span><br><span class="line"><span class="keyword">let</span> <span class="title class_">User</span> = <span class="keyword">class</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">sayHello</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hello, my name is <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> user = <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Alice&quot;</span>);</span><br><span class="line">user.<span class="title function_">sayHello</span>(); <span class="comment">// 输出 &quot;Hello, my name is Alice&quot;</span></span><br></pre></td></tr></table></figure><p>采用 <code>Class</code> 表达式，可以写出立即执行的 <code>Class</code>。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user = <span class="keyword">new</span> (<span class="keyword">class</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">sayHello</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hello, my name is <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)(<span class="string">&quot;Alice&quot;</span>);</span><br><span class="line"></span><br><span class="line">user.<span class="title function_">sayHello</span>(); <span class="comment">// 输出 &quot;Hello, my name is Alice&quot;</span></span><br></pre></td></tr></table></figure><hr><h3 id="21-7-静态方法"><a href="#21-7-静态方法" class="headerlink" title="21.7 静态方法"></a>21.7 静态方法</h3><p>类相当于实例的原型，所有在类中定义的方法都会被实例继承。<ins>如果在一个方法前，加上<code>static</code>关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”</ins>。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">classMethod</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Foo</span>.<span class="title function_">classMethod</span>(); <span class="comment">// &#x27;hello&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> foo = <span class="keyword">new</span> <span class="title class_">Foo</span>();</span><br><span class="line">foo.<span class="title function_">classMethod</span>();</span><br><span class="line"><span class="comment">// TypeError: foo.classMethod is not a function</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>Foo</code>类的<code>classMethod</code>方法前有<code>static</code>关键字，表明该方法是一个静态方法，可以直接在<code>Foo</code>类上调用，而不是在<code>Foo</code>类的实例上调用。如果在实例上调用静态方法，会抛出一个错误，表示不存在该方法。<br><br></p><p>注意，<ins>如果静态方法包含<code>this</code>关键字，这个<code>this</code>指的是类，而不是实例</ins>。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">myStaticMethod</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">myInstanceMethod</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">MyClass</span>.<span class="title function_">myStaticMethod</span>(); <span class="comment">// 输出 MyClass [Function: MyClass]，this 指向类</span></span><br><span class="line"><span class="keyword">let</span> instance = <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line">instance.<span class="title function_">myInstanceMethod</span>(); <span class="comment">// 输出 MyClass &#123;&#125;，this 指向实例</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>myStaticMethod</code>是<code>MyClass</code>的静态方法，<code>this</code>指向的是类<code>MyClass</code>。<code>myInstanceMethod</code>是实例方法，<code>this</code>指向的是类的实例。另外，从这个例子还可以看出，<ins>静态方法可以与非静态方法重名</ins>。<br><br></p><p><ins>父类的静态方法，可以被子类继承</ins>。同时，<ins>静态方法也是可以从<code>super</code>对象上调用的</ins>。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ParentClass</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">greeting</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello from ParentClass&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ChildClass</span> <span class="keyword">extends</span> <span class="title class_ inherited__">ParentClass</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">ChildClass</span>.<span class="title function_">greeting</span>(); <span class="comment">// 输出 &quot;Hello from ParentClass&quot;</span></span><br><span class="line"></span><br><span class="line">-----------------------------------------</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ParentClass</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">greeting</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello from ParentClass&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ChildClass</span> <span class="keyword">extends</span> <span class="title class_ inherited__">ParentClass</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">greeting</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>.<span class="title function_">greeting</span>();</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello from ChildClass&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">ChildClass</span>.<span class="title function_">greeting</span>();</span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// &quot;Hello from ParentClass&quot;</span></span><br><span class="line"><span class="comment">// &quot;Hello from ChildClass&quot;</span></span><br></pre></td></tr></table></figure><hr><h3 id="21-8-私有方法和私有属性"><a href="#21-8-私有方法和私有属性" class="headerlink" title="21.8 私有方法和私有属性"></a>21.8 私有方法和私有属性</h3><p><a href="https://github.com/tc39/proposal-class-fields">ES6</a>为<code>class</code>添加了私有属性，<ins>方法是在属性名之前使用<code>#</code>表示</ins>。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">IncreasingCounter</span> &#123;</span><br><span class="line">  #count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">value</span>() &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Getting the current value!&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.#count;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">increment</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.#count++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> counter = <span class="keyword">new</span> <span class="title class_">IncreasingCounter</span>();</span><br><span class="line">counter.#count; <span class="comment">// 报错</span></span><br><span class="line">counter.#count = <span class="number">42</span>; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>#count</code>就是私有属性，只能在类的内部使用（<code>this.#count</code>）。如果在类的外部使用，就会报错。<br><br></p><p>另外，<ins>不管在类的内部或外部，读取一个不存在的私有属性，都会报错</ins>。这跟公开属性的行为完全不同，如果读取一个不存在的公开属性，不会报错，只会返回<code>undefined</code>。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">IncreasingCounter</span> &#123;</span><br><span class="line">  #count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">value</span>() &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Getting the current value!&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.#myCount; <span class="comment">// 报错</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">increment</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.#count++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> counter = <span class="keyword">new</span> <span class="title class_">IncreasingCounter</span>();</span><br><span class="line">counter.#myCount; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><p>上面示例中，<code>#myCount</code>是一个不存在的私有属性，不管在函数内部或外部，读取该属性都会导致报错。注意，私有属性的属性名必须包括<code>#</code>，如果不带<code>#</code>，会被当作另一个属性。<br><br></p><p><code>ES6</code>中<ins>不仅可以写私有属性，还可以用来写私有方法</ins>。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">  #a;</span><br><span class="line">  #b;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.#a = a;</span><br><span class="line">    <span class="variable language_">this</span>.#b = b;</span><br><span class="line">  &#125;</span><br><span class="line">  #<span class="title function_">sum</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.#a + <span class="variable language_">this</span>.#b;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">printSum</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.#<span class="title function_">sum</span>());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外，<ins>私有属性也可以设置 <code>getter</code> 和 <code>setter</code> 方法</ins>。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">  #xValue = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.#x);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  get #<span class="title function_">x</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.#xValue;</span><br><span class="line">  &#125;</span><br><span class="line">  set #<span class="title function_">x</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.#xValue = value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>#x</code>是一个私有属性，它的读写都通过<code>get #x()</code>和<code>set #x()</code>操作另一个私有属性<code>#xValue</code>来完成。<br><br></p><p><ins>私有属性不限于从<code>this</code>引用，只要是在类的内部，实例也可以引用私有属性</ins>。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">  #privateProperty = <span class="string">&quot;I&#x27;m private&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">checkPrivateProperty</span>(<span class="params">otherInstance</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> otherInstance.#privateProperty;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> instance1 = <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line"><span class="keyword">const</span> instance2 = <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(instance1.<span class="title function_">checkPrivateProperty</span>(instance2));</span><br><span class="line"><span class="comment">// 输出 &quot;I&#x27;m private&quot;</span></span><br></pre></td></tr></table></figure><p><ins>私有属性和私有方法也可以加上<code>static</code>关键字，表示这是一个静态的私有属性或私有方法</ins>。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> #<span class="title function_">privateStaticMethod</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Hello from private static method&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">callPrivateStaticMethod</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.#<span class="title function_">privateStaticMethod</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">MyClass</span>.<span class="title function_">callPrivateStaticMethod</span>());</span><br><span class="line"><span class="comment">// 输出 &quot;Hello from private static method&quot;</span></span><br></pre></td></tr></table></figure><hr><h3 id="21-9-in-运算符"><a href="#21-9-in-运算符" class="headerlink" title="21.9 in 运算符"></a>21.9 in 运算符</h3><p>前面说过，<ins>直接访问某个类不存在的私有属性会报错，但是访问不存在的公开属性不会报错。这个特性可以用来判断，某个对象是否为类的实例</ins>。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line">  #brand;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">isC</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      obj.#brand;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面示例中，类<code>C</code>的静态方法<code>isC()</code>就用来判断，某个对象是否为<code>C</code>的实例。它采用的方法就是，访问该对象的私有属性<code>#brand</code>。如果不报错，就会返回<code>true</code>；如果报错，就说明该对象不是当前类的实例，从而<code>catch</code>部分返回<code>false</code>。<br><br></p><p>因此，<code>try...catch</code>结构可以用来判断某个私有属性是否存在。但是，这样的写法很麻烦，代码可读性很差，<a href="https://github.com/tc39/proposal-private-fields-in-in">ES6</a> 改进了<ins><code>in</code>运算符，使它也可以用来判断私有属性。它不会报错，而是返回一个布尔值</ins>。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line">  #brand;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">isC</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (#brand <span class="keyword">in</span> obj) &#123;</span><br><span class="line">      <span class="comment">// 私有属性 #brand 存在</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 私有属性 #foo 不存在</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>in</code>也可以跟<code>this</code>一起配合使用，用来检查一个对象是否拥有某个属性的，无论这个属性是在实例本身还是在它的原型链中。注意，<ins>判断私有属性时，<code>in</code>只能用在类的内部</ins>。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  #foo = <span class="number">0</span>;</span><br><span class="line">  <span class="title function_">m</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(#foo <span class="keyword">in</span> <span class="variable language_">this</span>); <span class="comment">// true</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(#bar <span class="keyword">in</span> <span class="variable language_">this</span>); <span class="comment">// false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="21-10-静态块"><a href="#21-10-静态块" class="headerlink" title="21.10 静态块"></a>21.10 静态块</h3><p>静态属性的一个问题是，如果它有初始化逻辑，这个逻辑要么写在类的外部，要么写在<code>constructor()</code>方法里面。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">MyClass</span>.<span class="property">myStaticProperty</span> = <span class="string">&quot;some value&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="title class_">MyClass</span>.<span class="property">myStaticProperty</span>) &#123;</span><br><span class="line">      <span class="title class_">MyClass</span>.<span class="property">myStaticProperty</span> = <span class="string">&quot;some value&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了解决这个问题，<code>ES2022</code> 引入了<a href="https://github.com/tc39/proposal-class-static-block">静态块</a>（<code>static block</code>），允许在类的内部设置一个代码块，<ins>在类生成时运行且只运行一次，主要作用是对静态属性进行初始化</ins>。以后，<ins>新建类的实例时，这个块就不运行了</ins>。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> a;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">a</span> = <span class="title function_">doSomethingThatMightFail</span>();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">a</span> = <span class="string">&quot;default value&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个类允许有多个静态块，每个静态块中只能访问之前声明的静态属性。同时，静态块的内部不能有<code>return</code>语句，但是可以使用类名或<code>this</code>，指代当前类。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> prop1;</span><br><span class="line">  <span class="keyword">static</span> prop2;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="comment">// 第一个静态块</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">prop1</span> = <span class="string">&quot;value1&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="comment">// 第二个静态块</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">prop2</span> = <span class="variable language_">this</span>.<span class="property">prop1</span> + <span class="string">&quot; value2&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">MyClass</span>.<span class="property">prop1</span>); <span class="comment">// 输出 &quot;value1&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">MyClass</span>.<span class="property">prop2</span>); <span class="comment">// 输出 &quot;value1 value2&quot;</span></span><br></pre></td></tr></table></figure><p>除了静态属性的初始化，静态块还有一个作用，就是<ins>将私有属性与类的外部代码分享</ins>。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">  <span class="comment">// 私有属性</span></span><br><span class="line">  <span class="keyword">static</span> #privateProp = <span class="string">&quot;private value&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="comment">// 在静态块中定义公开方法</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">getPrivateProp</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title class_">MyClass</span>.#privateProp;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">MyClass</span>.<span class="title function_">getPrivateProp</span>()); <span class="comment">// 输出 &quot;private value&quot;</span></span><br></pre></td></tr></table></figure><p>这个特性提供了一种灵活的方式来控制类的私有属性的访问，可以根据需要决定哪些私有属性应该对外部代码开放，以及在何种条件下开放。</p><hr><h3 id="21-11-类的注意点"><a href="#21-11-类的注意点" class="headerlink" title="21.11 类的注意点"></a>21.11 类的注意点</h3><p><strong>（1）Generator 方法</strong></p><p>如果某个方法之前加上星号<code>*</code>，就表示该方法是一个 <code>Generator</code> 函数。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">lass <span class="title class_">MyClass</span> &#123;</span><br><span class="line">  * <span class="title function_">generatorMethod</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&#x27;Hello,&#x27;</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&#x27;world!&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> myInstance = <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line"><span class="keyword">const</span> gen = myInstance.<span class="title function_">generatorMethod</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(gen.<span class="title function_">next</span>().<span class="property">value</span>); <span class="comment">// 输出 &quot;Hello,&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(gen.<span class="title function_">next</span>().<span class="property">value</span>); <span class="comment">// 输出 &quot;world!&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(gen.<span class="title function_">next</span>().<span class="property">value</span>); <span class="comment">// 输出 undefined</span></span><br></pre></td></tr></table></figure><p><strong>（2）this 的指向</strong></p><p>类的方法内部如果含有<code>this</code>，它默认指向类的实例。但是，如果将类的方法提取出来单独使用，那么<code>this</code>可能就不再指向原来的对象了。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">  <span class="title function_">myMethod</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> myInstance = <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line">myInstance.<span class="title function_">myMethod</span>(); <span class="comment">// MyClass的实例</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; method &#125; = myInstance;</span><br><span class="line"><span class="title function_">method</span>(); <span class="comment">// undefined或者全局对象（在非严格模式下）</span></span><br></pre></td></tr></table></figure><p>在上述代码中，<code>myMethod</code>方法中的<code>this</code>默认指向<code>MyClass</code>的实例。但当我们将<code>myMethod</code>方法赋值给变量<code>method</code>，并单独调用<code>method()</code>时，<code>this</code>就变成了<code>undefined</code>。<br><br></p><p>解决方法是，<ins>在构造方法中绑定<code>this</code></ins>，或者使用箭头函数。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">myMethod</span> = <span class="variable language_">this</span>.<span class="property">myMethod</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">myMethod</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">  myMethod = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="22-Class-的继承"><a href="#22-Class-的继承" class="headerlink" title="22. Class 的继承"></a>22. Class 的继承</h2><p><a href="https://es6.ruanyifeng.com/#docs/class-extends">本章</a>内容复杂，故先跳过一部分。</p><h3 id="22-1-简介"><a href="#22-1-简介" class="headerlink" title="22.1 简介"></a>22.1 简介</h3><p><ins><code>Class</code> 可以通过<code>extends</code>关键字实现继承，让子类继承父类的属性和方法</ins>。<code>extends</code> 的写法比 <code>ES5</code> 的原型链继承，要清晰和方便很多。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ColorPoint</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Point</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>上面示例中，<ins><code>Point</code>是父类，<code>ColorPoint</code>是子类，它通过<code>extends</code>关键字，继承了<code>Point</code>类的所有属性和方法</ins>。下面，我们在<code>ColorPoint</code>内部加上代码。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ColorPoint</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Point</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">x, y, color</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(x, y); <span class="comment">// 调用父类的 constructor(x, y)</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">color</span> = color;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">toString</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">color</span> + <span class="string">&quot; &quot;</span> + <span class="variable language_">super</span>.<span class="title function_">toString</span>(); <span class="comment">// 调用父类的 toString()</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面示例中，<code>constructor()</code>方法和<code>toString()</code>方法内部，都出现了<code>super</code>关键字。<ins><code>super</code>在这里表示父类的构造函数，用来新建一个父类的实例对象</ins>。<br><br></p><p><code>ES6</code> 规定，<ins>子类必须在<code>constructor()</code>方法中调用<code>super()</code></ins>，否则就会报错。这是因为子类自己的<code>this</code>对象，必须先通过父类的构造函数完成塑造，得到与父类同样的实例属性和方法，然后再添加子类自己的实例属性和方法。如果不调用<code>super()</code>方法，子类就得不到自己的<code>this</code>对象。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ColorPoint</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Point</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> cp = <span class="keyword">new</span> <span class="title class_">ColorPoint</span>(); <span class="comment">// ReferenceError</span></span><br></pre></td></tr></table></figure><p>为什么子类的构造函数，一定要调用<code>super()</code>？原因就在于 <code>ES6</code> 的继承机制，与 <code>ES5</code> 完全不同。</p><ul><li><code>ES5</code> 的继承机制，是先创造一个独立的子类的实例对象，然后再将父类的方法添加到这个对象上面，即“实例在前，继承在后”。</li><li><code>ES6</code> 的继承机制，则是先将父类的属性和方法，加到一个空的对象上面，然后再将该对象作为子类的实例，即“继承在前，实例在后”。</li></ul><p>这就是为什么 <code>ES6</code> 的继承必须先调用<code>super()</code>方法，因为这一步会生成一个继承父类的<code>this</code>对象，没有这一步就无法继承父类。<br><br></p><p>注意，这意味着<ins>新建子类实例时，父类的构造函数必定会先运行一次</ins>。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bar</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Foo</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>();</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> bar = <span class="keyword">new</span> <span class="title class_">Bar</span>();</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>上面示例中，子类 <code>Bar</code> 新建实例时，会输出<code>1</code>和<code>2</code>。原因就是子类构造函数调用<code>super()</code>时，会执行一次父类构造函数。<br><br></p><p>另一个需要注意的地方是，<ins>在子类的构造函数中，只有调用<code>super()</code>之后，才可以使用<code>this</code>关键字</ins>，否则会报错。这是因为子类实例的构建，必须先完成父类的继承，只有<code>super()</code>方法才能让子类实例继承父类。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&quot;Parent&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Parent</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// Error: Must call super constructor in derived class before accessing &#x27;this&#x27;</span></span><br><span class="line">    <span class="comment">// console.log(this.name);</span></span><br><span class="line"></span><br><span class="line">    <span class="variable language_">super</span>(); <span class="comment">// 正确初始化子类实例</span></span><br><span class="line"></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>); <span class="comment">// 输出: &#x27;Parent&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Child</span>();</span><br></pre></td></tr></table></figure><p>上面代码中，子类的<code>constructor()</code>方法没有调用<code>super()</code>之前，就使用<code>this</code>关键字，结果报错，而放在<code>super()</code>之后就是正确的。<br><br></p><p><ins>如果子类没有定义<code>constructor()</code>方法，这个方法会默认添加，并且里面会调用<code>super()</code></ins>。也就是说，不管有没有显式定义，任何一个子类都有<code>constructor()</code>方法。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Parent</span> &#123;</span><br><span class="line">  <span class="comment">// 这里我们没有显式定义 constructor()</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> child = <span class="keyword">new</span> <span class="title class_">Child</span>(<span class="string">&quot;John&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(child.<span class="property">name</span>); <span class="comment">// 输出: &#x27;John&#x27;</span></span><br></pre></td></tr></table></figure><p>有了子类的定义，就可以生成子类的实例了。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">child <span class="keyword">instanceof</span> <span class="title class_">Child</span>; <span class="comment">// true</span></span><br><span class="line">child <span class="keyword">instanceof</span> <span class="title class_">Parent</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>注意，<ins>如果父类和子类有同名属性，子类的属性会覆盖父类的属性</ins>。这是因为在子类中定义的属性和方法具有更高的优先级。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&quot;Parent&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Parent</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>();</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&quot;Child&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">showName</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> child = <span class="keyword">new</span> <span class="title class_">Child</span>();</span><br><span class="line">child.<span class="title function_">showName</span>(); <span class="comment">// 输出: &#x27;Child&#x27;</span></span><br></pre></td></tr></table></figure><hr><h3 id="22-2-私有属性和私有方法的继承"><a href="#22-2-私有属性和私有方法的继承" class="headerlink" title="22.2 私有属性和私有方法的继承"></a>22.2 私有属性和私有方法的继承</h3><p><ins>父类所有的属性和方法，都会被子类继承，除了私有的属性和方法</ins>。子类无法继承父类的私有属性，或者说，<ins>私有属性只能在定义它的 <code>class</code> 里面使用</ins>。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">  #p = <span class="number">1</span>;</span><br><span class="line">  #<span class="title function_">m</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bar</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Foo</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>();</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.#p); <span class="comment">// 报错</span></span><br><span class="line">    <span class="variable language_">this</span>.#<span class="title function_">m</span>(); <span class="comment">// 报错</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果<ins>父类定义了私有属性的读写方法，子类就可以通过这些方法，读写私有属性</ins>。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">  #p = <span class="number">1</span>;</span><br><span class="line">  <span class="title function_">getP</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.#p;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bar</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Foo</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>();</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="title function_">getP</span>()); <span class="comment">// 1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面示例中，<code>getP()</code>是父类用来读取私有属性的方法，子类可以用这个方法读到父类的私有属性。</p><hr><h3 id="22-3-静态属性和静态方法的继承"><a href="#22-3-静态属性和静态方法的继承" class="headerlink" title="22.3 静态属性和静态方法的继承"></a>22.3 静态属性和静态方法的继承</h3><p><ins>父类的静态属性和静态方法，也会被子类继承</ins>。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">hello</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_ inherited__">A</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">B.<span class="title function_">hello</span>(); <span class="comment">// hello world</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>hello()</code>是<code>A</code>类的静态方法，<code>B</code>继承<code>A</code>，也继承了<code>A</code>的静态方法。<br><br></p><p>注意，<ins>静态属性是通过<a href="https://vue3js.cn/interview/JavaScript/copy.html">软拷贝</a>实现继承的</ins>。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> foo = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_ inherited__">A</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>();</span><br><span class="line">    B.<span class="property">foo</span>--;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> b = <span class="keyword">new</span> <span class="title function_">B</span>();</span><br><span class="line">B.<span class="property">foo</span>; <span class="comment">// 99</span></span><br><span class="line">A.<span class="property">foo</span>; <span class="comment">// 100</span></span><br></pre></td></tr></table></figure><p>上面示例中，<code>foo</code>是 <code>A</code> 类的静态属性，<code>B</code> 类继承了 <code>A</code> 类，因此也继承了这个属性。但是，<ins>在 <code>B</code> 类内部操作<code>B.foo</code>这个静态属性，影响不到<code>A.foo</code></ins>，原因就是 <code>B</code> 类继承静态属性时，会采用浅拷贝，拷贝父类静态属性的值，因此<code>A.foo</code>和<code>B.foo</code>是两个彼此独立的属性。<br><br></p><p>但是，由于这种拷贝是浅拷贝，<ins>如果父类的静态属性的值是一个对象，那么子类的静态属性也会指向这个对象</ins>，因为浅拷贝只会拷贝对象的内存地址。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> foo = &#123; <span class="attr">n</span>: <span class="number">100</span> &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_ inherited__">A</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>();</span><br><span class="line">    B.<span class="property">foo</span>.<span class="property">n</span>--;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> b = <span class="keyword">new</span> <span class="title function_">B</span>();</span><br><span class="line">B.<span class="property">foo</span>.<span class="property">n</span>; <span class="comment">// 99</span></span><br><span class="line">A.<span class="property">foo</span>.<span class="property">n</span>; <span class="comment">// 99</span></span><br></pre></td></tr></table></figure><p>上面示例中，<code>A.foo</code>的值是一个对象，浅拷贝导致<code>B.foo</code>和<code>A.foo</code>指向同一个对象。所以，子类<code>B</code>修改这个对象的属性值，会影响到父类<code>A</code>。</p><hr><h3 id="22-4-super-关键字"><a href="#22-4-super-关键字" class="headerlink" title="22.4 super 关键字"></a>22.4 super 关键字</h3><p><code>super</code>这个关键字，既可以当作函数使用，也可以当作对象使用。<br><br></p><p>（1）当<code>super</code><ins>作为函数调用时，代表父类的构造函数</ins>。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_ inherited__">A</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用<code>super()</code>的作用是形成子类的<code>this</code>对象，把父类的实例属性和方法放到这个<code>this</code>对象上面。子类在调用<code>super()</code>之前，是没有<code>this</code>对象的，任何对<code>this</code>的操作都要放在<code>super()</code>的后面。<br><br></p><p>注意，<ins>这里的<code>super</code>虽然代表了父类的构造函数，但是因为返回的是子类的<code>this</code>（即子类的实例对象），所以<code>super</code>内部的<code>this</code>代表子类的实例，而不是父类的实例</ins>。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span>.<span class="property">target</span>.<span class="property">name</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_ inherited__">A</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> <span class="title function_">A</span>(); <span class="comment">// A</span></span><br><span class="line"><span class="keyword">new</span> <span class="title function_">B</span>(); <span class="comment">// B</span></span><br></pre></td></tr></table></figure><p>上面示例中，<code>new.target</code>指向当前正在执行的函数。可以看到，在<code>super()</code>执行时，它指向的是子类<code>B</code>的构造函数，而不是父类<code>A</code>的构造函数。也就是说，<code>super()</code>内部的<code>this</code>指向的是<code>B</code>。<br><br></p><p>不过，<ins>由于<code>super()</code>在子类构造方法中执行时，子类的属性和方法还没有绑定到<code>this</code>，所以如果存在同名属性，此时拿到的是父类的属性</ins>。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  name = <span class="string">&quot;A&quot;</span>;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;My name is &quot;</span> + <span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_ inherited__">A</span> &#123;</span><br><span class="line">  name = <span class="string">&quot;B&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> b = <span class="keyword">new</span> <span class="title function_">B</span>(); <span class="comment">// My name is A</span></span><br></pre></td></tr></table></figure><p>上面示例中，最后一行输出的是<code>A</code>，而不是<code>B</code>，原因就在于<code>super()</code>执行时，<code>B</code>的<code>name</code>属性还没有绑定到<code>this</code>，所以<code>this.name</code>拿到的是<code>A</code>类的<code>name</code>属性。<br><br></p><p><ins>作为函数时，<code>super()</code>只能用在子类的构造函数之中</ins>，用在其他地方就会报错。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_ inherited__">A</span> &#123;</span><br><span class="line">  <span class="title function_">m</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(); <span class="comment">// 报错</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）当<code>super</code><ins>作为对象时，在普通方法中指向父类的原型对象，在静态方法中指向父类</ins>。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&quot;Parent&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">greet</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hello, <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">sayHello</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello from Parent class&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Parent</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>();</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&quot;Child&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">greet</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>.<span class="title function_">greet</span>(); <span class="comment">// 使用super在普通方法中调用父类方法</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hello, <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span> from child class`</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">sayHello</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>.<span class="title function_">sayHello</span>(); <span class="comment">// 在静态方法中使用super调用父类静态方法</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello from Child class&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> c = <span class="keyword">new</span> <span class="title class_">Child</span>();</span><br><span class="line">c.<span class="title function_">greet</span>();</span><br><span class="line"><span class="title class_">Child</span>.<span class="title function_">sayHello</span>();</span><br></pre></td></tr></table></figure><p>如果<code>super</code>指向父类的原型对象，那么定义在父类实例上的方法或属性（即定义在<code>constructor</code>里），是无法通过<code>super</code>调用的。这时候想在子类中访问到父类实例上的属性，则需要在父类中定义一个方法来返回这个属性，然后在子类中调用这个方法。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&quot;Parent&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">getName</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Parent</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>();</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">super</span>.<span class="property">name</span>); <span class="comment">// TypeError ...</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">super</span>.<span class="title function_">getName</span>()); <span class="comment">// &#x27;Parent&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><ins>在子类普通方法中通过<code>super</code>调用父类的方法时，方法内部的<code>this</code>指向当前的子类实例</ins>。所以通过<code>super</code>对某个属性赋值，<code>super</code>就是<code>this</code>，赋值的属性会变成子类实例的属性。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">x</span> = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">print</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">x</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_ inherited__">A</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>();</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">x</span> = <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">m</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>.<span class="title function_">print</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> <span class="title function_">B</span>();</span><br><span class="line">b.<span class="title function_">m</span>(); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>super.print()</code>虽然调用的是<code>A.prototype.print()</code>，但是<code>A.prototype.print()</code>内部的<code>this</code>指向子类<code>B</code>的实例，导致输出的是<code>2</code>，而不是<code>1</code>。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">x</span> = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_ inherited__">A</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>();</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">x</span> = <span class="number">2</span>;</span><br><span class="line">    <span class="variable language_">super</span>.<span class="property">x</span> = <span class="number">3</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">super</span>.<span class="property">x</span>); <span class="comment">// undefined</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">x</span>); <span class="comment">// 3</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> <span class="title function_">B</span>();</span><br></pre></td></tr></table></figure><p>上面代码中，<code>super.x</code>赋值为<code>3</code>，这时等同于对<code>this.x</code>赋值为<code>3</code>。而当读取<code>super.x</code>的时候，读的是<code>A.prototype.x</code>，所以返回<code>undefined</code>。<br><br></p><p><ins>如果<code>super</code>作为对象，用在静态方法之中，这时<code>super</code>将指向父类，而不是父类的原型对象</ins>。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">myMethod</span>(<span class="params">msg</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;static&quot;</span>, msg);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">myMethod</span>(<span class="params">msg</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;instance&quot;</span>, msg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Parent</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">myMethod</span>(<span class="params">msg</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>.<span class="title function_">myMethod</span>(msg);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">myMethod</span>(<span class="params">msg</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>.<span class="title function_">myMethod</span>(msg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Child</span>.<span class="title function_">myMethod</span>(<span class="number">1</span>); <span class="comment">// static 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child = <span class="keyword">new</span> <span class="title class_">Child</span>();</span><br><span class="line">child.<span class="title function_">myMethod</span>(<span class="number">2</span>); <span class="comment">// instance 2</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>super</code>在静态方法之中指向父类，在普通方法之中指向父类的原型对象。<br><br></p><p>另外，<ins>在子类的静态方法中通过<code>super</code>调用父类的方法时，方法内部的<code>this</code>指向当前的子类，而不是子类的实例</ins>。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">x</span> = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">print</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">x</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_ inherited__">A</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>();</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">x</span> = <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">m</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>.<span class="title function_">print</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">B.<span class="property">x</span> = <span class="number">3</span>;</span><br><span class="line">B.<span class="title function_">m</span>(); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>上面代码中，静态方法<code>B.m</code>里面，<code>super.print</code>指向父类的静态方法。这个方法里面的<code>this</code>指向的是<code>B</code>，而不是<code>B</code>的实例。</p><hr><h3 id="22-5-类的-prototype-属性和-proto-属性"><a href="#22-5-类的-prototype-属性和-proto-属性" class="headerlink" title="22.5 类的 prototype 属性和 __proto__ 属性"></a>22.5 类的 prototype 属性和 __proto__ 属性</h3><p>大多数浏览器的 <code>ES5</code> 实现之中，每一个对象都有<code>__proto__</code>属性，指向对应的构造函数的<code>prototype</code>属性。<code>Class</code> 作为构造函数的语法糖，同时有<code>prototype</code>属性和<code>__proto__</code>属性，因此同时存在两条继承链。</p><ul><li>子类的<code>__proto__</code>属性，<ins>表示构造函数的继承，总是指向父类</ins>。</li><li>子类<code>prototype</code>属性的<code>__proto__</code>属性，<ins>表示方法的继承，总是指向父类的<code>prototype</code>属性</ins>。</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_ inherited__">A</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">B.<span class="property">__proto__</span> === A; <span class="comment">// true</span></span><br><span class="line">B.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">__proto__</span> === A.<span class="property"><span class="keyword">prototype</span></span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面代码中，<ins>子类<code>B</code>的<code>__proto__</code>属性指向父类<code>A</code>，子类<code>B</code>的<code>prototype</code>属性的<code>__proto__</code>属性指向父类<code>A</code>的<code>prototype</code>属性</ins>。</p><p>这两条继承链，可以这样理解：</p><ul><li>作为一个对象，子类（<code>B</code>）的原型（<code>__proto__</code>属性）是父类（<code>A</code>）。</li><li>作为一个构造函数，子类（<code>B</code>）的原型对象（<code>prototype</code>属性）是父类的原型对象（<code>prototype</code>属性）的实例。</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">B.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(A.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">B.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">__proto__</span> = A.<span class="property"><span class="keyword">prototype</span></span>;</span><br></pre></td></tr></table></figure><hr><h3 id="22-6-原生构造函数的继承"><a href="#22-6-原生构造函数的继承" class="headerlink" title="22.6 原生构造函数的继承"></a>22.6 原生构造函数的继承</h3><p><code>ES6</code> 允许继承原生构造函数定义子类，因为 <code>ES6</code> 是先新建父类的实例对象<code>this</code>，然后再用子类的构造函数修饰<code>this</code>，使得父类的所有行为都可以继承。下面是一个继承<code>Array</code>的例子。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyArray</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Array</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(...args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="title class_">MyArray</span>();</span><br><span class="line">arr[<span class="number">0</span>] = <span class="number">12</span>;</span><br><span class="line">arr.<span class="property">length</span>; <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">arr.<span class="property">length</span> = <span class="number">0</span>;</span><br><span class="line">arr[<span class="number">0</span>]; <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>上面代码定义了一个<code>MyArray</code>类，继承了<code>Array</code>构造函数，因此就可以从<code>MyArray</code>生成数组的实例。这意味着，<code>ES6</code> 可以自定义原生数据结构（比如<code>Array</code>、<code>String</code>等）的子类，这是 <code>ES5</code> 无法做到的。<br><br></p><p>上面这个例子也说明，<code>extends</code>关键字不仅可以用来继承类，还可以用来继承原生的构造函数。因此可以在原生数据结构的基础上，定义自己的数据结构。下面就是定义了一个带版本功能的数组。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">VersionedArray</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Array</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>();</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">history</span> = [[]];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">commit</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">history</span>.<span class="title function_">push</span>(<span class="variable language_">this</span>.<span class="title function_">slice</span>());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">revert</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">splice</span>(<span class="number">0</span>, <span class="variable language_">this</span>.<span class="property">length</span>, ...<span class="variable language_">this</span>.<span class="property">history</span>[<span class="variable language_">this</span>.<span class="property">history</span>.<span class="property">length</span> - <span class="number">1</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x = <span class="keyword">new</span> <span class="title class_">VersionedArray</span>();</span><br><span class="line"></span><br><span class="line">x.<span class="title function_">push</span>(<span class="number">1</span>);</span><br><span class="line">x.<span class="title function_">push</span>(<span class="number">2</span>);</span><br><span class="line">x; <span class="comment">// [1, 2]</span></span><br><span class="line">x.<span class="property">history</span>; <span class="comment">// [[]]</span></span><br><span class="line"></span><br><span class="line">x.<span class="title function_">commit</span>();</span><br><span class="line">x.<span class="property">history</span>; <span class="comment">// [[], [1, 2]]</span></span><br><span class="line"></span><br><span class="line">x.<span class="title function_">push</span>(<span class="number">3</span>);</span><br><span class="line">x; <span class="comment">// [1, 2, 3]</span></span><br><span class="line">x.<span class="property">history</span>; <span class="comment">// [[], [1, 2]]</span></span><br><span class="line"></span><br><span class="line">x.<span class="title function_">revert</span>();</span><br><span class="line">x; <span class="comment">// [1, 2]</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>VersionedArray</code>会通过<code>commit</code>方法，将自己的当前状态生成一个版本快照，存入<code>history</code>属性。<code>revert</code>方法用来将数组重置为最新一次保存的版本。除此之外，<code>VersionedArray</code>依然是一个普通数组，所有原生的数组方法都可以在它上面调用。<br><br></p><p>注意，继承<code>Object</code>的子类，有一个<a href="https://stackoverflow.com/questions/36203614/super-does-not-pass-arguments-when-instantiating-a-class-extended-from-object">行为差异</a>。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NewObj</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Object</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(...<span class="variable language_">arguments</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="title class_">NewObj</span>(&#123; <span class="attr">attr</span>: <span class="literal">true</span> &#125;);</span><br><span class="line">o.<span class="property">attr</span> === <span class="literal">true</span>; <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>NewObj</code>继承了<code>Object</code>，但是无法通过<code>super</code>方法向父类<code>Object</code>传参。这是因为 <code>ES6</code> 改变了<code>Object</code>构造函数的行为，一旦发现<code>Object</code>方法不是通过<code>new Object()</code>这种形式调用，<code>ES6</code> 规定<code>Object</code>构造函数会忽略参数。</p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> ES6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ES6学习笔记 • 中</title>
      <link href="/posts/9413d22e.html"/>
      <url>/posts/9413d22e.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>本读书笔记节是针对阮一峰编写的 <a href="https://es6.ruanyifeng.com/">《ECMAScript 6 入门教程》</a>的总结。适合已经掌握 <code>ES5</code> 的读者，用来了解这门语言的最新发展。笔记内容仅包括日常开发中可能会用到的概念。</p></blockquote><hr><h2 id="16-Promise-对象"><a href="#16-Promise-对象" class="headerlink" title="16. Promise 对象"></a>16. Promise 对象</h2><h3 id="16-1-事件循环"><a href="#16-1-事件循环" class="headerlink" title="16.1 事件循环"></a>16.1 事件循环</h3><p>推荐阅读：<a href="https://segmentfault.com/a/1190000038928521">js 事件循环机制 event-loop</a><br><br></p><p><code>JavaScript</code>是单线程语言，代码按顺序执行，但为了处理耗时操作（如网络请求、定时器），引入了异步机制。</p><p>执行顺序原则: 先同步，再异步；异步中先微任务，后宏任务</p><ul><li>宏任务（<code>macro-task</code>）：<code>setTimeout</code>、<code>setInterval</code>、整体代码<code>script</code></li><li>微任务（<code>micro-task</code>）：<code>Promise.then/catch</code>、<code>process.nextTick</code></li></ul><p>事件循环流程</p><ul><li><ol><li>同步任务直接在主线程执行</li></ol></li><li><ol start="2"><li>异步任务进入<code>Event Table</code>注册，完成后进入<code>Event Queue</code></li></ol></li><li><ol start="3"><li>主线程执行完毕后，从<code>Event Queue</code>读取任务执行</li></ol></li><li><ol start="4"><li>每执行完一个宏任务，就会清空所有微任务</li></ol></li><li><ol start="5"><li>然后进入下一个宏任务，循环往复</li></ol></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;1&#x27;</span>);  <span class="comment">// 同步，立即执行</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;2&#x27;</span>);  <span class="comment">// 宏任务</span></span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;3&#x27;</span>);  <span class="comment">// 微任务</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;4&#x27;</span>);  <span class="comment">// 同步，立即执行</span></span><br></pre></td></tr></table></figure><blockquote><p>输出顺序：1 → 4 → 3 → 2</p></blockquote><ul><li><code>setTimeout(fn, 0)</code> 不是立即执行，而是在主线程空闲时执行</li><li><code>new Promise</code> 的构造函数是同步执行的，只有 <code>.then()</code> 是异步的</li><li>每轮循环都是：执行一个宏任务 → 清空所有微任务 → 下一个宏任务</li></ul><hr><h3 id="16-2-Promise-的含义"><a href="#16-2-Promise-的含义" class="headerlink" title="16.2 Promise 的含义"></a>16.2 Promise 的含义</h3><p><code>Promise</code> 是异步编程的一种解决方案，比传统的<a href="https://segmentfault.com/a/1190000021942060">回调函数</a>和<a href="https://zh.javascript.info/introduction-browser-events">事件</a>，更合理和更强大。它类似于一个容器，里面保存着某个未来才会结束的事件，通常是一个异步操作的结果。<br><br></p><p><code>Promise</code>对象有以下两个特点</p><ul><li><ins><code>Promise</code>对象的状态不受外界影响</ins>。<code>Promise</code>对象代表一个异步操作，有三种状态：<code>pending</code>（进行中）、<code>fulfilled</code>（已成功）和<code>rejected</code>（已失败）。<ins>只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态</ins>。</li><li><ins><code>Promise</code>对象一旦状态改变，就不会再变</ins>。<code>Promise</code>对象的状态改变，只有两种可能：从<code>pending</code>变为<code>fulfilled</code>和从<code>pending</code>变为<code>rejected</code>。只要这两种情况发生，状态就凝固了，这时就称为 <code>resolved</code>（已定型）。</li></ul><p><code>Promise</code>对象的好处，是可以<ins>将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数</ins>。此外，<code>Promise</code>对象提供统一的接口，使得控制异步操作更加容易。</p><p><code>Promise</code>也有缺点。首先，<ins>无法取消<code>Promise</code>，一旦新建它就会立即执行，无法中途取消</ins>。其次，<ins>如果不设置回调函数，<code>Promise</code>内部抛出的错误，不会反应到外部</ins>。第三，当处于<code>pending</code>状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。</p><hr><h3 id="16-3-基本用法"><a href="#16-3-基本用法" class="headerlink" title="16.3 基本用法"></a>16.3 基本用法</h3><p><code>Promise</code>的构造函数接受一个函数作为参数，该函数的两个参数分别是<code>resolve</code>和<code>reject</code>。它们是两个函数，由 <code>JavaScript</code> 引擎提供，不用自己部署。</p><ul><li><code>resolve</code>函数的作用是，将<code>Promise</code>对象的状态从“未完成”变为“成功”（即从 <code>pending</code> 变为 <code>resolved</code>），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去。</li><li><code>reject</code>函数的作用是，将<code>Promise</code>对象的状态从“未完成”变为“失败”（即从 <code>pending</code> 变为 <code>rejected</code>），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="comment">/* 异步操作成功 */</span>)&#123;</span><br><span class="line">    <span class="title function_">resolve</span>(value);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="title function_">reject</span>(error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>Promise</code>实例生成后可以<ins>用<code>then</code>方法指定<code>resolved</code>和<code>rejected</code>的回调函数。这两个函数都是可选的，不一定要提供。它们都接受<code>Promise</code>对象传出的值作为参数</ins>。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">promise.<span class="title function_">then</span>(</span><br><span class="line">  <span class="keyword">function</span> (<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="comment">// success</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">function</span> (<span class="params">error</span>) &#123;</span><br><span class="line">    <span class="comment">// failure</span></span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>下面是一个<code>Promise</code>对象的例子。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">timeout</span>(<span class="params">ms</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// https://developer.mozilla.org/en-US/docs/Web/API/setTimeout</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(resolve, ms, <span class="string">&quot;done&quot;</span>); <span class="comment">// &#x27;done&#x27; 会传入回调函数 resolve</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">timeout</span>(<span class="number">1000</span>).<span class="title function_">then</span>(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 1秒后 &quot;done&quot;</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>timeout</code>方法返回一个<code>Promise</code>实例，表示一段时间以后才会发生的结果。过了指定的时间后，<code>Promise</code>实例的状态变为<code>resolved</code>，就会触发<code>then</code>方法绑定的回调函数。<br><br></p><p><ins><code>Promise</code> 新建后就会立即执行</ins>。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">  <span class="title function_">resolve</span>();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise.<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;resolved.&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hi!&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Hello</span></span><br><span class="line"><span class="comment">// Hi!</span></span><br><span class="line"><span class="comment">// resolved</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>Promise</code> 新建后立即执行，所以首先输出的是<code>Hello</code>。然后，<ins><code>then</code>方法指定的回调函数，将在当前脚本所有同步任务执行完才会执行</ins>，所以<code>resolved</code>最后输出。</p><p>如果<ins>调用<code>resolve</code>函数和<code>reject</code>函数时带有参数</ins>，那么它们的<ins>参数会被传递给回调函数</ins>。</p><ul><li><code>reject</code>函数的参数通常是<code>Error</code>对象的实例，表示抛出的错误。</li><li><code>resolve</code>函数的参数除了正常的值以外，还可能是另一个 <code>Promise</code> 实例。</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="title function_">resolve</span>(p1);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，<code>p1</code>和<code>p2</code>都是 <code>Promise</code> 的实例，但是<code>p2</code>的<code>resolve</code>方法将<code>p1</code>作为参数，即一个异步操作的结果是返回另一个异步操作。这时<code>p1</code>的状态就会传递给<code>p2</code>，此时<code>p1</code>的状态决定了<code>p2</code>的状态。</p><ul><li>如果<code>p1</code>的状态是<code>pending</code>，那么<code>p2</code>的回调函数就会等待<code>p1</code>的状态改变。</li><li>如果<code>p1</code>的状态已经是<code>resolved</code>或者<code>rejected</code>，那么<code>p2</code>的回调函数将会立刻执行。</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;fail&quot;</span>)), <span class="number">3000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">resolve</span>(p1), <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p2.<span class="title function_">then</span>(<span class="function">(<span class="params">result</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(result)).<span class="title function_">catch</span>(<span class="function">(<span class="params">error</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(error));</span><br><span class="line"><span class="comment">// Error: fail</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>p1</code>是一个 <code>Promise</code>，<code>3</code> 秒之后变为<code>rejected</code>。<code>p2</code>的状态在 <code>1</code> 秒之后改变，而且<code>resolve</code>方法返回的是<code>p1</code>。</p><ul><li>由于<code>p2</code>返回的是另一个 <code>Promise</code>，导致<code>p2</code>自己的状态无效了，<ins>由<code>p1</code>的状态决定<code>p2</code>的状态</ins>。所以，后面的<code>then</code>语句都变成针对后者<code>p1</code>。又过了 <code>2</code> 秒，<code>p1</code>变为<code>rejected</code>，导致触发<code>catch</code>方法指定的回调函数。</li></ul><p>注意，调用<code>resolve</code>或<code>reject</code>并不会终结 <code>Promise</code> 的参数函数的执行。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">(<span class="params">r</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(r);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>上面代码中，调用<code>resolve(1)</code>以后，后面的<code>console.log(2)</code>还是会执行，<ins>并且会首先打印出来。这是因为立即 <code>resolved</code> 的 <code>Promise</code> 是在本轮事件循环的末尾执行，总是晚于本轮循环的同步任务</ins>。<br><br></p><p>一般来说，调用<code>resolve</code>或<code>reject</code>以后，<code>Promise</code> 的使命就完成了，后继操作应该放到<code>then</code>方法里面，而不应该直接写在<code>resolve</code>或<code>reject</code>的后面。所以，<ins>最好在它们前面加上<code>return</code>语句</ins>，这样就不会有意外。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">resolve</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="comment">// 后面的语句不会执行</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><hr><h3 id="16-4-then-方法"><a href="#16-4-then-方法" class="headerlink" title="16.4 then 方法"></a>16.4 then 方法</h3><p><code>Promise.then()</code>方法的作用是为 <code>Promise</code> 实例添加状态改变时的回调函数。<ins><code>then</code>方法的第一个参数是<code>resolved</code>状态的回调函数，第二个参数是<code>rejected</code>状态的回调函数</ins>，它们都是可选的。<br><br></p><p><ins><code>then</code>方法返回的是一个新的<code>Promise</code>实例</ins>，因此可以采用链式写法，即<code>then</code>方法后面再调用另一个<code>then</code>方法。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">getJSON</span>(<span class="string">&quot;/posts.json&quot;</span>)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">json</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> json.<span class="property">post</span>;</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">post</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>上面的代码使用<code>then</code>方法，依次指定了两个回调函数。<ins>第一个回调函数完成以后，会将返回结果作为参数，传入第二个回调函数</ins>。<br><br></p><p>链式写法的<code>then</code>，可以指定一组按照次序调用的回调函数。<ins>这时，前一个回调函数，有可能返回的还是一个<code>Promise</code>对象（即有异步操作），这时后一个回调函数，就会等待该<code>Promise</code>对象的状态发生变化，才会被调用</ins>。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">getJSON</span>(<span class="string">&quot;/post/1.json&quot;</span>)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">post</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">getJSON</span>(post.<span class="property">commentURL</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(</span><br><span class="line">    <span class="keyword">function</span> (<span class="params">comments</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;resolved: &quot;</span>, comments);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">function</span> (<span class="params">err</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;rejected: &quot;</span>, err);</span><br><span class="line">    &#125;</span><br><span class="line">  );</span><br></pre></td></tr></table></figure><p>上面代码中，第一个<code>then</code>方法指定的回调函数，返回的是另一个<code>Promise</code>对象。<ins>这时，第二个<code>then</code>方法指定的回调函数，就会等待这个新的<code>Promise</code>对象状态发生变化</ins>。</p><ul><li>如果变为<code>resolved</code>，第二个<code>then</code>方法就调用第一个回调函数。</li><li>如果状态变为<code>rejected</code>，第二个<code>then</code>方法就调用第二个回调函数。</li></ul><p>如果采用箭头函数，上面的代码可以写得更简洁。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">getJSON</span>(<span class="string">&quot;/post/1.json&quot;</span>)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">post</span>) =&gt;</span> <span class="title function_">getJSON</span>(post.<span class="property">commentURL</span>))</span><br><span class="line">  .<span class="title function_">then</span>(</span><br><span class="line">    <span class="function">(<span class="params">comments</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;resolved: &quot;</span>, comments),</span><br><span class="line">    <span class="function">(<span class="params">err</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;rejected: &quot;</span>, err)</span><br><span class="line">  );</span><br></pre></td></tr></table></figure><hr><h3 id="16-5-catch-方法"><a href="#16-5-catch-方法" class="headerlink" title="16.5 catch 方法"></a>16.5 catch 方法</h3><p><code>Promise.catch()</code>方法用于指定发生错误时的回调函数。<ins>它返回的是一个新的<code>Promise</code>对象</ins>。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">getJSON</span>(<span class="string">&quot;/posts.json&quot;</span>)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">posts</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="keyword">function</span> (<span class="params">error</span>) &#123;</span><br><span class="line">    <span class="comment">// 处理 getJSON 和 前一个回调函数运行时发生的错误</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;发生错误！&quot;</span>, error);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，<code>getJSON()</code>方法返回一个 <code>Promise</code> 对象。</p><ul><li>如果该对象状态变为<code>resolved</code>，则会调用<code>then()</code>方法指定的回调函数。</li><li>如果异步操作抛出错误，状态就会变为<code>rejected</code>，就会调用<code>catch()</code>方法指定的回调函数处理这个错误。</li></ul><p>注意，<ins><code>then()</code>方法指定的回调函数，如果运行中抛出错误，也会被<code>catch()</code>方法捕获</ins>。</p><p>下面代码中，<code>promise</code>抛出一个错误，被<code>catch()</code>方法指定的回调函数捕获。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;test&quot;</span>); <span class="comment">// or reject(new Error(&#x27;test&#x27;));</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise.<span class="title function_">catch</span>(<span class="keyword">function</span> (<span class="params">error</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(error);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// Error: test</span></span><br></pre></td></tr></table></figure><p>下面两种写法与上面是等价的。（比较喜欢<code>try...catch...</code>的写法）<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="title function_">reject</span>(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise.<span class="title function_">catch</span>(<span class="keyword">function</span> (<span class="params">error</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(error);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">  <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;test&quot;</span>));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise.<span class="title function_">catch</span>(<span class="keyword">function</span> (<span class="params">error</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>注意，如果<code>Promise</code>状态已经变成<code>resolved</code>，再抛出错误是无效的。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="string">&quot;ok&quot;</span>);</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise</span><br><span class="line">  .<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="keyword">function</span> (<span class="params">error</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(error);</span><br><span class="line">  &#125;);</span><br><span class="line"><span class="comment">// ok</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>Promise</code> 在<code>resolve</code>语句后面，再抛出错误，并不会被捕获。因为 <code>Promise</code> 的状态一旦改变，就永久保持该状态。<br><br></p><p><code>Promise</code> 对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止。也就是说，错误总是会被下一个<code>catch</code>语句捕获。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">getJSON</span>(<span class="string">&quot;/post/1.json&quot;</span>)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">post</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">getJSON</span>(post.<span class="property">commentURL</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">comments</span>) &#123;</span><br><span class="line">    <span class="comment">// some code</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="keyword">function</span> (<span class="params">error</span>) &#123;</span><br><span class="line">    <span class="comment">// 处理前面三个Promise产生的错误</span></span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，一共有三个 <code>Promise</code> 对象: 一个由<code>getJSON()</code>产生，两个由<code>then()</code>产生。它们之中任何一个抛出的错误，都会被最后一个<code>catch()</code>捕获。<br><br></p><p>一般来说，<ins>不要在<code>then()</code>方法里面定义 <code>Reject</code> 状态的回调函数，总是使用<code>catch</code>方法</ins>。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line">promise.<span class="title function_">then</span>(</span><br><span class="line">  <span class="keyword">function</span> (<span class="params">data</span>) &#123;</span><br><span class="line">    <span class="comment">// success</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">function</span> (<span class="params">err</span>) &#123;</span><br><span class="line">    <span class="comment">// error</span></span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line">promise</span><br><span class="line">  .<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">data</span>) &#123;</span><br><span class="line">    <span class="comment">// success</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="keyword">function</span> (<span class="params">err</span>) &#123;</span><br><span class="line">    <span class="comment">// error</span></span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>跟传统的<code>try/catch</code>代码块不同的是，<ins>如果没有使用<code>catch()</code>方法指定错误处理的回调函数，<code>Promise</code> 对象抛出的错误不会传递到外层代码</ins>，即不会有任何反应。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> someAsyncThing = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">    <span class="comment">// 下面一行会报错，因为 x 没有声明</span></span><br><span class="line">    <span class="title function_">resolve</span>(x + <span class="number">2</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">someAsyncThing</span>().<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;everything is great&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">123</span>);</span><br><span class="line">&#125;, <span class="number">2000</span>);</span><br><span class="line"><span class="comment">// Uncaught (in promise) ReferenceError: x is not defined</span></span><br><span class="line"><span class="comment">// 123</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>someAsyncThing()</code>函数产生的 <code>Promise</code> 对象，内部有语法错误。运行到这一行时，会打印出错误提示，但是不会终止脚本执行，<code>2</code> 秒之后还是会输出<code>123</code>。这就是说，<ins><code>Promise</code> 内部的错误不会影响到 <code>Promise</code> 外部的代码</ins>，通俗的说法就是“<code>Promise</code> 会吃掉错误”。<br><br></p><p>所以建议，<code>Promise</code> 对象后面要跟<code>catch()</code>方法，这样可以处理 <code>Promise</code> 内部发生的错误。注意，<ins><code>catch()</code>方法返回的是一个新的<code>Promise</code>对象</ins>，因此后面还可以接着调用<code>then()</code>方法，或者<code>catch()</code>方法，去处理前一个<code>catch()</code>方法抛出的错误。</p><hr><h3 id="16-6-finally-方法"><a href="#16-6-finally-方法" class="headerlink" title="16.6 finally 方法"></a>16.6 finally 方法</h3><p><code>Promise.finally()</code>方法用于指定不管<code>Promise</code>对象最后状态如何，都会执行的操作。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">promise</span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">result</span> =&gt;</span> &#123;···&#125;)</span><br><span class="line">.<span class="title function_">catch</span>(<span class="function"><span class="params">error</span> =&gt;</span> &#123;···&#125;)</span><br><span class="line">.<span class="title function_">finally</span>(<span class="function">() =&gt;</span> &#123;···&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，不管<code>promise</code>最后的状态，在执行完<code>then</code>或<code>catch</code>指定的回调函数以后，都会执行<code>finally</code>方法指定的回调函数。<br><br></p><p>下面是一个例子，服务器使用 <code>Promise</code> 处理请求，然后使用<code>finally</code>方法关掉服务器。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">server</span><br><span class="line">  .<span class="title function_">listen</span>(port)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">finally</span>(server.<span class="property">stop</span>);</span><br></pre></td></tr></table></figure><p>由于<ins><code>finally</code>方法的回调函数不接受任何参数</ins>，这表明<ins><code>finally</code>方法里面的操作，应该是与状态无关的，不依赖于<code>Promise</code>的执行结果</ins>。</p><hr><h3 id="16-7-all-方法"><a href="#16-7-all-方法" class="headerlink" title="16.7 all 方法"></a>16.7 all 方法</h3><p><code>Promise.all()</code>方法用于将多个<code>Promise</code>实例，包装成一个新的<code>Promise</code>实例。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="title class_">Promise</span>.<span class="title function_">all</span>([p1, p2, p3]); <span class="comment">// 接受一个数组作为参数</span></span><br></pre></td></tr></table></figure><p>上面<code>p</code>的状态由<code>p1</code>、<code>p2</code>、<code>p3</code>决定，分成两种情况</p><ul><li>只有<code>p1</code>、<code>p2</code>、<code>p3</code>的<ins>状态都变成<code>fulfilled</code>，<code>p</code>的状态才会变成<code>fulfilled</code></ins>，此时<ins><code>p1</code>、<code>p2</code>、<code>p3</code>的返回值组成一个数组，传递给<code>p</code>的回调函数</ins>。</li><li>只要<code>p1</code>、<code>p2</code>、<code>p3</code>之中<ins>有一个被<code>rejected</code>，<code>p</code>的状态就变成<code>rejected</code></ins>，此时<ins>第一个被<code>reject</code>的实例的返回值，会传递给<code>p</code>的回调函数</ins>。</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 生成一个Promise对象的数组</span></span><br><span class="line"><span class="keyword">const</span> promises = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>].<span class="title function_">map</span>(<span class="keyword">function</span> (<span class="params">id</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">getJSON</span>(<span class="string">&quot;/post/&quot;</span> + id + <span class="string">&quot;.json&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">all</span>(promises)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">posts</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="keyword">function</span> (<span class="params">reason</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，只有<code>promises</code>中<code>6</code>个<code>Promise</code>实例的状态都变成<code>fulfilled</code>，或者有一个变为<code>rejected</code>，才会调用<code>Promise.all()</code>方法后面的回调函数。<br><br></p><p>下面是另一个例子。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> databasePromise = <span class="title function_">connectDatabase</span>(); <span class="comment">// 这里应该是返回一个 Promise 实例</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> booksPromise = databasePromise.<span class="title function_">then</span>(findAllBooks); <span class="comment">// 返回一个 Promise Object，为当前 Promise 的状态</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> userPromise = databasePromise.<span class="title function_">then</span>(getCurrentUser);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">all</span>([booksPromise, userPromise]).<span class="title function_">then</span>(<span class="function">(<span class="params">[books, user]</span>) =&gt;</span></span><br><span class="line">  <span class="title function_">pickTopRecommendations</span>(books, user)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>上面代码中，<code>booksPromise</code>和<code>userPromise</code>是两个异步操作，只有等到它们的结果都返回了，才会触发<code>pickTopRecommendations</code>这个回调函数。<br><br></p><p>注意，如果<ins>作为参数的 <code>Promise</code> 实例，自己定义了<code>catch</code>方法，那么它一旦被<code>rejected</code>，并不会触发<code>Promise.all()</code>的<code>catch</code>方法</ins>。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">&#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">result</span>) =&gt;</span> result)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function">(<span class="params">e</span>) =&gt;</span> e);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;报错了&quot;</span>);</span><br><span class="line">&#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">result</span>) =&gt;</span> result)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function">(<span class="params">e</span>) =&gt;</span> e);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">all</span>([p1, p2])</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">result</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(result))</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function">(<span class="params">e</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(e));</span><br><span class="line"><span class="comment">// [&quot;hello&quot;, Error: 报错了]</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>p1</code>是<code>resolved</code>，<code>p2</code>会被<code>rejected</code>。但是<code>p2</code>有自己的<code>catch</code>方法，返回一个新的 <code>Promise</code> 实例，<code>p2</code>实际指向的是这个新的实例。<ins>该实例执行完<code>catch</code>方法后，也会变成<code>resolved</code>，导致<code>Promise.all()</code>方法参数里面的两个实例都会<code>resolved</code>，因此会调用<code>then</code>方法指定的回调函数</ins>，而不会调用<code>catch</code>方法指定的回调函数。<br><br></p><p>如果<code>p2</code>没有自己的<code>catch</code>方法，就会调用<code>Promise.all()</code>的<code>catch</code>方法。</p><hr><h3 id="16-8-race-方法"><a href="#16-8-race-方法" class="headerlink" title="16.8 race 方法"></a>16.8 race 方法</h3><p><code>Promise.race()</code>方法同样是将多个 <code>Promise</code> 实例，包装成一个新的 <code>Promise</code> 实例。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="title class_">Promise</span>.<span class="title function_">race</span>([p1, p2, p3]);</span><br></pre></td></tr></table></figure><p>上面代码中，只要<code>p1</code>、<code>p2</code>、<code>p3</code>之中<ins>有一个实例率先改变状态，<code>p</code>的状态就跟着改变</ins>。那个率先改变的 <code>Promise</code> 实例的返回值，就传递给<code>p</code>的回调函数。<br><br></p><p>下面如果指定时间内没有获得结果，就将 <code>Promise</code> 的状态变为<code>reject</code>，否则变为<code>resolve</code>。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="title class_">Promise</span>.<span class="title function_">race</span>([</span><br><span class="line">  <span class="title function_">fetch</span>(<span class="string">&quot;/resource-that-may-take-a-while&quot;</span>),</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;request timeout&quot;</span>)), <span class="number">5000</span>);</span><br><span class="line">  &#125;),</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line">p.<span class="title function_">then</span>(<span class="variable language_">console</span>.<span class="property">log</span>).<span class="title function_">catch</span>(<span class="variable language_">console</span>.<span class="property">error</span>);</span><br></pre></td></tr></table></figure><p>上面代码中，如果 <code>5</code> 秒之内<code>fetch</code>方法无法返回结果，变量<code>p</code>的状态就会变为<code>rejected</code>，从而触发<code>catch</code>方法指定的回调函数。</p><hr><h3 id="16-9-allSettled-方法"><a href="#16-9-allSettled-方法" class="headerlink" title="16.9 allSettled 方法"></a>16.9 allSettled 方法</h3><p>有时候，我们希望等到一组异步操作都结束，不管每一个操作是成功还是失败，再进行下一步操作。为了解决这个问题，<code>ES6</code> 引入了<code>Promise.allSettled()</code>方法。<br><br></p><p><code>Promise.allSettled()</code>方法接受一个<code>Promise</code>数组作为参数，并<ins>返回一个新的 <code>Promise</code> 对象</ins>。只有等到参数数组的<ins>所有 <code>Promise</code> 对象都发生状态变更，不管是<code>fulfilled</code>还是<code>rejected</code>，返回的 <code>Promise</code> 对象才会发生状态变更</ins>。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promises = [<span class="title function_">fetch</span>(<span class="string">&quot;/api-1&quot;</span>), <span class="title function_">fetch</span>(<span class="string">&quot;/api-2&quot;</span>), <span class="title function_">fetch</span>(<span class="string">&quot;/api-3&quot;</span>)];</span><br><span class="line"></span><br><span class="line"><span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">allSettled</span>(promises);</span><br><span class="line"><span class="title function_">removeLoadingIndicator</span>();</span><br></pre></td></tr></table></figure><p>上面示例中，数组<code>promises</code>包含了三个请求，只有等到这三个请求都结束了，不管请求成功还是失败，<code>removeLoadingIndicator()</code>才会执行。<br><br></p><p><code>Promise.allSettled()</code>返回的 <code>Promise</code> 实例，<ins>状态总是<code>fulfilled</code>，不会变成<code>rejected</code></ins>。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> resolved = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">42</span>);</span><br><span class="line"><span class="keyword">const</span> rejected = <span class="title class_">Promise</span>.<span class="title function_">reject</span>(-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> allSettledPromise = <span class="title class_">Promise</span>.<span class="title function_">allSettled</span>([resolved, rejected]);</span><br><span class="line"></span><br><span class="line">allSettledPromise.<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">results</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(results);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// [</span></span><br><span class="line"><span class="comment">//    &#123; status: &#x27;fulfilled&#x27;, value: 42 &#125;,</span></span><br><span class="line"><span class="comment">//    &#123; status: &#x27;rejected&#x27;, reason: -1 &#125;</span></span><br><span class="line"><span class="comment">// ]</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>Promise.allSettled()</code>的返回值<code>allSettledPromise</code>，状态只可能变成<code>fulfilled</code>。<ins>它的回调函数接收到的参数是数组<code>results</code>，对应传入<code>Promise.allSettled()</code>的数组里面的两个 <code>Promise</code> 对象</ins>。<br><br></p><p>上面<code>results</code>的每个成员是一个对象，对应异步操作的结果。（重点）<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 异步操作成功时</span></span><br><span class="line">&#123;<span class="attr">status</span>: <span class="string">&#x27;fulfilled&#x27;</span>, <span class="attr">value</span>: value&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步操作失败时</span></span><br><span class="line">&#123;<span class="attr">status</span>: <span class="string">&#x27;rejected&#x27;</span>, <span class="attr">reason</span>: reason&#125;</span><br></pre></td></tr></table></figure><p>成员对象的<code>status</code>属性的值只可能是字符串<code>fulfilled</code>或字符串<code>rejected</code>，用来区分异步操作是成功还是失败。<ins>如果是成功<code>fulfilled</code>，对象会有<code>value</code>属性，如果是失败<code>rejected</code>，会有<code>reason</code>属性</ins>，对应两种状态时前面异步操作的返回值。</p><hr><h3 id="16-10-any-方法"><a href="#16-10-any-方法" class="headerlink" title="16.10 any 方法"></a>16.10 any 方法</h3><p><code>Promise.any()</code> 接受一组 <code>Promise</code> 实例作为参数，包装成一个新的 <code>Promise</code> 实例返回。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">any</span>([</span><br><span class="line">  <span class="title function_">fetch</span>(<span class="string">&quot;https://v8.dev/&quot;</span>).<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="string">&quot;home&quot;</span>),</span><br><span class="line">  <span class="title function_">fetch</span>(<span class="string">&quot;https://v8.dev/blog&quot;</span>).<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="string">&quot;blog&quot;</span>),</span><br><span class="line">  <span class="title function_">fetch</span>(<span class="string">&quot;https://v8.dev/docs&quot;</span>).<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="string">&quot;docs&quot;</span>),</span><br><span class="line">])</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">first</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 只要有一个 fetch() 请求成功</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(first);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 所有三个 fetch() 全部请求失败</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(error);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><ul><li>只要参数实例有一个变成<code>fulfilled</code>状态，包装实例就会变成<code>fulfilled</code>状态。</li><li>如果所有参数实例都变成<code>rejected</code>状态，包装实例就会变成<code>rejected</code>状态。</li></ul><p>下面是<code>Promise()</code>与<code>await</code>命令结合使用的例子。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promises = [</span><br><span class="line">  <span class="title function_">fetch</span>(<span class="string">&quot;/endpoint-a&quot;</span>).<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="string">&quot;a&quot;</span>),</span><br><span class="line">  <span class="title function_">fetch</span>(<span class="string">&quot;/endpoint-b&quot;</span>).<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="string">&quot;b&quot;</span>),</span><br><span class="line">  <span class="title function_">fetch</span>(<span class="string">&quot;/endpoint-c&quot;</span>).<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="string">&quot;c&quot;</span>),</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> first = <span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">any</span>(promises);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(first);</span><br><span class="line">&#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(error);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>Promise.any()</code>方法的参数包含三个 <code>Promise</code> 操作。其中只要有一个变成<code>fulfilled</code>，<code>Promise.any()</code>返回的 <code>Promise</code> 对象就变成<code>fulfilled</code>。如果所有三个操作都变成<code>rejected</code>，那么<code>await</code>命令就会抛出错误。</p><hr><h3 id="16-11-resolve-方法"><a href="#16-11-resolve-方法" class="headerlink" title="16.11 resolve 方法"></a>16.11 resolve 方法</h3><p>有时需要将现有对象转为 <code>Promise</code> 对象，<code>Promise.resolve()</code>方法就起到这个作用。<br><br></p><p><strong>（1）参数是一个 thenable 对象</strong></p><p><code>thenable</code>对象指的是具有<code>then</code>方法的对象，比如下面这个对象。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> thenable = &#123;</span><br><span class="line">  <span class="attr">then</span>: <span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="number">42</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(thenable);</span><br><span class="line"></span><br><span class="line">p1.<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">value</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(value); <span class="comment">// 42</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，<ins><code>resolve()</code>方法会将这个对象转为 <code>Promise</code> 对象，然后立即执行<code>thenable</code>对象的<code>then()</code>方法</ins>。<br><br></p><p><strong>（2）参数不是具有 then()方法的对象，或根本就不是对象</strong></p><p>如果参数是一个原始值，或者是一个不具有<code>then()</code>方法的对象，则<code>resolve()</code>方法返回一个新的 <code>Promise</code> 对象，状态为<code>resolved</code>。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">p.<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">s</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(s);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// Hello</span></span><br></pre></td></tr></table></figure><p><strong>（3）不带有任何参数</strong></p><p><code>resolve()</code>方法调用时可以<ins>不带参数，直接返回一个<code>resolved</code>状态的 <code>Promise</code> 对象</ins>。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>();</span><br><span class="line"></span><br><span class="line">p.<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><ins>立即<code>resolve()</code>的 <code>Promise</code> 对象，是在本轮“事件循环”的结束时执行，而不是在下一轮“事件循环”的开始时</ins>。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;three&quot;</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;two&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;one&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// one</span></span><br><span class="line"><span class="comment">// two</span></span><br><span class="line"><span class="comment">// three</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>setTimeout(fn, 0)</code>在下一轮“事件循环”开始时执行，<code>resolve()</code>在本轮“事件循环”结束时执行，<code>console.log(&#39;one&#39;)</code>则是立即执行，因此最先输出。</p><hr><h3 id="16-12-reject-方法"><a href="#16-12-reject-方法" class="headerlink" title="16.12 reject 方法"></a>16.12 reject 方法</h3><p><code>Promise.reject(reason)</code>方法也会返回一个新的 <code>Promise</code> 实例，该实例的状态为<code>rejected</code>。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="string">&quot;出错了&quot;</span>);</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="title function_">reject</span>(<span class="string">&quot;出错了&quot;</span>));</span><br><span class="line"></span><br><span class="line">p.<span class="title function_">then</span>(<span class="literal">null</span>, <span class="keyword">function</span> (<span class="params">s</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(s);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 出错了</span></span><br></pre></td></tr></table></figure><p><code>Promise.reject()</code>方法的参数，会原封不动地作为<code>reject</code>的理由，变成后续方法的参数。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="string">&quot;出错了&quot;</span>).<span class="title function_">catch</span>(<span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(e === <span class="string">&quot;出错了&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure><hr><h2 id="17-Iterator-和-for…of-循环"><a href="#17-Iterator-和-for…of-循环" class="headerlink" title="17. Iterator 和 for…of 循环"></a>17. Iterator 和 for…of 循环</h2><h3 id="17-1-Iterator-概念"><a href="#17-1-Iterator-概念" class="headerlink" title="17.1 Iterator 概念"></a>17.1 Iterator 概念</h3><p>遍历器<code>Iterator</code>是一种接口，<ins>为各种不同的数据结构提供统一的访问机制</ins>。任何数据结构只要部署 <code>Iterator</code> 接口，就可以完成遍历操作，依次处理该数据结构的所有成员。<br><br></p><p><code>Iterator</code> 的遍历过程</p><ol><li>创建一个指针对象，指向当前数据结构的起始位置。</li><li>第一次调用指针对象的<code>next</code>方法，可以将指针指向数据结构的第一个成员。</li><li>第二次调用指针对象的<code>next</code>方法，指针就指向数据结构的第二个成员。</li><li>不断调用指针对象的<code>next</code>方法，直到它指向数据结构的结束位置。</li></ol><p>每一次调用<code>next</code>方法，都会返回数据结构的当前成员的信息。具体来说，就是返回一个包含<code>value</code>和<code>done</code>两个属性的对象。其中，<ins><code>value</code>属性是当前成员的值，<code>done</code>属性是一个布尔值，表示遍历是否结束</ins>。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = [<span class="number">1</span>, <span class="number">5</span>, <span class="number">15</span>, <span class="number">25</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> it = a[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]();</span><br><span class="line"></span><br><span class="line">it.<span class="title function_">next</span>().<span class="property">value</span>; <span class="comment">// 1</span></span><br><span class="line">it.<span class="title function_">next</span>().<span class="property">value</span>; <span class="comment">// 5</span></span><br><span class="line">it.<span class="title function_">next</span>().<span class="property">value</span>; <span class="comment">// 15</span></span><br></pre></td></tr></table></figure><p><code>ES6</code> 规定，默认的 <code>Iterator</code> 接口部署在数据结构的<code>Symbol.iterator</code>属性，或者说，一个数据结构只要具有<code>Symbol.iterator</code>属性，就可以认为是“可遍历的”。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">numbers</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">  [<span class="title class_">Symbol</span>.<span class="property">iterator</span>]: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> self = <span class="variable language_">this</span>;</span><br><span class="line">    <span class="keyword">let</span> idx = -<span class="number">1</span>; <span class="comment">// &lt;--- 抵消 ++ 的 side-effect</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">next</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        idx++;</span><br><span class="line">        <span class="comment">// 可以尝试 log 出下面的 object</span></span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">          <span class="attr">value</span>: self.<span class="property">numbers</span>[idx],</span><br><span class="line">          <span class="attr">done</span>: idx &gt;= self.<span class="property">numbers</span>.<span class="property">length</span>,</span><br><span class="line">        &#125;;</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> num <span class="keyword">of</span> obj) <span class="variable language_">console</span>.<span class="title function_">log</span>(num); <span class="comment">// 1 2 3</span></span><br></pre></td></tr></table></figure><p>上面代码中，对象<code>obj</code>是可遍历的，因为具有<code>Symbol.iterator</code>属性。执行这个属性，会返回一个遍历器对象。该对象的根本特征就是具有<code>next</code>方法。每次调用<code>next</code>方法，都会返回一个代表当前成员的信息对象，具有<code>value</code>和<code>done</code>两个属性。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 上面 iterator 打印出来的 objects</span></span><br><span class="line">&#123; <span class="attr">value</span>: <span class="number">1</span>, <span class="attr">done</span>: <span class="literal">false</span> &#125;</span><br><span class="line">&#123; <span class="attr">value</span>: <span class="number">2</span>, <span class="attr">done</span>: <span class="literal">false</span> &#125;</span><br><span class="line">&#123; <span class="attr">value</span>: <span class="number">3</span>, <span class="attr">done</span>: <span class="literal">false</span> &#125;</span><br><span class="line">&#123; <span class="attr">value</span>: <span class="literal">undefined</span>, <span class="attr">done</span>: <span class="literal">true</span> &#125;</span><br></pre></td></tr></table></figure><p>注意，<code>done</code> 不代表返回的值是否是最后一个，而是表示迭代器是否没有更多的值可以返回。</p><hr><h3 id="17-2-for…of-循环"><a href="#17-2-for…of-循环" class="headerlink" title="17.2 for…of 循环"></a>17.2 for…of 循环</h3><p><strong>（1）数组，Set 与 Map</strong></p><p><code>ES6</code> 的数组，<code>Set</code> 和 <code>Map</code> 原生具有 <code>Iterator</code> 接口。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;green&quot;</span>, <span class="string">&quot;blue&quot;</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> color <span class="keyword">of</span> arr) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(color);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// red green blue</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>(arr);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> color <span class="keyword">of</span> set) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(color);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// red green blue</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>().<span class="title function_">set</span>(<span class="string">&quot;a&quot;</span>, <span class="number">1</span>).<span class="title function_">set</span>(<span class="string">&quot;b&quot;</span>, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> pair <span class="keyword">of</span> map) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(pair);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// [&#x27;a&#x27;, 1]</span></span><br><span class="line"><span class="comment">// [&#x27;b&#x27;, 2]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> map) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(key + <span class="string">&quot; : &quot;</span> + value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// a : 1</span></span><br><span class="line"><span class="comment">// b : 2</span></span><br></pre></td></tr></table></figure><p>上面代码可以看出，<code>Set</code> 和 <code>Map</code> 遍历的顺序是按照各个成员被添加进数据结构的顺序。<br><br></p><p><strong>（2）计算生成的数据结构</strong></p><p>有些数据结构是在现有数据结构的基础上，计算生成的。比如，<code>ES6</code> 的数组、<code>Set</code>、<code>Map</code> 都部署了以下三个方法，调用后都返回遍历器对象。</p><ul><li><code>entries()</code> 返回一个遍历器对象，用来遍历[键名, 键值]组成的数组。</li><li><code>keys()</code> 返回一个遍历器对象，用来遍历所有的键名。</li><li><code>values()</code> 返回一个遍历器对象，用来遍历所有的键值。</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> pair <span class="keyword">of</span> arr.<span class="title function_">entries</span>()) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(pair);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// [0, &#x27;a&#x27;]</span></span><br><span class="line"><span class="comment">// [1, &#x27;b&#x27;]</span></span><br><span class="line"><span class="comment">// [2, &#x27;c&#x27;]</span></span><br></pre></td></tr></table></figure><p><strong>（3）类似数组的对象</strong></p><p>字符串是一个类似数组的对象，也原生具有 <code>Iterator</code> 接口。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 字符串</span></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> s <span class="keyword">of</span> str) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(s); <span class="comment">// h e l l o</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// arguments对象</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">printArgs</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">of</span> <span class="variable language_">arguments</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">printArgs</span>(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>);</span><br><span class="line"><span class="comment">// &#x27;a&#x27;</span></span><br><span class="line"><span class="comment">// &#x27;b&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>（4）对象</strong></p><p><code>for...of</code>不能直接使用于普通对象上，必须部署 <code>Iterator</code> 接口后才能使用。</p><ul><li>一种解决方法是，遍历<code>Object.keys()</code>生成的对象键名的数组。</li><li>一种解决方法是，使用 <code>Generator</code> 函数将对象重新包装。</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">c</span>: <span class="number">3</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方案一</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> <span class="title class_">Object</span>.<span class="title function_">keys</span>(obj)) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(key, <span class="string">&quot;-&gt;&quot;</span>, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方案二</span></span><br><span class="line"><span class="keyword">function</span>* <span class="title function_">entries</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> <span class="title class_">Object</span>.<span class="title function_">keys</span>(obj)) &#123;</span><br><span class="line">    <span class="keyword">yield</span> [key, obj[key]];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> <span class="title function_">entries</span>(obj)) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(key, <span class="string">&quot;-&gt;&quot;</span>, value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// a -&gt; 1</span></span><br><span class="line"><span class="comment">// b -&gt; 2</span></span><br><span class="line"><span class="comment">// c -&gt; 3</span></span><br></pre></td></tr></table></figure><hr><h2 id="18-Generator-函数"><a href="#18-Generator-函数" class="headerlink" title="18. Generator 函数"></a>18. Generator 函数</h2><h3 id="18-1-基本概念"><a href="#18-1-基本概念" class="headerlink" title="18.1 基本概念"></a>18.1 基本概念</h3><p><code>Generator</code> 函数是 <code>ES6</code> 提供的一种异步编程解决方案，语法行为与传统函数完全不同。</p><ul><li><strong>语法上：</strong><ins><code>Generator</code> 函数类似一个状态机，封装了多个内部状态</ins>。执行 <code>Generator</code> 函数会返回一个遍历器对象，<ins>可以依次遍历 <code>Generator</code> 函数内部的每一个状态</ins>。</li><li><strong>形式上：</strong><code>Generator</code> 函数是一个普通函数，但是有两个特征。一是，<code>function</code>关键字与函数名之间有一个星号；二是，函数体内部使用<code>yield</code>表达式，定义不同的内部状态。</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">hwGenerator</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&quot;world&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;ending&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> hw = <span class="title function_">hwGenerator</span>();</span><br></pre></td></tr></table></figure><p>上面代码定义了一个 <code>Generator</code> 函数<code>hwGenerator</code>，它内部有两个<code>yield</code>表达式<code>hello</code>和<code>world</code>，即该函数有三个状态：<code>hello</code>，<code>world</code> 和 <code>return</code> 语句。<br><br></p><p><code>Generator</code> 函数的调用方法与普通函数一样。不同的是，<ins>调用 <code>Generator</code> 函数后，该函数并不执行，返回的也不是函数运行结果，而是一个指向内部状态的指针对象</ins>。通过调用遍历器对象的<code>next</code>方法，<ins>使得指针移向下一个状态</ins>。<br><br></p><p>每次调用<code>next</code>方法，内部指针就从函数头部或上一次停下来的地方开始执行，直到遇到下一个<code>yield</code>表达式（或<code>return</code>语句）为止。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">hw.<span class="title function_">next</span>();</span><br><span class="line"><span class="comment">// &#123; value: &#x27;hello&#x27;, done: false &#125;</span></span><br><span class="line"></span><br><span class="line">hw.<span class="title function_">next</span>();</span><br><span class="line"><span class="comment">// &#123; value: &#x27;world&#x27;, done: false &#125;</span></span><br><span class="line"></span><br><span class="line">hw.<span class="title function_">next</span>();</span><br><span class="line"><span class="comment">// &#123; value: &#x27;ending&#x27;, done: true &#125;</span></span><br><span class="line"></span><br><span class="line">hw.<span class="title function_">next</span>();</span><br><span class="line"><span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure><p>总结，调用 <code>Generator</code> 函数，返回一个遍历器对象，代表 <code>Generator</code> 函数的内部指针。每次调用遍历器对象的<code>next</code>方法，就会返回一个有着<code>value</code>和<code>done</code>两个属性的对象。<code>value</code>属性表示当前的内部状态的值，是<code>yield</code>表达式后面那个表达式的值；<code>done</code>属性是一个布尔值，表示是否遍历结束。</p><hr><h3 id="18-2-yield-表达式"><a href="#18-2-yield-表达式" class="headerlink" title="18.2 yield 表达式"></a>18.2 yield 表达式</h3><p>由于 <code>Generator</code> 函数返回的<ins>遍历器对象，只有调用<code>next</code>方法才会遍历下一个内部状态</ins>，所以<code>Generator</code>其实<ins>提供了一种可以暂停执行的函数</ins>。<code>yield</code>表达式就是暂停标志。<br><br></p><p>遍历器对象的<code>next</code>方法的运行逻辑如下</p><ul><li><ins>遇到<code>yield</code>表达式，就暂停执行后面的操作，并将紧跟在<code>yield</code>后面的那个表达式的值，作为返回的对象的<code>value</code>属性值</ins>。</li><li>下一次调用<code>next</code>方法时，再继续往下执行，直到遇到下一个<code>yield</code>表达式。</li><li>如果没有再遇到新的<code>yield</code>表达式，就一直运行到函数结束，直到<code>return</code>语句为止，并将<code>return</code>语句后面的表达式的值，作为返回的对象的<code>value</code>属性值。</li><li>如果该函数没有<code>return</code>语句，则返回的对象的<code>value</code>属性值为<code>undefined</code>。</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">gen</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">123</span> + <span class="number">456</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> g = <span class="title function_">gen</span>();</span><br><span class="line">g.<span class="title function_">next</span>(); <span class="comment">// &#123;value: 579, done: false&#125;</span></span><br><span class="line">g.<span class="title function_">next</span>(); <span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure><p><code>yield</code>表达式与<code>return</code>语句既有相似之处，也有区别。相似之处在于，都能返回紧跟在语句后面的那个表达式的值。<ins>区别在于每次遇到<code>yield</code>，函数暂停执行，下一次再从该位置继续向后执行，而<code>return</code>语句不具备位置记忆的功能</ins>。一个函数里面，只能执行一次<code>return</code>语句，但是可以执行多次<code>yield</code>表达式。</p><hr><h3 id="18-3-与-Iterator-接口的关系"><a href="#18-3-与-Iterator-接口的关系" class="headerlink" title="18.3 与 Iterator 接口的关系"></a>18.3 与 Iterator 接口的关系</h3><p>由于 <code>Generator</code> 函数就是遍历器生成函数，因此可以把 <code>Generator</code> 赋值给对象的<code>Symbol.iterator</code>属性，从而使得该对象具有 <code>Iterator</code> 接口。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> myIterable = &#123;&#125;;</span><br><span class="line">myIterable[<span class="title class_">Symbol</span>.<span class="property">iterator</span>] = <span class="keyword">function</span>* () &#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">[...myIterable]; <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>Generator</code> 函数赋值给<code>Symbol.iterator</code>属性，从而使得<code>myIterable</code>对象具有了 <code>Iterator</code> 接口，可以被<code>...</code>运算符遍历了。</p><hr><h3 id="18-4-next-方法的参数"><a href="#18-4-next-方法的参数" class="headerlink" title="18.4 next 方法的参数"></a>18.4 next 方法的参数</h3><p><code>yield</code>表达式本身没有返回值，或者说总是返回<code>undefined</code>。<code>next</code>方法可以带一个参数，<ins>该参数就会被当作上一个<code>yield</code>表达式的返回值</ins>。（每一次调用<code>next</code>方法，都会返回数据结构的当前成员的信息）<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; <span class="literal">true</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> reset = <span class="keyword">yield</span> i;</span><br><span class="line">    <span class="keyword">if</span> (reset) &#123;</span><br><span class="line">      i = -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> g = <span class="title function_">f</span>(); <span class="comment">// 启动</span></span><br><span class="line"></span><br><span class="line">g.<span class="title function_">next</span>(); <span class="comment">// &#123; value: 0, done: false &#125;</span></span><br><span class="line">g.<span class="title function_">next</span>(); <span class="comment">// &#123; value: 1, done: false &#125;</span></span><br><span class="line">g.<span class="title function_">next</span>(<span class="literal">true</span>); <span class="comment">// &#123; value: 0, done: false &#125;</span></span><br><span class="line"><span class="comment">// 此时 rest 为 true，所以 i = -1，又因为 i++，</span></span><br><span class="line"><span class="comment">// 所以下一次运行到 yield i 的时候 i 就是 0</span></span><br></pre></td></tr></table></figure><p>上面代码定义了一个可以无限运行的 <code>Generator</code> 函数<code>f</code>，如果<code>next</code>方法没有参数，每次运行到<code>yield</code>表达式，变量<code>reset</code>的值总是<code>undefined</code>。当<code>next</code>方法带一个参数<code>true</code>时，变量<code>reset</code>就被重置为这个参数，因此<code>i</code>会等于<code>-1</code>，下一轮循环就会从<code>-1</code>开始递增。<br><br></p><p>这个功能有很重要的意义。<code>Generator</code> 函数从暂停状态到恢复运行，它的上下文状态<code>context</code>是不变的。通过<code>next</code>方法的参数，就有办法在 <code>Generator</code> 函数开始运行之后，继续向函数体内部注入值。<ins>从而在 <code>Generator</code> 函数运行的不同阶段，调整函数行为</ins>。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">foo</span>(<span class="params">x</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> y = <span class="number">2</span> * (<span class="keyword">yield</span> x + <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">let</span> z = <span class="keyword">yield</span> y / <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">return</span> x + y + z;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="title function_">foo</span>(<span class="number">5</span>);</span><br><span class="line">a.<span class="title function_">next</span>(); <span class="comment">// &#123; value:6, done:false &#125;</span></span><br><span class="line">a.<span class="title function_">next</span>(); <span class="comment">// 此时 y 为 undefined, &#123; value:NaN, done:false &#125;</span></span><br><span class="line">a.<span class="title function_">next</span>(); <span class="comment">// 此时 z 为 undefined, &#123; value:NaN, done:true &#125;</span></span><br></pre></td></tr></table></figure><p>上面代码中，第二次运行<code>next()</code>的时候不带参数，导致 <code>y</code> 的值等于<code>2 * undefined</code>，除以 <code>3</code> 以后变成<code>NaN</code>，因此返回对象的<code>value</code>属性也等于<code>NaN</code>。第三次运行<code>next</code>方法的时候不带参数，所以<code>z</code>等于<code>undefined</code>，返回对象的<code>value</code>属性等于<code>5 + NaN + undefined</code>，即<code>NaN</code>。<br><br></p><p>如果向<code>next</code>方法提供参数，返回结果就完全不一样。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> b = <span class="title function_">foo</span>(<span class="number">5</span>);</span><br><span class="line">b.<span class="title function_">next</span>(); <span class="comment">// &#123; value:6, done:false &#125;</span></span><br><span class="line">b.<span class="title function_">next</span>(<span class="number">12</span>); <span class="comment">// 此时 y 为 24, 因为 yield (x + 1) = 12, &#123; value:8, done:false &#125;</span></span><br><span class="line">b.<span class="title function_">next</span>(<span class="number">13</span>); <span class="comment">// 此时 z 为 13, 因为 yield (y / 3) = 13, &#123; value:42, done:true &#125;</span></span><br></pre></td></tr></table></figure><p>上面代码第一次调用<code>next</code>方法时，返回<code>x+1</code>的值<code>6</code>；第二次调用<code>next</code>方法，将上一次<code>yield</code>表达式的值设为<code>12</code>，因此<code>y</code>等于<code>24</code>，返回<code>y / 3</code>的值<code>8</code>；第三次调用<code>next</code>方法，将上一次<code>yield</code>表达式的值设为<code>13</code>，因此<code>z</code>等于<code>13</code>，这时<code>x</code>等于<code>5</code>，<code>y</code>等于<code>24</code>，所以<code>return</code>语句的值等于<code>42</code>。<br><br></p><p>注意，由于<code>next</code>方法的参数表示上一个<code>yield</code>表达式的返回值，所以在第一次使用<code>next</code>方法时，传递参数是无效的。</p><hr><h3 id="18-5-for…of-循环"><a href="#18-5-for…of-循环" class="headerlink" title="18.5 for…of 循环"></a>18.5 for…of 循环</h3><p><code>for...of</code>可以自动遍历 <code>Generator</code> 函数生成的<code>Iterator</code>对象，且不需要调用<code>next</code>方法。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> v <span class="keyword">of</span> <span class="title function_">foo</span>()) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1 2 3 (没有4)</span></span><br></pre></td></tr></table></figure><p>上面的代码可以看出，一旦返回对象的<code>done</code>属性为<code>true</code>，<code>for...of</code>循环就会中止，且不包含该返回对象。所以上面代码的<code>return</code>语句返回的<code>4</code>，不包括在<code>for...of</code>循环之中。<br><br></p><p>除了<code>for...of</code>循环以外，扩展运算符、解构赋值和<code>Array.from</code>方法内部调用的，都是遍历器接口。这意味着，它们都可以将 <code>Generator</code> 函数返回的遍历器对象，作为参数。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">numbers</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩展运算符</span></span><br><span class="line">[...<span class="title function_">numbers</span>()]; <span class="comment">// [1, 2]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Array.from 方法</span></span><br><span class="line"><span class="title class_">Array</span>.<span class="title function_">from</span>(<span class="title function_">numbers</span>()); <span class="comment">// [1, 2]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 解构赋值</span></span><br><span class="line"><span class="keyword">let</span> [x, y] = <span class="title function_">numbers</span>();</span><br><span class="line">x; <span class="comment">// 1</span></span><br><span class="line">y; <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><hr><h3 id="18-6-throw-方法"><a href="#18-6-throw-方法" class="headerlink" title="18.6 throw 方法"></a>18.6 throw 方法</h3><p>遍历器对象的<code>throw()</code>方法，可以<ins>在函数体外抛出错误，然后在 <code>Generator</code> 函数体内捕获</ins>。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> g = <span class="keyword">function</span>* () &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">yield</span>;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;内部捕获&quot;</span>, e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> i = <span class="title function_">g</span>();</span><br><span class="line">i.<span class="title function_">next</span>(); <span class="comment">// 初始化启动</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  i.<span class="keyword">throw</span>(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">  i.<span class="keyword">throw</span>(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;外部捕获&quot;</span>, e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 内部捕获 a</span></span><br><span class="line"><span class="comment">// 外部捕获 b</span></span><br></pre></td></tr></table></figure><p>上面代码中，遍历器对象<code>i</code>连续抛出两个错误。<ins>第一个错误被 <code>Generator</code> 函数体内的<code>catch</code>语句捕获</ins>。<code>i</code>第二次抛出错误，由于 <code>Generator</code> 函数内部的<code>catch</code>语句已经执行过了，不会再捕捉到这个错误了，所以这个错误就<ins>被函数体外的<code>catch</code>语句捕获</ins>。<br><br></p><p>注意，不要混淆遍历器对象的<code>throw</code>方法和全局的<code>throw</code>命令。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;外部捕获&quot;</span>, e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 外部捕获 [Error: a]</span></span><br></pre></td></tr></table></figure><p>上面代码之所以只捕获了<code>a</code>，是因为函数体外的<code>catch</code>语句块，捕获了抛出的<code>a</code>错误以后，就不会再继续<code>try</code>代码块里面剩余的语句了。</p><ul><li>如果 <code>Generator</code> 函数内部没有部署<code>try...catch</code>代码块，那么<code>throw</code>方法抛出的错误，<ins>将被外部<code>try...catch</code>代码块捕获</ins>。</li><li>如果 <code>Generator</code> 函数内部和外部，都没有部署<code>try...catch</code>代码块，那么程序将报错，直接中断执行。</li></ul><p><code>throw</code>方法抛出的错误要被内部捕获，<ins>前提是必须至少执行过一次<code>next</code>方法</ins>。同时，<ins><code>throw</code>方法被捕获后，会附带执行下一条<code>yield</code>表达式</ins>，等同于执行一次<code>next</code>方法。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> gen = <span class="keyword">function</span>* <span class="title function_">gen</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">yield</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">  <span class="keyword">yield</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> g = <span class="title function_">gen</span>();</span><br><span class="line">g.<span class="title function_">next</span>(); <span class="comment">// a</span></span><br><span class="line">g.<span class="keyword">throw</span>(); <span class="comment">// b</span></span><br><span class="line">g.<span class="title function_">next</span>(); <span class="comment">// c</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>g.throw()</code>方法被捕获以后，自动执行了一次<code>next</code>方法，所以会打印<code>b</code>。这里可以看出，<ins>只要 <code>Generator</code> 函数内部部署了<code>try...catch</code>代码块，那么遍历器的<code>throw</code>方法抛出的错误，不影响下一次遍历</ins>。<br><br></p><p><code>Generator</code> 函数体外抛出的错误，可以在函数体内捕获；反过来，<code>Generator</code> 函数体内抛出的错误，也可以被函数体外的<code>catch</code>捕获。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> x = <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">let</span> y = x.<span class="title function_">toUpperCase</span>();</span><br><span class="line">  <span class="keyword">yield</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> it = <span class="title function_">foo</span>();</span><br><span class="line"></span><br><span class="line">it.<span class="title function_">next</span>(); <span class="comment">// &#123; value:3, done:false &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  it.<span class="title function_">next</span>(<span class="number">42</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(err);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，第二个<code>next</code>方法向函数体内传入一个参数 <code>42</code>，数值是没有<code>toUpperCase</code>方法的，所以会抛出一个 <code>TypeError</code> 错误，被函数体外的<code>catch</code>捕获。</p><hr><h3 id="18-7-return-方法"><a href="#18-7-return-方法" class="headerlink" title="18.7 return 方法"></a>18.7 return 方法</h3><p>遍历器对象的<code>return()</code>方法，可以返回给定的值，并且<ins>终结遍历 <code>Generator</code> 函数</ins>。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">gen</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> g = <span class="title function_">gen</span>();</span><br><span class="line"></span><br><span class="line">g.<span class="title function_">next</span>(); <span class="comment">// &#123; value: 1, done: false &#125;</span></span><br><span class="line">g.<span class="keyword">return</span>(<span class="string">&quot;foo&quot;</span>); <span class="comment">// &#123; value: &quot;foo&quot;, done: true &#125;</span></span><br><span class="line">g.<span class="title function_">next</span>(); <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure><p>上面代码中，遍历器对象<code>g</code>调用<code>return()</code>方法后，返回值的<code>value</code>属性就是<code>return()</code>方法的参数<code>foo</code>。并且，<code>Generator</code> 函数的遍历就终止了，返回值的<code>done</code>属性为<code>true</code>。</p><ul><li>如果<code>return()</code>方法调用时，不提供参数，则返回值的<code>value</code>属性为<code>undefined</code>。</li><li>如果 <code>Generator</code> 函数内部有<code>try...finally</code>代码块，且正在执行<code>try</code>代码块，那么<code>return()</code>方法会导致立刻进入<code>finally</code>代码块。</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">numbers</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">5</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">6</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> g = <span class="title function_">numbers</span>();</span><br><span class="line">g.<span class="title function_">next</span>(); <span class="comment">// &#123; value: 1, done: false &#125;</span></span><br><span class="line">g.<span class="title function_">next</span>(); <span class="comment">// &#123; value: 2, done: false &#125;</span></span><br><span class="line">g.<span class="keyword">return</span>(<span class="number">7</span>); <span class="comment">// &#123; value: 4, done: false &#125;</span></span><br><span class="line">g.<span class="title function_">next</span>(); <span class="comment">// &#123; value: 5, done: false &#125;</span></span><br><span class="line">g.<span class="title function_">next</span>(); <span class="comment">// &#123; value: 7, done: true &#125;</span></span><br></pre></td></tr></table></figure><p>上面代码中，调用<code>return()</code>方法后，就开始执行<code>finally</code>代码块，不执行<code>try</code>里面剩下的代码了，然后等到<code>finally</code>代码块执行完，再返回<code>return()</code>方法指定的返回值。</p><hr><h3 id="18-8-方法的共同点"><a href="#18-8-方法的共同点" class="headerlink" title="18.8 方法的共同点"></a>18.8 方法的共同点</h3><p><code>Generator</code> 函数返回的遍历器对象的<code>next()</code>、<code>throw()</code>、<code>return()</code>本质上是同一件事，它们的作用都是让 <code>Generator</code> 函数恢复执行，并且使用不同的语句替换<code>yield</code>表达式。</p><ul><li><code>next()</code>方法是将<code>yield</code>表达式替换成一个值。</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> g = <span class="keyword">function</span>* (x, y) &#123;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="keyword">yield</span> x + y;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> gen = <span class="title function_">g</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">gen.<span class="title function_">next</span>(); <span class="comment">// Object &#123;value: 3, done: false&#125;</span></span><br><span class="line"></span><br><span class="line">gen.<span class="title function_">next</span>(<span class="number">1</span>); <span class="comment">// Object &#123;value: 1, done: true&#125;</span></span><br><span class="line"><span class="comment">// 相当于将 let result = yield x + y</span></span><br><span class="line"><span class="comment">// 替换成 let result = 1;</span></span><br></pre></td></tr></table></figure><ul><li><code>throw()</code>方法是将<code>yield</code>表达式替换成一个<code>throw</code>语句。</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">gen.<span class="keyword">throw</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;出错了&quot;</span>)); <span class="comment">// Uncaught Error: 出错了</span></span><br><span class="line"><span class="comment">// 相当于将 let result = yield x + y</span></span><br><span class="line"><span class="comment">// 替换成 let result = throw(new Error(&#x27;出错了&#x27;));</span></span><br></pre></td></tr></table></figure><ul><li><code>return()</code>方法是将<code>yield</code>表达式替换成一个<code>return</code>语句。</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">gen.<span class="keyword">return</span>(<span class="number">2</span>); <span class="comment">// Object &#123;value: 2, done: true&#125;</span></span><br><span class="line"><span class="comment">// 相当于将 let result = yield x + y</span></span><br><span class="line"><span class="comment">// 替换成 let result = return 2;</span></span><br></pre></td></tr></table></figure><hr><h3 id="18-9-yield-表达式"><a href="#18-9-yield-表达式" class="headerlink" title="18.9 yield* 表达式"></a>18.9 yield* 表达式</h3><p><code>ES6</code> 提供的<code>yield*</code>表达式，可以在一个 <code>Generator</code> 函数里面执行另一个 <code>Generator</code> 函数。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> delegatedIterator = (<span class="keyword">function</span>* () &#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&quot;Hello!&quot;</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&quot;Bye!&quot;</span>;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> delegatingIterator = (<span class="keyword">function</span>* () &#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&quot;Greetings!&quot;</span>;</span><br><span class="line">  <span class="keyword">yield</span>* delegatedIterator;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&quot;Ok, bye.&quot;</span>;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> delegatingIterator) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &quot;Greetings!</span></span><br><span class="line"><span class="comment">// &quot;Hello!&quot;</span></span><br><span class="line"><span class="comment">// &quot;Bye!&quot;</span></span><br><span class="line"><span class="comment">// &quot;Ok, bye.&quot;</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>delegatingIterator</code>是代理者，<code>delegatedIterator</code>是被代理者。如果被代理的 <code>Generator</code> 函数有<code>return</code>语句，那么就可以向代理它的 <code>Generator</code> 函数返回数据。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">genFuncWithReturn</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&quot;a&quot;</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&quot;b&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;The result&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span>* <span class="title function_">logReturned</span>(<span class="params">genObj</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="keyword">yield</span>* genObj;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[...<span class="title function_">logReturned</span>(<span class="title function_">genFuncWithReturn</span>())];</span><br><span class="line"><span class="comment">// The result</span></span><br><span class="line"><span class="comment">// 值为 [ &#x27;a&#x27;, &#x27;b&#x27; ]</span></span><br></pre></td></tr></table></figure><p>上面代码中，存在两次遍历。</p><ul><li>第一次是扩展运算符遍历函数<code>logReturned</code>返回的遍历器对象。</li><li>第二次是<code>yield*</code>语句遍历函数<code>genFuncWithReturn</code>返回的遍历器对象。</li></ul><p>这两次遍历的效果是叠加的，最终表现为扩展运算符遍历函数<code>genFuncWithReturn</code>返回的遍历器对象。所以最后的数据表达式得到的值等于<code>[ &#39;a&#39;, &#39;b&#39; ]</code>。同时，函数<code>genFuncWithReturn</code>的<code>return</code>语句的返回值<code>The result</code>，会返回给函数<code>logReturned</code>内部的<code>result</code>变量。</p><hr><h3 id="18-10-作为对象的属性"><a href="#18-10-作为对象的属性" class="headerlink" title="18.10 作为对象的属性"></a>18.10 作为对象的属性</h3><p>如果一个对象的属性是 <code>Generator</code> 函数，可以简写成下面的形式。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  * <span class="title function_">myGeneratorMethod</span>(<span class="params"></span>) &#123;</span><br><span class="line">    ···</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>它的完整形式如下，与上面的写法是等价的。（详细请见上一章的属性的简洁表示法）<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">myGeneratorMethod</span>: <span class="keyword">function</span>* () &#123;</span><br><span class="line">    <span class="comment">// ···</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h3 id="18-11-含义"><a href="#18-11-含义" class="headerlink" title="18.11 含义"></a>18.11 含义</h3><p><strong>（1）Generator 与状态机</strong></p><p><code>Generator</code> 是实现状态机的最佳结构。比如，下面的<code>clock</code>函数就是一个状态机。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> ticking = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">let</span> clock = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (ticking) <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Tick!&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Tock!&quot;</span>);</span><br><span class="line">  ticking = !ticking;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面代码的<code>clock</code>函数一共有两种状态<code>Tick</code>和<code>Tock</code>，每运行一次，就改变一次状态。这个函数如果用 <code>Generator</code> 实现，就是下面这样。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> clock = <span class="keyword">function</span>* () &#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Tick!&quot;</span>);</span><br><span class="line">    <span class="keyword">yield</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Tock!&quot;</span>);</span><br><span class="line">    <span class="keyword">yield</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面的 <code>Generator</code> 实现与 <code>ES5</code> 实现对比，可以看到少了用来保存状态的外部变量<code>ticking</code>，这样就更简洁，更安全，在写法上也更优雅。<br><br></p><p><strong>（2）Generator 与协程</strong></p><p>协程 <code>coroutine</code> 是一种程序运行的方式，可以理解成“协作的线程”或“协作的函数”。协程既可以用单线程实现，也可以用多线程实现。</p><ul><li><p><strong>协程与子例程的差异</strong><br>传统的“子例程” <code>subroutine</code> 采用堆栈式“后进先出”的执行方式，只有当调用的子函数完全执行完毕，才会结束执行父函数。<ins>协程与其不同，多个线程（单线程情况下，即多个函数）可以并行执行，但是只有一个线程（或函数）处于正在运行的状态，其他线程（或函数）都处于暂停态 <code>suspended</code>，线程（或函数）之间可以交换执行权</ins>。这种可以并行执行、交换执行权的线程（或函数），就称为协程。</p></li><li><p><strong>协程与普通线程的差异</strong><br>协程适合用于多任务运行的环境。在这个意义上，它与普通的线程很相似，都有自己的执行上下文、可以分享全局变量。它们的不同之处在于，<ins>同一时间可以有多个线程处于运行状态，但是运行的协程只能有一个，其他协程都处于暂停状态</ins>。此外，<ins>普通的线程是抢先式的，到底哪个线程优先得到资源，必须由运行环境决定，但是协程是合作式的，执行权由协程自己分配</ins>。</p></li></ul><p><code>Generator</code> 函数是 <code>ES6</code> 对协程的实现，<ins>但属于不完全实现</ins>。<code>Generator</code> 函数被称为“半协程”，意思是只有 <code>Generator</code> 函数的调用者，才能将程序的执行权还给 <code>Generator</code> 函数。如果是完全实现的协程，任何函数都可以让暂停的协程继续执行。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">A</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;我是A&quot;</span>);</span><br><span class="line">  <span class="keyword">yield</span> <span class="title function_">B</span>(); <span class="comment">// A停住，在这里转交线程执行权给B</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;结束了&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">B</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;我是B&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">100</span>; <span class="comment">// 返回，并且将线程执行权还给A</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> gen = <span class="title function_">A</span>();</span><br><span class="line">gen.<span class="title function_">next</span>();</span><br><span class="line">gen.<span class="title function_">next</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我是A</span></span><br><span class="line"><span class="comment">// 我是B</span></span><br><span class="line"><span class="comment">// 结束了</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>A</code>将执行权交给<code>B</code>，我们称<code>A</code>是<code>B</code>的父协程。那么现在<code>B</code>执行，<code>A</code>就相当于处于暂停的状态。等到<code>B</code>最后<code>return 100</code>，执行权就会还给<code>A</code>。<br><br></p><p><strong>（3）Generator 与上下文</strong></p><p>执行 <code>JS</code> 代码时，会产生一个全局的上下文环境，包含了当前所有的变量和对象。执行函数或块级代码时，又会<mark class="hl-label red">在当前上下文环境的上层</mark> ，产生一个 <mark class="hl-label blue">函数运行的上下文</mark> ，作为 <mark class="hl-label green">当前active的上下文</mark> ，由此形成一个上下文环境的堆栈。<br><br></p><p>这个堆栈是“后进先出”的数据结构，最后产生的上下文环境首先执行完成，退出堆栈，然后再执行完成它下层的上下文，直至所有代码执行完成，堆栈清空。<br><br></p><p><code>Generator</code> 函数不一样，它执行产生的上下文环境，一旦<ins>遇到<code>yield</code>命令，就会暂时退出堆栈，但是并不消失，里面的所有变量和对象会冻结在当前状态</ins>。等到对它执行<code>next</code>命令时，这个上下文环境又会重新加入调用栈，冻结的变量和对象恢复执行。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">gen</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> g = <span class="title function_">gen</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="title function_">next</span>().<span class="property">value</span>, g.<span class="title function_">next</span>().<span class="property">value</span>); <span class="comment">// 1, 2</span></span><br></pre></td></tr></table></figure><p>上面代码中，第一次执行<code>g.next()</code>时，<code>Generator</code> 函数<code>gen</code>的上下文会加入堆栈，即开始运行<code>gen</code>内部的代码。等遇到<code>yield 1</code>时，<code>gen</code>上下文退出堆栈，内部状态冻结。第二次执行<code>g.next()</code>时，<code>gen</code>上下文重新加入堆栈，变成当前的上下文，重新恢复执行。</p><hr><h3 id="18-12-应用"><a href="#18-12-应用" class="headerlink" title="18.12 应用"></a>18.12 应用</h3><p><strong>（1）异步操作的同步化表达</strong></p><p><code>Generator</code> 函数的暂停执行的效果，意味着<ins>可以把异步操作写在<code>yield</code>表达式里面</ins>，等到调用<code>next</code>方法时再往后执行。所以，<code>Generator</code> 函数的一个重要实际意义就是用来处理异步操作，改写回调函数。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">loadUI</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title function_">showLoadingScreen</span>();</span><br><span class="line">  <span class="keyword">yield</span> <span class="title function_">loadUIDataAsynchronously</span>();</span><br><span class="line">  <span class="title function_">hideLoadingScreen</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> loader = <span class="title function_">loadUI</span>();</span><br><span class="line"><span class="comment">// 加载UI</span></span><br><span class="line">loader.<span class="title function_">next</span>();</span><br><span class="line"><span class="comment">// 卸载UI</span></span><br><span class="line">loader.<span class="title function_">next</span>();</span><br></pre></td></tr></table></figure><p>上面代码中，第一次调用<code>loadUI</code>函数时，该函数不会执行，仅返回一个遍历器。下一次对该遍历器调用<code>next</code>方法，则会显示<code>Loading</code>界面，并且异步加载数据。等到数据加载完成，再一次使用<code>next</code>方法，则会隐藏<code>Loading</code>界面。<br><br></p><p><strong>（2）控制流管理</strong></p><p>如果有一个多步操作，采用回调函数，可能会写成下面这样。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">step1</span>(<span class="keyword">function</span> (<span class="params">value1</span>) &#123;</span><br><span class="line">  <span class="title function_">step2</span>(value1, <span class="keyword">function</span> (<span class="params">value2</span>) &#123;</span><br><span class="line">    <span class="title function_">step3</span>(value2, <span class="keyword">function</span> (<span class="params">value3</span>) &#123;</span><br><span class="line">      <span class="title function_">step4</span>(value3, <span class="keyword">function</span> (<span class="params">value4</span>) &#123;</span><br><span class="line">        <span class="comment">// Do something with value4</span></span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>采用 <code>Promise</code> 改写上面的代码。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>(step1)</span><br><span class="line">  .<span class="title function_">then</span>(step2)</span><br><span class="line">  .<span class="title function_">then</span>(step3)</span><br><span class="line">  .<span class="title function_">then</span>(step4)</span><br><span class="line">  .<span class="title function_">then</span>(</span><br><span class="line">    <span class="keyword">function</span> (<span class="params">value4</span>) &#123;</span><br><span class="line">      <span class="comment">// Do something with value4</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">function</span> (<span class="params">error</span>) &#123;</span><br><span class="line">      <span class="comment">// Handle any error from step1 through step4</span></span><br><span class="line">    &#125;</span><br><span class="line">  )</span><br><span class="line">  .<span class="title function_">done</span>();</span><br></pre></td></tr></table></figure><p>上面代码已经把回调函数，改成了直线执行的形式，但是加入了大量 <code>Promise</code> 的语法。<code>Generator</code> 函数可以进一步改善代码运行流程。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">longRunningTask</span>(<span class="params">value1</span>) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> value2 = <span class="keyword">yield</span> <span class="title function_">step1</span>(value1);</span><br><span class="line">    <span class="keyword">let</span> value3 = <span class="keyword">yield</span> <span class="title function_">step2</span>(value2);</span><br><span class="line">    <span class="keyword">let</span> value4 = <span class="keyword">yield</span> <span class="title function_">step3</span>(value3);</span><br><span class="line">    <span class="keyword">let</span> value5 = <span class="keyword">yield</span> <span class="title function_">step4</span>(value4);</span><br><span class="line">    <span class="comment">// Do something with value4</span></span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="comment">// Handle any error from step1 through step4</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，<ins>使用一个函数，按次序自动执行所有步骤</ins>。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">scheduler</span>(<span class="title function_">longRunningTask</span>(initialValue));</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">scheduler</span>(<span class="params">task</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> taskObj = task.<span class="title function_">next</span>(task.<span class="property">value</span>);</span><br><span class="line">  <span class="comment">// 如果Generator函数未结束，就继续调用</span></span><br><span class="line">  <span class="keyword">if</span> (!taskObj.<span class="property">done</span>) &#123;</span><br><span class="line">    task.<span class="property">value</span> = taskObj.<span class="property">value</span>;</span><br><span class="line">    <span class="title function_">scheduler</span>(task);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，上面这种做法，只适合同步操作，即所有的<code>task</code>都必须是同步的，不能有异步操作。因为这里的代码一得到返回值，就继续往下执行，没有判断异步操作何时完成。<br><br></p><p><strong>（3）控制流管理 II</strong></p><p>利用<code>for...of</code>循环会自动依次执行<code>yield</code>命令的特性，能提供一种更一般的控制流管理的方法。</p><p>首先，用数组<code>steps</code>封装了一个任务的多个步骤，并依次为这些步骤加上<code>yield</code>命令。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> steps = [step1Func, step2Func, step3Func];</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span>* <span class="title function_">iterateSteps</span>(<span class="params">steps</span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; steps.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> step = steps[i];</span><br><span class="line">    <span class="keyword">yield</span> <span class="title function_">step</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，将任务分解成步骤之后，还可以再将项目分解成多个依次执行的任务<code>jobs</code>。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> jobs = [job1, job2, job3];</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span>* <span class="title function_">iterateJobs</span>(<span class="params">jobs</span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; jobs.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> job = jobs[i];</span><br><span class="line">    <span class="keyword">yield</span>* <span class="title function_">iterateSteps</span>(job.<span class="property">steps</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，就可以用<code>for...of</code>循环一次性依次执行所有任务的所有步骤。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> step <span class="keyword">of</span> <span class="title function_">iterateJobs</span>(jobs)) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(step.<span class="property">id</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再次提醒，上面的做法只能用于所有步骤都是同步操作的情况，不能有异步操作的步骤。</p><hr><h2 id="19-Generator-函数异步应用"><a href="#19-Generator-函数异步应用" class="headerlink" title="19. Generator 函数异步应用"></a>19. Generator 函数异步应用</h2><h3 id="19-1-基本概念"><a href="#19-1-基本概念" class="headerlink" title="19.1 基本概念"></a>19.1 基本概念</h3><p><strong>（1）异步</strong></p><p>所谓”异步”，可以理解成一个任务被人为分成两段，先执行第一段，然后转而执行其他任务，等做好了准备，再回过头执行第二段</ins>。</p><ul><li>比如，有一个任务是读取文件进行处理，任务的第一段向操作系统发出请求，要求读取文件。然后，程序执行其他任务，等到操作系统返回文件，再接着执行任务的第二段处理文件。</li></ul><p>相应地，连续的执行就叫做同步。由于是连续执行，不能插入其他任务，所以操作系统从硬盘读取文件的这段时间，程序只能干等着。<br><br></p><p><strong>（2）回调函数</strong></p><p><code>JS</code> 语言对异步编程的实现，就是回调函数。所谓<ins>回调函数，就是把任务的第二段单独写在一个函数里面，等到重新执行这个任务的时候，就直接调用这个函数</ins>。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">fs.<span class="title function_">readFile</span>(<span class="string">&quot;/etc/passwd&quot;</span>, <span class="string">&quot;utf-8&quot;</span>, <span class="keyword">function</span> (<span class="params">err, data</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，<code>readFile</code>函数的第三个参数，就是回调函数，也就是任务的第二段。等到操作系统返回了<code>/etc/passwd</code>这个文件以后，回调函数才会执行。<br><br></p><p><strong>（3）Promise</strong></p><p>回调函数的问题出现在多个回调函数嵌套。假定读取<code>A</code>文件之后，再读取<code>B</code>文件。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">fs.<span class="title function_">readFile</span>(fileA, <span class="string">&quot;utf-8&quot;</span>, <span class="keyword">function</span> (<span class="params">err, data</span>) &#123;</span><br><span class="line">  fs.<span class="title function_">readFile</span>(fileB, <span class="string">&quot;utf-8&quot;</span>, <span class="keyword">function</span> (<span class="params">err, data</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>不难想象，如果依次读取两个以上的文件，就会出现多重嵌套。因为多个异步操作形成了强耦合，只要有一个操作需要修改，它的上层回调函数和下层回调函数，可能都要跟着修改。<br><br></p><p><code>Promise</code> 对象就是为了解决这个问题而提出的。它不是新的语法功能，而是一种新的写法，<ins>允许将回调函数的嵌套，改成链式调用</ins>。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> readFile = <span class="built_in">require</span>(<span class="string">&quot;fs-readfile-promise&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_">readFile</span>(fileA)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">data</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data.<span class="title function_">toString</span>());</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">readFile</span>(fileB);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">data</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data.<span class="title function_">toString</span>());</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="keyword">function</span> (<span class="params">err</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(err);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>上面代码中的<code>fs-readfile-promise</code>模块，返回一个 <code>Promise</code> 版本的<code>readFile</code>函数，并通过<code>then</code>方法加载回调函数，<code>catch</code>方法捕捉执行过程中抛出的错误。<br><br></p><p><code>Promise</code> 的写法只是回调函数的改进，使用<code>then</code>方法以后，异步任务的两段执行看得更清楚了。但是，<code>Promise</code> 的最大问题是代码冗余，原来的任务被 <code>Promise</code> 包装了一下，不管什么操作，一眼看去许多<code>then</code>，原来的语义变得很不清楚。<br><br></p><p><strong>（4）Generator 函数</strong></p><p>“协程” <code>coroutine</code>，是多个线程互相协作，完成异步任务。协程有点像函数，又有点像线程。它的运行流程大致如下：</p><ul><li>第一步，协程<code>A</code>开始执行。</li><li>第二步，<ins>协程<code>A</code>执行到一半，进入暂停，执行权转移到协程<code>B</code></ins>。</li><li>第三步，一段时间后，协程<code>B</code>交还执行权。</li><li>第四步，协程<code>A</code>恢复执行。</li></ul><p>上面流程的协程<code>A</code>，就是异步任务，因为它分成两段或多段执行。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">asyncJob</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// ...其他代码</span></span><br><span class="line">  <span class="keyword">let</span> f = <span class="keyword">yield</span> <span class="title function_">readFile</span>(fileA);</span><br><span class="line">  <span class="comment">// ...其他代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码的函数<code>asyncJob</code>是一个协程，它的奥妙就在其中的<code>yield</code>命令，<ins>表示执行到此处，执行权将交给其他协程。也就是说，<code>yield</code>命令是异步两个阶段的分界线</ins>。<br><br></p><p><code>Generator</code> 函数是协程在 <code>ES6</code> 的实现，最大特点就是可以交出函数的执行权（即暂停执行）。它是一个封装的异步任务，或者说是异步任务的容器。异步操作需要暂停的地方，都用<code>yield</code>语句注明。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">gen</span>(<span class="params">x</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> y = <span class="keyword">yield</span> x + <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> g = <span class="title function_">gen</span>(<span class="number">1</span>);</span><br><span class="line">g.<span class="title function_">next</span>(); <span class="comment">// &#123; value: 3, done: false &#125;</span></span><br><span class="line">g.<span class="title function_">next</span>(); <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure><p>上面代码中，调用 <code>Generator</code> 函数，会返回一个内部指针（即遍历器）<code>g</code>。这是 <code>Generator</code> 函数不同于普通函数的另一个地方，即执行它不会返回结果，返回的是指针对象。调用指针<code>g</code>的<code>next</code>方法，会移动内部指针（即执行异步任务的第一段），指向第一个遇到的<code>yield</code>语句，上例是执行到<code>x + 2</code>为止。<br><br></p><p>换言之，<code>next</code>方法的作用是分阶段执行<code>Generator</code>函数。每次调用<code>next</code>方法，会返回一个对象，表示当前阶段的信息（<code>value</code>属性和<code>done</code>属性）。<code>value</code>属性是<code>yield</code>语句后面表达式的值，表示当前阶段的值；<code>done</code>属性是一个布尔值，表示 <code>Generator</code> 函数是否执行完毕，即是否还有下一个阶段。</p><hr><h3 id="19-2-数据交换和错误处理"><a href="#19-2-数据交换和错误处理" class="headerlink" title="19.2 数据交换和错误处理"></a>19.2 数据交换和错误处理</h3><p><code>Generator</code> 函数可以暂停和恢复执行，这是它能封装异步任务的根本原因。除此之外，它还有两个特性，使它可以作为异步编程的完整解决方案：<ins>函数体内外的数据交换和错误处理机制</ins>。<br><br></p><p><code>next</code>返回值的 <code>value</code> 属性，是 <code>Generator</code> 函数向外输出数据。<code>next</code>方法还可以接受参数，向 <code>Generator</code> 函数体内输入数据。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">gen</span>(<span class="params">x</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> y = <span class="keyword">yield</span> x + <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> g = <span class="title function_">gen</span>(<span class="number">1</span>);</span><br><span class="line">g.<span class="title function_">next</span>(); <span class="comment">// &#123; value: 3, done: false &#125;</span></span><br><span class="line">g.<span class="title function_">next</span>(<span class="number">2</span>); <span class="comment">// &#123; value: 2, done: true &#125;</span></span><br></pre></td></tr></table></figure><p>上面代码中，第一个<code>next</code>方法的<code>value</code>属性，返回表达式<code>x + 2</code>的值。第二个<code>next</code>方法带有参数，这个参数被传入 <code>Generator</code> 函数，作为上个阶段异步任务的返回结果，也就是<code>y</code>的值。因此，这一步的<code>value</code>属性，返回的就是<code>2</code>。<br><br></p><p><code>Generator</code> 函数内部还可以部署错误处理代码，捕获函数体外抛出的错误。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">gen</span>(<span class="params">x</span>) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> y = <span class="keyword">yield</span> x + <span class="number">2</span>;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(e);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> g = <span class="title function_">gen</span>(<span class="number">1</span>);</span><br><span class="line">g.<span class="title function_">next</span>();</span><br><span class="line">g.<span class="keyword">throw</span>(<span class="string">&quot;出错了&quot;</span>);</span><br><span class="line"><span class="comment">// 出错了</span></span><br></pre></td></tr></table></figure><p>上面代码的最后一行，<code>Generator</code> 函数体外，<ins>使用指针对象的<code>throw</code>方法抛出的错误，可以被函数体内的<code>try...catch</code>代码块捕获</ins>。这意味着，<ins>出错的代码与处理错误的代码，实现了时间和空间上的分离，这对于异步编程无疑是很重要的</ins>。</p><hr><h3 id="19-3-异步任务的封装"><a href="#19-3-异步任务的封装" class="headerlink" title="19.3 异步任务的封装"></a>19.3 异步任务的封装</h3><p>使用<code>Generator</code>封装异步操作的核心思路：</p><ul><li>在异步任务执行时，使用<code>yield</code>交出执行权。</li><li>在异步任务结束后，使用<code>next</code>交还执行权。</li></ul><p>下面看看如何使用 <code>Generator</code> 函数，执行一个真实的异步任务。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 首先写一个异步任务,在一秒后返回特定字符串</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">asyncTask</span>(<span class="params">callback</span>) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">callback</span>(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 接下来写出期望执行的顺序</span></span><br><span class="line"><span class="keyword">function</span>* <span class="title function_">runTask</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> text = <span class="keyword">yield</span> asyncTask;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(text); <span class="comment">// 我们期望这里正常输出 Hello World</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 按照期望值执行函数</span></span><br><span class="line"><span class="keyword">const</span> gen = <span class="title function_">runTask</span>(); <span class="comment">// 此时执行权已经交出</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里 gen.next().value 就是 asyncTask，执行 asyncTask</span></span><br><span class="line"><span class="comment">// 关键点在于 callback 里调用 next 交还执行权</span></span><br><span class="line"><span class="comment">// 由于 next 方法带有参数 text，且是 callback 的返回值，所以有终端输出。</span></span><br><span class="line">gen.<span class="title function_">next</span>().<span class="title function_">value</span>(<span class="keyword">function</span> (<span class="params">text</span>) &#123;</span><br><span class="line">  gen.<span class="title function_">next</span>(text);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码虽然很粗糙，但是已经反映了使用<code>Generator</code>封装异步任务的核心思想。最直观的受益就是，<code>runTask</code>的内容与同步代码相似，条理清晰，很适合阅读。<br><br></p><p>可以看到，虽然 <code>Generator</code> 函数将异步操作表示得很简洁，但是上面代码中第三部分的流程管理却不方便，即何时执行第一阶段、何时执行第二阶段。</p><hr><h3 id="19-4-Thunk-函数"><a href="#19-4-Thunk-函数" class="headerlink" title="19.4 Thunk 函数"></a>19.4 Thunk 函数</h3><p><code>Thunk</code> 函数是自动执行 <code>Generator</code> 函数的一种方法。<br><br></p><p><strong>（1）参数的求值策略</strong></p><p><code>Thunk</code> 函数早在上个世纪 <code>60</code> 年代就诞生了。那时，编程语言刚刚起步，计算机学家还在研究，编译器怎么写比较好。一个争论的焦点是”求值策略”，即函数的参数到底应该何时求值。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">m</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> m * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">f</span>(x + <span class="number">5</span>)；</span><br></pre></td></tr></table></figure><p>上面代码先定义函数<code>f</code>，然后向它传入表达式<code>x + 5</code>。请问，这个表达式应该何时求值？<br><br></p><p>一种意见是<ins>“传值调用”</ins>，即在进入函数体之前，就计算<code>x + 5</code>的值，再将这个值传入函数<code>f</code>。<code>C</code> 语言就采用这种策略。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">f</span>(x + <span class="number">5</span>);</span><br><span class="line"><span class="comment">// 传值调用时，等同于</span></span><br><span class="line"><span class="title function_">f</span>(<span class="number">6</span>);</span><br></pre></td></tr></table></figure><p>另一种意见是<ins>“传名调用”</ins>，即直接将表达式<code>x + 5</code>传入函数体，只在用到它的时候求值。<code>Haskell</code> 语言采用这种策略。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">f</span>(x + <span class="number">5</span>)(</span><br><span class="line">  <span class="comment">// 传名调用时，等同于</span></span><br><span class="line">  x + <span class="number">5</span></span><br><span class="line">) * <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>传值调用和传名调用，哪一种比较好？回答是各有利弊。传值调用比较简单，但是对参数求值的时候，实际上还没用到这个参数，有可能造成性能损失。<br><br></p><p><strong>（2）Thunk 函数的含义</strong></p><p>编译器“传名调用”的实现，往往是将参数放到一个临时函数之中，再将这个临时函数传入函数体。这个临时函数就叫做 <code>Thunk</code> 函数。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">m</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> m * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">f</span>(x + <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> thunk = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> x + <span class="number">5</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">thunk</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">thunk</span>() * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，函数 <code>f</code> 的参数<code>x + 5</code>被一个函数替换了。凡是用到原参数的地方，对<code>Thunk</code>函数求值即可。这就是 <code>Thunk</code> 函数的定义，<ins>它是“传名调用”的一种实现策略，用来替换某个表达式</ins>。<br><br></p><p><strong>（3）JS 语言的 Thunk 函数</strong></p><p><ins><code>JavaScript</code> 是传值调用</ins>，它的 <code>Thunk</code> 函数含义有所不同。在 <code>JavaScript</code> 中，<code>Thunk</code> 函数替换的不是表达式，而是多参数函数，将其替换成一个只接受回调函数作为参数的单参数函数。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 正常版本的 readFile（多参数版本）</span></span><br><span class="line">fs.<span class="title function_">readFile</span>(fileName, callback);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Thunk版本的 readFile（单参数版本）</span></span><br><span class="line"><span class="keyword">let</span> <span class="title class_">Thunk</span> = <span class="keyword">function</span> (<span class="params">fileName</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">callback</span>) &#123;</span><br><span class="line">    <span class="comment">// 注意</span></span><br><span class="line">    <span class="keyword">return</span> fs.<span class="title function_">readFile</span>(fileName, callback);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> readFileThunk = <span class="title class_">Thunk</span>(fileName);</span><br><span class="line"><span class="title function_">readFileThunk</span>(callback);</span><br></pre></td></tr></table></figure><p>上面代码中，<code>fs</code>模块的<code>readFile</code>方法是一个多参数函数，两个参数分别为文件名和回调函数。经过转换器处理，它变成了一个单参数函数，只接受回调函数作为参数。这个单参数版本，就叫做 <code>Thunk</code> 函数。<br><br></p><p>任何函数，只要参数有回调函数，就能写成 <code>Thunk</code> 函数的形式。（<a href="https://zhuanlan.zhihu.com/p/404060484">推荐阅读</a>）<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Thunk</span> = <span class="keyword">function</span> (<span class="params">fn</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">...args</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">callback</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> fn.<span class="title function_">call</span>(<span class="variable language_">this</span>, ...args, callback);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>（4）Thunkify 模块</strong></p><p><code>Thunkify</code> 模块的使用方式如下。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> thunkify = <span class="built_in">require</span>(<span class="string">&quot;thunkify&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> read = <span class="title function_">thunkify</span>(fs.<span class="property">readFile</span>);</span><br><span class="line"><span class="title function_">read</span>(<span class="string">&quot;package.json&quot;</span>)(<span class="keyword">function</span> (<span class="params">err, str</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>Thunkify</code> 的源码与上一节那个简单的转换器非常像。（<a href="https://segmentfault.com/a/1190000010414406">源码解读</a>）<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">thunkify</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> args = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="variable language_">arguments</span>.<span class="property">length</span>);</span><br><span class="line">    <span class="keyword">let</span> ctx = <span class="variable language_">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; args.<span class="property">length</span>; ++i) &#123;</span><br><span class="line">      args[i] = <span class="variable language_">arguments</span>[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">done</span>) &#123;</span><br><span class="line">      <span class="keyword">let</span> called;</span><br><span class="line"></span><br><span class="line">      args.<span class="title function_">push</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (called) &#123;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        called = <span class="literal">true</span>;</span><br><span class="line">        done.<span class="title function_">apply</span>(<span class="literal">null</span>, <span class="variable language_">arguments</span>);</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        fn.<span class="title function_">apply</span>(ctx, args);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">        <span class="title function_">done</span>(err);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它的源码主要多了一个检查机制，变量<code>called</code>确保回调函数只运行一次。这样的设计与下面的 <code>Generator</code> 函数相关。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">a, b, callback</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> sum = a + b;</span><br><span class="line">  <span class="title function_">callback</span>(sum);</span><br><span class="line">  <span class="title function_">callback</span>(sum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> ft = <span class="title function_">thunkify</span>(f);</span><br><span class="line"><span class="keyword">let</span> print = <span class="variable language_">console</span>.<span class="property">log</span>.<span class="title function_">bind</span>(<span class="variable language_">console</span>);</span><br><span class="line"><span class="title function_">ft</span>(<span class="number">1</span>, <span class="number">2</span>)(print);</span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>上面代码中，由于<code>thunkify</code>只允许回调函数执行一次，所以只输出一行结果。<br><br></p><p><strong>（5）Generator 函数的流程管理</strong></p><p><code>Thunk</code> 函数可以用于 <code>Generator</code> 函数的自动流程管理。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">gen</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> g = <span class="title function_">gen</span>();</span><br><span class="line"><span class="keyword">let</span> res = g.<span class="title function_">next</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!res.<span class="property">done</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res.<span class="property">value</span>);</span><br><span class="line">  res = g.<span class="title function_">next</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>Generator</code> 函数<code>gen</code>会自动执行完所有步骤。<br><br></p><p>但是，这不适合异步操作。<ins>如果必须保证前一步执行完，才能执行后一步，上面的自动执行就不可行</ins>。这时，<code>Thunk</code> 函数就能派上用处。<br><br></p><p>以读取文件为例。下面的 <code>Generator</code> 函数封装了两个异步操作。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> thunkify = <span class="built_in">require</span>(<span class="string">&quot;thunkify&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> readFileThunk = <span class="title function_">thunkify</span>(fs.<span class="property">readFile</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> gen = <span class="keyword">function</span>* () &#123;</span><br><span class="line">  <span class="keyword">let</span> r1 = <span class="keyword">yield</span> <span class="title function_">readFileThunk</span>(<span class="string">&quot;/etc/fstab&quot;</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(r1.<span class="title function_">toString</span>());</span><br><span class="line">  <span class="keyword">let</span> r2 = <span class="keyword">yield</span> <span class="title function_">readFileThunk</span>(<span class="string">&quot;/etc/shells&quot;</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(r2.<span class="title function_">toString</span>());</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面代码中，<ins><code>yield</code>命令用于将程序的执行权移出 <code>Generator</code> 函数，那么就需要一种方法，将执行权再交还给 <code>Generator</code> 函数</ins>。<br><br></p><p>这种方法就是 <code>Thunk</code> 函数，<ins>因为它可以在回调函数里，将执行权交还给 <code>Generator</code> 函数</ins>。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> g = <span class="title function_">gen</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> r1 = g.<span class="title function_">next</span>();</span><br><span class="line">r1.<span class="title function_">value</span>(<span class="keyword">function</span> (<span class="params">err, data</span>) &#123;</span><br><span class="line">  <span class="comment">// r1.value 就是 readFileThunk 方法</span></span><br><span class="line">  <span class="keyword">if</span> (err) &#123;</span><br><span class="line">    <span class="keyword">throw</span> err; <span class="comment">// 错误处理</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> r2 = g.<span class="title function_">next</span>(data); <span class="comment">// 如果 data 从 readFileThunk 方法回调出来</span></span><br><span class="line">  <span class="comment">// 归还执行权，r1 赋值成功，运行至下一个 yield</span></span><br><span class="line">  r2.<span class="title function_">value</span>(<span class="keyword">function</span> (<span class="params">err, data</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">      <span class="keyword">throw</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">    g.<span class="title function_">next</span>(data);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，变量<code>g</code>是 <code>Generator</code> 函数的内部指针，表示目前执行到哪一步。<code>next</code>方法负责将指针移动到下一步，并返回该步的<code>value</code>属性和<code>done</code>属性。<br><br></p><p>仔细看上面的代码，可以发现 <code>Generator</code> 函数的执行过程，其实是<ins>将同一个回调函数，反复传入<code>next</code>方法的<code>value</code>属性</ins>。这使得我们可以用递归来自动完成这个过程。（理论上）<br><br></p><p><strong>（6）Thunk 函数的自动流程管理</strong></p><p><code>Thunk</code> 函数真正的威力，在于可以自动执行 <code>Generator</code> 函数。下面就是一个基于 <code>Thunk</code> 函数的 <code>Generator</code> 执行器。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">run</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> gen = <span class="title function_">fn</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">next</span>(<span class="params">err, data</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> result = gen.<span class="title function_">next</span>(data);</span><br><span class="line">    <span class="keyword">if</span> (result.<span class="property">done</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    result.<span class="title function_">value</span>(next);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">next</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span>* <span class="title function_">g</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">run</span>(g);</span><br></pre></td></tr></table></figure><p>上面代码的<code>run</code>函数，就是一个 <code>Generator</code> 函数的自动执行器。内部的<code>next</code>函数就是 <code>Thunk</code> 的回调函数。<code>next</code>函数先将指针移到 <code>Generator</code> 函数的下一步（<code>gen.next</code>方法），然后判断 <code>Generator</code> 函数是否结束（<code>result.done</code>属性），如果没结束，就将<code>next</code>函数再传入 <code>Thunk</code> 函数（<code>result.value</code>属性），否则就直接退出。<br><br></p><p>有了这个执行器，执行 <code>Generator</code> 函数方便多了。不管内部有多少个异步操作，直接把 <code>Generator</code> 函数传入<code>run</code>函数即可。注意，<ins>前提是每一个异步操作，都要是 <code>Thunk</code> 函数，也就是说，跟在<code>yield</code>命令后面的必须是 <code>Thunk</code> 函数</ins>。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> g = <span class="keyword">function</span>* () &#123;</span><br><span class="line">  <span class="keyword">let</span> f1 = <span class="keyword">yield</span> <span class="title function_">readFileThunk</span>(<span class="string">&quot;fileA&quot;</span>);</span><br><span class="line">  <span class="keyword">let</span> f2 = <span class="keyword">yield</span> <span class="title function_">readFileThunk</span>(<span class="string">&quot;fileB&quot;</span>);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">let</span> fn = <span class="keyword">yield</span> <span class="title function_">readFileThunk</span>(<span class="string">&quot;fileN&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">run</span>(g);</span><br></pre></td></tr></table></figure><p>上面代码中，函数<code>g</code>封装了<code>n</code>个异步的读取文件操作，只要执行<code>run</code>函数，这些操作就会自动完成。这样一来，异步操作不仅可以写得像同步操作，而且一行代码就可以执行。<br><br></p><p><code>Thunk</code> 函数并不是 <code>Generator</code> 函数自动执行的唯一方案。因为自动执行的关键是，必须有一种机制，自动控制 <code>Generator</code> 函数的流程，接收和交还程序的执行权。回调函数可以做到这一点，<code>Promise</code> 对象也可以做到这一点。</p><hr><h3 id="19-5-co-模块"><a href="#19-5-co-模块" class="headerlink" title="19.5 co 模块"></a>19.5 co 模块</h3><p>下面是一个 <code>Generator</code> 函数，用于依次读取两个文件。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> gen = <span class="keyword">function</span>* () &#123;</span><br><span class="line">  <span class="keyword">let</span> f1 = <span class="keyword">yield</span> <span class="title function_">readFile</span>(<span class="string">&quot;/etc/fstab&quot;</span>);</span><br><span class="line">  <span class="keyword">let</span> f2 = <span class="keyword">yield</span> <span class="title function_">readFile</span>(<span class="string">&quot;/etc/shells&quot;</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(f1.<span class="title function_">toString</span>());</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(f2.<span class="title function_">toString</span>());</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/tj/co">co 模块</a>可以用于 <code>Generator</code> 函数的自动执行，不用再编写 <code>Generator</code> 函数的执行器。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> co = <span class="built_in">require</span>(<span class="string">&quot;co&quot;</span>);</span><br><span class="line"><span class="title function_">co</span>(gen);</span><br></pre></td></tr></table></figure><p>上面代码中，<code>Generator</code> 函数只要传入<code>co</code>函数，就会自动执行。</p><p><code>co</code>函数返回一个<code>Promise</code>对象，因此可以用<code>then</code>方法添加回调函数。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">co</span>(gen).<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Generator 函数执行完成&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，等到 <code>Generator</code> 函数执行结束，就会输出一行提示。<br><br></p><p><strong>（1）co 模块的原理</strong></p><p>为什么 <code>co</code> 可以自动执行 <code>Generator</code> 函数？</p><p>前面说过，<ins><code>Generator</code> 就是一个异步操作的容器。它的自动执行需要一种机制，当异步操作有了结果，能够自动交回执行权</ins>。</p><p>两种方法可以做到这一点：</p><ul><li>回调函数。将异步操作包装成 <code>Thunk</code> 函数，在回调函数里面交回执行权。</li><li><code>Promise</code> 对象。将异步操作包装成 <code>Promise</code> 对象，用<code>then</code>方法交回执行权。</li></ul><p><code>co</code> 模块其实就是将两种自动执行器（<code>Thunk</code> 函数和 <code>Promise</code> 对象），包装成一个模块。</p><ul><li>使用 <code>co</code> 的前提条件是，<code>Generator</code> 函数的<code>yield</code>命令后面，只能是 <code>Thunk</code> 函数或 <code>Promise</code> 对象。如果数组或对象的成员，全部都是 <code>Promise</code> 对象，也可以使用 <code>co</code>。<br><br></li></ul><p><strong>（2）基于 Promise 对象的自动执行</strong></p><p>沿用上面的例子。首先，把<code>fs</code>模块的<code>readFile</code>方法包装成一个 <code>Promise</code> 对象。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> readFile = <span class="keyword">function</span> (<span class="params">fileName</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">    <span class="comment">// Promise 新建后立即执行</span></span><br><span class="line">    fs.<span class="title function_">readFile</span>(fileName, <span class="keyword">function</span> (<span class="params">error, data</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (error) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">reject</span>(error);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="title function_">resolve</span>(data); <span class="comment">// 读取成功，传 data 进 then 方法</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> gen = <span class="keyword">function</span>* () &#123;</span><br><span class="line">  <span class="keyword">let</span> f1 = <span class="keyword">yield</span> <span class="title function_">readFile</span>(<span class="string">&quot;/etc/fstab&quot;</span>);</span><br><span class="line">  <span class="keyword">let</span> f2 = <span class="keyword">yield</span> <span class="title function_">readFile</span>(<span class="string">&quot;/etc/shells&quot;</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(f1.<span class="title function_">toString</span>());</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(f2.<span class="title function_">toString</span>());</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后，手动执行上面的 <code>Generator</code> 函数。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> g = <span class="title function_">gen</span>();</span><br><span class="line"><span class="comment">// 注意，此时 gen.next().value 是 readFile 返回的 Promise 对象</span></span><br><span class="line"><span class="comment">// resolve 返回的 data 进入回调函数</span></span><br><span class="line">g.<span class="title function_">next</span>().<span class="property">value</span>.<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">data</span>) &#123;</span><br><span class="line">  g.<span class="title function_">next</span>(data).<span class="property">value</span>.<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">data</span>) &#123;</span><br><span class="line">    g.<span class="title function_">next</span>(data);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>手动执行就是用<code>then</code>方法，层层添加回调函数。理解了这一点，就可以写出一个自动执行器。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">run</span>(<span class="params">gen</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> g = <span class="title function_">gen</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">next</span>(<span class="params">data</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> result = g.<span class="title function_">next</span>(data);</span><br><span class="line">    <span class="keyword">if</span> (result.<span class="property">done</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> result.<span class="property">value</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    result.<span class="property">value</span>.<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">data</span>) &#123;</span><br><span class="line">      <span class="title function_">next</span>(data);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">next</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">run</span>(gen);</span><br></pre></td></tr></table></figure><p>上面代码中，只要 <code>Generator</code> 函数还没执行到最后一步，<code>next</code>函数就调用自身，实现自动执行。<br><br></p><p><strong>（3）co 模块的源码</strong></p><p>首先，<code>co</code> 函数接受 <code>Generator</code> 函数作为参数，返回一个 <code>Promise</code> 对象。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">co</span>(<span class="params">gen</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> ctx = <span class="variable language_">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在返回的 <code>Promise</code> 对象里面，<code>co</code> 先检查参数<code>gen</code>是否为 <code>Generator</code> 函数。如果是，就执行该函数，得到一个内部指针对象；如果不是就返回，并将 <code>Promise</code> 对象的状态改为<code>resolved</code>。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">co</span>(<span class="params">gen</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> ctx = <span class="variable language_">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> gen === <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">      gen = gen.<span class="title function_">call</span>(ctx);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!gen || <span class="keyword">typeof</span> gen.<span class="property">next</span> !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">resolve</span>(gen);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着，<code>co</code> 将 <code>Generator</code> 函数的内部指针对象的<code>next</code>方法，包装成<code>onFulfilled</code>函数。这主要是为了能够捕捉抛出的错误。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">co</span>(<span class="params">gen</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> ctx = <span class="variable language_">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> gen === <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">      gen = gen.<span class="title function_">call</span>(ctx);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!gen || <span class="keyword">typeof</span> gen.<span class="property">next</span> !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">resolve</span>(gen);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">onFulfilled</span>();</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">onFulfilled</span>(<span class="params">res</span>) &#123;</span><br><span class="line">      <span class="keyword">let</span> ret;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        ret = gen.<span class="title function_">next</span>(res);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">reject</span>(e);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="title function_">next</span>(ret);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，就是关键的<code>next</code>函数，它会反复调用自身。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">next</span>(<span class="params">ret</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (ret.<span class="property">done</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">resolve</span>(ret.<span class="property">value</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> value = toPromise.<span class="title function_">call</span>(ctx, ret.<span class="property">value</span>);</span><br><span class="line">  <span class="keyword">if</span> (value &amp;&amp; <span class="title function_">isPromise</span>(value)) &#123;</span><br><span class="line">    <span class="keyword">return</span> value.<span class="title function_">then</span>(onFulfilled, onRejected);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">onRejected</span>(</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">TypeError</span>(</span><br><span class="line">      <span class="string">&quot;You may only yield a function, promise, generator, array, or object, &quot;</span> +</span><br><span class="line">        <span class="string">&#x27;but the following object was passed: &quot;&#x27;</span> +</span><br><span class="line">        <span class="title class_">String</span>(ret.<span class="property">value</span>) +</span><br><span class="line">        <span class="string">&#x27;&quot;&#x27;</span></span><br><span class="line">    )</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>next</code>函数的内部代码，一共只有四行命令。</p><ul><li>检查当前是否为 <code>Generator</code> 函数的最后一步，如果是就返回。</li><li>确保每一步的返回值，是 <code>Promise</code> 对象。</li><li><code>then</code>方法为返回值加上回调函数，然后通过<code>onFulfilled</code>函数再次调用<code>next</code>函数。</li><li>在参数不符合要求的情况下（参数非 <code>Thunk</code> 函数和 <code>Promise</code> 对象），将 <code>Promise</code> 对象的状态改为<code>rejected</code>，从而终止执行。</li></ul><p><strong>（4）处理并发的异步操作</strong></p><p><code>co</code> 支持并发的异步操作，即允许某些操作同时进行，等到它们全部完成，才进行下一步。这时，要把并发的操作都放在数组或对象里面，跟在<code>yield</code>语句后面。（<a href="https://es6.ruanyifeng.com/#docs/generator-async#%E5%AE%9E%E4%BE%8B%EF%BC%9A%E5%A4%84%E7%90%86-Stream">例子</a>）<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数组的写法</span></span><br><span class="line"><span class="title function_">co</span>(<span class="keyword">function</span>* () &#123;</span><br><span class="line">  <span class="keyword">let</span> res = <span class="keyword">yield</span> [<span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">1</span>), <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">2</span>)];</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br><span class="line">&#125;).<span class="title function_">catch</span>(onerror);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象的写法</span></span><br><span class="line"><span class="title function_">co</span>(<span class="keyword">function</span>* () &#123;</span><br><span class="line">  <span class="keyword">let</span> res = <span class="keyword">yield</span> &#123;</span><br><span class="line">    <span class="number">1</span>: <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">1</span>),</span><br><span class="line">    <span class="number">2</span>: <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">2</span>),</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br><span class="line">&#125;).<span class="title function_">catch</span>(onerror);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> ES6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ES6学习笔记 • 上</title>
      <link href="/posts/fbe58254.html"/>
      <url>/posts/fbe58254.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>本读书笔记节是针对阮一峰编写的 <a href="https://es6.ruanyifeng.com/">《ECMAScript 6 入门教程》</a>的总结。适合已经掌握 <code>ES5</code> 的读者，用来了解这门语言的最新发展。笔记内容仅包括日常开发中可能会用到的概念。</p></blockquote><hr><h2 id="1-let-和-const-命令"><a href="#1-let-和-const-命令" class="headerlink" title="1. let 和 const 命令"></a>1. let 和 const 命令</h2><h3 id="1-1-let-命令"><a href="#1-1-let-命令" class="headerlink" title="1.1 let 命令"></a>1.1 let 命令</h3><p><code>let</code>的用法类似于<code>var</code>，但所声明的变量只在<code>let</code>命令所在的代码块（即 <code>&#123;&#125;</code> 包裹起来的内容）内有效。而<code>var</code>所声明的变量在全局范围内都有效。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">var</span> b = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">a; <span class="comment">// ReferenceError: a is not defined.</span></span><br><span class="line">b; <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p><strong>（1）不存在变量提升</strong></p><p><code>var</code>命令会发生<ins>“变量提升”现象，即变量可以在声明之前使用，值为<code>undefined</code></ins>。为了纠正这种现象，<code>let</code>命令改变了语法行为，它所声明的变量一定要在声明后使用。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// var 的情况</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(foo); <span class="comment">// 输出 undefined</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// let 的情况</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(bar); <span class="comment">// 报错 ReferenceError</span></span><br><span class="line"><span class="keyword">let</span> bar = <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p><strong>（2）暂时性死区</strong></p><p>只要<a href="https://blog.poetries.top/browser-working-principle/guide/part2/lesson09.html#%E4%BD%9C%E7%94%A8%E5%9F%9F-scope">块级作用域</a>内存在<code>let</code>和<code>const</code>命令，它所声明的变量就“绑定”（<code>binding</code>）这个区域，不再受外部的影响。凡是在声明之前就使用这些变量，就会报错。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> tmp = <span class="number">123</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="comment">// TDZ 开始</span></span><br><span class="line">  tmp = <span class="string">&quot;abc&quot;</span>; <span class="comment">// ReferenceError</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(tmp); <span class="comment">// ReferenceError</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> tmp; <span class="comment">// TDZ 结束</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(tmp); <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line">  tmp = <span class="number">123</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(tmp); <span class="comment">// 123</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="1-2-块级作用域"><a href="#1-2-块级作用域" class="headerlink" title="1.2 块级作用域"></a>1.2 块级作用域</h3><p><code>ES5</code> 只有全局作用域和函数作用域，没有块级作用域，这带来很多不合理的情况 <br><br></p><p><strong>（1）内层变量覆盖外层变量</strong><br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> tmp = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(tmp);</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> tmp = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">f</span>(); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>上面代码的原意是，<code>if</code>代码块的外部使用外层的<code>tmp</code>变量，内部使用内层的<code>tmp</code>变量。但是函数<code>f</code>执行后，输出结果却为<code>undefined</code>。<br><br></p><p><ins>原因其实就是变量提升，导致内层的<code>tmp</code>变量覆盖了外层的<code>tmp</code>变量</ins>。实际中的代码如下<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> tmp = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> tmp; <span class="comment">// 声明但未赋值 undefined</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(tmp); <span class="comment">// 输出 undefined</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">    tmp = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">f</span>(); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p><strong>（2）用来计数的循环变量泄露为全局变量</strong><br><br></p><p>下面代码中，变量<code>i</code>只用来控制循环，但是循环结束后，它并没有消失，泄露成了全局变量。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; s.<span class="property">length</span>; i++) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(s[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(i); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure><p>为了应对上面这些情况，<code>ES6</code> 新增了块级作用域，<ins>外层作用域无法获取到内层作用域</ins>。<ins>即使外层和内层都使用相同变量名，也都互不干扰</ins>。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f1</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> n = <span class="number">5</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> n = <span class="number">10</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(n); <span class="comment">// 5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的函数有两个代码块，都声明了变量<code>n</code>，运行后输出 <code>5</code>。这表示外层代码块不受内层代码块的影响。如果两次都使用<code>var</code>定义变量<code>n</code>，最后输出的值就是 <code>10</code>。</p><hr><h3 id="1-3-const-命令"><a href="#1-3-const-命令" class="headerlink" title="1.3 const 命令"></a>1.3 const 命令</h3><p><code>const</code>声明一个只读常量。一旦声明，常量的值就不能改变，<ins>且必须立即初始化</ins>。（与 <code>let</code> 一样，<code>const</code> 不存在变量提升，存在暂时性死区）<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">PI</span> = <span class="number">3.1415</span>;</span><br><span class="line"><span class="variable constant_">PI</span>; <span class="comment">// 3.1415</span></span><br><span class="line"><span class="variable constant_">PI</span> = <span class="number">3</span>;</span><br><span class="line"><span class="comment">// TypeError: Assignment to constant variable.</span></span><br></pre></td></tr></table></figure><p><code>const</code>保证的，并不是变量的值不得改动，<ins>而是变量指向的那个内存地址所保存的数据不得改动</ins>。</p><ul><li>对于简单类型的数据（比如数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。</li><li>但对于复合类型的数据（比如对象、数组），变量指向的内存地址，保存的只是一个指向实际数据的指针。<code>const</code>只能保证这个指针是固定的，至于它指向的数据结构是不是可变的，就完全不能控制了。</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为 foo 添加一个属性</span></span><br><span class="line">foo.<span class="property">prop</span> = <span class="number">123</span>;</span><br><span class="line">foo.<span class="property">prop</span>; <span class="comment">// 123</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 foo 指向另一个对象，报错</span></span><br><span class="line">foo = &#123;&#125;; <span class="comment">// TypeError: &quot;foo&quot; is read-only</span></span><br></pre></td></tr></table></figure><hr><h2 id="2-变量的解构赋值"><a href="#2-变量的解构赋值" class="headerlink" title="2. 变量的解构赋值"></a>2. 变量的解构赋值</h2><h3 id="2-1-数组的解构赋值"><a href="#2-1-数组的解构赋值" class="headerlink" title="2.1 数组的解构赋值"></a>2.1 数组的解构赋值</h3><p>从数组或对象中提取值，按照对应位置, 对变量进行赋值，这被称为解构。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [a, b, c] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br></pre></td></tr></table></figure><p>这种写法属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [foo, [[bar], baz]] = [<span class="number">1</span>, [[<span class="number">2</span>], <span class="number">3</span>]];</span><br><span class="line">foo; <span class="comment">// 1</span></span><br><span class="line">bar; <span class="comment">// 2</span></span><br><span class="line">baz; <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [, , third] = [<span class="string">&quot;foo&quot;</span>, <span class="string">&quot;bar&quot;</span>, <span class="string">&quot;baz&quot;</span>];</span><br><span class="line">third; <span class="comment">// &quot;baz&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [head, ...tail] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">head; <span class="comment">// 1</span></span><br><span class="line">tail; <span class="comment">// [2, 3, 4]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [x, y, ...z] = [<span class="string">&quot;a&quot;</span>];</span><br><span class="line">x; <span class="comment">// &quot;a&quot;</span></span><br><span class="line">y; <span class="comment">// undefined</span></span><br><span class="line">z; <span class="comment">// []</span></span><br></pre></td></tr></table></figure><p>数组的解构赋值有两种特殊情况</p><ul><li>解构不成功，那么对应变量的值就等于<code>undefined</code>。</li><li>不完全解构，等号左边的模式，只会匹配一部分的等号右边的数组。</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [foo] = []; <span class="comment">// foo == undefined</span></span><br><span class="line"><span class="keyword">let</span> [bar, foo] = [<span class="number">1</span>]; <span class="comment">// foo == undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [a, [b], d] = [<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>], <span class="number">4</span>];</span><br><span class="line">a; <span class="comment">// 1</span></span><br><span class="line">b; <span class="comment">// 2</span></span><br><span class="line">d; <span class="comment">// 4</span></span><br></pre></td></tr></table></figure><p>事实上，只要某种数据结构具有 <code>Iterator</code> 接口，都可以采用数组形式的解构赋值。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [x, y, z] = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>]); <span class="comment">// Set 原生带有 Iterator 接口</span></span><br><span class="line">x; <span class="comment">// &quot;a&quot;</span></span><br></pre></td></tr></table></figure><p>数组的解构赋值可以指定默认值，并且<ins>必须严格等于<code>undefined</code></ins>才会生效。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [foo = <span class="literal">true</span>] = [];</span><br><span class="line">foo; <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [x, y = <span class="string">&quot;b&quot;</span>] = [<span class="string">&quot;a&quot;</span>]; <span class="comment">// x=&#x27;a&#x27;, y=&#x27;b&#x27;</span></span><br><span class="line"><span class="keyword">let</span> [x, y = <span class="string">&quot;b&quot;</span>] = [<span class="string">&quot;a&quot;</span>, <span class="literal">undefined</span>]; <span class="comment">// x=&#x27;a&#x27;, y=&#x27;b&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [x = <span class="number">1</span>] = [<span class="literal">undefined</span>];</span><br><span class="line">x; <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [x = <span class="number">1</span>] = [<span class="literal">null</span>];</span><br><span class="line">x; <span class="comment">// null</span></span><br></pre></td></tr></table></figure><hr><h3 id="2-2-对象的解构赋值"><a href="#2-2-对象的解构赋值" class="headerlink" title="2.2 对象的解构赋值"></a>2.2 对象的解构赋值</h3><p>对象的解构与数组有一个重要的不同。<ins>数组的元素是按次序排列的，变量的取值由它的位置决定</ins>。<ins>而对象的属性没有次序，变量必须与属性同名，才能取到正确的值</ins>。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; bar, foo &#125; = &#123; <span class="attr">foo</span>: <span class="string">&quot;aaa&quot;</span>, <span class="attr">bar</span>: <span class="string">&quot;bbb&quot;</span> &#125;;</span><br><span class="line">foo; <span class="comment">// &quot;aaa&quot;</span></span><br><span class="line">bar; <span class="comment">// &quot;bbb&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; baz &#125; = &#123; <span class="attr">foo</span>: <span class="string">&quot;aaa&quot;</span>, <span class="attr">bar</span>: <span class="string">&quot;bbb&quot;</span> &#125;;</span><br><span class="line">baz; <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>如果<ins>变量名与属性名不一致</ins>，必须写成下面这样。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">first</span>: <span class="string">&quot;hello&quot;</span>, <span class="attr">last</span>: <span class="string">&quot;world&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">first</span>: f, <span class="attr">last</span>: l &#125; = obj;</span><br><span class="line">f; <span class="comment">// &#x27;hello&#x27;</span></span><br><span class="line">l; <span class="comment">// &#x27;world&#x27;</span></span><br></pre></td></tr></table></figure><p>上面的代码可以看出，对象的解构赋值的机制，是<ins>先找到同名属性，然后再赋给对应的变量</ins>，<mark class="hl-label red">真正被赋值的是后者，而不是前者</mark> 。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; <span class="attr">foo</span>: foo, <span class="attr">bar</span>: bar &#125; = &#123; <span class="attr">foo</span>: <span class="string">&quot;aaa&quot;</span>, <span class="attr">bar</span>: <span class="string">&quot;bbb&quot;</span> &#125;;</span><br><span class="line"><span class="comment">// let &#123;foo, bar&#125; = &#123; foo: &#x27;aaa&#x27;, bar: &#x27;bbb&#x27; &#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">foo</span>: baz &#125; = &#123; <span class="attr">foo</span>: <span class="string">&quot;aaa&quot;</span>, <span class="attr">bar</span>: <span class="string">&quot;bbb&quot;</span> &#125;;</span><br><span class="line">baz; <span class="comment">// &quot;aaa&quot;</span></span><br><span class="line">foo; <span class="comment">// error: foo is not defined</span></span><br></pre></td></tr></table></figure><p>解构也可以用于嵌套结构的对象。下面代码分别对<code>p</code>，<code>x</code>，<code>y</code>三个属性进行解构赋值。注意，在对<code>x</code>，<code>y</code>属性的解构赋值之中，<code>x</code>，<code>y</code>是变量，<code>p</code>是模式。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="attr">p</span>: [<span class="string">&quot;Hello&quot;</span>, &#123; <span class="attr">y</span>: <span class="string">&quot;World&quot;</span> &#125;],</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123;</span><br><span class="line">  p,</span><br><span class="line">  <span class="attr">p</span>: [x, &#123; y &#125;],</span><br><span class="line">&#125; = obj;</span><br><span class="line">p; <span class="comment">// [&quot;Hello&quot;, &#123;y: &quot;World&quot;&#125;]</span></span><br><span class="line">x; <span class="comment">// &quot;Hello&quot;</span></span><br><span class="line">y; <span class="comment">// &quot;World&quot;</span></span><br></pre></td></tr></table></figure><p>对象的解构也可以指定默认值，并且必须严格等于<code>undefined</code>才会生效。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; x = <span class="number">3</span> &#125; = &#123;&#125;;</span><br><span class="line">x; <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; x, y = <span class="number">5</span> &#125; = &#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="literal">undefined</span> &#125;;</span><br><span class="line">x; <span class="comment">// 1</span></span><br><span class="line">y; <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">x</span>: y = <span class="number">3</span> &#125; = &#123;&#125;;</span><br><span class="line">y; <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">x</span>: y = <span class="number">3</span> &#125; = &#123; <span class="attr">x</span>: <span class="number">5</span> &#125;;</span><br><span class="line">y; <span class="comment">// 5</span></span><br></pre></td></tr></table></figure><hr><h3 id="2-3-函数参数的解构赋值"><a href="#2-3-函数参数的解构赋值" class="headerlink" title="2.3 函数参数的解构赋值"></a>2.3 函数参数的解构赋值</h3><p>函数的参数也可以使用解构赋值。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">move</span>(<span class="params">&#123; x = <span class="number">0</span>, y = <span class="number">0</span> &#125; = &#123;&#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> [x, y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">move</span>(&#123; <span class="attr">x</span>: <span class="number">3</span>, <span class="attr">y</span>: <span class="number">8</span> &#125;); <span class="comment">// [3, 8]</span></span><br><span class="line"><span class="title function_">move</span>(&#123; <span class="attr">x</span>: <span class="number">3</span> &#125;); <span class="comment">// [3, 0]</span></span><br><span class="line"><span class="title function_">move</span>(&#123;&#125;); <span class="comment">// [0, 0]</span></span><br><span class="line"><span class="title function_">move</span>(); <span class="comment">// [0, 0]</span></span><br></pre></td></tr></table></figure><p>上面代码中，函数<code>move</code>的参数是一个对象。通过对这个对象进行解构，得到变量<code>x</code>和<code>y</code>的值。如果解构失败，<code>x</code>和<code>y</code>等于默认值。<br><br></p><p>注意，下面的写法会得到与上面不一样的结果。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">move</span>(<span class="params">&#123; x, y &#125; = &#123; x: <span class="number">0</span>, y: <span class="number">0</span> &#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> [x, y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">move</span>(&#123; <span class="attr">x</span>: <span class="number">3</span>, <span class="attr">y</span>: <span class="number">8</span> &#125;); <span class="comment">// [3, 8]</span></span><br><span class="line"><span class="title function_">move</span>(&#123; <span class="attr">x</span>: <span class="number">3</span> &#125;); <span class="comment">// [3, undefined]</span></span><br><span class="line"><span class="title function_">move</span>(&#123;&#125;); <span class="comment">// [undefined, undefined]</span></span><br><span class="line"><span class="title function_">move</span>(); <span class="comment">// [0, 0]</span></span><br></pre></td></tr></table></figure><p>上面代码<ins>为函数<code>move</code>的参数指定默认值，而不是为变量<code>x</code>和<code>y</code>指定默认值</ins>。当参数为<code>undefined</code>时，参数默认值启用。</p><hr><h3 id="2-4-解构赋值的用途"><a href="#2-4-解构赋值的用途" class="headerlink" title="2.4 解构赋值的用途"></a>2.4 解构赋值的用途</h3><p><strong>（1）交换变量的值</strong></p><p>下面代码交换变量<code>x</code>和<code>y</code>的值，这样的写法简洁易读，语义清晰。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> y = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">[x, y] = [y, x]; <span class="comment">// x = 2, y = 1</span></span><br></pre></td></tr></table></figure><p><strong>（2）从函数返回多个值</strong></p><p>函数只能返回一个值，如果要返回多个值，只能将它们放在数组或对象里返回。有了解构赋值，取出这些值就非常方便。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回一个数组</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">example</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> [a, b, c] = <span class="title function_">example</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回一个对象</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">example</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">foo</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">bar</span>: <span class="number">2</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> &#123; foo, bar &#125; = <span class="title function_">example</span>();</span><br></pre></td></tr></table></figure><p><strong>（3）提取 JSON 数据</strong></p><p>解构赋值对提取 <code>JSON</code> 对象中的数据，尤其有用。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> jsonData = &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="number">42</span>,</span><br><span class="line">  <span class="attr">status</span>: <span class="string">&quot;OK&quot;</span>,</span><br><span class="line">  <span class="attr">data</span>: [<span class="number">867</span>, <span class="number">5309</span>],</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; id, status, <span class="attr">data</span>: number &#125; = jsonData;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(id, status, number);</span><br><span class="line"><span class="comment">// 42, &quot;OK&quot;, [867, 5309]</span></span><br></pre></td></tr></table></figure><p><strong>（4）函数参数的定义</strong></p><p>解构赋值可以方便地将一组参数与变量名对应起来。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参数是一组有次序的值</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">[x, y, z]</span>) &#123; ... &#125;</span><br><span class="line"><span class="title function_">f</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数是一组无次序的值</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">&#123;x, y, z&#125;</span>) &#123; ... &#125;</span><br><span class="line"><span class="title function_">f</span>(&#123;<span class="attr">z</span>: <span class="number">3</span>, <span class="attr">y</span>: <span class="number">2</span>, <span class="attr">x</span>: <span class="number">1</span>&#125;);</span><br></pre></td></tr></table></figure><p><strong>（5）遍历 Map 结构</strong></p><p>前面提到，任何部署了 <code>Iterator</code> 接口的对象，都可以用<code>for...of</code>循环遍历。<code>Map</code> 结构原生支持 <code>Iterator</code> 接口，配合变量的解构赋值，获取键名和键值就非常方便。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">map.<span class="title function_">set</span>(<span class="string">&quot;first&quot;</span>, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line">map.<span class="title function_">set</span>(<span class="string">&quot;second&quot;</span>, <span class="string">&quot;world&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> map) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(key + <span class="string">&quot; is &quot;</span> + value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// first is hello</span></span><br><span class="line"><span class="comment">// second is world</span></span><br></pre></td></tr></table></figure><hr><h2 id="3-字符串的扩展"><a href="#3-字符串的扩展" class="headerlink" title="3. 字符串的扩展"></a>3. 字符串的扩展</h2><p><a href="https://es6.ruanyifeng.com/#docs/string">本章</a>内容复杂，故先跳过一部分。</p><h3 id="3-1-模板字符串"><a href="#3-1-模板字符串" class="headerlink" title="3.1 模板字符串"></a>3.1 模板字符串</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&quot;#result&quot;</span>).<span class="title function_">append</span>(<span class="string">`</span></span><br><span class="line"><span class="string">  There are &lt;b&gt;<span class="subst">$&#123;basket.count&#125;</span>&lt;/b&gt; items</span></span><br><span class="line"><span class="string">   in your basket, &lt;em&gt;<span class="subst">$&#123;basket.onSale&#125;</span>&lt;/em&gt;</span></span><br><span class="line"><span class="string">  are on sale!</span></span><br><span class="line"><span class="string">`</span>);</span><br></pre></td></tr></table></figure><p>模板字符串（<code>template string</code>）是增强版的字符串。它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 字符串中嵌入变量</span></span><br><span class="line"><span class="keyword">let</span> name = <span class="string">&quot;Bob&quot;</span>,</span><br><span class="line">  time = <span class="string">&quot;today&quot;</span>;</span><br><span class="line"><span class="string">`Hello <span class="subst">$&#123;name&#125;</span>, how are you <span class="subst">$&#123;time&#125;</span>?`</span>;</span><br></pre></td></tr></table></figure><p>注意，如果使用模板字符串表示多行字符串，所有的空格，换行，缩进都会被保留在输出之中。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str1 = <span class="string">&quot;Hello&quot;</span> + <span class="string">&quot;World&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> str2 = <span class="string">`Hello</span></span><br><span class="line"><span class="string">World`</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str1); <span class="comment">// HelloWorld</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str2); <span class="comment">// Hello</span></span><br><span class="line"><span class="comment">// World 换行被保留</span></span><br></pre></td></tr></table></figure><hr><h3 id="3-2-标签模板"><a href="#3-2-标签模板" class="headerlink" title="3.2 标签模板"></a>3.2 标签模板</h3><p>模板字符串可以紧跟在一个函数名后面，该函数将被调用来处理这个模板字符串。这被称为“标签模板”功能（<code>tagged template</code>）。</p><ul><li>标签模板不是模板，而是函数调用的一种特殊形式。“标签”指的是函数，它的参数是紧跟在后面的模板字符串。</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">alert<span class="string">`hello`</span>;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="title function_">alert</span>([<span class="string">&quot;hello&quot;</span>]);</span><br></pre></td></tr></table></figure><p>如果模板字符里面有变量，就不是直接调用了。会先将模板字符串先处理成多个参数，再调用函数。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">tag</span>(<span class="params">stringArr, ...values</span>)&#123; ... &#125;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">tag</span>(<span class="params">stringArr, value1, value2</span>)&#123; ... &#125;</span><br><span class="line"></span><br><span class="line">tag<span class="string">`Hello <span class="subst">$&#123; a + b &#125;</span> world <span class="subst">$&#123; a * b &#125;</span>`</span>;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="title function_">tag</span>([<span class="string">&#x27;Hello &#x27;</span>, <span class="string">&#x27; world &#x27;</span>, <span class="string">&#x27;&#x27;</span>], <span class="number">15</span>, <span class="number">50</span>);</span><br></pre></td></tr></table></figure><hr><h2 id="4-字符串的新增方法"><a href="#4-字符串的新增方法" class="headerlink" title="4. 字符串的新增方法"></a>4. 字符串的新增方法</h2><h3 id="4-1-新增方法"><a href="#4-1-新增方法" class="headerlink" title="4.1 新增方法"></a>4.1 新增方法</h3><p><code>ES5</code> 中只有<code>indexOf()</code>方法可以用来确定一个字符串是否包含在另一个字符串中。<code>ES6</code> 又提供了三种新方法</p><ul><li><code>includes()</code>：返回布尔值，表示是否找到了参数字符串。</li><li><code>startsWith()</code>：返回布尔值，表示参数字符串是否在原字符串的头部。</li><li><code>endsWith()</code>：返回布尔值，表示参数字符串是否在原字符串的尾部。</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">&quot;Hello world!&quot;</span>;</span><br><span class="line"></span><br><span class="line">s.<span class="title function_">startsWith</span>(<span class="string">&quot;Hello&quot;</span>); <span class="comment">// true</span></span><br><span class="line">s.<span class="title function_">endsWith</span>(<span class="string">&quot;!&quot;</span>); <span class="comment">// true</span></span><br><span class="line">s.<span class="title function_">includes</span>(<span class="string">&quot;o&quot;</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>这三个方法都支持第二个参数，表示开始搜索的位置。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">&quot;Hello world!&quot;</span>;</span><br><span class="line"></span><br><span class="line">s.<span class="title function_">startsWith</span>(<span class="string">&quot;world&quot;</span>, <span class="number">6</span>); <span class="comment">// true</span></span><br><span class="line">s.<span class="title function_">endsWith</span>(<span class="string">&quot;Hello&quot;</span>, <span class="number">5</span>); <span class="comment">// true</span></span><br><span class="line">s.<span class="title function_">includes</span>(<span class="string">&quot;Hello&quot;</span>, <span class="number">6</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>上面代码中，使用第二个参数<code>n</code>时，<code>endsWith()</code>的行为与其他两个方法不同。它针对前<code>n</code>个字符，而其他两个方法针对从第<code>n</code>个位置直到字符串结束。<br><br></p><p><code>repeat()</code>方法返回一个新字符串，将原字符串重复<code>n</code>次。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;na&quot;</span>.<span class="title function_">repeat</span>(<span class="number">3</span>); <span class="comment">// &quot;nana&quot;</span></span><br><span class="line"><span class="string">&quot;na&quot;</span>.<span class="title function_">repeat</span>(<span class="string">&quot;2&quot;</span>); <span class="comment">// &quot;nana&quot; 转换成数字</span></span><br><span class="line"><span class="string">&quot;na&quot;</span>.<span class="title function_">repeat</span>(<span class="number">0</span>); <span class="comment">// &quot;&quot;</span></span><br><span class="line"><span class="string">&quot;na&quot;</span>.<span class="title function_">repeat</span>(<span class="number">2.9</span>); <span class="comment">// &quot;nana&quot; 取整</span></span><br><span class="line"><span class="string">&quot;na&quot;</span>.<span class="title function_">repeat</span>(-<span class="number">1</span>); <span class="comment">// RangeError</span></span><br></pre></td></tr></table></figure><p><code>ES6</code> 引入字符串补全长度功能，能在某个字符串不够指定长度时，往头部或尾部补全。<code>padStart()</code>用于头部补全，<code>padEnd()</code>用于尾部补全。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;x&quot;</span>.<span class="title function_">padStart</span>(<span class="number">5</span>, <span class="string">&quot;ab&quot;</span>); <span class="comment">// &#x27;ababx&#x27; 补到length == 5</span></span><br><span class="line"><span class="string">&quot;abc&quot;</span>.<span class="title function_">padStart</span>(<span class="number">10</span>, <span class="string">&quot;0123456789&quot;</span>);</span><br><span class="line"><span class="comment">// &#x27;0123456abc&#x27; 如果两者的长度之和超过了最大长度，则会截去超出的位数</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;x&quot;</span>.<span class="title function_">padEnd</span>(<span class="number">5</span>, <span class="string">&quot;ab&quot;</span>); <span class="comment">// &#x27;xabab&#x27;</span></span><br><span class="line"><span class="string">&quot;x&quot;</span>.<span class="title function_">padEnd</span>(<span class="number">4</span>, <span class="string">&quot;ab&quot;</span>); <span class="comment">// &#x27;xaba&#x27;</span></span><br></pre></td></tr></table></figure><p><code>ES6</code> 新增了<code>trimStart()</code>和<code>trimEnd()</code>两个方法。它们的行为与<code>trim()</code>一致，<code>trimStart()</code>消除字符串头部的空格，<code>trimEnd()</code>消除尾部的空格。它们返回的都是新字符串，不会修改原始字符串。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="string">&quot;  abc  &quot;</span>;</span><br><span class="line"></span><br><span class="line">s.<span class="title function_">trim</span>(); <span class="comment">// &quot;abc&quot;</span></span><br><span class="line">s.<span class="title function_">trimStart</span>(); <span class="comment">// &quot;abc  &quot;</span></span><br><span class="line">s.<span class="title function_">trimEnd</span>(); <span class="comment">// &quot;  abc&quot;</span></span><br></pre></td></tr></table></figure><p><code>ES5</code>中，<code>replace()</code>只能替换第一个匹配。如果要替换所有的匹配，需要使用正则表达式的<code>g</code>修饰符。<code>ES6</code>引入了<code>replaceAll()</code>方法，可以一次性替换所有匹配。它返回的是新字符串，不会修改原始字符串。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;aabbcc&quot;</span>.<span class="title function_">replace</span>(<span class="string">&quot;b&quot;</span>, <span class="string">&quot;_&quot;</span>);</span><br><span class="line"><span class="comment">// &#x27;aa_bcc&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;aabbcc&quot;</span>.<span class="title function_">replace</span>(<span class="regexp">/b/g</span>, <span class="string">&quot;_&quot;</span>);</span><br><span class="line"><span class="comment">// &#x27;aa__cc&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;aabbcc&quot;</span>.<span class="title function_">replaceAll</span>(<span class="string">&quot;b&quot;</span>, <span class="string">&quot;_&quot;</span>);</span><br><span class="line"><span class="comment">// &#x27;aa__cc&#x27;</span></span><br></pre></td></tr></table></figure><p><code>ES6</code> 增加了<code>matchAll()</code>方法，可以一次性取出字符串里面所有匹配。但是，它返回的是一个遍历器，而不是数组。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> string = <span class="string">&quot;test1test2test3&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> regex = <span class="regexp">/t(e)(st(\d?))/g</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> match <span class="keyword">of</span> string.<span class="title function_">matchAll</span>(regex)) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(match);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// [&quot;test1&quot;, &quot;e&quot;, &quot;st1&quot;, &quot;1&quot;, index: 0, input: &quot;test1test2test3&quot;]</span></span><br><span class="line"><span class="comment">// [&quot;test2&quot;, &quot;e&quot;, &quot;st2&quot;, &quot;2&quot;, index: 5, input: &quot;test1test2test3&quot;]</span></span><br><span class="line"><span class="comment">// [&quot;test3&quot;, &quot;e&quot;, &quot;st3&quot;, &quot;3&quot;, index: 10, input: &quot;test1test2test3&quot;]</span></span><br></pre></td></tr></table></figure><p>遍历器转为数组是非常简单的，使用<code>...</code>运算符和<code>Array.from()</code>方法就可以。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 转为数组的方法一</span></span><br><span class="line">[...string.<span class="title function_">matchAll</span>(regex)];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转为数组的方法二</span></span><br><span class="line"><span class="title class_">Array</span>.<span class="title function_">from</span>(string.<span class="title function_">matchAll</span>(regex));</span><br></pre></td></tr></table></figure><hr><h2 id="5-正则的扩展"><a href="#5-正则的扩展" class="headerlink" title="5. 正则的扩展"></a>5. 正则的扩展</h2><p><a href="https://es6.ruanyifeng.com/#docs/regex">本章</a>内容复杂，故先跳过一部分。</p><h3 id="5-1-具名组匹配"><a href="#5-1-具名组匹配" class="headerlink" title="5.1 具名组匹配"></a>5.1 具名组匹配</h3><p>正则表达式使用圆括号进行<a href="https://segmentfault.com/a/1190000021043947">组匹配</a>。使用<code>exec</code>方法，就可以将这匹配结果提取出来。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">RE_DATE</span> = <span class="regexp">/(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> matchObj = <span class="variable constant_">RE_DATE</span>.<span class="title function_">exec</span>(<span class="string">&quot;1999-12-31&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> year = matchObj[<span class="number">1</span>]; <span class="comment">// 1999</span></span><br><span class="line"><span class="keyword">const</span> month = matchObj[<span class="number">2</span>]; <span class="comment">// 12</span></span><br><span class="line"><span class="keyword">const</span> day = matchObj[<span class="number">3</span>]; <span class="comment">// 31</span></span><br></pre></td></tr></table></figure><p>组匹配的一个问题是，每一组的匹配含义不容易看出来，而且只能用数字序号<code>XXX[1]</code>引用，要是组的顺序变了，引用的时候就必须修改序号。<br><br></p><p><code>ES6</code> 引入了具名组匹配（<code>Named Capture Groups</code>），允许为每一个组匹配指定一个名字，既便于阅读代码，又便于引用。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">RE_DATE</span> = <span class="regexp">/(?&lt;year&gt;\d&#123;4&#125;)-(?&lt;month&gt;\d&#123;2&#125;)-(?&lt;day&gt;\d&#123;2&#125;)/</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> matchObj = <span class="variable constant_">RE_DATE</span>.<span class="title function_">exec</span>(<span class="string">&quot;1999-12-31&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> year = matchObj.<span class="property">groups</span>.<span class="property">year</span>; <span class="comment">// &quot;1999&quot;</span></span><br><span class="line"><span class="keyword">const</span> month = matchObj.<span class="property">groups</span>.<span class="property">month</span>; <span class="comment">// &quot;12&quot;</span></span><br><span class="line"><span class="keyword">const</span> day = matchObj.<span class="property">groups</span>.<span class="property">day</span>; <span class="comment">// &quot;31&quot;</span></span><br></pre></td></tr></table></figure><hr><h2 id="6-数值的扩展"><a href="#6-数值的扩展" class="headerlink" title="6. 数值的扩展"></a>6. 数值的扩展</h2><p><a href="https://es6.ruanyifeng.com/#docs/number">本章</a>内容复杂，故先跳过一部分。</p><h3 id="6-1-BigInt-数据类型"><a href="#6-1-BigInt-数据类型" class="headerlink" title="6.1 BigInt 数据类型"></a>6.1 BigInt 数据类型</h3><p><code>ES5</code> 中所有数字都保存成 <code>64</code> 位浮点数，这给数值的表示带来了两大限制：</p><ul><li>数值的精度只能到 <code>53</code> 个二进制位，相当于 <code>16</code> 个十进制位，大于这个范围的整数，无法精确表示。 （不适合进行科学和金融方面的精确计算）</li><li>大于或等于<code>2</code>的<code>1024</code>次方的数值无法表示，会返回<code>Infinity</code>。</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 超过 53 个二进制位的数值，无法保持精度</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">pow</span>(<span class="number">2</span>, <span class="number">53</span>) === <span class="title class_">Math</span>.<span class="title function_">pow</span>(<span class="number">2</span>, <span class="number">53</span>) + <span class="number">1</span>; <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 超过 2 的 1024 次方的数值，无法表示</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">pow</span>(<span class="number">2</span>, <span class="number">1024</span>); <span class="comment">// Infinity</span></span><br></pre></td></tr></table></figure><p><code>ES6</code> 引入了一种新的数据类型 <code>BigInt</code>，来解决这个问题，这是 <code>ECMAScript</code> 的<a href="https://juejin.cn/post/6954892721173561358">第八种数据类型</a>。<code>BigInt</code> <ins>只用来表示整数</ins>，没有位数的限制，任何位数的整数都可以精确表示。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="number">2172141653n</span>;</span><br><span class="line"><span class="keyword">const</span> b = <span class="number">15346349309n</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// BigInt 可以保持精度</span></span><br><span class="line">a * b; <span class="comment">// 33334444555566667777n</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通整数无法保持精度</span></span><br><span class="line"><span class="title class_">Number</span>(a) * <span class="title class_">Number</span>(b); <span class="comment">// 33334444555566670000</span></span><br></pre></td></tr></table></figure><p><code>BigInt</code> 与普通整数是两种值，它们之间并不相等，且不能进行混合运算。为了与 <code>Number</code> 类型区别，<code>BigInt</code> 类型的数据必须添加后缀<code>n</code>。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">42n</span> === <span class="number">42</span>; <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="number">1n</span> + <span class="number">1.3</span>; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><hr><h2 id="7-函数的扩展"><a href="#7-函数的扩展" class="headerlink" title="7. 函数的扩展"></a>7. 函数的扩展</h2><h3 id="7-1-函数参数的默认值"><a href="#7-1-函数参数的默认值" class="headerlink" title="7.1 函数参数的默认值"></a>7.1 函数参数的默认值</h3><p><code>ES6</code> 允许为函数的参数设置默认值，可以直接写在参数定义的后面（通常是函数的尾参数）。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Point</span>(<span class="params">x = <span class="number">0</span>, y = <span class="number">0</span></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">x</span> = x; <span class="comment">// this.x = x || 0 （ES5 写法）</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">y</span> = y; <span class="comment">// this.y = y || 0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Point</span>();</span><br><span class="line">p; <span class="comment">// &#123; x: 0, y: 0 &#125;</span></span><br></pre></td></tr></table></figure><p>函数参数的默认值有两个好处</p><ul><li>阅读代码的人，可以立刻意识到哪些参数是可以省略的，不用查看函数体或文档。</li><li>有利于将来的代码优化，即使未来的版本在对外接口中，彻底拿掉这个参数，也不会导致以前的代码无法运行。</li></ul><p>参数默认值可以与解构赋值的默认值结合使用。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fetch</span>(<span class="params">url, &#123; body = <span class="string">&quot;&quot;</span>, method = <span class="string">&quot;GET&quot;</span>, headers = &#123;&#125; &#125;</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(method);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">fetch</span>(<span class="string">&quot;http://example.com&quot;</span>, &#123;&#125;);</span><br><span class="line"><span class="comment">// &quot;GET&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">fetch</span>(<span class="string">&quot;http://example.com&quot;</span>);</span><br><span class="line"><span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><p>上面代码中，函数<code>fetch</code>的第二个参数是一个对象，它的三个属性都有默认值。这种写法不能省略第二个参数，如果结合函数参数的默认值，就可以省略第二个参数。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fetch</span>(<span class="params">url, &#123; body = <span class="string">&quot;&quot;</span>, method = <span class="string">&quot;GET&quot;</span>, headers = &#123;&#125; &#125; = &#123;&#125;</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(method);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">fetch</span>(<span class="string">&quot;http://example.com&quot;</span>);</span><br><span class="line"><span class="comment">// &quot;GET&quot;</span></span><br></pre></td></tr></table></figure><p>上面代码中，当函数<code>fetch</code>没有第二个参数时，函数参数的默认值就会生效，然后才是解构赋值的默认值生效，变量<code>method</code>才会取到默认值<code>GET</code>。</p><p>注意，函数参数的默认值生效以后，参数解构赋值依然会进行。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">&#123; a, b = <span class="string">&quot;world&quot;</span> &#125; = &#123; a: <span class="string">&quot;hello&quot;</span> &#125;</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">f</span>(); <span class="comment">// world</span></span><br></pre></td></tr></table></figure><hr><h3 id="7-2-rest-参数"><a href="#7-2-rest-参数" class="headerlink" title="7.2 rest 参数"></a>7.2 rest 参数</h3><p><code>rest</code> 参数可以代替<code>arguments</code>对象，去获取函数的多余参数。<code>rest</code> 参数之后不能再有其他参数，它只能是最后一个参数。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// arguments变量的写法</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sortNumbers</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Array</span>.<span class="title function_">from</span>(<span class="variable language_">arguments</span>).<span class="title function_">sort</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">sortNumbers</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">3</span>));</span><br><span class="line"><span class="comment">// [1,2,3,5]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// rest参数的写法</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">sortNumbers</span> = (<span class="params">...numbers</span>) =&gt; numbers.<span class="title function_">sort</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">sortNumbers</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">3</span>));</span><br><span class="line"><span class="comment">// [1,2,3,5]</span></span><br></pre></td></tr></table></figure><p>上面代码的两种写法，比较后可以发现，<code>rest</code> 参数的写法更自然也更简洁。</p><hr><h3 id="7-3-箭头函数"><a href="#7-3-箭头函数" class="headerlink" title="7.3 箭头函数"></a>7.3 箭头函数</h3><p><code>ES6</code> 允许使用“箭头” <code>=&gt;</code> 定义函数。</p><ul><li>如果箭头函数不需要参数或需要多个参数，就使用一个圆括号代表参数部分。</li><li>如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用<code>return</code>语句返回。</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title function_">f</span> = (<span class="params"></span>) =&gt; <span class="number">5</span>;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">let</span> f = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="title function_">sum</span> = (<span class="params">num1, num2</span>) =&gt; num1 + num2;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">let</span> <span class="title function_">sum</span> = (<span class="params">num1, num2</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">let</span> sum = <span class="keyword">function</span> (<span class="params">num1, num2</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>箭头函数可以与变量解构结合使用。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">full</span> = (<span class="params">&#123; first, last &#125;</span>) =&gt; first + <span class="string">&quot; &quot;</span> + last;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">full</span>(<span class="params">person</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> person.<span class="property">first</span> + <span class="string">&quot; &quot;</span> + person.<span class="property">last</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>箭头函数还可以和上面的 <code>rest</code> 参数结合使用。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">numbers</span> = (<span class="params">...nums</span>) =&gt; nums;</span><br><span class="line"></span><br><span class="line"><span class="title function_">numbers</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line"><span class="comment">// [1,2,3,4,5]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">headAndTail</span> = (<span class="params">head, ...tail</span>) =&gt; [head, tail];</span><br><span class="line"></span><br><span class="line"><span class="title function_">headAndTail</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line"><span class="comment">// [1,[2,3,4,5]]</span></span><br></pre></td></tr></table></figure><p>箭头函数的重要用处是简化<a href="https://segmentfault.com/a/1190000021942060">回调函数</a>。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 普通函数写法</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].<span class="title function_">map</span>(<span class="keyword">function</span> (<span class="params">x</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 箭头函数写法</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].<span class="title function_">map</span>(<span class="function">(<span class="params">x</span>) =&gt;</span> x * x);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通函数写法</span></span><br><span class="line"><span class="keyword">let</span> result = values.<span class="title function_">sort</span>(<span class="keyword">function</span> (<span class="params">a, b</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> a - b;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 箭头函数写法</span></span><br><span class="line"><span class="keyword">let</span> result = values.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br></pre></td></tr></table></figure><p>箭头函数有几个使用<a href="https://es6.ruanyifeng.com/#docs/function#%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E7%82%B9">注意点</a>，其中最重要的是，箭头函数没有自己的<code>this</code>对象。</p><ul><li>对于<ins>普通函数来说，内部的<code>this</code>指向函数运行时所在的对象</ins>，但是<ins>这一点对箭头函数不成立。它没有自己的<code>this</code>对象，内部的<code>this</code>就是定义时上层作用域中的<code>this</code></ins>。也就是说，<ins>箭头函数内部的<code>this</code>指向是固定的</ins>，相比之下，<ins>普通函数的<code>this</code>指向是可变的</ins>。</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Timer</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">s1</span> = <span class="number">0</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">s2</span> = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 箭头函数</span></span><br><span class="line">  <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> <span class="variable language_">this</span>.<span class="property">s1</span>++, <span class="number">1000</span>);</span><br><span class="line">  <span class="comment">// 普通函数</span></span><br><span class="line">  <span class="built_in">setInterval</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">s2</span>++;</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> timer = <span class="keyword">new</span> <span class="title class_">Timer</span>(); <span class="comment">// 注意</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;s1: &quot;</span>, timer.<span class="property">s1</span>), <span class="number">3100</span>);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;s2: &quot;</span>, timer.<span class="property">s2</span>), <span class="number">3100</span>);</span><br><span class="line"><span class="comment">// s1: 3</span></span><br><span class="line"><span class="comment">// s2: 0</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>Timer</code>函数内部设置了两个定时器，分别使用了箭头函数和普通函数。<ins>前者的<code>this</code>绑定定义时所在的作用域，即<code>Timer</code>函数，后者的<code>this</code>指向运行时所在的作用域，即全局对象</ins>。所以，<code>3100</code> 毫秒之后，<code>timer.s1</code>被更新了 <code>3</code> 次，而<code>timer.s2</code>一次都没更新。</p><hr><h2 id="8-数组的扩展"><a href="#8-数组的扩展" class="headerlink" title="8. 数组的扩展"></a>8. 数组的扩展</h2><h3 id="8-1-扩展运算符"><a href="#8-1-扩展运算符" class="headerlink" title="8.1 扩展运算符"></a>8.1 扩展运算符</h3><p>扩展运算符 <code>...</code>，将一个数组转为用逗号分隔的参数序列。类似 <code>rest</code> 参数的逆运算。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(...[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="comment">// 1 2 3</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>, ...[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], <span class="number">5</span>)</span><br><span class="line"><span class="comment">// 1 2 3 4 5</span></span><br><span class="line"></span><br><span class="line">[...<span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;div&#x27;</span>)]</span><br><span class="line"><span class="comment">// [&lt;div&gt;, &lt;div&gt;, &lt;div&gt;]</span></span><br></pre></td></tr></table></figure><p>扩展运算符主要用于函数调用，可以代替<code>apply()</code>方法将数组转为函数的参数。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ES5 的写法</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">x, y, z</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> args = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">f.<span class="title function_">apply</span>(<span class="literal">null</span>, args);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6 的写法</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">x, y, z</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> args = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="title function_">f</span>(...args);</span><br></pre></td></tr></table></figure><hr><h3 id="8-2-扩展运算符的应用"><a href="#8-2-扩展运算符的应用" class="headerlink" title="8.2 扩展运算符的应用"></a>8.2 扩展运算符的应用</h3><p><strong>（1）复制数组</strong></p><p>数组是复合的数据类型，直接复制的话，只是复制了指向底层数据结构的指针，而不是克隆一个全新的数组。扩展运算符提供了复制数组的简便写法。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a1 = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">const</span> a2 = a1;</span><br><span class="line"></span><br><span class="line">a2[<span class="number">0</span>] = <span class="number">2</span>;</span><br><span class="line">a1; <span class="comment">// [2, 2]，浅拷贝</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="keyword">const</span> a2 = [...a1];</span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="keyword">const</span> [...a2] = a1;</span><br></pre></td></tr></table></figure><p><strong>（2）合并数组</strong></p><p>扩展运算符提供了数组合并的新写法。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr1 = [<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>];</span><br><span class="line"><span class="keyword">const</span> arr2 = [<span class="string">&quot;c&quot;</span>];</span><br><span class="line"><span class="keyword">const</span> arr3 = [<span class="string">&quot;d&quot;</span>, <span class="string">&quot;e&quot;</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES5 的合并数组</span></span><br><span class="line">arr1.<span class="title function_">concat</span>(arr2, arr3);</span><br><span class="line"><span class="comment">// [ &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27; ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6 的合并数组</span></span><br><span class="line">[...arr1, ...arr2, ...arr3];</span><br><span class="line"><span class="comment">// [ &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27; ]</span></span><br></pre></td></tr></table></figure><p>不过两种方法都是<a href="https://vue3js.cn/interview/JavaScript/copy.html">浅拷贝</a>，使用的时候需要特别小心。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a1 = [&#123; <span class="attr">foo</span>: <span class="number">1</span> &#125;];</span><br><span class="line"><span class="keyword">const</span> a2 = [&#123; <span class="attr">bar</span>: <span class="number">2</span> &#125;];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a3 = a1.<span class="title function_">concat</span>(a2);</span><br><span class="line"><span class="keyword">const</span> a4 = [...a1, ...a2];</span><br><span class="line"></span><br><span class="line">a3[<span class="number">0</span>] === a1[<span class="number">0</span>]; <span class="comment">// true</span></span><br><span class="line">a4[<span class="number">0</span>] === a1[<span class="number">0</span>]; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>a3</code>和<code>a4</code>是用两种不同方法合并而成的新数组，但是它们的成员都是对原数组成员的引用，这就是浅拷贝。<ins>如果修改了引用指向的值，会同步反映到新数组</ins>。<br><br></p><p><strong>（3）与解构赋值结合</strong></p><p>扩展运算符可以与解构赋值结合起来，用于生成数组。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> [first, ...rest] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">first; <span class="comment">// 1</span></span><br><span class="line">rest; <span class="comment">// [2, 3, 4, 5]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> [first, ...rest] = [];</span><br><span class="line">first; <span class="comment">// undefined</span></span><br><span class="line">rest; <span class="comment">// []</span></span><br></pre></td></tr></table></figure><p><strong>（4）具有 Iterator 接口的对象</strong></p><p>扩展运算符调用的是数据结构的 <code>Iterator</code> 接口，因此只要具有 <code>Iterator</code> 接口的对象，都可以使用扩展运算符。比如字符串，<code>Map</code>和<code>Set</code>，<code>Generator</code>函数返回的遍历器对象。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[...<span class="string">&quot;hello&quot;</span>];</span><br><span class="line"><span class="comment">// [ &quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot; ]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>([</span><br><span class="line">  [<span class="number">1</span>, <span class="string">&quot;one&quot;</span>],</span><br><span class="line">  [<span class="number">2</span>, <span class="string">&quot;two&quot;</span>],</span><br><span class="line">  [<span class="number">3</span>, <span class="string">&quot;three&quot;</span>],</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = [...map.<span class="title function_">keys</span>()]; <span class="comment">// [1, 2, 3]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> go = <span class="keyword">function</span>* () &#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">[...<span class="title function_">go</span>()]; <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure><hr><h3 id="8-3-新增方法"><a href="#8-3-新增方法" class="headerlink" title="8.3 新增方法"></a>8.3 新增方法</h3><p><code>Array.from()</code>方法用于将两类对象转为真正的数组，类似数组的对象和可遍历的对象。（包括 <code>ES6</code> 新增的数据结构 <code>Set</code> 和 <code>Map</code>，和部署了 <code>Iterator</code> 接口的数据结构）<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arrayLike = &#123;</span><br><span class="line">  <span class="number">0</span>: <span class="string">&quot;a&quot;</span>,</span><br><span class="line">  <span class="number">1</span>: <span class="string">&quot;b&quot;</span>,</span><br><span class="line">  <span class="number">2</span>: <span class="string">&quot;c&quot;</span>,</span><br><span class="line">  <span class="attr">length</span>: <span class="number">3</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES5 的写法</span></span><br><span class="line"><span class="keyword">var</span> arr1 = [].<span class="property">slice</span>.<span class="title function_">call</span>(arrayLike); <span class="comment">// [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6 的写法</span></span><br><span class="line"><span class="keyword">let</span> arr2 = <span class="title class_">Array</span>.<span class="title function_">from</span>(arrayLike); <span class="comment">// [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]</span></span><br></pre></td></tr></table></figure><p><code>Array.from()</code>还可以接受一个函数作为第二个参数，作用类似于数组的<code>map()</code>方法，用来对每个元素进行处理，将处理后的值放入返回的数组。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="title function_">from</span>(arrayLike, <span class="function">(<span class="params">x</span>) =&gt;</span> x * x);</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="title class_">Array</span>.<span class="title function_">from</span>(arrayLike).<span class="title function_">map</span>(<span class="function">(<span class="params">x</span>) =&gt;</span> x * x);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Array</span>.<span class="title function_">from</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="function">(<span class="params">x</span>) =&gt;</span> x * x);</span><br><span class="line"><span class="comment">// [1, 4, 9]</span></span><br></pre></td></tr></table></figure><p><code>Array.of()</code>方法用于将一组值，转换为数组。它可以替代<code>Array()</code>或<code>new Array()</code>，并且不存在由于参数不同而导致的重载。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="title function_">of</span>(<span class="number">3</span>, <span class="number">11</span>, <span class="number">8</span>); <span class="comment">// [3,11,8]</span></span><br><span class="line"><span class="title class_">Array</span>.<span class="title function_">of</span>(<span class="number">3</span>); <span class="comment">// [3]</span></span><br><span class="line"><span class="title class_">Array</span>.<span class="title function_">of</span>(<span class="number">3</span>).<span class="property">length</span>; <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载</span></span><br><span class="line"><span class="title class_">Array</span>(); <span class="comment">// []</span></span><br><span class="line"><span class="title class_">Array</span>(<span class="number">3</span>); <span class="comment">// [, , ,]</span></span><br><span class="line"><span class="title class_">Array</span>(<span class="number">3</span>, <span class="number">11</span>, <span class="number">8</span>); <span class="comment">// [3, 11, 8]</span></span><br></pre></td></tr></table></figure><p><code>find()</code>方法，用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为<code>true</code>的成员，然后返回该成员。如果没有符合条件的成员，则返回<code>undefined</code>。<br><br></p><p><code>findIndex()</code>方法的用法与<code>find()</code>方法类似，返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回<code>-1</code>。<code>find()</code>和<code>findIndex()</code>都是从数组的<code>0</code>号位，依次向后检查。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">4</span>, -<span class="number">5</span>, <span class="number">10</span>]</span><br><span class="line">  .<span class="title function_">find</span>(<span class="function">(<span class="params">n</span>) =&gt;</span> n &lt; <span class="number">0</span>)</span><br><span class="line">  [</span><br><span class="line">    <span class="comment">// -5</span></span><br><span class="line"></span><br><span class="line">    (<span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>)</span><br><span class="line">  ].<span class="title function_">findIndex</span>(<span class="keyword">function</span> (<span class="params">value, index, arr</span>) &#123;</span><br><span class="line">    <span class="comment">// 当前的值、当前的位置和原数组</span></span><br><span class="line">    <span class="keyword">return</span> value &gt; <span class="number">9</span>;</span><br><span class="line">  &#125;); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>与之相反，<code>findLast()</code>和<code>findLastIndex()</code>是从数组的最后一个成员开始，依次向前检查，其他都保持不变。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> array = [&#123; <span class="attr">value</span>: <span class="number">1</span> &#125;, &#123; <span class="attr">value</span>: <span class="number">2</span> &#125;, &#123; <span class="attr">value</span>: <span class="number">3</span> &#125;, &#123; <span class="attr">value</span>: <span class="number">4</span> &#125;];</span><br><span class="line"></span><br><span class="line">array.<span class="title function_">findLast</span>(<span class="function">(<span class="params">n</span>) =&gt;</span> n.<span class="property">value</span> % <span class="number">2</span> === <span class="number">1</span>); <span class="comment">// &#123; value: 3 &#125;</span></span><br><span class="line">array.<span class="title function_">findLastIndex</span>(<span class="function">(<span class="params">n</span>) =&gt;</span> n.<span class="property">value</span> % <span class="number">2</span> === <span class="number">1</span>); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p><code>fill()</code>方法使用给定值，填充一个数组。它还可以接受第二个和第三个参数，用于指定填充的起始位置和结束位置。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>].<span class="title function_">fill</span>(<span class="number">7</span>);</span><br><span class="line"><span class="comment">// [7, 7, 7]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">3</span>).<span class="title function_">fill</span>(<span class="number">7</span>)[</span><br><span class="line">  <span class="comment">// [7, 7, 7]</span></span><br><span class="line"></span><br><span class="line">  (<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>)</span><br><span class="line">].<span class="title function_">fill</span>(<span class="number">7</span>, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="comment">// [&#x27;a&#x27;, 7, &#x27;c&#x27;]</span></span><br></pre></td></tr></table></figure><p><code>ES6</code> 提供三个新的方法用于遍历数组。<code>keys()</code>是对键名的遍历，<code>values()</code>是对键值的遍历，<code>entries()</code>是对键值对的遍历。它们都可以用<code>for...of</code>循环进行遍历。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> index <span class="keyword">of</span> [<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>].<span class="title function_">keys</span>()) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(index);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> elem <span class="keyword">of</span> [<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>].<span class="title function_">values</span>()) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(elem);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &#x27;a&#x27;</span></span><br><span class="line"><span class="comment">// &#x27;b&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [index, elem] <span class="keyword">of</span> [<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>].<span class="title function_">entries</span>()) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(index, elem);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0 &quot;a&quot;</span></span><br><span class="line"><span class="comment">// 1 &quot;b&quot;</span></span><br></pre></td></tr></table></figure><p><code>includes()</code>方法返回一个布尔值，表示某个数组是否包含给定的值。该方法的第二个参数表示搜索的起始位置，默认为<code>0</code>。如果第二个参数为负数，则表示倒数的位置。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">  .<span class="title function_">includes</span>(<span class="number">2</span>) <span class="comment">// true</span></span><br><span class="line">  [(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)].<span class="title function_">includes</span>(<span class="number">4</span>) <span class="comment">// false</span></span><br><span class="line">  [(<span class="number">1</span>, <span class="number">2</span>, <span class="title class_">NaN</span>)].<span class="title function_">includes</span>(<span class="title class_">NaN</span>) <span class="comment">// true</span></span><br><span class="line">  [(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)].<span class="title function_">includes</span>(<span class="number">3</span>, -<span class="number">1</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>数组的成员有时还是数组，<code>flat()</code>方法用于将嵌套的数组“拉平”，变成一维的数组。该方法返回一个新数组，对原数据没有影响。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>]].<span class="title function_">flat</span>();</span><br><span class="line"><span class="comment">// [1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure><p><code>flat()</code>方法默认只会“拉平”一层，如果想要“拉平”多层的嵌套数组，可以指定<code>flat()</code>方法的参数，表示想要拉平的层数，默认为<code>1</code>。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>]]]</span><br><span class="line">  .<span class="title function_">flat</span>()</span><br><span class="line">  [</span><br><span class="line">    <span class="comment">// [1, 2, 3, [4, 5]]</span></span><br><span class="line"></span><br><span class="line">    (<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>]])</span><br><span class="line">  ].<span class="title function_">flat</span>(<span class="number">2</span>)</span><br><span class="line">  [</span><br><span class="line">    <span class="comment">// [1, 2, 3, 4, 5]</span></span><br><span class="line"></span><br><span class="line">    (<span class="number">1</span>, [<span class="number">2</span>, [<span class="number">3</span>]])</span><br><span class="line">  ].<span class="title function_">flat</span>(<span class="title class_">Infinity</span>);</span><br><span class="line"><span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure><p><code>flatMap()</code>方法对原数组的每个成员执行一个函数（相当于执行<code>map()</code>）, 然后对返回值组成的数组执行<code>flat()</code>方法。注意，<code>flatMap()</code>只能展开一层数组。该方法返回一个新数组，不改变原数组。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 相当于 [[2, 4], [3, 6], [4, 8]].flat()</span></span><br><span class="line">[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">  .<span class="title function_">flatMap</span>(<span class="function">(<span class="params">x</span>) =&gt;</span> [x, x * <span class="number">2</span>])</span><br><span class="line">  [</span><br><span class="line">    <span class="comment">// [2, 4, 3, 6, 4, 8]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 相当于 [[[2]], [[4]], [[6]], [[8]]].flat()</span></span><br><span class="line">    (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">  ].<span class="title function_">flatMap</span>(<span class="function">(<span class="params">x</span>) =&gt;</span> [[x * <span class="number">2</span>]]);</span><br><span class="line"><span class="comment">// [[2], [4], [6], [8]]</span></span><br></pre></td></tr></table></figure><p><code>ES5</code> 不支持数组的负索引，如果要引用数组的最后一个成员，不能写成<code>arr[-1]</code>，只能使用<code>arr[arr.length - 1]</code>。<code>ES6</code> 为数组实例增加了<code>at()</code>方法，接受一个整数作为参数，返回对应位置的成员，并支持负索引。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">5</span>, <span class="number">12</span>, <span class="number">8</span>, <span class="number">130</span>, <span class="number">44</span>];</span><br><span class="line"></span><br><span class="line">arr[-<span class="number">2</span>]; <span class="comment">// Error</span></span><br><span class="line">arr.<span class="title function_">at</span>(<span class="number">2</span>); <span class="comment">// 8</span></span><br><span class="line">arr.<span class="title function_">at</span>(-<span class="number">2</span>); <span class="comment">// 130</span></span><br></pre></td></tr></table></figure><hr><h2 id="9-对象的扩展"><a href="#9-对象的扩展" class="headerlink" title="9. 对象的扩展"></a>9. 对象的扩展</h2><p><a href="https://es6.ruanyifeng.com/#docs/object">本章</a>内容复杂，故先跳过一部分。</p><h3 id="9-1-属性的简洁表示法"><a href="#9-1-属性的简洁表示法" class="headerlink" title="9.1 属性的简洁表示法"></a>9.1 属性的简洁表示法</h3><p><code>ES6</code> 允许在大括号里面，直接写入变量和函数，作为对象的属性和方法。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> birth = <span class="string">&quot;2000/01/01&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Person</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;张三&quot;</span>,</span><br><span class="line">  birth, <span class="comment">// 等同于 birth: birth</span></span><br><span class="line">  <span class="title function_">hello</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;我的名字是&quot;</span>, <span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 等同于 hello: function ()...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h3 id="9-2-super-关键字"><a href="#9-2-super-关键字" class="headerlink" title="9.2 super 关键字"></a>9.2 super 关键字</h3><p>众所周知，<ins><code>this</code>关键字总是指向函数所在的当前对象</ins>，<code>ES6</code> 又新增了另一个类似的关键字<ins><code>super</code>，指向当前对象的原型对象</ins>。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> proto = &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="string">&quot;hello&quot;</span>,</span><br><span class="line">  <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">x</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="string">&quot;world&quot;</span>,</span><br><span class="line">  <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>.<span class="title function_">foo</span>();</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(obj, proto);</span><br><span class="line">obj.<span class="title function_">foo</span>(); <span class="comment">// &quot;world&quot;</span></span><br></pre></td></tr></table></figure><p>上面代码中，对象<code>obj.foo()</code>方法之中，通过<code>super.foo</code>引用了原型对象<code>proto</code>的<code>foo</code>方法。<ins>但是绑定的<code>this</code>却还是当前对象<code>obj</code>，因此输出的就是<code>world</code></ins>。<br><br></p><p>注意，<code>super</code>关键字表示原型对象时，<ins>只能用在对象的方法之中</ins>，用在其他地方都会报错。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">/ 报错</span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">foo</span>: <span class="variable language_">super</span>.<span class="property">foo</span> <span class="comment">// 对象属性</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">foo</span>: <span class="function">() =&gt;</span> <span class="variable language_">super</span>.<span class="property">foo</span> <span class="comment">// 对象属性</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">foo</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="comment">// 对象属性</span></span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">super</span>.<span class="property">foo</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="9-3-对象的扩展运算符"><a href="#9-3-对象的扩展运算符" class="headerlink" title="9.3 对象的扩展运算符"></a>9.3 对象的扩展运算符</h3><p><strong>（1）解构赋值</strong></p><p>对象的解构赋值用于从一个对象取值，将目标对象所有<a href="https://es6.ruanyifeng.com/#docs/object#%E5%B1%9E%E6%80%A7%E7%9A%84%E5%8F%AF%E6%9E%9A%E4%B8%BE%E6%80%A7%E5%92%8C%E9%81%8D%E5%8E%86">可遍历</a>的、但尚未被读取的属性，分配到指定的对象上面。（注意，解构赋值必须是最后一个参数，且等号右边不能是<code>undefined</code>或<code>null</code>）<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; x, y, ...z &#125; = &#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span>, <span class="attr">a</span>: <span class="number">3</span>, <span class="attr">b</span>: <span class="number">4</span> &#125;;</span><br><span class="line">x <span class="comment">// 1</span></span><br><span class="line">y <span class="comment">// 2</span></span><br><span class="line">z <span class="comment">// &#123; a: 3, b: 4 &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> z = &#123; <span class="attr">a</span>: <span class="number">3</span>, <span class="attr">b</span>: <span class="number">4</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> n = &#123; ...z &#125;;</span><br><span class="line">n <span class="comment">// &#123; a: 3, b: 4 &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; ...x, y, z &#125; = someObject; <span class="comment">// 句法错误</span></span><br></pre></td></tr></table></figure><p>解构赋值的拷贝是<a href="https://vue3js.cn/interview/JavaScript/copy.html">浅拷贝</a>，即<ins>如果一个键的值是复合类型的值（如数组、对象、函数），那么解构赋值拷贝的是这个值的引用，而不是这个值的副本</ins>。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">a</span>: &#123; <span class="attr">b</span>: <span class="number">1</span> &#125; &#125;;</span><br><span class="line"><span class="keyword">let</span> &#123; ...x &#125; = obj;</span><br><span class="line">obj.<span class="property">a</span>.<span class="property">b</span> = <span class="number">2</span>;</span><br><span class="line">x.<span class="property">a</span>.<span class="property">b</span>; <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>x</code>是解构赋值所在的对象，拷贝了对象<code>obj</code>的<code>a</code>属性。<code>a</code>属性引用了一个对象，修改这个对象的值，会影响到解构赋值对它的引用。<br><br></p><p>解构赋值的一个用处，是扩展某个函数的参数，引入其他操作。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">baseFunction</span>(<span class="params">&#123; a, b &#125;</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">wrapperFunction</span>(<span class="params">&#123; x, y, ...restConfig &#125;</span>) &#123;</span><br><span class="line">  <span class="comment">// 使用 x 和 y 参数进行操作</span></span><br><span class="line">  <span class="comment">// 其余参数传给原始函数</span></span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">baseFunction</span>(restConfig);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，原始函数<code>baseFunction</code>接受<code>a</code>和<code>b</code>作为参数，函数<code>wrapperFunction</code>在<code>baseFunction</code>的基础上进行了扩展，能够接受多余的参数，并且保留原始函数的行为。<br><br></p><p><strong>（2）扩展运算符</strong></p><p>对象的扩展运算符 <code>...</code> 用于取出参数对象的所有可遍历属性，拷贝到当前对象之中。（扩展运算符不需要是最后一个参数）<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> z = &#123; <span class="attr">a</span>: <span class="number">3</span>, <span class="attr">b</span>: <span class="number">4</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> n = &#123; ...z &#125;;</span><br><span class="line">n <span class="comment">// &#123; a: 3, b: 4 &#125;</span></span><br><span class="line"></span><br><span class="line">&#123;...&#123;&#125;, <span class="attr">a</span>: <span class="number">1</span>&#125;</span><br><span class="line"><span class="comment">// &#123; a: 1 &#125;</span></span><br></pre></td></tr></table></figure><p>扩展运算符还可以用于合并两个对象。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> ab = &#123; ...a, ...b &#125;;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">let</span> ab = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, a, b);</span><br></pre></td></tr></table></figure><p>如果用户自定义的属性，放在扩展运算符后面，则扩展运算符内部的同名属性会被覆盖掉。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> aWithOverrides = &#123; ...a, <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">let</span> aWithOverrides = &#123; ...a, ...&#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span> &#125; &#125;;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">let</span> x = <span class="number">1</span>,</span><br><span class="line">  y = <span class="number">2</span>,</span><br><span class="line">  aWithOverrides = &#123; ...a, x, y &#125;;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">let</span> aWithOverrides = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, a, &#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span> &#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，<code>a</code>对象的<code>x</code>属性和<code>y</code>属性，拷贝到新对象后会被覆盖掉。</p><hr><h2 id="10-对象的新增方法"><a href="#10-对象的新增方法" class="headerlink" title="10. 对象的新增方法"></a>10. 对象的新增方法</h2><p><a href="https://es6.ruanyifeng.com/#docs/object-methods">本章</a>内容复杂，故先跳过一部分。</p><h3 id="10-1-静态方法"><a href="#10-1-静态方法" class="headerlink" title="10.1 静态方法"></a>10.1 静态方法</h3><p><code>ES5</code> 中比较两个值是否相等，只有两个运算符，相等运算符<code>==</code>和严格相等运算符<code>===</code>。它们都有缺点，前者会自动转换数据类型，后者的<code>NaN</code>不等于自身，以及<code>+0</code>等于<code>-0</code>。<br><br></p><p><code>Object.is()</code>方法用来比较两个值是否严格相等，与严格比较运算符<code>===</code>的行为基本一致。不同之处只有两个，一是<code>+0</code>不等于<code>-0</code>，二是<code>NaN</code>等于自身。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">is</span>(<span class="string">&quot;foo&quot;</span>, <span class="string">&quot;foo&quot;</span>);</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">is</span>(&#123;&#125;, &#123;&#125;);</span><br><span class="line"><span class="comment">// false</span></span><br></pre></td></tr></table></figure><p><code>Object.assign()</code>方法用于对象的合并，将源对象<code>source</code>的所有可枚举属性，复制到目标对象<code>target</code>。它的第一个参数是目标对象，后面的参数都是源对象。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> source1 = &#123; <span class="attr">b</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> source2 = &#123; <span class="attr">c</span>: <span class="number">3</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">assign</span>(target, source1, source2);</span><br><span class="line">target; <span class="comment">// &#123;a:1, b:2, c:3&#125;</span></span><br></pre></td></tr></table></figure><p><code>Object.assign()</code>有以下几个使用注意点。<br><br></p><p><strong>（1）浅拷贝</strong></p><p><code>Object.assign()</code>方法实行的是浅拷贝，而不是深拷贝。也就是说，如果源对象某个属性的值是对象，那么目标对象拷贝得到的是这个对象的引用（指针）。<br><br></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const obj1 = &#123;a: &#123;b: 1&#125;&#125;;</span><br><span class="line">const obj2 = Object.assign(&#123;&#125;, obj1);</span><br><span class="line"></span><br><span class="line">obj1.a.b = 2;</span><br><span class="line">obj2.a.b // 2</span><br></pre></td></tr></table></figure><p>上面代码中，源对象<code>obj1</code>的<code>a</code>属性的值是一个对象，<code>Object.assign()</code>拷贝得到的是这个对象的引用。这个对象的任何变化，都会反映到目标对象上面。<br><br></p><p><strong>（2）同名属性的替换</strong></p><p>对于嵌套的对象，一旦遇到同名属性，<code>Object.assign()</code>的处理方法是替换，而不是添加。这通常不是我们想要的，需要特别小心。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123; <span class="attr">a</span>: &#123; <span class="attr">b</span>: <span class="string">&quot;c&quot;</span>, <span class="attr">d</span>: <span class="string">&quot;e&quot;</span> &#125; &#125;;</span><br><span class="line"><span class="keyword">const</span> source = &#123; <span class="attr">a</span>: &#123; <span class="attr">b</span>: <span class="string">&quot;hello&quot;</span> &#125; &#125;;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">assign</span>(target, source);</span><br><span class="line"><span class="comment">// &#123; a: &#123; b: &#x27;hello&#x27; &#125; &#125;</span></span><br></pre></td></tr></table></figure><p>对于普通对象，我们可以用下面的方法对对象进行遍历。</p><ul><li><code>Object.keys()</code>返回一个数组，成员是参数对象自身的所有可遍历属性的键名。</li><li><code>Object.values()</code>返回一个数组，成员是参数对象自身的所有可遍历属性的键值。</li><li><code>Object.entries()</code>返回一个数组，成员是参数对象自身的所有可遍历属性的键值对数组。</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">foo</span>: <span class="string">&quot;bar&quot;</span>, <span class="attr">baz</span>: <span class="number">42</span> &#125;;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">keys</span>(obj);</span><br><span class="line"><span class="comment">// [&quot;foo&quot;, &quot;baz&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">foo</span>: <span class="string">&quot;bar&quot;</span>, <span class="attr">baz</span>: <span class="number">42</span> &#125;;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">values</span>(obj);</span><br><span class="line"><span class="comment">// [&quot;bar&quot;, 42]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">foo</span>: <span class="string">&quot;bar&quot;</span>, <span class="attr">baz</span>: <span class="number">42</span> &#125;;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">entries</span>(obj);</span><br><span class="line"><span class="comment">// [ [&quot;foo&quot;, &quot;bar&quot;], [&quot;baz&quot;, 42] ]</span></span><br></pre></td></tr></table></figure><hr><h2 id="11-运算符的扩展"><a href="#11-运算符的扩展" class="headerlink" title="11. 运算符的扩展"></a>11. 运算符的扩展</h2><h3 id="11-1-链判断运算符"><a href="#11-1-链判断运算符" class="headerlink" title="11.1 链判断运算符"></a>11.1 链判断运算符</h3><p>当我们打算读取对象内部的某个属性时，往往需要判断一下属性的上层对象是否存在。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误的写法</span></span><br><span class="line"><span class="keyword">const</span> firstName = message.<span class="property">body</span>.<span class="property">user</span>.<span class="property">firstName</span> || <span class="string">&quot;default&quot;</span>; <span class="comment">// 无法保证 message.body 存在...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确的写法</span></span><br><span class="line"><span class="keyword">const</span> firstName =</span><br><span class="line">  (message &amp;&amp;</span><br><span class="line">    message.<span class="property">body</span> &amp;&amp;</span><br><span class="line">    message.<span class="property">body</span>.<span class="property">user</span> &amp;&amp;</span><br><span class="line">    message.<span class="property">body</span>.<span class="property">user</span>.<span class="property">firstName</span>) ||</span><br><span class="line">  <span class="string">&quot;default&quot;</span>;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>firstName</code>属性在对象的第四层，所以需要判断四次，每一层是否有值。这样的层层判断非常麻烦，因此 <code>ES6</code> 引入了“链判断运算符” <code>?.</code>，用来简化上面的写法。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> firstName = message?.<span class="property">body</span>?.<span class="property">user</span>?.<span class="property">firstName</span> || <span class="string">&quot;default&quot;</span>;</span><br></pre></td></tr></table></figure><p>上面代码使用了<code>?.</code>运算符，直接在链式调用的时候判断，左侧的对象是否为<code>null</code>或<code>undefined</code>。如果是的，就不再往下运算，而是返回<code>undefined</code>。<br><br></p><p>下面是 <code>?.</code> 运算符常见形式，以及不使用该运算符时的等价形式。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">a?.<span class="property">b</span>;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">a == <span class="literal">null</span> ? <span class="literal">undefined</span> : a.<span class="property">b</span>;</span><br><span class="line"></span><br><span class="line">a?.[x];</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">a == <span class="literal">null</span> ? <span class="literal">undefined</span> : a[x];</span><br><span class="line"></span><br><span class="line">a?.<span class="title function_">b</span>();</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">a == <span class="literal">null</span> ? <span class="literal">undefined</span> : a.<span class="title function_">b</span>();</span><br><span class="line"></span><br><span class="line">a?.();</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">a == <span class="literal">null</span> ? <span class="literal">undefined</span> : <span class="title function_">a</span>();</span><br></pre></td></tr></table></figure><hr><h3 id="11-2-Null-判断运算符"><a href="#11-2-Null-判断运算符" class="headerlink" title="11.2 Null 判断运算符"></a>11.2 Null 判断运算符</h3><p>读取对象属性的时候，如果某个属性的值是<code>null</code>或<code>undefined</code>，有时候需要为它们指定默认值。常见做法是通过<code>||</code>运算符指定默认值。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> headerText = response.<span class="property">settings</span>.<span class="property">headerText</span> || <span class="string">&quot;Hello, world!&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> animationDuration = response.<span class="property">settings</span>.<span class="property">animationDuration</span> || <span class="number">300</span>;</span><br><span class="line"><span class="keyword">const</span> showSplashScreen = response.<span class="property">settings</span>.<span class="property">showSplashScreen</span> || <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><p>但是属性的值如果为空字符串或<code>false</code>或<code>0</code>，默认值也会生效。为此，<code>ES6</code> 引入了一个新的 <code>Null</code> 判断运算符<code>??</code>。它的行为类似<code>||</code>，但是只有运算符左侧的值为<code>null</code>或<code>undefined</code>时，才会返回右侧的值。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> animationDuration = response.<span class="property">settings</span>?.<span class="property">animationDuration</span> ?? <span class="number">300</span>;</span><br></pre></td></tr></table></figure><p>上面代码中，如果<code>response.settings</code>是<code>null</code>或<code>undefined</code>，或者<code>response.settings.animationDuration</code>是<code>null</code>或<code>undefined</code>，就会返回默认值<code>300</code>。</p><hr><h2 id="12-Symbol-数据类型"><a href="#12-Symbol-数据类型" class="headerlink" title="12. Symbol 数据类型"></a>12. Symbol 数据类型</h2><p><a href="https://es6.ruanyifeng.com/#docs/symbol">本章</a>内容复杂，故先跳过一部分。</p><h3 id="12-1-Symbol-概述"><a href="#12-1-Symbol-概述" class="headerlink" title="12.1 Symbol 概述"></a>12.1 Symbol 概述</h3><p><code>ES6</code> 引入了一种新的原始数据类型 <code>Symbol</code>，表示独一无二的值。</p><p><code>Symbol</code> 通过 <code>Symbol()</code> 函数生成，可以用于为对象添加新的方法，且不存在属性名冲突。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="title class_">Symbol</span>(); <span class="comment">// Symbol() 函数前不能使用 new 命令</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> s;</span><br><span class="line"><span class="comment">// &quot;symbol&quot;</span></span><br></pre></td></tr></table></figure><p><code>ES6</code> 提供了一个 <code>Symbol</code> 值的实例属性<code>description</code>，直接返回 <code>Symbol</code> 值的描述。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> sym = <span class="title class_">Symbol</span>(<span class="string">&quot;foo&quot;</span>); <span class="comment">// 字符串作为参数</span></span><br><span class="line"></span><br><span class="line">sym; <span class="comment">// [object Symbol] &#123; ... &#125;</span></span><br><span class="line">sym.<span class="title function_">toString</span>(); <span class="comment">// &quot;Symbol(foo)&quot;</span></span><br><span class="line"></span><br><span class="line">sym.<span class="property">description</span>; <span class="comment">// &quot;foo&quot;</span></span><br></pre></td></tr></table></figure><p>因为 <code>Symbol</code> 值都是不相等的（就算是相同描述，除非使用 <a href="https://es6.ruanyifeng.com/#docs/symbol#Symbol-for%EF%BC%8CSymbol-keyFor"><code>Symbol.for</code></a>），使用 <code>Symbol</code> 值作为标识符，用于对象的属性名，就能保证不会出现同名的属性。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> mySymbol = <span class="title class_">Symbol</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一种写法</span></span><br><span class="line"><span class="keyword">let</span> a = &#123;&#125;;</span><br><span class="line">a[mySymbol] = <span class="string">&quot;Hello!&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种写法</span></span><br><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">  [mySymbol]: <span class="string">&quot;Hello!&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以上写法都得到同样结果</span></span><br><span class="line">a[mySymbol]; <span class="comment">// &quot;Hello!&quot;</span></span><br></pre></td></tr></table></figure><hr><h2 id="13-Set-和-Map-数据结构"><a href="#13-Set-和-Map-数据结构" class="headerlink" title="13. Set 和 Map 数据结构"></a>13. Set 和 Map 数据结构</h2><p><a href="https://es6.ruanyifeng.com/#docs/set-map">本章</a>跳过 <code>WeakSet</code> 和 <code>WeakMap</code> 部分。</p><h3 id="13-1-Set-基本用法"><a href="#13-1-Set-基本用法" class="headerlink" title="13.1 Set 基本用法"></a>13.1 Set 基本用法</h3><p><code>ES6</code>提供了新的数据结构 <code>Set</code>。它类似于数组，但是<ins>成员的值都是唯一的，没有重复的值</ins>。它可以接受一个数组，或者具有 <code>iterable</code> 接口的其他数据结构，作为参数初始化。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line"></span><br><span class="line">[<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">2</span>].<span class="title function_">forEach</span>(<span class="function">(<span class="params">x</span>) =&gt;</span> s.<span class="title function_">add</span>(x));</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> s) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2 3 5 4</span></span><br></pre></td></tr></table></figure><p>下面介绍 <code>Set</code> 实例的属性和方法</p><ul><li><code>Set.prototype.size</code>：返回<code>Set</code>实例的成员总数。</li><li><code>Set.prototype.add(value)</code>：添加某个值，返回 <code>Set</code> 结构本身。</li><li><code>Set.prototype.delete(value)</code>：删除某个值，返回一个布尔值，表示删除是否成功。</li><li><code>Set.prototype.has(value)</code>：返回一个布尔值，表示该值是否为<code>Set</code>的成员。</li><li><code>Set.prototype.clear()</code>：清除所有成员，没有返回值。</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line">s.<span class="title function_">add</span>(<span class="number">1</span>).<span class="title function_">add</span>(<span class="number">2</span>).<span class="title function_">add</span>(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 注意2被加入了两次</span></span><br><span class="line"></span><br><span class="line">s.<span class="property">size</span>; <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">s.<span class="title function_">has</span>(<span class="number">1</span>); <span class="comment">// true</span></span><br><span class="line">s.<span class="title function_">has</span>(<span class="number">2</span>); <span class="comment">// true</span></span><br><span class="line">s.<span class="title function_">has</span>(<span class="number">3</span>); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">s.<span class="title function_">delete</span>(<span class="number">2</span>);</span><br><span class="line">s.<span class="title function_">has</span>(<span class="number">2</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p><code>Set</code> 结构的实例默认可遍历, 可以直接用<code>for...of</code>循环遍历 <code>Set</code>。也可以用<code>forEach</code>方法，用于对每个成员执行某种操作，没有返回值。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="string">&quot;red&quot;</span>, <span class="string">&quot;green&quot;</span>, <span class="string">&quot;blue&quot;</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">of</span> set) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// red</span></span><br><span class="line"><span class="comment">// green</span></span><br><span class="line"><span class="comment">// blue</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>]);</span><br><span class="line">set.<span class="title function_">forEach</span>(<span class="function">(<span class="params">value, key</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(key + <span class="string">&quot; : &quot;</span> + value));</span><br><span class="line"><span class="comment">// 1 : 1</span></span><br><span class="line"><span class="comment">// 4 : 4</span></span><br><span class="line"><span class="comment">// 9 : 9</span></span><br></pre></td></tr></table></figure><p>上面代码中<code>forEach</code>方法的参数是一个处理函数。但是因为 <code>Set</code> 结构的键名就是键值，因此第一个参数与第二个参数的值永远都是一样的。</p><hr><h3 id="13-2-Set-遍历的应用"><a href="#13-2-Set-遍历的应用" class="headerlink" title="13.2 Set 遍历的应用"></a>13.2 Set 遍历的应用</h3><p>扩展运算符和 <code>Set</code> 结构相结合，可以去除数组的重复成员。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 去除数组的重复成员</span></span><br><span class="line">[...<span class="keyword">new</span> <span class="title class_">Set</span>(array)]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 去除字符串里面的重复字符</span></span><br><span class="line">[...<span class="keyword">new</span> <span class="title class_">Set</span>(<span class="string">&#x27;ababbc&#x27;</span>)].<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"><span class="comment">// &quot;abc&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用Array.from方法可以将 Set 结构转为数组。</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">dedupe</span>(<span class="params">array</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Array</span>.<span class="title function_">from</span>(<span class="keyword">new</span> <span class="title class_">Set</span>(array));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">dedupe</span>([<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]) <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure><p>数组的<code>map</code>和<code>filter</code>方法也可以间接用于 <code>Set</code>。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line">set = <span class="keyword">new</span> <span class="title class_">Set</span>([...set].<span class="title function_">map</span>(<span class="function">(<span class="params">x</span>) =&gt;</span> x * <span class="number">2</span>));</span><br><span class="line"><span class="comment">// 返回Set结构：&#123;2, 4, 6&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]);</span><br><span class="line">set = <span class="keyword">new</span> <span class="title class_">Set</span>([...set].<span class="title function_">filter</span>(<span class="function">(<span class="params">x</span>) =&gt;</span> x % <span class="number">2</span> == <span class="number">0</span>));</span><br><span class="line"><span class="comment">// 返回Set结构：&#123;2, 4&#125;</span></span><br></pre></td></tr></table></figure><hr><h3 id="13-3-Map-基本用法"><a href="#13-3-Map-基本用法" class="headerlink" title="13.3 Map 基本用法"></a>13.3 Map 基本用法</h3><p><code>Map</code> 数据结构类似于对象，是键值对的集合，但是各种类型的值（包括对象）都可以当作键。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>([</span><br><span class="line">  [<span class="string">&quot;name&quot;</span>, <span class="string">&quot;张三&quot;</span>],</span><br><span class="line">  [<span class="string">&quot;title&quot;</span>, <span class="string">&quot;Author&quot;</span>],</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line">map.<span class="property">size</span>; <span class="comment">// 2</span></span><br><span class="line">map.<span class="title function_">has</span>(<span class="string">&quot;name&quot;</span>); <span class="comment">// true</span></span><br><span class="line">map.<span class="title function_">get</span>(<span class="string">&quot;name&quot;</span>); <span class="comment">// &quot;张三&quot;</span></span><br><span class="line">map.<span class="title function_">has</span>(<span class="string">&quot;title&quot;</span>); <span class="comment">// true</span></span><br><span class="line">map.<span class="title function_">get</span>(<span class="string">&quot;title&quot;</span>); <span class="comment">// &quot;Author&quot;</span></span><br></pre></td></tr></table></figure><p>下面介绍 <code>Map</code> 实例的属性和方法</p><ul><li><code>Map.prototype.size</code>：返回 <code>Map</code> 结构的成员总数。</li><li><code>Map.prototype.set(key, value)</code>：设置键名<code>key</code>对应的键值为<code>value</code>，然后返回整个 <code>Map</code> 结构。如果<code>key</code>已经有值，则键值会被更新，否则就新生成该键。</li><li><code>Map.prototype.get(key)</code>：读取<code>key</code>对应的键值，如果找不到<code>key</code>，返回<code>undefined</code>。</li><li><code>Map.prototype.has(key)</code>：返回一个布尔值，表示某个键是否在当前 <code>Map</code> 对象之中。</li><li><code>Map.prototype.delete(key)</code>：删除某个键，返回<code>true</code>。如果删除失败，返回<code>false</code>。</li><li><code>Map.prototype.clear()</code>：清除所有成员，没有返回值。</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">map.<span class="title function_">set</span>(<span class="string">&quot;foo&quot;</span>, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line">map.<span class="title function_">set</span>(<span class="string">&quot;bar&quot;</span>, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">map.<span class="property">size</span>; <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">map.<span class="title function_">get</span>(<span class="string">&quot;foo&quot;</span>); <span class="comment">// hello</span></span><br><span class="line">map.<span class="title function_">has</span>(<span class="string">&quot;foo&quot;</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">map.<span class="title function_">delete</span>(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line">map.<span class="title function_">has</span>(<span class="string">&quot;foo&quot;</span>); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">map.<span class="title function_">clear</span>();</span><br><span class="line">map.<span class="property">size</span>; <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><p>下面介绍 <code>Map</code> 结构原生提供三个遍历器生成函数和一个遍历方法</p><ul><li><code>Map.prototype.keys()</code>：返回键名的遍历器。</li><li><code>Map.prototype.values()</code>：返回键值的遍历器。</li><li><code>Map.prototype.entries()</code>：返回所有成员的遍历器。</li><li><code>Map.prototype.forEach()</code>：遍历 <code>Map</code> 的所有成员。</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>([</span><br><span class="line">  [<span class="string">&quot;F&quot;</span>, <span class="string">&quot;no&quot;</span>],</span><br><span class="line">  [<span class="string">&quot;T&quot;</span>, <span class="string">&quot;yes&quot;</span>],</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> map.<span class="title function_">keys</span>()) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &quot;F&quot;</span></span><br><span class="line"><span class="comment">// &quot;T&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> map.<span class="title function_">values</span>()) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &quot;no&quot;</span></span><br><span class="line"><span class="comment">// &quot;yes&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> map.<span class="title function_">entries</span>()) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(item[<span class="number">0</span>], item[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &quot;F&quot; &quot;no&quot;</span></span><br><span class="line"><span class="comment">// &quot;T&quot; &quot;yes&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> map.<span class="title function_">entries</span>()) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(key, value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &quot;F&quot; &quot;no&quot;</span></span><br><span class="line"><span class="comment">// &quot;T&quot; &quot;yes&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于使用map.entries()</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> map) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(key, value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &quot;F&quot; &quot;no&quot;</span></span><br><span class="line"><span class="comment">// &quot;T&quot; &quot;yes&quot;</span></span><br><span class="line"></span><br><span class="line">map.<span class="title function_">forEach</span>(<span class="keyword">function</span> (<span class="params">value, key, map</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Key: %s, Value: %s&quot;</span>, key, value);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>需要特别注意的是，<code>Map</code> 的遍历顺序就是插入顺序。</p><hr><h3 id="13-4-Map-与其他数据结构转换"><a href="#13-4-Map-与其他数据结构转换" class="headerlink" title="13.4 Map 与其他数据结构转换"></a>13.4 Map 与其他数据结构转换</h3><p><strong>（1）Map 转为数组</strong></p><p><code>Map</code> 转为数组最方便的方法，就是使用扩展运算符<code>...</code>。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> myMap = <span class="keyword">new</span> <span class="title class_">Map</span>().<span class="title function_">set</span>(<span class="literal">true</span>, <span class="number">7</span>).<span class="title function_">set</span>(&#123; <span class="attr">foo</span>: <span class="number">3</span> &#125;, [<span class="string">&quot;abc&quot;</span>]);</span><br><span class="line">[...myMap];</span><br><span class="line"><span class="comment">// [ [ true, 7 ], [ &#123; foo: 3 &#125;, [ &#x27;abc&#x27; ] ] ]</span></span><br></pre></td></tr></table></figure><p>结合数组的<code>map</code>方法、<code>filter</code>方法，就可以实现 <code>Map</code> 的遍历和过滤。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> map0 = <span class="keyword">new</span> <span class="title class_">Map</span>().<span class="title function_">set</span>(<span class="number">1</span>, <span class="string">&quot;a&quot;</span>).<span class="title function_">set</span>(<span class="number">2</span>, <span class="string">&quot;b&quot;</span>).<span class="title function_">set</span>(<span class="number">3</span>, <span class="string">&quot;c&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> map1 = <span class="keyword">new</span> <span class="title class_">Map</span>([...map0].<span class="title function_">filter</span>(<span class="function">(<span class="params">[k, v]</span>) =&gt;</span> k &lt; <span class="number">3</span>));</span><br><span class="line"><span class="comment">// 产生 Map 结构 &#123;1 =&gt; &#x27;a&#x27;, 2 =&gt; &#x27;b&#x27;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> map2 = <span class="keyword">new</span> <span class="title class_">Map</span>([...map0].<span class="title function_">map</span>(<span class="function">(<span class="params">[k, v]</span>) =&gt;</span> [k * <span class="number">2</span>, <span class="string">&quot;_&quot;</span> + v]));</span><br><span class="line"><span class="comment">// 产生 Map 结构 &#123;2 =&gt; &#x27;_a&#x27;, 4 =&gt; &#x27;_b&#x27;, 6 =&gt; &#x27;_c&#x27;&#125;</span></span><br></pre></td></tr></table></figure><p><strong>（2）数组 转为 Map</strong></p><p>将数组传入 <code>Map</code> 构造函数，就可以转为 <code>Map</code>。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Map</span>([</span><br><span class="line">  [<span class="literal">true</span>, <span class="number">7</span>],</span><br><span class="line">  [&#123; <span class="attr">foo</span>: <span class="number">3</span> &#125;, [<span class="string">&quot;abc&quot;</span>]],</span><br><span class="line">]);</span><br><span class="line"><span class="comment">// Map &#123;</span></span><br><span class="line"><span class="comment">//   true =&gt; 7,</span></span><br><span class="line"><span class="comment">//   Object &#123;foo: 3&#125; =&gt; [&#x27;abc&#x27;]</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure><p><strong>（3）Map 转为对象</strong></p><p>如果所有 <code>Map</code> 的键都是字符串，它可以无损地转为对象。如果有非字符串的键名，那么这个键名会被转成字符串，再作为对象的键名。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">strMapToObj</span>(<span class="params">strMap</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> obj = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> [k, v] <span class="keyword">of</span> strMap) &#123;</span><br><span class="line">    obj[k] = v;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> myMap = <span class="keyword">new</span> <span class="title class_">Map</span>().<span class="title function_">set</span>(<span class="string">&quot;yes&quot;</span>, <span class="literal">true</span>).<span class="title function_">set</span>(<span class="string">&quot;no&quot;</span>, <span class="literal">false</span>);</span><br><span class="line"><span class="title function_">strMapToObj</span>(myMap);</span><br><span class="line"><span class="comment">// &#123; yes: true, no: false &#125;</span></span><br></pre></td></tr></table></figure><p><strong>（4）对象转为 Map</strong></p><p>对象转为 <code>Map</code> 可以通过 <code>Object.entries()</code>。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>(<span class="title class_">Object</span>.<span class="title function_">entries</span>(obj));</span><br></pre></td></tr></table></figure><p><strong>（5）Map 转为 JSON</strong></p><p><code>Map</code> 转为 <code>JSON</code> 要区分两种情况。</p><p>一种情况是，<code>Map</code> 的键名都是字符串，这时可以选择转为对象 <code>JSON</code>。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">strMapToJson</span>(<span class="params">strMap</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(<span class="title function_">strMapToObj</span>(strMap));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myMap = <span class="keyword">new</span> <span class="title class_">Map</span>().<span class="title function_">set</span>(<span class="string">&quot;yes&quot;</span>, <span class="literal">true</span>).<span class="title function_">set</span>(<span class="string">&quot;no&quot;</span>, <span class="literal">false</span>);</span><br><span class="line"><span class="title function_">strMapToJson</span>(myMap);</span><br><span class="line"><span class="comment">// &#x27;&#123;&quot;yes&quot;:true,&quot;no&quot;:false&#125;&#x27;</span></span><br></pre></td></tr></table></figure><p>另一种情况是，<code>Map</code> 的键名有非字符串，这时可以选择转为数组 <code>JSON</code>。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">mapToArrayJson</span>(<span class="params">map</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">JSON</span>.<span class="title function_">stringify</span>([...map]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myMap = <span class="keyword">new</span> <span class="title class_">Map</span>().<span class="title function_">set</span>(<span class="literal">true</span>, <span class="number">7</span>).<span class="title function_">set</span>(&#123; <span class="attr">foo</span>: <span class="number">3</span> &#125;, [<span class="string">&quot;abc&quot;</span>]);</span><br><span class="line"><span class="title function_">mapToArrayJson</span>(myMap);</span><br><span class="line"><span class="comment">// &#x27;[[true,7],[&#123;&quot;foo&quot;:3&#125;,[&quot;abc&quot;]]]&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>（6）JSON 转为 Map</strong></p><p><code>JSON</code> 转为 <code>Map</code>，正常情况下，所有键名都是字符串。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">objToStrMap</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> strMap = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> k <span class="keyword">of</span> <span class="title class_">Object</span>.<span class="title function_">keys</span>(obj)) &#123;</span><br><span class="line">    strMap.<span class="title function_">set</span>(k, obj[k]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> strMap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">jsonToStrMap</span>(<span class="params">jsonStr</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">objToStrMap</span>(<span class="title class_">JSON</span>.<span class="title function_">parse</span>(jsonStr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">jsonToStrMap</span>(<span class="string">&#x27;&#123;&quot;yes&quot;: true, &quot;no&quot;: false&#125;&#x27;</span>);</span><br><span class="line"><span class="comment">// Map &#123;&#x27;yes&#x27; =&gt; true, &#x27;no&#x27; =&gt; false&#125;</span></span><br></pre></td></tr></table></figure><p>如果整个 <code>JSON</code> 就是一个数组，且每个数组成员本身，又是一个有两个成员的数组。这时，它可以直接转为 <code>Map</code>。（类似 <code>Map</code> 转为数组 <code>JSON</code> 的逆操作）<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">jsonToMap</span>(<span class="params">jsonStr</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Map</span>(<span class="title class_">JSON</span>.<span class="title function_">parse</span>(jsonStr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">jsonToMap</span>(<span class="string">&#x27;[[true,7],[&#123;&quot;foo&quot;:3&#125;,[&quot;abc&quot;]]]&#x27;</span>);</span><br><span class="line"><span class="comment">// Map &#123;true =&gt; 7, Object &#123;foo: 3&#125; =&gt; [&#x27;abc&#x27;]&#125;</span></span><br></pre></td></tr></table></figure><hr><h2 id="14-Proxy"><a href="#14-Proxy" class="headerlink" title="14. Proxy"></a>14. Proxy</h2><p><a href="https://es6.ruanyifeng.com/#docs/proxy">本章</a>内容复杂，故先跳过一部分。</p><h3 id="14-1-Proxy-概述"><a href="#14-1-Proxy-概述" class="headerlink" title="14.1 Proxy 概述"></a>14.1 Proxy 概述</h3><p><code>Proxy</code> 可以理解成，<ins>在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写</ins>。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> <span class="title class_">Proxy</span>(</span><br><span class="line">  &#123;&#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">get</span>: <span class="keyword">function</span> (<span class="params">target, propKey, receiver</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`getting <span class="subst">$&#123;propKey&#125;</span>!`</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, propKey, receiver);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">set</span>: <span class="keyword">function</span> (<span class="params">target, propKey, value, receiver</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`setting <span class="subst">$&#123;propKey&#125;</span>!`</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">set</span>(target, propKey, value, receiver);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>上面代码对一个空对象架设了一层拦截，重定义了属性的读取<code>get</code>和设置<code>set</code>行为。对设置了拦截行为的对象<code>obj</code>读写它的属性，就会得到下面的结果。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">obj.<span class="property">count</span> = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//  setting count!</span></span><br><span class="line">++obj.<span class="property">count</span>;</span><br><span class="line"><span class="comment">//  getting count!</span></span><br><span class="line"><span class="comment">//  setting count!</span></span><br><span class="line"><span class="comment">//  2</span></span><br></pre></td></tr></table></figure><p>这里可以看出，<code>Proxy</code> 实际上重载<code>overload</code>了点运算符，即用自己的定义覆盖了语言的原始定义。(类似<code>C++</code>的重载)<br><br></p><p><code>ES6</code> 原生提供 <code>Proxy</code> 构造函数，用来生成 <code>Proxy</code> 实例。<code>target</code>参数表示所要拦截的目标对象，<code>handler</code>参数也是一个对象，用来定制拦截行为。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler);</span><br></pre></td></tr></table></figure><p>下面是另一个拦截读取属性行为的例子。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(</span><br><span class="line">  &#123;&#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">get</span>: <span class="keyword">function</span> (<span class="params">target, propKey</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">35</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">proxy.<span class="property">time</span>; <span class="comment">// 35</span></span><br><span class="line">proxy.<span class="property">name</span>; <span class="comment">// 35</span></span><br><span class="line">proxy.<span class="property">title</span>; <span class="comment">// 35</span></span><br></pre></td></tr></table></figure><p>上面代码中，作为构造函数，<code>Proxy</code>接受两个参数。第一个参数是所要代理的目标对象。第二个参数是一个配置对象，对于每一个被代理的操作，需要提供一个对应的处理函数，该函数将拦截对应的操作。<br><br></p><p>注意，要使得<code>Proxy</code>起作用，必须针对<code>Proxy</code>实例进行操作，而不是针对目标对象进行操作。</p><hr><h3 id="14-2-Proxy-的实例方法"><a href="#14-2-Proxy-的实例方法" class="headerlink" title="14.2 Proxy 的实例方法"></a>14.2 Proxy 的实例方法</h3><p><code>Proxy</code> 支持的拦截操作一共 <code>13</code> 种。(剩下的可以在<a href="https://es6.ruanyifeng.com/#docs/proxy#Proxy-%E5%AE%9E%E4%BE%8B%E7%9A%84%E6%96%B9%E6%B3%95">这里</a>找到) <br><br></p><p><code>get()</code>方法用于拦截某个属性的读取操作，可以接受三个参数，依次为目标对象、属性名和 <code>proxy</code> 实例本身。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;张三&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(person, &#123;</span><br><span class="line">  <span class="attr">get</span>: <span class="keyword">function</span> (<span class="params">target, propKey</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (propKey <span class="keyword">in</span> target) &#123;</span><br><span class="line">      <span class="keyword">return</span> target[propKey];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ReferenceError</span>(<span class="string">&#x27;Prop name &quot;&#x27;</span> + propKey + <span class="string">&#x27;&quot; does not exist.&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">proxy.<span class="property">name</span>; <span class="comment">// &quot;张三&quot;</span></span><br><span class="line">proxy.<span class="property">age</span>; <span class="comment">// 抛出一个错误</span></span><br></pre></td></tr></table></figure><p><code>set()</code>方法用来拦截某个属性的赋值操作，可以接受四个参数，依次为目标对象、属性名、属性值和 <code>Proxy</code> 实例本身。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> validator = &#123;</span><br><span class="line">  <span class="attr">set</span>: <span class="keyword">function</span> (<span class="params">obj, prop, value</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (prop === <span class="string">&quot;age&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="title class_">Number</span>.<span class="title function_">isInteger</span>(value)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&quot;The age is not an integer&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (value &gt; <span class="number">200</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RangeError</span>(<span class="string">&quot;The age seems invalid&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对于满足条件的 age 属性以及其他属性，直接保存</span></span><br><span class="line">    obj[prop] = value;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> <span class="title class_">Proxy</span>(&#123;&#125;, validator);</span><br><span class="line">person.<span class="property">age</span> = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">person.<span class="property">age</span>; <span class="comment">// 100</span></span><br><span class="line">person.<span class="property">age</span> = <span class="string">&quot;young&quot;</span>; <span class="comment">// 报错</span></span><br><span class="line">person.<span class="property">age</span> = <span class="number">300</span>; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><hr><h2 id="15-Reflect"><a href="#15-Reflect" class="headerlink" title="15. Reflect"></a>15. Reflect</h2><h3 id="15-1-Reflect-概述"><a href="#15-1-Reflect-概述" class="headerlink" title="15.1 Reflect 概述"></a>15.1 Reflect 概述</h3><p><code>Reflect</code>对象与<code>Proxy</code>对象一样，也是 <code>ES6</code> 为了操作对象而提供的新 <code>API</code>。<code>Reflect</code>对象的设计目的有这样几个。</p><ul><li><p>将<code>Object</code>对象的一些属于语言内部的方法（比如<code>Object.defineProperty</code>），放到<code>Reflect</code>对象上。也就是说，未来可以从<code>Reflect</code>对象上拿到语言内部的方法。</p></li><li><p>修改某些<code>Object</code>方法的返回结果，让其变得更合理。</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 老写法</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(target, property, attributes);</span><br><span class="line">  <span class="comment">// success</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="comment">// 报错</span></span><br><span class="line">  <span class="comment">// failure</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新写法</span></span><br><span class="line"><span class="keyword">if</span> (<span class="title class_">Reflect</span>.<span class="title function_">defineProperty</span>(target, property, attributes)) &#123;</span><br><span class="line">  <span class="comment">// success</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// 直接返回 false</span></span><br><span class="line">  <span class="comment">// failure</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>让<code>Object</code>操作都变成函数行为。比如<code>name in obj</code>和<code>delete obj[name]</code>，而<code>Reflect.has(obj, name)</code>和<code>Reflect.deleteProperty(obj, name)</code>让它们变成了函数行为。</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 老写法</span></span><br><span class="line"><span class="string">&quot;assign&quot;</span> <span class="keyword">in</span> <span class="title class_">Object</span>; <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 新写法</span></span><br><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">has</span>(<span class="title class_">Object</span>, <span class="string">&quot;assign&quot;</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><ul><li>让<code>Reflect</code>对象的方法与<code>Proxy</code>对象的方法对应，只要是<code>Proxy</code>对象的方法，就能在<code>Reflect</code>对象上找到对应的方法。这就让<code>Proxy</code>对象可以方便地调用对应的<code>Reflect</code>方法，完成默认行为，作为修改行为的基础。</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> loggedObj = <span class="keyword">new</span> <span class="title class_">Proxy</span>(obj, &#123;</span><br><span class="line">  <span class="title function_">get</span>(<span class="params">target, name</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;get&quot;</span>, target, name);</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, name);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">deleteProperty</span>(<span class="params">target, name</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;delete&quot;</span> + name);</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">deleteProperty</span>(target, name);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">has</span>(<span class="params">target, name</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;has&quot;</span> + name);</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">has</span>(target, name);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，每一个<code>Proxy</code>对象的拦截操作<code>get</code>、<code>delete</code>、<code>has</code>，内部都调用对应的<code>Reflect</code>方法，保证原生行为能够正常执行。<br><br></p><p>简单来说，有了<code>Reflect</code>对象以后，很多操作会更易读。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 老写法</span></span><br><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">apply</span>.<span class="title function_">call</span>(<span class="title class_">Math</span>.<span class="property">floor</span>, <span class="literal">undefined</span>, [<span class="number">1.75</span>]); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 新写法</span></span><br><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">apply</span>(<span class="title class_">Math</span>.<span class="property">floor</span>, <span class="literal">undefined</span>, [<span class="number">1.75</span>]); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><hr><h3 id="15-2-Reflect-静态方法"><a href="#15-2-Reflect-静态方法" class="headerlink" title="15.2 Reflect 静态方法"></a>15.2 Reflect 静态方法</h3><p><code>Reflect</code>对象也有 <code>13</code> 个静态方法。(剩下的可以在<a href="https://es6.ruanyifeng.com/#docs/reflect#%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95">这里</a>找到) <br><br></p><p><code>Reflect.get</code>方法查找并返回<code>target</code>对象的<code>name</code>属性。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> myObject = &#123;</span><br><span class="line">  <span class="attr">foo</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">bar</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">baz</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">foo</span> + <span class="variable language_">this</span>.<span class="property">bar</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">get</span>(myObject, <span class="string">&quot;foo&quot;</span>); <span class="comment">// 1</span></span><br><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">get</span>(myObject, <span class="string">&quot;bar&quot;</span>); <span class="comment">// 2</span></span><br><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">get</span>(myObject, <span class="string">&quot;baz&quot;</span>); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p><code>Reflect.set</code>方法设置<code>target</code>对象的<code>name</code>属性等于<code>value</code>。<br><br></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> myObject = &#123;</span><br><span class="line">  <span class="attr">foo</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="keyword">set</span> <span class="title function_">bar</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="variable language_">this</span>.<span class="property">foo</span> = value);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">myObject.<span class="property">foo</span>; <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">set</span>(myObject, <span class="string">&quot;foo&quot;</span>, <span class="number">2</span>);</span><br><span class="line">myObject.<span class="property">foo</span>; <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">set</span>(myObject, <span class="string">&quot;bar&quot;</span>, <span class="number">3</span>);</span><br><span class="line">myObject.<span class="property">foo</span>; <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> ES6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Coding</title>
      <link href="/posts/3458e8f8.html"/>
      <url>/posts/3458e8f8.html</url>
      
        <content type="html"><![CDATA[<h3 id="PriorityQueue-优先队列"><a href="#PriorityQueue-优先队列" class="headerlink" title="PriorityQueue 优先队列"></a><code>PriorityQueue</code> 优先队列</h3><h4 id="第k大的元素"><a href="#第k大的元素" class="headerlink" title="第k大的元素"></a>第<code>k</code>大的元素</h4><blockquote><p><a href="https://leetcode.com/problems/kth-largest-element-in-an-array/">Leetcode 215. Kth Largest Element in an Array</a></p></blockquote><ul><li><code>题目:</code> 给定一个数组<code>nums</code>和一个整数<code>k</code>，输出数组中第<code>k</code>大的元素</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: nums = [3, 2, 1, 5, 6, 4], k = 2</span><br><span class="line">Output: 5</span><br></pre></td></tr></table></figure><ul><li><code>解法:</code> 最小堆 <a href="https://www.geeksforgeeks.org/heap-queue-or-heapq-in-python/">什么是 heap</a></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 初始化一个大小为 k 的最小堆，将前 k 个元素加入堆中</span><br><span class="line">2. 遍历剩余的元素，如果当前元素大于堆顶元素，则替换堆顶</span><br><span class="line">3. 遍历结束后，堆顶即为第 k 大的元素</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findKthLargest</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> k == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">        heap = nums[:k]</span><br><span class="line">        heapq.heapify(heap)  <span class="comment"># 建立最小堆</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums[k:]:</span><br><span class="line">            <span class="keyword">if</span> num &gt; heap[<span class="number">0</span>]:  <span class="comment"># 只在当前元素大于堆顶时替换</span></span><br><span class="line">                heapq.heapreplace(heap, num)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> heap[<span class="number">0</span>] <span class="comment"># 如果是 heap, 那就是返回数组前 k 大的元素</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">findKthLargest</span>(<span class="params">nums, k</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> minPQ = <span class="keyword">new</span> <span class="title class_">MinPriorityQueue</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.<span class="property">length</span>; i++) &#123;</span><br><span class="line">            minPQ.<span class="title function_">enqueue</span>(nums[i]);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (minPQ.<span class="title function_">size</span>() &gt; k)</span><br><span class="line">                minPQ.<span class="title function_">dequeue</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> minPQ.<span class="title function_">front</span>().<span class="property">element</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h4 id="前k个元素的频率"><a href="#前k个元素的频率" class="headerlink" title="前k个元素的频率"></a>前<code>k</code>个元素的频率</h4><blockquote><p><a href="https://leetcode.com/problems/top-k-frequent-elements/">Leetcode 347. Top K Frequent Elements</a></p></blockquote><ul><li><code>题目:</code> 给定一个数组<code>nums</code>和一个整数<code>k</code>，返回数组中出现频率最高的前<code>k</code>个元素</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: nums = [1, 1, 1, 2, 2, 3], k = 2</span><br><span class="line">Output: [1, 2]</span><br></pre></td></tr></table></figure><ul><li><code>解法 1: heapq.nlargest</code> (<code>Python</code>)</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 使用 `Counter` 统计元素出现频率</span><br><span class="line">2. 调用 `heapq.nlargest`，在 O(n + k log n) 时间内找到前 k 大的频率</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">topKFrequent</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums) == k:</span><br><span class="line">            <span class="keyword">return</span> nums</span><br><span class="line"></span><br><span class="line">        count = Counter(nums)</span><br><span class="line">        <span class="keyword">return</span> heapq.nlargest(k, count.keys(), key=count.get)</span><br></pre></td></tr></table></figure><ul><li><code>解法 2:</code> 最小堆</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 统计元素频率，使用堆存储前 k 个高频元素</span><br><span class="line">2. 每次比较当前元素与堆顶的频率，维护堆的大小为 k</span><br><span class="line">3. 最后堆中的元素即为结果</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">topKFrequent</span>(<span class="params">nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="comment"># 1. 统计每个元素的频率</span></span><br><span class="line">        freq_map = Counter(nums)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 2. 使用最小堆找到前 k 个频率最高的元素</span></span><br><span class="line">        heap = []</span><br><span class="line">        <span class="keyword">for</span> num, freq <span class="keyword">in</span> freq_map.items():</span><br><span class="line">            heapq.heappush(heap, (freq, num))  <span class="comment"># 堆中存储 (频率, 元素)</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(heap) &gt; k:</span><br><span class="line">                heapq.heappop(heap)  <span class="comment"># 维持堆的大小为 k</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 3. 提取堆中的元素</span></span><br><span class="line">        <span class="keyword">return</span> [num <span class="keyword">for</span> freq, num <span class="keyword">in</span> heap]</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">topKFrequent</span>(<span class="params">nums, k</span>) &#123;</span><br><span class="line">        <span class="comment">// 1. 统计频率</span></span><br><span class="line">        <span class="keyword">const</span> freqMap = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> num <span class="keyword">of</span> nums)</span><br><span class="line">            freqMap.<span class="title function_">set</span>(num, (freqMap.<span class="title function_">get</span>(num) || <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 使用最小堆</span></span><br><span class="line">        <span class="keyword">const</span> minPQ = <span class="keyword">new</span> <span class="title class_">MinPriorityQueue</span>(&#123; <span class="attr">priority</span>: <span class="function"><span class="params">x</span> =&gt;</span> x[<span class="number">1</span>] &#125;);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> [num, freq] <span class="keyword">of</span> freqMap) &#123;</span><br><span class="line">            minPQ.<span class="title function_">enqueue</span>([num, freq]);</span><br><span class="line">            <span class="keyword">if</span> (minPQ.<span class="title function_">size</span>() &gt; k)</span><br><span class="line">                minPQ.<span class="title function_">dequeue</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 提取堆中的元素</span></span><br><span class="line">        <span class="keyword">return</span> minPQ.<span class="title function_">toArray</span>().<span class="title function_">map</span>(<span class="function"><span class="params">x</span> =&gt;</span> x.<span class="property">element</span>[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><ul><li><code>解法 3:</code> 桶排序</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 统计频率，并将元素按频率存储在“桶”中</span><br><span class="line">2. 桶的索引表示频率，从高到低提取前 k 个元素</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">topKFrequent</span>(<span class="params">nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="comment"># 1. 统计频率</span></span><br><span class="line">        freq_map = Counter(nums)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 2. 桶排序</span></span><br><span class="line">        bucket = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums) + <span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> num, freq <span class="keyword">in</span> freq_map.items():</span><br><span class="line">            bucket[freq].append(num) <span class="comment"># 将元素按频率存储在对应桶中</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 3. 从高频到低频提取前 k 个元素</span></span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(bucket) - <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> num <span class="keyword">in</span> bucket[i]:</span><br><span class="line">                result.append(num)</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">len</span>(result) == k:</span><br><span class="line">                    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">topKFrequent</span>(<span class="params">nums, k</span>) &#123;</span><br><span class="line">        <span class="comment">// 1. 统计频率</span></span><br><span class="line">        <span class="keyword">const</span> freqMap = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> num <span class="keyword">of</span> nums)</span><br><span class="line">            freqMap.<span class="title function_">set</span>(num, (freqMap.<span class="title function_">get</span>(num) || <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 桶排序</span></span><br><span class="line">        <span class="keyword">const</span> bucket = <span class="title class_">Array</span>(nums.<span class="property">length</span> + <span class="number">1</span>).<span class="title function_">fill</span>(<span class="literal">null</span>).<span class="title function_">map</span>(<span class="function">() =&gt;</span> []);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> [num, freq] <span class="keyword">of</span> freqMap)</span><br><span class="line">            bucket[freq].<span class="title function_">push</span>(num);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 从高频到低频提取前 k 个元素</span></span><br><span class="line">        <span class="keyword">const</span> result = [];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = bucket.<span class="property">length</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; result.<span class="property">length</span> &lt; k; i--)</span><br><span class="line">            result.<span class="title function_">push</span>(...bucket[i]);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><blockquote><p><code>最小堆</code>: 更灵活，可以适应动态输入数据，适合<code>k</code>较小的情况<br><code>桶排序</code>: 更高效，尤其是当<code>k</code>较大或频率分布较均匀时</p></blockquote><hr><h3 id="Design"><a href="#Design" class="headerlink" title="Design"></a><code>Design</code></h3><h4 id="LRU-缓存"><a href="#LRU-缓存" class="headerlink" title="LRU 缓存"></a><code>LRU</code> 缓存</h4><blockquote><p><a href="https://leetcode.com/problems/lru-cache/">Leetcode 146. LRU Cache</a></p></blockquote><ul><li><p><code>题目:</code> 实现一个数据结构<code>LRU Cache (Least Recently Used Cache)</code>，它能够在固定容量下缓存键值对，同时满足以下两种操作</p><ul><li><code>get(key)</code>: 如果键存在，返回其值，并将该键标记为最近使用。如果不存在，返回<code>-1</code></li><li><code>put(key, value)</code>: 插入新键值对。如果缓存已满，移除最久未使用的键值对</li></ul></li><li><p><code>解法 1: OrderedDict</code> (<code>Python</code>)</p><ul><li><code>Python</code>中的<code>OrderedDict</code>可以非常直观地实现<code>LRU Cache</code></li><li><code>OrderedDict</code>自动维护插入顺序，最久未使用的元素总在最前面</li><li>提供了<code>move_to_end(key)</code>方法，可以将某个键移动到末尾，表示最近使用</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">get 方法</span><br><span class="line">    如果键存在，将其移到末尾，表示最近使用，并返回对应值</span><br><span class="line">    如果键不存在，返回 -1</span><br><span class="line"></span><br><span class="line">put 方法</span><br><span class="line">    如果键存在，更新值并移到末尾</span><br><span class="line">    如果键不存在，直接添加</span><br><span class="line">    如果缓存超出容量，删除最前面的键（popitem(last=False)）</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> OrderedDict</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, capacity: <span class="built_in">int</span></span>):</span><br><span class="line">        self.cache = OrderedDict() <span class="comment"># 创建一个有序字典</span></span><br><span class="line">        self.capacity = capacity</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">self, key: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">in</span> self.cache:</span><br><span class="line">            <span class="comment"># 将访问的键移到末尾</span></span><br><span class="line">            self.cache.move_to_end(key)</span><br><span class="line">            <span class="keyword">return</span> self.cache[key]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">put</span>(<span class="params">self, key: <span class="built_in">int</span>, value: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">in</span> self.cache:</span><br><span class="line">            <span class="comment"># 如果键已经存在，更新值，并移到末尾</span></span><br><span class="line">            self.cache.move_to_end(key)</span><br><span class="line"></span><br><span class="line">        self.cache[key] = value</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self.cache) &gt; self.capacity:</span><br><span class="line">            <span class="comment"># 超过容量时，删除第一个键（最久未使用）</span></span><br><span class="line">            self.cache.popitem(last=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><ul><li><code>解法 2: Map</code> (<code>Javascript</code>)<ul><li><code>JS</code>的<code>Map</code>数据结构，它按插入顺序存储键值对</li><li>使用<code>set(key, value)</code>方法更新键时，会将该键移到末尾，表示最近使用</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">get 方法</span><br><span class="line">    如果键存在，先删除它，再重新插入到末尾</span><br><span class="line">    如果键不存在，返回 -1</span><br><span class="line"></span><br><span class="line">put 方法</span><br><span class="line">    如果键已存在，先删除它，再插入新值</span><br><span class="line">    如果超过容量，删除最老的键（Map.keys().next().value 返回第一个键）</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">capacity</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">capacity</span> = capacity;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">cache</span> = <span class="keyword">new</span> <span class="title class_">Map</span>(); <span class="comment">// Map 是有序的，按插入顺序维护键值对</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">get</span>(<span class="params">key</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">cache</span>.<span class="title function_">has</span>(key)) <span class="keyword">return</span> -<span class="number">1</span>; </span><br><span class="line">        <span class="keyword">const</span> value = <span class="variable language_">this</span>.<span class="property">cache</span>.<span class="title function_">get</span>(key);</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">cache</span>.<span class="title function_">delete</span>(key); <span class="comment">// 删除旧位置的键</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">cache</span>.<span class="title function_">set</span>(key, value); <span class="comment">// 将键移到末尾（最新使用）</span></span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">put</span>(<span class="params">key, value</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">cache</span>.<span class="title function_">has</span>(key))</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">cache</span>.<span class="title function_">delete</span>(key); <span class="comment">// 如果键已存在，先删除它</span></span><br><span class="line"></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">cache</span>.<span class="title function_">set</span>(key, value); <span class="comment">// 插入新键值对</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">cache</span>.<span class="property">size</span> &gt; <span class="variable language_">this</span>.<span class="property">capacity</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> oldestKey = <span class="variable language_">this</span>.<span class="property">cache</span>.<span class="title function_">keys</span>().<span class="title function_">next</span>().<span class="property">value</span>; <span class="comment">// 获取最老的键</span></span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">cache</span>.<span class="title function_">delete</span>(oldestKey);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="实现随机集合"><a href="#实现随机集合" class="headerlink" title="实现随机集合"></a>实现随机集合</h4><blockquote><p><a href="https://leetcode.com/problems/insert-delete-getrandom-o1/">Leetcode 380. Insert Delete GetRandom O(1)</a></p></blockquote><ul><li><code>题目:</code> 设计一个支持以下操作的集合，在平均时间复杂度为<code>O(1)</code>下实现插入、删除和随机获取操作<ul><li><code>insert(val)</code>: 如果集合中没有该值，则插入</li><li><code>remove(val)</code>: 如果集合中存在该值</li><li><code>getRandom()</code>: 随机返回集合中的一个元素，每个元素被返回的概率相等</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input</span><br><span class="line">[&quot;RandomizedSet&quot;, &quot;insert&quot;, &quot;remove&quot;, &quot;insert&quot;, &quot;getRandom&quot;, &quot;remove&quot;, &quot;insert&quot;, &quot;getRandom&quot;]</span><br><span class="line">[[], [1], [2], [2], [], [1], [2], []]</span><br><span class="line">Output</span><br><span class="line">[null, true, false, true, 2, true, false, 2]</span><br></pre></td></tr></table></figure><ul><li><code>解法:</code> 数组 + 哈希表</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 数组存储集合的元素，用于随机访问</span><br><span class="line">2. 哈希表记录每个值在数组中的索引，方便 O(1) 时间查找和删除</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RandomizedSet</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.<span class="built_in">dict</span> = &#123;&#125;</span><br><span class="line">        self.<span class="built_in">list</span> = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">insert</span>(<span class="params">self, val: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">if</span> val <span class="keyword">in</span> self.<span class="built_in">dict</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        self.<span class="built_in">dict</span>[val] = <span class="built_in">len</span>(self.<span class="built_in">list</span>) <span class="comment"># 记录值的索引</span></span><br><span class="line">        self.<span class="built_in">list</span>.append(val) <span class="comment"># 将值添加到列表</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">remove</span>(<span class="params">self, val: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">if</span> val <span class="keyword">not</span> <span class="keyword">in</span> self.<span class="built_in">dict</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        idx = self.<span class="built_in">dict</span>[val] <span class="comment"># 获取值的索引</span></span><br><span class="line">        last = self.<span class="built_in">list</span>[-<span class="number">1</span>] <span class="comment"># 获取列表中的最后一个元素</span></span><br><span class="line"></span><br><span class="line">        self.<span class="built_in">list</span>[idx] = last <span class="comment"># 将最后一个元素移到被移除的位置</span></span><br><span class="line">        self.<span class="built_in">dict</span>[last] = idx <span class="comment"># 更新最后一个元素的索引</span></span><br><span class="line"></span><br><span class="line">        self.<span class="built_in">list</span>.pop() <span class="comment"># 删除最后一个元素</span></span><br><span class="line">        <span class="keyword">del</span> self.<span class="built_in">dict</span>[val] <span class="comment"># 从字典中删除该值</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getRandom</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">return</span> random.choice(self.<span class="built_in">list</span>) <span class="comment"># 随机选择一个列表中的值</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">map</span> = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">list</span> = [];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">insert</span>(<span class="params">val</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">map</span>.<span class="title function_">has</span>(val)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">map</span>.<span class="title function_">set</span>(val, <span class="variable language_">this</span>.<span class="property">list</span>.<span class="property">length</span>); <span class="comment">// 存储值和索引</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">list</span>.<span class="title function_">push</span>(val); <span class="comment">// 将值添加到数组</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">remove</span>(<span class="params">val</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">map</span>.<span class="title function_">has</span>(val)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> idx = <span class="variable language_">this</span>.<span class="property">map</span>.<span class="title function_">get</span>(val); <span class="comment">// 获取值的索引</span></span><br><span class="line">        <span class="keyword">const</span> last = <span class="variable language_">this</span>.<span class="property">list</span>[<span class="variable language_">this</span>.<span class="property">list</span>.<span class="property">length</span> - <span class="number">1</span>]; <span class="comment">// 获取最后一个值</span></span><br><span class="line"></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">list</span>[idx] = last; <span class="comment">// 将最后一个值移到被删除的位置</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">map</span>.<span class="title function_">set</span>(last, idx); <span class="comment">// 更新最后一个值的索引</span></span><br><span class="line"></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">list</span>.<span class="title function_">pop</span>(); <span class="comment">// 删除最后一个值</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">map</span>.<span class="title function_">delete</span>(val); <span class="comment">// 从映射中删除该值</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">getRandom</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> randomIndex = <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="variable language_">this</span>.<span class="property">list</span>.<span class="property">length</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">list</span>[randomIndex];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h3 id="LinkedList-链表"><a href="#LinkedList-链表" class="headerlink" title="LinkedList 链表"></a><code>LinkedList</code> 链表</h3><h4 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h4><blockquote><p><a href="https://leetcode.com/problems/reverse-linked-list/">Leetcode 206. Reverse Linked List</a></p></blockquote><ul><li><code>题目:</code> 给定一个单链表的头节点<code>head</code>，将其完全反转，并返回新的头节点</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: head = [0,1,2,3]</span><br><span class="line">Output: [3,2,1,0]</span><br></pre></td></tr></table></figure><ul><li><code>解法: Two Pointers</code> 双指针</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 初始化两个指针：prev 表示前一个节点，curr 表示当前节点</span><br><span class="line">2. 遍历链表，逐个调整当前节点的指向，使其指向前一个节点</span><br><span class="line">3. 移动指针，直到链表尾部</span><br><span class="line">4. 返回 prev 作为新的头节点</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseList</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        prev = <span class="literal">None</span></span><br><span class="line">        curr = head</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> curr:</span><br><span class="line">            next_node = curr.<span class="built_in">next</span> <span class="comment"># 暂存下一个节点</span></span><br><span class="line">            curr.<span class="built_in">next</span> = prev <span class="comment"># 当前节点指向前一个节点</span></span><br><span class="line">            prev = curr <span class="comment"># prev 向前移动到当前节点</span></span><br><span class="line">            curr = next_node <span class="comment"># curr 向前移动到下一个节点</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> prev   </span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">reverseList</span>(<span class="params">head</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> prev = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">let</span> curr = head;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (curr) &#123;</span><br><span class="line">            <span class="keyword">let</span> nextNode = curr.<span class="property">next</span>; <span class="comment">// 暂存下一个节点</span></span><br><span class="line">            curr.<span class="property">next</span> = prev; <span class="comment">// 当前节点指向前一个节点</span></span><br><span class="line">            prev = curr; <span class="comment">// prev 向前移动到当前节点</span></span><br><span class="line">            curr = nextNode; <span class="comment">// curr 向前移动到下一个节点</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h4 id="反转链表中间部分"><a href="#反转链表中间部分" class="headerlink" title="反转链表中间部分"></a>反转链表中间部分</h4><blockquote><p><a href="https://leetcode.com/problems/reverse-linked-list-ii/">Leetcode 92. Reverse Linked List II</a></p></blockquote><ul><li><code>题目:</code> 给定一个单链表的头节点<code>head</code>，以及两个整数<code>left</code>和<code>right</code>，反转链表中从位置<code>left</code>到位置<code>right</code>的部分，并返回链表的头节点</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: head = [1,2,3,4,5], left = 2, right = 4</span><br><span class="line">Output: [1,4,3,2,5]</span><br></pre></td></tr></table></figure><ul><li><code>解法:</code> 虚拟头节点法</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 添加虚拟头节点：用于处理从链表头部开始反转的特殊情况</span><br><span class="line">2. 找到 left 的前驱节点 prev 和要反转的第一个节点 curr</span><br><span class="line">3. 遍历从 left 到 right 的链表部分，逐个将当前节点插入到子链表的头部</span><br><span class="line">4. 返回链表的新头节点</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseBetween</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode], left: <span class="built_in">int</span>, right: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        dummy = ListNode(<span class="number">0</span>, head)</span><br><span class="line">        prev = dummy</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 1. 找到 left 的前驱节点（prev）和 left 节点（curr）</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(left - <span class="number">1</span>):</span><br><span class="line">            prev = prev.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        curr = prev.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 2. 反转 [left, right] 之间的节点</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(right - left):</span><br><span class="line">            next_node = curr.<span class="built_in">next</span> <span class="comment"># 暂存当前节点的 next</span></span><br><span class="line">            curr.<span class="built_in">next</span> = next_node.<span class="built_in">next</span> <span class="comment"># 当前节点指向 next 的 next</span></span><br><span class="line">            next_node.<span class="built_in">next</span> = prev.<span class="built_in">next</span> <span class="comment"># 插入到子链表头部</span></span><br><span class="line">            prev.<span class="built_in">next</span> = next_node <span class="comment"># 更新 prev 的 next</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">reverseBetween</span>(<span class="params">head, left, right</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> dummy = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>, head);</span><br><span class="line">        <span class="keyword">let</span> prev = dummy;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 找到 left 的前驱节点（prev）和 left 节点（curr）</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; left; i++)</span><br><span class="line">            prev = prev.<span class="property">next</span>;</span><br><span class="line"></span><br><span class="line">        curr = prev.<span class="property">next</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 反转 [left, right] 之间的节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; right - left; i++) &#123;</span><br><span class="line">            <span class="keyword">const</span> nextNode = curr.<span class="property">next</span>;</span><br><span class="line">            curr.<span class="property">next</span> = nextNode.<span class="property">next</span>;</span><br><span class="line">            nextNode.<span class="property">next</span> = prev.<span class="property">next</span>;</span><br><span class="line">            prev.<span class="property">next</span> = nextNode;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><ul><li>例子，反转链表<code>1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5</code> 第<code>2</code>个节点到第<code>4</code>个节点</li></ul><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Step 1</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Step 2</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img221705.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><p><img src="https://raw.githubusercontent.com/Hongda-Lin/ImageStore/master/img221721.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h4 id="合成链表"><a href="#合成链表" class="headerlink" title="合成链表"></a>合成链表</h4><blockquote><p><a href="https://leetcode.com/problems/merge-two-sorted-lists/">Leetcode 21. Merge Two Sorted Lists</a></p></blockquote><ul><li><code>题目:</code> 给定两个单链表<code>list1</code>和<code>list2</code>，它们的元素按升序排列。将它们合并为一个新的链表，要求新链表也按照升序排列，并返回新链表的头节点</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: list1 = [1,2,4], list2 = [1,3,5]</span><br><span class="line">Output: [1,1,2,3,4,5]</span><br></pre></td></tr></table></figure><ul><li><code>解法:</code> 虚拟头节点法</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 使用一个虚拟头节点 dummy 来简化链表连接逻辑</span><br><span class="line">2. 遍历 list1 和 list2，逐步比较它们的节点值，将较小的节点连接到结果链表中</span><br><span class="line">3. 当一个链表遍历完成后，将另一个链表剩余的节点直接连接到结果链表</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">mergeTwoLists</span>(<span class="params">self, list1: <span class="type">Optional</span>[ListNode], list2: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        dummy = ListNode()</span><br><span class="line">        curr = dummy</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 遍历两个链表，比较节点值</span></span><br><span class="line">        <span class="keyword">while</span> list1 <span class="keyword">and</span> list2:</span><br><span class="line">            <span class="keyword">if</span> list1.val &lt; list2.val:</span><br><span class="line">                curr.<span class="built_in">next</span> = list1</span><br><span class="line">                list1 = list1.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                curr.<span class="built_in">next</span> = list2</span><br><span class="line">                list2 = list2.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">            curr = curr.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 连接剩余的节点</span></span><br><span class="line">        curr.<span class="built_in">next</span> = list1 <span class="keyword">or</span> list2</span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">mergeTwoLists</span>(<span class="params">list1, list2</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> dummy = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">let</span> curr = dummt;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历两个链表，比较节点值</span></span><br><span class="line">        <span class="keyword">while</span> (list1 !== <span class="literal">null</span> &amp;&amp; list2 !== <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (list1.<span class="property">val</span> &lt; list2.<span class="property">val</span>) &#123;</span><br><span class="line">                curr.<span class="property">next</span> = list1;</span><br><span class="line">                list1 = list1.<span class="property">next</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                curr.<span class="property">next</span> = list2;</span><br><span class="line">                list2 = list2.<span class="property">next</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            curr = curr.<span class="property">next</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 连接剩余的节点</span></span><br><span class="line">        curr.<span class="property">next</span> = list1 || list2;</span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h4 id="k个一组翻转链表"><a href="#k个一组翻转链表" class="headerlink" title="k个一组翻转链表"></a><code>k</code>个一组翻转链表</h4><blockquote><p><a href="https://leetcode.com/problems/reverse-nodes-in-k-group/">Leetcode 25. Reverse Nodes in k-Group</a></p></blockquote><ul><li><code>题目:</code> 给定一个单链表的头节点<code>head</code>和一个整数<code>k</code>，将链表按照每<code>k</code>个节点为一组进行翻转。如果剩余节点不足 <code>k</code>个，则保持原样。要求返回翻转后的链表</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: head = [1,2,3,4,5,6], k = 3</span><br><span class="line">Output: [3,2,1,6,5,4]</span><br></pre></td></tr></table></figure><ul><li><code>解法:</code> 按组翻转 + 双指针</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 遍历链表并按 k 个节点为一组分割</span><br><span class="line">2. 对每组节点执行翻转操作</span><br><span class="line">3. 翻转后的部分与链表的其他部分正确连接</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseKGroup</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode], k: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        dummy = ListNode(<span class="number">0</span>, head)</span><br><span class="line">        group_prev = dummy</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="comment"># 找到当前组的第 k 个节点</span></span><br><span class="line">            kth = self.getKthNode(group_prev, k)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> kth:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            group_next = kth.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 反转当前组的节点</span></span><br><span class="line">            prev, curr = group_next, group_prev.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">while</span> curr != group_next:</span><br><span class="line">                next_node = curr.<span class="built_in">next</span></span><br><span class="line">                curr.<span class="built_in">next</span> = prev</span><br><span class="line">                prev = curr</span><br><span class="line">                curr = next_node</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 处理连接：将反转后的部分与链表其余部分连接起来</span></span><br><span class="line">            next_node = group_prev.<span class="built_in">next</span></span><br><span class="line">            group_prev.<span class="built_in">next</span> = kth</span><br><span class="line">            group_prev = next_node</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getKthNode</span>(<span class="params">self, node, k</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        <span class="keyword">while</span> node <span class="keyword">and</span> k &gt; <span class="number">0</span>:</span><br><span class="line">            node = node.<span class="built_in">next</span></span><br><span class="line">            k -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> node</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">reverseKGroup</span>(<span class="params">head, k</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> dummy = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>, head);</span><br><span class="line">        <span class="keyword">let</span> groupPrev = dummy;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 找到当前组的第 k 个节点</span></span><br><span class="line">            <span class="keyword">const</span> kth = <span class="variable language_">this</span>.<span class="title function_">getKthNode</span>(groupPrev, k);</span><br><span class="line">            <span class="keyword">if</span> (!kth) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">const</span> groupNext = kth.<span class="property">next</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 反转当前组的节点</span></span><br><span class="line">            <span class="keyword">let</span> prev = groupNext;</span><br><span class="line">            <span class="keyword">let</span> curr = groupPrev.<span class="property">next</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (curr !== groupNext) &#123;</span><br><span class="line">                <span class="keyword">const</span> nextNode = curr.<span class="property">next</span>;</span><br><span class="line">                curr.<span class="property">next</span> = prev;</span><br><span class="line">                prev = curr;</span><br><span class="line">                curr = nextNode;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 处理连接</span></span><br><span class="line">            <span class="keyword">const</span> nextNode = groupPrev.<span class="property">next</span>;</span><br><span class="line">            groupPrev.<span class="property">next</span> = kth;</span><br><span class="line">            groupPrev = nextNode;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">getKthNode</span>(<span class="params">node, k</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (node &amp;&amp; k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            node = node.<span class="property">next</span>;</span><br><span class="line">            k--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h4 id="成对反转链表节点"><a href="#成对反转链表节点" class="headerlink" title="成对反转链表节点"></a>成对反转链表节点</h4><blockquote><p><a href="https://leetcode.com/problems/swap-nodes-in-pairs/">Leetcode 24. Swap Nodes in Pairs</a></p></blockquote><ul><li><code>题目:</code> 给定一个单链表的头节点<code>head</code>，将链表中的节点两两交换，并返回交换后的链表。如果链表节点数是奇数，最后一个节点保持不变</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: head = [1,2,3,4]</span><br><span class="line">Output: [2,1,4,3]</span><br></pre></td></tr></table></figure><ul><li><code>解法:</code> 虚拟头节点法</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 使用一个虚拟头节点 dummy，便于操作头节点及其后的节点</span><br><span class="line">2. 每次取出两个相邻节点，将它们交换</span><br><span class="line">3. 正确调整指针以保持链表的顺序</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">swapPairs</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        dummy = ListNode(<span class="number">0</span>, head)</span><br><span class="line">        prev = dummy</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> head <span class="keyword">and</span> head.<span class="built_in">next</span>:</span><br><span class="line">            <span class="comment"># 要交换的两个节点</span></span><br><span class="line">            first = head</span><br><span class="line">            second = head.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 交换节点</span></span><br><span class="line">            prev.<span class="built_in">next</span> = second</span><br><span class="line">            first.<span class="built_in">next</span> = second.<span class="built_in">next</span></span><br><span class="line">            second.<span class="built_in">next</span> = first</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 移动指针准备下一组交换</span></span><br><span class="line">            prev = first</span><br><span class="line">            head = first.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">swapPairs</span>(<span class="params">head</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> dummy = <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        dummy.<span class="property">next</span> = head;</span><br><span class="line">        <span class="keyword">let</span> prev = dummy;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (head &amp;&amp; head.<span class="property">next</span>) &#123;</span><br><span class="line">            <span class="comment">// 要交换的两个节点</span></span><br><span class="line">            <span class="keyword">const</span> first = head;</span><br><span class="line">            <span class="keyword">const</span> second = head.<span class="property">next</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 交换节点</span></span><br><span class="line">            prev.<span class="property">next</span> = second;</span><br><span class="line">            first.<span class="property">next</span> = second.<span class="property">next</span>;</span><br><span class="line">            second.<span class="property">next</span> = first;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 移动指针准备下一组交换</span></span><br><span class="line">            prev = first;</span><br><span class="line">            head = first.<span class="property">next</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h4 id="对折链表"><a href="#对折链表" class="headerlink" title="对折链表"></a>对折链表</h4><blockquote><p><a href="https://leetcode.com/problems/reorder-list/">Leetcode 143. Reorder List</a></p></blockquote><ul><li><code>题目:</code> 给定一个单链表<code>head</code>，要求在原地修改链表，不使用额外的空间, 将其重新排序为<ul><li>原链表的第一个节点 -&gt; 最后一个节点 -&gt; 第二个节点 -&gt; 倒数第二个节点 -&gt;</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: head = [1,2,3,4,5]</span><br><span class="line">Output: [1,5,2,4,3]</span><br></pre></td></tr></table></figure><ul><li><code>解法:</code> 快慢指针 + 反转链表 + 合并链表</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 找到链表中点</span><br><span class="line">   - 使用快慢指针，快指针每次移动两步，慢指针每次移动一步，当快指针到达末尾时，慢指针指向中点</span><br><span class="line">2. 反转链表后半部分</span><br><span class="line">   - 将链表从中点分成两部分，反转后半部分链表</span><br><span class="line">3. 合并链表</span><br><span class="line">   - 按顺序交替连接前半部分和反转后的后半部分链表</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reorderList</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify head in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 1. 使用快慢指针找到链表中点</span></span><br><span class="line">        slow, fast = head, head.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> fast <span class="keyword">and</span> fast.<span class="built_in">next</span>:</span><br><span class="line">            slow = slow.<span class="built_in">next</span></span><br><span class="line">            fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 2. 反转链表的后半部分</span></span><br><span class="line">        curr = slow.<span class="built_in">next</span></span><br><span class="line">        prev = <span class="literal">None</span></span><br><span class="line">        slow.<span class="built_in">next</span> = <span class="literal">None</span> <span class="comment"># 切断前半部分和后半部分链表的连接</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> curr:</span><br><span class="line">            next_node = curr.<span class="built_in">next</span></span><br><span class="line">            second.<span class="built_in">next</span> = prev</span><br><span class="line">            prev = curr</span><br><span class="line">            curr = next_node</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 3. 合并链表</span></span><br><span class="line">        first, second = head, prev <span class="comment"># first 是前半部分的链表头，second 是反转后的后半部分链表头</span></span><br><span class="line">        <span class="keyword">while</span> second:</span><br><span class="line">            tmp1, tmp2 = first.<span class="built_in">next</span>, second.<span class="built_in">next</span></span><br><span class="line">            first.<span class="built_in">next</span> = second</span><br><span class="line">            second.<span class="built_in">next</span> = tmp1</span><br><span class="line">            first, second = tmp1, tmp2</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">reorderList</span>(<span class="params">head</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!head || !head.<span class="property">next</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 使用快慢指针找到链表中点</span></span><br><span class="line">        <span class="keyword">let</span> slow = head, fast = head.<span class="property">next</span>;</span><br><span class="line">        <span class="keyword">while</span> (fast &amp;&amp; fast.<span class="property">next</span>) &#123;</span><br><span class="line">            slow = slow.<span class="property">next</span>;</span><br><span class="line">            fast = fast.<span class="property">next</span>.<span class="property">next</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 反转链表的后半部分</span></span><br><span class="line">        <span class="keyword">let</span> curr = slow.<span class="property">next</span>;</span><br><span class="line">        <span class="keyword">let</span> prev = <span class="literal">null</span>;</span><br><span class="line">        slow.<span class="property">next</span> = <span class="literal">null</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (curr) &#123;</span><br><span class="line">            <span class="keyword">const</span> nextNode = curr.<span class="property">next</span>;</span><br><span class="line">            curr.<span class="property">next</span> = prev;</span><br><span class="line">            prev = curr;</span><br><span class="line">            curr = nextNode;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 合并链表</span></span><br><span class="line">        <span class="keyword">let</span> first = head, second = prev;</span><br><span class="line">        <span class="keyword">while</span> (second) &#123;</span><br><span class="line">            <span class="keyword">let</span> tmp1 = first.<span class="property">next</span>, tmp2 = second.<span class="property">next</span>;</span><br><span class="line">            first.<span class="property">next</span> = second;</span><br><span class="line">            second.<span class="property">next</span> = tmp1;</span><br><span class="line">            first = tmp1, second = tmp2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h4 id="删除有序链表重复元素"><a href="#删除有序链表重复元素" class="headerlink" title="删除有序链表重复元素"></a>删除有序链表重复元素</h4><blockquote><p><a href="https://leetcode.com/problems/remove-duplicates-from-sorted-list/">Leetcode 83. Remove Duplicates from Sorted List</a></p></blockquote><ul><li><code>题目:</code> 从一个升序排列的链表中，删除所有重复的节点，确保每个值只出现一次</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: head = [1,1,2,3,3]</span><br><span class="line">Output: [1,2,3]</span><br></pre></td></tr></table></figure><ul><li><code>解法:</code> 遍历链表</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 从链表头开始，依次检查当前节点和下一个节点的值</span><br><span class="line">2. 如果当前节点值和下一个节点值相同，则跳过下一个节点</span><br><span class="line">3. 如果值不同，则移动指针到下一个节点</span><br><span class="line">4. 重复上述过程，直到遍历完整个链表</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">deleteDuplicates</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        curr = head</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> curr <span class="keyword">and</span> curr.<span class="built_in">next</span>:</span><br><span class="line">            next_node = curr.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">if</span> curr.val == next_node.val: <span class="comment"># 如果当前值等于下一个值</span></span><br><span class="line">                curr.<span class="built_in">next</span> = next_node.<span class="built_in">next</span> <span class="comment"># 跳过下一个节点</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                curr = curr.<span class="built_in">next</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">deleteDuplicates</span>(<span class="params">head</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> curr = head;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (curr &amp;&amp; curr.<span class="property">next</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> nextNode = curr.<span class="property">next</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (curr.<span class="property">val</span> === nextNode.<span class="property">val</span>) </span><br><span class="line">                curr.<span class="property">next</span> = nextNode.<span class="property">next</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                curr = curr.<span class="property">next</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h4 id="删除有序链表所有重复元素"><a href="#删除有序链表所有重复元素" class="headerlink" title="删除有序链表所有重复元素"></a>删除有序链表所有重复元素</h4><blockquote><p><a href="https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/">Leetcode 82. Remove Duplicates from Sorted List II</a></p></blockquote><ul><li><code>题目:</code> 从一个升序排列的链表中，删除所有出现次数超过<code>1</code>次的节点，仅保留没有重复的节点</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: head = [1,2,3,3,4,4,5]</span><br><span class="line">Output: [1,2,5]</span><br></pre></td></tr></table></figure><ul><li><code>解法:</code> 双指针 + 虚拟头节点</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 创建虚拟头节点 dummy，以处理可能需要删除头节点的情况</span><br><span class="line">2. 定义两个指针：</span><br><span class="line">    - prev：指向最后一个不重复的节点</span><br><span class="line">    - curr：用于遍历链表</span><br><span class="line">3. 遍历链表：</span><br><span class="line">    - 如果 curr 和 curr.next 的值相同，跳过所有重复的节点</span><br><span class="line">    - 如果没有重复，移动 prev 指针到当前节点</span><br><span class="line">4. 返回虚拟头节点的下一个节点</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">deleteDuplicates</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        dummy = ListNode(<span class="number">0</span>, head)</span><br><span class="line">        prev, curr = dummy, head</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> curr:</span><br><span class="line">            <span class="comment"># 如果当前节点的值与下一个节点的值相同</span></span><br><span class="line">            <span class="keyword">if</span> curr.<span class="built_in">next</span> <span class="keyword">and</span> curr.val == curr.<span class="built_in">next</span>.val:</span><br><span class="line">                <span class="comment"># 跳过所有值相同的节点</span></span><br><span class="line">                <span class="keyword">while</span> curr.<span class="built_in">next</span> <span class="keyword">and</span> curr.val == curr.<span class="built_in">next</span>.val:</span><br><span class="line">                    curr = curr.<span class="built_in">next</span></span><br><span class="line">                <span class="comment"># 将 prev 的 next 指向下一个不重复的节点</span></span><br><span class="line">                prev.<span class="built_in">next</span> = curr.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 如果没有重复，移动 prev 指针</span></span><br><span class="line">                prev = prev.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 移动 curr 指针</span></span><br><span class="line">            curr = curr.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">deleteDuplicates</span>(<span class="params">head</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> dummy = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>, head);</span><br><span class="line">        <span class="keyword">let</span> prev = dummy, curr = head;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (curr) &#123;</span><br><span class="line">            <span class="comment">// 如果当前节点的值与下一个节点的值相同</span></span><br><span class="line">            <span class="keyword">if</span> (curr.<span class="property">next</span> &amp;&amp; curr.<span class="property">val</span> === curr.<span class="property">next</span>.<span class="property">val</span>) &#123;</span><br><span class="line">                <span class="comment">// 跳过所有值相同的节点</span></span><br><span class="line">                <span class="keyword">while</span> (curr.<span class="property">next</span> &amp;&amp; curr.<span class="property">val</span> === curr.<span class="property">next</span>.<span class="property">val</span>)</span><br><span class="line">                    curr = curr.<span class="property">next</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将 prev 的 next 指向下一个不重复的节点</span></span><br><span class="line">            prev.<span class="property">next</span> = curr.<span class="property">next</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果没有重复，移动 prev 指针</span></span><br><span class="line">            prev = prev.<span class="property">next</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 移动 curr 指针</span></span><br><span class="line">        curr = curr.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dummy.<span class="property">next</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h4 id="链表转树"><a href="#链表转树" class="headerlink" title="链表转树"></a>链表转树</h4><blockquote><p><a href="https://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/">Leetcode 109. Convert Sorted List to Binary Search Tree</a></p></blockquote><ul><li>题目: 将一个有序链表转换为高度平衡的二叉搜索树（<code>BST</code>）。高度平衡指的是树中每个节点的两个子树的高度差不超过<code>1</code></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: head = [-10,-3,0,5,9]</span><br><span class="line">Output: [0,-3,9,-10,null,5]</span><br></pre></td></tr></table></figure><ul><li>解法: 分治法 + 快慢指针</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 使用快慢指针找到链表的中间节点，将其作为当前树的根节点</span><br><span class="line">2. 对中间节点之前的链表递归构建左子树</span><br><span class="line">3. 对中间节点之后的链表递归构建右子树</span><br><span class="line">4. 当链表为空时，返回 None</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sortedListToBST</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">        <span class="comment"># 辅助函数：找到链表的中间节点</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">find_middle</span>(<span class="params">start, end</span>):</span><br><span class="line">            slow = fast = start</span><br><span class="line">            <span class="keyword">while</span> fast != end <span class="keyword">and</span> fast.<span class="built_in">next</span> != end:</span><br><span class="line">                slow = slow.<span class="built_in">next</span></span><br><span class="line">                fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">return</span> slow</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 主函数：递归构建二叉搜索树</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">build_bst</span>(<span class="params">start, end</span>):</span><br><span class="line">            <span class="keyword">if</span> start == end:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            </span><br><span class="line">            mid = find_middle(start, end)</span><br><span class="line">            root = TreeNode(mid.val)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 构建左右子树</span></span><br><span class="line">            root.left = build_bst(start, mid)</span><br><span class="line">            root.right = build_bst(mid.<span class="built_in">next</span>, end)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> build_bst(head, <span class="literal">None</span>)</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">sortedListToBST</span>(<span class="params">head</span>) &#123;</span><br><span class="line">        <span class="comment">// 辅助函数：找到链表的中间节点</span></span><br><span class="line">        <span class="keyword">function</span> <span class="title function_">findMiddle</span>(<span class="params">start, end</span>) &#123;</span><br><span class="line">            <span class="keyword">let</span> slow = start;</span><br><span class="line">            <span class="keyword">let</span> fast = start;</span><br><span class="line">            <span class="keyword">while</span> (fast !== end &amp;&amp; fast.<span class="property">next</span> !== end) &#123;</span><br><span class="line">                slow = slow.<span class="property">next</span>;</span><br><span class="line">                fast = fast.<span class="property">next</span>.<span class="property">next</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> slow;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 主函数：递归构建二叉搜索树</span></span><br><span class="line">        <span class="keyword">function</span> <span class="title function_">buildBST</span>(<span class="params">start, end</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (start === end) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> mid = <span class="title function_">findMiddle</span>(start, end);</span><br><span class="line">            <span class="keyword">const</span> root = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(mid.<span class="property">val</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 构建左右子树</span></span><br><span class="line">            root.<span class="property">left</span> = <span class="title function_">buildBST</span>(start, mid);</span><br><span class="line">            root.<span class="property">right</span> = <span class="title function_">buildBST</span>(mid.<span class="property">next</span>, end);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">buildBST</span>(head, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h4 id="合并k个有序链表"><a href="#合并k个有序链表" class="headerlink" title="合并k个有序链表"></a>合并<code>k</code>个有序链表</h4><blockquote><p><a href="https://leetcode.com/problems/merge-k-sorted-lists/">Leetcode 23. Merge k Sorted Lists</a></p></blockquote><ul><li>题目: 给定<code>k</code>个有序链表，将它们合并成一个有序链表并返</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: lists = [[1,4,5],[1,3,4],[2,6]]</span><br><span class="line">Output: [1,1,2,3,4,4,5,6]</span><br></pre></td></tr></table></figure><ul><li>解法: 最小堆（优先队列）</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 将每个链表的头节点加入最小堆</span><br><span class="line">2. 每次从堆中取出最小值节点，将其加入结果链表</span><br><span class="line">3. 如果该节点有下一个节点，将下一个节点加入堆中</span><br><span class="line">4. 重复以上过程直到堆为空</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">mergeKLists</span>(<span class="params">self, lists: <span class="type">List</span>[<span class="type">Optional</span>[ListNode]]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        min_heap = []</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 将每个链表的头节点放入堆中</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(lists)):</span><br><span class="line">            <span class="keyword">if</span> lists[i]:</span><br><span class="line">                heapq.heappush(min_heap, (lists[i].val, i, lists[i]))</span><br><span class="line"></span><br><span class="line">        dummy = ListNode(<span class="number">0</span>)</span><br><span class="line">        curr = dummy</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 不断从堆中取出最小节点，并将其后续节点继续放入堆中</span></span><br><span class="line">        <span class="keyword">while</span> min_heap:</span><br><span class="line">            val, idx, node = heapq.heappop(min_heap)</span><br><span class="line">            curr.<span class="built_in">next</span> = node</span><br><span class="line">            curr = curr.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">if</span> node.<span class="built_in">next</span>:</span><br><span class="line">                heapq.heappush(min_heap, (node.<span class="built_in">next</span>.val, idx, node.<span class="built_in">next</span>))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">mergeKLists</span>(<span class="params">lists</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> minHeap = <span class="keyword">new</span> <span class="title class_">MinPriorityQueue</span>(&#123; <span class="attr">priority</span>: <span class="function">(<span class="params">node</span>) =&gt;</span> node.<span class="property">val</span> &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将每个链表的头节点加入堆中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; lists.<span class="property">length</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (lists[i])</span><br><span class="line">                minHeap.<span class="title function_">enqueue</span>(lists[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> dummy = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">let</span> curr = dummy;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从堆中取出最小节点，构建合并链表</span></span><br><span class="line">        <span class="keyword">while</span> (!minHeap.<span class="title function_">isEmpty</span>()) &#123;</span><br><span class="line">            <span class="keyword">const</span> smallestNode = minHeap.<span class="title function_">dequeue</span>().<span class="property">element</span>; <span class="comment">// 取出最小值节点</span></span><br><span class="line">            curr.<span class="property">next</span> = smallestNode;</span><br><span class="line">            curr = curr.<span class="property">next</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (smallestNode.<span class="property">next</span>)</span><br><span class="line">                minHeap.<span class="title function_">enqueue</span>(smallestNode.<span class="property">next</span>); <span class="comment">// 将下一个节点加入堆</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h3 id="BFS-amp-DFS"><a href="#BFS-amp-DFS" class="headerlink" title="BFS &amp; DFS"></a><code>BFS</code> &amp; <code>DFS</code></h3><h4 id="海岛问题"><a href="#海岛问题" class="headerlink" title="海岛问题"></a>海岛问题</h4><blockquote><p><a href="https://leetcode.com/problems/number-of-islands/">Leetcode 200. Number of Islands</a></p></blockquote><ul><li>题目: 给定一个由<code>&#39;1&#39;</code>和<code>&#39;0&#39;</code>组成的网格，<code>&#39;1&#39;</code>表示陆地，<code>&#39;0&#39;</code>表示水域，计算网格中岛屿的数量。岛屿被水域包围，由相邻的陆地（水平或垂直方向）连接而成</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: grid = [</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;]</span><br><span class="line">]</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure><ul><li>解法<code>1</code>: 广度优先搜索 (<code>BFS</code>)</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 遍历网格中的每个位置，找到未访问的陆地节点作为起点</span><br><span class="line">2. 从起点开始，使用 BFS 遍历整个岛屿，将所有相连的陆地标记为已访问</span><br><span class="line">3. 每发现一个新岛屿时，岛屿计数器加一</span><br><span class="line">4. 返回最终的岛屿数量</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">numIslands</span>(<span class="params">self, grid: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        island = <span class="number">0</span></span><br><span class="line">        visited = <span class="built_in">set</span>() <span class="comment"># 记录已访问节点</span></span><br><span class="line">        rows, cols = <span class="built_in">len</span>(grid), <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">bfs</span>(<span class="params">r, c</span>):</span><br><span class="line">            q = deque()</span><br><span class="line">            q.append((r, c))</span><br><span class="line">            visited.add((r, c))</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> q:</span><br><span class="line">                row, col = q.popleft()</span><br><span class="line">                <span class="keyword">for</span> dr, dc <span class="keyword">in</span> [[<span class="number">1</span>, <span class="number">0</span>], [-<span class="number">1</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">1</span>], [<span class="number">0</span>, -<span class="number">1</span>]]:</span><br><span class="line">                    nr, nc = dr + row, dc + col</span><br><span class="line">                    <span class="keyword">if</span> (</span><br><span class="line">                        <span class="number">0</span> &lt;= nr &lt; rows <span class="keyword">and</span></span><br><span class="line">                        <span class="number">0</span> &lt;= nc &lt; cols <span class="keyword">and</span></span><br><span class="line">                        grid[nr][nc] == <span class="string">&quot;1&quot;</span> <span class="keyword">and</span></span><br><span class="line">                        (nr, nc) <span class="keyword">not</span> <span class="keyword">in</span> visited</span><br><span class="line">                    ):</span><br><span class="line">                        q.append((nr, nc))</span><br><span class="line">                        visited.add((nr, nc))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> r <span class="keyword">in</span> <span class="built_in">range</span>(rows):</span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">range</span>(cols):</span><br><span class="line">                <span class="keyword">if</span> grid[r][c] == <span class="string">&quot;1&quot;</span> <span class="keyword">and</span> (r, c) <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">                    island += <span class="number">1</span></span><br><span class="line">                    bfs(r, c)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> island</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">numIslands</span>(<span class="params">grid</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> rows = grid.<span class="property">length</span>;</span><br><span class="line">        <span class="keyword">const</span> cols = grid[<span class="number">0</span>].<span class="property">length</span>;</span><br><span class="line">        <span class="keyword">const</span> visited = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line">        <span class="keyword">let</span> island = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> <span class="title function_">bfs</span> = (<span class="params">r, c</span>) =&gt; &#123;</span><br><span class="line">            <span class="keyword">const</span> queue = [];</span><br><span class="line">            queue.<span class="title function_">push</span>([r, c]);</span><br><span class="line">            visited.<span class="title function_">add</span>(<span class="string">`<span class="subst">$&#123;r&#125;</span>,<span class="subst">$&#123;c&#125;</span>`</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (queue.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">const</span> [row, col] = queue.<span class="title function_">shift</span>();</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">const</span> [dr, dc] <span class="keyword">of</span> [[<span class="number">1</span>, <span class="number">0</span>], [-<span class="number">1</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">1</span>], [<span class="number">0</span>, -<span class="number">1</span>]]) &#123;</span><br><span class="line">                    <span class="keyword">const</span> nr = dr + row;</span><br><span class="line">                    <span class="keyword">const</span> nc = dc + col;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (nr &gt;= <span class="number">0</span> &amp;&amp;</span><br><span class="line">                        nc &gt;= <span class="number">0</span> &amp;&amp;</span><br><span class="line">                        nr &lt; rows &amp;&amp;</span><br><span class="line">                        nc &lt; cols &amp;&amp;</span><br><span class="line">                        grid[nr][nc] === <span class="string">&quot;1&quot;</span> &amp;&amp;</span><br><span class="line">                        !visited.<span class="title function_">has</span>(<span class="string">`<span class="subst">$&#123;nr&#125;</span>,<span class="subst">$&#123;nc&#125;</span>`</span>)</span><br><span class="line">                    ) &#123;</span><br><span class="line">                        queue.<span class="title function_">push</span>([nr, nc]);</span><br><span class="line">                        visited.<span class="title function_">add</span>(<span class="string">`<span class="subst">$&#123;nr&#125;</span>,<span class="subst">$&#123;nc&#125;</span>`</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> r = <span class="number">0</span>; r &lt; rows; r++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> c = <span class="number">0</span>; c &lt; cols; c++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[r][c] === <span class="string">&quot;1&quot;</span> &amp;&amp; !visited.<span class="title function_">has</span>(<span class="string">`<span class="subst">$&#123;r&#125;</span>,<span class="subst">$&#123;c&#125;</span>`</span>)) &#123;</span><br><span class="line">                    island += <span class="number">1</span>;</span><br><span class="line">                    <span class="title function_">bfs</span>(r, c);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> island;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><ul><li>解法<code>2</code>: 深度优先搜索 (<code>DFS</code>)</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 使用递归替代 BFS 的队列逻辑</span><br><span class="line">2. 遍历网格，遇到未访问的陆地时，启动 DFS 遍历整个岛屿</span><br><span class="line">3. 每发现一个新岛屿时，岛屿计数器加一</span><br><span class="line">4. 返回岛屿数量</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">numIslands</span>(<span class="params">self, grid: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        island = <span class="number">0</span></span><br><span class="line">        rows, cols = <span class="built_in">len</span>(grid), <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">r, c</span>):</span><br><span class="line">            <span class="keyword">if</span> r &lt; <span class="number">0</span> <span class="keyword">or</span> c &lt; <span class="number">0</span> <span class="keyword">or</span> r &gt;= rows <span class="keyword">or</span> c &gt;= cols <span class="keyword">or</span> grid[r][c] == <span class="string">&quot;0&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            grid[r][c] = <span class="string">&quot;0&quot;</span> <span class="comment"># 标记为已访问</span></span><br><span class="line">            <span class="comment"># 遍历四个方向</span></span><br><span class="line">            <span class="keyword">for</span> dr, dc <span class="keyword">in</span> [[<span class="number">1</span>, <span class="number">0</span>], [-<span class="number">1</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">1</span>], [<span class="number">0</span>, -<span class="number">1</span>]]:</span><br><span class="line">                dfs(r + dr, c + dc)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> r <span class="keyword">in</span> <span class="built_in">range</span>(rows):</span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">range</span>(cols):</span><br><span class="line">                <span class="keyword">if</span> grid[r][c] == <span class="string">&quot;1&quot;</span>:</span><br><span class="line">                    island += <span class="number">1</span></span><br><span class="line">                    dfs(r, c)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> island</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">numIslands</span>(<span class="params">grid</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> rows = grid.<span class="property">length</span>;</span><br><span class="line">        <span class="keyword">const</span> cols = grid[<span class="number">0</span>].<span class="property">length</span>;</span><br><span class="line">        <span class="keyword">let</span> island = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> <span class="title function_">dfs</span> = (<span class="params">r, c</span>) =&gt; &#123;</span><br><span class="line">            <span class="comment">// 如果超出边界或遇到水域，则停止递归</span></span><br><span class="line">            <span class="keyword">if</span> (r &lt; <span class="number">0</span> || c &lt; <span class="number">0</span> || r &gt;= rows || c &gt;= cols || grid[r][c] === <span class="string">&quot;0&quot;</span>)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">            grid[r][c] = <span class="number">0</span>; <span class="comment">// 标记为已访问</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">const</span> [dr, dc] <span class="keyword">of</span> [[<span class="number">1</span>, <span class="number">0</span>], [-<span class="number">1</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">1</span>], [<span class="number">0</span>, -<span class="number">1</span>]])</span><br><span class="line">                <span class="title function_">dfs</span>(r + dr, c + dc);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> r = <span class="number">0</span>; r &lt; rows; r++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> c = <span class="number">0</span>; c &lt; cols; c++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[r][c] === <span class="string">&quot;1&quot;</span>) &#123;</span><br><span class="line">                    island += <span class="number">1</span>;</span><br><span class="line">                    <span class="title function_">dfs</span>(r, c);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> island;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h3 id="Two-Pointers-双指针"><a href="#Two-Pointers-双指针" class="headerlink" title="Two Pointers 双指针"></a><code>Two Pointers</code> 双指针</h3><h4 id="雨水问题"><a href="#雨水问题" class="headerlink" title="雨水问题"></a>雨水问题</h4><blockquote><p><a href="https://leetcode.com/problems/trapping-rain-water/">Leetcode 42. Trapping Rain Water</a></p></blockquote><ul><li>题目: 给定一个非负整数数组<code>height</code>，表示每个柱子的高度。假设下雨后水只会停留在柱子之间，请计算可以接住的总雨水量</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: height = [0,1,0,2,1,0,1,3,2,1,2,1]</span><br><span class="line">Output: 6</span><br></pre></td></tr></table></figure><ul><li>解法: 双指针</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 使用两个指针分别从数组的左右两端向中间靠拢</span><br><span class="line">2. 在遍历过程中，记录左右两侧的最大高度</span><br><span class="line">3. 计算当前柱子上方的雨水量：</span><br><span class="line">    - 雨水量 = 较低一侧的最大高度 - 当前柱子高度</span><br><span class="line">4. 移动较低一侧的指针，同时更新对应的最大高度</span><br><span class="line">5. 遍历结束时，累加所有雨水量并返回结果</span><br><span class="line"></span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">trap</span>(<span class="params">self, height: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> height:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        left, right = <span class="number">0</span>, <span class="built_in">len</span>(height) - <span class="number">1</span></span><br><span class="line">        <span class="comment"># 初始化左右两边的最大高度</span></span><br><span class="line">        left_max, right_max = height[left], height[right]</span><br><span class="line">        result = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            <span class="comment"># 如果左边的最大高度小于右边的最大高度</span></span><br><span class="line">            <span class="keyword">if</span> left_max &lt; right_max:</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">                <span class="comment"># 更新左边的最大高度</span></span><br><span class="line">                left_max = <span class="built_in">max</span>(left_max, height[left])</span><br><span class="line">                <span class="comment"># 计算当前左指针位置的接水量（左边的最大高度 - 当前柱子的高度）</span></span><br><span class="line">                result += left_max - height[left]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line">                <span class="comment"># 更新右边的最大高度</span></span><br><span class="line">                right_max = <span class="built_in">max</span>(right_max, height[right])</span><br><span class="line">                <span class="comment"># 计算当前右指针位置的接水量（右边的最大高度 - 当前柱子的高度）</span></span><br><span class="line">                result += right_max - height[right]</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">trap</span>(<span class="params">height</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> left = <span class="number">0</span>, right = height.<span class="property">length</span> - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">let</span> leftMax = height[left], rightMax = height[right];</span><br><span class="line">        <span class="keyword">let</span> result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">if</span> (leftMax &lt; rightMax) &#123;</span><br><span class="line">                left++;</span><br><span class="line">                leftMax = <span class="title class_">Math</span>.<span class="title function_">max</span>(leftMax, height[left]); <span class="comment">// 更新左边最大高度</span></span><br><span class="line">                result += leftMax - height[left]; <span class="comment">// 计算左侧接水量</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right--;</span><br><span class="line">                rightMax = <span class="title class_">Math</span>.<span class="title function_">max</span>(rightMax, height[right]); <span class="comment">// 更新右边最大高度</span></span><br><span class="line">                result += rightMax - height[right]; <span class="comment">// 计算右侧接水量</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h4 id="盛水问题"><a href="#盛水问题" class="headerlink" title="盛水问题"></a>盛水问题</h4><blockquote><p><a href="https://leetcode.com/problems/container-with-most-water/">Leetcode 11. Container With Most Water</a></p></blockquote><ul><li>题目: 给定一个数组<code>height</code>，其中每个元素表示一个竖线的高度，竖线在横轴上的间隔为<code>1</code>。找到两根竖线之间形成的容器能够盛水的最大面积</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: height = [1,8,6,2,5,4,8,3,7]</span><br><span class="line">Output: 49</span><br></pre></td></tr></table></figure><ul><li>解法: 双指针</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 初始化左右指针，分别指向数组的两端</span><br><span class="line">2. 每次计算由左右指针对应的竖线形成的容器面积，更新最大面积</span><br><span class="line">3. 移动较短竖线的一侧指针，尝试找到更大的容器</span><br><span class="line">4. 重复上述步骤，直到左右指针相遇</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxArea</span>(<span class="params">self, height: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        left, right = <span class="number">0</span>, <span class="built_in">len</span>(height) - <span class="number">1</span></span><br><span class="line">        result = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            <span class="comment"># 计算当前容器的面积</span></span><br><span class="line">            width = right - left</span><br><span class="line">            area = <span class="built_in">min</span>(height[left], height[right]) * width</span><br><span class="line">            <span class="comment"># 更新最大面积</span></span><br><span class="line">            result = <span class="built_in">max</span>(result, area)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 移动较短边对应的指针，尝试找到更大的容器</span></span><br><span class="line">            <span class="keyword">if</span> height[left] &lt; height[right]:</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">maxArea</span>(<span class="params">height</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> left = <span class="number">0</span>, right = height.<span class="property">length</span> - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">let</span> maxArea = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="comment">// 计算当前容器的面积</span></span><br><span class="line">            <span class="keyword">const</span> width = right - left;</span><br><span class="line">            <span class="keyword">const</span> area = <span class="title class_">Math</span>.<span class="title function_">min</span>(height[left], height[right]) * width;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 更新最大面积</span></span><br><span class="line">            maxArea = <span class="title class_">Math</span>.<span class="title function_">max</span>(maxArea, area);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 移动较短边对应的指针</span></span><br><span class="line">            <span class="keyword">if</span> (height[left] &lt; height[right])</span><br><span class="line">                left++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                right--;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> maxArea;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h4 id="一维数组去重"><a href="#一维数组去重" class="headerlink" title="一维数组去重"></a>一维数组去重</h4><blockquote><p><a href="https://leetcode.com/problems/remove-duplicates-from-sorted-array/">Leetcode 26. Remove Duplicates from Sorted Array</a></p></blockquote><ul><li>题目: 有序数组<code>nums</code>，需要原地移除重复项，使每个元素最多出现一次</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: nums = [0,0,1,1,1,2,2,3,3,4]</span><br><span class="line">Output: 5, nums = [0,1,2,3,4,_,_,_,_,_]</span><br></pre></td></tr></table></figure><ul><li>解法: 双指针</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 定义 i 指针跟踪去重后数组的最后一个位置</span><br><span class="line">2. 使用 j 指针遍历数组，寻找不重复的元素</span><br><span class="line">3. 遇到新元素时，将其放在 i+1 位置，并更新 i</span><br><span class="line">4. 返回去重后数组的长度 i+1</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeDuplicates</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        i = <span class="number">0</span> <span class="comment"># 跟踪去重后数组的最后一个位置</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[j] != nums[i]: <span class="comment"># 如果发现新的元素</span></span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">                nums[i] = nums[j] <span class="comment"># 将 nums[j] 移动到去重后的数组中</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> i + <span class="number">1</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">removeDuplicates</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="property">length</span> === <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>; j &lt; nums.<span class="property">length</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[j] !== nums[i]) &#123; <span class="comment">// 遇到新元素</span></span><br><span class="line">                i++;</span><br><span class="line">                nums[i] = nums[j]; <span class="comment">// 更新数组</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h4 id="最接近的三数之和"><a href="#最接近的三数之和" class="headerlink" title="最接近的三数之和"></a>最接近的三数之和</h4><blockquote><p><a href="https://leetcode.com/problems/3sum-closest/">Leetcode 16. 3Sum Closest</a></p></blockquote><ul><li>题目: 给定一个长度为<code>n</code>的整数数组<code>nums</code>和一个目标值<code>target</code>，找到数组中三个数的和，使其最接近目标值。返回这个和</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: nums = [-1,2,1,-4], target = 1</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: The sum that is closest to the target is 2. (-1 + 2 + 1 = 2)</span><br></pre></td></tr></table></figure><ul><li>解法: 排序 + 双指针</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 首先对数组进行排序</span><br><span class="line">2. 遍历数组，固定一个数 nums[i]，用双指针从 i+1 和数组末尾出发寻找最接近的三数之和</span><br><span class="line">3. 如果当前三数之和比记录的更接近目标值，更新结果</span><br><span class="line">4. 根据当前和与目标值的大小关系移动左右指针</span><br><span class="line">5. 返回最接近的三数之和</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">threeSumClosest</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        nums.sort() <span class="comment"># 排序</span></span><br><span class="line">        result = <span class="built_in">float</span>(<span class="string">&quot;inf&quot;</span>) <span class="comment"># 初始化最接近的结果</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums) - <span class="number">2</span>):</span><br><span class="line">            left, right = i + <span class="number">1</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> left &lt; right:</span><br><span class="line">                curr_sum = nums[i] + nums[left] + nums[right]</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 更新最接近的结果</span></span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">abs</span>(curr_sum - target) &lt; <span class="built_in">abs</span>(result - target):</span><br><span class="line">                    result = curr_sum</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 根据当前和与目标值的关系调整指针</span></span><br><span class="line">                <span class="keyword">if</span> curr_sum &lt; target:</span><br><span class="line">                    left += <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> curr_sum &gt; target:</span><br><span class="line">                    right -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> curr_sum <span class="comment"># 当前和等于目标值时直接返回</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">threeSumClosest</span>(<span class="params">nums, target</span>) &#123;</span><br><span class="line">        nums.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b); <span class="comment">// 排序</span></span><br><span class="line">        <span class="keyword">let</span> result = <span class="title class_">Infinity</span>; <span class="comment">// 初始化最接近的结果</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.<span class="property">length</span> - <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">let</span> left = i + <span class="number">1</span>, right = nums.<span class="property">length</span> - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">                <span class="keyword">let</span> currSum = nums[i] + nums[left] + nums[right];</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 更新最接近的结果</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="title class_">Math</span>.<span class="title function_">abs</span>(currSum - target) &lt; <span class="title class_">Math</span>.<span class="title function_">abs</span>(result - target))</span><br><span class="line">                    result = currSum;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 根据当前和与目标值的关系调整指针</span></span><br><span class="line">                <span class="keyword">if</span> (currSum &lt; target)</span><br><span class="line">                    left++;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (currSum &gt; target)</span><br><span class="line">                    right--;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">return</span> currSum; <span class="comment">// 当前和等于目标值时直接返回</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h4 id="三数之和"><a href="#三数之和" class="headerlink" title="三数之和"></a>三数之和</h4><blockquote><p><a href="https://leetcode.com/problems/3sum/">Leetcode 15. 3Sum</a></p></blockquote><ul><li>题目: 给定一个包含整数的数组<code>nums</code>，返回所有不重复的三元组<code>[nums[i], nums[j], nums[k]]</code>，使得<code>nums[i] + nums[j] + nums[k] == 0</code>。答案中不能包含重复的三元组</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: nums = [-1, 0, 1, 2, -1, -4]</span><br><span class="line">Output: [[-1, -1, 2], [-1, 0, 1]]</span><br><span class="line">Explanation: </span><br><span class="line">nums[0] + nums[1] + nums[3] = -1 + -1 + 2 = 0</span><br><span class="line">nums[0] + nums[2] + nums[4] = -1 + 0 + 1 = 0</span><br></pre></td></tr></table></figure><ul><li>解法: 排序 + 双指针</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 对数组进行排序，便于去重和使用双指针</span><br><span class="line">2. 遍历数组，固定一个数 nums[i]，然后用双指针从 i+1 和数组末尾出发，寻找和为 -nums[i] 的另外两个数</span><br><span class="line">3. 如果找到和为 0 的三元组，将其加入结果集中，同时移动指针跳过重复值</span><br><span class="line">4. 如果当前和小于 0，左指针右移；如果当前和大于 0，右指针左移</span><br><span class="line">5. 遍历结束返回结果</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">threeSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        nums.sort() <span class="comment"># 对数组进行排序，方便后续去重和双指针处理</span></span><br><span class="line">        result = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums) - <span class="number">2</span>):</span><br><span class="line">            <span class="comment"># 如果当前数和前一个数相同，跳过，避免重复三元组</span></span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i - <span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            left, right = i + <span class="number">1</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> left &lt; right:</span><br><span class="line">                total = nums[i] + nums[left] + nums[right] <span class="comment"># 计算当前三数之和</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> total == <span class="number">0</span>:</span><br><span class="line">                    result.append([nums[i], nums[left], nums[right]])</span><br><span class="line"></span><br><span class="line">                    <span class="comment"># 跳过重复的左指针和右指针值</span></span><br><span class="line">                    <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> nums[left] == nums[left + <span class="number">1</span>]:</span><br><span class="line">                        left += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> nums[right] == nums[right - <span class="number">1</span>]:</span><br><span class="line">                        right -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment"># 移动指针</span></span><br><span class="line">                    left += <span class="number">1</span></span><br><span class="line">                    right -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> total &lt; <span class="number">0</span>: <span class="comment"># 如果当前和小于 0，增加左指针</span></span><br><span class="line">                    left += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>: <span class="comment"># 如果当前和大于 0，减少右指针</span></span><br><span class="line">                    right -= <span class="number">1</span> </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">threeSum</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">        nums.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b); <span class="comment">// 对数组进行排序</span></span><br><span class="line">        <span class="keyword">const</span> result = [];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.<span class="property">length</span> - <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 如果当前数和前一个数相同，跳过，避免重复三元组</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] === nums[i - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">let</span> left = i + <span class="number">1</span>, right = nums.<span class="property">length</span> - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">                <span class="keyword">const</span> total = nums[i] + nums[left] + nums[right];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (total === <span class="number">0</span>) &#123;</span><br><span class="line">                    result.<span class="title function_">push</span>([nums[i], nums[left], nums[right]]);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 跳过重复的左指针和右指针值</span></span><br><span class="line">                    <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[left] === nums[left + <span class="number">1</span>]) left++;</span><br><span class="line">                    <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[right] === nums[right - <span class="number">1</span>]) right--;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 移动指针</span></span><br><span class="line">                    left++;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (total &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    left++; <span class="comment">// 如果当前和小于 0，增加左指针</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    right--;  如果当前和大于 <span class="number">0</span>，减少右指针</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h4 id="四数之和"><a href="#四数之和" class="headerlink" title="四数之和"></a>四数之和</h4><blockquote><p><a href="https://leetcode.com/problems/4sum/">Leetcode 18. 4Sum</a></p></blockquote><ul><li>题目: 给定一个由整数数组<code>nums</code>和一个目标值<code>target</code>，找出所有不重复的四元组<code>[nums[a], nums[b], nums[c], nums[d]]</code>，使得<code>nums[a] + nums[b] + nums[c] + nums[d] == target</code></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: nums = [1,0,-1,0,-2,2], target = 0</span><br><span class="line">Output: [[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]</span><br><span class="line">Explanation: The solution sets are unique and order does not matter</span><br></pre></td></tr></table></figure><ul><li>解法: 排序 + 双指针 + 多层遍历</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 对数组进行排序，以便后续去重和使用双指针</span><br><span class="line">2. 先固定两个数 nums[i] 和 nums[j]，然后使用双指针寻找剩下两个数，使得四数之和等于 target</span><br><span class="line">3. 遍历过程中跳过重复的数值，避免结果中出现重复的四元组</span><br><span class="line">4. 返回所有符合条件的四元组</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fourSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        nums.sort() <span class="comment"># 排序</span></span><br><span class="line">        result = []</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums) - <span class="number">3</span>):</span><br><span class="line">            <span class="comment"># 跳过重复的第一个数</span></span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i - <span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i + <span class="number">1</span>, <span class="built_in">len</span>(nums) - <span class="number">2</span>):</span><br><span class="line">                <span class="comment"># 跳过重复的第二个数</span></span><br><span class="line">                <span class="keyword">if</span> j &gt; i + <span class="number">1</span> <span class="keyword">and</span> nums[j] == nums[j - <span class="number">1</span>]:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                </span><br><span class="line">                left, right = j + <span class="number">1</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> left &lt; right:</span><br><span class="line">                    total = nums[i] + nums[j] + nums[left] + nums[right]</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> total == target:</span><br><span class="line">                        result.append([nums[i], nums[j], nums[left], nums[right]])</span><br><span class="line"></span><br><span class="line">                        <span class="comment"># 跳过重复的左指针和右指针值</span></span><br><span class="line">                        <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> nums[left] == nums[left + <span class="number">1</span>]:</span><br><span class="line">                            left += <span class="number">1</span></span><br><span class="line">                        <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> nums[right] == nums[right - <span class="number">1</span>]:</span><br><span class="line">                            right -= <span class="number">1</span></span><br><span class="line">                        </span><br><span class="line">                        <span class="comment"># 移动指针</span></span><br><span class="line">                        left += <span class="number">1</span></span><br><span class="line">                        right -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">elif</span> total &lt; target:</span><br><span class="line">                        left += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        right -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">fourSum</span>(<span class="params">nums, target</span>) &#123;</span><br><span class="line">        nums.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b); <span class="comment">// 排序</span></span><br><span class="line">        <span class="keyword">const</span> result = [];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.<span class="property">length</span> - <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 跳过重复的第一个数</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] === nums[i - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; nums.<span class="property">length</span> - <span class="number">2</span>; j++) &#123;</span><br><span class="line">                <span class="comment">// 跳过重复的第二个数</span></span><br><span class="line">                <span class="keyword">if</span> (j &gt; i + <span class="number">1</span> &amp;&amp; nums[j] === nums[j - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">let</span> left = j + <span class="number">1</span>, right = nums.<span class="property">length</span> - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">                    <span class="keyword">const</span> total = nums[i] + nums[j] + nums[left] + nums[right];</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (total === target) &#123;</span><br><span class="line">                        result.<span class="title function_">push</span>([nums[i], nums[j], nums[left], nums[right]]);</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 跳过重复的左指针和右指针值</span></span><br><span class="line">                        <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[left] === nums[left + <span class="number">1</span>]) left++;</span><br><span class="line">                        <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[right] === nums[right - <span class="number">1</span>]) right--;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 移动指针</span></span><br><span class="line">                        left++;</span><br><span class="line">                        right--;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (total &lt; target) &#123;</span><br><span class="line">                        left++;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        right--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h4 id="找出数组中的重复数字"><a href="#找出数组中的重复数字" class="headerlink" title="找出数组中的重复数字"></a>找出数组中的重复数字</h4><blockquote><p><a href="https://leetcode.com/problems/find-the-duplicate-number/">Leetcode 287. Find the Duplicate Number</a></p></blockquote><ul><li>题目: 给定一个包含<code>n + 1</code>个整数的数组 nums，其中每个整数都在范围 [1, n] 内，且只有一个重复的数字。找出该重复的数字。注意：不能修改数组内容，并且仅使用常数级别的额外空间</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: nums = [3,1,3,4,2]</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure><ul><li>解法: 快慢指针（<code>Floyd</code>判圈算法）</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 将数组看作链表，nums[i] 指向下一个节点</span><br><span class="line">2. 使用快慢指针找到环的位置：慢指针一次走一步，快指针一次走两步</span><br><span class="line">3. 在环中找到入口，也就是重复的数字</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findDuplicate</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 使用快慢指针</span></span><br><span class="line">        slow, fast = nums[<span class="number">0</span>], nums[nums[<span class="number">0</span>]]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 阶段 1：找到快慢指针相遇点</span></span><br><span class="line">        <span class="keyword">while</span> slow != fast:</span><br><span class="line">            slow = nums[slow]</span><br><span class="line">            fast = nums[nums[fast]]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 阶段 2：找到环的入口，即重复的数字</span></span><br><span class="line">        slow = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> slow != fast:</span><br><span class="line">            slow = nums[slow]</span><br><span class="line">            fast = nums[fast]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> slow</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">findDuplicate</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> slow = nums[<span class="number">0</span>], fast = nums[nums[<span class="number">0</span>]];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 阶段 1：找到快慢指针相遇点</span></span><br><span class="line">        <span class="keyword">while</span> (slow !== fast) &#123;</span><br><span class="line">            slow = nums[slow];</span><br><span class="line">            fast = nums[nums[fast]];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 阶段 2：找到环的入口，即重复的数字</span></span><br><span class="line">        slow = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (slow !== fast) &#123;</span><br><span class="line">            slow = nums[slow];</span><br><span class="line">            fast = nums[fast];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h3 id="Binary-Search"><a href="#Binary-Search" class="headerlink" title="Binary Search"></a><code>Binary Search</code></h3><h4 id="最长递增子序列"><a href="#最长递增子序列" class="headerlink" title="最长递增子序列"></a>最长递增子序列</h4><blockquote><p><a href="https://leetcode.com/problems/longest-increasing-subsequence/">Leetcode 300. Longest Increasing Subsequence</a></p></blockquote><ul><li>题目: 给定一个整数数组<code>nums</code>，找到其中最长严格递增子序列的长度</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: nums = [10,9,2,5,3,7,101,18]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4</span><br></pre></td></tr></table></figure><ul><li>解法: 动态规划 + 二分法优化</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 动态规划：</span><br><span class="line">   定义 dp[i] 表示以 nums[i] 为结尾的最长递增子序列的长度</span><br><span class="line">   状态转移方程：dp[i] = max(dp[i], dp[j] + 1) for all j &lt; i and nums[j] &lt; nums[i]</span><br><span class="line">   时间复杂度为 O(n^2)</span><br><span class="line"></span><br><span class="line">2. 二分法优化：</span><br><span class="line">   维护一个数组 tails，其中 tails[i] 表示长度为 i+1 的递增子序列的末尾最小值</span><br><span class="line">   对每个 nums 中的元素使用二分法更新 tails</span><br><span class="line">   时间复杂度为 O(n log n)</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lengthOfLIS</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 用于存储不同长度递增子序列的最小末尾值</span></span><br><span class="line">        tails = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="comment"># 二分查找，寻找第一个大于等于 num 的位置</span></span><br><span class="line">            left, right = <span class="number">0</span>, <span class="built_in">len</span>(tails)</span><br><span class="line">            <span class="keyword">while</span> left &lt; right:</span><br><span class="line">                mid = (left + right) // <span class="number">2</span></span><br><span class="line">                <span class="keyword">if</span> tails[mid] &lt; num:</span><br><span class="line">                    left = mid + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    right = mid</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 如果 left 等于 tails 长度，说明 num 是一个新的最大值</span></span><br><span class="line">            <span class="keyword">if</span> left == <span class="built_in">len</span>(tails):</span><br><span class="line">                tails.append(num)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                tails[left] = num</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(tails)</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">lengthOfLIS</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> tails = [];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> num <span class="keyword">of</span> nums) &#123;</span><br><span class="line">            <span class="comment">// 找到第一个大于等于 num 的位置</span></span><br><span class="line">            <span class="keyword">let</span> left = <span class="number">0</span>, right = tails.<span class="property">length</span>;</span><br><span class="line">            <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">                <span class="keyword">const</span> mid = <span class="title class_">Math</span>.<span class="title function_">floor</span>((left + right) / <span class="number">2</span>);</span><br><span class="line">                <span class="keyword">if</span> (tails[mid] &lt; num)</span><br><span class="line">                    left = mid + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    right = mid;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (left === tails.<span class="property">length</span>)</span><br><span class="line">                <span class="comment">// 如果 num 比 tails 中的所有值都大，直接添加到末尾</span></span><br><span class="line">                tails.<span class="title function_">push</span>(num);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="comment">// 否则替换位置 left 的值，保持更小的末尾</span></span><br><span class="line">                tails[left] = num;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> tails.<span class="property">length</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h3 id="Tree-树与二叉树"><a href="#Tree-树与二叉树" class="headerlink" title="Tree 树与二叉树"></a><code>Tree</code> 树与二叉树</h3><h4 id="二叉树层序遍历"><a href="#二叉树层序遍历" class="headerlink" title="二叉树层序遍历"></a>二叉树层序遍历</h4><ul><li>实现二叉树的层序遍历（广度优先遍历，<code>BFS</code>）</li><li>从二叉树的根节点开始，按层级顺序逐层访问节点，每层从左到右</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    3  </span><br><span class="line">   / \</span><br><span class="line">  9   20</span><br><span class="line">     /  \</span><br><span class="line">    15   7</span><br><span class="line"></span><br><span class="line">输出: </span><br><span class="line">[</span><br><span class="line">    [3],</span><br><span class="line">    [9, 20],</span><br><span class="line">    [15, 7]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><ul><li>解法: 队列实现<code>BFS</code></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 使用 deque 实现队列，初始包含根节点</span><br><span class="line">2. 遍历每一层：</span><br><span class="line">    - 记录当前层的节点数量（level_size）</span><br><span class="line">    - 弹出队首节点，存储值到当前层结果</span><br><span class="line">    - 将左右子节点加入队列</span><br><span class="line">3. 每层遍历结束后，将当前层结果加入最终结果</span><br><span class="line">4. 队列为空时，遍历完成</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, val=<span class="number">0</span>, left=<span class="literal">None</span>, right=<span class="literal">None</span></span>):</span><br><span class="line">        self.val = val</span><br><span class="line">        self.left = left</span><br><span class="line">        self.right = right</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">levelOrder</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="built_in">list</span>[<span class="built_in">list</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">        queue = deque([root]) <span class="comment"># 初始化队列，包含根节点</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            level_size = <span class="built_in">len</span>(queue) <span class="comment"># 当前层的节点数</span></span><br><span class="line">            current_level = [] <span class="comment"># 用于存储当前层的节点值</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(level_size):</span><br><span class="line">                node = queue.popleft() <span class="comment"># 弹出队首节点</span></span><br><span class="line">                current_level.append(node.val) <span class="comment"># 添加节点值到当前层</span></span><br><span class="line"></span><br><span class="line">                <span class="comment"># 将左右子节点加入队列</span></span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    queue.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    queue.append(node.right)</span><br><span class="line"></span><br><span class="line">            result.append(current_level) <span class="comment"># 将当前层加入结果</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result       </span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">val = <span class="number">0</span>, left = <span class="literal">null</span>, right = <span class="literal">null</span></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">val</span> = val;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">left</span> = left;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">right</span> = right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">levelOrder</span>(<span class="params">root</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> result = [];</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> queue = [root]; <span class="comment">// 初始化队列，包含根节点</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (queue.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> levelSize = queue.<span class="property">length</span>; <span class="comment">// 当前层的节点数</span></span><br><span class="line">            <span class="keyword">const</span> currentLevel = []; <span class="comment">// 用于存储当前层的节点值</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; levelSize; i++) &#123;</span><br><span class="line">                <span class="keyword">const</span> node = queue.<span class="title function_">shift</span>(); <span class="comment">// 弹出队首节点</span></span><br><span class="line">                currentLevel.<span class="title function_">push</span>(node.<span class="property">val</span>); <span class="comment">// 添加节点值到当前层</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 将左右子节点加入队列</span></span><br><span class="line">                <span class="keyword">if</span> (node.<span class="property">left</span>) queue.<span class="title function_">push</span>(node.<span class="property">left</span>);</span><br><span class="line">                <span class="keyword">if</span> (node.<span class="property">right</span>) queue.<span class="title function_">push</span>(node.<span class="property">right</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            result.<span class="title function_">push</span>(currentLevel);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h4 id="树每层的最大值"><a href="#树每层的最大值" class="headerlink" title="树每层的最大值"></a>树每层的最大值</h4><blockquote><p><a href="https://leetcode.com/problems/find-largest-value-in-each-tree-row/">Leetcode 515. Find Largest Value in Each Tree Row</a></p></blockquote><ul><li>题目: 给定一个二叉树，按层遍历树，返回每一行中的最大值</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">      1</span><br><span class="line">     / \</span><br><span class="line">    3   2</span><br><span class="line">   / \    \</span><br><span class="line">  5   3    9</span><br><span class="line"></span><br><span class="line">Output: [1,3,9]</span><br></pre></td></tr></table></figure><ul><li>解法: 广度优先搜索<code>BFS</code></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 使用队列（deque）进行层序遍历（BFS）</span><br><span class="line">2. 遍历每一层时，找出该层节点值的最大值</span><br><span class="line">3. 将每层的最大值添加到结果列表中</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">largestValues</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        </span><br><span class="line">        result = []</span><br><span class="line">        queue = deque([root])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            level_size = <span class="built_in">len</span>(queue)</span><br><span class="line">            max_val = <span class="built_in">float</span>(<span class="string">&quot;-inf&quot;</span>) <span class="comment"># 初始化每层最大值</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(level_size):</span><br><span class="line">                node = queue.popleft() <span class="comment"># 弹出当前层的节点</span></span><br><span class="line">                max_val = <span class="built_in">max</span>(max_val, node.val) <span class="comment"># 更新最大值</span></span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    queue.append(node.left) <span class="comment"># 加入左子节点</span></span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    queue.append(node.right) <span class="comment"># 加入右子节点</span></span><br><span class="line">            </span><br><span class="line">            result.append(max_val) <span class="comment"># 保存每层最大值</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">largestValues</span>(<span class="params">root</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> [];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> result = [];</span><br><span class="line">        <span class="keyword">const</span> queue = [root];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (queue.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> levelSize = queue.<span class="property">length</span>;</span><br><span class="line">            <span class="keyword">let</span> maxVal = -<span class="title class_">Infinity</span>; <span class="comment">// 初始化每层最大值</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; levelSize; i++) &#123;</span><br><span class="line">                <span class="keyword">const</span> node = queue.<span class="title function_">shift</span>(); <span class="comment">// 弹出当前层的节点</span></span><br><span class="line">                maxVal = <span class="title class_">Math</span>.<span class="title function_">max</span>(maxVal, node.<span class="property">val</span>); <span class="comment">// 更新最大值</span></span><br><span class="line">                <span class="keyword">if</span> (node.<span class="property">left</span>) queue.<span class="title function_">push</span>(node.<span class="property">left</span>); <span class="comment">// 加入左子节点</span></span><br><span class="line">                <span class="keyword">if</span> (node.<span class="property">right</span>) queue.<span class="title function_">push</span>(node.<span class="property">right</span>); <span class="comment">// 加入右子节点</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            result.<span class="title function_">push</span>(maxVal); <span class="comment">// 保存每层最大值</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h4 id="验证二叉搜索树"><a href="#验证二叉搜索树" class="headerlink" title="验证二叉搜索树"></a>验证二叉搜索树</h4><blockquote><p><a href="https://leetcode.com/problems/validate-binary-search-tree/">Leetcode 98. Validate Binary Search Tree</a></p></blockquote><ul><li>题目: 验证一棵二叉树是否为二叉搜索树（<code>BST</code>）</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">二叉搜索树的性质:</span><br><span class="line">1. 节点的左子树只包含比当前节点值小的节点</span><br><span class="line">2. 节点的右子树只包含比当前节点值大的节点</span><br><span class="line">3. 左右子树也必须是二叉搜索树</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: root = [2,1,3]</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><ul><li>解法: 递归验证上下界</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 使用递归检查每个节点的值是否满足二叉搜索树的性质:</span><br><span class="line">   节点的值应在一个范围内 `(low, high)`</span><br><span class="line">2. 初始范围是 `(-inf, inf)`</span><br><span class="line">3. 左子树的值范围: `(low, node.val)`</span><br><span class="line">   右子树的值范围: `(node.val, high)`</span><br><span class="line">4. 递归检查子树是否满足条件</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isValidBST</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="comment"># 递归函数，检查节点是否在 (low, high) 范围内</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">validate</span>(<span class="params">node, low, high</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node: <span class="comment"># 空节点是合法的</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="comment"># 当前节点值必须在范围内</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> (low &lt; node.val &lt; high):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">return</span> validate(node.left, low, node.val) <span class="keyword">and</span> validate(node.right, node.val, high)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 初始范围为 (-inf, inf)</span></span><br><span class="line">        <span class="keyword">return</span> validate(root, <span class="built_in">float</span>(<span class="string">&quot;-inf&quot;</span>), <span class="built_in">float</span>(<span class="string">&quot;inf&quot;</span>))</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">isValidBST</span>(<span class="params">root</span>) &#123;</span><br><span class="line">        <span class="keyword">function</span> <span class="title function_">validate</span>(<span class="params">node, low, high</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!node) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 空节点合法</span></span><br><span class="line">            <span class="keyword">if</span> (node.<span class="property">val</span> &lt;= low || node.<span class="property">val</span> &gt;= high) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 不在范围内</span></span><br><span class="line">            <span class="comment">// 检查左右子树</span></span><br><span class="line">            <span class="keyword">return</span> <span class="title function_">validate</span>(node.<span class="property">left</span>, low, node.<span class="property">val</span>) &amp;&amp; <span class="title function_">validate</span>(node.<span class="property">right</span>, node.<span class="property">val</span>, high);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始范围 (-Infinity, Infinity)</span></span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">validate</span>(root, -<span class="title class_">Infinity</span>, <span class="title class_">Infinity</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h4 id="二叉树最大差值"><a href="#二叉树最大差值" class="headerlink" title="二叉树最大差值"></a>二叉树最大差值</h4><blockquote><p><a href="https://leetcode.com/problems/maximum-difference-between-node-and-ancestor/">Leetcode 1026. Maximum Difference Between Node and Ancestor</a></p></blockquote><ul><li>题目: 找到二叉树中任意节点与其祖先节点值之间的最大差值<ul><li>祖先节点: 从根节点到当前节点路径上的任意节点</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: root = [8,3,10,1,6,null,14,null,null,4,7,13]</span><br><span class="line">Output: 7</span><br><span class="line"></span><br><span class="line">差值最大的一对节点是: 8 和 1，差值为 7</span><br></pre></td></tr></table></figure><ul><li>解法: 深度优先搜索（<code>DFS</code>）</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 使用递归（DFS）遍历二叉树</span><br><span class="line">2. 在递归过程中维护当前路径上的最小值和最大值</span><br><span class="line">3. 每到一个节点</span><br><span class="line">    - 更新路径的最小值和最大值</span><br><span class="line">    - 计算当前节点值与路径最小值或最大值的差值</span><br><span class="line">4. 遍历整棵树，返回最大差值</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxAncestorDiff</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">maxDiff</span>(<span class="params">node, curr_min, curr_max</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node: <span class="comment"># 如果节点为空，返回当前差值</span></span><br><span class="line">                <span class="keyword">return</span> curr_max - curr_min</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 更新当前路径的最小值和最大值</span></span><br><span class="line">            curr_min = <span class="built_in">min</span>(curr_min, node.val)</span><br><span class="line">            curr_max = <span class="built_in">max</span>(curr_max, node.val)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 递归左子树和右子树，计算最大差值</span></span><br><span class="line">            left_diff = maxDiff(node.left, curr_min, curr_max)</span><br><span class="line">            right_diff = maxDiff(node.right, curr_min, curr_max)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 返回左右子树中差值的最大值</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">max</span>(left_diff, right_diff)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 从根节点开始，初始最小值和最大值为根节点的值</span></span><br><span class="line">        <span class="keyword">return</span> maxDiff(root, root.val, root.val)</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">maxAncestorDiff</span>(<span class="params">root</span>) &#123;</span><br><span class="line">        <span class="keyword">function</span> <span class="title function_">maxDiff</span>(<span class="params">node, currMin, currMax</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!node) <span class="keyword">return</span> currMax - currMin; <span class="comment">// 返回当前差值</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 更新路径中的最小值和最大值</span></span><br><span class="line">            currMin = <span class="title class_">Math</span>.<span class="title function_">min</span>(currMin, node.<span class="property">val</span>);</span><br><span class="line">            currMax = <span class="title class_">Math</span>.<span class="title function_">max</span>(currMax, node.<span class="property">val</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 递归左右子树，计算最大差值</span></span><br><span class="line">            <span class="keyword">const</span> leftDiff = <span class="title function_">maxDiff</span>(node.<span class="property">left</span>, currMin, currMax);</span><br><span class="line">            <span class="keyword">const</span> rightDiff = <span class="title function_">maxDiff</span>(node.<span class="property">right</span>, currMin, currMax);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 返回左右子树中差值的最大值</span></span><br><span class="line">            <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">max</span>(leftDiff, rightDiff);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始最小值和最大值为根节点的值</span></span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">maxDiff</span>(root, root.<span class="property">val</span>, root.<span class="property">val</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h4 id="不同二叉搜索树的数量"><a href="#不同二叉搜索树的数量" class="headerlink" title="不同二叉搜索树的数量"></a>不同二叉搜索树的数量</h4><blockquote><p><a href="https://leetcode.com/problems/unique-binary-search-trees/">Leetcode 96. Unique Binary Search Trees</a></p></blockquote><ul><li>题目: 给定一个整数<code>n</code>，表示从<code>1</code>到<code>n</code>的节点，计算可以形成的不同二叉搜索树（<code>BST</code>）的数量</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: n = 3</span><br><span class="line">Output: 5</span><br><span class="line"></span><br><span class="line">   1         3     3      2      1</span><br><span class="line">    \       /     /      / \      \</span><br><span class="line">     3     2     1      1   3      2</span><br><span class="line">    /     /       \                 \</span><br><span class="line">   2     1         2                 3</span><br></pre></td></tr></table></figure><ul><li>解法: 动态规划 (卡特兰数公式)</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 定义 G[i] 表示由 i 个节点可以构成的不同二叉搜索树的数量</span><br><span class="line">2. 初始条件</span><br><span class="line">    - G[0] = 1（空树有 1 种情况）</span><br><span class="line">    - G[1] = 1（只有一个节点也只有 1 种情况）</span><br><span class="line">3. 递推公式</span><br><span class="line">    - G[i] = Σ G[j-1] * G[i-j]</span><br><span class="line">    - 即选择第 j 个节点为根时</span><br><span class="line">        - 左子树有 j-1 个节点，数量为 G[j-1]</span><br><span class="line">        - 右子树有 i-j 个节点，数量为 G[i-j]</span><br><span class="line">    - 对所有可能的根节点 j 求和</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">numTrees</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># G[i] 表示 i 个节点的不同二叉搜索树数量</span></span><br><span class="line">        G = [<span class="number">0</span>] * (n + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 初始条件</span></span><br><span class="line">        G[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        G[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 动态规划计算 G[2] 到 G[n]</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, i + <span class="number">1</span>):</span><br><span class="line">                G[i] += G[j - <span class="number">1</span>] * G[i - j]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> G[n]</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">numTrees</span>(<span class="params">n</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> G = <span class="keyword">new</span> <span class="title class_">Array</span>(n + <span class="number">1</span>).<span class="title function_">fill</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始条件</span></span><br><span class="line">        G[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        G[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 动态规划计算 G[2] 到 G[n]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>; j &lt;= i; j++) &#123;</span><br><span class="line">                G[i] += G[j - <span class="number">1</span>] * G[i - j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> G[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h4 id="检查二叉树是否平衡"><a href="#检查二叉树是否平衡" class="headerlink" title="检查二叉树是否平衡"></a>检查二叉树是否平衡</h4><blockquote><p><a href="https://leetcode.com/problems/balanced-binary-tree/">Leetcode 110. Balanced Binary Tree</a></p></blockquote><ul><li>题目: 给定一个二叉树，判断它是否是高度平衡的<ul><li>平衡二叉树的定义是: 二叉树的任意节点的左右子树高度差不超过<code>1</code></li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: root = [3,9,20,null,null,15,7]</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><ul><li>解法: 深度优先搜索 (<code>DFS</code>)</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 使用递归函数 dfs(node)</span><br><span class="line">   - 如果节点为空，返回平衡状态 True 和高度 0</span><br><span class="line">   - 递归检查左右子树，计算它们的平衡状态和高度</span><br><span class="line">2. 当前节点是否平衡</span><br><span class="line">   - 左右子树都平衡</span><br><span class="line">   - 左右子树高度差不超过 1</span><br><span class="line">3. 返回当前节点的平衡状态和高度</span><br><span class="line">4. 检查根节点的平衡状态</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isBalanced</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">node</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span>, <span class="number">0</span> <span class="comment"># [是否平衡, 高度]</span></span><br><span class="line">            </span><br><span class="line">            left_balanced, left_height = dfs(node.left)</span><br><span class="line">            right_balanced, right_height = dfs(node.right)</span><br><span class="line"></span><br><span class="line">            balanced = left_balanced <span class="keyword">and</span> right_balanced <span class="keyword">and</span> <span class="built_in">abs</span>(left_height - right_height) &lt;= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            height = <span class="built_in">max</span>(left_height, right_height) + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> balanced, height</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dfs(root)[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">isBalanced</span>(<span class="params">root</span>) &#123;</span><br><span class="line">        <span class="keyword">function</span> <span class="title function_">dfs</span>(<span class="params">node</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!node) <span class="keyword">return</span> [<span class="literal">true</span>, <span class="number">0</span>]; <span class="comment">// [是否平衡, 高度]</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">const</span> [leftBalanced, leftHeight] = <span class="title function_">dfs</span>(node.<span class="property">left</span>);</span><br><span class="line">            <span class="keyword">const</span> [rightBalanced, rightHeight] = <span class="title function_">dfs</span>(node.<span class="property">right</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> balanced = leftBalanced &amp;&amp; rightBalanced &amp;&amp; <span class="title class_">Math</span>.<span class="title function_">abs</span>(leftHeight - rightHeight) &lt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> height = <span class="title class_">Math</span>.<span class="title function_">max</span>(leftHeight, rightHeight) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> [balanced, height];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">dfs</span>(root)[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h4 id="二叉搜索树第k小的节点"><a href="#二叉搜索树第k小的节点" class="headerlink" title="二叉搜索树第k小的节点"></a>二叉搜索树第<code>k</code>小的节点</h4><blockquote><p><a href="https://leetcode.com/problems/kth-smallest-element-in-a-bst/">Leetcode 230. Kth Smallest Element in a BST</a></p></blockquote><ul><li>题目: 给定一棵二叉搜索树的根节点<code>root</code>，以及一个整数<code>k</code>，请返回该二叉搜索树中第<code>k</code>小的节点值</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: root = [3,1,4,null,2], k = 1</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure><ul><li>解法: 中序遍历 (<code>In-order Traversal</code>)</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 中序遍历二叉搜索树，按升序访问节点值</span><br><span class="line">2. 计数每访问一个节点，当计数等于 k 时，返回该节点值</span><br><span class="line">3. 使用递归实现中序遍历</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">kthSmallest</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        count = <span class="number">0</span> <span class="comment"># 计数器</span></span><br><span class="line">        result = <span class="literal">None</span> <span class="comment"># 结果存储</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">inorder</span>(<span class="params">node</span>):</span><br><span class="line">            <span class="keyword">nonlocal</span> count, result</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 遍历左子树</span></span><br><span class="line">            inorder(node.left)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 处理当前节点</span></span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> count == k:</span><br><span class="line">                result = node.val</span><br><span class="line">                <span class="keyword">return</span> </span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 遍历右子树</span></span><br><span class="line">            inorder(node.right)</span><br><span class="line"></span><br><span class="line">        inorder(root)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">kthSmallest</span>(<span class="params">root, k</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> count = <span class="number">0</span>; <span class="comment">// 计数器</span></span><br><span class="line">        <span class="keyword">let</span> result = <span class="literal">null</span>; <span class="comment">// 结果存储</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">function</span> <span class="title function_">inorder</span>(<span class="params">node</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!node) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 遍历左子树</span></span><br><span class="line">            <span class="title function_">inorder</span>(node.<span class="property">left</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 处理当前节点</span></span><br><span class="line">            count += <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (count === k) &#123;</span><br><span class="line">                result = node.<span class="property">val</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 遍历右子树</span></span><br><span class="line">            <span class="title function_">inorder</span>(node.<span class="property">right</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="title function_">inorder</span>(root);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h4 id="二叉树展开为链表"><a href="#二叉树展开为链表" class="headerlink" title="二叉树展开为链表"></a>二叉树展开为链表</h4><blockquote><p><a href="https://leetcode.com/problems/flatten-binary-tree-to-linked-list/">Leetcode 114. Flatten Binary Tree to Linked List</a></p></blockquote><ul><li>题目: 将二叉树展开为链表，要求“就地”修改树的结构，使其变为一个单链表形式，顺序与前序遍历一致</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: root = [1,2,5,3,4,null,6]</span><br><span class="line">Output: [1,null,2,null,3,null,4,null,5,null,6]</span><br></pre></td></tr></table></figure><ul><li>解法: 递归</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 递归处理左子树和右子树，将它们分别扁平化</span><br><span class="line">2. 保存右子树，并将左子树移到右子树的位置，将左子树置为 None</span><br><span class="line">3. 找到左子树的最右节点，将保存的右子树接到这个节点上</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">flatten</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 递归处理左子树和右子树</span></span><br><span class="line">        self.flatten(root.left)</span><br><span class="line">        self.flatten(root.right)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 保存右子树</span></span><br><span class="line">        right_subtree = root.right</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 将左子树移动到右子树的位置</span></span><br><span class="line">        root.right = root.left</span><br><span class="line">        root.left = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 找到左子树的最右节点</span></span><br><span class="line">        curr = root</span><br><span class="line">        <span class="keyword">while</span> curr.right:</span><br><span class="line">            curr = curr.right</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 将保存的右子树接到最右节点</span></span><br><span class="line">        curr.right = right_subtree</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">flatten</span>(<span class="params">root</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 递归处理左子树和右子树</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">flatten</span>(root.<span class="property">left</span>);</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">flatten</span>(root.<span class="property">right</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 保存右子树</span></span><br><span class="line">        <span class="keyword">const</span> rightSubtree = root.<span class="property">right</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将左子树移动到右子树的位置</span></span><br><span class="line">        root.<span class="property">right</span> = root.<span class="property">left</span>;</span><br><span class="line">        root.<span class="property">left</span> = <span class="literal">null</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 找到左子树的最右节点</span></span><br><span class="line">        <span class="keyword">let</span> curr = root;</span><br><span class="line">        <span class="keyword">while</span> (curr.<span class="property">right</span>)</span><br><span class="line">            curr = curr.<span class="property">right</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将保存的右子树接到最右节点</span></span><br><span class="line">        curr.<span class="property">right</span> = rightSubtree;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h4 id="二叉搜索树的最近公共祖先"><a href="#二叉搜索树的最近公共祖先" class="headerlink" title="二叉搜索树的最近公共祖先"></a>二叉搜索树的最近公共祖先</h4><blockquote><p><a href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/">Leetcode 235. Lowest Common Ancestor of a Binary Search Tree</a></p></blockquote><ul><li>题目: 在一个二叉搜索树（<code>BST</code>）中，给定两个节点<code>p</code>和<code>q</code>，找到它们的最近公共祖先（<code>LCA</code>）</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: root = [5,3,8,1,4,7,9,null,2], p = 3, q = 8</span><br><span class="line">Output: 5</span><br><span class="line">Explanation: 节点 5 是节点 3 和 8 的最近公共祖先</span><br></pre></td></tr></table></figure><ul><li>解法: 利用二叉搜索树的性质</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 从根节点开始遍历</span><br><span class="line">2. 如果 p 和 q 的值都小于当前节点值，则往左子树继续查找</span><br><span class="line">3. 如果 p 和 q 的值都大于当前节点值，则往右子树继续查找</span><br><span class="line">4. 如果 p 和 q 的值分别位于当前节点的两侧，或者当前节点值等于其中一个节点值，则当前节点为最近公共祖先</span><br></pre></td></tr></table></figure><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">Python</button></li><li class="tab"><button type="button" data-href="#test-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lowestCommonAncestor</span>(<span class="params">self, root: <span class="string">&#x27;TreeNode&#x27;</span>, p: <span class="string">&#x27;TreeNode&#x27;</span>, q: <span class="string">&#x27;TreeNode&#x27;</span></span>) -&gt; <span class="string">&#x27;TreeNode&#x27;</span>:</span><br><span class="line">        <span class="keyword">while</span> root:</span><br><span class="line">            <span class="keyword">if</span> root.val &gt; p.val <span class="keyword">and</span> root.val &gt; q.val:</span><br><span class="line">                root = root.left <span class="comment"># p 和 q 都在左子树</span></span><br><span class="line">            <span class="keyword">elif</span> root.val &lt; p.val <span class="keyword">and</span> root.val &lt; q.val:</span><br><span class="line">                root = root.right <span class="comment"># p 和 q 都在右子树</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> root <span class="comment"># 当前节点是最近公共祖先</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">lowestCommonAncestor</span>(<span class="params">root, p, q</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (root) &#123;</span><br><span class="line">            <span class="keyword">if</span> (root.<span class="property">val</span> &gt; p.<span class="property">val</span> &amp;&amp; root.<span class="property">val</span> &gt; q.<span class="property">val</span>)</span><br><span class="line">                root = root.<span class="property">left</span>; <span class="comment">// p 和 q 都在左子树</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (root.<span class="property">val</span> &lt; p.<span class="property">val</span> &amp;&amp; root.<span class="property">val</span> &lt; q.<span class="property">val</span>)</span><br><span class="line">                root = root.<span class="property">right</span>; <span class="comment">// p 和 q 都在右子树</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> root; <span class="comment">// 当前节点是最近公共祖先</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h4 id="对称二叉树"><a href="#对称二叉树" class="headerlink" title="对称二叉树"></a>对称二叉树</h4><blockquote><p><a href="https://leetcode.com/problems/symmetric-tree/">Leetcode 101. Symmetric Tree</a></p></blockquote><ul><li>题目: 判断给定的二叉树是否是对称的。如果一棵树的左子树和右子树是镜像对称的，则这棵树是对称</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: root = [1,2,2,3,4,4,3]</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><ul><li>解法: 递归</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 如果树为空，返回 True</span><br><span class="line">2. 定义一个辅助函数 isMirror，判断两个节点是否对称</span><br><span class="line">   - 如果两个节点都为空，返回 True</span><br><span class="line">   - 如果只有一个节点为空，返回 False</span><br><span class="line">   - 判断两个节点的值是否相等，并递归判断它们的左右子节点是否对称</span><br><span class="line">3. 调用 isMirror(root.left, root.right)</span><br></pre></td></tr></table></figure><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">Python</button></li><li class="tab"><button type="button" data-href="#test-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isSymmetric</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">isMirror</span>(<span class="params">t1, t2</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> t1 <span class="keyword">and</span> <span class="keyword">not</span> t2:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> t1 <span class="keyword">or</span> <span class="keyword">not</span> t2:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">return</span> t1.val == t2.val <span class="keyword">and</span> isMirror(t1.right, t2.left) <span class="keyword">and</span> isMirror(t1.left, t2.right)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> isMirror(root, root)</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">isSymmetric</span>(<span class="params">root</span>) &#123;</span><br><span class="line">        <span class="keyword">function</span> <span class="title function_">isMirror</span>(<span class="params">t1, t2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!t1 &amp;&amp; !t2) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (!t1 || !t2) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> t1.<span class="property">val</span> === t2.<span class="property">val</span> &amp;&amp; <span class="title function_">isMirror</span>(t1.<span class="property">right</span>, t2.<span class="property">left</span>) &amp;&amp; <span class="title function_">isMirror</span>(t1.<span class="property">left</span>, t2.<span class="property">right</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">isMirror</span>(root, root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h4 id="存在路径总和"><a href="#存在路径总和" class="headerlink" title="存在路径总和"></a>存在路径总和</h4><blockquote><p><a href="https://leetcode.com/problems/path-sum/">Leetcode 112. Path Sum</a></p></blockquote><ul><li>题目: 给定一个二叉树和一个目标和，判断树中是否存在从根节点到叶子节点的路径，使得路径上的所有节点值相加等于目标和</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22</span><br><span class="line">Output: true</span><br><span class="line">Explanation: The path 5 → 4 → 11 → 2 has a sum of 22</span><br></pre></td></tr></table></figure><ul><li>解法: 深度优先搜索</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 从根节点出发，递归地检查左右子树</span><br><span class="line">2. 在每次递归中，将目标值减去当前节点的值</span><br><span class="line">3. 当到达叶子节点时，检查剩余目标值是否为 0</span><br><span class="line">4. 如果找到一条路径符合条件，则返回 True；否则继续搜索</span><br></pre></td></tr></table></figure><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">Python</button></li><li class="tab"><button type="button" data-href="#test-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hasPathSum</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], targetSum: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 减去当前节点值</span></span><br><span class="line">        targetSum -= root.val</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 检查是否是叶子节点并且目标值为</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right:</span><br><span class="line">            <span class="keyword">return</span> targetSum == <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 递归检查左右子树</span></span><br><span class="line">        <span class="keyword">return</span> self.hasPathSum(root.left, targetSum) <span class="keyword">or</span> self.hasPathSum(root.right, targetSum)</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">hasPathSum</span>(<span class="params">root, targetSum</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 减去当前节点值</span></span><br><span class="line">        targetSum -= root.<span class="property">val</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查是否是叶子节点并且目标值为0</span></span><br><span class="line">        <span class="keyword">if</span> (!root.<span class="property">left</span> &amp;&amp; !root.<span class="property">right</span>)</span><br><span class="line">            <span class="keyword">return</span> targetSum === <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 递归检查左右子树</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">hasPathSum</span>(root.<span class="property">left</span>, targetSum) || <span class="variable language_">this</span>.<span class="title function_">hasPathSum</span>(root.<span class="property">right</span>, targetSum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h4 id="所有路径总和"><a href="#所有路径总和" class="headerlink" title="所有路径总和"></a>所有路径总和</h4><blockquote><p><a href="https://leetcode.com/problems/path-sum-ii/">Leetcode 113. Path Sum II</a></p></blockquote><ul><li>题目: 给定一个二叉树和一个目标和，返回所有从根节点到叶子节点的路径，使得路径上的节点值之和等于目标和</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22</span><br><span class="line">Output: [[5,4,11,2],[5,8,4,5]]</span><br><span class="line">Explanation: The paths are:</span><br><span class="line">5 → 4 → 11 → 2</span><br><span class="line">5 → 8 → 4 → 5</span><br></pre></td></tr></table></figure><ul><li>解法: 深度优先搜索 + 回溯</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 使用递归深度优先搜索（DFS）遍历二叉树</span><br><span class="line">2. 在路径上记录当前节点值，减去当前节点值更新目标和</span><br><span class="line">3. 当到达叶子节点且目标和为 0 时，将当前路径加入结果</span><br><span class="line">4. 回溯时移除当前节点值，返回上一层递归继续搜索</span><br></pre></td></tr></table></figure><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">Python</button></li><li class="tab"><button type="button" data-href="#test-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pathSum</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], targetSum: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        result = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">node, current_path, remaining_sum</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 添加当前节点值到路径</span></span><br><span class="line">            current_path.append(node.val)</span><br><span class="line">            remaining_sum -= node.val</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 如果是叶子节点且目标和为0，保存路径</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node.left <span class="keyword">and</span> <span class="keyword">not</span> node.right <span class="keyword">and</span> remaining_sum == <span class="number">0</span>:</span><br><span class="line">                result.append(<span class="built_in">list</span>(current_path))</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 递归遍历左右子树</span></span><br><span class="line">            dfs(node.left, current_path, remaining_sum)</span><br><span class="line">            dfs(node.right, current_path, remaining_sum)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 回溯</span></span><br><span class="line">            current_path.pop()</span><br><span class="line">        </span><br><span class="line">        dfs(root, [], targetSum)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">pathSum</span>(<span class="params">root, targetSum</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> result = [];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">function</span> <span class="title function_">dfs</span>(<span class="params">node, currentPath, remainingSum</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!node) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 添加当前节点值到路径</span></span><br><span class="line">            currentPath.<span class="title function_">push</span>(node.<span class="property">val</span>);</span><br><span class="line">            remainingSum -= node.<span class="property">val</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果是叶子节点且目标和为0，保存路径</span></span><br><span class="line">            <span class="keyword">if</span> (!node.<span class="property">left</span> &amp;&amp; !node.<span class="property">right</span> &amp;&amp; remainingSum === <span class="number">0</span>)</span><br><span class="line">                result.<span class="title function_">push</span>([...currentPath]);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 递归遍历左右子树</span></span><br><span class="line">            <span class="title function_">dfs</span>(node.<span class="property">left</span>, currentPath, remainingSum);</span><br><span class="line">            <span class="title function_">dfs</span>(node.<span class="property">right</span>, currentPath, remainingSum);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 回溯</span></span><br><span class="line">            currentPath.<span class="title function_">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="title function_">dfs</span>(root, [], targetSum);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h3 id="Matrix-矩阵"><a href="#Matrix-矩阵" class="headerlink" title="Matrix 矩阵"></a><code>Matrix</code> 矩阵</h3><h4 id="螺旋矩阵"><a href="#螺旋矩阵" class="headerlink" title="螺旋矩阵"></a>螺旋矩阵</h4><blockquote><p><a href="https://leetcode.com/problems/spiral-matrix/">Leetcode 54. Spiral Matrix</a></p></blockquote><ul><li>题目: 按照螺旋顺序输出矩阵中的所有元素</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: matrix = [[1,2,3],[4,5,6],[7,8,9]]</span><br><span class="line">Output: [1,2,3,6,9,8,7,4,5]</span><br></pre></td></tr></table></figure><ul><li>解法: 逐层遍历</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 初始化矩阵的边界</span><br><span class="line">    - 上边界 top，初始为 0</span><br><span class="line">    - 下边界 bottom，初始为矩阵的行数 - 1</span><br><span class="line">    - 左边界 left，初始为 0</span><br><span class="line">    - 右边界 right，初始为矩阵的列数 - 1</span><br><span class="line">2. 按照螺旋顺序</span><br><span class="line">    - 从左到右遍历最上面一行</span><br><span class="line">    - 从上到下遍历最右边一列</span><br><span class="line">    - 从右到左遍历最下面一行（如果还有剩余行）</span><br><span class="line">    - 从下到上遍历最左边一列（如果还有剩余列）</span><br><span class="line">3. 每遍历一层后缩小边界，直到遍历完整个矩阵</span><br></pre></td></tr></table></figure><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">Python</button></li><li class="tab"><button type="button" data-href="#test-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">spiralOrder</span>(<span class="params">self, matrix: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        top, bottom = <span class="number">0</span>, <span class="built_in">len</span>(matrix) - <span class="number">1</span></span><br><span class="line">        left, right = <span class="number">0</span>, <span class="built_in">len</span>(matrix[<span class="number">0</span>]) - <span class="number">1</span></span><br><span class="line">        result = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> top &lt;= bottom <span class="keyword">and</span> left &lt;= right:</span><br><span class="line">            <span class="comment"># 从左到右遍历最上面一行</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(left, right + <span class="number">1</span>):</span><br><span class="line">                result.append(matrix[top][i])</span><br><span class="line">            top += <span class="number">1</span>  <span class="comment"># 上边界向下移动</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 从上到下遍历最右边一列</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(top, bottom + <span class="number">1</span>):</span><br><span class="line">                result.append(matrix[i][right])</span><br><span class="line">            right -= <span class="number">1</span>  <span class="comment"># 右边界向左移动</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> top &lt;= bottom:</span><br><span class="line">                <span class="comment"># 从右到左遍历最下面一行</span></span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(right, left - <span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                    result.append(matrix[bottom][i])</span><br><span class="line">                bottom -= <span class="number">1</span>  <span class="comment"># 下边界向上移动</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> left &lt;= right:</span><br><span class="line">                <span class="comment"># 从下到上遍历最左边一列</span></span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(bottom, top - <span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                    result.append(matrix[i][left])</span><br><span class="line">                left += <span class="number">1</span>  <span class="comment"># 左边界向右移动</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">spiralOrder</span>(<span class="params">matrix</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> top = <span class="number">0</span>, bottom = matrix.<span class="property">length</span> - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">let</span> left = <span class="number">0</span>, right = matrix[<span class="number">0</span>].<span class="property">length</span> - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">let</span> result = [];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> ((top &lt;= bottom) &amp;&amp; (left &lt;= right)) &#123;</span><br><span class="line">            <span class="comment">// 从左到右遍历最上面一行</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = left; i &lt; right + <span class="number">1</span>; i++)</span><br><span class="line">                result.<span class="title function_">push</span>(matrix[top][i]);</span><br><span class="line">            top += <span class="number">1</span>; <span class="comment">// 上边界向下移动</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 从上到下遍历最右边一列</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> j = top; j &lt; bottom + <span class="number">1</span>; j++)</span><br><span class="line">                result.<span class="title function_">push</span>(matrix[j][right]);</span><br><span class="line">            right -= <span class="number">1</span>; <span class="comment">// 右边界向左移动</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (top &lt;= bottom) &#123;</span><br><span class="line">                <span class="comment">// 从右到左遍历最下面一行</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">let</span> i = right; i &gt; left - <span class="number">1</span>; i--)</span><br><span class="line">                    result.<span class="title function_">push</span>(matrix[bottom][i]);</span><br><span class="line">                bottom -= <span class="number">1</span>; <span class="comment">// 下边界向上移动</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (left &lt;= right) &#123;</span><br><span class="line">                <span class="comment">// 从下到上遍历最左边一列</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">let</span> j = bottom; j &gt; top - <span class="number">1</span>; j--)</span><br><span class="line">                    result.<span class="title function_">push</span>(matrix[j][left]);</span><br><span class="line">                left += <span class="number">1</span>; <span class="comment">// 左边界向右移动</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h4 id="有效数独"><a href="#有效数独" class="headerlink" title="有效数独"></a>有效数独</h4><blockquote><p><a href="https://leetcode.com/problems/valid-sudoku/">Leetcode 36. Valid Sudoku</a></p></blockquote><ul><li>题目: 给定一个<code>9x9</code>的数独棋盘，验证该棋盘是否有效<ul><li>每行数字不能重复</li><li>每列数字不能重复</li><li>每个<code>3x3</code>方块中的数字不能重复</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: board = </span><br><span class="line">[[&quot;5&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;]</span><br><span class="line">,[&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;]</span><br><span class="line">,[&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;]</span><br><span class="line">,[&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;]</span><br><span class="line">,[&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;]</span><br><span class="line">,[&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;]</span><br><span class="line">,[&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;]</span><br><span class="line">,[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;]</span><br><span class="line">,[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]]</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><ul><li>解法: 哈希表</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 使用三个哈希表分别记录</span><br><span class="line">    - 每行中已出现的数字</span><br><span class="line">    - 每列中已出现的数字</span><br><span class="line">    - 每个 3x3 方块中已出现的数字</span><br><span class="line">2. 遍历整个棋盘</span><br><span class="line">    - 如果遇到 .，跳过</span><br><span class="line">    - 检查数字是否已存在于当前行、列或对应的 3x3 方块中</span><br><span class="line">    - 如果存在，返回 False</span><br><span class="line">    - 如果不存在，添加到相应的哈希表中</span><br><span class="line">3. 遍历结束后，若未发现冲突，返回 True</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isValidSudoku</span>(<span class="params">board: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="comment"># 哈希表记录每行、每列和每个 3x3 方块的数字</span></span><br><span class="line">        rows = collections.defaultdict(<span class="built_in">set</span>)</span><br><span class="line">        cols = collections.defaultdict(<span class="built_in">set</span>)</span><br><span class="line">        squares = collections.defaultdict(<span class="built_in">set</span>) <span class="comment"># 键为 (r//3, c//3)</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> r <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">                num = board[r][c]</span><br><span class="line">                <span class="keyword">if</span> num == <span class="string">&quot;.&quot;</span>:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">                <span class="comment"># 检查当前数字是否已存在</span></span><br><span class="line">                <span class="keyword">if</span> num <span class="keyword">in</span> rows[r] <span class="keyword">or</span> num <span class="keyword">in</span> cols[c] <span class="keyword">or</span> num <span class="keyword">in</span> squares[(r // <span class="number">3</span>, c // <span class="number">3</span>)]:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">                <span class="comment"># 添加数字到对应哈希表</span></span><br><span class="line">                rows[r].add(num)</span><br><span class="line">                cols[c].add(num)</span><br><span class="line">                squares[((r // <span class="number">3</span>, c // <span class="number">3</span>))].add(num)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">isValidSudoku</span>(<span class="params">board</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> rows = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">9</span>).<span class="title function_">fill</span>(<span class="number">0</span>).<span class="title function_">map</span>(<span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="title class_">Set</span>());</span><br><span class="line">        <span class="keyword">const</span> cols = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">9</span>).<span class="title function_">fill</span>(<span class="number">0</span>).<span class="title function_">map</span>(<span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="title class_">Set</span>());</span><br><span class="line">        <span class="keyword">const</span> squares = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">9</span>).<span class="title function_">fill</span>(<span class="number">0</span>).<span class="title function_">map</span>(<span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="title class_">Set</span>());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> r = <span class="number">0</span>; r &lt; <span class="number">9</span>; r++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> c = <span class="number">0</span>; c &lt; <span class="number">9</span>; c++) &#123;</span><br><span class="line">                <span class="keyword">const</span> num = board[r][c];</span><br><span class="line">                <span class="keyword">if</span> (num === <span class="string">&quot;.&quot;</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">const</span> squareIndex = <span class="title class_">Math</span>.<span class="title function_">floor</span>(r / <span class="number">3</span>) * <span class="number">3</span> + <span class="title class_">Math</span>.<span class="title function_">floor</span>(c / <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (rows[r].<span class="title function_">has</span>(num) || cols[c].<span class="title function_">has</span>(num) || squares[squareIndex].<span class="title function_">has</span>(num))</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">                rows[r].<span class="title function_">add</span>(num);</span><br><span class="line">                cols[c].<span class="title function_">add</span>(num);</span><br><span class="line">                squares[squareIndex].<span class="title function_">add</span>(num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h4 id="最大岛屿面积"><a href="#最大岛屿面积" class="headerlink" title="最大岛屿面积"></a>最大岛屿面积</h4><blockquote><p><a href="https://leetcode.com/problems/max-area-of-island/">Leetcode 695. Max Area of Island</a></p></blockquote><ul><li>题目: 给定一个二维网格<code>grid</code>，其中<code>0</code>表示水域，<code>1</code>表示陆地，计算网格中最大的岛屿面积。岛屿由上下左右四个方向相连的陆地组成</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: grid = [[0,0,1,0,0,0,0,1,0,0,0,0,0],</span><br><span class="line">               [0,0,0,0,0,0,0,1,1,1,0,0,0],</span><br><span class="line">               [0,1,1,0,1,0,0,0,0,0,0,0,0],</span><br><span class="line">               [0,1,0,0,1,1,0,0,1,0,1,0,0],</span><br><span class="line">               [0,1,0,0,1,1,0,0,1,1,1,0,0],</span><br><span class="line">               [0,0,0,0,0,0,0,0,0,0,1,0,0],</span><br><span class="line">               [0,0,0,0,0,0,0,1,1,1,0,0,0],</span><br><span class="line">               [0,0,0,0,0,0,0,1,1,0,0,0,0]]</span><br><span class="line">Output: 6</span><br></pre></td></tr></table></figure><ul><li>解法: 深度优先搜索（<code>DFS</code>）</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 遍历整个网格</span><br><span class="line">2. 遇到 1 时，启动 DFS 计算连通岛屿的面积</span><br><span class="line">3. 将访问过的格子标记为 0，防止重复访问</span><br><span class="line">4. 更新最大岛屿面积</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxAreaOfIsland</span>(<span class="params">self, grid: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 定义 DFS 函数，遍历岛屿</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">i, j</span>):</span><br><span class="line">            <span class="comment"># 如果超出边界或当前位置不是岛屿，返回 0</span></span><br><span class="line">            <span class="keyword">if</span> i &lt; <span class="number">0</span> <span class="keyword">or</span> i &gt;= <span class="built_in">len</span>(grid) <span class="keyword">or</span> j &lt; <span class="number">0</span> <span class="keyword">or</span> j &gt;= <span class="built_in">len</span>(grid[<span class="number">0</span>]) <span class="keyword">or</span> grid[i][j] == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">            grid[i][j] = <span class="number">0</span> <span class="comment"># 标记为已访问</span></span><br><span class="line">            <span class="comment"># 递归地访问上下左右</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> + dfs(i + <span class="number">1</span>, j) + dfs(i - <span class="number">1</span>, j) + dfs(i, j + <span class="number">1</span>) + dfs(i, j - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        max_area = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(grid)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(grid[<span class="number">0</span>])):</span><br><span class="line">                <span class="keyword">if</span> grid[i][j] == <span class="number">1</span>:</span><br><span class="line">                    max_area = <span class="built_in">max</span>(max_area, dfs(i, j)) <span class="comment"># 如果找到岛屿，启动 DFS</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> max_area</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">maxAreaOfIsland</span>(<span class="params">grid</span>) &#123;</span><br><span class="line">        <span class="keyword">function</span> <span class="title function_">dfs</span>(<span class="params">i, j</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果超出边界或当前位置不是岛屿，返回 0</span></span><br><span class="line">            <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= grid.<span class="property">lenght</span> || j &lt; <span class="number">0</span> || j &gt;= grid[<span class="number">0</span>].<span class="property">length</span> || grid[i][j] === <span class="number">0</span>) </span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            grid[i][j] = <span class="number">0</span>; <span class="comment">// 标记为已访问</span></span><br><span class="line">            <span class="comment">// 递归地访问上下左右</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> + <span class="title function_">dfs</span>(i + <span class="number">1</span>, j) + <span class="title function_">dfs</span>(i - <span class="number">1</span>, j) + <span class="title function_">dfs</span>(i, j + <span class="number">1</span>) + <span class="title function_">dfs</span>(i, j - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> maxArea = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; grid.<span class="property">length</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].<span class="property">length</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] === <span class="number">1</span>)</span><br><span class="line">                    maxArea = <span class="title class_">Math</span>.<span class="title function_">max</span>(maxArea, <span class="title function_">dfs</span>(i, j));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxArea;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h3 id="Array-数组"><a href="#Array-数组" class="headerlink" title="Array 数组"></a><code>Array</code> 数组</h3><h4 id="轮转数组"><a href="#轮转数组" class="headerlink" title="轮转数组"></a>轮转数组</h4><blockquote><p><a href="https://leetcode.com/problems/rotate-array/">Leetcode 189. Rotate Array</a></p></blockquote><ul><li>题目: 给定一个数组，将其元素向右轮转<code>k</code>位，其中<code>k</code>是非负数</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: nums = [1,2,3,4,5,6,7], k = 3</span><br><span class="line">Output: [5,6,7,1,2,3,4]</span><br></pre></td></tr></table></figure><ul><li>解法: 翻转法</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 翻转整个数组</span><br><span class="line">2. 翻转前 k 个元素</span><br><span class="line">3. 翻转剩余的元素</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">rotate</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        k %= n <span class="comment"># 处理 k 大于数组长度的情况</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 翻转数组的辅助函数</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">reverse</span>(<span class="params">start, end</span>):</span><br><span class="line">            <span class="keyword">while</span> start &lt; end:</span><br><span class="line">                nums[start], nums[end] = nums[end], nums[start]</span><br><span class="line">                start += <span class="number">1</span></span><br><span class="line">                end -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 1. 翻转整个数组</span></span><br><span class="line">        reverse(<span class="number">0</span>, n - <span class="number">1</span>)</span><br><span class="line">        <span class="comment"># 2. 翻转前 k 个元素</span></span><br><span class="line">        reverse(<span class="number">0</span>, k - <span class="number">1</span>)</span><br><span class="line">        <span class="comment"># 3. 翻转剩下的元素</span></span><br><span class="line">        reverse(k, n - <span class="number">1</span>)</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">rotate</span>(<span class="params">nums, k</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> n = nums.<span class="property">length</span>;</span><br><span class="line">        k %= n; <span class="comment">// 处理 k 大于数组长度的情况</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">function</span> <span class="title function_">reverse</span>(<span class="params">start, end</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">                [nums[start], nums[end]] = [nums[end], nums[start]];</span><br><span class="line">                start++;</span><br><span class="line">                end--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 翻转整个数组</span></span><br><span class="line">        <span class="title function_">reverse</span>(<span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 2. 翻转前 k 个元素</span></span><br><span class="line">        <span class="title function_">reverse</span>(<span class="number">0</span>, k - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 3. 翻转剩下的元素</span></span><br><span class="line">        <span class="title function_">reverse</span>(k, n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h4 id="数组转树"><a href="#数组转树" class="headerlink" title="数组转树"></a>数组转树</h4><blockquote><p><a href="https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/">Leetcode 108. Convert Sorted Array to Binary Search Tree</a></p></blockquote><ul><li>题目: 将一个有序数组转换为一棵高度平衡的二叉搜索树（<code>BST</code>）。高度平衡指的是树中每个节点的两个子树的高度差不超过<code>1</code></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: nums = [-10,-3,0,5,9]</span><br><span class="line">Output: [0,-3,9,-10,null,5]</span><br></pre></td></tr></table></figure><ul><li>解法: 递归构建</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 选择数组的中间元素作为当前子树的根节点。</span><br><span class="line">2. 左侧子数组递归构建左子树。</span><br><span class="line">3. 右侧子数组递归构建右子树。</span><br><span class="line">4. 当数组为空时，返回 None。</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sortedArrayToBST</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">        <span class="comment"># 如果数组为空，返回 None</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 找到中间元素并创建当前根节点</span></span><br><span class="line">        mid = <span class="built_in">len</span>(nums) // <span class="number">2</span></span><br><span class="line">        root = TreeNode(nums[mid])</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 构建左子树和右子树</span></span><br><span class="line">        root.left = self.sortedArrayToBST(nums[:mid])</span><br><span class="line">        root.right = self.sortedArrayToBST(nums[mid + <span class="number">1</span>:])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">sortedArrayToBST</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果数组为空，返回 null</span></span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="property">length</span> === <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找到中间元素并创建当前根节点</span></span><br><span class="line">        <span class="keyword">const</span> mid = <span class="title class_">Math</span>.<span class="title function_">floor</span>(nums.<span class="property">length</span> / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">const</span> root = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(nums[mid]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构建左子树和右子树</span></span><br><span class="line">        root.<span class="property">left</span> = <span class="variable language_">this</span>.<span class="title function_">sortedArrayToBST</span>(nums.<span class="title function_">slice</span>(<span class="number">0</span>, mid));</span><br><span class="line">        root.<span class="property">right</span> = <span class="variable language_">this</span>.<span class="title function_">sortedArrayToBST</span>(nums.<span class="title function_">slice</span>(mid + <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h4 id="合并两个有序数组"><a href="#合并两个有序数组" class="headerlink" title="合并两个有序数组"></a>合并两个有序数组</h4><blockquote><p><a href="https://leetcode.com/problems/merge-sorted-array/">Leetcode 88. Merge Sorted Array</a></p></blockquote><ul><li>题目: 将两个有序数组<code>nums1</code>和<code>nums2</code>合并为一个有序数组，其中<code>nums1</code>有足够的空间存放<code>nums2</code>的元素</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3</span><br><span class="line">Output: [1,2,2,3,5,6]</span><br></pre></td></tr></table></figure><ul><li>解法: 双指针从后往前合并</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 设置三个指针</span><br><span class="line">   - i 指向 nums1 的有效元素部分的末尾</span><br><span class="line">   - j 指向 nums2 的末尾</span><br><span class="line">   - k 指向 nums1 的末尾</span><br><span class="line">2. 比较 nums1 和 nums2 中的元素，将较大的元素填入 nums1 的末尾，指针向前移动</span><br><span class="line">3. 如果 nums2 还有剩余的元素，直接填入 nums1</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">merge</span>(<span class="params">self, nums1: <span class="type">List</span>[<span class="built_in">int</span>], m: <span class="built_in">int</span>, nums2: <span class="type">List</span>[<span class="built_in">int</span>], n: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="comment"># 指针 i 指向 nums1 的有效部分末尾，j 指向 nums2 末尾，k 指向 nums1 的总末尾</span></span><br><span class="line">        i, j, k = m - <span class="number">1</span>, n - <span class="number">1</span>, m + n - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 从后往前合并</span></span><br><span class="line">        <span class="keyword">while</span> i &gt;= <span class="number">0</span> <span class="keyword">and</span> j &gt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> nums1[i] &gt; nums2[j]:</span><br><span class="line">                nums1[k] = nums1[i]</span><br><span class="line">                i -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                nums1[k] = nums2[j]</span><br><span class="line">                j -= <span class="number">1</span></span><br><span class="line">            k -= <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 如果 nums2 还有剩余元素，填入 nums1</span></span><br><span class="line">        <span class="keyword">while</span> j &gt;= <span class="number">0</span>:</span><br><span class="line">            nums1[k] = nums2[j]</span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">            k -= <span class="number">1</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">merge</span>(<span class="params">nums1, m, nums2, n</span>) &#123;</span><br><span class="line">        <span class="comment">// 指针 i 指向 nums1 的有效部分末尾，j 指向 nums2 末尾，k 指向 nums1 的总末尾</span></span><br><span class="line">        <span class="keyword">let</span> i = m - <span class="number">1</span>, j = n - <span class="number">1</span>, k = m + n - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从后往前合并</span></span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums1[i] &gt; nums2[j]) &#123;</span><br><span class="line">                nums1[k] = nums1[i];</span><br><span class="line">                i--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                nums1[k] = nums2[j];</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            k--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果 nums2 还有剩余元素，填入 nums1</span></span><br><span class="line">        <span class="keyword">while</span> (j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            nums1[k] = nums2[j];</span><br><span class="line">            j--;</span><br><span class="line">            k--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h4 id="每日温度"><a href="#每日温度" class="headerlink" title="每日温度"></a>每日温度</h4><blockquote><p><a href="https://leetcode.com/problems/daily-temperatures/">Leetcode 739. Daily Temperatures</a></p></blockquote><ul><li>题目: 给定一个整数数组<code>temperatures</code>，表示每天的温度，返回一个数组<code>answer</code>，其中<code>answer[i]</code>是需要等待的天数，直到<code>temperatures[i]</code>之后出现更高的温度。如果没有更高的温度，<code>answer[i] = 0</code></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: temperatures = [73,74,75,71,69,72,76,73]</span><br><span class="line">Output: [1,1,4,2,1,1,0,0]</span><br></pre></td></tr></table></figure><ul><li>解法: 单调栈</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 使用栈存储温度的索引</span><br><span class="line">2. 遍历 temperatures：</span><br><span class="line">   - 如果当前温度高于栈顶索引对应的温度，弹出栈顶索引并计算等待天数</span><br><span class="line">   - 否则，将当前索引压入栈</span><br><span class="line">3. 最后栈中未处理的索引对应的等待天数为 0</span><br><span class="line">4. 时间复杂度 O(n)</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dailyTemperatures</span>(<span class="params">self, temperatures: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="comment"># 初始化结果数组和栈</span></span><br><span class="line">        result = [<span class="number">0</span>] * <span class="built_in">len</span>(temperatures)</span><br><span class="line">        stack = []</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 遍历温度数组</span></span><br><span class="line">        <span class="keyword">for</span> i, temp <span class="keyword">in</span> <span class="built_in">enumerate</span>(temperatures):</span><br><span class="line">            <span class="comment"># 如果当前温度比栈顶的温度高</span></span><br><span class="line">            <span class="keyword">while</span> stack <span class="keyword">and</span> temp &gt; temperatures[stack[-<span class="number">1</span>]]:</span><br><span class="line">                prev_index = stack.pop()</span><br><span class="line">                result[prev_index] = i - prev_index</span><br><span class="line">            <span class="comment"># 将当前索引压入栈</span></span><br><span class="line">            stack.append(i)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">dailyTemperatures</span>(<span class="params">temperatures</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> result = <span class="keyword">new</span> <span class="title class_">Array</span>(temperatures.<span class="property">length</span>).<span class="title function_">fill</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">const</span> stack = [];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历温度数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; temperatures.<span class="property">length</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 如果当前温度比栈顶的温度高</span></span><br><span class="line">            <span class="keyword">while</span> (stack.<span class="property">length</span> &amp;&amp; temperatures[i] &gt; temperatures[stack[stack.<span class="property">length</span> - <span class="number">1</span>]]) &#123;</span><br><span class="line">                <span class="keyword">const</span> prevIndex = stack.<span class="title function_">pop</span>();</span><br><span class="line">                result[prevIndex] = i - prevIndex;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将当前索引压入栈</span></span><br><span class="line">            stack.<span class="title function_">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h3 id="String-字符串"><a href="#String-字符串" class="headerlink" title="String 字符串"></a><code>String</code> 字符串</h3><h4 id="字符串解码"><a href="#字符串解码" class="headerlink" title="字符串解码"></a>字符串解码</h4><blockquote><p><a href="https://leetcode.com/problems/decode-string/">Leetcode 394. Decode String</a></p></blockquote><ul><li>题目: 给定一个编码过的字符串<code>s</code>，其中包含嵌套的数字和括号结构，例如<code>3[a2[c]]</code>，其解码规则为<ul><li>数字表示括号内字符串的重复次数</li><li>解码后输出完整的字符串</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: s = &quot;3[a]2[bc]&quot;</span><br><span class="line">Output: &quot;aaabcbc&quot;</span><br></pre></td></tr></table></figure><ul><li>解法: 栈</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 使用栈保存当前的字符串和重复次数</span><br><span class="line">2. 遇到 [ 将当前字符串和次数入栈，清空当前的数字和字符串</span><br><span class="line">3. 遇到 ] 将栈中的字符串与当前字符串组合，并重复指定次数</span><br><span class="line">4. 遇到数字时，累积数字值</span><br><span class="line">5. 遇到普通字符时，将其追加到当前字符串</span><br><span class="line">6. 最后，栈中保存的即为解码后的结果</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">decodeString</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        stack = [] <span class="comment"># 栈，用于保存 (当前字符串, 当前数字)</span></span><br><span class="line">        curr_num = <span class="number">0</span> <span class="comment"># 当前的重复次数</span></span><br><span class="line">        curr_str = <span class="string">&quot;&quot;</span> <span class="comment"># 当前正在构建的字符串</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> c.isdigit():</span><br><span class="line">                <span class="comment"># 构建数字</span></span><br><span class="line">                curr_num = curr_num * <span class="number">10</span> + <span class="built_in">int</span>(c)</span><br><span class="line">            <span class="keyword">elif</span> c == <span class="string">&quot;[&quot;</span>:</span><br><span class="line">                <span class="comment"># 遇到左括号，将当前字符串和数字入栈</span></span><br><span class="line">                stack.append((curr_str, curr_num))</span><br><span class="line">                curr_str = <span class="string">&quot;&quot;</span></span><br><span class="line">                curr_num = <span class="number">0</span></span><br><span class="line">            <span class="keyword">elif</span> c == <span class="string">&quot;]&quot;</span>:</span><br><span class="line">                <span class="comment"># 遇到右括号，出栈并构造新字符串</span></span><br><span class="line">                prev_str, num = stack.pop()</span><br><span class="line">                curr_str = prev_str + num * curr_str</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 字母追加到当前字符串</span></span><br><span class="line">                curr_str += c</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> curr_str</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">decodeString</span>(<span class="params">s</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> stack = [];</span><br><span class="line">        <span class="keyword">let</span> currNum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">let</span> currStr = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> c <span class="keyword">of</span> s) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">isNaN</span>(c)) &#123;</span><br><span class="line">                <span class="comment">// 构建数字</span></span><br><span class="line">                currNum = currNum * <span class="number">10</span> + <span class="built_in">parseInt</span>(c);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c === <span class="string">&quot;[&quot;</span>) &#123;</span><br><span class="line">                <span class="comment">// 遇到左括号，将当前字符串和数字入栈</span></span><br><span class="line">                stack.<span class="title function_">push</span>([currStr, currNum]);</span><br><span class="line">                currStr = <span class="string">&quot;&quot;</span>;</span><br><span class="line">                currNum = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c === <span class="string">&quot;]&quot;</span>) &#123;</span><br><span class="line">                <span class="comment">// 遇到右括号，出栈并构造新字符串</span></span><br><span class="line">                <span class="keyword">const</span> [prevStr, num] = stack.<span class="title function_">pop</span>();</span><br><span class="line">                currStr = prevStr + currStr.<span class="title function_">repeat</span>(num);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 字母追加到当前字符串</span></span><br><span class="line">                currStr += c;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> currStr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h4 id="最长无重复子串"><a href="#最长无重复子串" class="headerlink" title="最长无重复子串"></a>最长无重复子串</h4><blockquote><p><a href="https://leetcode.com/problems/longest-substring-without-repeating-characters/">Leetcode 3. Longest Substring Without Repeating Characters</a></p></blockquote><ul><li>题目: 给定一个字符串<code>s</code>，找出其中不含重复字符的最长子串的长度</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: s = &quot;abcabcbb&quot;</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure><ul><li>解法: 滑动窗口</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 使用两个指针 `left` 和 `right` 维护一个滑动窗口，窗口内的字符不重复</span><br><span class="line">2. 用一个 `set` 存储当前窗口内的字符</span><br><span class="line">3. 每次移动右指针，将字符尝试加入窗口：</span><br><span class="line">   - 如果字符已存在，移动左指针，直到窗口中无重复字符</span><br><span class="line">4. 更新当前窗口的最大长度</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lengthOfLongestSubstring</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        result = <span class="number">0</span></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        char_set = <span class="built_in">set</span>()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> right <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">            <span class="comment"># 如果字符重复，移动左指针直到窗口无重复字符</span></span><br><span class="line">            <span class="keyword">while</span> s[right] <span class="keyword">in</span> char_set:</span><br><span class="line">                char_set.remove(s[left])</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 将当前字符加入窗口</span></span><br><span class="line">            char_set.add(s[right])</span><br><span class="line">            <span class="comment"># 更新最大长度</span></span><br><span class="line">            result = <span class="built_in">max</span>(result, right - left + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">lengthOfLongestSubstring</span>(<span class="params">s</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">let</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">let</span> charSet = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> right = <span class="number">0</span>; right &lt; s.<span class="property">length</span>; right++) &#123;</span><br><span class="line">            <span class="comment">// 如果字符重复，移动左指针直到窗口无重复字符</span></span><br><span class="line">            <span class="keyword">while</span> (charSet.<span class="title function_">has</span>(s[right])) &#123;</span><br><span class="line">                charSet.<span class="title function_">delete</span>(s[left]);</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将当前字符加入窗口</span></span><br><span class="line">            charSet.<span class="title function_">add</span>(s[right]);</span><br><span class="line">            <span class="comment">// 更新最大长度</span></span><br><span class="line">            result = <span class="title class_">Math</span>.<span class="title function_">max</span>(result, right - left + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h4 id="括号匹配"><a href="#括号匹配" class="headerlink" title="括号匹配"></a>括号匹配</h4><blockquote><p><a href="https://leetcode.com/problems/valid-parentheses/">Leetcode 20. Valid Parentheses</a></p></blockquote><ul><li>题目: 验证一个只包含括号的字符串是否有效<ul><li>所有的左括号必须有对应的右括号</li><li>左括号必须以正确的顺序闭合</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: s = &quot;()[]&#123;&#125;&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><ul><li>解法: 栈</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 用一个栈来保存左括号</span><br><span class="line">2. 遍历字符串</span><br><span class="line">    - 遇到左括号，就压入栈</span><br><span class="line">    - 遇到右括号，检查栈顶是否是对应的左括号</span><br><span class="line">        - 如果匹配，弹出栈顶</span><br><span class="line">        - 如果不匹配或栈为空，返回 False</span><br><span class="line">3. 遍历结束后，如果栈为空，说明括号有效</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isValid</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="comment"># 定义右括号到左括号的映射</span></span><br><span class="line">        char_map = &#123;<span class="string">&quot;)&quot;</span>: <span class="string">&quot;(&quot;</span>, <span class="string">&quot;]&quot;</span>: <span class="string">&quot;[&quot;</span>, <span class="string">&quot;&#125;&quot;</span>: <span class="string">&quot;&#123;&quot;</span>&#125;</span><br><span class="line">        stack = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">            <span class="comment"># 如果是左括号，压入栈中</span></span><br><span class="line">            <span class="keyword">if</span> c <span class="keyword">not</span> <span class="keyword">in</span> char_map:</span><br><span class="line">                stack.append(c)</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 如果栈为空或者栈顶元素不匹配，返回 False</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> stack <span class="keyword">or</span> stack[-<span class="number">1</span>] != char_map[c]:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 匹配成功，弹出栈顶</span></span><br><span class="line">            stack.pop()</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> stack</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">isValid</span>(<span class="params">s</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> charMap = &#123; <span class="string">&quot;)&quot;</span>: <span class="string">&quot;(&quot;</span>, <span class="string">&quot;]&quot;</span>: <span class="string">&quot;[&quot;</span>, <span class="string">&quot;&#125;&quot;</span>: <span class="string">&quot;&#123;&quot;</span> &#125;;</span><br><span class="line">        <span class="keyword">const</span> stack = [];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> c <span class="keyword">of</span> s) &#123;</span><br><span class="line">            <span class="comment">// 如果是左括号，压入栈中</span></span><br><span class="line">            <span class="keyword">if</span> (!(c <span class="keyword">in</span> charMap)) &#123;</span><br><span class="line">                stack.<span class="title function_">push</span>(c);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果栈为空或者栈顶元素不匹配，返回 false</span></span><br><span class="line">            <span class="keyword">if</span> (!stack.<span class="property">length</span> || stack[stack.<span class="property">length</span> - <span class="number">1</span>] !== charMap[c])</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 匹配成功，弹出栈顶</span></span><br><span class="line">            stack.<span class="title function_">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> stack.<span class="property">length</span> === <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h4 id="生成括号"><a href="#生成括号" class="headerlink" title="生成括号"></a>生成括号</h4><blockquote><p><a href="https://leetcode.com/problems/generate-parentheses/">Leetcode 22. Generate Parentheses</a></p></blockquote><ul><li>题目: 给定一个数字<code>n</code>，生成所有可能的有效括号组合<ul><li>左括号数量等于右括号数量，并且任意位置右括号的数量不超过左括号</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: n = 3</span><br><span class="line">Output: [&quot;((()))&quot;,&quot;(()())&quot;,&quot;(())()&quot;,&quot;()(())&quot;,&quot;()()()&quot;]</span><br></pre></td></tr></table></figure><ul><li>解法: 回溯法</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 使用递归来生成括号组合</span><br><span class="line">2. 每次递归时，维护当前括号字符串 s 和左右括号的数量</span><br><span class="line">    - 如果左括号的数量小于 n，可以添加左括号</span><br><span class="line">    - 如果右括号的数量小于左括号，添加右括号</span><br><span class="line">3. 当字符串长度等于 2 * n 时，添加到结果中</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">generateParenthesis</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">str</span>]:</span><br><span class="line">        result = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">s, left, right</span>):</span><br><span class="line">            <span class="comment"># 如果长度达到 2 * n，记录结果</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(s) == <span class="number">2</span> * n:</span><br><span class="line">                result.append(s)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 添加左括号</span></span><br><span class="line">            <span class="keyword">if</span> left &lt; n:</span><br><span class="line">                backtrack(s + <span class="string">&quot;(&quot;</span>, left + <span class="number">1</span>, right)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 添加右括号</span></span><br><span class="line">            <span class="keyword">if</span> right &lt; left:</span><br><span class="line">                backtrack(s + <span class="string">&quot;)&quot;</span>, left, right + <span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        backtrack(<span class="string">&quot;&quot;</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">generateParenthesis</span>(<span class="params">n</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> result = [];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">function</span> <span class="title function_">backtrack</span>(<span class="params">s, left, right</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果长度达到 2 * n，记录结果</span></span><br><span class="line">            <span class="keyword">if</span> (s.<span class="property">length</span> === <span class="number">2</span> * n) &#123;</span><br><span class="line">                result.<span class="title function_">push</span>(s);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 添加左括号</span></span><br><span class="line">            <span class="keyword">if</span> (left &lt; n) <span class="title function_">backtrack</span>(s + <span class="string">&quot;(&quot;</span>, left + <span class="number">1</span>, right);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 添加右括号</span></span><br><span class="line">            <span class="keyword">if</span> (right &lt; left) <span class="title function_">backtrack</span>(s + <span class="string">&quot;)&quot;</span>, left, right + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="title function_">backtrack</span>(<span class="string">&quot;&quot;</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h4 id="比较版本号"><a href="#比较版本号" class="headerlink" title="比较版本号"></a>比较版本号</h4><blockquote><p><a href="https://leetcode.com/problems/compare-version-numbers/">Leetcode 165. Compare Version Numbers</a></p></blockquote><ul><li>题目: 给定两个版本号<code>version1</code>和<code>version2</code>，比较它们的大小<ul><li>如果<code>version1 &gt; version2</code>返回<code>1</code></li><li>如果<code>version1 &lt; version2</code>返回<code>-1</code></li><li>如果它们相等，返回<code>0</code></li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: version1 = &quot;1.2&quot;, version2 = &quot;1.10&quot;</span><br><span class="line">Output: -1</span><br></pre></td></tr></table></figure><ul><li>解法: 分割和补齐</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 使用点号分割版本号，将其转换为整数列表</span><br><span class="line">2. 找到两个版本号的最大长度，将较短的版本号用 0 补齐</span><br><span class="line">3. 从左到右逐个比较对应的版本号部分，返回结果</span><br><span class="line">4. 如果遍历结束后仍然没有结果，则两个版本号相等</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">compareVersion</span>(<span class="params">self, version1: <span class="built_in">str</span>, version2: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 将版本号分割为整数列表</span></span><br><span class="line">        v1_parts = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, version1.split(<span class="string">&quot;.&quot;</span>)))</span><br><span class="line">        v2_parts = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, version2.split(<span class="string">&quot;.&quot;</span>)))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 用 0 补齐较短的版本号部分</span></span><br><span class="line">        max_len = <span class="built_in">max</span>(<span class="built_in">len</span>(v1_parts), <span class="built_in">len</span>(v2_parts))</span><br><span class="line">        v1_parts += [<span class="number">0</span>] * (max_len - <span class="built_in">len</span>(v1_parts))</span><br><span class="line">        v2_parts += [<span class="number">0</span>] * (max_len - <span class="built_in">len</span>(v2_parts))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 比较每一部分</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(max_len):</span><br><span class="line">            <span class="keyword">if</span> v1_parts[i] &gt; v2_parts[i]:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> v1_parts[i] &lt; v2_parts[<span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 如果遍历结束仍未分出大小，则版本号相等</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">compareVersion</span>(<span class="params">version1, version2</span>) &#123;</span><br><span class="line">        <span class="comment">// 将版本号分割为整数数组</span></span><br><span class="line">        <span class="keyword">const</span> v1Parts = version1.<span class="title function_">split</span>(<span class="string">&quot;.&quot;</span>).<span class="title function_">map</span>(<span class="title class_">Number</span>);</span><br><span class="line">        <span class="keyword">const</span> v2Parts = version2.<span class="title function_">split</span>(<span class="string">&quot;.&quot;</span>).<span class="title function_">map</span>(<span class="title class_">Number</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用 0 补齐较短的版本号部分</span></span><br><span class="line">        <span class="keyword">const</span> maxLen = <span class="title class_">Math</span>.<span class="title function_">max</span>(v1Parts.<span class="property">length</span>, v2Parts.<span class="property">length</span>);</span><br><span class="line">        <span class="keyword">while</span> (v1Parts.<span class="property">length</span> &lt; maxLen) v1Parts.<span class="title function_">push</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">while</span> (v2Parts.<span class="property">length</span> &lt; maxLen) v2Parts.<span class="title function_">push</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 比较每一部分</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; maxLen; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (v1Parts[i] &gt; v2Parts[i]) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (v1Parts[i] &lt; v2Parts[i]) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果遍历结束仍未分出大小，则版本号相等</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h4 id="经典计算器-无乘除"><a href="#经典计算器-无乘除" class="headerlink" title="经典计算器 (无乘除)"></a>经典计算器 (无乘除)</h4><blockquote><p><a href="https://leetcode.com/problems/basic-calculator/">Leetcode 224. Basic Calculator</a></p></blockquote><ul><li>题目: 实现一个基本的计算器来计算由正整数、<code>+</code>、<code>-</code>和括号组成的数学表达式的值。表达式中可能包含空格，确保输入合法且结果不会溢出</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: s = &quot;(1+(4+5+2)-3)+(6+8)&quot;</span><br><span class="line">Output: 23</span><br></pre></td></tr></table></figure><ul><li>解法: 栈 + 模拟</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 定义一个栈，用于存储运算结果和符号</span><br><span class="line">2. 遍历字符串:</span><br><span class="line">   - 如果是数字，累加当前数字</span><br><span class="line">   - 如果是 `+` 或 `-`，更新当前的符号，并将累加的数字加到结果中</span><br><span class="line">   - 如果是 `(`，将当前结果和符号压栈，并重置结果和符号</span><br><span class="line">   - 如果是 `)`，将栈顶的结果和符号弹出，并与当前结果相加</span><br><span class="line">3. 返回最终计算结果</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">calculate</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        stack = []</span><br><span class="line">        num = <span class="number">0</span></span><br><span class="line">        result = <span class="number">0</span></span><br><span class="line">        sign = <span class="number">1</span> <span class="comment"># 初始符号为正号</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> char <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> char.isdigit():</span><br><span class="line">                <span class="comment"># 如果是数字，更新当前数字</span></span><br><span class="line">                num = num * <span class="number">10</span> + <span class="built_in">int</span>(char)</span><br><span class="line">            <span class="keyword">elif</span> char <span class="keyword">in</span> <span class="string">&quot;+-&quot;</span>:</span><br><span class="line">                <span class="comment"># 如果是加号或减号，先更新当前结果</span></span><br><span class="line">                result += sign * num</span><br><span class="line">                num = <span class="number">0</span></span><br><span class="line">                sign = <span class="number">1</span> <span class="keyword">if</span> char == <span class="string">&quot;+&quot;</span> <span class="keyword">else</span> -<span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> char == <span class="string">&quot;(&quot;</span>:</span><br><span class="line">                <span class="comment"># 如果是左括号，保存当前结果和符号到栈中</span></span><br><span class="line">                stack.append(result)</span><br><span class="line">                stack.append(sign)</span><br><span class="line">                result = <span class="number">0</span></span><br><span class="line">                sign = <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> char == <span class="string">&quot;)&quot;</span>:</span><br><span class="line">                <span class="comment"># 如果是右括号，计算括号内的结果</span></span><br><span class="line">                result += sign * num</span><br><span class="line">                num = <span class="number">0</span></span><br><span class="line">                result *= stack.pop() <span class="comment"># 弹出符号并应用</span></span><br><span class="line">                result += stack.pop() <span class="comment"># 加上之前的结果</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> result + sign * num</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">calculate</span>(<span class="params">s</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> stack = [];</span><br><span class="line">        <span class="keyword">let</span> num = <span class="number">0</span>, result = <span class="number">0</span>, sign = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> char <span class="keyword">of</span> s) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">isNaN</span>(char) &amp;&amp; char !== <span class="string">&quot; &quot;</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果是数字，更新当前数字</span></span><br><span class="line">                num = num * <span class="number">10</span> + <span class="built_in">parseInt</span>(char);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (char === <span class="string">&quot;+&quot;</span> || char === <span class="string">&quot;-&quot;</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果是加号或减号，先更新当前结果</span></span><br><span class="line">                result += sign * num;</span><br><span class="line">                num = <span class="number">0</span>;</span><br><span class="line">                sign = char === <span class="string">&quot;+&quot;</span> ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (char === <span class="string">&quot;(&quot;</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果是左括号，保存当前结果和符号到栈中</span></span><br><span class="line">                stack.<span class="title function_">push</span>(result);</span><br><span class="line">                stack.<span class="title function_">push</span>(sign);</span><br><span class="line">                result = <span class="number">0</span>;</span><br><span class="line">                sign = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (char === <span class="string">&quot;)&quot;</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果是右括号，计算括号内的结果</span></span><br><span class="line">                result += sign * num;</span><br><span class="line">                num = <span class="number">0</span>;</span><br><span class="line">                result *= stack.<span class="title function_">pop</span>(); <span class="comment">// 弹出符号并应用</span></span><br><span class="line">                result += stack.<span class="title function_">pop</span>(); <span class="comment">// 加上之前的结果</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result + sign * num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h4 id="经典计算器-有乘除"><a href="#经典计算器-有乘除" class="headerlink" title="经典计算器 (有乘除)"></a>经典计算器 (有乘除)</h4><blockquote><p><a href="https://leetcode.com/problems/basic-calculator-ii/">Leetcode 227. Basic Calculator II</a></p></blockquote><ul><li>题目: 实现一个基本的计算器来计算一个字符串表达式的值。表达式仅包含非负整数、<code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>运算符以及空格</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: s = &quot;3+2*2&quot;</span><br><span class="line">Output: 7</span><br><span class="line">Explanation: 3 + (2 * 2) = 7</span><br></pre></td></tr></table></figure><ul><li>解法: 栈 + 模拟</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 使用栈来保存当前的计算结果</span><br><span class="line">2. 遍历字符串，处理数字、操作符和空格</span><br><span class="line">   - 如果是数字，累加构成完整数字</span><br><span class="line">   - 如果是操作符或到达字符串末尾，根据前一个操作符执行计算</span><br><span class="line">     - `+`：将当前数字压入栈</span><br><span class="line">     - `-`：将当前数字取反后压入栈</span><br><span class="line">     - `*`：弹出栈顶数字，与当前数字相乘后压入栈</span><br><span class="line">     - `/`：弹出栈顶数字，执行整数除法后压入栈</span><br><span class="line">3. 遍历结束后，栈中的所有元素求和即为最终结果</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">calculate</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        stack = []</span><br><span class="line">        num = <span class="number">0</span></span><br><span class="line">        op = <span class="string">&#x27;+&#x27;</span> <span class="comment"># 初始操作符为 &#x27;+&#x27;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i, c <span class="keyword">in</span> <span class="built_in">enumerate</span>(s):</span><br><span class="line">            <span class="keyword">if</span> c.isdigit():</span><br><span class="line">                num = num * <span class="number">10</span> + <span class="built_in">int</span>(c) <span class="comment"># 累加数字</span></span><br><span class="line">            <span class="keyword">if</span> c <span class="keyword">in</span> <span class="string">&quot;+-*/&quot;</span> <span class="keyword">or</span> i == <span class="built_in">len</span>(s) - <span class="number">1</span>: <span class="comment"># 遇到操作符或字符串末尾</span></span><br><span class="line">                <span class="keyword">if</span> op == <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">                    stack.append(num)</span><br><span class="line">                <span class="keyword">elif</span> op == <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">                    stack.append(-num)</span><br><span class="line">                <span class="keyword">elif</span> op == <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">                    stack.append(stack.pop() * num)</span><br><span class="line">                <span class="keyword">elif</span> op == <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">                    stack.append(<span class="built_in">int</span>(stack.pop() / num))</span><br><span class="line">                op = c <span class="comment"># 更新操作符</span></span><br><span class="line">                num = <span class="number">0</span> <span class="comment"># 重置当前数字</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span>(stack)</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">calculate</span>(<span class="params">s</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> stack = [];</span><br><span class="line">        <span class="keyword">let</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">let</span> op = <span class="string">&#x27;+&#x27;</span>; <span class="comment">// 初始操作符为 &#x27;+&#x27;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; s.<span class="property">length</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">const</span> c = s[i];</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">isNaN</span>(c) &amp;&amp; c !== <span class="string">&#x27; &#x27;</span>) num = num * <span class="number">10</span> + <span class="built_in">parseInt</span>(c); <span class="comment">// 累加数字</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;+-*/&quot;</span>.<span class="title function_">includes</span>(c) || i === s.<span class="property">length</span> - <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (op === <span class="string">&#x27;+&#x27;</span>) stack.<span class="title function_">push</span>(num);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (op === <span class="string">&#x27;-&#x27;</span>) stack.<span class="title function_">push</span>(-num);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (op === <span class="string">&#x27;*&#x27;</span>) stack.<span class="title function_">push</span>(stack.<span class="title function_">pop</span>() * num);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (op === <span class="string">&#x27;/&#x27;</span>) stack.<span class="title function_">push</span>(<span class="title class_">Math</span>.<span class="title function_">trunc</span>(stack.<span class="title function_">pop</span>() / num));</span><br><span class="line"></span><br><span class="line">                op = c; <span class="comment">// 更新操作符</span></span><br><span class="line">                num = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> stack.<span class="title function_">reduce</span>(<span class="function">(<span class="params">acc, num</span>) =&gt;</span> acc + num, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h4 id="回文子串个数"><a href="#回文子串个数" class="headerlink" title="回文子串个数"></a>回文子串个数</h4><blockquote><p><a href="https://leetcode.com/problems/palindromic-substrings/">Leetcode 647. Palindromic Substrings</a></p></blockquote><ul><li>题目: 给定一个字符串<code>s</code>，计算其中包含多少个回文子串</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: s = &quot;abc&quot;</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: Three palindromic substrings are &quot;a&quot;, &quot;b&quot;, and &quot;c&quot;</span><br><span class="line"></span><br><span class="line">Input: s = &quot;aaa&quot;</span><br><span class="line">Output: 6</span><br><span class="line">Explanation: Six palindromic substrings are &quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;aa&quot;, &quot;aa&quot;, and &quot;aaa&quot;</span><br></pre></td></tr></table></figure><ul><li>解法: 中心扩展法</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 中心扩展法</span><br><span class="line">   - 每个字符可以作为奇数长度回文的中心</span><br><span class="line">   - 每对相邻字符可以作为偶数长度回文的中心</span><br><span class="line">   - 从中心向两边扩展，判断两边字符是否相等，同时统计回文子串的数量</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">countSubstrings</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(s)</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">expand_around_center</span>(<span class="params">left, right</span>):</span><br><span class="line">            <span class="keyword">nonlocal</span> count</span><br><span class="line">            <span class="keyword">while</span> left &gt;= <span class="number">0</span> <span class="keyword">and</span> right &lt; n <span class="keyword">and</span> s[left] == s[right]:</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">                left -= <span class="number">1</span></span><br><span class="line">                right += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="comment"># 奇数长度的回文</span></span><br><span class="line">            expand_around_center(i, i)</span><br><span class="line">            <span class="comment"># 偶数长度的回文</span></span><br><span class="line">            expand_around_center(i, i + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">countSubstrings</span>(<span class="params">s</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> n = s.<span class="property">length</span>;</span><br><span class="line">        <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">function</span> <span class="title function_">expandAroundCenter</span>(<span class="params">left, right</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (left &gt;= <span class="number">0</span> &amp;&amp; right &lt; n &amp;&amp; s[left] === s[right]) &#123;</span><br><span class="line">                count++;</span><br><span class="line">                left--;</span><br><span class="line">                right++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">// 奇数长度的回文</span></span><br><span class="line">            <span class="title function_">expandAroundCenter</span>(i, i);</span><br><span class="line">            <span class="comment">// 偶数长度的回文</span></span><br><span class="line">            <span class="title function_">expandAroundCenter</span>(i, i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h4 id="最长回文子串"><a href="#最长回文子串" class="headerlink" title="最长回文子串"></a>最长回文子串</h4><blockquote><p><a href="https://leetcode.com/problems/longest-palindromic-substring/">Leetcode 5. Longest Palindromic Substring</a></p></blockquote><ul><li>题目: 给定一个字符串<code>s</code>，找到其中最长的回文子串</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: s = &quot;babad&quot;</span><br><span class="line">Output: &quot;bab&quot;</span><br><span class="line">Explanation: &quot;aba&quot; is also a valid answer</span><br></pre></td></tr></table></figure><ul><li>解法: 中心扩展法</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 回文的中心可以是一个字符，也可以是两个字符之间的间隔</span><br><span class="line">2. 遍历字符串，每个字符和每两个字符之间都作为回文中心进行扩展</span><br><span class="line">3. 在扩展过程中，更新最长的回文子串的起始位置和长度</span><br><span class="line">4. 时间复杂度 O(n^2)</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">longestPalindrome</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">expand_around_center</span>(<span class="params">left, right</span>):</span><br><span class="line">            <span class="comment"># 从中心扩展，寻找最长回文</span></span><br><span class="line">            <span class="keyword">while</span> left &gt;= <span class="number">0</span> <span class="keyword">and</span> right &lt; <span class="built_in">len</span>(s) <span class="keyword">and</span> s[left] == s[right]:</span><br><span class="line">                left -= <span class="number">1</span></span><br><span class="line">                right += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> s[left + <span class="number">1</span>:right]</span><br><span class="line"></span><br><span class="line">        longest = <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">            <span class="comment"># 奇数长度回文</span></span><br><span class="line">            odd_palindrome = expand_around_center(i, i)</span><br><span class="line">            <span class="comment"># 偶数长度回文</span></span><br><span class="line">            even_palindrome = expand_around_center(i, i + <span class="number">1</span>)</span><br><span class="line">            <span class="comment"># 更新最长回文子串</span></span><br><span class="line">            longest = <span class="built_in">max</span>(longest, odd_palindrome, even_palindrome, key=<span class="built_in">len</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> longest</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">longestPalindrome</span>(<span class="params">s</span>) &#123;</span><br><span class="line">        <span class="keyword">function</span> <span class="title function_">expandAroundCenter</span>(<span class="params">left, right</span>) &#123;</span><br><span class="line">            <span class="comment">// 从中心扩展，寻找最长回文</span></span><br><span class="line">            <span class="keyword">while</span> (left &gt;= <span class="number">0</span> &amp;&amp; right &lt; s.<span class="property">length</span> &amp;&amp; s[left] === s[right]) &#123;</span><br><span class="line">                left--;</span><br><span class="line">                right++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> s.<span class="title function_">substring</span>(left + <span class="number">1</span>, right);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> longest = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; s.<span class="property">length</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 奇数长度回文</span></span><br><span class="line">            <span class="keyword">const</span> oddPalindrome = <span class="title function_">expandAroundCenter</span>(i, i);</span><br><span class="line">            <span class="comment">// 偶数长度回文</span></span><br><span class="line">            <span class="keyword">const</span> evenPalindrome = <span class="title function_">expandAroundCenter</span>(i, i + <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 更新最长回文子串</span></span><br><span class="line">            <span class="keyword">if</span> (oddPalindrome.<span class="property">length</span> &gt; longest.<span class="property">length</span>) longest = oddPalindrome;</span><br><span class="line">            <span class="keyword">if</span> (evenPalindrome.<span class="property">length</span> &gt; longest.<span class="property">length</span>) longest = evenPalindrome;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> longest;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h4 id="大数相加"><a href="#大数相加" class="headerlink" title="大数相加"></a>大数相加</h4><blockquote><p><a href="https://leetcode.com/problems/add-strings/">Leetcode 415. Add Strings</a></p></blockquote><ul><li>题目: 给定两个非负整数<code>num1</code>和<code>num2</code>，以字符串的形式表示，返回它们的和，结果也用字符串表示。不能直接使用大整数库或将输入直接转换为整数</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: num1 = &quot;11&quot;, num2 = &quot;123&quot;</span><br><span class="line">Output: &quot;134&quot;</span><br></pre></td></tr></table></figure><ul><li>解法: 模拟逐位相加</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 从字符串末尾开始，逐位相加，记录进位</span><br><span class="line">2. 如果一个字符串较短，用零补齐</span><br><span class="line">3. 将每位的计算结果插入到最终结果的前面</span><br><span class="line">4. 如果最终还有进位，追加到结果</span><br><span class="line">5. 返回拼接的结果字符串</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">addStrings</span>(<span class="params">self, num1: <span class="built_in">str</span>, num2: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="comment"># 初始化指针和变量</span></span><br><span class="line">        i, j = <span class="built_in">len</span>(num1) - <span class="number">1</span>, <span class="built_in">len</span>(num2) - <span class="number">1</span></span><br><span class="line">        carry = <span class="number">0</span></span><br><span class="line">        result = []</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 从右向左逐位相加</span></span><br><span class="line">        <span class="keyword">while</span> i &gt;= <span class="number">0</span> <span class="keyword">or</span> j &gt;= <span class="number">0</span> <span class="keyword">or</span> carry:</span><br><span class="line">            n1 = <span class="built_in">int</span>(num1[i]) <span class="keyword">if</span> i &gt;= <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            n2 = <span class="built_in">int</span>(num2[j]) <span class="keyword">if</span> j &gt;= <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            total = n1 + n2 + carry</span><br><span class="line"></span><br><span class="line">            carry  = total // <span class="number">10</span> <span class="comment"># 计算进位</span></span><br><span class="line">            result.append(<span class="built_in">str</span>(total % <span class="number">10</span>))</span><br><span class="line"></span><br><span class="line">            i -= <span class="number">1</span></span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(result[::-<span class="number">1</span>]) <span class="comment"># 翻转并拼接结果</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">addStrings</span>(<span class="params">num1, num2</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> i = num1.<span class="property">length</span> - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">let</span> j = num2.<span class="property">length</span> - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">let</span> carry = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">let</span> result = [];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从右向左逐位相加</span></span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span> || carry) &#123;</span><br><span class="line">            <span class="keyword">const</span> n1 = i &gt;= <span class="number">0</span> ? <span class="built_in">parseInt</span>(num1[i]) : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">const</span> n2 = j &gt;= <span class="number">0</span> ? <span class="built_in">parseInt</span>(num2[j]) : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">const</span> total = n1 + n2 + carry;</span><br><span class="line"></span><br><span class="line">            carry = <span class="title class_">Math</span>.<span class="title function_">floor</span>(total / <span class="number">10</span>); <span class="comment">// 计算进位</span></span><br><span class="line">            result.<span class="title function_">push</span>(total % <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">            i--;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result.<span class="title function_">reverse</span>().<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>); <span class="comment">// 翻转并拼接结果</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h3 id="Backtrack-回溯"><a href="#Backtrack-回溯" class="headerlink" title="Backtrack 回溯"></a><code>Backtrack</code> 回溯</h3><h4 id="全排列（无重复元素）"><a href="#全排列（无重复元素）" class="headerlink" title="全排列（无重复元素）"></a>全排列（无重复元素）</h4><blockquote><p><a href="https://leetcode.com/problems/permutations/">Leetcode 46. Permutations</a></p></blockquote><ul><li>题目: 给定一个不包含重复的数组<code>nums</code>，返回数组的所有可能的排列，不包含重复</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: nums = [1,2,3]</span><br><span class="line">Output: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</span><br></pre></td></tr></table></figure><ul><li>解法: 回溯算法</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 初始化一个空路径 path 和一个 used 数组用于标记是否使用过某元素</span><br><span class="line">2. 遍历数组，对未使用的元素进行选择，加入路径</span><br><span class="line">3. 如果路径长度等于数组长度，将当前路径加入结果</span><br><span class="line">4. 撤销选择，尝试其他未使用的元素</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">permute</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        result = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">path, used</span>):</span><br><span class="line">            <span class="comment"># 如果路径长度等于数组长度，加入结果</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(path) == <span class="built_in">len</span>(nums):</span><br><span class="line">                result.append(path[:]) <span class="comment"># 深拷贝当前路径</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">                <span class="keyword">if</span> used[i]:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">                <span class="comment"># 做选择</span></span><br><span class="line">                path.append(nums[i])</span><br><span class="line">                used[i] = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">                <span class="comment"># 递归</span></span><br><span class="line">                backtrack(path, used)</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 撤销选择</span></span><br><span class="line">                path.pop()</span><br><span class="line">                used[i] = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        backtrack([], [<span class="literal">False</span>] * <span class="built_in">len</span>(nums))</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">permute</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> result = [];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">function</span> <span class="title function_">backtrack</span>(<span class="params">path, used</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果路径长度等于数组长度，加入结果</span></span><br><span class="line">            <span class="keyword">if</span> (path.<span class="property">length</span> === nums.<span class="property">length</span>) &#123;</span><br><span class="line">                result.<span class="title function_">push</span>([...path]); <span class="comment">// 深拷贝当前路径</span></span><br><span class="line">                <span class="keyword">return</span>; </span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.<span class="property">length</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (used[i]) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 做选择</span></span><br><span class="line">                path.<span class="title function_">push</span>(nums[i]);</span><br><span class="line">                used[i] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 递归</span></span><br><span class="line">                <span class="title function_">backtrack</span>(path, used);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 撤销选择</span></span><br><span class="line">                path.<span class="title function_">pop</span>();</span><br><span class="line">                used[i] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="title function_">backtrack</span>([], <span class="title class_">Array</span>(nums.<span class="property">length</span>).<span class="title function_">fill</span>(<span class="literal">false</span>));</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h4 id="全排列（有重复元素）"><a href="#全排列（有重复元素）" class="headerlink" title="全排列（有重复元素）"></a>全排列（有重复元素）</h4><blockquote><p><a href="https://leetcode.com/problems/permutations-ii/">Leetcode 47. Permutations II</a></p></blockquote><ul><li>题目: 给定一个可能包含重复数字的数组<code>nums</code>，返回数组的所有不重复的排列</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: nums = [1,1,2]</span><br><span class="line">Output:</span><br><span class="line">[[1,1,2],</span><br><span class="line"> [1,2,1],</span><br><span class="line"> [2,1,1]]</span><br></pre></td></tr></table></figure><ul><li>解法: 回溯算法 + 去重</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 对 nums 排序，使得相同的数字相邻，方便去重</span><br><span class="line">2. 在回溯过程中，跳过当前数字与前一个数字相同且前一个数字未被使用的情况</span><br><span class="line">3. 构建排列路径，记录已使用数字</span><br><span class="line">4. 撤销选择，尝试其他未使用的数字</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">permuteUnique</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        result = []</span><br><span class="line">        nums.sort() <span class="comment"># 排序以便去重</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">path, used</span>):</span><br><span class="line">            <span class="comment"># 如果路径长度等于数组长度，加入结果</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(path) == <span class="built_in">len</span>(nums):</span><br><span class="line">                result.append(path[:])</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">                <span class="comment"># 如果数字已使用，跳过</span></span><br><span class="line">                <span class="keyword">if</span> used[i]:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">                <span class="comment"># 去重：当前数字与前一个数字相同，且前一个数字未被使用</span></span><br><span class="line">                <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i - <span class="number">1</span>] <span class="keyword">and</span> <span class="keyword">not</span> used[i - <span class="number">1</span>]:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">                <span class="comment"># 做选择</span></span><br><span class="line">                path.append(nums[i])</span><br><span class="line">                used[i] = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">                <span class="comment"># 递归</span></span><br><span class="line">                backtrack(path, used)</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 撤销选择</span></span><br><span class="line">                path.pop()</span><br><span class="line">                used[i] = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        backtrack([], [<span class="literal">False</span>] * <span class="built_in">len</span>(nums))</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">permuteUnique</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> result = [];</span><br><span class="line">        nums.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b); <span class="comment">// 排序以便去重</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">function</span> <span class="title function_">backtrack</span>(<span class="params">path, used</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果路径长度等于数组长度，加入结果</span></span><br><span class="line">            <span class="keyword">if</span> (path.<span class="property">length</span> === nums.<span class="property">length</span>) &#123;</span><br><span class="line">                result.<span class="title function_">push</span>([...path]); <span class="comment">// 深拷贝路径</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.<span class="property">length</span>; i++) &#123;</span><br><span class="line">                <span class="comment">// 如果数字已使用，跳过</span></span><br><span class="line">                <span class="keyword">if</span> (used[i]) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 去重：当前数字与前一个数字相同，且前一个数字未被使用</span></span><br><span class="line">                <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] === nums[i - <span class="number">1</span>] &amp;&amp; !used[i - <span class="number">1</span>])</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 做选择</span></span><br><span class="line">                path.<span class="title function_">push</span>(nums[i]);</span><br><span class="line">                used[i] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 递归</span></span><br><span class="line">                <span class="title function_">backtrack</span>(path, used);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 撤销选择</span></span><br><span class="line">                path.<span class="title function_">pop</span>();</span><br><span class="line">                used[i] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="title function_">backtrack</span>([], <span class="title class_">Array</span>(nums.<span class="property">length</span>).<span class="title function_">fill</span>(<span class="literal">false</span>));</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h3 id="Dynamic-Programming"><a href="#Dynamic-Programming" class="headerlink" title="Dynamic Programming"></a><code>Dynamic Programming</code></h3><h4 id="分割等和子集"><a href="#分割等和子集" class="headerlink" title="分割等和子集"></a>分割等和子集</h4><blockquote><p><a href="https://leetcode.com/problems/partition-equal-subset-sum/">Leetcode 416. Partition Equal Subset Sum</a></p></blockquote><ul><li>题目: 给定一个非空正整数数组<code>nums</code>，判断是否可以将这个数组分割为两个子集，使得两个子集的元素和相等</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: nums = [1,5,11,5]</span><br><span class="line">Output: true</span><br><span class="line">Explanation: The array can be partitioned as [1, 5, 5] and [11]</span><br></pre></td></tr></table></figure><ul><li>解法: 动态规划（背包问题）</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 目标是找到一个子集，使其和等于总和的一半</span><br><span class="line">2. 如果数组总和为奇数，直接返回 False</span><br><span class="line">3. 定义 dp[i] 表示是否存在一个子集，使得这个子集的和为 i</span><br><span class="line">4. 初始化 dp[0] = True（空集的和为 0 总是成立）</span><br><span class="line">5. 遍历数组中的每个数，从 target（总和的一半）开始向下更新 dp 数组</span><br><span class="line">6. 对于每个数 num 和当前的和 i，如果 dp[i - num] 为 True，则 dp[i] 也为 True</span><br><span class="line">7. 最终检查 dp[target] 是否为 True</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">canPartition</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        total_sum = <span class="built_in">sum</span>(nums)</span><br><span class="line">        <span class="keyword">if</span> total_sum % <span class="number">2</span> != <span class="number">0</span>: <span class="comment"># 如果总和是奇数，无法平分</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        target = total_sum // <span class="number">2</span></span><br><span class="line">        dp = [<span class="literal">False</span>] * (target + <span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="literal">True</span> <span class="comment"># 和为 0 的子集总是存在</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(target, num - <span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                dp[i] = dp[i] <span class="keyword">or</span> dp[i - num]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[target]</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">canPartition</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> totalSum = nums.<span class="title function_">reduce</span>(<span class="function">(<span class="params">acc, num</span>) =&gt;</span> acc + num, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (totalSum % <span class="number">2</span> !== <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 如果总和是奇数，无法平分</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> target = totalSum / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">const</span> dp = <span class="title class_">Array</span>(target + <span class="number">1</span>).<span class="title function_">fill</span>(<span class="literal">false</span>);</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="literal">true</span>; <span class="comment">// 和为 0 的子集总是存在</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> num <span class="keyword">of</span> nums) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = target; i &gt;= num; i--) &#123;</span><br><span class="line">                dp[i] = dp[i] || dp[i - num];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h4 id="组成目标和"><a href="#组成目标和" class="headerlink" title="组成目标和"></a>组成目标和</h4><blockquote><p><a href="https://leetcode.com/problems/target-sum/">Leetcode 494. Target Sum</a></p></blockquote><ul><li>题目: 给定一个数组<code>nums</code>，可以为每个元素加上<code>+</code>或<code>-</code>符号，问有多少种不同的方式使得总和等于目标值<code>target</code></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: nums = [1,1,1,1,1], target = 3</span><br><span class="line">Output: 5</span><br><span class="line">Explanation: There are 5 ways to assign symbols to make the sum of nums be target 3</span><br><span class="line">-1 + 1 + 1 + 1 + 1 = 3</span><br><span class="line">+1 - 1 + 1 + 1 + 1 = 3</span><br><span class="line">+1 + 1 - 1 + 1 + 1 = 3</span><br><span class="line">+1 + 1 + 1 - 1 + 1 = 3</span><br><span class="line">+1 + 1 + 1 + 1 - 1 = 3</span><br></pre></td></tr></table></figure><ul><li>解法: 动态规划</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 将问题转换为子集问题，设 P 是正号部分，N 是负号部分</span><br><span class="line">2. 方程联立：P - N = target 和 P + N = sum(nums) 得到 P = (target + sum(nums)) / 2</span><br><span class="line">3. 如果 (target + sum(nums)) 不是偶数或 target 超过 sum(nums)，返回 0</span><br><span class="line">4. 定义 dp[i] 表示和为 i 的子集数，初始化 dp[0] = 1</span><br><span class="line">5. 遍历数组中的每个数，倒序更新 dp 数组</span><br><span class="line">6. dp[subset_sum] 即为结果</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findTargetSumWays</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        total_sum = <span class="built_in">sum</span>(nums)</span><br><span class="line">        <span class="comment"># 如果目标值无法分割为两部分，返回 </span></span><br><span class="line">        <span class="keyword">if</span> (target + total_sum) % <span class="number">2</span> != <span class="number">0</span> <span class="keyword">or</span> total_sum &lt; <span class="built_in">abs</span>(target):</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 转换为子集和问题</span></span><br><span class="line">        subset_sum = (target + total_sum) // <span class="number">2</span></span><br><span class="line">        <span class="comment"># dp[i] 表示和为 i 的子集数</span></span><br><span class="line">        dp = [<span class="number">0</span>] * (subset_sum + <span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span> <span class="comment"># 和为 0 的子集数为 1（空集）</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="comment"># 从后向前更新 dp 数组</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(subset_sum, num - <span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                dp[i] += dp[i - num]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[subset_sum]</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">findTargetSumWays</span>(<span class="params">nums, target</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> totalSum = nums.<span class="title function_">reduce</span>(<span class="function">(<span class="params">acc, num</span>) =&gt;</span> acc + num, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 如果目标值无法分割为两部分，返回 0</span></span><br><span class="line">        <span class="keyword">if</span> ((target + totalSum) % <span class="number">2</span> !== <span class="number">0</span> || totalSum &lt; <span class="title class_">Math</span>.<span class="title function_">abs</span>(target))</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 转换为子集和问题</span></span><br><span class="line">        <span class="keyword">const</span> subsetSum = (target + totalSum) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">const</span> dp = <span class="keyword">new</span> <span class="title class_">Array</span>(subsetSum + <span class="number">1</span>).<span class="title function_">fill</span>(<span class="number">0</span>);</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>; <span class="comment">// 和为 0 的子集数为 1（空集）</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> num <span class="keyword">of</span> nums) &#123;</span><br><span class="line">            <span class="comment">// 从后向前更新 dp 数组</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = subsetSum; i &gt;= num; i--) &#123;</span><br><span class="line">                dp[i] += dp[i - num];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[subsetSum];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h4 id="跳跃游戏"><a href="#跳跃游戏" class="headerlink" title="跳跃游戏"></a>跳跃游戏</h4><blockquote><p><a href="https://leetcode.com/problems/jump-game/">Leetcode 55. Jump Game</a></p></blockquote><ul><li>题目: 给定一个非负整数数组<code>nums</code>，每个元素表示在该位置上最多可以跳跃的步数。判断是否能够从数组的第一个位置跳到最后一个位置</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: nums = [2,3,1,1,4]</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><ul><li>解法: 贪心算法</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 初始化变量 maxReach 记录当前能到达的最远位置</span><br><span class="line">2. 遍历数组</span><br><span class="line">    - 如果当前位置 i 超过 maxReach，返回 False，表示无法跳到该位置</span><br><span class="line">    - 更新 maxReach 为 max(maxReach, i + nums[i])</span><br><span class="line">3. 遍历结束后，如果未返回 False，说明可以到达终点</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">canJump</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        max_reach = <span class="number">0</span> <span class="comment"># 初始化能够到达的最远位置</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="comment"># 如果当前位置超过了最远可达位置，返回 False</span></span><br><span class="line">            <span class="keyword">if</span> i &gt; max_reach:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 更新最远可达位置</span></span><br><span class="line">            max_reach = <span class="built_in">max</span>(max_reach, i + nums[i])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">canJump</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> maxReach = <span class="number">0</span>; <span class="comment">// 初始化能够到达的最远位置</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.<span class="property">length</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 如果当前位置超过了最远可达位置，返回 false</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; maxReach) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 更新最远可达位置</span></span><br><span class="line">            maxReach = <span class="title class_">Math</span>.<span class="title function_">max</span>(maxReach, i + nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h4 id="最小跳跃次数"><a href="#最小跳跃次数" class="headerlink" title="最小跳跃次数"></a>最小跳跃次数</h4><blockquote><p><a href="https://leetcode.com/problems/jump-game-ii/">Leetcode 45. Jump Game II</a></p></blockquote><ul><li>题目: 给定一个非负整数数组<code>nums</code>，每个元素表示在该位置上最多可以跳跃的步数。求从数组的第一个位置跳到最后一个位置所需的最小跳跃次数</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: nums = [2,3,1,1,4]</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure><ul><li>解法: 贪心算法</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 初始化 jumps（跳跃次数），current_end（当前跳跃的边界），farthest（能跳到的最远位置）</span><br><span class="line">2. 遍历数组，更新 farthest 为 max(farthest, i + nums[i])</span><br><span class="line">3. 当到达 current_end 时，增加跳跃次数，并更新 current_end 为 farthest</span><br><span class="line">4. 遍历结束返回 jumps</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">jump</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        jumps = <span class="number">0</span> <span class="comment"># 跳跃次数</span></span><br><span class="line">        current_end = <span class="number">0</span> <span class="comment"># 当前跳跃的边界</span></span><br><span class="line">        farthest = <span class="number">0</span> <span class="comment"># 当前能跳到的最远位置</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums) - <span class="number">1</span>): <span class="comment"># 最后一个元素不需要遍历</span></span><br><span class="line">            farthest = <span class="built_in">max</span>(farthest, i + nums[i])</span><br><span class="line">            <span class="keyword">if</span> i == current_end: <span class="comment"># 到达当前跳跃的边界</span></span><br><span class="line">                jumps += <span class="number">1</span></span><br><span class="line">                current_end = farthest</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> jumps</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">jump</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> jumps = <span class="number">0</span>; <span class="comment">// 跳跃次数</span></span><br><span class="line">        <span class="keyword">let</span> currentEnd = <span class="number">0</span>; <span class="comment">// 当前跳跃的边界</span></span><br><span class="line">        <span class="keyword">let</span> farthest = <span class="number">0</span>; <span class="comment">// 当前能跳到的最远位置</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.<span class="property">length</span> - <span class="number">1</span>; i++) &#123; <span class="comment">// 最后一个元素不需要遍历</span></span><br><span class="line">            farthest = <span class="title class_">Math</span>.<span class="title function_">max</span>(farthest, i + nums[i]);</span><br><span class="line">            <span class="keyword">if</span> (i === currentEnd) &#123;</span><br><span class="line">                jumps++;</span><br><span class="line">                currentEnd = farthest;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> jumps;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h4 id="买卖股票的最佳时机"><a href="#买卖股票的最佳时机" class="headerlink" title="买卖股票的最佳时机"></a>买卖股票的最佳时机</h4><blockquote><p><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock/">Leetcode 121. Best Time to Buy and Sell Stock</a></p></blockquote><ul><li>题目: 给定一个整数数组<code>prices</code>，其中<code>prices[i]</code>表示某天的股票价格。只允许完成一笔交易（买入和卖出），求最大利润。如果无法获得利润，返回<code>0</code></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: prices = [7,1,5,3,6,4]</span><br><span class="line">Output: 5</span><br><span class="line">Explanation: 在价格为1时买入，价格为6时卖出，利润为6-1=5</span><br></pre></td></tr></table></figure><ul><li>解法: 贪心算法</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 初始化最小买入价格为无穷大，最大利润为 0</span><br><span class="line">2. 遍历价格数组</span><br><span class="line">    - 如果当前价格小于最小买入价格，更新最小买入价格</span><br><span class="line">    - 如果当前价格减去最小买入价格的利润大于最大利润，更新最大利润</span><br><span class="line">3. 返回最大利润</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxProfit</span>(<span class="params">self, prices: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        min_price = <span class="built_in">float</span>(<span class="string">&quot;inf&quot;</span>) <span class="comment"># 最小买入价格</span></span><br><span class="line">        max_profit = <span class="number">0</span> <span class="comment"># 最大利润</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> price <span class="keyword">in</span> prices:</span><br><span class="line">            <span class="comment"># 更新最小买入价格</span></span><br><span class="line">            <span class="keyword">if</span> price &lt; min_price:</span><br><span class="line">                min_price = price</span><br><span class="line">            <span class="comment"># 计算当前利润，并更新最大利润</span></span><br><span class="line">            <span class="keyword">elif</span> price - min_price &gt; max_profit:</span><br><span class="line">                max_profit = price - min_price</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> max_profit</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">maxProfit</span>(<span class="params">prices</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> minPrice = <span class="title class_">Infinity</span>; <span class="comment">// 最小买入价格</span></span><br><span class="line">        <span class="keyword">let</span> maxProfit = <span class="number">0</span>; <span class="comment">// 最大利润</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> price <span class="keyword">of</span> prices) &#123;</span><br><span class="line">            <span class="comment">// 更新最小买入价格</span></span><br><span class="line">            <span class="keyword">if</span> (price &lt; minPrice) </span><br><span class="line">                minPrice = price;</span><br><span class="line">            <span class="comment">// 计算当前利润，并更新最大利润</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (price - minPrice &gt; maxProfit)</span><br><span class="line">                maxProfit = price - minPrice;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> maxProfit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h4 id="股票买卖的最大收益"><a href="#股票买卖的最大收益" class="headerlink" title="股票买卖的最大收益"></a>股票买卖的最大收益</h4><blockquote><p><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/">Leetcode 122. Best Time to Buy and Sell Stock II</a></p></blockquote><ul><li>题目: 给定一个数组，<code>prices[i]</code>表示第<code>i</code>天的股票价格。可以进行多次买卖操作（但必须先卖掉之前的股票后才能再次购买），求能获得的最大利润</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: prices = [7,1,5,3,6,4]</span><br><span class="line">Output: 7</span><br><span class="line">Explanation: 在第2天买入（价格=1），第3天卖出（价格=5），收益=5-1=4；然后在第4天买入（价格=3），第5天卖出（价格=6），收益=6-3=3，总收益为7</span><br></pre></td></tr></table></figure><ul><li>解法: 贪心算法</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 遍历价格数组，检查是否存在连续上涨的价格差</span><br><span class="line">2. 如果今天的价格高于昨天的价格，将差值累加到最大利润中</span><br><span class="line">3. 遍历完成后，返回最大利润</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxProfit</span>(<span class="params">self, prices: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        max_profit = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(prices)):</span><br><span class="line">            <span class="comment"># 如果今天的价格比昨天高，累加差值到利润中</span></span><br><span class="line">            <span class="keyword">if</span> prices[i] &gt; prices[i - <span class="number">1</span>]:</span><br><span class="line">                max_profit += prices[i] - prices[i - <span class="number">1</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> max_profit</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">maxProfit</span>(<span class="params">prices</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> maxProfit = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; prices.<span class="property">length</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 如果今天的价格比昨天高，累加差值到利润中</span></span><br><span class="line">            <span class="keyword">if</span> (prices[i] &gt; prices[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                maxProfit += prices[i] - prices[i - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> maxProfit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h4 id="不同路径的数目"><a href="#不同路径的数目" class="headerlink" title="不同路径的数目"></a>不同路径的数目</h4><blockquote><p><a href="https://leetcode.com/problems/unique-paths/">Leetcode 62. Unique Paths</a></p></blockquote><ul><li>题目: 一个机器人位于一个<code>m x n</code>网格的左上角 (起点在<code>(0, 0)</code>)。机器人每次只能向下或向右移动一步。网格的右下角在<code>(m-1, n-1)</code>。问有多少条不同的路径可以到达终点</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: m = 3, n = 7</span><br><span class="line">Output: 28</span><br></pre></td></tr></table></figure><ul><li>解法: 动态规划</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 定义 dp 数组，dp[i][j] 表示到达网格 (i, j) 的路径数量</span><br><span class="line">2. 初始状态: dp[0][j] 和 dp[i][0] 都为 1（第一行和第一列的路径数量都为 1）</span><br><span class="line">3. 状态转移方程: dp[i][j] = dp[i-1][j] + dp[i][j-1]</span><br><span class="line">4. 返回 dp[m-1][n-1]</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">uniquePaths</span>(<span class="params">self, m: <span class="built_in">int</span>, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 初始化 dp 数组，所有值为 1</span></span><br><span class="line">        dp = [[<span class="number">1</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m)]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 填充 dp 表格</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>]</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">uniquePaths</span>(<span class="params">m, n</span>) &#123;</span><br><span class="line">        <span class="comment">// 初始化 dp 数组，所有值为 1</span></span><br><span class="line">        <span class="keyword">const</span> dp = <span class="title class_">Array</span>.<span class="title function_">from</span>(&#123;<span class="attr">length</span>: m&#125;, <span class="function">() =&gt;</span> <span class="title class_">Array</span>(n).<span class="title function_">fill</span>(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 填充 dp 表格</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h4 id="最大连续和"><a href="#最大连续和" class="headerlink" title="最大连续和"></a>最大连续和</h4><blockquote><p><a href="https://leetcode.com/problems/maximum-subarray/">Leetcode 53. Maximum Subarray</a></p></blockquote><ul><li>题目: 给定一个整数数组<code>nums</code>，找到具有最大和的连续子数组（至少包含一个元素），返回其最大和</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: nums = [-2,1,-3,4,-1,2,1,-5,4]</span><br><span class="line">Output: 6</span><br><span class="line">Explanation: [4,-1,2,1] has the largest sum = 6</span><br></pre></td></tr></table></figure><ul><li>解法: 动态规划</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 定义 dp[i] 表示以 nums[i] 结尾的最大子数组和</span><br><span class="line">2. 状态转移方程:</span><br><span class="line">   dp[i] = max(nums[i], dp[i-1] + nums[i])</span><br><span class="line">   即当前位置的最大和，要么是当前数字本身，要么是当前数字加上前面的最大和</span><br><span class="line">3. 初始化: dp[0] = nums[0]</span><br><span class="line">4. 遍历数组，计算每个位置的 dp 值，并记录最大值</span><br><span class="line">5. 时间复杂度 O(n)，空间复杂度 O(1)（通过优化只保留当前值）</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxSubArray</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 初始化当前最大和和全局最大和</span></span><br><span class="line">        current_sum = max_sum = nums[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums[<span class="number">1</span>:]:</span><br><span class="line">            <span class="comment"># 当前和为当前数字或当前数字加之前的和</span></span><br><span class="line">            current_sum = <span class="built_in">max</span>(num, current_sum + num)</span><br><span class="line">            <span class="comment"># 更新全局最大和</span></span><br><span class="line">            max_sum = <span class="built_in">max</span>(max_sum, current_sum)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> max_sum</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">maxSubArray</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">        <span class="comment">// 初始化当前最大和和全局最大和</span></span><br><span class="line">        <span class="keyword">let</span> currentSum = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">let</span> maxSum = nums[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; nums.<span class="property">length</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 当前和为当前数字或当前数字加之前的和</span></span><br><span class="line">            currentSum = <span class="title class_">Math</span>.<span class="title function_">max</span>(nums[i], currentSum + nums[i]);</span><br><span class="line">            <span class="comment">// 更新全局最大和</span></span><br><span class="line">            maxSum = <span class="title class_">Math</span>.<span class="title function_">max</span>(maxSum, currentSum);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> maxSum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h4 id="最长公共子串"><a href="#最长公共子串" class="headerlink" title="最长公共子串"></a>最长公共子串</h4><blockquote><p><a href="https://leetcode.com/problems/longest-common-subsequence/">Leetcode 1143. Longest Common Subsequence</a></p></blockquote><ul><li>题目: 给定两个字符串<code>text1</code>和<code>text2</code>，返回它们最长公共子序列的长度。如果不存在公共子序列，则返回<code>0</code></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: text1 = &quot;abcde&quot;, text2 = &quot;ace&quot;</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: The longest common subsequence is &quot;ace&quot; and its length is 3</span><br></pre></td></tr></table></figure><ul><li>解法: 动态规划</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 定义 dp[i][j]:</span><br><span class="line">   - dp[i][j] 表示 text1 前 i 个字符和 text2 前 j 个字符的最长公共子序列长度</span><br><span class="line">2. 转移方程:</span><br><span class="line">   - 如果 text1[i-1] == text2[j-1]，则 dp[i][j] = dp[i-1][j-1] + 1</span><br><span class="line">   - 否则，dp[i][j] = max(dp[i-1][j], dp[i][j-1])</span><br><span class="line">3. 初始化:</span><br><span class="line">   - dp[0][j] = 0 和 dp[i][0] = 0，因为空字符串与任何字符串的公共子序列长度为 0</span><br><span class="line">4. 遍历:</span><br><span class="line">   - 填充整个 dp 表，并返回 dp[m][n]，其中 m 和 n 是 text1 和 text2 的长度</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">longestCommonSubsequence</span>(<span class="params">self, text1: <span class="built_in">str</span>, text2: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        m, n = <span class="built_in">len</span>(text1), <span class="built_in">len</span>(text2)</span><br><span class="line">        <span class="comment"># 创建 dp 数组并初始化</span></span><br><span class="line">        dp = [[<span class="number">0</span>] * (n + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m + <span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 遍历两个字符串的所有前缀组合</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> text1[i - <span class="number">1</span>] == text2[j - <span class="number">1</span>]:</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[m][n]</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">longestCommonSubsequence</span>(<span class="params">text1, text2</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> m = text1.<span class="property">length</span>, n = text2.<span class="property">length</span>;</span><br><span class="line">        <span class="comment">// 创建 dp 数组并初始化</span></span><br><span class="line">        <span class="keyword">const</span> dp = <span class="title class_">Array</span>.<span class="title function_">from</span>(&#123;<span class="attr">length</span>: m + <span class="number">1</span>&#125;, <span class="function">() =&gt;</span> <span class="title class_">Array</span>(n + <span class="number">1</span>).<span class="title function_">fill</span>(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历两个字符串的所有前缀组合</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (text1[i - <span class="number">1</span>] === text2[j - <span class="number">1</span>])</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp[i][j] = <span class="title class_">Math</span>.<span class="title function_">max</span>(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h3 id="Other-其他"><a href="#Other-其他" class="headerlink" title="Other 其他"></a><code>Other</code> 其他</h3><h4 id="二维数组去重"><a href="#二维数组去重" class="headerlink" title="二维数组去重"></a>二维数组去重</h4><ul><li>题目: 给定一个二维数组，可能包含重复的行，实现一个方法去重，返回去重后的二维数组</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">matrix = [</span><br><span class="line">    [1, 2, 3],</span><br><span class="line">    [1, 2, 3],</span><br><span class="line">    [4, 5, 6]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"># 输出: [(1, 2, 3), (4, 5, 6)]</span><br></pre></td></tr></table></figure><ul><li>解法<code>1</code>: 不保留顺序</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">将每一行转化为不可变类型</span><br><span class="line">    在 Python 中使用 tuple</span><br><span class="line">    在 JavaScript 中使用 JSON.stringify</span><br><span class="line">利用 Set 的特性去重</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">remove_duplicates</span>(<span class="params">matrix</span>):</span><br><span class="line">        <span class="comment"># 将每一行转化为元组并用 set 去重</span></span><br><span class="line">        unique_rows = <span class="built_in">set</span>(<span class="built_in">tuple</span>(row) <span class="keyword">for</span> row <span class="keyword">in</span> matrix)</span><br><span class="line">        <span class="comment"># 将去重后的结果转回列表形式</span></span><br><span class="line">        <span class="keyword">return</span> [<span class="built_in">list</span>(row) <span class="keyword">for</span> row <span class="keyword">in</span> unique_rows]</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">removeDuplicates</span>(<span class="params">matrix</span>) &#123;</span><br><span class="line">        <span class="comment">// 使用 Set 去重，将每一行转换为字符串</span></span><br><span class="line">        <span class="keyword">const</span> uniqueRows = <span class="keyword">new</span> <span class="title class_">Set</span>(matrix.<span class="title function_">map</span>(<span class="function"><span class="params">row</span> =&gt;</span> <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(rows)));</span><br><span class="line">        <span class="comment">// 将字符串还原为数组</span></span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Array</span>.<span class="title function_">from</span>(uniqueRows, <span class="function"><span class="params">row</span> =&gt;</span> <span class="title class_">JSON</span>.<span class="title function_">parse</span>(row));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><ul><li>解法<code>2</code>: 保留顺序</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">使用 Set 跟踪已经处理的行</span><br><span class="line">遍历二维数组，检查每一行是否已在 Set 中</span><br><span class="line">    如果未出现过，则添加到结果数组中，并将其标记为已处理</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">remove_duplicates_with_order</span>(<span class="params">matrix</span>):</span><br><span class="line">        seen = <span class="built_in">set</span>()</span><br><span class="line">        unique_rows = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> matrix:</span><br><span class="line">            row_tuple = <span class="built_in">tuple</span>(row)</span><br><span class="line">            <span class="keyword">if</span> row_tuple <span class="keyword">not</span> <span class="keyword">in</span> seen: <span class="comment"># 如果该行尚未处理</span></span><br><span class="line">                seen.add(row_tuple) <span class="comment"># 标记为已处理</span></span><br><span class="line">                unique_rows.append(row) <span class="comment"># 添加到结果中</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> unique_rows</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">removeDuplicatesWithOrder</span>(<span class="params">matrix</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> seen = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line">        <span class="keyword">const</span> uniqueRows = [];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> row <span class="keyword">of</span> matrix) &#123;</span><br><span class="line">            <span class="keyword">const</span> rowString = <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(row); <span class="comment">// 将行转化为字符串</span></span><br><span class="line">            <span class="keyword">if</span> (!seen.<span class="title function_">has</span>(rowString)) &#123;</span><br><span class="line">                seen.<span class="title function_">add</span>(rowString);</span><br><span class="line">                uniqueRows.<span class="title function_">push</span>(row);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> uniqueRows;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h4 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">斐波那契数列的定义是</span><br><span class="line">    F(0) = 0</span><br><span class="line">    F(1) = 1</span><br><span class="line">    对于 n &gt;= 2，F(n) = F(n-1) + F(n-2)</span><br><span class="line"></span><br><span class="line">数列前几项为</span><br><span class="line">    0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...</span><br></pre></td></tr></table></figure><ul><li>解法<code>1</code>: 递归</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">按照定义，递归计算每个斐波那契数</span><br><span class="line">优点：实现简单，代码清晰</span><br><span class="line">缺点：存在大量重复计算，效率较低</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fibonacci</span>(<span class="params">n</span>):</span><br><span class="line">        <span class="keyword">if</span> n &lt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">elif</span> n == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> fibonacci(n - <span class="number">1</span>) + fibonacci(n - <span class="number">2</span>)</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">fibonacci</span>(<span class="params">n</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (n === <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">fibonacci</span>(n - <span class="number">1</span>) + <span class="title function_">fibonacci</span>(n - <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><ul><li>解法<code>2</code>: 动态规划</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">使用两个变量存储前两个数值，避免重复计算</span><br><span class="line">从 F(2) 开始循环计算，最终返回 F(n)</span><br><span class="line">优点：时间复杂度 O(n)，空间复杂度 O(1)</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fibonacci</span>(<span class="params">n</span>):</span><br><span class="line">        <span class="keyword">if</span> n &lt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">elif</span> n == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        prev2, prev1 = <span class="number">0</span>, <span class="number">1</span> <span class="comment"># 初始值</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n + <span class="number">1</span>):</span><br><span class="line">            curr = prev1 + prev2 </span><br><span class="line">            prev2 = prev1  <span class="comment"># 更新前两个数</span></span><br><span class="line">            prev1 = curr</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> prev1</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">fibonacci</span>(<span class="params">n</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (n === <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> prev2 = <span class="number">0</span>, prev1 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">const</span> curr = prev1 + prev2;</span><br><span class="line">            prev2 = prev1;</span><br><span class="line">            prev1 = curr;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> prev1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><table><thead><tr><th>方法</th><th>时间复杂度</th><th>空间复杂度</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>递归</td><td><code>O(2^n)</code></td><td><code>O(n)</code></td><td>简单易理解，适合小问题</td><td>性能差，大量重复计算</td></tr><tr><td>动态规划优化空间</td><td><code>O(n)</code></td><td><code>O(1)</code></td><td>高效，占用空间少</td><td>不保存所有中间结果</td></tr><tr><td>通用迭代</td><td><code>O(n)</code></td><td><code>O(n)</code></td><td>清晰直观，适合扩展</td><td>占用更多空间</td></tr></tbody></table><hr><h4 id="整数反转"><a href="#整数反转" class="headerlink" title="整数反转"></a>整数反转</h4><blockquote><p><a href="https://leetcode.com/problems/reverse-integer/">Leetcode 7. Reverse Integer</a></p></blockquote><ul><li>题目: 给定一个<code>32</code>位有符号整数<code>x</code>，将其数字部分反转<ul><li>如果反转后整数溢出（不在<code>[-2^31, 2^31 - 1]</code>范围内），返回<code>0</code></li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: x = 123</span><br><span class="line">Output: 321</span><br></pre></td></tr></table></figure><ul><li>解法: 逐位反转</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 记录整数的符号（正或负），然后将整数取绝对值，方便处理</span><br><span class="line">2. 通过 取余操作 获取最后一位数字，将其添加到结果中</span><br><span class="line">    - 每次更新结果为 res = res * 10 + digit</span><br><span class="line">    - 再通过整除去掉最后一位数字</span><br><span class="line">3. 反转后乘以原始符号恢复符号</span><br><span class="line">4. 检查是否超出 32 位整数范围，如果超出返回 0</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverse</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 定义 32 位整数范围</span></span><br><span class="line">        INT_MIN, INT_MAX = -(<span class="number">2</span>**<span class="number">31</span>), <span class="number">2</span>**<span class="number">31</span> - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        result = <span class="number">0</span></span><br><span class="line">        sign = -<span class="number">1</span> <span class="keyword">if</span> x &lt; <span class="number">0</span> <span class="keyword">else</span> <span class="number">1</span> <span class="comment"># 记录符号</span></span><br><span class="line">        x = <span class="built_in">abs</span>(x)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> x != <span class="number">0</span>:</span><br><span class="line">            digit = x % <span class="number">10</span> <span class="comment"># 取出最后一位数字</span></span><br><span class="line">            result = result * <span class="number">10</span> + digit <span class="comment"># 更新结果</span></span><br><span class="line">            x //= <span class="number">10</span> <span class="comment"># 去掉最后一位</span></span><br><span class="line"></span><br><span class="line">        result *= sign <span class="comment"># 恢复符号</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> result &lt; INT_MIN <span class="keyword">or</span> result &gt; INT_MAX:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">reverse</span>(<span class="params">x</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="variable constant_">INT_MIN</span> = -(<span class="number">2</span> ** <span class="number">31</span>);</span><br><span class="line">        <span class="keyword">const</span> <span class="variable constant_">INT_MAX</span> = <span class="number">2</span> ** <span class="number">31</span> - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">const</span> sign = x &lt; <span class="number">0</span> ? -<span class="number">1</span> : <span class="number">1</span>;</span><br><span class="line">        x = <span class="title class_">Math</span>.<span class="title function_">abs</span>(x);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (x !== <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> digit = x % <span class="number">10</span>; <span class="comment">// 取出最后一位数字</span></span><br><span class="line">            result = result * <span class="number">10</span> + digit; <span class="comment">// 更新结果</span></span><br><span class="line">            x = <span class="title class_">Math</span>.<span class="title function_">floor</span>(x / <span class="number">10</span>); <span class="comment">// 去掉最后一位</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        result *= sign;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (result &lt; <span class="variable constant_">INT_MIN</span> || result &gt; <span class="variable constant_">INT_MAX</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h4 id="位1的个数"><a href="#位1的个数" class="headerlink" title="位1的个数"></a>位<code>1</code>的个数</h4><blockquote><p><a href="https://leetcode.com/problems/number-of-1-bits/">Leetcode 191. Number of 1 Bits</a></p></blockquote><ul><li>题目: 给定一个无符号整数，返回其二进制表示中<code>1</code>的个数（也称为汉明权重）</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: n = 11 (二进制表示为 00000000000000000000000000001011)</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: 11 的二进制表示有三个 1</span><br></pre></td></tr></table></figure><ul><li>解法: 位操作</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 使用按位与 (n &amp; (n - 1)) 消除最低位的 1，直到 n 为 0，统计次数</span><br></pre></td></tr></table></figure><div class="tabs" id="mytabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#mytabs-1">Python</button></li><li class="tab"><button type="button" data-href="#mytabs-2">Javascript</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="mytabs-1"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hammingWeight</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> n:</span><br><span class="line">            n &amp;= n - <span class="number">1</span> <span class="comment"># 每次消除最低位的 1</span></span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="mytabs-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="title function_">hammingWeight</span>(<span class="params">n</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n !== <span class="number">0</span>) &#123;</span><br><span class="line">            n &amp;= n - <span class="number">1</span>; <span class="comment">// 每次消除最低位的 1</span></span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><ul><li>快速排序是一种基于分治思想的高效排序算法，平均时间复杂度为<code>O(n log n)</code>，最坏情况下时间复杂度为 <code>O(n^2)</code>。它的基本思想是通过一次排序将待排序数组分割成独立的两部分，其中一部分的所有元素都比另一部分的所有元素小，然后对这两部分分别进行递归排序。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">quicksort</span>(<span class="params">arr</span>):</span><br><span class="line">    <span class="comment"># 基本条件：如果数组为空或只有一个元素，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(arr) &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> arr</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 选择基准元素</span></span><br><span class="line">    pivot = arr[<span class="built_in">len</span>(arr) // <span class="number">2</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 将数组分成三个部分：小于基准的部分、等于基准的部分、大于基准的部分</span></span><br><span class="line">    left = [x <span class="keyword">for</span> x <span class="keyword">in</span> arr <span class="keyword">if</span> x &lt; pivot]</span><br><span class="line">    middle = [x <span class="keyword">for</span> x <span class="keyword">in</span> arr <span class="keyword">if</span> x == pivot]</span><br><span class="line">    right = [x <span class="keyword">for</span> x <span class="keyword">in</span> arr <span class="keyword">if</span> x &gt; pivot]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 递归排序左右两部分</span></span><br><span class="line">    <span class="keyword">return</span> quicksort(left) + middle + quicksort(right)</span><br></pre></td></tr></table></figure><hr><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><ul><li>冒泡排序是一种简单的排序算法，它通过重复遍历列表，将相邻的元素进行比较并交换，使得每次遍历后最大（或最小）的元素逐步“冒泡”到列表的末尾。冒泡排序的时间复杂度为<code>O(n²)</code>，适用于小规模数据的排序。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">bubble_sort</span>(<span class="params">arr</span>):</span><br><span class="line">    n = <span class="built_in">len</span>(arr)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 外层循环控制遍历次数</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        swapped = <span class="literal">False</span>  <span class="comment"># 用来标记是否发生交换</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 内层循环进行相邻元素的比较和交换</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, n - i - <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> arr[j] &gt; arr[j + <span class="number">1</span>]:</span><br><span class="line">                <span class="comment"># 交换相邻元素</span></span><br><span class="line">                arr[j], arr[j + <span class="number">1</span>] = arr[j + <span class="number">1</span>], arr[j]</span><br><span class="line">                swapped = <span class="literal">True</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 如果没有发生交换，说明数组已经排序完毕</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> swapped:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> arr</span><br></pre></td></tr></table></figure><hr><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><ul><li>插入排序是一种简单直观的排序算法，适合处理小规模数据。它的工作原理是构建一个有序序列，对于未排序的数据，在已排序的序列中从后向前扫描，找到相应位置并插入。插入排序的时间复杂度为<code>O(n²)</code>，在数组几乎有序的情况下表现很好，接近<code>O(n)</code>。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">insertion_sort</span>(<span class="params">arr</span>):</span><br><span class="line">    <span class="comment"># 从第二个元素开始遍历</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(arr)):</span><br><span class="line">        key = arr[i]  <span class="comment"># 当前待插入的元素</span></span><br><span class="line">        j = i - <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 向前遍历已排序的序列，找到适合的位置插入当前元素</span></span><br><span class="line">        <span class="keyword">while</span> j &gt;= <span class="number">0</span> <span class="keyword">and</span> arr[j] &gt; key:</span><br><span class="line">            arr[j + <span class="number">1</span>] = arr[j]  <span class="comment"># 将大于 key 的元素向后移动</span></span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        arr[j + <span class="number">1</span>] = key  <span class="comment"># 将当前元素插入到正确的位置</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> arr</span><br></pre></td></tr></table></figure><hr><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><ul><li>归并排序是一种经典的分治算法，通过将数组递归地分成两个子数组，分别进行排序，然后合并这两个有序子数组来实现排序。归并排序的时间复杂度为<code>O(n log n)</code>，它具有稳定性且适用于大规模数据的排序。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">merge_sort</span>(<span class="params">arr</span>):</span><br><span class="line">    <span class="comment"># 如果数组长度小于等于1，则直接返回</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(arr) &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> arr</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 分割数组</span></span><br><span class="line">    mid = <span class="built_in">len</span>(arr) // <span class="number">2</span></span><br><span class="line">    left_half = merge_sort(arr[:mid])</span><br><span class="line">    right_half = merge_sort(arr[mid:])</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 合并两个已排序的子数组</span></span><br><span class="line">    <span class="keyword">return</span> merge(left_half, right_half)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">merge</span>(<span class="params">left, right</span>):</span><br><span class="line">    sorted_array = []</span><br><span class="line">    i = j = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 逐步比较两个子数组中的元素，按顺序合并</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(left) <span class="keyword">and</span> j &lt; <span class="built_in">len</span>(right):</span><br><span class="line">        <span class="keyword">if</span> left[i] &lt; right[j]:</span><br><span class="line">            sorted_array.append(left[i])</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            sorted_array.append(right[j])</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 将剩余的元素加入合并结果</span></span><br><span class="line">    sorted_array.extend(left[i:])</span><br><span class="line">    sorted_array.extend(right[j:])</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> sorted_array</span><br></pre></td></tr></table></figure><hr><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><ul><li>堆排序是一种基于二叉堆的数据结构的比较排序算法，时间复杂度为<code>O(n log n)</code>。堆排序分为最大堆和最小堆，通常使用最大堆来进行升序排序。堆排序具有原地排序的特点，不需要额外的存储空间。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">heapify</span>(<span class="params">arr, n, i</span>):</span><br><span class="line">    largest = i  <span class="comment"># 设当前节点 i 为最大</span></span><br><span class="line">    left = <span class="number">2</span> * i + <span class="number">1</span>  <span class="comment"># 左子节点</span></span><br><span class="line">    right = <span class="number">2</span> * i + <span class="number">2</span>  <span class="comment"># 右子节点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 如果左子节点存在，且大于当前最大值</span></span><br><span class="line">    <span class="keyword">if</span> left &lt; n <span class="keyword">and</span> arr[left] &gt; arr[largest]:</span><br><span class="line">        largest = left</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 如果右子节点存在，且大于当前最大值</span></span><br><span class="line">    <span class="keyword">if</span> right &lt; n <span class="keyword">and</span> arr[right] &gt; arr[largest]:</span><br><span class="line">        largest = right</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 如果最大值不是当前节点，进行交换并继续调整堆</span></span><br><span class="line">    <span class="keyword">if</span> largest != i:</span><br><span class="line">        arr[i], arr[largest] = arr[largest], arr[i]</span><br><span class="line">        heapify(arr, n, largest)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">heap_sort</span>(<span class="params">arr</span>):</span><br><span class="line">    n = <span class="built_in">len</span>(arr)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 构建最大堆</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n // <span class="number">2</span> - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">        heapify(arr, n, i)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 交换元素，并重新调整堆结构</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n - <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>):</span><br><span class="line">        arr[i], arr[<span class="number">0</span>] = arr[<span class="number">0</span>], arr[i]  <span class="comment"># 将堆顶元素移到数组末尾</span></span><br><span class="line">        heapify(arr, i, <span class="number">0</span>)  <span class="comment"># 调整剩下的部分为最大堆</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> arr</span><br></pre></td></tr></table></figure><hr><h3 id="深度优先搜索-DFS-amp-广度优先搜索-BFS"><a href="#深度优先搜索-DFS-amp-广度优先搜索-BFS" class="headerlink" title="深度优先搜索 (DFS) &amp; 广度优先搜索 (BFS)"></a>深度优先搜索 (DFS) &amp; 广度优先搜索 (BFS)</h3><ul><li>深度优先搜索: <code>DFS</code>是一种通过深入每一个节点并尽可能深地搜索其子节点的遍历算法。可以使用递归或显式栈来实现。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">dfs_recursive</span>(<span class="params">graph, node, visited=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="keyword">if</span> visited <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        visited = <span class="built_in">set</span>()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 访问当前节点</span></span><br><span class="line">    <span class="built_in">print</span>(node)</span><br><span class="line">    visited.add(node)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 递归访问相邻节点</span></span><br><span class="line">    <span class="keyword">for</span> neighbor <span class="keyword">in</span> graph[node]:</span><br><span class="line">        <span class="keyword">if</span> neighbor <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">            dfs_recursive(graph, neighbor, visited)</span><br></pre></td></tr></table></figure><ul><li>广度优先搜索: <code>BFS</code>是一种逐层遍历算法，先访问当前节点的所有相邻节点，再继续访问这些相邻节点的相邻节点。<code>BFS</code>通常用队列来实现。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">bfs</span>(<span class="params">graph, start</span>):</span><br><span class="line">    visited = <span class="built_in">set</span>()</span><br><span class="line">    queue = deque([start])  <span class="comment"># 使用双端队列作为队列</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> queue:</span><br><span class="line">        node = queue.popleft()  <span class="comment"># 从队列中取出第一个节点</span></span><br><span class="line">        <span class="keyword">if</span> node <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">            <span class="built_in">print</span>(node)</span><br><span class="line">            visited.add(node)</span><br><span class="line">            <span class="comment"># 将相邻节点加入队列</span></span><br><span class="line">            queue.extend(graph[node])</span><br></pre></td></tr></table></figure><hr><h3 id="前序，中序，后序"><a href="#前序，中序，后序" class="headerlink" title="前序，中序，后序"></a>前序，中序，后序</h3><ul><li>前序遍历顺序为：根节点 -&gt; 左子树 -&gt; 右子树</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">preorder</span>(<span class="params">root</span>):</span><br><span class="line">    <span class="keyword">if</span> root:</span><br><span class="line">        <span class="built_in">print</span>(root.val)  <span class="comment"># 先访问根节点</span></span><br><span class="line">        preorder(root.left)  <span class="comment"># 递归访问左子树</span></span><br><span class="line">        preorder(root.right)  <span class="comment"># 递归访问右子树</span></span><br></pre></td></tr></table></figure><ul><li>中序遍历顺序为：左子树 -&gt; 根节点 -&gt; 右子树</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">inorder</span>(<span class="params">root</span>):</span><br><span class="line">    <span class="keyword">if</span> root:</span><br><span class="line">        inorder(root.left)  <span class="comment"># 递归访问左子树</span></span><br><span class="line">        <span class="built_in">print</span>(root.val)  <span class="comment"># 访问根节点</span></span><br><span class="line">        inorder(root.right)  <span class="comment"># 递归访问右子树</span></span><br></pre></td></tr></table></figure><ul><li>后序遍历顺序为：左子树 -&gt; 右子树 -&gt; 根节点</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">postorder</span>(<span class="params">root</span>):</span><br><span class="line">    <span class="keyword">if</span> root:</span><br><span class="line">        postorder(root.left)  <span class="comment"># 递归访问左子树</span></span><br><span class="line">        postorder(root.right)  <span class="comment"># 递归访问右子树</span></span><br><span class="line">        <span class="built_in">print</span>(root.val)  <span class="comment"># 最后访问根节点</span></span><br></pre></td></tr></table></figure><hr>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>前端面试笔记</title>
      <link href="/posts/c7d67744.html"/>
      <url>/posts/c7d67744.html</url>
      
        <content type="html"><![CDATA[<h3 id="1-CSS-题目"><a href="#1-CSS-题目" class="headerlink" title="1. CSS 题目"></a>1. CSS 题目</h3><h4 id="1-1-画等腰直角三角形"><a href="#1-1-画等腰直角三角形" class="headerlink" title="1.1 画等腰直角三角形"></a>1.1 画等腰直角三角形</h4><ul><li><p>这题是美团前端面试一面题: <a href="https://juejin.cn/post/6950081305560219679?searchId=202410130111434E030964573D8F88A42E">参考链接</a></p></li><li><p>第一种方法: 使用<code>boarder</code></p></li></ul><iframe width="100%" height="300" src="//jsfiddle.net/HDL52/mojg3tqL/13/embedded/html,css,result/dark/" frameborder="0" loading="lazy" allowtransparency="true" allowfullscreen="true"></iframe><ul><li>第二种方法: 使用<code>linear-gradient</code></li></ul><iframe width="100%" height="300" src="//jsfiddle.net/HDL52/uwykmf1a/4/embedded/html,css,result/dark/" frameborder="0" loading="lazy" allowtransparency="true" allowfullscreen="true"></iframe><ul><li>第三种方法: 使用<code>clip-path</code></li></ul><iframe width="100%" height="300" src="//jsfiddle.net/HDL52/7eowjy52/15/embedded/html,css,result/dark/" frameborder="0" loading="lazy" allowtransparency="true" allowfullscreen="true"></iframe><hr><h4 id="1-2-不定宽高水平垂直居中"><a href="#1-2-不定宽高水平垂直居中" class="headerlink" title="1.2 不定宽高水平垂直居中"></a>1.2 不定宽高水平垂直居中</h4><ul><li>第一种方法: 使用<code>Flexbox</code> (也可以父元素是<code>flex</code>然后子元素<code>margin:auto</code>)</li></ul><iframe width="100%" height="300" src="//jsfiddle.net/HDL52/9fa0m5rg/14/embedded/html,css,result/dark/" frameborder="0" loading="lazy" allowtransparency="true" allowfullscreen="true"></iframe><ul><li>第二种方法: 使用<code>Grid</code></li></ul><iframe width="100%" height="300" src="//jsfiddle.net/HDL52/0b2oduje/4/embedded/html,css,result/dark/" frameborder="0" loading="lazy" allowtransparency="true" allowfullscreen="true"></iframe><ul><li>第三种方法: 绝对定位 + <code>transform</code></li></ul><iframe width="100%" height="300" src="//jsfiddle.net/HDL52/u1e7a2mv/5/embedded/html,css,result/dark/" frameborder="0" loading="lazy" allowtransparency="true" allowfullscreen="true"></iframe><hr><h4 id="1-3-正方形子元素"><a href="#1-3-正方形子元素" class="headerlink" title="1.3 正方形子元素"></a>1.3 正方形子元素</h4><ul><li>这题是字节跳动一面题: 父元素的宽高不固定，并且可以随窗口变形，而子元素必须保持正方形 (只能使用<code>CSS</code>)<ul><li>解决方案: 子元素使用百分比宽度并使用<code>aspect-ratio</code>属性来保持子元素的正方形比例</li></ul></li></ul><iframe width="100%" height="300" src="//jsfiddle.net/HDL52/qy79su82/27/embedded/html,css,result/dark/" frameborder="0" loading="lazy" allowtransparency="true" allowfullscreen="true"></iframe><hr><h4 id="1-4-position-定位"><a href="#1-4-position-定位" class="headerlink" title="1.4 position 定位"></a>1.4 position 定位</h4><ul><li><p><code>position: static</code>（默认定位）: 所有元素的默认定位方式。元素按照正常的文档流排列，不会受<code>top</code>、<code>right</code>、<code>bottom</code>或<code>left</code>等属性的影响</p></li><li><p><code>position: relative</code>（相对定位）: 相对于元素自身的原始位置进行定位，但可以通过<code>top</code>、<code>right</code>、<code>bottom</code>、<code>left</code>等属性调整元素的相对位置</p></li></ul><iframe width="100%" height="300" src="//jsfiddle.net/HDL52/5qb29Lzg/2/embedded/html,css,result/dark/" frameborder="0" loading="lazy" allowtransparency="true" allowfullscreen="true"></iframe><ul><li><code>position: absolute</code>（绝对定位）: 相对于最近的非<code>static</code>定位的父元素进行定位。如果没有非<code>static</code>的父元素，则相对于文档的根元素（通常是<code>&lt;html&gt;</code>或<code>&lt;body&gt;</code>）进行定位</li></ul><iframe width="100%" height="300" src="//jsfiddle.net/HDL52/3jmu7q8a/7/embedded/html,css,result/dark/" frameborder="0" loading="lazy" allowtransparency="true" allowfullscreen="true"></iframe><ul><li><p><code>position: fixed</code>（固定定位）: 相对于浏览器窗口进行定位，无论页面如何滚动，元素始终保持在浏览器窗口中的固定位置</p></li><li><p><code>position: sticky</code>（粘性定位）: 结合了<code>relative</code>和<code>fixed</code>的特性。元素一开始是相对于文档流定位的（<code>relative</code>），当页面滚动到某个阈值时，元素会变为固定定位（<code>fixed</code>）</p><ul><li>父元素不能<code>overflow:hidden</code>或者<code>overflow:auto</code>属性</li><li>必须指定<code>top</code>、<code>bottom</code>、<code>left</code>、<code>right</code>四个值之一，否则只会处于相对定位</li></ul></li></ul><iframe width="100%" height="300" src="//jsfiddle.net/HDL52/ybk3o9Lu/23/embedded/html,css,result/dark/" frameborder="0" loading="lazy" allowtransparency="true" allowfullscreen="true"></iframe><hr><h4 id="1-5-盒模型"><a href="#1-5-盒模型" class="headerlink" title="1.5 盒模型"></a>1.5 盒模型</h4><p>盒模型分为<code>IE</code>盒模型和<code>W3C</code>标准盒模型</p><ul><li>在标准盒模型下，一个块的总宽度 &#x3D; <code>width + margin(左右) + padding(左右) + border(左右)</code></li><li>在<code>IE</code>盒模型下，一个块的总宽度 &#x3D; <code>width + margin(左右)</code>（即<code>width</code>已经包含了<code>padding</code>和<code>border</code>值）</li></ul><blockquote><p>当设置<code>box-sizing:content-box</code>时，采用标准盒模型计算，也是默认模式<br>当设置<code>box-sizing:border-box</code>时，采用<code>IE</code>盒模型计算</p></blockquote><ul><li><code>JS</code>如何获取盒模型对应的宽和高<ul><li><code>window.getComputedStyle(dom).width/height</code>: 取到的是最终渲染后的宽和高</li><li><code>dom.getBoundingClientRect().width/height</code>: 得到渲染后的宽和高，还可以取到相对于视窗的上下左右的距离</li><li><code>dom.offsetWidth/offsetHeight</code>: 包括高度（宽度）、内边距和边框，不包括外边距 (兼容性最好)</li></ul></li></ul><hr><h4 id="1-6-CSS-实现扇形"><a href="#1-6-CSS-实现扇形" class="headerlink" title="1.6 CSS 实现扇形"></a>1.6 CSS 实现扇形</h4><hr><h4 id="1-7-BFC"><a href="#1-7-BFC" class="headerlink" title="1.7 BFC"></a>1.7 BFC</h4><ul><li><code>BFC</code>是<code>CSS</code>布局的一个概念，是一块独立的渲染区域，是一个环境，里面的元素不会影响到外部的元素</li></ul><hr><h3 id="2-JS-题目"><a href="#2-JS-题目" class="headerlink" title="2. JS 题目"></a>2. JS 题目</h3><h4 id="2-1-var-与循环"><a href="#2-1-var-与循环" class="headerlink" title="2.1 var 与循环"></a>2.1 var 与循环</h4><ul><li>字节跳动一面的题目</li><li>下面循环的最终结果是什么，<code>i</code>的最终值是什么，<code>i</code>在循环结束后的值是什么</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>这个循环将会输出<code>0 1 2 3 4</code>，<code>i</code>的最终值为<code>5</code></p></li><li><p>由于<code>var</code>声明的变量在整个函数（或全局范围内）都是共享的，它不受块作用域的限制。因此，<code>i</code>在整个函数或脚本范围内是可见的。换句话说，<code>i</code>仍然在循环结束后存在并且可以访问</p></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(i), <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>这个循环将会输出<code>5 5 5 5 5</code>，<code>i</code>的最终值为<code>5</code></li><li>由于<code>var</code>是函数级作用域，所有的<code>setTimeout</code>回调函数在执行时访问的都是同一个<code>i</code>，即循环结束时的<code>i</code>值<code>5</code>。因为<code>setTimeout</code>是异步的，它会在<code>1</code>秒后执行，此时循环早已结束，<code>i</code>已经被更新为<code>5</code></li><li>解决方案: 使用<code>let</code>或闭包可以解决这个问题，确保每次迭代时<code>i</code>的值是独立的</li></ul><hr><h4 id="2-2-手写倒计时"><a href="#2-2-手写倒计时" class="headerlink" title="2.2 手写倒计时"></a>2.2 手写倒计时</h4><ul><li><p>美团一面的题目</p></li><li><p>手写一个倒计时函数，要求输出<code>5 4 3 2 1</code>，每隔一分钟输出一个值</p></li><li><p>方法一: 使用<code>setInterval</code></p><ul><li><code>setInterval</code>会在指定的时间间隔内反复执行一个函数，直到手动清除这个定时器</li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">countdown</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">const</span> intervalId = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(count);</span><br><span class="line">        count--;</span><br><span class="line">        <span class="keyword">if</span> (count === <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">clearInterval</span>(intervalId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="number">60000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">countdown</span>();</span><br></pre></td></tr></table></figure><ul><li>方法二: 使用<code>Generator</code>函数<ul><li>使用<code>Generator</code>函数可以通过<code>yield</code>暂停和恢复函数的执行，结合<code>setTimeout</code>来实现倒计时</li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">countdownGenerator</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">while</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">yield</span> count;</span><br><span class="line">        count--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">countdown</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> generator = <span class="title function_">countdownGenerator</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">nextCountdown</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; value, done &#125; = generator.<span class="title function_">next</span>();</span><br><span class="line">        <span class="keyword">if</span> (!done) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">            <span class="built_in">setTimeout</span>(nextCountdown, <span class="number">60000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">nextCountdown</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">countdown</span>();</span><br></pre></td></tr></table></figure><hr><h4 id="2-3-防抖和节流"><a href="#2-3-防抖和节流" class="headerlink" title="2.3 防抖和节流"></a>2.3 防抖和节流</h4><ul><li><p>可以使用类似<code>loadash</code>这种库来实现</p></li><li><p>防抖 <code>Debounce</code></p><ul><li>防抖是指在事件被触发<code>n</code>秒后在执行回调，如果在这<code>n</code>秒内时间又被触发，则重新计时</li><li>可以使用在一些点击请求的事件上，避免因为用户的多次点击向后端发送多次请求</li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">fn, delay = <span class="number">500</span></span>) &#123;</span><br><span class="line">    <span class="comment">// 通过闭包缓存一个定时器 id</span></span><br><span class="line">    <span class="keyword">let</span> timer = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果已经设定过定时器就清空上一次的定时器</span></span><br><span class="line">        <span class="keyword">if</span> (timer) <span class="built_in">clearTimeout</span>(timer)</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 开始设定一个新的定时器，定时器结束后执行传入的函数 fn</span></span><br><span class="line">        <span class="comment">// 这里必须是箭头函数，不然 this 指向 window，要让 this 就指向 fn 的调用者</span></span><br><span class="line">        timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123; </span><br><span class="line">            fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args)</span><br><span class="line">        &#125;, delay)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行 debounce 函数返回新函数</span></span><br><span class="line"><span class="keyword">const</span> betterFn = <span class="title function_">debounce</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;fn 防抖执行了&#x27;</span>), <span class="number">1000</span>)</span><br><span class="line"><span class="comment">// 停止滑动 1 秒后执行函数 () =&gt; console.log(&#x27;fn 防抖执行了&#x27;)</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;scroll&#x27;</span>, betterFn)</span><br></pre></td></tr></table></figure><blockquote><p>防抖函数分为非立即执行版和立即执行版，需要根据不同的场景来决定需要使用哪一个版本的防抖函数</p></blockquote><ul><li>节流 <code>Throttle</code><ul><li>节流就是一定时间内执行一次事件，即使重复触发，也只有一次生效</li><li>可以使用在监听滚动<code>scroll</code>事件上，通过事件节流来降低事件调用的频率</li></ul></li></ul><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">时间戳版本</button></li><li class="tab"><button type="button" data-href="#test-2">定时器版本</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">throttle</span> = (<span class="params">fn, delay = <span class="number">500</span></span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 上一次执行 fn 的时间</span></span><br><span class="line">  <span class="keyword">let</span> prev = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">    <span class="comment">// 获取当前时间，转换成时间戳，单位毫秒</span></span><br><span class="line">    <span class="keyword">let</span> now = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line">    <span class="comment">// 如果差值大于等于设置的等待时间就执行函数</span></span><br><span class="line">    <span class="keyword">if</span> (now - prev &gt;= delay) &#123;</span><br><span class="line">      fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args);</span><br><span class="line">      prev = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行 throttle 函数返回新函数</span></span><br><span class="line"><span class="keyword">const</span> betterFn = <span class="title function_">throttle</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;fn 函数执行了&#x27;</span>), <span class="number">1000</span>)</span><br><span class="line"><span class="comment">// 每 10 毫秒执行一次 betterFn 函数，但是只有时间差大于 1s 时才会执行 fn</span></span><br><span class="line"><span class="built_in">setInterval</span>(betterFn, <span class="number">10</span>)</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">throttle</span> = (<span class="params">fn, delay = <span class="number">500</span></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> timer = <span class="literal">null</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (timer) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args);</span><br><span class="line">      <span class="comment">// 执行完后，需重置定时器，不然 timer 一直有值，无法开启下一个定时器</span></span><br><span class="line">      timer = <span class="literal">null</span>;</span><br><span class="line">    &#125;, delay)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><blockquote><p>对于节流，一般有两种方式可以实现，分别是时间戳版和定时器版。时间戳版的函数触发是在时间段内开始的时候，而定时器版的函数触发是在时间段内结束的时候</p></blockquote><hr><h4 id="2-4-undefined-与-null-的区别"><a href="#2-4-undefined-与-null-的区别" class="headerlink" title="2.4 undefined 与 null 的区别"></a>2.4 undefined 与 null 的区别</h4><ul><li><code>undefined</code>表示”缺少值”，就是此处应该有一个值，但是还没有定义</li><li><code>null</code>表示”没有对象”，即该处不应该有值</li></ul><hr><h4 id="2-5-浅拷贝和深拷贝"><a href="#2-5-浅拷贝和深拷贝" class="headerlink" title="2.5 浅拷贝和深拷贝"></a>2.5 浅拷贝和深拷贝</h4><ul><li>浅拷贝<ul><li>浅拷贝是创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝</li><li>如果属性是基本类型，拷贝的就是基本类型的值，如果属性是引用类型，拷贝的就是内存地址，所以如果其中一个对象改变了这个地址，就会影响到另一个对象</li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">shallowCopy</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="comment">// 只拷贝对象，基本类型或 null 直接返回</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="string">&#x27;object&#x27;</span> || object === <span class="literal">null</span>)</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断是新建一个数组还是对象</span></span><br><span class="line">  <span class="keyword">let</span> newObj = <span class="title class_">Array</span>.<span class="title function_">isArray</span>(obj) ? [] : &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="comment">// hasOwnProperty 判断是否是对象自身属性，会忽略从原型链上继承的属性</span></span><br><span class="line">    <span class="keyword">if</span> (obj.<span class="title function_">hasOwnProperty</span>(key))</span><br><span class="line">      newObj[key] = obj[key]; <span class="comment">// 只拷贝对象本身的属性</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> newObj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试</span></span><br><span class="line"><span class="keyword">var</span> obj =&#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&#x27;张三&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>:<span class="number">8</span>,</span><br><span class="line">    <span class="attr">pal</span>:[<span class="string">&#x27;王五&#x27;</span>,<span class="string">&#x27;王六&#x27;</span>,<span class="string">&#x27;王七&#x27;</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj2 = <span class="title function_">shallowCopy</span>(obj);</span><br><span class="line">obj2.<span class="property">name</span> = <span class="string">&#x27;李四&#x27;</span></span><br><span class="line">obj2.<span class="property">pal</span>[<span class="number">0</span>] = <span class="string">&#x27;王麻子&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj); <span class="comment">//&#123;age: 8, name: &quot;张三&quot;, pal: [&#x27;王麻子&#x27;, &#x27;王六&#x27;, &#x27;王七&#x27;]&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj2); <span class="comment">//&#123;age: 8, name: &quot;李四&quot;, pal: [&#x27;王麻子&#x27;, &#x27;王六&#x27;, &#x27;王七&#x27;]&#125;</span></span><br></pre></td></tr></table></figure><ul><li>深拷贝<ul><li>深拷贝是将一个对象从内存中完整的拷贝一份出来，从堆内存中开辟一个新的区域存放新对象，且修改新对象不会影响原对象</li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">deepCopy</span>(<span class="params">obj, map = <span class="keyword">new</span> <span class="built_in">WeakMap</span>()</span>) &#123;</span><br><span class="line">  <span class="comment">// 基本类型或 null 直接返回</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="string">&#x27;object&#x27;</span> || obj === <span class="literal">null</span>)</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断是新建一个数组还是对象</span></span><br><span class="line">  <span class="keyword">let</span> newObj = <span class="title class_">Array</span>.<span class="title function_">isArray</span>(obj) ? [] : &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 利用 map 解决循环引用</span></span><br><span class="line">  <span class="keyword">if</span> (map.<span class="title function_">has</span>(obj))</span><br><span class="line">    <span class="keyword">return</span> map.<span class="title function_">get</span>(obj);</span><br><span class="line"></span><br><span class="line">  map.<span class="title function_">set</span>(obj, newObj); <span class="comment">// 将当前对象作为 key，克隆对象作为 value</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> obj) &#123;</span><br><span class="line">    <span class="keyword">if</span> (obj.<span class="title function_">hasOwnProperty</span>(key))</span><br><span class="line">      newObj[key] = <span class="title function_">deepCopy</span>(object[key], map); <span class="comment">// 递归</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> newObj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="keyword">let</span> obj1 = &#123;</span><br><span class="line">    name : <span class="string">&#x27;AK、哒哒哒&#x27;</span>,</span><br><span class="line">    arr : [<span class="number">1</span>,[<span class="number">2</span>,<span class="number">3</span>],<span class="number">4</span>],</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> obj2=<span class="title function_">deepCopy</span>(obj1)</span><br><span class="line">obj2.<span class="property">name</span> = <span class="string">&quot;哒哒哒&quot;</span>;</span><br><span class="line">obj2.<span class="property">arr</span>[<span class="number">1</span>] = [<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>] ; <span class="comment">// 新对象跟原对象不共享内存</span></span><br><span class="line"> </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;obj1&#x27;</span>,obj1) <span class="comment">// obj1 &#123; name: &#x27;AK、哒哒哒&#x27;, arr: [ 1, [ 2, 3 ], 4 ] &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;obj2&#x27;</span>,obj2) <span class="comment">// obj2 &#123; name: &#x27;哒哒哒&#x27;, arr: [ 1, [ 5, 6, 7 ], 4 ] &#125;</span></span><br></pre></td></tr></table></figure><hr><h4 id="2-6-函数柯里化"><a href="#2-6-函数柯里化" class="headerlink" title="2.6 函数柯里化"></a>2.6 函数柯里化</h4><ul><li>在数学和计算机科学中，柯里化是一种将使用多个参数的一个函数转换成一系列使用一个参数的函数的技术</li></ul><blockquote><p>柯里化实际是把简单的问题复杂化，但是复杂化的同时，在使用函数时拥有了更加多的自由度。而对于函数参数的自由处理，正是柯里化的核心所在。柯里化本质上是降低通用性，提高适用性</p></blockquote><ul><li>参数定长的柯里化<ul><li>假设存在一个原函数<code>fn</code>，<code>fn</code>接受三个参数<code>a, b, c</code>，那么函数<code>fn</code>最多被柯里化三次</li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">curry</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">  <span class="comment">// 获取原函数的参数长度</span></span><br><span class="line">  <span class="keyword">const</span> argLen = fn.<span class="property">length</span>;</span><br><span class="line">  <span class="comment">// 保存预置参数</span></span><br><span class="line">  <span class="keyword">const</span> presetArgs = [].<span class="property">slice</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>, <span class="number">1</span>)</span><br><span class="line">  <span class="comment">// 返回一个新函数</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 新函数调用时会继续传参</span></span><br><span class="line">    <span class="keyword">const</span> restArgs = [].<span class="property">slice</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>)</span><br><span class="line">    <span class="keyword">const</span> allArgs = [...presetArgs, ...restArgs]</span><br><span class="line">    <span class="keyword">if</span> (allArgs.<span class="property">length</span> &gt;= argLen) &#123;</span><br><span class="line">      <span class="comment">// 如果参数够了，就执行原函数</span></span><br><span class="line">      <span class="keyword">return</span> fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, allArgs)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 否则继续柯里化</span></span><br><span class="line">      <span class="keyword">return</span> curry.<span class="title function_">call</span>(<span class="literal">null</span>, fn, ...allArgs)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">a, b, c</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b + c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> curried = <span class="title function_">curry</span>(sum);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">curried</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)); <span class="comment">//6</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">curried</span>(<span class="number">1</span>, <span class="number">2</span>)(<span class="number">3</span>)); <span class="comment">//6</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">curried</span>(<span class="number">1</span>)(<span class="number">2</span>, <span class="number">3</span>)); <span class="comment">//6</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">curried</span>(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)); <span class="comment">//6</span></span><br></pre></td></tr></table></figure><ul><li>参数不定长的柯里化<ul><li>如果要支持参数不定长的场景，已经柯里化的函数在执行完毕时不能返回一个值，只能返回一个函数。同时要让<code>JS</code>引擎在解析得到的这个结果时，能求出预期的值</li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">curry</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">  <span class="comment">// 保存预置参数</span></span><br><span class="line">  <span class="keyword">const</span> presetArgs = [].<span class="property">slice</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>, <span class="number">1</span>)</span><br><span class="line">  <span class="comment">// 返回一个新函数</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">curried</span> () &#123;</span><br><span class="line">    <span class="comment">// 新函数调用时会继续传参</span></span><br><span class="line">    <span class="keyword">const</span> restArgs = [].<span class="property">slice</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>)</span><br><span class="line">    <span class="keyword">const</span> allArgs = [...presetArgs, ...restArgs]</span><br><span class="line">    <span class="keyword">return</span> curry.<span class="title function_">call</span>(<span class="literal">null</span>, fn, ...allArgs)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 重写toString</span></span><br><span class="line">  curried.<span class="property">toString</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> fn.<span class="title function_">apply</span>(<span class="literal">null</span>, presetArgs)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> curried;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">dynamicAdd</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> [...<span class="variable language_">arguments</span>].<span class="title function_">reduce</span>(<span class="function">(<span class="params">prev, curr</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> prev + curr</span><br><span class="line">  &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> add = <span class="title function_">curry</span>(dynamicAdd);</span><br><span class="line"><span class="title function_">add</span>(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)(<span class="number">4</span>) <span class="comment">// 10</span></span><br><span class="line"><span class="title function_">add</span>(<span class="number">1</span>, <span class="number">2</span>)(<span class="number">3</span>, <span class="number">4</span>)(<span class="number">5</span>, <span class="number">6</span>) <span class="comment">// 21</span></span><br></pre></td></tr></table></figure><hr><h4 id="2-7-数组扁平化"><a href="#2-7-数组扁平化" class="headerlink" title="2.7 数组扁平化"></a>2.7 数组扁平化</h4><blockquote><p>实现扁平化的方法，封装<code>flatten</code><br>已有多级嵌套数组<code>[1, [2, [3, [4, 5]]], 6]</code> 将其扁平化处理，输出<code>[1,2,3,4,5,6]</code></p></blockquote><ul><li><code>ES6 flat</code><ul><li><code>flat(depth)</code>方法会按照一个可指定的深度递归遍历数组，并将所有元素与遍历到的子数组中的元素合并为一个新数组返回。使用<code>Infinity</code>，可展开任意深度的嵌套数组</li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, [<span class="number">2</span>, [<span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>]]], <span class="number">6</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">flatten</span>(<span class="params">params</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> params.<span class="title function_">flat</span>(<span class="title class_">Infinity</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">flatten</span>(arr));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出: [1,2,3,4,5,6]</span></span><br></pre></td></tr></table></figure><blockquote><p>⭐ 直接使用自带的方法可以很快的实现, 但是面试官当然不希望就看到这些呀</p></blockquote><ul><li>循环递归<ul><li>循环判断数组的每一项是否是数组<code>Array.isArray(arr[i])</code></li><li>是数组就递归调用扁平化代码<code>result = result.concat(flatten(arr[i]));</code></li><li>不是数组,直接通过<code>push</code>添加到返回值数组</li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">flatten</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> result = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(arr[i])) &#123;</span><br><span class="line">      result = result.<span class="title function_">concat</span>(<span class="title function_">flatten</span>(arr[i]));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      result.<span class="title function_">push</span>(arr[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">flatten</span>(arr));</span><br></pre></td></tr></table></figure><blockquote><p>⭐⭐⭐ 使用递归写出数组扁平化, 但是缺少控制层级关系</p></blockquote><ul><li>增加参数控制扁平化深度<ul><li>可以理解为手写<code>flat()</code>方法</li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// forEach 遍历数组会自动跳过空元素</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">eachFlat</span> = (<span class="params">arr = [], depth = <span class="number">1</span></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> result = []; <span class="comment">// 缓存递归结果</span></span><br><span class="line">  <span class="comment">// 开始递归</span></span><br><span class="line">  (<span class="keyword">function</span> <span class="title function_">flat</span>(<span class="params">arr, depth</span>) &#123;</span><br><span class="line">    <span class="comment">// forEach 会自动去除数组空位</span></span><br><span class="line">    arr.<span class="title function_">forEach</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 控制递归深度</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(item) &amp;&amp; depth &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 递归数组</span></span><br><span class="line">        <span class="title function_">flat</span>(item, depth - <span class="number">1</span>)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 缓存元素</span></span><br><span class="line">        result.<span class="title function_">push</span>(item)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)(arr, depth)</span><br><span class="line">  <span class="comment">// 返回递归结果</span></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>⭐⭐⭐⭐ 使用递归写出数组扁平化, 可以通过参数控制层级关系</p></blockquote><ul><li><code>while</code>循环+<code>some</code>方法<ul><li>通过<code>some</code>来判断数组中是否用数组, 通过<code>while</code>不断循环执行判断, 如果是数组的话可以使用拓展运算符<code>...</code>, <code>...</code>每次只能展开最外层的数组, 加上<code>contact</code>来减少嵌套层数</li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">flatten</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="keyword">while</span> (arr.<span class="title function_">some</span>(<span class="function"><span class="params">item</span>=&gt;</span> <span class="title class_">Array</span>.<span class="title function_">isArray</span>(item))) &#123;</span><br><span class="line">    arr = [].<span class="title function_">concat</span>(...arr)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">flatten</span>(arr));</span><br></pre></td></tr></table></figure><blockquote><p>⭐⭐⭐⭐ 使用<code>while</code>循环取消递归操作, 巧用<code>some</code>操作进行判断</p></blockquote><hr><h4 id="2-8-typeof-判断"><a href="#2-8-typeof-判断" class="headerlink" title="2.8 typeof 判断"></a>2.8 typeof 判断</h4><ul><li><code>typeof null</code> 是 <code>“object”</code>: 历史遗留问题</li><li><code>typeof NaN</code> 是 <code>“number”</code>: <code>NaN</code> 实际存储是一种特殊的数值类型</li><li><code>typeof Function.prototype</code> 是 <code>function</code></li></ul><table><thead><tr><th align="center">类型</th><th align="center">结果</th></tr></thead><tbody><tr><td align="center">Undefined</td><td align="center"><code>&quot;undefined&quot;</code></td></tr><tr><td align="center">Null</td><td align="center"><code>&quot;object&quot;</code></td></tr><tr><td align="center">Boolean</td><td align="center"><code>&quot;boolean&quot;</code></td></tr><tr><td align="center">Number</td><td align="center"><code>&quot;number&quot;</code></td></tr><tr><td align="center">BigInt</td><td align="center"><code>&quot;bigint&quot;</code></td></tr><tr><td align="center">String</td><td align="center"><code>&quot;string&quot;</code></td></tr><tr><td align="center">Symbol</td><td align="center"><code>&quot;symbol&quot;</code></td></tr><tr><td align="center">Function (class)</td><td align="center"><code>&quot;function&quot;</code></td></tr><tr><td align="center">其他任何对象</td><td align="center"><code>&quot;object&quot;</code></td></tr></tbody></table><hr><h4 id="2-9-事件委托优化"><a href="#2-9-事件委托优化" class="headerlink" title="2.9 事件委托优化"></a>2.9 事件委托优化</h4><ul><li>字节一面题</li></ul><blockquote><p>举个例子，比如我们需要去做<code>Event Tracking System</code>，需要去记录用户在网站内做了什么，点击了什么按钮。如果有很多个按钮，每个都绑一个点击事件性能很差，如何优化？</p></blockquote><ul><li>绑定事件到父元素<ul><li>而不是为每个子节点单独绑定事件处理程序，事件委托可以将事件处理程序绑定到公共的父元素上，然后通过事件的<code>target</code>来确定实际触发事件的子节点。</li></ul></li><li>检查目标元素<ul><li>使用事件对象的<code>event.target</code>属性来判断哪个子节点触发了事件，并根据需要处理相应的逻辑</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;ul id=&quot;parent&quot;&gt;</span><br><span class="line">  &lt;li class=&quot;child&quot;&gt;子节点 1&lt;/li&gt;</span><br><span class="line">  &lt;li class=&quot;child&quot;&gt;子节点 2&lt;/li&gt;</span><br><span class="line">  &lt;li class=&quot;child&quot;&gt;子节点 3&lt;/li&gt;</span><br><span class="line">  &lt;li class=&quot;child&quot;&gt;子节点 4&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line"></span><br><span class="line">// 使用事件委托，将点击事件绑定到父元素</span><br><span class="line">const parent = document.getElementById(&#x27;parent&#x27;);</span><br><span class="line"></span><br><span class="line">// 事件处理器绑定在父元素上</span><br><span class="line">parent.addEventListener(&#x27;click&#x27;, function (event) &#123;</span><br><span class="line">  // 通过 event.target 来判断点击的是否是目标子节点</span><br><span class="line">  if (event.target &amp;&amp; event.target.classList.contains(&#x27;child&#x27;)) &#123;</span><br><span class="line">    console.log(&#x27;点击了子节点：&#x27;, event.target.innerText);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><blockquote><p>事件委托特别适用于存在大量类似元素的场景，如列表、表格中的行、动态生成的元素等</p></blockquote><hr><h3 id="3-网络安全"><a href="#3-网络安全" class="headerlink" title="3. 网络安全"></a>3. 网络安全</h3><h4 id="3-1-跨站脚本攻击-XSS"><a href="#3-1-跨站脚本攻击-XSS" class="headerlink" title="3.1 跨站脚本攻击 XSS"></a>3.1 跨站脚本攻击 XSS</h4><ul><li><code>XSS</code>（跨站脚本攻击，<code>Cross-Site Scripting</code>）是一种安全漏洞，攻击者通过向网页注入恶意脚本，使得当用户访问受感染的页面时，恶意脚本会在用户的浏览器中执行<ul><li>防止 <code>XSS</code>攻击的关键是严格处理用户输入和输出</li><li>对用户输入进行严格验证和过滤<strong>，</strong>使用安全的框架和库</li></ul></li></ul><hr><h4 id="3-2-跨站请求伪造-CSRF"><a href="#3-2-跨站请求伪造-CSRF" class="headerlink" title="3.2 跨站请求伪造 CSRF"></a>3.2 跨站请求伪造 CSRF</h4><ul><li>跨站点请求伪造 (<code>CSRF</code>) 是一种前端安全攻击，通过伪造的形式来执行你原本不希望执行的操作<ul><li>防止<code>CSRF</code>攻击需要确保请求是合法的，并且是用户有意发起的</li><li>防止<code>CSRF</code>攻击的最简单方法之一是使用从服务器生成的<code>CSRF</code>令牌。如果客户端无法提供准确的令牌，服务器可以拒绝请求的操作</li></ul></li></ul><hr><h3 id="4-网络协议"><a href="#4-网络协议" class="headerlink" title="4. 网络协议"></a>4. 网络协议</h3><h4 id="4-1-网络七层模型与四层模型区别"><a href="#4-1-网络七层模型与四层模型区别" class="headerlink" title="4.1 网络七层模型与四层模型区别"></a>4.1 网络七层模型与四层模型区别</h4><ul><li>参考: <a href="https://juejin.cn/post/6844903492763533319?searchId=20241013095821BCBAFA2F17F7FC9E99C5">链接</a></li><li>网络七层模型 <code>OSI</code>（<code>Open Systems Interconnection Model</code>）是一个标准，而非实现</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/imgCapture1234.PNG"></p><ul><li><code>OSI</code>模型是从上往下的，越底层越接近硬件，越往上越接近软件，这七层模型分别是<strong>物理层、数据链路层、网络层、传输层、会话层、表示层、应用层</strong>。</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; 物理层：底层数据传输，如网线；网卡标准。</span><br><span class="line">&gt; 数据链路层：定义数据的基本格式，如何传输，如何标识；如网卡MAC地址。</span><br><span class="line">&gt; 网络层：定义IP编址，定义路由功能；如不同设备的数据转发。</span><br><span class="line">&gt; 传输层：端到端传输数据的基本功能；如 TCP、UDP。</span><br><span class="line">&gt; 会话层：控制应用程序之间会话能力；如不同软件数据分发给不同软件。</span><br><span class="line">&gt; 标识层：数据格式标识，基本压缩加密功能。</span><br><span class="line">&gt; 应用层：各种应用软件，包括 Web 应用。</span><br></pre></td></tr></table></figure><ul><li>网络四层模型是一个实现的应用模型，由七层模型简化合并而来</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/imgCapture4321.PNG"></p><ul><li><code>TCP/IP</code>模型将<code>OSI</code>模型由七层简化为四层，传输层和网络层被完整保留，因此网络中最核心的技术就是传输层和网络层技术</li></ul><hr><h4 id="4-2-http-和-https-基本概念"><a href="#4-2-http-和-https-基本概念" class="headerlink" title="4.2 http 和 https 基本概念"></a>4.2 http 和 https 基本概念</h4><ul><li><code>HTTP</code>: 是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准<code>TCP</code>，用于从<code>WWW</code>服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少</li><li><code>HTTPS</code>: 是以安全为目标的<code>HTTP</code>通道，简单讲是<code>HTTP</code>的安全版，即<code>HTTP</code>下加入<code>SSL</code>层，<code>HTTPS</code>的安全基础是<code>SSL</code>，因此加密的详细内容就需要<code>SSL</code></li><li><code>HTTPS</code>协议的主要作用可以分为两种：一种是建立一个信息安全通道，来保证数据传输的安全。另一种就是确认网站的真实性</li></ul><hr><h4 id="4-3-http-和-https-区别"><a href="#4-3-http-和-https-区别" class="headerlink" title="4.3 http 和 https 区别"></a>4.3 http 和 https 区别</h4><p><code>HTTP</code>协议传输的数据都是未加密的，也就是明文的，因此使用<code>HTTP</code>协议传输隐私信息非常不安全，为了保证 这些隐私数据能加密传输，于是网景公司设计了<code>SSL</code>(<code>Secure Sockets Layer</code>)协议用于对<code>HTTP</code>协议传输的数据进行加密，从而就诞生了<code>HTTPS</code>。简单来说，<code>HTTPS</code>协议是由<code>SSL+HTTP</code>协议构建的可进行加密传输、身份认证的网络协议，要比<code>HTTP</code>协议安全</p><ul><li><code>https</code>协议需要到<code>ca</code>申请证书，一般免费证书较少，因而需要一定费用</li><li><code>http</code>是超文本传输协议，信息是明文传输，<code>https</code>则是具有安全性的<code>ssl</code>加密传输协议</li><li><code>http</code>和<code>https</code>使用的是完全不同的连接方式，用的端口也不一样，前者是<code>80</code>，后者是<code>443</code></li><li><code>http</code>的连接很简单，是无状态的。<code>https</code>协议是由<code>SSL+HTTP</code>协议构建的可进行加密传输、身份认证的网络协议，比<code>http</code>协议安全</li></ul><blockquote><p>注意: <code>HTTPS = HTTP + SSL/TLS</code>，如今<code>SSL</code>已废弃，所以现在只关注<code>HTTP + TLS</code></p></blockquote><hr><h4 id="4-4-http1-x-和-http2-x-区别"><a href="#4-4-http1-x-和-http2-x-区别" class="headerlink" title="4.4 http1.x 和 http2.x 区别"></a>4.4 http1.x 和 http2.x 区别</h4><p><code>http1.x</code>和<code>http2.x</code>主要有以下<code>4</code>个区别</p><ul><li><p><code>HTTP2</code>使用的是二进制传送，<code>HTTP1.X</code>是文本(字符串)传送</p><ul><li>二进制传送的单位是帧和流。帧组成了流，同时流还有流<code>ID</code>标示</li><li>优势: 传输速度更快 (二进制数据体积较小), 处理更高效 (不需要进行文本解析), 适用于复杂数据类型 (图像、音频、视频), 安全性更高 (二进制数据不易被直接阅读)</li></ul></li><li><p><code>HTTP2</code>支持多路复用</p><ul><li>因为有流<code>ID</code>，所以通过同一个<code>http</code>请求实现多个<code>http</code>请求传输变成了可能，可以通过流<code>ID</code>来标示究竟是哪个流从而定位到是哪个<code>http</code>请求</li></ul></li><li><p><code>HTTP2</code>头部压缩</p><ul><li><code>HTTP2</code>通过<code>gzip</code>和<code>compress</code>压缩头部然后再发送，同时客户端和服务器端同时维护一张头信息表，所有字段都记录在这张表中，这样后面每次传输只需要传输表里面的索引<code>ID</code>就行，通过索引<code>ID</code>查询表头的值</li></ul></li><li><p><code>HTTP2</code>支持服务器推送</p><ul><li><code>HTTP2</code>支持在未经客户端许可的情况下，主动向客户端推送内容</li></ul></li></ul><hr><h4 id="4-5-http-请求方式"><a href="#4-5-http-请求方式" class="headerlink" title="4.5 http 请求方式"></a>4.5 http 请求方式</h4><p><code>http</code>请求方式有以下<code>8</code>种，其中<code>GET</code>和<code>POST</code>是最常用的</p><ul><li><code>GET</code>: 向特定的资源发出请求。<code>GET</code>方法不应当被用于产生“副作用”的操作中</li><li><code>POST</code>: 向指定资源提交数据进行处理请求, 例如提交表单或者上传文件。数据被包含在请求体中。<code>POST</code>请求可能会导致新的资源的建立和&#x2F;或已有资源的修改</li><li><code>PUT</code>: 向指定资源位置上传其最新内容</li><li><code>DELETE</code>: 请求服务器删除<code>Request-URL</code>所标识的资源</li><li><code>HEAD</code>: 向服务器索与<code>GET</code>请求相一致的响应，只不过响应体将不会被返回。这一方法可以再不必传输整个响应内容的情况下，就可以获取包含在响应小消息头中的元信息</li><li><code>OPTIONS</code>: 返回服务器针对特定资源所支持的<code>HTTP</code>请求方法，也可以利用向<code>web</code>服务器发送<code>‘*’</code>的请求来测试服务器的功能性</li><li><code>TRACE</code>: 回显服务器收到的请求，主要用于测试或诊断</li><li><code>CONNECT</code>: <code>HTTP/1.1</code>协议中预留给能够将连接改为管道方式的代理服务器</li></ul><hr><h4 id="4-6-TCP-三次握手"><a href="#4-6-TCP-三次握手" class="headerlink" title="4.6 TCP 三次握手"></a>4.6 TCP 三次握手</h4><hr><h3 id="5-React-题目"><a href="#5-React-题目" class="headerlink" title="5. React 题目"></a>5. React 题目</h3><hr><h3 id="6-缓存"><a href="#6-缓存" class="headerlink" title="6. 缓存"></a>6. 缓存</h3><h4 id="6-1-强缓存与协商缓存"><a href="#6-1-强缓存与协商缓存" class="headerlink" title="6.1 强缓存与协商缓存"></a>6.1 强缓存与协商缓存</h4><ul><li><p>参考: <a href="https://juejin.cn/post/7259298281578889273?searchId=20241013235036EC2DA00FC6CFFB00CC87">链接</a></p></li><li><p>为了减少资源请求次数，加快资源访问速度，浏览器会对资源文件如图片、<code>css</code>文件、<code>js</code>文件等进行缓存，而浏览器缓存策略又分为强缓存和协商缓存</p></li><li><p>强缓存 <code>Strong Cache</code></p><ul><li>所谓强缓存，可以理解为强制缓存的意思，即浏览器在访问某个资源时会判断是否使用本地缓存里已经存在的资源文件，使用本地缓存的话则不会发送请求到服务器，从而达到减轻服务器访问压力的作用，且由于直接从本地缓存读取资源文件，大大提高了加载速度</li><li>浏览器第一次请求远程服务器的某个资源时，如果服务器希望浏览器得到该资源后一段时间内不要再发送请求过来，直接从浏览器里的缓存里取，则服务器可以通过在响应头里设置<code>Cache-Control: max-age=31536000</code>，<code>max-age</code>代表缓存时间，单位为秒，这里的数据换算过来就是一年，意味着在一年内浏览器不会再向服务器发送请求。</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/imgCapture4567.PNG"></p><ul><li>使用缓存的话，状态码<code>200</code>后面会标明情况。浏览器缓存资源的地方有两个: 磁盘缓存（<code>disk cache</code>）和内存缓存（<code>memory cache</code>）</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/imgCapture7654.PNG"></p><ul><li>当缓存时间到期后再次访问时，状态码<code>200</code>后面便没有括号内的内容了</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/imgCapture12345.PNG"></p><blockquote><p>一般来说，浏览器会将较大的资源缓存到<code>disk cache</code>，而较小的资源则被缓存到<code>memory cache</code>里。内存缓存与磁盘缓存相比，访问速度要更快一些</p></blockquote><ul><li>强缓存除了使用<code>Cache-Control</code>实现之外，还可以使用<code>Expires</code>字段，<code>Expires</code>是<code>Http1.0</code>规范，<code>Cache-Control</code>是<code>Http1.1</code>规范，<code>Expires</code>返回一个具体的时间值，代表缓存的有效期，在该日期内浏览器不会向服务器发起请求，而是直接从缓存里获取资源</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/imgCapture5431.PNG"></p><ul><li>因为<code>Expires</code>参照的是本地客户端的时间，而客户端的时间是可以被修改的，所以会有误差产生的情况，这也是<code>Expires</code>的一个缺点，所以有了后来<code>Http1.1</code>规范的<code>Cache-control</code></li></ul><blockquote><p><code>Cache-control</code>的优先级要高于<code>Expires</code>，如果两者同时设置，会优先使用<code>Cache-control</code>而忽略掉<code>Expires</code></p></blockquote><ul><li>协商缓存 <code>Negotiation Cache</code><ul><li>在强缓存里，是否使用缓存是由浏览器来确定的，而协商缓存则是由服务器来告诉浏览器是否使用缓存资源，也就是浏览器每一次都要发送请求到服务器询问是否使用缓存</li><li>浏览器初次请求资源，服务器返回资源，同时生成一个<code>Etag</code>值携带在响应头里返回给浏览器，当浏览器再次请求资源时会在请求头里携带<code>If-None-Match</code>，值是之前服务器返回的<code>Etag</code>的值，服务器收到之后拿该值与资源文件最新的<code>Etag</code>值做对比</li></ul></li></ul><blockquote><p>如果没有变化则返回<code>304</code>，告诉浏览器继续使用缓存（不返回资源文件）<br>如果发生变化，则返回<code>200</code>和最新的资源文件给浏览器使用</p></blockquote><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/imgCapture2567.PNG"></p><ul><li>除了<code>Etag</code>外，还有一个<code>Last-Modified</code>的属性，它是<code>Http1.0</code>规范的，服务器返回<code>Last-Modified</code>，浏览器请求头对应携带的是<code>If-Modified-since</code>，与<code>Etag</code>不同的是，<code>Last-Modified</code>的值是一个时间值，代表文件的修改时间，服务器通过对比文件的修改时间是否发生改变来判断是否使用缓存</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/imgCapture7890.PNG"></p><ul><li>相比<code>Last-Modified</code>，<code>Etag</code>优先级更高，使用上也更精确一些，因为有时候会存在文件内容并没有改变，但文件的修改时间变更了，<code>Last-Modified</code>不一致所以服务器会重新返回资源文件，实际上还是可以继续使用缓存的</li></ul><blockquote><p>强缓存优先级大于协商缓存，即两者同时存在时，如果强缓存开启且在有效期内，则不会走协商缓存</p></blockquote><hr><h3 id="7-算法"><a href="#7-算法" class="headerlink" title="7. 算法"></a>7. 算法</h3><h4 id="7-1-LRU-Cache"><a href="#7-1-LRU-Cache" class="headerlink" title="7.1 LRU Cache"></a>7.1 LRU Cache</h4><ul><li>字节一面算法题</li><li>使用<code>JS</code>实现一个魔改版的<code>LRU Cache</code>，并且满足以下要求</li></ul><blockquote><p>维护一个容量为<code>n</code>的缓存<br>每个缓存项如果在<code>X</code>秒后没有被使用，则自动删除</p></blockquote><ul><li>可以使用<code>Map</code>来维护缓存的顺序和容量，利用<code>setTimeout</code>来实现自动删除的功能</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">capacity, expireTime</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">capacity</span> = capacity; <span class="comment">// 缓存容量</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">expireTime</span> = expireTime; <span class="comment">// 缓存项的有效时间（秒）</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">cache</span> = <span class="keyword">new</span> <span class="title class_">Map</span>(); <span class="comment">// 用 Map 来存储缓存数据</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">timers</span> = <span class="keyword">new</span> <span class="title class_">Map</span>(); <span class="comment">// 用来存储每个缓存项的定时器</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取缓存</span></span><br><span class="line">  <span class="title function_">get</span>(<span class="params">key</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">cache</span>.<span class="title function_">has</span>(key)) <span class="keyword">return</span> -<span class="number">1</span>; <span class="comment">// 如果缓存中没有这个key，返回-1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果缓存命中，需要刷新缓存的顺序（将这个key移到最新的位置）</span></span><br><span class="line">    <span class="keyword">const</span> value = <span class="variable language_">this</span>.<span class="property">cache</span>.<span class="title function_">get</span>(key);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">cache</span>.<span class="title function_">delete</span>(key); <span class="comment">// 先删除老的位置</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">cache</span>.<span class="title function_">set</span>(key, value); <span class="comment">// 重新插入，保证最新访问的在末尾</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重置定时器，延长过期时间</span></span><br><span class="line">    <span class="built_in">clearTimeout</span>(<span class="variable language_">this</span>.<span class="property">timers</span>.<span class="title function_">get</span>(key)); <span class="comment">// 清除老的定时器</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">timers</span>.<span class="title function_">set</span>(key, <span class="variable language_">this</span>.<span class="title function_">setExpiration</span>(key)); <span class="comment">// 重新设置定时器</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 添加缓存</span></span><br><span class="line">  <span class="title function_">put</span>(<span class="params">key, value</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">cache</span>.<span class="title function_">has</span>(key)) &#123;</span><br><span class="line">      <span class="comment">// 如果已经存在，删除旧的缓存</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">cache</span>.<span class="title function_">delete</span>(key);</span><br><span class="line">      <span class="built_in">clearTimeout</span>(<span class="variable language_">this</span>.<span class="property">timers</span>.<span class="title function_">get</span>(key));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果缓存已满，删除最老的缓存</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">cache</span>.<span class="property">size</span> &gt;= <span class="variable language_">this</span>.<span class="property">capacity</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> oldestKey = <span class="variable language_">this</span>.<span class="property">cache</span>.<span class="title function_">keys</span>().<span class="title function_">next</span>().<span class="property">value</span>; <span class="comment">// 获取 Map 中第一个（最旧）的key</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">cache</span>.<span class="title function_">delete</span>(oldestKey); <span class="comment">// 删除最旧的缓存项</span></span><br><span class="line">      <span class="built_in">clearTimeout</span>(<span class="variable language_">this</span>.<span class="property">timers</span>.<span class="title function_">get</span>(oldestKey)); <span class="comment">// 清除相应的定时器</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">timers</span>.<span class="title function_">delete</span>(oldestKey); <span class="comment">// 删除定时器记录</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入新的缓存项</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">cache</span>.<span class="title function_">set</span>(key, value);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">timers</span>.<span class="title function_">set</span>(key, <span class="variable language_">this</span>.<span class="title function_">setExpiration</span>(key)); <span class="comment">// 设置定时器</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置缓存项的自动删除定时器</span></span><br><span class="line">  <span class="title function_">setExpiration</span>(<span class="params">key</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">cache</span>.<span class="title function_">delete</span>(key); <span class="comment">// 删除缓存项</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">timers</span>.<span class="title function_">delete</span>(key); <span class="comment">// 删除定时器记录</span></span><br><span class="line">    &#125;, <span class="variable language_">this</span>.<span class="property">expireTime</span> * <span class="number">1000</span>); <span class="comment">// 转换为毫秒</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> lru = <span class="keyword">new</span> <span class="title class_">LRUCache</span>(<span class="number">3</span>, <span class="number">5</span>); <span class="comment">// 创建容量为3，缓存项5秒后失效的LRU Cache</span></span><br><span class="line">lru.<span class="title function_">put</span>(<span class="number">1</span>, <span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">lru.<span class="title function_">put</span>(<span class="number">2</span>, <span class="string">&#x27;B&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(lru.<span class="title function_">get</span>(<span class="number">1</span>)); <span class="comment">// 输出 &#x27;A&#x27;</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(lru.<span class="title function_">get</span>(<span class="number">2</span>)); <span class="comment">// 在5秒内访问，输出 &#x27;B&#x27;</span></span><br><span class="line">&#125;, <span class="number">4000</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(lru.<span class="title function_">get</span>(<span class="number">1</span>)); <span class="comment">// 超过5秒未访问，输出 -1（已过期）</span></span><br><span class="line">&#125;, <span class="number">6000</span>);</span><br></pre></td></tr></table></figure><hr><h4 id="7-2-格式化数字"><a href="#7-2-格式化数字" class="headerlink" title="7.2 格式化数字"></a>7.2 格式化数字</h4><ul><li><p>字节一面算法题</p></li><li><p>给一个数字比如<code>1000000</code>，把它转化成<code>1,000,000</code>。或者是<code>1000000.12</code>，把它转化成<code>1,000,000.12</code>。只能使用<code>JS</code>实现</p></li><li><p>解决方案一: 使用<code>toLocaleString()</code></p></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">formatNumberWithCommas</span>(<span class="params">number</span>) &#123;</span><br><span class="line">  <span class="comment">// 分离整数和小数部分，默认小数部分为空字符串</span></span><br><span class="line">  <span class="keyword">let</span> [integer, decimal = <span class="string">&#x27;&#x27;</span>] = (number + <span class="string">&#x27;&#x27;</span>).<span class="title function_">split</span>(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 通过 toLocaleString 格式化整数部分，自动加上千分位逗号</span></span><br><span class="line">  integer = (+integer).<span class="title function_">toLocaleString</span>();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 如果没有小数部分，直接返回格式化后的整数部分</span></span><br><span class="line">  <span class="keyword">if</span> (decimal === <span class="string">&#x27;&#x27;</span>) <span class="keyword">return</span> integer;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 小数部分无需反转或使用 toLocaleString，直接返回原来的小数部分即可</span></span><br><span class="line">  <span class="keyword">return</span> integer + <span class="string">&#x27;.&#x27;</span> + decimal;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">formatNumberWithCommas</span>(<span class="number">1000000</span>)); <span class="comment">// 输出 &quot;1,000,000&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">formatNumberWithCommas</span>(<span class="number">1000000.12</span>)); <span class="comment">// 输出 &quot;1,000,000.12&quot;</span></span><br></pre></td></tr></table></figure><ul><li>解决方案二: 正则表达式</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">formateNumberWithCommas</span>(<span class="params">number</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> number.<span class="title function_">toString</span>().<span class="title function_">replace</span>(<span class="regexp">/\B(?=(\d&#123;3&#125;)+(?!\d))/g</span>, <span class="string">&quot;,&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">formateNumberWithCommas</span>(<span class="number">1000000</span>)); <span class="comment">// 输出 &quot;1,000,000&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">formateNumberWithCommas</span>(<span class="number">1000000.12</span>)); <span class="comment">// 输出 &quot;1,000,000.12&quot;</span></span><br></pre></td></tr></table></figure><ul><li>解决方案三: 手动实现格式化</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">formatNumberWithCommas</span>(<span class="params">number</span>) &#123;</span><br><span class="line">  <span class="comment">// 类型检测</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> number !== <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 先转成字符串</span></span><br><span class="line">  number = number.<span class="title function_">toString</span>();</span><br><span class="line">  <span class="comment">// 支持小数,按小数点分成两部分 使用了es6解构</span></span><br><span class="line">  <span class="keyword">let</span> [integer, decimal] = number.<span class="title function_">split</span>(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 封装了 doSplit 方法 第二个参数 isInteger 来表示是整数部分还是小数部分</span></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">doSplit</span> = (<span class="params">num, isInteger = <span class="literal">true</span></span>) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 如果为空，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (!num) <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="comment">// 如果是整数部分 先按位切割再反转</span></span><br><span class="line">    <span class="comment">// 整数部分数字从右往左数，每3位插入一个逗号</span></span><br><span class="line">    <span class="comment">// 小数部分从左往右数</span></span><br><span class="line">    <span class="comment">// 两次反转，它的逗号顺序是一样的。</span></span><br><span class="line">    <span class="keyword">if</span> (isInteger) num = num.<span class="title function_">split</span>(<span class="string">&#x27;&#x27;</span>).<span class="title function_">reverse</span>();</span><br><span class="line">    <span class="keyword">let</span> str = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; num.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (i !== <span class="number">0</span> &amp;&amp; i % <span class="number">3</span> === <span class="number">0</span>) str.<span class="title function_">push</span>(<span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">      str.<span class="title function_">push</span>(num[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isInteger) <span class="keyword">return</span> str.<span class="title function_">reverse</span>().<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> str.<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 处理整数部分</span></span><br><span class="line">  integer = <span class="title function_">doSplit</span>(integer);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 处理小数部分，确保 undefined 小数不会导致问题</span></span><br><span class="line">  decimal = decimal ? <span class="title function_">doSplit</span>(decimal, <span class="literal">false</span>) : <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> integer + (decimal === <span class="string">&#x27;&#x27;</span> ? <span class="string">&#x27;&#x27;</span> : <span class="string">&#x27;.&#x27;</span> + decimal);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">formatNumberWithCommas</span>(<span class="number">1000000</span>)); <span class="comment">// 输出 &quot;1,000,000&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">formatNumberWithCommas</span>(<span class="number">1000000.12</span>)); <span class="comment">// 输出 &quot;1,000,000.12&quot;</span></span><br></pre></td></tr></table></figure><hr><h4 id="7-3-手写数组转树"><a href="#7-3-手写数组转树" class="headerlink" title="7.3 手写数组转树"></a>7.3 手写数组转树</h4><ul><li>做到类似下面的转换</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> input = [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">val</span>: <span class="string">&#x27;学校&#x27;</span>, <span class="attr">parentId</span>: <span class="literal">null</span></span><br><span class="line">    &#125;, &#123;</span><br><span class="line">        <span class="attr">id</span>: <span class="number">2</span>, <span class="attr">val</span>: <span class="string">&#x27;班级1&#x27;</span>, <span class="attr">parentId</span>: <span class="number">1</span></span><br><span class="line">    &#125;, &#123;</span><br><span class="line">        <span class="attr">id</span>: <span class="number">3</span>, <span class="attr">val</span>: <span class="string">&#x27;班级2&#x27;</span>, <span class="attr">parentId</span>: <span class="number">1</span></span><br><span class="line">    &#125;, &#123;</span><br><span class="line">        <span class="attr">id</span>: <span class="number">4</span>, <span class="attr">val</span>: <span class="string">&#x27;学生1&#x27;</span>, <span class="attr">parentId</span>: <span class="number">2</span></span><br><span class="line">    &#125;, &#123;</span><br><span class="line">        <span class="attr">id</span>: <span class="number">5</span>, <span class="attr">val</span>: <span class="string">&#x27;学生2&#x27;</span>, <span class="attr">parentId</span>: <span class="number">2</span></span><br><span class="line">    &#125;, &#123;</span><br><span class="line">        <span class="attr">id</span>: <span class="number">6</span>, <span class="attr">val</span>: <span class="string">&#x27;学生3&#x27;</span>, <span class="attr">parentId</span>: <span class="number">3</span></span><br><span class="line">    &#125;,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> output = &#123;</span><br><span class="line">    <span class="attr">id</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">val</span>: <span class="string">&#x27;学校&#x27;</span>,</span><br><span class="line">    <span class="attr">children</span>: [&#123;</span><br><span class="line">        <span class="attr">id</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="attr">val</span>: <span class="string">&#x27;班级1&#x27;</span>,</span><br><span class="line">        <span class="attr">children</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">id</span>: <span class="number">4</span>,</span><br><span class="line">                <span class="attr">val</span>: <span class="string">&#x27;学生1&#x27;</span>,</span><br><span class="line">                <span class="attr">children</span>: []</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">id</span>: <span class="number">5</span>,</span><br><span class="line">                <span class="attr">val</span>: <span class="string">&#x27;学生2&#x27;</span>,</span><br><span class="line">                <span class="attr">children</span>: []</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;, &#123;</span><br><span class="line">        <span class="attr">id</span>: <span class="number">3</span>,</span><br><span class="line">        <span class="attr">val</span>: <span class="string">&#x27;班级2&#x27;</span>,</span><br><span class="line">        <span class="attr">children</span>: [&#123;</span><br><span class="line">            <span class="attr">id</span>: <span class="number">6</span>,</span><br><span class="line">            <span class="attr">val</span>: <span class="string">&#x27;学生3&#x27;</span>,</span><br><span class="line">            <span class="attr">children</span>: []</span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">arrayToTree</span>(<span class="params">array</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> root = array[<span class="number">0</span>];</span><br><span class="line">  array.<span class="title function_">shift</span>();</span><br><span class="line">  <span class="keyword">let</span> tree = &#123;</span><br><span class="line">    <span class="attr">id</span>: root.<span class="property">id</span>,</span><br><span class="line">    <span class="attr">val</span>: root.<span class="property">val</span>,</span><br><span class="line">    <span class="attr">children</span>: array.<span class="property">length</span> &gt; <span class="number">0</span> ? <span class="title function_">toTree</span>(root.<span class="property">id</span>, array) : []</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> tree;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">toTree</span>(<span class="params">parentId, array</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> children = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; array.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> node = array[i];</span><br><span class="line">    <span class="keyword">if</span> (node.<span class="property">parentId</span> === parentId) &#123;</span><br><span class="line">      children.<span class="title function_">push</span>(&#123;</span><br><span class="line">        <span class="attr">id</span>: node.<span class="property">id</span>,</span><br><span class="line">        <span class="attr">val</span>: node.<span class="property">val</span>,</span><br><span class="line">        <span class="attr">children</span>: <span class="title function_">toTree</span>(node.<span class="property">id</span>, array)</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> children;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">arrayToTree</span>(input));</span><br></pre></td></tr></table></figure><hr><h4 id="7-4-数组去重"><a href="#7-4-数组去重" class="headerlink" title="7.4 数组去重"></a>7.4 数组去重</h4><ul><li><p>将<code>[1,1,2,2,3,3,4,4,5,5]</code>去重, 结果应该是<code>[1,2,3,4,5]</code></p></li><li><p>方法一: <code>ES6</code>的<code>Set</code>去重</p></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>];</span><br><span class="line"><span class="keyword">const</span> setData = <span class="title class_">Array</span>.<span class="title function_">from</span>(<span class="keyword">new</span> <span class="title class_">Set</span>(arr));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(setData);</span><br></pre></td></tr></table></figure><blockquote><p><code>Set</code>去重有一个弊端，无法去重引用类型的数据。比如对象数组<code>[&#123;a:1&#125;, &#123;a:1&#125;]</code></p></blockquote><ul><li>方法二: 双重<code>for</code>循环去重</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">handleRemoveRepeat</span> = (<span class="params">arr</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, len = arr.<span class="property">length</span>; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; len; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (arr[i] === arr[j]) &#123;</span><br><span class="line">        arr.<span class="title function_">splice</span>(j, <span class="number">1</span>);</span><br><span class="line">        j--;</span><br><span class="line">        len--;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>使用<code>len = arr.length</code>的原因: 假设这个循环需要循环<code>10000</code>次，<code>length</code>就会被执行<code>10000</code>次</p></blockquote><hr><h3 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h3><blockquote><p>文件还未上传 Github</p></blockquote>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
