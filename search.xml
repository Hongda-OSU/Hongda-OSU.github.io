<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>CSS 学习笔记</title>
      <link href="/posts/eb0c992c.html"/>
      <url>/posts/eb0c992c.html</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote></blockquote><hr><h3 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h3><blockquote><p>文件还未上传 Github</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>考证：AWS DVA-C02</title>
      <link href="/posts/31e3742d.html"/>
      <url>/posts/31e3742d.html</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><ul><li>官网: <a href="https://aws.amazon.com/certification/certified-developer-associate/">https://aws.amazon.com/certification/certified-developer-associate/</a></li><li>网课：<a href="https://www.udemy.com/course/aws-certified-developer-associate-dva-c01/">https://www.udemy.com/course/aws-certified-developer-associate-dva-c01/</a></li><li>题库: <a href="https://www.udemy.com/course/aws-certified-developer-associate-practice-tests-dva-c01/">https://www.udemy.com/course/aws-certified-developer-associate-practice-tests-dva-c01/</a></li><li>题库: <a href="https://www.examtopics.com/exams/amazon/aws-certified-developer-associate-dva-c02/view/">https://www.examtopics.com/exams/amazon/aws-certified-developer-associate-dva-c02/view/</a></li><li>准备时间: 3 月 30 号准备, 6 月 26 号考试 (因为中间要上课)</li></ul></blockquote><hr><h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><h3 id="1-AWS-Cloud-Overview"><a href="#1-AWS-Cloud-Overview" class="headerlink" title="1. AWS Cloud Overview"></a>1. AWS Cloud Overview</h3><h4 id="AWS-Regions"><a href="#AWS-Regions" class="headerlink" title="AWS Regions"></a>AWS Regions</h4><ul><li>A Region is a cluster of data centers</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img231130.png"></p><ul><li>To reuse SSH keys in AWS Region<ul><li>Generate a public SSH key from the private SSH key. Import the key to each AWS Region</li></ul></li></ul><hr><h4 id="AWS-Availability-Zone"><a href="#AWS-Availability-Zone" class="headerlink" title="AWS Availability Zone"></a>AWS Availability Zone</h4><ul><li>一个 Region 可以有 3 - 6 个 AZ, 每个 AZ 都是分开的</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img140727.png"></p><hr><h4 id="AWS-Edge-Locations"><a href="#AWS-Edge-Locations" class="headerlink" title="AWS Edge Locations"></a>AWS Edge Locations</h4><ul><li>Deliver content to user with low latency (离用户越近, deliver 速度越快)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img140903.png"></p><hr><h3 id="2-IAM"><a href="#2-IAM" class="headerlink" title="2. IAM"></a>2. IAM</h3><h4 id="AWS-IAM"><a href="#AWS-IAM" class="headerlink" title="AWS IAM"></a>AWS IAM</h4><ul><li>Root Account: Created by default, don’t share with others</li><li>Users: People within the organization</li><li>Groups: Only contain Users, not other Groups (User 可以属于多个 Group)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img145736.png"></p><ul><li>AWS 需要至少 5 weeks 来生成 budget forecasts</li><li>注意, User 默认无法 access AWS Billing and Cost Management console, 必须要 grant access 才行</li></ul><hr><h4 id="IAM-Permissions"><a href="#IAM-Permissions" class="headerlink" title="IAM Permissions"></a>IAM Permissions</h4><ul><li>定义了 User 或者 Group 的 Permissions<ul><li>要遵守 Least Privilege Principle</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img160124.png"></p><blockquote><p>As an AWS security best practice, you should not create an IAM user and pass the user’s credentials to the application or embed the credentials in the application</p></blockquote><hr><h4 id="IAM-Polices"><a href="#IAM-Polices" class="headerlink" title="IAM Polices"></a>IAM Polices</h4><ul><li>Statements 里面必须包含: Effect, Principal, Action, Resource<ul><li>Inline Policy 是 assign 给个人的</li></ul></li><li>注意, The only resource-based policy IAM support is Trust policy</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img175653.png"></p><blockquote><p>IAM policies define permissions for an action regardless of the method that used to perform the operation.</p></blockquote><hr><h4 id="IAM-MFA"><a href="#IAM-MFA" class="headerlink" title="IAM MFA"></a>IAM MFA</h4><ul><li>Protect Root Accounts and IAM Users</li><li>MFA options: Virtual MFA Device, U2F Sercurity Key (USB)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img180624.png"></p><hr><h4 id="IAM-CLI-amp-SDK"><a href="#IAM-CLI-amp-SDK" class="headerlink" title="IAM CLI &amp; SDK"></a>IAM CLI &amp; SDK</h4><ul><li>可以用 AWS Management Console, AWS CLI, AWS SDK 来访问 AWS<ul><li>Set the <code>DeleteOnTermination</code> attribute to False using the command line</li><li>如果考试遇到不会的就选 CLI</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img193342.png"></p><hr><h4 id="IAM-Roles"><a href="#IAM-Roles" class="headerlink" title="IAM Roles"></a>IAM Roles</h4><ul><li>授权 AWS 服务去做某些事</li><li>常见的 Role: EC2 Instance Role, Lambda Function Role 等等</li><li>IAM Instance Role: 为 EC2 实例分配 temporary credentials，以便实例能够安全地访问其他 AWS 服务</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img203306.png"></p><blockquote><p>An IAM entity that defines a set of permissions for making requests to AWS services, and will be used by an AWS service</p></blockquote><hr><h4 id="IAM-Security-Tools"><a href="#IAM-Security-Tools" class="headerlink" title="IAM Security Tools"></a>IAM Security Tools</h4><ul><li>IAM Credentials Report: 返回用户数据和 credentials</li><li>IAM Access Advisor: 显示当前用户被授权的服务和使用时间</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img203553.png"></p><hr><h3 id="3-EC2-Fundamentals"><a href="#3-EC2-Fundamentals" class="headerlink" title="3. EC2 Fundamentals"></a>3. EC2 Fundamentals</h3><h4 id="AWS-EC2"><a href="#AWS-EC2" class="headerlink" title="AWS EC2"></a>AWS EC2</h4><ul><li>EC2 &#x3D; Elastic Compute Cloud &#x3D; IaaS , 绑定 AZ</li><li>SSH 到 EC2 Instance 的 Public IP (记住 169, meta-data)<ul><li><code>http://169.254.169.254/latest/meta-data/public-ipv4</code></li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img214749.png"></p><ul><li>User Data: EC2 启动的时候运行的代码<ul><li>By default, user data runs only during boot cycle when first lauch instance</li><li>By default, scripts entered as user data are executed with root user privileges</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img214956.png"></p><ul><li>如果要 monitor 一个 EC2 Instance, <code>aws ec2 monitor-instances --instance-ids &#123;id&#125;</code></li></ul><hr><h4 id="EC2-Instance-Type"><a href="#EC2-Instance-Type" class="headerlink" title="EC2 Instance Type"></a>EC2 Instance Type</h4><ul><li>一共 7 种 EC2 Instance Type, 但 4 种用的最多<ul><li>General Purpose: Balanced (平衡的)</li><li>Compute Optimized: High performance (处理 Batch, 视频和 HPC)</li><li>Memory Optimized: Process data in memory (处理 cache)</li><li>Storage Optimized: Read and write data on local storage (OLTP)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img220941.png"></p><hr><h4 id="EC2-Security-Groups"><a href="#EC2-Security-Groups" class="headerlink" title="EC2 Security Groups"></a>EC2 Security Groups</h4><ul><li>Control how traffic is allowed in and out of EC2 instance<ul><li>Security groups only contain allow rules (EC2 出问题优先检查 Security Group)</li></ul></li><li>可以作为 Security Group 的 Inbound Rule 有 IP address, CIDR block, Security Group</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img222531.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img223020.png"></p><hr><h4 id="EC2-Instance-Purchasing-Options"><a href="#EC2-Instance-Purchasing-Options" class="headerlink" title="EC2 Instance Purchasing Options"></a>EC2 Instance Purchasing Options</h4><ul><li>On-Demand Intances: Short workload, pay by second (短期内紧急使用)</li><li>Reserved: 1 - 3 years (72% discount, reserve capacity in an AZ)<ul><li>Reserved Instance: Long workload (1 - 3 年, discount 随年份增加)</li><li>Convertible Reserved Instances (RI): Long workload with flexible instance (66% discount, 但是可以自由改变 Instance Type)</li></ul></li><li>Saving Plans: 1 - 3 years, commitment to an amount of usage (72% discount, 要定一个使用上限, 超过上限就变成 On-Demand)<ul><li>还有 Compute Saving Plan, 66% discount, work with Lambda and Fargate</li></ul></li><li>Spot Instance: Short workload, can lose instance (最便宜, 90% discount)</li><li>Dedicated Host: The physical server is yours (最贵, 可以控制 how Instance placed)</li><li>Dedicated Instance: Run hardware, but not lockdown to you (服务器大部分是你的)</li><li>Capacity Reservation: Reserve capacity in AZ (比如一天中只有几个小时需要 EC2)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img224149.png"></p><ul><li>Reserved Instance 有 Regional 和 Zonal, Zonal 提供 capacity reservation, Regional 不提供</li></ul><hr><h3 id="4-EC2-Instance-Storage"><a href="#4-EC2-Instance-Storage" class="headerlink" title="4. EC2 Instance Storage"></a>4. EC2 Instance Storage</h3><h4 id="AWS-EBS"><a href="#AWS-EBS" class="headerlink" title="AWS EBS"></a>AWS EBS</h4><ul><li>Block-level storage, 类似 network drive, 绑定 AZ, provisioned capacity<ul><li>可以从一个 EC2 Instance 取下来装到另一个上</li><li>记住 EBS 是绑定 AZ 的, 很重要</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img191440.png"></p><ul><li>EBS - Delete on Termination attribute<ul><li>By default, Root Volume will be deleted on termination (重要)</li><li>By default, other EBS volume will not be deleted on termination (重要)</li><li>Can be controled by AWS console &#x2F; AWS CLI</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img002840.png"></p><hr><h4 id="EBS-Snapshots"><a href="#EBS-Snapshots" class="headerlink" title="EBS Snapshots"></a>EBS Snapshots</h4><ul><li>Make a backup of EBS volume (备份 EBS)<ul><li>可以将这个 snapshot 用在其他 AZ 或者 Region 上</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img195715.png"></p><ul><li>EBS Snapchot Archive: 便宜 75%</li><li>Recycle Bin: Setup rules to retain deleted snapshots (可以 recover)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img195833.png"></p><hr><h4 id="AWS-AMI"><a href="#AWS-AMI" class="headerlink" title="AWS AMI"></a>AWS AMI</h4><ul><li>AMI: Amazon Machine Image, customization of an EC2 Instance<ul><li>可以更好的管理和启动 EC2 Instance</li></ul></li><li>Built for a specific region and can copy across regions (AMI 跨域复制)<ul><li>注意, AMIs are built for a specific AWS Region</li></ul></li></ul><blockquote><p>When the new AMI is copied from Region A into Region B, it automatically creates a snapshot in Region B (注意, 跨域 copy AMI 会产生 snapshot)</p></blockquote><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img200249.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img200341.png"></p><hr><h4 id="EC2-Instance-Store"><a href="#EC2-Instance-Store" class="headerlink" title="EC2 Instance Store"></a>EC2 Instance Store</h4><ul><li>Block-level storage, 物理硬盘 (Physical drive, temporary storage, 可以处理数据库)</li><li>High random I&#x2F;O performance, good for cache at low cost (重要)</li><li>EC2 Instance Store lose when stopped (Ephemeral, 数据在 Instance Store 关闭时消失)<ul><li>反正记住, Instance Store 不能复用, Instance Store 里的数据不会 preserve</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img203146.png"></p><hr><h4 id="EBS-Volume-Types"><a href="#EBS-Volume-Types" class="headerlink" title="EBS Volume Types"></a>EBS Volume Types</h4><ul><li>General Purpose (gp2 &#x2F; gp3): Balanced, cost-effective</li><li>Provisioned IOPS (io1 &#x2F; io2): High-performance, support Multi-Attach<ul><li>Low latency, high throughput</li><li>记住, io 的比 gp 的贵, 但是 io 的 IOPS 也比 gp 高</li><li>gp2 的 max IOPS 是 5.3 TiB</li></ul></li><li>Hard Disk Drives (HDD): Data intensive (st1) 或者 less frequent access (sc1)<ul><li>HDD 不可以用来创建 EC2</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img203437.png"></p><hr><h4 id="EBS-Multi-Attach"><a href="#EBS-Multi-Attach" class="headerlink" title="EBS Multi-Attach"></a>EBS Multi-Attach</h4><ul><li>Attach same EBS volume to multiple EC2 instance in same AZ (记住是相同的 AZ)</li><li>Only for io1 &#x2F; io2 family (Provisioned IOPS SSD, 重要)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img203956.png"></p><hr><h4 id="EBS-RAID"><a href="#EBS-RAID" class="headerlink" title="EBS RAID"></a>EBS RAID</h4><ul><li>RAID 0 (看重 I&#x2F;O performance)<ul><li>Use RAID 0 when I&#x2F;O performance is more important than fault tolerance</li><li>可以用来提高 EBS volume 的 performance</li></ul></li><li>RAID 1 (看重 falut tolerance)<ul><li>Use RAID 1 when fault tolerance is more important than I&#x2F;O performance</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/imgpt6-q37-i1.jpg"></p><hr><h4 id="AWS-EFS"><a href="#AWS-EFS" class="headerlink" title="AWS EFS"></a>AWS EFS</h4><ul><li>NFS (network file system), 可以 mount 到多个 EC2 Instance<ul><li>Scale automatically, highly availiable, no capacity planning</li></ul></li><li>EC2 Instances can access files on an EFS file system across AZs, Regions and VPCs<ul><li>重要, 可以从不同的 AZ, Region, VPC 来 access</li><li>可以用 VPC Security Group 或者 IAM Policy 来 control access to EFS</li></ul></li><li>EFS Infrequent Access (如果遇到 POSIX compliant file storage)<ul><li>因为 EFS 只能和 Linux Instance (POSIX) 一起用, Windows 不行</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img233415.png"></p><ul><li>EFS 有 2 种 Performance Mode (set at EFS creation time)<ul><li>General Purpose: Default (web server)</li><li>Max I&#x2F;O: High latency, throughput, parallel (big data, media process)</li></ul></li><li>EFS 有 3 种 Throughput Mode (重要)<ul><li>Bursting: 很快</li><li>Provisioned: 设置上限 (high throughput, 处理大量文件 migrate 时候使用)</li><li>Elastic: 根据 workload 来 scale</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img233732.png"></p><blockquote><p>EFS 并不是永远最贵的, 但 S3 永远是最便宜的。<br>在性能方面，AWS EBS 由于可以提供高 IOPS，速度最快。但是在共享和可弹性伸缩的文件系统方面，AWS EFS 是最好的选择。</p></blockquote><hr><h3 id="5-ELB-amp-ASG"><a href="#5-ELB-amp-ASG" class="headerlink" title="5. ELB &amp; ASG"></a>5. ELB &amp; ASG</h3><h4 id="Scalability-amp-High-Availability"><a href="#Scalability-amp-High-Availability" class="headerlink" title="Scalability &amp; High Availability"></a>Scalability &amp; High Availability</h4><ul><li>Vertical (竖直) Scale: Increase the size of the Instance (增加大小)</li><li>Horizontal (水平) Scale: Increase the number of the Instance (增加数量)</li><li>High Availability: Running application in at least 2 AZ (Disaster recovery, 重要)</li></ul><hr><h4 id="AWS-ELB"><a href="#AWS-ELB" class="headerlink" title="AWS ELB"></a>AWS ELB</h4><ul><li>Foward traffic to multiple EC2 Instances (流量控制)<ul><li>High availability across AZs, handle failures of downstream instances</li></ul></li><li>Health Check: 可以知道 EC2 Instance 是否是 Healthy 的<ul><li>ELB 在 public subnet, ASG 在 private subnet (重要)</li></ul></li><li>ELB cannot distribute traffic for targets deployed in different region</li><li>使用 ELB 的原因, 有 2 点<ul><li>Separate public traffic from private traffic</li><li>Build a highly available system</li></ul></li><li>Elastic Load Balancing use ports <code>1024-65535</code></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img141400.png"></p><ul><li>Application Load Balancer (HTTP &#x2F; HTTPS, Layer 7)</li><li>Network Load Balancer (TCP &#x2F; UDP, Layer 4)<ul><li>NLB provide static DNS and static IP, ALB only provide static DNS</li></ul></li><li>Gateway Load Balancer (Security, Layer 3, 要特别注意)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img090125.png"></p><ul><li>如果问到 ELB route traffic 到一个 instance 或者 AZ 更多, 有 2 种可能性<ul><li>Instances of a specific capacity type aren’t equally distributed across AZ</li><li>Sticky sessions are enabled for the load balancer</li></ul></li></ul><hr><h4 id="Application-Load-Balancer-ALB"><a href="#Application-Load-Balancer-ALB" class="headerlink" title="Application Load Balancer (ALB)"></a>Application Load Balancer (ALB)</h4><ul><li>Deal with Layer 7 (HTTP &#x2F; HTTPS, WebSocket)</li><li>Route base on Path <code>/Home</code> or Query <code>?Platform=Mobile</code></li><li>ALB adds an additional header called <code>X-Forwarded-For</code> contains the client’s IP</li><li>可以 configure ALB to redirect HTTP to HTTPS (重要)</li><li>ALB 无法被 assign Elstaic IP, NLB 可以</li><li>如果 ALB 没有 register 任何 target, 会造成 <code>HTTP 503: Service unavailable</code></li><li>可以使用 ALB access logs 来 analyze incoming requests for latencies and IP address</li><li>You cannot specify publicly routable IP addresses to an ALB</li><li>An ALB has three possible target types: Instance, IP, and Lambda</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img192523.png"></p><ul><li>Routing tables to different target groups<ul><li>Route based on path in URL</li><li>Route based on hostname in URL</li><li>Route based on Query String, Headers, Client IP</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img142631.png"></p><blockquote><p>To forward all requests to the website so that the requests will use HTTPS, a solutions architect can create a listener rule on the ALB that redirects HTTP traffic to HTTPS. </p></blockquote><hr><h4 id="Network-Load-Balancer-NLB"><a href="#Network-Load-Balancer-NLB" class="headerlink" title="Network Load Balancer (NLB)"></a>Network Load Balancer (NLB)</h4><ul><li>Deal with Layer 4 (TCP &#x2F; UDP), 很快, 处理有大量 request 的情况 (比如银行和游戏)<ul><li>NLB best suited for use-cases involving low latency and high throughput workloads</li></ul></li><li>One static IP per AZ or use Elastic IP</li><li>NLB supports HTTP health checks as well as TCP and HTTPS</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img144359.png"></p><blockquote><p>If you specify targets using an instance ID, traffic is routed to instances using the primary private IP address specified in the primary network interface for the instance.</p></blockquote><hr><h4 id="Gateway-Load-Balancer-GWLB"><a href="#Gateway-Load-Balancer-GWLB" class="headerlink" title="Gateway Load Balancer (GWLB)"></a>Gateway Load Balancer (GWLB)</h4><ul><li>Deal with Layer 3 (Security, 3rd Party)</li><li>GWLB allows perform inline inspection of traffic from multiple spoke VPCs in a simplified and scalable fashion</li><li>Use GENEVE protocol on port 6081</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img223042.png"></p><hr><h4 id="Sticky-Sessions-Session-Affinity"><a href="#Sticky-Sessions-Session-Affinity" class="headerlink" title="Sticky Sessions (Session Affinity)"></a>Sticky Sessions (Session Affinity)</h4><ul><li>Same client is always redirect to the same instance behind a load balancer</li><li>Make sure user doesn’t loss session data (比如用户登录)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img223425.png"></p><ul><li>Application-based Cookies: Don’t use AWSALB, AWSALBAPP, AWSALBTG</li><li>Duration-based Cookies: AWSALB for ALB, AWSELB for CLB</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img223604.png"></p><hr><h4 id="Cross-Zone-Load-Balancing"><a href="#Cross-Zone-Load-Balancing" class="headerlink" title="Cross Zone Load Balancing"></a>Cross Zone Load Balancing</h4><ul><li>ELB distributes traffic evenly across all registered EC2 instances in all AZs<ul><li>所有 Instance 分到的 traffic 一定是一样的</li><li>如果没有 enable, 那么 AZ 内部就是平均分</li></ul></li><li>ALB enabled by default, NLB disabled by default (重要)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img230059.png"></p><hr><h4 id="SSL-Certificates"><a href="#SSL-Certificates" class="headerlink" title="SSL Certificates"></a>SSL Certificates</h4><ul><li>Allow traffic between client and load balancer encrypted in transit (HTTPS)<ul><li>Manage SSL certificates using ACM (AWS Certificate Manager)</li></ul></li><li>如果问到需要管理很多个 SSL 或者 TSL, 选择 SNI (重要)</li><li>用来 deploy SSL&#x2F;TLS 的 AWS 服务是 AWS Certificate Manger 和 IAM (重要)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img230614.png"></p><ul><li>Could be used in ALB &amp; NLB, use SNI to make it work</li><li>SNI: Load multiple SSL certificates onto one web server (Server Name Indication)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img230910.png"></p><blockquote><p>Server Name Indication (SNI) allows you to expose multiple HTTPS applications each with its own SSL certificate on the same listener. </p></blockquote><hr><h4 id="Deregistration-Delay-Connection-Draining"><a href="#Deregistration-Delay-Connection-Draining" class="headerlink" title="Deregistration Delay (Connection Draining)"></a>Deregistration Delay (Connection Draining)</h4><ul><li>Waiting for existing connections to complete</li><li>Connection Draining enables the load balancer to complete in-flight requests made to instances that are de-registering or unhealthy</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img231418.png"></p><hr><h4 id="AWS-ASG"><a href="#AWS-ASG" class="headerlink" title="AWS ASG"></a>AWS ASG</h4><ul><li>ASG 可以和 ELB 一起用, 来 scale in 或者 out 基于服务器压力 (ASG 是免费的)</li><li>ASG 可以保证最少或最多有多少 EC2 Instance 在工作 (min, max)<ul><li>ASG 是在一个 Region 里面去根据 availiable 的 AZ 进行 scale</li><li>ASG 没有办法 span across multiple Regions</li></ul></li><li>当一个 Instance 是 unhealthy 的时候, ASG 会 terminate 这个 Instance<ul><li>ASG 在一个 AZ 里最早 terminate 的是那个最早被 launch 的 Instance</li><li>遇到 unbalanced 的情况, ASG 是先 launch new instance 然后 terminate old instance</li><li>在 unhealthy 的情况下是先 terminate unhealth Instance 然后 create new instance</li></ul></li><li>如果问到在某个节日前去 scale, 那就是 ASG Scheduled Action</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img232350.png"></p><ul><li>可以和 ELB 一起用, 来 scale out 或者 in 基于服务器压力</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img232615.png"></p><ul><li>Launch Template: 可以作为 template 来生成 EC2 Instance<ul><li>Launch Template 是管要生成什么 Instance 的 (eg. Spot, On-Demand)</li><li>Launch Configuration 是管生成的 Instance 的信息的 (eg. AMI, security group)</li></ul></li><li>如果要更新 Launch Template, 需要删掉旧的然后使用新的 (注意)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img232823.png"></p><ul><li>可以和 CloudWatch Alarm 一起根据服务器压力 scale out 或 scale in<ul><li>需要一个 CloudWatch custom metric</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img232959.png"></p><ul><li>ASG Scaling Cooldowns<ul><li>After a scaling activity, you are in the cooldown period (default 300 seconds)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img025149.png"></p><ul><li>ASG 不 terminate Instance 的情况<ul><li>The health check grace period for the instance has not expired</li><li>The instance maybe in Impaired status</li><li>The instance has failed the Elastic Load Balancing (ELB) health check status</li></ul></li></ul><hr><h4 id="Scaling-Policies"><a href="#Scaling-Policies" class="headerlink" title="Scaling Policies"></a>Scaling Policies</h4><ul><li>Target Tracking Scaling: 根据 CPU 用量或者 SQS 长度来 scale</li><li>Simple &#x2F; Step Scaling: 和 CloudWatch Alarm 关联</li><li>Scheduled Actions: 比如在感恩节那天进行 scale</li><li>Predictive Scaling: Forecast load and schedule scaling ahead</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img233532.png"></p><ul><li>注意, 对于 EC2 Scaling Policy 来说, 一定不可能超过 maximum capacity (重要)</li></ul><hr><h4 id="ASG-Instance-Refresh"><a href="#ASG-Instance-Refresh" class="headerlink" title="ASG Instance Refresh"></a>ASG Instance Refresh</h4><ul><li>Update launch template and then re-creating all EC2 Instance</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img212220.png"></p><hr><h3 id="6-AWS-Fundamentals"><a href="#6-AWS-Fundamentals" class="headerlink" title="6. AWS Fundamentals"></a>6. AWS Fundamentals</h3><h4 id="AWS-RDS"><a href="#AWS-RDS" class="headerlink" title="AWS RDS"></a>AWS RDS</h4><ul><li>使用 RDS 的好处 (对比将数据库存在 EC2 上)<ul><li>Automated provisioning, auto-scaling, backup</li><li>Read Replicas (最多 15 个) 和 Multi-AZ</li></ul></li><li>RDS Read Replica: If master database is encrypted, the replica is also encrypted<ul><li>注意, Read Replica 提高的是 read, 而不是 scale 数据库的 storage (而且 Replica 贵), 处理类似 report 或者 analytics 的就是 Read Replica</li><li>Read Replica 不是提高 High Availability, Multi-AZ 才是</li><li>Cross-Region Read Replica: 可以作为 DB backup (Replica in different Region)</li></ul></li><li>RDS Multi-AZ: RDS create a primary DB Instance and synchronously replicates the data to a standby instance in a different AZ (High Availability)<ul><li>RDS Multi-AZ update 是 standby 和 primary 一起 update (会有 downtime)</li></ul></li><li>Support MySQL, PostgreSQL, MariaDB, Oracle, MS SQL Server, and Amazon Aurora</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img161720.png"></p><ul><li>RDS - Storage Auto Scaling (重要)<ul><li>For application with unpredictable workloads</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img161952.png"></p><ul><li>RDS - Disaster Recovery<ul><li>Create a Read Replica in different region and enable Multi-AZ on Read Replica</li></ul></li><li>IAM Database Authentication: 可以用来访问 RDS</li><li>可以从 RDS Read Replica 迁移到 Aurora Read Replica, 这个做法可以 minimal change<ul><li>注意, 这只适用于 Read Replica 的情况下, 正常情况就直接开 auto scaling</li></ul></li><li>RDS OS update 是先 update standby, 然后把 standby promote 成 primary, 然后 update 原来的 primary, 最后原来的 primary 变成新的 standby (重要)</li></ul><hr><h4 id="Read-Replicas-vs-Multi-AZ"><a href="#Read-Replicas-vs-Multi-AZ" class="headerlink" title="Read Replicas vs. Multi AZ"></a>Read Replicas vs. Multi AZ</h4><ul><li>Read Replicas: Scalability, Async Replication<ul><li>Within AZ, Cross AZ or Cross Region</li></ul></li><li>Read Replicas in Same Region is free (Replication in AZs), Cross Region is not free</li><li>You can’t create encrypted Read Replicas from an unencrypted RDS DB instance.</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img173522.png"></p><ul><li>用 Production databse 处理日常, 用 Read Replica 来建一个副本处理数据分析</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img173820.png"></p><ul><li>Multi AZ: High Availability, Disaster Recovery, Sync Replication<ul><li>在 Multi-AZ 的情况下, 当 RDS 数据库 goes down, CNAME 会更新指向 standby</li><li>Multi AZ 不需要你去更改 SQL connection string</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img174148.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img174357.png"></p><hr><h4 id="AWS-Aurora"><a href="#AWS-Aurora" class="headerlink" title="AWS Aurora"></a>AWS Aurora</h4><ul><li>Support PostgreSQL and MySQL (不需要管理 storage)</li><li>Aurora 没有 standby database, Aurora Replica 可以作为 failover target</li><li>一般来说, Aurora 比 RDS 快</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img183915.png"></p><ul><li>High Availiability &amp; Read Scaling (Aurora Read Replica)<ul><li>One Master Write, Multiple Read Replicas (Up to 15 Replica), 一共 16 个</li><li>如果问到和 Aurora 有关, 且关于处理网络请求激增的问题, 选 Aurora Replica</li><li>Replica Tier 越高, failover 时就会先被 promote</li></ul></li><li>如果问到关于 Aurora 的 Auto-Scaling, 那就是 Aurora Serverless</li><li>如果问到 Aurora 而且是 test database, 选择 Aurora Database Cloning</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img184105.png"></p><hr><h4 id="RDS-Security"><a href="#RDS-Security" class="headerlink" title="RDS Security"></a>RDS Security</h4><ul><li>At-rest encryption: AWS KMS (Key Management Service)</li><li>In-flight encryption: AWS TLS Certificates</li><li>IAM Authentication: IAM roles to connect to database (重要)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img133048.png"></p><hr><h4 id="RDS-Proxy"><a href="#RDS-Proxy" class="headerlink" title="RDS Proxy"></a>RDS Proxy</h4><ul><li>Have a proxy for access RDS or Aurora, 缓解数据库压力, minimize open connections<ul><li>Allow apps to pool and share DB connections (提高 DB efficiency)</li><li>Reduced RDS &amp; Aurora failover time by up 66% (重要)</li><li>Enforce IAM authentication for DB</li></ul></li><li>Serverless, auto scaling, highly avaliable (Multi-AZ)</li><li>Not publicly accessible (Need to use VPC)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img184531.png"></p><hr><h4 id="AWS-ElastiCache"><a href="#AWS-ElastiCache" class="headerlink" title="AWS ElastiCache"></a>AWS ElastiCache</h4><ul><li>Manage Redis or Memcached (ElastiCache 可以解决数据库高频读取的问题, 重要)<ul><li>ElastiCache 不支持 relational database, 也不能用 SQL queries</li></ul></li><li>Cache are in-memory database with high performance and low latency (compute-intensive)</li><li>Cache helps reduce load off of database for read intensive workload (read heavy)</li><li>Help to make application stateless (AWS 负责大部分工作)</li><li>处理 S3 的是 CloudFront, 而不是 ElastiCache (记住)</li><li>支持 multi-threading 的是 ElastiCache for Memcached</li><li>关于 ElastiCache for Redis cluster 的 2 个知识点<ul><li>All the nodes in a Redis cluster must reside in the same region</li><li>While using Redis with cluster mode enabled, you cannot manually promote any of the replica nodes to primary</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img184841.png"></p><ul><li>DB Cache: Get data from ElastiCache<ul><li>If not avaliable, get from RDS and store in ElastiCache</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img185024.png"></p><ul><li>User Session: Write Session data into ElastiCache<ul><li>User in another instance could still be logged in</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img185153.png"></p><ul><li>Redis vs Memcahed<ul><li>Redis: Read Replicas, High Availiablity, Backup and restore (非常重要)</li><li>Memcached: Not High Availiablity, No Backup, risk to lose data, Multi-threaded</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img185310.png"></p><blockquote><p>The maximum number of Read Replicas you can add in an ElastiCache Redis Cluster with Cluster Mode Disabled is 5.</p></blockquote><hr><h4 id="ElastiCache-Strategies"><a href="#ElastiCache-Strategies" class="headerlink" title="ElastiCache Strategies"></a>ElastiCache Strategies</h4><ul><li>Lazy Loading &#x2F; Cache-Aside &#x2F; Lazy Population<ul><li>Pros: Only requested data is cached (重要, only requested data)</li><li>Cons: Cache miss penalty results in 3 round trips &amp; stale data (数据可能不是最新的)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img200816.png"></p><ul><li>Write Through (write 耗时, 但是 read 的 latency 很低)<ul><li>Pros: Data in cache is never stale, write penalty with 2 calls (数据一定是最新的)</li><li>Cons: Missing data until data is added &#x2F; updated in the DB</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img201308.png"></p><ul><li>Cache Evictions &amp; Time-to-live (TTL)<ul><li>Cache Evictions: 这里指的是缓存达到上限的情况, 需要用 TTL 去按时清理缓存</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img201512.png"></p><hr><h4 id="MemoryDB-for-Redis"><a href="#MemoryDB-for-Redis" class="headerlink" title="MemoryDB for Redis"></a>MemoryDB for Redis</h4><ul><li>Redis-compatible, durable, in-memory database service (为 Redis 服务)</li><li>Durable in-memory data storage with Multi-AZ transactional log</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img201727.png"></p><hr><h3 id="7-Route-53"><a href="#7-Route-53" class="headerlink" title="7. Route 53"></a>7. Route 53</h3><h4 id="What’s-DNS"><a href="#What’s-DNS" class="headerlink" title="What’s DNS"></a>What’s DNS</h4><ul><li>Translate hostname into IP address: <code>www.google.com = 172.217.18.36</code></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img213136.png"></p><hr><h4 id="AWS-Route-53"><a href="#AWS-Route-53" class="headerlink" title="AWS Route 53"></a>AWS Route 53</h4><ul><li>User can update the DNS records (High available, scalable)</li><li>Route 53 is a Domain Registrar</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img213527.png"></p><ul><li>Route 53 Records:<ul><li>Domain Name, Record Type, Value, Routing Policy, TTL</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img213613.png"></p><ul><li>Route 53 Record Types<ul><li>A: IPv4</li><li>AAAA: IPv6</li><li>CNAME: Map hostname to another hostname</li><li>NS: Name Servers for the Hosted Zone</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img213753.png"></p><ul><li>Route 53: Hosted Zones<ul><li>Public Hosted Zones: Public domain name</li><li>Private Hosted Zones: Private domain name (VPC)</li></ul></li></ul><blockquote><p>注意, DNS hostnames and DNS resolution are required settings for private hosted zones</p></blockquote><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img234126.png"></p><ul><li>GoDaddy + Route 53 (As DNS Service Provider)<ul><li>Create a Public Hosted Zone and update the 3rd party Registrar NS records</li></ul></li><li>Route 53 Health Check<ul><li>如果 ELB 出问题, 就去找 Route 53 Health Check</li></ul></li></ul><hr><h4 id="Route-53-TTL"><a href="#Route-53-TTL" class="headerlink" title="Route 53 TTL"></a>Route 53 TTL</h4><ul><li>TTL: Time To Live (生存时间)<ul><li>How long the value should be cached (后端更新不代表 cache 更新了)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img232659.png"></p><hr><h4 id="CNAME-vs-Alias"><a href="#CNAME-vs-Alias" class="headerlink" title="CNAME vs Alias"></a>CNAME vs Alias</h4><ul><li>CNAME: Point a hostname to another hostname<ul><li>从 <code>acme.example.com</code> 到 <code>zenith.example.org</code> 或者 <code>example.com</code> 到 <code>example.net</code></li></ul></li><li>Alias: Point a hostname to an AWS resource (对象是 CloudFront, S3 这些)<ul><li>从 <code>covid19survey.com</code> 到 <code>www.covid19survey.com</code></li><li>从 <code>app.mydomain.com</code> 到 <code>app.amazonaws.com</code></li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img233313.png"></p><hr><h4 id="Health-Checks"><a href="#Health-Checks" class="headerlink" title="Health Checks"></a>Health Checks</h4><ul><li>Health Checks are only for public resources</li><li>Health Check 检测: Endpoints, 其他 Health Checks, CloudWatch Alarms (重要)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img000106.png"></p><hr><h4 id="Routing-Policy-Simple"><a href="#Routing-Policy-Simple" class="headerlink" title="Routing Policy (Simple)"></a>Routing Policy (Simple)</h4><ul><li>Define how Route 53 responds to DNS queries (一共 7 种 Routing Policies)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img234623.png"></p><ul><li>Simple: Route traffic to a single resource<ul><li>If multiple values returned, a random one is chosen by client</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img234350.png"></p><hr><h4 id="Routing-Policy-Weighted"><a href="#Routing-Policy-Weighted" class="headerlink" title="Routing Policy (Weighted)"></a>Routing Policy (Weighted)</h4><ul><li>Weighted: Control the % of the request go to each resource</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img234856.png"></p><hr><h4 id="Routing-Policy-Latency"><a href="#Routing-Policy-Latency" class="headerlink" title="Routing Policy (Latency)"></a>Routing Policy (Latency)</h4><ul><li>Latency: Redirect to the resource that has the least latency close to us</li><li>Latency is based on traffic between users and AWS Regions</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img235654.png"></p><hr><h4 id="Routing-Policy-Failover"><a href="#Routing-Policy-Failover" class="headerlink" title="Routing Policy (Failover)"></a>Routing Policy (Failover)</h4><ul><li>Failover: Have a Primary Instance and a Secondary Instance (重要)<ul><li>When failover, switch to Secondary Instance</li></ul></li><li>注意, 当问到 failover 的时候, 选择的是 active-passive failover routing policy<ul><li>没有什么 active-active, 只有 active-passive</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img150940.png"></p><hr><h4 id="Routing-Policy-Geolocation"><a href="#Routing-Policy-Geolocation" class="headerlink" title="Routing Policy (Geolocation)"></a>Routing Policy (Geolocation)</h4><ul><li>Geolocation: Routing based on user location<ul><li>Need to create a “Default” record</li><li>Use cases: website localization, restrict content distribution 等等</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img151650.png"></p><hr><h4 id="Routing-Policy-Geoproximity"><a href="#Routing-Policy-Geoproximity" class="headerlink" title="Routing Policy (Geoproximity)"></a>Routing Policy (Geoproximity)</h4><ul><li>Geoproximity: Route traffic to resource based on geolocation<ul><li>But have the ability to shift more traffic to resource based on bias (重要)</li><li>可以做到 route more traffic or less</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img152310.png"></p><hr><h4 id="Routing-Policy-Traffic-Flow"><a href="#Routing-Policy-Traffic-Flow" class="headerlink" title="Routing Policy (Traffic Flow)"></a>Routing Policy (Traffic Flow)</h4><ul><li>Visual editor to manage complex routing decision trees<ul><li>Configuration can be saved as Traffic Flow Policy</li><li>Can be applied to different Route 53 Hosted Zone</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img224018.png"></p><hr><h4 id="Routing-Policy-IP-Based"><a href="#Routing-Policy-IP-Based" class="headerlink" title="Routing Policy (IP-Based)"></a>Routing Policy (IP-Based)</h4><ul><li>IP-Based: Routing based on client’s IP address<ul><li>Provide a list of CIDRs for your client</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img153711.png"></p><hr><h4 id="Routing-Policy-Multi-Value"><a href="#Routing-Policy-Multi-Value" class="headerlink" title="Routing Policy (Multi-Value)"></a>Routing Policy (Multi-Value)</h4><ul><li>Multi-Value: Route traffic to multiple resources<ul><li>Not a subsitute for ELB</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img153842.png"></p><hr><h3 id="8-VPC-Fundamentals"><a href="#8-VPC-Fundamentals" class="headerlink" title="8. VPC Fundamentals"></a>8. VPC Fundamentals</h3><h4 id="AWS-VPC"><a href="#AWS-VPC" class="headerlink" title="AWS VPC"></a>AWS VPC</h4><ul><li>VPC: Virtual Private Cloud, all AWS account have a default VPC</li><li>CIDR should not overlap, max CIDR size in AWS is &#x2F;16, min CIDR size in AWS is &#x2F;28</li><li>要让 VPC 使用 custom domain 需要 <code>enableDnsHostnames</code> 和 <code>enableDnsSupport</code></li><li>可以创建 Shared Service VPC, 这样每个 VPC 都可以 access 到需要的 services (重要)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img201530.png"></p><ul><li>Each Amazon EC2 instance that you launch into a VPC has a tenancy attribute (重要)<ul><li>可以在 dedicated 和 host 之间互相切换</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img042420.png"></p><hr><h4 id="VPC-Subnet"><a href="#VPC-Subnet" class="headerlink" title="VPC Subnet"></a>VPC Subnet</h4><ul><li>Allow you to partition your network inside the VPC (VPC 内划分网络)<ul><li>Can have Public Subnet and Private Subnet</li></ul></li><li>AWS reserves 5 IP addresses in each subnet (first 4 &amp; last 1, 重要)</li><li>Subnet is always associated with Route Table (重要)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img013421.png"></p><hr><h4 id="Internet-Gateway-IGW-amp-Route-Table"><a href="#Internet-Gateway-IGW-amp-Route-Table" class="headerlink" title="Internet Gateway (IGW) &amp; Route Table"></a>Internet Gateway (IGW) &amp; Route Table</h4><ul><li>IGW allow resource (eg. EC2 Instance) in a VPC connect to internet (重要)<ul><li>相当于让 VPC 里的 resource 可以连上网</li><li>IGW 需要 Route Table (重要)</li></ul></li><li>如果 IGW 出问题<ul><li>Need to also have Route Table (首先检查 Route Table, 因为 IGW 需要)</li><li>检查 Security Group 是否允许通过</li></ul></li><li>处理 Network Address Translation 的就是 Internet Gateway</li><li>Internet Gateway 无法直接在 private subnet 里面使用 (重要)</li><li>NAT 针对的是 Subnet 层面, IGW 针对的是 VPC 层面 (重要)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img202043.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img193121.png"></p><hr><h4 id="NAT-Gateway-NATGW"><a href="#NAT-Gateway-NATGW" class="headerlink" title="NAT Gateway (NATGW)"></a>NAT Gateway (NATGW)</h4><ul><li>AWS managed NAT, AZ specific, use Elastic IP (针对 IPv4, Egress 是 IPv6)<ul><li>Allow EC2 Instance in Private Subnet to connect to the Internet</li><li>Requires an IGW, NATGW 是处于 public subnet 的 (注意)</li></ul></li><li>NAT 针对的是 Subnet 层面, IGW 针对的是 VPC 层面</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img233648.png"></p><ul><li>Resilient within single AZ, Multiple-AZ need multiple NATGW <ul><li>每个 AZ 都要一个 NATGW, 用来 fault-tolerance (容错能力)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img203654.png"></p><hr><h4 id="NACL-amp-Security-Groups"><a href="#NACL-amp-Security-Groups" class="headerlink" title="NACL &amp; Security Groups"></a>NACL &amp; Security Groups</h4><ul><li>The request has to go over NACL before go to Subnet (Subnet level)<ul><li>NACL is stateless (inbound outbound 都要检测)</li></ul></li><li>The request has to go over Security Group before go to EC2 Instance (Instance level)<ul><li>Security Group (SG) is stateful (inbound accepted &#x3D; outbound accepted)</li></ul></li><li>反正记住 NACL 是 Subnet level (stateless), Security Group 是 Instance level (stateful)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img204310.png"></p><ul><li>Network Access Control List (NACL)<ul><li>NACL control traffic from and to subnets (eg. block IP)</li><li>One NACL per subnet, each subnet have default NACL (注意)<ul><li>Default NACL accept every inbound and outbound</li><li>但是 custom NACL 默认是 deny inbound 和 outbound 的 (注意)</li></ul></li><li>NACL Rules have number, higher precedence with lower number (越优先数字越低)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img204553.png"></p><hr><h4 id="VPC-Flow-Logs"><a href="#VPC-Flow-Logs" class="headerlink" title="VPC Flow Logs"></a>VPC Flow Logs</h4><ul><li>Capture information about IP traffic going into interfaces (监视 IP 流量的)<ul><li>Monitor &amp; troubleshoot connectivity issues (网络连接问题)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img231819.png"></p><hr><h4 id="VPC-Peering"><a href="#VPC-Peering" class="headerlink" title="VPC Peering"></a>VPC Peering</h4><ul><li>VPC Peering: Privately connect two VPCs using AWS network (只适合少量 VPC, 重要)<ul><li>每一对 VPC 都要 VPC Peering, 和 S3 Replication 类似</li></ul></li><li>Can create VPC Peering between VPCs in different AWS accounts &#x2F; regions</li><li>Need to update Route Table in each VPC subnet to make sure they can communicate<ul><li>出问题就检查 Route Table</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img205313.png"></p><hr><h4 id="VPC-Sharing"><a href="#VPC-Sharing" class="headerlink" title="VPC Sharing"></a>VPC Sharing</h4><ul><li>VPC Sharing: Allows multiple AWS accounts to create resources (eg. EC2, RDS) into shared and centrally-managed AWS VPC (重要)<ul><li>遇到 centrally managed 的就是 VPC Sharing</li><li>而且是 owner 需要 share one or more subnet (注意)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img824817.png"></p><hr><h4 id="VPC-Endpoints-AWS-PrivateLink"><a href="#VPC-Endpoints-AWS-PrivateLink" class="headerlink" title="VPC Endpoints (AWS PrivateLink)"></a>VPC Endpoints (AWS PrivateLink)</h4><ul><li>VPC Endpoints allow private access to AWS services within a VPC (重要)<ul><li>用 Private Network 连接 AWS 服务, 和 On-Premise 没有关系</li><li>Interface Endpoint 支持大部分 AWS 服务 (付费)</li><li>Gateway Endpoint 只支持 S3 和 DynamoDB (很容易考, 免费)</li></ul></li><li>注意, VPC Gateway Endpoint 专门处理 S3 和 DynamoDB (不要去选择 NAT 或者 IGW)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img205719.png"></p><ul><li>两种 Types of Endpoints (Interface &#x2F; Gateway)<ul><li>Interface Endpoints: Supports most AWS services (付费)</li><li>Gateway Endpoints: Must be used as a target in a route table (免费, 重要)<ul><li>Only support S3 and DynamoDB (只支持 S3 和 DynamoDB)</li></ul></li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img205939.png"></p><hr><h4 id="Site-to-Site-VPN-VPN-Connection"><a href="#Site-to-Site-VPN-VPN-Connection" class="headerlink" title="Site-to-Site VPN (VPN Connection)"></a>Site-to-Site VPN (VPN Connection)</h4><ul><li>Site-to-Site VPN: Connect AWS to Corporate Data Center over public internet (重点, public internet, On-Premise to AWS)<ul><li>Need a Virtual Private Gateway (VGW) on VPC (AWS 方)</li><li>Need a Customer Gateway (CGW) on DC (On-Premise 方)</li></ul></li><li>对比 DX, Site-to-Site VPN 没有提供 low latency, and high throughput connection</li><li>Site-to-Site VPN 有 encrypted network connectivity between On-Premise and VPC</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img232320.png"></p><ul><li>需要 VPN Gateway 和 Customer Gateway 来连接 VPC 和 On-Premise</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img232649.png"></p><hr><h4 id="Direct-Connect-DX"><a href="#Direct-Connect-DX" class="headerlink" title="Direct Connect (DX)"></a>Direct Connect (DX)</h4><ul><li>Provide a dedicated private connection from a remote network to VPC (重点, private internet, On-Premise to AWS)<ul><li>需要设置 VGW, 如果给 DX 找 backup, 那么就选择 Site-to-Site VPN (这两个服务类似)</li><li>对比 Site-to-Site VPN, DX provide low latency, and high throughput connection</li><li>DX 不支持 encrypted network connectivity, Site-to-Site VPN 可以, 但是如果需要 encrypt DX connection 可以和 AWS VPN 一起用 (注意)</li><li>DX 的 set up 时间很长 (所以 DX 不算什么 quick solution)</li></ul></li><li>All private, no public network involve (注意, 如果问到 all Private 就是 DX)<ul><li>Direct Connect does not involve the Internet</li></ul></li><li>可以 access public resources (S3) 和 private resources (EC2)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img233024.png"></p><ul><li>两种 Connection Type (带宽选项, Dedicated 最快)<ul><li>Dedicated Connections: 1Gbps 到 100Gbps</li><li>Hosted Connections: 50Mbps 到 10 Gbps</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img004140.png"></p><ul><li>Direct Connect Gateway (连接许多 VPC 在不同的 Region)<ul><li>Direct Connection to one or more VPC in many different regions</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img233531.png"></p><ul><li>PrivateLink vs DX<ul><li><p>AWS PrivateLink provides a connection between VPCs (Virtual Private Clouds) and AWS services while bypassing the public Internet. It is a private network connection that securely transfers data without leaving the AWS network</p></li><li><p>AWS Direct Connect is a dedicated, private connection between the customer’s on-premises infrastructure at a data center and an AWS location. The main features of the connection are ultra-fast data transfer rates, low latency, and improved security since it bypasses the public Internet</p></li></ul></li></ul><hr><h3 id="9-S3"><a href="#9-S3" class="headerlink" title="9. S3"></a>9. S3</h3><h4 id="AWS-S3"><a href="#AWS-S3" class="headerlink" title="AWS S3"></a>AWS S3</h4><ul><li>S3 Buckets (S3 是 Global 的, 但是 Bucket 是 Regional 的)<ul><li>Store objects (files) in “buckets”</li><li>Buckets must have globally unique name (名字必须独特)</li><li>Buckets are defined at region level</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img171839.png"></p><ul><li>Objects (files) have a key, max object size is 5TB</li><li>如果上传超过 5 GB, 就要用 Multi-Part Upload (还有 S3 Transfer Acceleration)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img172025.png"></p><ul><li>S3 sync command: Uses the <code>CopyObject</code> APIs to copy objects between S3 buckets</li><li>S3 always return the lastest version of the object (重要)</li><li>S3 没办法加密 metadata</li><li>S3 是 serverless 的</li><li>如果遇到需要处理 static content 的, 就一定是 S3 + CloudFront (重要)</li><li>如果问到 S3 而且是关于图片上传, 选择 S3 Event Notification, 不是 EventBridge (重要)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/imglifecycle-transitions-v2.png"></p><ul><li>如果发现 S3 的传输功能出问题, 那么就给 S3 bucket 加上 prefix (重要)</li><li>注意, S3 和 database 是不沾边的, S3 不是数据库</li><li>如果要 control access to data stored on AWS S3, 可以用下面 2 点<ul><li>Query String Authentication, Access Control List (ACLs)</li><li>Bucket policies, Identity and Access Management (IAM) policies</li></ul></li><li>In order to get object access log, the object owner also need to be bucket owner</li><li>S3 Object Ownership is a S3 bucket setting that control ownership of new objects that are uploaded to a bucket (重要)</li></ul><blockquote><p>By default, an Amazon S3 object is owned by the AWS account that uploaded it. This is true even when the bucket is owned by another account (重要)</p></blockquote><hr><h4 id="S3-Bucket-Policy"><a href="#S3-Bucket-Policy" class="headerlink" title="S3 Bucket Policy"></a>S3 Bucket Policy</h4><ul><li>User-Based Security<ul><li>IAM Policies: Which API calls should be allowed for a user from IAM (重要)</li></ul></li><li>Resource-Based Security<ul><li>Bucket Policies: Bucket rules (比如让 object public)</li></ul></li><li>注意, IAM Policy 的 precedence 是比 S3 Bucket Policy 要优先的</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img173050.png"></p><ul><li>S3 Bucket Policies (JSON based policies)<ul><li>Resoruces: buckets and objects</li><li>Effect: Allow &#x2F; Deny</li><li>Actions: API to Allow or Deny</li><li>Principal: The account or user to apply the policy to</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img173325.png"></p><hr><h4 id="S3-Website"><a href="#S3-Website" class="headerlink" title="S3 Website"></a>S3 Website</h4><ul><li>Host 在 S3 上面的网站一般是以下两种后缀 (dash Region 或者 dot Region)<ul><li>s3-website-Region: <code>http://bucket-name.s3-website-Region.amazonaws.com</code></li><li>s3-website.Region: <code>http://bucket-name.s3-website.Region.amazonaws.com</code></li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img043622.png"></p><hr><h4 id="S3-Versioning"><a href="#S3-Versioning" class="headerlink" title="S3 Versioning"></a>S3 Versioning</h4><ul><li>Enabled at the bucket level (Default is null)</li><li>Best pratice to version the buckets (可以 roll back, 可以防止误删, 重要)<ul><li>可以防止 accidental deletion of objects</li></ul></li><li>Once version-enable a bucket, it can never return to an unversioned state (重要)</li><li>Versioning 是针对这个 bucket 里面的所有 object, 所以不能指定 folder 来 versioning</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img174246.png"></p><hr><h4 id="S3-Replication-CRR-amp-SRR"><a href="#S3-Replication-CRR-amp-SRR" class="headerlink" title="S3 Replication (CRR &amp; SRR)"></a>S3 Replication (CRR &amp; SRR)</h4><ul><li>CRR: Cross Region Replication (compliance, lower latency access)</li><li>SRR: Same Region Replication (create test environment)<ul><li>Must enable Versioning</li><li>The Copying is asynchronous</li><li>Must give IAM permissions to S3</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img174840.png"></p><ul><li>Only new objects are replicated, existing objects need S3 Batch Replication<ul><li>也就是说只有新的 object 会被 Replicate, 老的 object 要 S3 Batch Replication</li></ul></li><li>No “chaining” in replication<ul><li>比如把 A 复制到 B 和 C, 需要 A 复制到 B 和 A 复制到 C</li></ul></li><li>S3 lifecycle actions are not replicated with S3 Replication</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img175004.png"></p><hr><h4 id="S3-Storage-Classes"><a href="#S3-Storage-Classes" class="headerlink" title="S3 Storage Classes"></a>S3 Storage Classes</h4><ul><li>一共 7 种 Storage Class: General + 2 IA + 3 Glacier + Intelligent</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img175742.png"></p><ul><li>S3 Standard - General Purpose<ul><li>Used for frequently accessed data (最常见)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img175932.png"></p><ul><li>S3 Infrequent Access (Standard IA &amp; One Zone IA)<ul><li>For data is less frequent access but require rapid access when needed (重要)</li><li>Lower cost than Standard </li><li>从 Standard 转到 One Zone IA 最少要 30 天</li><li>One Zone IA 不是 High Availability 的选择 (注意, 因为 AZ 会 down)</li><li>如果遇到 access is always required 就不能选 One Zone IA, 因为 AZ 可能会 down</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img180147.png"></p><ul><li>S3 Glacier Storage Classes (Archive 专用)<ul><li>Low-cost object storage for archiving &#x2F; backup</li><li>Price: storage + retrieval</li><li>S3 Glacier Instant Retrieval: Glacier 里最快但也最贵</li><li>S3 Glacier Flexible Retrieval: 三种模式 (Expedited 加急, Standard, Bulk 批量)</li><li>S3 Glacier Deep Archive: 存的时间最久, 两种模式 (Standard, Bulk), 48 小时 retrieval</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img180642.png"></p><ul><li>S3 Intelligent Tiering<ul><li>Move objects automatically between Access Tiers based on usage</li><li>就是自动帮你把 Object 移到不同的 Storage Class 里</li><li>Intelligent Tier 是在 Standard 和 Standard IA 下面的, 不能从下往上转移</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img180806.png"></p><hr><h3 id="10-AWS-CLI-SDK-IAM-Roles-amp-Policies"><a href="#10-AWS-CLI-SDK-IAM-Roles-amp-Policies" class="headerlink" title="10. AWS CLI, SDK, IAM Roles &amp; Policies"></a>10. AWS CLI, SDK, IAM Roles &amp; Policies</h3><h4 id="EC2-Instance-Metadata-IMDS"><a href="#EC2-Instance-Metadata-IMDS" class="headerlink" title="EC2 Instance Metadata (IMDS)"></a>EC2 Instance Metadata (IMDS)</h4><ul><li>Allow EC2 Instance to “learn about themselves” without using an IAM Role</li><li>AWS CLI 用 Instance Metadata 去拿 temporary credentials (在 Python 环境下)<ul><li>Metadata &#x3D; info about the EC2 Instance (没法拿到 IAM Policy)</li><li>Userdata &#x3D; launch script of the EC2 Instance</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img150522.png"></p><ul><li>IMDSv2 vs. IMDSv1<ul><li>IMDSv1 access <code>http://169.254.169.254/latest/meta-data</code> (不推荐)</li><li>IMDSv2 is more secure and done in two steps</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img150716.png"></p><hr><h4 id="MFA-with-CLI"><a href="#MFA-with-CLI" class="headerlink" title="MFA with CLI"></a>MFA with CLI</h4><ul><li>To use MFA with CLI, you must create a temporary session<ul><li>Run the <code>STS GetSession</code> API call</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img151057.png"></p><ul><li>如果是 check IAM permission, 用 <code>AWS CLI --dry-run</code></li></ul><hr><h4 id="AWS-SDK"><a href="#AWS-SDK" class="headerlink" title="AWS SDK"></a>AWS SDK</h4><ul><li>Perform actions on AWS directly from your application code</li><li>If not configure a default region, <code>us-east-1</code> will be chosen by default</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img151356.png"></p><hr><h4 id="AWS-Limits-Quotas"><a href="#AWS-Limits-Quotas" class="headerlink" title="AWS Limits (Quotas)"></a>AWS Limits (Quotas)</h4><ul><li>API Rate Limits<ul><li>For Intermittent Errors: implement Exponential Backoff</li><li>For Consistent Errors: request an API throttling limit increase (通过 AWS 申请)</li></ul></li><li>Service Quotas &#x2F; Limits<ul><li>Request a service limit increase by opening a ticket</li><li>Request a service quota increase by Service Quotas API</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img151813.png"></p><ul><li>Exponential Backoff<ul><li>If get <code>ThrottlingException</code> intermittently, use exponential backoff</li><li>It’s a retry mechanism included in AWS SDK API calls</li><li>Only retry for 5XX errors</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img152100.png"></p><hr><h4 id="AWS-CLI-Credentials-Provider-Chain"><a href="#AWS-CLI-Credentials-Provider-Chain" class="headerlink" title="AWS CLI Credentials Provider Chain"></a>AWS CLI Credentials Provider Chain</h4><ul><li>The CLI will look credentials in order<ul><li><code>Command Line Options -&gt; Environment Variables -&gt; EC2 Instance Profile</code></li></ul></li><li>The credentials chain could give priority to the environment variables</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img152316.png"></p><hr><h4 id="AWS-Sigv4"><a href="#AWS-Sigv4" class="headerlink" title="AWS Sigv4"></a>AWS Sigv4</h4><ul><li>AWS SigV4 是对 AWS 请求进行签名的身份验证方法，确保安全和完整性 (2 种选择)<ul><li>HTTP Header: Signature in Authorization header</li><li>Query String: Signature in <code>X-Amz-Signature</code></li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img153415.png"></p><hr><h3 id="11-Advanced-S3"><a href="#11-Advanced-S3" class="headerlink" title="11. Advanced S3"></a>11. Advanced S3</h3><h4 id="S3-Lifecycle-Rules"><a href="#S3-Lifecycle-Rules" class="headerlink" title="S3 Lifecycle Rules"></a>S3 Lifecycle Rules</h4><ul><li>Transition objects between storage classes (比如从 IA 到 Glacier)<ul><li>Transition 需要 Lifecycle Rules (重要)</li></ul></li><li>比如从 Snowball 到 Glacier 就需要 Lifecycle Rule</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img235516.png"></p><ul><li>Transition Actions: Configure objects to transition to another storage class (转移)</li><li>Expiration Actions: Configure objects to expire after some time (删除)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img235639.png"></p><ul><li>S3 Analytics: Help decide when to transition objects to the right storage class</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img000151.png"></p><hr><h4 id="S3-Event-Notifications"><a href="#S3-Event-Notifications" class="headerlink" title="S3 Event Notifications"></a>S3 Event Notifications</h4><ul><li>Automatically react to certain event happened in S3 (比如图片上传)<ul><li>Need to have IAM Permissions</li><li>S3 Event Notification 的 destination 是 SQS, SNS, Lambda (记住)</li></ul></li><li>大部分和 S3 事件相关的都是 S3 Event Notification, 而不是 EventBridge (重要)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img000725.png"></p><hr><h4 id="S3-Performance"><a href="#S3-Performance" class="headerlink" title="S3 Performance"></a>S3 Performance</h4><ul><li>For Upload 上传 (重要)<ul><li>Multi-Part Upload: 当上传文件大于 5 GB, 可以 parallelize uploads</li><li>S3 Transfer Acceleration: 将文件传到 AWS edge location, 可以和 Multi-Part 一起用</li><li>S3 Transfer Acceleration (S3TA) can speed up content transfers to and from S3</li><li>注意, S3 Transfer Acceleration 没办法 copy object between buckets</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img001645.png"></p><ul><li>For Download 下载<ul><li>S3 Byte-Range Fetches: Parallelize GETs, retrieve partial data (拿部分数据, 重要)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img001828.png"></p><hr><h4 id="S3-Select-amp-Glacier-Select"><a href="#S3-Select-amp-Glacier-Select" class="headerlink" title="S3 Select &amp; Glacier Select"></a>S3 Select &amp; Glacier Select</h4><ul><li>S3 Select 使用 SQL 来做 server-side filtering, 过滤从而减少数据量</li><li>Less network transfer, less CPU cost client-side</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img002050.png"></p><hr><h4 id="S3-Object-Tags-amp-Metadata"><a href="#S3-Object-Tags-amp-Metadata" class="headerlink" title="S3 Object Tags &amp; Metadata"></a>S3 Object Tags &amp; Metadata</h4><ul><li>S3 User-Defined Object Metadata: Must begin with <code>x-amz-meta-</code></li><li>S3 Object Tags: Useful for fine-grained permission or analytics purpose</li><li>You cannot search the object metadata or object tags (重要)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img194215.png"></p><hr><h3 id="12-S3-Security"><a href="#12-S3-Security" class="headerlink" title="12. S3 Security"></a>12. S3 Security</h3><h4 id="S3-Encryption"><a href="#S3-Encryption" class="headerlink" title="S3 Encryption"></a>S3 Encryption</h4><ul><li>Server-Side Encryption (SSE-S3 免费, SSE-KMS 要钱, SSE-C)</li><li>Client-Side Encryption (如果用户已经有 encryption method)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img223133.png"></p><ul><li>Server-Side Encryption with Amazon S3-Managed Keys (SSE-S3)<ul><li>Enabled by default for new buckets &amp; objects</li><li>SSE-S3 的 header 是 <code>x-amz-server-side-encryption:AES256</code></li><li>使用 SSE-S3, 每一个 Object 都是由 unique key 来 encrypt 的</li><li>SSE-S3 使用 256-bit Advanced Encryption Standard (AES-256)</li><li>SSE-S3 是没有 automatic key rotation 的, 要用 SSE-KMS (重要)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img223242.png"></p><ul><li>Server-Side Encryption with KMS Keys stored in AWS KMS (SSE-KMS)<ul><li>User control + audit key usage in CloudTrail (可以管理 key rotation)</li><li>SSE-KMS 的 header 是 <code>x-amz-server-side-encryption:aws:kms</code></li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img223417.png"></p><ul><li>Server-Side Encryption with Customer-Provided Keys (SSE-C)<ul><li>用户自己有 keys, AWS will not store the key, HTTPS must be used (重要)</li><li>当问题中提到用户需要使用自己的 key, 但是打算在 AWS 端做 encryption</li><li>S3 will reject any requests made over <code>HTTP</code> when using SSE-C (重要)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img223602.png"></p><ul><li>Client-Side Encryption<ul><li>User fully manages the keys and encryption cycle</li><li>数据在送到 AWS 之前就是加密好的</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img223715.png"></p><ul><li>Encryption in Transit (SSL&#x2F;TLS)<ul><li>可以用 <code>aws:SecureTransport</code> 来 enforce (不过有 SSL 基本上就是 HTTPS)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img223811.png"></p><hr><h4 id="S3-CORS"><a href="#S3-CORS" class="headerlink" title="S3 CORS"></a>S3 CORS</h4><ul><li>CORS: Cross-Origin Resource Sharing (跨域问题)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img224630.png"></p><ul><li>S3 CORS (重要)<ul><li>A client makes a cross-origin request on S3 bucket, need the correct CORS headers</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img224951.png"></p><hr><h4 id="S3-MFA-Delete"><a href="#S3-MFA-Delete" class="headerlink" title="S3 MFA Delete"></a>S3 MFA Delete</h4><ul><li>MFA Delete: 防止不小心删除文件, 用户需要先验证身份 (重要)<ul><li>To use MFA Delete: Versioning must be enabled</li></ul></li><li>Only the bucket owner (root user) can enable&#x2F;disable MFA Delete (重要)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img225415.png"></p><hr><h4 id="S3-Access-Logs"><a href="#S3-Access-Logs" class="headerlink" title="S3 Access Logs"></a>S3 Access Logs</h4><ul><li>Any request made to S3 will be logged to another S3 bucket (数据分析)<ul><li>可以作为 Data Analysis 的工具</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img230251.png"></p><hr><h4 id="S3-Pre-signed-URL"><a href="#S3-Pre-signed-URL" class="headerlink" title="S3 Pre-signed URL"></a>S3 Pre-signed URL</h4><ul><li>S3 Pre-signed URL 允许临时访问特定 S3 对象的 URL</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img230702.png"></p><hr><h4 id="S3-Access-Points"><a href="#S3-Access-Points" class="headerlink" title="S3 Access Points"></a>S3 Access Points</h4><ul><li>Access Points simplify security management for S3 Buckets (根据用户属性)</li><li>Each Access Point: DNS name + Access Point Policy</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img231500.png"></p><hr><h4 id="S3-Object-Lambda"><a href="#S3-Object-Lambda" class="headerlink" title="S3 Object Lambda"></a>S3 Object Lambda</h4><ul><li>Use AWS Lambda to change object before retrieve by caller (在到达 caller 之前)<ul><li>用途: 可以给图片打水印</li></ul></li><li>需要 S3 Access Point 和 S3 Object Lambda Access Points</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img231810.png"></p><hr><h3 id="13-CloudFront"><a href="#13-CloudFront" class="headerlink" title="13. CloudFront"></a>13. CloudFront</h3><h4 id="AWS-CloudFront"><a href="#AWS-CloudFront" class="headerlink" title="AWS CloudFront"></a>AWS CloudFront</h4><ul><li>Content Delivery Network (CDN), 可以 serve static &amp; dynamic content<ul><li>Improve read performance, content is cached at the edge</li></ul></li><li>可以防止 DDoS protection (搭配 AWS Shield), 可以根据 content type 来 route, 可以指定 primary &amp; secondary origins 来做 high availiability &amp; failover</li><li>CloudFront Origins: S3 Bucket (OAC) 或者 Custom Origin (HTTP)<ul><li>OAC: Origin Access Control (重要, 如果涉及到 S3 的问题)</li></ul></li><li>如果问到 CloudFront 而且需要 encryption, 选择 field level encryption (不是 KMS)<ul><li>Field-level encryption allows you to enable your users to securely upload sensitive information to your web servers.</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img232701.png"></p><ul><li>CloudFront vs S3 Cross Region Replication<ul><li>CloudFront: 使用 global edge network, 有 TTL, 用于 static content</li><li>S3 Cross Region Replication (CRR): 每个 Region 都要设置, 但是没有 TTL, 用于 dynamic content (updated in near real-time, 只读)</li><li>问到 S3 并且有关 high available 和 low latency 的就是 S3 Cross Region Replication</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img233016.png"></p><ul><li>Price Classes: 不同地区的价格不一样<ul><li>可以用来 cost reduction (降低价格)</li></ul></li><li>CloudFront 允许 Proxy methods 和 Dynamic content 跳过 regional edge cache</li><li>除了 WAF 可以去 block IP, 还可以使用 OAI (origin access identity, 重要)<ul><li>OAI 也可以用来 secure communication between CloudFront &amp; S3</li></ul></li><li>可以用 CloudFront signed URLs 和 CloudFront signed cookies 来 restrict access to documents (比如 subscription)</li><li>Can configure CloudFront to require HTTPS from clients (可以用 CloudFront 要求 client 必须使用 HTTPS)</li></ul><hr><h4 id="CloudFront-Caching"><a href="#CloudFront-Caching" class="headerlink" title="CloudFront Caching"></a>CloudFront Caching</h4><ul><li>The cache lives at each CloudFront Edge Location</li><li>CloudFront identifies each object in the cache using Cache Key</li><li>如果遇到 CloudFront 处理 language 配置出问题, 那么可以用 <code>Query string forwarding and caching</code> (这道题很长)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img144432.png"></p><ul><li>CloudFront Cache Key<ul><li>By default, consists of hostname + resource portion of the URL</li><li>Could add other elements to the Cache Key using CloudFront Cache Policies</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img144654.png"></p><ul><li>Cache Policy: 可以使用 HTTP Headers, Cookies, Query Strings (重要)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img444857.png"></p><ul><li>Origin Request Policy<ul><li>Values that you want to include in origin requests without including in the Cache Key</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img145256.png"></p><hr><h4 id="CloudFront-Cache-Invalidation"><a href="#CloudFront-Cache-Invalidation" class="headerlink" title="CloudFront Cache Invalidation"></a>CloudFront Cache Invalidation</h4><ul><li>让 CloudFront 跳过 TTL 立即更新<ul><li>比如你更新了后端, 但是 CloudFront 不会立即更新, 需要 CloudFront Invalidation 来跳过 TTL 来立即更新</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img234007.png"></p><hr><h4 id="CloudFront-Cache-Behaviors"><a href="#CloudFront-Cache-Behaviors" class="headerlink" title="CloudFront Cache Behaviors"></a>CloudFront Cache Behaviors</h4><ul><li>根据不同的 URL 结构做不同的 Cache Behaviors</li><li>Maximize cache hits by separating staic and dynamic distributions</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img150007.png"></p><hr><h4 id="CloudFront-Geo-Restriction"><a href="#CloudFront-Geo-Restriction" class="headerlink" title="CloudFront Geo Restriction"></a>CloudFront Geo Restriction</h4><ul><li>Allowlist &amp; Blocklist (针对 IP, 国家进行访问限制)<ul><li>CloudFront Geo Restriction 没办法和 VPC 一起使用</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img233638.png"></p><hr><h4 id="CloudFront-Signed-URL-x2F-Cookies"><a href="#CloudFront-Signed-URL-x2F-Cookies" class="headerlink" title="CloudFront Signed URL &#x2F; Cookies"></a>CloudFront Signed URL &#x2F; Cookies</h4><ul><li>类似 S3 Pre-Signed URL<ul><li>Signed URL: access to individual files (单个文件)</li><li>Signed Cookies: access to multiple files (多个文件)</li></ul></li><li>Recommend to use Trusted Key Group than CloudFront Key Pair (重要)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img484256.png"></p><ul><li>CloudFront Signed URL vs. S3 Pre-Signed URL<ul><li>Access CloudFront 的就是 CloudFront Signed URL</li><li>Access S3 的就是 S3 Pre-Signed URL</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img184528.png"></p><ul><li>与 CloudFront signer 有关的 2 个知识点<ul><li>When create a signer, the public key is CloudFront and private key is used to sign a portion of URL</li><li>When use the root user to manage CloudFront key pairs, you can only have up to two active CloudFront key pairs per AWS account</li></ul></li><li>CloudFront Key Pair 只能由 root user 来创建</li></ul><hr><h4 id="CloudFront-Advanced-Concepts"><a href="#CloudFront-Advanced-Concepts" class="headerlink" title="CloudFront Advanced Concepts"></a>CloudFront Advanced Concepts</h4><ul><li>Price Classes (一共 3 种)<ul><li>Price Class All: all regions - best performance </li><li>Price Class 200: most regions, but excludes the most expensive regions</li><li>Price Class 100: only the least expensive regions</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img185111.png"></p><ul><li>CloudFront - Origin Groups<ul><li>Increase high-availability and do failover</li><li>Origin Group: one primary and one secondary origin</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img185430.png"></p><ul><li>CloudFront - Field Level Encryption<ul><li>Protect user sensitive information through application stack (重要)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img185545.png"></p><hr><h4 id="CloudFront-Real-Time-Logs"><a href="#CloudFront-Real-Time-Logs" class="headerlink" title="CloudFront Real Time Logs"></a>CloudFront Real Time Logs</h4><ul><li>Get real-time requests received by CloudFront sent to Kinesis Data Stream</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img195222.png"></p><hr><h4 id="AWS-Global-Accelerator"><a href="#AWS-Global-Accelerator" class="headerlink" title="AWS Global Accelerator"></a>AWS Global Accelerator</h4><ul><li>利用 AWS internal network to route application<ul><li>Provide 2 global static anycast IPs (重要)</li><li>Improve availability and performance of the applications (globally)</li></ul></li><li>Global Accelerator improves performance for applications over TCP or UDP</li><li>Global Accelerator has automatic failover </li><li>Global Accelerator is more expensive as it adds an extra layer of infrastructure (对比 CloudFront 不是一个 cost-effective 的选择)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img234527.png"></p><ul><li>AWS Global Accelerator vs CloudFront<ul><li>CloudFront: Content is served at edge, 比如图片和视频 (cacheable), Dynamic content such as API acceleration &amp; dynamic site delivery</li><li>Global Accelerator: 适合 TCP 或者 UDP, 比如游戏和 IoT (static IP)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img000939.png"></p><blockquote><p>AWS Global Accelerator is a network service that can provide a global traffic management solution. By creating a standard accelerator in AWS Global Accelerator, you can guide user traffic to the endpoint closest to them, thereby improving the performance and availability of the application. </p></blockquote><hr><h3 id="14-ECS-ECR-amp-Fargate"><a href="#14-ECS-ECR-amp-Fargate" class="headerlink" title="14. ECS, ECR &amp; Fargate"></a>14. ECS, ECR &amp; Fargate</h3><h4 id="AWS-ECS"><a href="#AWS-ECS" class="headerlink" title="AWS ECS"></a>AWS ECS</h4><ul><li>Elastic Container Service (Manage Docker containers on AWS)</li><li>ECS 有两种 Launch Type: EC2 和 Fargate (Fargate 是 serverless 的)</li><li>EC2 Launch Type: Need Provision, 需要 ECS Agent (重点)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img212508.png"></p><ul><li>Fargate Launch Type: Serverless, No Provision (重点)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img212546.png"></p><ul><li>IAM Roles for ECS (重要, 是 IAM)<ul><li>EC2 Instance Profile: 只针对 EC2 Launch Type, used by ECS agent</li><li>ECS Task Role: 每个 Task 都有自己的 Role (负责)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img212709.png"></p><ul><li>ECS 可以和 Load Balancer 一起用 (ALB &#x2F; NLB)</li><li>ECS 可以和 EFS 一起用 (Fargate + EFS &#x3D; Serverless, 管理文件)</li><li>如果 terminate ECS 出现 synchronization issue, 那么 ECS 当前的状态一定是 <code>STOPPED</code></li><li>如果 ECS cluster launch 出问题, 那么先检查 <code>ecs.config</code> 有没有问题</li></ul><blockquote><p>Amazon ECS with EC2 launch type is charged based on EC2 instances and EBS volumes used. Amazon ECS with Fargate launch type is charged based on vCPU and memory resources that the containerized application requests</p></blockquote><hr><h4 id="ECS-Auto-Scaling"><a href="#ECS-Auto-Scaling" class="headerlink" title="ECS Auto Scaling"></a>ECS Auto Scaling</h4><ul><li>Automatically increase &#x2F; decrease the number of ECS tasks<ul><li>Target Scaling: Scale based on target value for CloudWatch metric</li><li>Step Scaling: Scale based on CloudWatch Alarm (重要)</li><li>Scheduled Scaling: Scale based on specific time (重要)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img222247.png"></p><ul><li>Auto Scaling EC2 Instances<ul><li>Accommodate ECS Service Scaling by adding underlying EC2 Instances</li><li>Auto Scaling Group Scaling &#x2F; ECS Cluster Capacity Provider</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img205104.png"></p><hr><h4 id="ECS-Rolling-Updates"><a href="#ECS-Rolling-Updates" class="headerlink" title="ECS Rolling Updates"></a>ECS Rolling Updates</h4><ul><li>Control how many tasks can be started and stopped when update from v1 to v2</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img205259.png"></p><hr><h4 id="ECS-Task-Definitions"><a href="#ECS-Task-Definitions" class="headerlink" title="ECS Task Definitions"></a>ECS Task Definitions</h4><ul><li>Task definitions are metadata in JSON form to tell ECS how to run Docker container</li><li>Environment Variable: Hardcoded, SSM Parameter Store, Secrets Manager, S3</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img210902.png"></p><ul><li>ECS Load Balancing - EC2 Launch Type<ul><li>Get a Dynamic Host Port Mapping if define only the container port in task definiton</li><li>Must allow EC2 Instance’s Security Group any port from the ALB’s Security Group (重要)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img211103.png"></p><ul><li>ECS Load Balancing - Fargate<ul><li>Each task has a unique private IP, only define the container port</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img211211.png"></p><ul><li>ECS Data Volumes (Bind Mounts)<ul><li>Share data between multiple containers in the same Task Definition</li><li>Work for both EC2 and Fargate</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img211542.png"></p><hr><h4 id="ECS-Task-Placements"><a href="#ECS-Task-Placements" class="headerlink" title="ECS Task Placements"></a>ECS Task Placements</h4><ul><li>For EC2 Launch Type, determine where to place the EC2, CPU, Memory 等等</li><li>ECS Task Placement Strategies could mixed together (Binpack, Random 和 Spread)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img212801.png"></p><ul><li>ECS Task Placement Strategies - Binpack<ul><li>Place tasks based on the least available amount of CPU or memory</li><li>This minimize the number of instances in use (cost saving, 重要)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img213429.png"></p><ul><li>ECS Task Placement Strategies - Random<ul><li>Place the task randomly</li><li>To enable random host port, set host <code>port = 0</code> or empty, which allow multiple containers of same type to launch on the same EC2 container instance</li><li>如果问到第一个 container 运行成功, 但第二个运行失败, 那就是 host port 的问题</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img213517.png"></p><ul><li>ECS Task Placement Strategies - Spread<ul><li>Place the task evenly based on the specified value</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img213603.png"></p><ul><li>ECS Task Placement Constraints<ul><li><code>distinctInstance</code>: Place each task on a different container instance</li><li><code>memberOf</code>: Place task on instances that satisfy an expression</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img213754.png"></p><hr><h4 id="AWS-ECR"><a href="#AWS-ECR" class="headerlink" title="AWS ECR"></a>AWS ECR</h4><ul><li>Elastic Container Registry (ECR, 管理 Docker Image, 不是 Docker Container)<ul><li>Store and manage Docker images on AWS</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img222836.png"></p><ul><li>How to use CLI to pull and push image to ECR<ul><li>Login Command (aws 开头) &#x2F; Docker Commands (docker 开头)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img214106.png"></p><hr><h4 id="AWS-CoPilot"><a href="#AWS-CoPilot" class="headerlink" title="AWS CoPilot"></a>AWS CoPilot</h4><ul><li>CLI tool to build, release, and operate production-ready containerized apps<ul><li>Run your apps on AppRunner, ECS, and Fargate</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img214226.png"></p><hr><h4 id="AWS-EKS"><a href="#AWS-EKS" class="headerlink" title="AWS EKS"></a>AWS EKS</h4><ul><li>Elastic Kubernetes Service (Manage Kubernetes clusters on AWS)<ul><li>Support 2 deployment mode: EC2 &amp; Fargate (和 ECS 一样)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img223132.png"></p><ul><li>EKS Data Volumes (需要 StorageClass)<ul><li>Leverages a Container Storage Interface (CSI) compliant driver</li><li>支持 EBS, EFS, FSx</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img223503.png"></p><hr><h3 id="15-Elastic-Beanstalk"><a href="#15-Elastic-Beanstalk" class="headerlink" title="15. Elastic Beanstalk"></a>15. Elastic Beanstalk</h3><h4 id="AWS-Elastic-Beanstalk"><a href="#AWS-Elastic-Beanstalk" class="headerlink" title="AWS Elastic Beanstalk"></a>AWS Elastic Beanstalk</h4><ul><li>Elastic Beanstalk is a developer centric view of deploying an application on AWS</li><li>Automatically handles capacity provisioning, load balancing, scaling 等等</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img150326.png"></p><ul><li>Web Server Tier vs. Worker Tier (重要)<ul><li>一个管 Web Server, 另一个处理 Process (SQS, SNS 等等)</li></ul></li><li>对于 Worker 或者 Web environment 来说, 需要一个 <code>cron.yaml</code> 文件</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img210711.png"></p><ul><li>如果选择 deploy 到 Elastic Beanstalk 上, 并且省钱, 选择 Single Instance Mode</li><li>如果需要用类似 Rust 这种不支持的 runtime, 可以用 Docker image 去跑 Elastic Beanstalk</li><li>如果 deploy 失败, 那么 EB 会 replace the failed instances with instances running in the application version from the most recent successful deployment (重要)</li><li>如果要 setup HTTPS on Beanstalk, 要在 <code>.ebextensions</code> folder 弄一个 config 来管 Load Balancer</li></ul><hr><h4 id="Beanstalk-Deployment-Modes"><a href="#Beanstalk-Deployment-Modes" class="headerlink" title="Beanstalk Deployment Modes"></a>Beanstalk Deployment Modes</h4><ul><li>一共 6 种 Beanstalk Deployment Modes</li><li>这里面 Immutable 和 Traffic Splitting 可能会导致 EC2 burst balance lost (重要)</li><li>注意, Rolling 和 Rolling with additional batches 都会导致 reduce availability</li><li>All at once (直接全部更新, 但会有 downtime)<ul><li>Fastest, but have downtime</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img151200.png"></p><ul><li>Rolling (一批一批的更新)<ul><li>Update a few instances at a time (bucket), then move onto the next bucket</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img151311.png"></p><ul><li>Rolling with additional batches (类似 Rolling, 但是老版本仍然运行, 有部分额外费用)<ul><li>Like rolling, but spins up new instances to move the batch, old application still available</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img151443.png"></p><ul><li>Immutable (和 quick roll back 有关)<ul><li>Spin up new instances in a new ASG, deploys version to these instances, and then swaps all the instances when everything is healthy</li><li>如果需要 maintain at least the full capacity of the application and minimal impact of fail deployment, 选择 Immutable</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img151738.png"></p><ul><li>Blue Green (会先创造一个新的 environment)<ul><li>Create a new environment and switch over when ready</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img151838.png"></p><ul><li>Traffic Splitting (分一部分 traffic 到新环境)<ul><li>Canary testing, send a small % of traffic to new deployment</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img151935.png"></p><hr><h4 id="Beanstalk-Lifecycle-Policy"><a href="#Beanstalk-Lifecycle-Policy" class="headerlink" title="Beanstalk Lifecycle Policy"></a>Beanstalk Lifecycle Policy</h4><ul><li>Elastic Beanstalk can store at most 1000 application versions</li><li>To phase out old application versions, use a lifecycle policy (重要)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img152423.png"></p><hr><h4 id="Beanstalk-Extensions"><a href="#Beanstalk-Extensions" class="headerlink" title="Beanstalk Extensions"></a>Beanstalk Extensions</h4><ul><li>A zip file containing code must be deployed to Elastic Beanstalk<ul><li>In the <code>.ebextensions/</code> in the root directory (必须存在 <code>.ebextensions</code> 的文件夹下)</li><li><code>.config</code> extensions (必须以 <code>.config</code> 为文件后缀)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img155315.png"></p><hr><h4 id="Beanstalk-with-CloudFormation"><a href="#Beanstalk-with-CloudFormation" class="headerlink" title="Beanstalk with CloudFormation"></a>Beanstalk with CloudFormation</h4><ul><li>Under the hood, Elastic Beanstalk relies on CloudFormation</li><li>CloudFormation is used to provision other AWS services</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img161346.png"></p><hr><h4 id="Beanstalk-Cloning"><a href="#Beanstalk-Cloning" class="headerlink" title="Beanstalk Cloning"></a>Beanstalk Cloning</h4><ul><li>Clone an environment with the exact same configuration</li><li>Useful for deploying a <code>test</code> version of your application</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img161531.png"></p><hr><h3 id="16-AWS-CloudFormation"><a href="#16-AWS-CloudFormation" class="headerlink" title="16. AWS CloudFormation"></a>16. AWS CloudFormation</h3><h4 id="AWS-CloudFormation"><a href="#AWS-CloudFormation" class="headerlink" title="AWS CloudFormation"></a>AWS CloudFormation</h4><ul><li>A declarative way of outlining AWS Infrastructure (相当于有一个模板帮你生成你想要的)<ul><li>需要什么 (eg. EC2 Instance, S3), CloudFormation 给你 create 什么</li><li>CloudFormation 是 IaaS (Infrastructure as a Service)</li></ul></li><li>Can leverage existing templates on the web (可以用网上已经有的 template)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img003448.png"></p><ul><li>Templates must be uploaded in S3 and referenced in CloudFormation (重要)</li><li>To update a template, need to re-upload a new version of the template (重要)<ul><li>一般来说, 先在本地更新 CloudFormation template, 然后上传到 S3 并在 CloudFormation console 里面应用</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img193232.png"></p><ul><li>Deploying CloudFormation Templates (2 种方法)<ul><li>Manual way: Edit templates in Applcation Composer or code editor</li><li>Automated way: Edit templates in a YAML file</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img193404.png"></p><ul><li>注意, 依赖 CloudFormation 来 provision resource 的是 Elastic Beanstalk 和 SAM</li><li>CloudFormation 用来 upload Lambda 和 CloudFormation template 的是 <code>cloudformation package and cloudformation deploy</code></li><li>如果要 declare Lambda function in CloudFormation<ul><li>Write the AWS Lambda code inline in CloudFormation in the <code>AWS::Lambda::Function</code> block as long as there are no third-party dependencies</li><li>Upload all the code as a zip to S3 and refer the object in <code>AWS::Lambda::Function</code> block</li></ul></li></ul><hr><h4 id="CloudFormation-Resources"><a href="#CloudFormation-Resources" class="headerlink" title="CloudFormation Resources"></a>CloudFormation Resources</h4><ul><li>Resources represent different AWS Components that will be created and configured<ul><li>不需要定义 <code>Resource</code> 生成的 order</li><li><code>Resource</code> 是 mandatory 的 (重要)</li></ul></li><li>形式 <code>service-provider::service-name::data-type-name</code></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img194109.png"></p><hr><h4 id="CloudFormation-Parameters"><a href="#CloudFormation-Parameters" class="headerlink" title="CloudFormation Parameters"></a>CloudFormation Parameters</h4><ul><li>Parameters are a way to provide inputs to AWS CloudFormation Template<ul><li>Can reuse the templates, also don’t need to re-upload the template</li><li>Parameter type 有 <code>AWS::EC2::KeyPair::KeyName, CommaDelimitedList, String</code></li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img194424.png"></p><ul><li>Parameters Settings (记下面 2 个)<ul><li><code>AllowedValues</code>: 给用户选项, 比如选择 <code>t2.micro</code>, <code>t2.small</code>, <code>t2.medium</code></li><li><code>NoEcho</code>: 把 password 这种 secret 的东西从 log 里面移除</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img194757.png"></p><ul><li>Pseudo Parameters<ul><li>Can be used anytime and enabled by default</li><li><code>AccountId, Region, StackId, StackName, NotificationARNs, NoValue</code></li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img223040.png"></p><hr><h4 id="CloudFormation-Mappings"><a href="#CloudFormation-Mappings" class="headerlink" title="CloudFormation Mappings"></a>CloudFormation Mappings</h4><ul><li>Mappings are fixed variables within CloudFormation template<ul><li>Used to differentiate between environments (dev vs. prod), regions, AMI 等等</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img212000.png"></p><hr><h4 id="CloudFormation-Outputs-amp-Exports"><a href="#CloudFormation-Outputs-amp-Exports" class="headerlink" title="CloudFormation Outputs &amp; Exports"></a>CloudFormation Outputs &amp; Exports</h4><ul><li>Outputs declares optional ouputs values that can import into other stacks (重要)<ul><li>Outputs 可以申明资源让我们可以在其他 Stack 里面用 (前提是先 export 它们)</li><li>Exported output name 在 Region 内必须是 unique 的 (重要)</li></ul></li><li>如果我们要在第二个 template 里面去 leverage 前一个 template 的资源, 要用到 <code>Fn::ImportValue</code> (重要)</li><li>注意, <code>ImportValue</code> 是用来 reference value from other stack, <code>Export</code> 才是用来 export value to other stacks 的</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img212344.png"></p><ul><li>注意, 对于 CloudFormation 来说, All of the imports must be removed before you can delete the exporting stack or modify the output value, 所以如果遇到 Stack B, C 需要 reference Stack A, 那么 Stack A 一定是最后被删除的</li></ul><hr><h4 id="CloudFormation-Conditions"><a href="#CloudFormation-Conditions" class="headerlink" title="CloudFormation Conditions"></a>CloudFormation Conditions</h4><ul><li>Conditions are used to control the creation of resources or outputs based on a condition<ul><li>常见的有 Environment, AWS Region, Parameter value</li></ul></li><li>可以和 <code>Conditions</code> associate 有 <code>Resources, Conditions, Outputs</code></li><li>在 CloudFormation template 里面代表 invalid section 的是 <code>Dependencies</code></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img212731.png"></p><hr><h4 id="CloudFormation-Intrinsic-Functions"><a href="#CloudFormation-Intrinsic-Functions" class="headerlink" title="CloudFormation Intrinsic Functions"></a>CloudFormation Intrinsic Functions</h4><ul><li><code>Fn::Ref</code>: Reference Rarameters or Resources (只能在 Parameter 或者 Resource 里用)</li><li><code>Fn::GetAtt</code>: Get an attribute from your resource</li><li><code>Fn::FindInMap</code>: Return a named value from a specific key (注意, 就 3 参数)</li><li><code>Fn::ImportValue</code>: Import values that are exported in other stacks</li><li><code>Fn::Base64</code>: Convert String to it’s Base64 representation</li><li>Condition Functions: <code>Fn::And/Equals/If/Not/Or</code></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img214211.png"></p><hr><h4 id="CloudFormation-Rollbacks"><a href="#CloudFormation-Rollbacks" class="headerlink" title="CloudFormation Rollbacks"></a>CloudFormation Rollbacks</h4><ul><li>Stack Creation Fails 和 Stack Update Fails 都会去 rollback, 但 rollback 也可能失败</li><li>Rollback 之后如果需要重新更新 Stack, 要先删除之前的 Stack, 然后 create 新的 Stack</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img215108.png"></p><hr><h4 id="CloudFormation-Service-Role"><a href="#CloudFormation-Service-Role" class="headerlink" title="CloudFormation Service Role"></a>CloudFormation Service Role</h4><ul><li>IAM role that allow CloudFormation to <code>create/update/delete</code> stack resources<ul><li>可以用 Stack Servie Role 去给 developer permission 去管理 resources (重要)</li></ul></li><li>Achieve least privilege principle, must have <code>iam::PassRole</code> permission</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img215347.png"></p><hr><h4 id="CloudFormation-DeletionPolicy"><a href="#CloudFormation-DeletionPolicy" class="headerlink" title="CloudFormation DeletionPolicy"></a>CloudFormation DeletionPolicy</h4><ul><li>DeletionPolicy &#x3D; Delete (默认)<ul><li>Control what happens when the CloudFormation template is deleted or when a resource is removed from a CloudFormation template</li></ul></li><li>Delete won’t work on S3 if bucket is not empty</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img220014.png"></p><ul><li>DeletionPolicy &#x3D; Retain (相当于申明什么要被保存)<ul><li>Specify on resources to preserve in case of CloudFormation deletes</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img220147.png"></p><ul><li>DeletionPolicy &#x3D; Snapshot (会在删除前生成一个备份)<ul><li>Create one final snapshot before deleting the resource</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img220302.png"></p><hr><h4 id="CloudFormation-Stack-Policy"><a href="#CloudFormation-Stack-Policy" class="headerlink" title="CloudFormation Stack Policy"></a>CloudFormation Stack Policy</h4><ul><li>A Stack Policy is a JSON document that defines the update actions that are allowed on specific resources during Stack updates</li><li>Protect resources from unintentional updates (重要)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img220535.png"></p><hr><h4 id="CloudFormation-Termination-Protection"><a href="#CloudFormation-Termination-Protection" class="headerlink" title="CloudFormation Termination Protection"></a>CloudFormation Termination Protection</h4><ul><li>To prevent accidental deletes of CloudFormation Stacks, use <code>TerminationProtection</code></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img220655.png"></p><hr><h4 id="CloudFormation-Custom-Resources"><a href="#CloudFormation-Custom-Resources" class="headerlink" title="CloudFormation Custom Resources"></a>CloudFormation Custom Resources</h4><ul><li>Used to define resources that are not supported or outside CloudFormation</li><li>Defined in template with <code>Custom::MyCustomResourceTypeName</code></li><li>可以处理之前提到的 S3 bucket 无法删除的问题</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img221103.png"></p><hr><h4 id="CloudFormation-StackSets"><a href="#CloudFormation-StackSets" class="headerlink" title="CloudFormation StackSets"></a>CloudFormation StackSets</h4><ul><li>Create, update, delete stacks across multiple accounts and regions<ul><li>注意, StackSets 是给多个账户, 或者多个 Region 去创造 CloudFormation stack</li><li>只有 Administrator 才可以创建 StackSets</li></ul></li><li>When update a stack set, all associated stack instance will be updated (重要)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img221509.png"></p><hr><h3 id="17-SQS-SNS-Kinesis"><a href="#17-SQS-SNS-Kinesis" class="headerlink" title="17. SQS, SNS, Kinesis"></a>17. SQS, SNS, Kinesis</h3><h4 id="AWS-SQS"><a href="#AWS-SQS" class="headerlink" title="AWS SQS"></a>AWS SQS</h4><ul><li>用来 decouple applications (比如处理视频, 属于多对多模型)</li><li>SQS scale automatically (unlimited throughput, unlimited message, can retry)</li><li>SQS 最多只能保存 message 14 天, SQS 一个 message 最大只有 256 KB</li><li>Standard SQS 允许将 S3 作为 event notification destination, SQS FIFO 则不行</li><li>处理 parallel 选 SQS 而不是 SNS</li><li>处理 decouple microservice (但是没有 3rd party 的) 就是 SQS</li><li>处理 high-throughput request-reponse message pattern 的, 选择 Temporary Queue</li><li>遇到要处理 workflows that take a long time to complete, 选择 Dedicated worker environment</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img231916.png"></p><ul><li>SQS - Producing Messages<ul><li>Message is persisted in SQS until a consumer delete it (重要)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img232217.png"></p><ul><li>SQS - Consuming Messages<ul><li>可以有很多 consumer 来同时 parallel 处理 messages (重要)</li><li>Consumer delete messages after processing them (处理完就删掉)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img232414.png"></p><ul><li>当遇到 SQS 而且需要 priority 的时候, Create two Amazon SQS standard queues, Set up Amazon EC2 instances to prioritize polling</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/imgpt6-q32-i1.jpg"></p><ul><li>关于 SQS <code>CreateQueue</code> API 的 2 个知识点</li><li>The visibility timeout value of the queue is in seconds, default is 30 seconds</li><li>You can’t change the queue type after create it</li><li>如果遇到 <code>ApproximateNumberOfMessagesVisible</code> 这个问题, 可以用 backlog per instance metric with target tracking scaling policy 来解决</li></ul><hr><h4 id="SQS-Message-Visibility-Timeout"><a href="#SQS-Message-Visibility-Timeout" class="headerlink" title="SQS Message Visibility Timeout"></a>SQS Message Visibility Timeout</h4><ul><li>Visibility Timeout is high: Consumer crash, re-process take time</li><li>Visibility Timeout is low: Get duplicate (防止 read duplicate, 增加 timeout, 重要)</li><li>Use the <code>ChangeMessageVisibility</code> API call to increase the visibility timeout</li><li>题目大部分针对的都是 Visibility Timeout low 的情况</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img020440.png"></p><hr><h4 id="SQS-Dead-Letter-Queues-DLQ"><a href="#SQS-Dead-Letter-Queues-DLQ" class="headerlink" title="SQS Dead Letter Queues (DLQ)"></a>SQS Dead Letter Queues (DLQ)</h4><ul><li>Fail to process message within Visibility Timeout, message goes back to queue<ul><li>问题在于这个 message 可能本身就是无法处理的</li><li>遇到 SQS message process failure, 选择 DLQ 来解决 (重要)</li></ul></li><li>Set a threshold of how many times a message can go back to queue<ul><li>After <code>MaximumReceives</code> threshold exceeded, message goes to DLQ</li><li>DLQ 很适合用来做 Debug</li></ul></li><li>DLQ of a FIFO queue must also be a FIFO queue, same with Standard (形式得相同)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img164418.png"></p><ul><li>DLQ - Redrive to Source (相当于从 DLQ 修复完返回原来的 Queue)<ul><li>Feature to help consume messages in DLQ to understand what is wrong</li><li>When the code is fixed, we can redrive the message from DLQ to source queue</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img164607.png"></p><hr><h4 id="SQS-Delay-Queues"><a href="#SQS-Delay-Queues" class="headerlink" title="SQS Delay Queues"></a>SQS Delay Queues</h4><ul><li>Delay a message up to 15 minutes (使用 <code>DelaySeconds</code> 参数)</li><li>遇到需要 SQS 去 postpone the delivery of new messages, 那么就是 Delay Queue</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img164931.png"></p><hr><h4 id="SQS-Long-Polling"><a href="#SQS-Long-Polling" class="headerlink" title="SQS Long Polling"></a>SQS Long Polling</h4><ul><li>Decrease latency &amp; decrease API call (减少 API 请求, 更好的 performance, 重要)<ul><li>Minimize the cost of using SQS (省钱)</li><li>Long Polling 不能处理 SQS duplicate, 还是要用 Visibility Timeout</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img003255.png"></p><hr><h4 id="SQS-Extended-Client"><a href="#SQS-Extended-Client" class="headerlink" title="SQS Extended Client"></a>SQS Extended Client</h4><ul><li>Handle send message greater than 256 KB (重要)<ul><li>这证明 SQS 的 message 也是有 size 的限制</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img165310.png"></p><hr><h4 id="SQS-FIFO-Queues"><a href="#SQS-FIFO-Queues" class="headerlink" title="SQS FIFO Queues"></a>SQS FIFO Queues</h4><ul><li>按 order 传递 message (SNS 也可以做到)<ul><li>By default, FIFO queues support up to 300 messages per second (重要)</li></ul></li><li>如果没有 GroupID, 那只能有 1 个 consumer, 如果有 GroupID, 可以有多个 consumer (重要)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img003507.png"></p><ul><li>把 SQS 转成 FIFO queue<ul><li>Delete the existing SQS and recreate it as FIFO queue</li><li>Make sure the name of the FIFO queue ends with .fifo suffix</li><li>Make sure the throughput for the FIFO queue not exceed 3000 meesage &#x2F; second</li></ul></li></ul><hr><h4 id="SQS-FIFO-Queues-Advanced"><a href="#SQS-FIFO-Queues-Advanced" class="headerlink" title="SQS FIFO Queues Advanced"></a>SQS FIFO Queues Advanced</h4><ul><li>De-duplication: (使用 <code>MessageDeduplicationID</code>)<ul><li>Send 2 same message within 5 minutes interval, the second will be refused</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img170023.png"></p><ul><li>Message Grouping (使用 <code>MessageGroupID</code>)<ul><li>Same <code>MessageGroupID</code> in the entire FIFO queue, then only have 1 consumer</li><li>Different MessageGroupID for a subset of message, have different consumers</li><li>对于 FIFO queues 来说, <code>MessageGroupID</code> 可以保证 same message group 是有 order 的</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img170254.png"></p><hr><h4 id="AWS-SNS"><a href="#AWS-SNS" class="headerlink" title="AWS SNS"></a>AWS SNS</h4><ul><li>Send one message to many receivers (可以给用户发 email)<ul><li>Publisher &amp; Subscriber 模型 (属于一对多模型)</li><li>Subscriber: SQS, Lambda, Kinesis Data Firehose, HTTPS endpoints, Email</li></ul></li><li>SNS Message Filtering: Could filter message based on topic (重要)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img010634.png"></p><hr><h4 id="Fan-Out-Pattern"><a href="#Fan-Out-Pattern" class="headerlink" title="Fan Out Pattern"></a>Fan Out Pattern</h4><ul><li>Push once in SNS, receive in all SQS (由 SNS 传递 message 给 SQS 来接收, 重要)<ul><li>Fully decoupled, no data loss (重要, 因为它 decouple)</li><li>可以用于 message filtering (信息过滤, 根据不同的 filter policy)</li></ul></li><li>Kinesis 也可以使用 Fan Out Pattern (使用 Shard)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img011026.png"></p><hr><h4 id="AWS-Kinesis"><a href="#AWS-Kinesis" class="headerlink" title="AWS Kinesis"></a>AWS Kinesis</h4><ul><li>Process, ingest, buffer streaming data in real-time (处理实时数据)</li><li>Kinesis Data Streams: Capture, process, store data streams</li><li>Kinesis Data Firehose: Load data streams into AWS data stores (S3, Redshift)</li><li>Kinesis Data Analytics: Analyze data streams with SQL or Apache Flink</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img150053.png"></p><blockquote><p>Kinesis Agent cannot write to Amazon Kinesis Firehose for which the delivery stream source is already set as Amazon Kinesis Data Streams</p></blockquote><ul><li>Kinesis Agent is a stand-alone Java software application that offers an easy way to collect and send data to Kinesis Data Streams</li></ul><hr><h4 id="Kinesis-Data-Streams"><a href="#Kinesis-Data-Streams" class="headerlink" title="Kinesis Data Streams"></a>Kinesis Data Streams</h4><ul><li>Have the ability to reprocess &amp; replay stream data (处理数据, 重要)<ul><li>处理 real-time data stream, 比如 clickstreams, transactions, media (金融数据)</li><li>Consumer 有 Lambda, Kinesis Firehose, Kinesis Data Analytics</li><li>Kinesis Data Streams 有助于每秒从多个来源连续收集数 GB 的数据</li><li>Kinesis Data Streams 最多保存数据 1 年</li></ul></li><li>Once data is inserted in Kinesis, it can’t be deleted (没法删除)</li><li>如果问到 Kinesis Data Stream 加上 SQL, 那么答案里一定有 Kinesis Data Analytics</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img014850.png"></p><ul><li>Data share the same partition goes the same shard (有顺序的)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img151123.png"></p><ul><li>Capacity Mode (一共 2 种)<ul><li>Provisioned mode: Choose a number of shards provisioned (设置上限)</li><li>On-demand mode: No need to provision or manage capacity (自动 scale)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img151507.png"></p><hr><h4 id="Kinesis-Producers"><a href="#Kinesis-Producers" class="headerlink" title="Kinesis Producers"></a>Kinesis Producers</h4><ul><li>Put data records into data streams</li><li>Producers: AWS SDK, Kinesis Producer Library (KPL), Kinesis Agent</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img172002.png"></p><ul><li>Use Hash function to determine which message should go to which Shard</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img172126.png"></p><ul><li>如果遇到 <code>ProvisionedThroughputExceededException</code> 问题<ul><li>Over producing to a shard, get <code>ProvisionedThroughputExceededException</code></li><li>解决方案 1: Use highly distributed partition key </li><li>解决方案 2: Use error retry and exponential backoff mechanism</li><li>解决方案 3: Increase shards</li><li>解决方案 4: Decrease the frequency or size of the requests</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img172335.png"></p><hr><h4 id="Kinesis-Consumers"><a href="#Kinesis-Consumers" class="headerlink" title="Kinesis Consumers"></a>Kinesis Consumers</h4><ul><li>Get data records from data streams and process them</li><li>Consumers: Lambda, Kinesis Data Analytics, Kinesis Data Firehose, KCL 等等</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img190504.png"></p><ul><li>Kinesis Consumers - Custom Consumer (重要)<ul><li>Shared Fan-out Consumer: pull, low number of consuming applications, 省钱</li><li>Enhanced Fan-out Consumer: push, multiple consuming application, 贵</li><li>Enhanced Fan-out Consumer 可以 increase read throughput (重要)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img202712.png"></p><ul><li>Kinesis Consumers - AWS Lambda (重要)<ul><li>Supports Classic &amp; Enhanced fan-out consumers</li><li>Read records in batches, can configure batch size and window</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img203145.png"></p><hr><h4 id="Kinesis-Client-Library-KCL"><a href="#Kinesis-Client-Library-KCL" class="headerlink" title="Kinesis Client Library (KCL)"></a>Kinesis Client Library (KCL)</h4><ul><li>A Java library that helps read record from a Kinesis Data Stream</li><li>When using Kinesis Client Library, each shard is to be read-only by one KCL instance</li><li>Progress is checkpointed into DynamoDB (need IAM access)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img205645.png"></p><hr><h4 id="Kinesis-Operations"><a href="#Kinesis-Operations" class="headerlink" title="Kinesis Operations"></a>Kinesis Operations</h4><ul><li>Shard Splitting: Deal with <code>hot shard</code><ul><li>Used to increase the Stream capacity, divide a <code>hot shard</code></li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img205913.png"></p><ul><li>Merging Shards: Group two shards with low traffic<ul><li>Decrease the Stream capacity and save costs</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img210015.png"></p><hr><h4 id="Kinesis-Data-Firehose"><a href="#Kinesis-Data-Firehose" class="headerlink" title="Kinesis Data Firehose"></a>Kinesis Data Firehose</h4><ul><li>Kinesis Data Firehose load streaming data into data stores and analytics tools<ul><li>Managed service, auto scaling, serverless, support data transformation</li><li>Kinesis Data Firehose 提供将数据流传进数据存储或者数据分析的功能</li></ul></li><li>Near Real Time, 而且 Firehose 只支持一个 consumer (dump data in a single data repo)<ul><li>但是不要被 Near Real Time 忽悠, 要根据题目选择 Data Stream 或者 Data Firehose</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img015040.png"></p><ul><li>Firehose 的对象是 S3, Redshift 这种 (Serverless, 专门处理 log 数据)<ul><li>Firehose 不支持 DynamoDB 的</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img151812.png"></p><ul><li>Kinesis Data Streams vs Firehose<ul><li>Data Streams: Write custom code, real-time, have data storage, have replay</li><li>Firehose: Fully managed, near real-time, no data storage, no replay</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img152247.png"></p><hr><h4 id="Kinesis-Data-Analytics"><a href="#Kinesis-Data-Analytics" class="headerlink" title="Kinesis Data Analytics"></a>Kinesis Data Analytics</h4><ul><li>Real-time analytics on Kinesis Data Streams &amp; Firehose using SQL (重要)<ul><li>Fully managed, auto-scaling, serverless</li><li>以 Kinesis Data Streams &amp; Firehose 作为目标使用 SQL 进行数据分析</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img225813.png"></p><ul><li>Amazon Managed Service for Apache Flink<ul><li>Use Flink to process and analyze streaming data</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img225906.png"></p><hr><h4 id="Data-ordering-for-Kinesis"><a href="#Data-ordering-for-Kinesis" class="headerlink" title="Data ordering for Kinesis"></a>Data ordering for Kinesis</h4><ul><li>Ordering data into Kinesis<ul><li>Same key (Partition) will always go to the same shard (有顺序)</li><li>适用于需要处理大量 data 的情况</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img154939.png"></p><ul><li>Ordering data into SQS<ul><li>相比之下 SQS 只有 FIFO (GroupID), 不然就没有 ordering</li><li>适用于需要 dynamic number of consumers 的情况</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img210807.png"></p><hr><h3 id="18-AWS-Mointoring-amp-Audit"><a href="#18-AWS-Mointoring-amp-Audit" class="headerlink" title="18. AWS Mointoring &amp; Audit"></a>18. AWS Mointoring &amp; Audit</h3><h4 id="CloudWatch-Metrics"><a href="#CloudWatch-Metrics" class="headerlink" title="CloudWatch Metrics"></a>CloudWatch Metrics</h4><ul><li>CloudWatch Metrics 用于收集、存储和分析 AWS 资源和应用程序的性能指标</li><li>可以用 <code>PutMetricData</code> 来 push custom metric data 到 CloudWatch 里</li><li>记住, 如果是处理第三方的 API, 用的一定是 CloudWatch custom metrics (重要)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img010357.png"></p><ul><li>CloudWatch - EC2 Detailed Monitoring (重要)<ul><li>With detailed monitoring, you get data every 1 minute</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img033959.png"></p><hr><h4 id="CloudWatch-Custom-Metrics"><a href="#CloudWatch-Custom-Metrics" class="headerlink" title="CloudWatch Custom Metrics"></a>CloudWatch Custom Metrics</h4><ul><li>Define your own custom metrics to CloudWatch</li><li>High-Resolution Custom Metrics can have a minimum resolution of 1 second (重要)</li><li>Accepts metric data points two weeks in the past and two hours in the future</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img010630.png"></p><hr><h4 id="CloudWatch-Logs"><a href="#CloudWatch-Logs" class="headerlink" title="CloudWatch Logs"></a>CloudWatch Logs</h4><ul><li>A place to store application logs in AWS (S3, Kinesis, Lambda, OpenSearch)<ul><li>CloudWatch Logs 可以自己定义 expire 的时间, 默认是 never expire</li><li>Log Retention Policy defined at Log Groups level (重要)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img010815.png"></p><ul><li>CloudWatch Logs Insights (query engine)<ul><li>Search and analyze log data stored in CloudWatch Logs (查询)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img150531.png"></p><ul><li>CloudWatch Logs Subscriptions<ul><li>Get a real-time log events from CloudWatch Logs for processing and analysis</li><li>Subscription Filter: Filter which logs are events delivered to destination (重要)</li><li>Cross-Account Subscription: Send log events to resources in different AWS account</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img150643.png"></p><hr><h4 id="CloudWatch-Agent"><a href="#CloudWatch-Agent" class="headerlink" title="CloudWatch Agent"></a>CloudWatch Agent</h4><ul><li>CloudWatch Logs Agent: Old version, only send to CloudWatch Logs</li><li>CloudWatch Unified Agent: 可以传递更多信息, 比如 CPU, RAM 等等<ul><li>CloudWatch Unified Agent 可以把 EC2 的 log 传递给 CloudWatch (重要)</li></ul></li><li>可以把 CloudWatch Agent 装在 on-premise 上来收集信息</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img151251.png"></p><hr><h4 id="CloudWatch-Logs-Metric-Filter"><a href="#CloudWatch-Logs-Metric-Filter" class="headerlink" title="CloudWatch Logs Metric Filter"></a>CloudWatch Logs Metric Filter</h4><ul><li>CloudWatch Logs Metric Filter 用于从日志数据中提取指标，以监控特定事件和模式</li><li>Filters only publish the metric data points for events that happen after the filter was created (只有 filter 生成后的 event 才会被 filter)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img011918.png"></p><hr><h4 id="CloudWatch-Alarms"><a href="#CloudWatch-Alarms" class="headerlink" title="CloudWatch Alarms"></a>CloudWatch Alarms</h4><ul><li>CloudWatch Alarms are used to trigger notifications for any metric </li><li>CloudWatch Alarms 主要对象是 EC2, ASG, SNS (重要)</li><li>High resolution custom metrics 的情况下 triggered 最快是 10 秒 (重要)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img012137.png"></p><ul><li>Composite Alarms (监视当前所有 Alarm 的情况)<ul><li>Composite Alarams are mointoring the states of multiple other alarms</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img151615.png"></p><ul><li>可以用 <code>set-alarm-state</code> CLI 来控制 CloudWatch Alarms, 这样是 cost-effective 的</li></ul><hr><h4 id="CloudWatch-Syntheics"><a href="#CloudWatch-Syntheics" class="headerlink" title="CloudWatch Syntheics"></a>CloudWatch Syntheics</h4><ul><li>Configurable script that monitor your APIs, URLs, Websites<ul><li>Can run once or on a regular schedule</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img012521.png"></p><hr><h4 id="AWS-EventBridge"><a href="#AWS-EventBridge" class="headerlink" title="AWS EventBridge"></a>AWS EventBridge</h4><ul><li>Schedule CRON jobs <code>CRON means jobs on a repeating schedule</code></li><li>React to events from SaaS application (AWS services)<ul><li>如果提到 3rd party application, 考虑 EventBridge</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img185605.png"></p><ul><li>Event Bus<ul><li>可以 archive rvents 并且 replay archived events, good for debugging</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img190403.png"></p><ul><li>Schema Registry: Generate code in advance for how data is structured in event bus<ul><li>Analyze events in Event Bus and infer schema</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img190004.png"></p><ul><li>Resource-based Policy<ul><li>Manage permissions (allow &#x2F; deny) for a specific Event Bus</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img190215.png"></p><hr><h4 id="AWS-X-Ray"><a href="#AWS-X-Ray" class="headerlink" title="AWS X-Ray"></a>AWS X-Ray</h4><ul><li>Automated Trace Analysis &amp; Central Service Map Visulization<ul><li>AWS X-Ray 是一个分布式跟踪系统，用于分析和调试生产和分布式应用程序的性能问题</li><li>X-Ray 可以 cross-account tracing and visualization (重要, tracing 和 visualization)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img020641.png"></p><ul><li>How to enable X-Ray (两种方法)<ul><li>Import the AWS X-Ray SDK in your code</li><li>Install the X-Ray daemon or enable X-Ray AWS Integration</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img021009.png"></p><ul><li>X-Ray Troubleshooting (EC2 要在 Instance 上跑 X-Ray Daemon)<ul><li>EC2: IAM Role has proper permission 和 Instace running X-Ray Daemon (重要)</li><li>Lambda: IAM Role <code>RayWriteOnlyAccess</code> 和 Enable Lambda X-Ray Active Tracing</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img021323.png"></p><ul><li>如果要在 Farget deployed 的 Docker 上跑 X-Ray daemon<ul><li>Deploy the X-Ray daemon agent as a sidecar container</li><li>Provide the correct IAM task role to the X-Ray container</li></ul></li><li>如果要验证 X-Ray daemon 在 ECS 上跑, 用 <code>AWS_XRAY_DAEMON_ADDRESS</code></li></ul><hr><h4 id="X-Ray-Advance"><a href="#X-Ray-Advance" class="headerlink" title="X-Ray Advance"></a>X-Ray Advance</h4><ul><li>Instrumentation: Measure of product’s performance and write trace information<ul><li>检测应用程序涉及发送传入和传出请求以及应用程序内其他事件的跟踪数据</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img021538.png"></p><ul><li>X-Ray Concepts (记下面 2 个)<ul><li><code>Sampling</code>: Decrease the amount of requests sent to X-Ray, reduce cost (省钱)</li><li><code>Annotations</code>: Index traces and use with filters (重要, 有 filter)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img021924.png"></p><ul><li>X-Ray Sampling Rules (可以控制 record data 的数量, 重要)<ul><li>With sampling rules, you control the amount of data that you record</li><li>X-Ray records first request each second, and five percent for additional requests</li><li>上面重要的点: first request <code>each second</code>, addition requests <code>5 percent</code></li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img022256.png"></p><hr><h4 id="X-Ray-APIs"><a href="#X-Ray-APIs" class="headerlink" title="X-Ray APIs"></a>X-Ray APIs</h4><ul><li>X-Ray Write APIs<ul><li><code>PutTraceSegments</code>: Upload segment documents to AWS X-Ray</li><li><code>PutTelemetryRecords</code>: Used by AWS X-Ray daemon to upload telemetry</li><li><code>GetSamplingRules</code>: Retrieve all sampling rules</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img022650.png"></p><ul><li>X-Ray Read APIs: 全都都带有 <code>Get</code><ul><li><code>GetServiceGraph</code>: Main graph</li><li><code>BatchGetTrace</code>: Retrieve a list of traces specified by ID</li><li><code>GetTraceSummaries</code>: Retrieve IDs and annotations for trace in a time frame</li><li><code>GetTraceGraph</code>: Retrieve a service graph for one or more trace IDs</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img022934.png"></p><hr><h4 id="X-Ray-with-Beanstalk"><a href="#X-Ray-with-Beanstalk" class="headerlink" title="X-Ray with Beanstalk"></a>X-Ray with Beanstalk</h4><ul><li>可以在 Elastic Beanstalk 使用 X-Ray daemon (用 console 或者 config file)<ul><li>需要 <code>.ebextensions/xray-daemon.config</code> 文件</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img023148.png"></p><hr><h4 id="AWS-Distro-for-OpenTelemetry"><a href="#AWS-Distro-for-OpenTelemetry" class="headerlink" title="AWS Distro for OpenTelemetry"></a>AWS Distro for OpenTelemetry</h4><ul><li>AWS supported distribution of open-source project OpenTelemetry</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img023636.png"></p><hr><h4 id="AWS-CloudTrail"><a href="#AWS-CloudTrail" class="headerlink" title="AWS CloudTrail"></a>AWS CloudTrail</h4><ul><li>AWS CloudTrail 是一项日志记录服务，记录和监控 AWS 账户中的 API 调用和相关活动</li><li>CloudTrail 是 Global Service, 如果东西被误删, 第一时间看 CloudTrail</li><li>CloudTrail 可以和 EventBridge 一起用去 Intercept API Calls</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img023929.png"></p><ul><li>CloudTrail Events (一共 3 种)<ul><li>Management Events: Performed on resources in AWS account</li><li>Data Events: S3 object-level activity</li><li>CloudTrail Insigths Events: Detect unusual activity (安全)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img023847.png"></p><ul><li>CloudTrail Insights (重要, 监控 unusual activity)<ul><li>CloudTrail Insights to detect unusual activity in account</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img192157.png"></p><ul><li>CloudTrail Event Retention (重要, 和 S3, Athena 有关)<ul><li>Keep events to S3 after they stored 90 days and use Athena to analyze</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img163847.png"></p><hr><h3 id="19-Lambda"><a href="#19-Lambda" class="headerlink" title="19. Lambda"></a>19. Lambda</h3><h4 id="AWS-Lambda"><a href="#AWS-Lambda" class="headerlink" title="AWS Lambda"></a>AWS Lambda</h4><ul><li>Virtual functions, serverless, limited by time (short execution of 15 min)<ul><li>Run on-demand, scaling is automated</li></ul></li><li>Could be Event-Driven, could handle CRON job<ul><li>Use EventBridge to trigger Lambda every hour</li></ul></li><li>Lambda 是有 account quota (配额限制) 的, 需要联系 AWS 来提高上限</li><li>Lambda environment variable 最大限制是 4KB, 没有数量的限制</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img162057.png"></p><ul><li>可以用 Lambda 去 connect private subnets in a VPC in your account (重要)</li><li>大部分题目都是通过增加 memory 来 improve CPU-bound Lambda function peformance (重要)</li><li>API caching 是用来 reduce calls 的, 要 faster initialization 选择 provisioned concurrency</li></ul><hr><h4 id="Lambda-Synchronous-Invocations"><a href="#Lambda-Synchronous-Invocations" class="headerlink" title="Lambda Synchronous Invocations"></a>Lambda Synchronous Invocations</h4><ul><li>Synchronous: CLI, SDK, API Gateway, Application Load Balancer <ul><li>Results is returned right away</li><li>Error handling must happen client side</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img164039.png"></p><hr><h4 id="Lambda-with-ALB"><a href="#Lambda-with-ALB" class="headerlink" title="Lambda with ALB"></a>Lambda with ALB</h4><ul><li>Expose a Lambda function as an HTTPs endpoint, use ALB or API Gateway<ul><li>The Lambda function must be registered in a Target Group (重要)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img163555.png"></p><ul><li>ALB Multi-Header Values<ul><li>HTTP headers and query string parameters are shown as arrays</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img163757.png"></p><hr><h4 id="Lambda-Asynchronous-Invocations"><a href="#Lambda-Asynchronous-Invocations" class="headerlink" title="Lambda Asynchronous Invocations"></a>Lambda Asynchronous Invocations</h4><ul><li>Asynchronous: S3, SNS, CloudWatch, EventBridge<ul><li>The events are placed in a Event Queue</li><li>Lambda attemps to retry on errors (3 tries total)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img164249.png"></p><hr><h4 id="Lambda-Event-Source-Mapping"><a href="#Lambda-Event-Source-Mapping" class="headerlink" title="Lambda Event Source Mapping"></a>Lambda Event Source Mapping</h4><ul><li>Work with Kinesis Data Streams, SQS (FIFO), DynamoDB Streams (重要)<ul><li>Lambda function is invoked synchronously, 所以 SNS 就不能用 Event Source Mapping</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img165403.png"></p><ul><li>Streasm &amp; Lambda (Kinesis &amp; DynamoDB)<ul><li>An event source mapping creates an iterator for each shard, process items in order</li><li>Low traffic: Use batch window </li><li>High traffic: Multiple batches in parallel</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img165631.png"></p><ul><li>Streasm &amp; Lambda Error Handling<ul><li>By default, if function returns an error, the entire batch is reprocessed until the function succeeds, or the items in the batch expire</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img165758.png"></p><ul><li>Queue &amp; Lambda (SQS &amp; FIFO)<ul><li>Event Source Mapping will poll SQS (Long Polling)</li><li>If use FIFO queues, Lambda will scale up to the number of active message groups</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img165931.png"></p><hr><h4 id="Lambda-Event-and-Context-Objects"><a href="#Lambda-Event-and-Context-Objects" class="headerlink" title="Lambda Event and Context Objects"></a>Lambda Event and Context Objects</h4><ul><li>简单来说就是 lambda_hander 里面的参数 event 和 context</li><li><code>event</code>: JSON document contains data for the function to process</li><li><code>context</code>: Provides information about the invocation, function, runtime environment</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img170535.png"></p><hr><h4 id="Lambda-Destinations"><a href="#Lambda-Destinations" class="headerlink" title="Lambda Destinations"></a>Lambda Destinations</h4><ul><li>Can configure to send result to a destination (重要)<ul><li>Asynchronous invocations: Define destinations for successful and failed event</li><li>Event Source Mapping: For discarded event batches</li></ul></li><li>注意, Lambda Destionation 可以是 DLQ, 这样可以直接用 SQS (重要)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img170912.png"></p><hr><h4 id="Lambda-Permissions"><a href="#Lambda-Permissions" class="headerlink" title="Lambda Permissions"></a>Lambda Permissions</h4><ul><li>Lambda Execution Role (重要, 大部分 Lambda 的问题都和 Execution Role 有关)<ul><li>Grant Lambda function permissions to AWS services (IAM Role)</li><li>Best practice: Create one Lambda Execution Role per function</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img171158.png"></p><ul><li>Lambda Resource Based Policies<ul><li>Use resource-based policies to give other accounts and AWS services permission to use your Lambda resources (感觉 Resource Base Policy 都是给跨账号权限的)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img171329.png"></p><hr><h4 id="Lambda-Environment-Variables"><a href="#Lambda-Environment-Variables" class="headerlink" title="Lambda Environment Variables"></a>Lambda Environment Variables</h4><ul><li>存 secrets 和 api keys 的</li><li>可以用来 inject dynamic variables into Lambda function (重要)</li><li>注意, 像 token 这种就不能放在 Environment Variable, 要在 deployment package <code>.zip</code> 里</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img173203.png"></p><hr><h4 id="Lambda-Logging-amp-Monitoring"><a href="#Lambda-Logging-amp-Monitoring" class="headerlink" title="Lambda Logging &amp; Monitoring"></a>Lambda Logging &amp; Monitoring</h4><ul><li>Lambda execution logs are stored in AWS CloudWatch Logs</li><li>Lambda metrices are displayed in AWS CloudWatch Metrices</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img173409.png"></p><ul><li>Lambda Tracing with X-Ray<ul><li>Enable in Lambda configuration (Active Tracing)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img173520.png"></p><hr><h4 id="CloudFront-Functions-amp-Lambda-Edge"><a href="#CloudFront-Functions-amp-Lambda-Edge" class="headerlink" title="CloudFront Functions &amp; Lambda@Edge"></a>CloudFront Functions &amp; Lambda@Edge</h4><ul><li>Execute logic at the edge (Edge Function, serverless)</li><li>两种方法: CloudFront Functions, Lambda@Edge (它们支持的语言不同)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img173715.png"></p><ul><li>CloudFront Functions<ul><li>For high-scale, latency-sensitive CDN customizations (millions 级别的)</li><li>Used to change Viewer requestes and responses, short execution time</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img173900.png"></p><ul><li>Lambda@Edge<ul><li>Scales to 1000s of requests&#x2F;second (thousands 级别的)</li><li>Used to change Viewer requestes and responses, longer execution time</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img214545.png"></p><hr><h4 id="Lambda-in-VPC"><a href="#Lambda-in-VPC" class="headerlink" title="Lambda in VPC"></a>Lambda in VPC</h4><ul><li>正常情况下, Lambda 无法访问 VPC (所以要 Lambda in VPC)</li><li>需要 VPC ID, Subnet 和 Security Groups, Lambda will create an ENI</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img174359.png"></p><ul><li>Lambda in VPC - Internet Access (2 种方法)<ul><li>Lambda function in your VPC does not have internet access</li><li>Deploying a Lambda function in public subnet does not give internet access</li></ul></li><li>Need to deploy Lambda function in private subnet and give a NAT Gateway &#x2F; Instance</li><li>Also can use VPC endpoints to privately access AWS services without NAT</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img174704.png"></p><hr><h4 id="Lambda-Function-Performance"><a href="#Lambda-Function-Performance" class="headerlink" title="Lambda Function Performance"></a>Lambda Function Performance</h4><ul><li>Lambda Function Configuration<ul><li>RAM: If application is CPU-bound (computation heavy), increase RAM</li><li>Timeout: Default 3 seconds, maximum is 900 seconds (15 minutes)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img174946.png"></p><ul><li>Lambda Execution Context<ul><li>The execution context is a temporary runtime environment that initializes any external dependencies of your lambda code</li><li>The execution context includes the <code>/tmp</code> directory (重要)</li><li><code>/tmp</code> directory 的最大容量是 <code>10240</code> MB, default 是 <code>512</code> MB</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img175158.png"></p><ul><li>Initialize outside the handler (重要)<ul><li>防止 DB connection 被多次建立</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img175513.png"></p><hr><h4 id="Lambda-Layers"><a href="#Lambda-Layers" class="headerlink" title="Lambda Layers"></a>Lambda Layers</h4><ul><li>Create Custom Runtime &amp; Externalize Dependencies to re-use them</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img192245.png"></p><hr><h4 id="Lambda-File-Systems-Mounting"><a href="#Lambda-File-Systems-Mounting" class="headerlink" title="Lambda File Systems Mounting"></a>Lambda File Systems Mounting</h4><ul><li>Lambda functions can access EFS file systems if they are running in a VPC<ul><li>Leaverage EFS Access Points</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img192513.png"></p><hr><h4 id="Lambda-Concurrency"><a href="#Lambda-Concurrency" class="headerlink" title="Lambda Concurrency"></a>Lambda Concurrency</h4><ul><li>Can set a <code>reserved concurrency</code> to limit the number of concurrent execution</li><li>Each invocation over the concurrency limit will trigger a <code>Throttle</code><ul><li>If need a higher limit, open a support ticket</li></ul></li><li>对于处理 Asynchronous 的情况, Lambda 会把 event 返回到 queue 里</li><li>可以 configure Auto Scaling to manage Lambda provisioned concurrency on a schedule<ul><li>比如要应对圣诞节这种情况</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img193032.png"></p><ul><li>Cold Starts &amp; Provisioned Concurrency<ul><li>Cold Start: First request served by new instances has higher latency than rest</li><li>Provisioned Concurrency: Allocate concurrency before the function is invoked</li><li>Provisioned Concurrency 解决了 Cold Start 的问题 (重要)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img224130.png"></p><hr><h4 id="Lambda-External-Dependencies"><a href="#Lambda-External-Dependencies" class="headerlink" title="Lambda External Dependencies"></a>Lambda External Dependencies</h4><ul><li>If Lambda function depends on external libraries<ul><li>You need to install the packages alongside your code and zip together</li></ul></li><li>注意, 这里是把 functions 和 dependencies zip 在一起, 而不是分开 zip (重要)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img224459.png"></p><hr><h4 id="Lambda-Container-Image"><a href="#Lambda-Container-Image" class="headerlink" title="Lambda Container Image"></a>Lambda Container Image</h4><ul><li>Deploy Lambda function as container images (也就是说 Lambda 和 Docker 是可以一起用的)</li><li>Pack complex dependencies, large dependencies in a container</li><li>To deploy a container image to Lambda, the container image must implement Lambda Runtime API</li><li>AWS Lambda service does not support Lambda functions that use multi-architecture container image</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img000324.png"></p><hr><h4 id="Lambda-Versions-and-Aliases"><a href="#Lambda-Versions-and-Aliases" class="headerlink" title="Lambda Versions and Aliases"></a>Lambda Versions and Aliases</h4><ul><li>Lambda Versions (重要)<ul><li>When work on a Lambda function, work on $LATEST</li><li>When publish a Lambda function, create a version</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img000644.png"></p><ul><li>Lambda Aliases (重要)<ul><li>Aliases are <code>pointers</code> to Lambda function versions</li><li>Aliases enable Canary deployment by assigning weights to Lambda functions</li><li>Aliases cannot reference aliases</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img000912.png"></p><hr><h4 id="Lambda-with-CodeDeploy"><a href="#Lambda-with-CodeDeploy" class="headerlink" title="Lambda with CodeDeploy"></a>Lambda with CodeDeploy</h4><ul><li>CodeDeploy can help automate traffic shift for Lambda aliases<ul><li>Linear: Grow traffic every <code>N minutes</code> until <code>100%</code></li><li>Canary: Try <code>X</code> percent then <code>100%</code></li><li>AllAtOnce: Immediate</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img001338.png"></p><hr><h4 id="Lambda-Function-URL"><a href="#Lambda-Function-URL" class="headerlink" title="Lambda Function URL"></a>Lambda Function URL</h4><ul><li>Dedicated HTTPS endpoint for Lambda function (不用 API Gateway 的做法)<ul><li>形式 <code>https://&lt;url-id&gt;.lambda-url.&lt;region&gt;.on.aws</code></li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img001532.png"></p><hr><h4 id="Lambda-with-CodeGuru"><a href="#Lambda-with-CodeGuru" class="headerlink" title="Lambda with CodeGuru"></a>Lambda with CodeGuru</h4><ul><li>Gain insights into runtime performance of your Lambda function</li><li>CodeGuru creates a Profiler Group for your Lambda function</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img001843.png"></p><hr><h3 id="20-DynamoDB"><a href="#20-DynamoDB" class="headerlink" title="20. DynamoDB"></a>20. DynamoDB</h3><h4 id="AWS-DynamoDB"><a href="#AWS-DynamoDB" class="headerlink" title="AWS DynamoDB"></a>AWS DynamoDB</h4><ul><li>NoSQL database, with replication across multiple AZs, auto scaling, no provision</li><li>两种 Class: Standard &amp; Infrequent Access (IA)</li><li>如果问到 DynamoDB 而且是处理 Email 的, 就是 DynamoDB Stream</li><li>如果问到 DynamoDB 而且是处理 unpredictable 数据的时候, 选择 On-Demand table</li><li>By default, DynamoDB tables are encrypted with AWS owned key (重要)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img012414.png"></p><ul><li>Each table has a Primary Key, must be decided at creation time (2 种选择)<ul><li>Partition Key (HASH): Partition Key must be unique for each item</li><li>Partition Key + Sort Key (HASH + RANGE): The combination must be unique</li></ul></li><li>Item 的最大大小是 400 KB</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img012627.png"></p><ul><li>DynamoDB 有 2 种 backup 方法, On-demand 和 Point-in-time recovery, 但它们只能把数据写到 S3 里, 没办法从 backup 里面去 access S3 buckets</li><li>不要用 DynamoDB 去保存图片, 因为 DynamoDB 最大 item 大小是 400 KB</li><li>如果要给 DynamoDB ready-only access, 用 IAM Role <code>AmazonDynamoDBReadOnlyAccess</code></li></ul><hr><h4 id="DynamoDB-WCU-amp-RCU"><a href="#DynamoDB-WCU-amp-RCU" class="headerlink" title="DynamoDB WCU &amp; RCU"></a>DynamoDB WCU &amp; RCU</h4><ul><li>Read &#x2F; Write Capacity Mode (2 种 Mode)<ul><li>Provisioned Mode: 自己定义需要多少 RCU 和 WCU (默认)</li><li>On-Demand Mode: 自动 scale 需要的 RCU 和 WCU (贵)</li></ul></li><li>RCU 和 WCU 没有关联吗, 可以只加 RCU 不加 WCU</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img014420.png"></p><ul><li>R&#x2F;W Capacity Modes - Provisioned<ul><li>Read Capacity Units (RCU): throughput for reads</li><li>Write Capacity Units (WCU): throughput for writes</li><li>Throughput can be exceeded temporarily using <code>Burst Capacity</code></li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img014716.png"></p><ul><li>Write Capacity Units (WCU)<ul><li>One Write Capacity Unit represents <code>one write per second</code> for an item up to <code>1KB</code></li><li>非常重要, 记住 WCU 是 1 比 1 的, size 需要 round up 到整数</li><li>例子: 6 items with item size 4.5KB: <code>6 * 5 / 1 = 30 WCU</code></li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img014951.png"></p><ul><li>Strongly Consistent Read vs. Eventually Consistent Read (重要)<ul><li>Eventually Consistent Read: might get stale data because of duplication (默认)</li><li>Strongly Consistent Read: will always get the correct data (贵)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img015146.png"></p><ul><li>Read Capacity Units (RCU)<ul><li>One Read Capacity Unit represents one Strongly Consistent Read per second, or two Eventually Consistent Read per second, for an item up to 4 KB in size (重要)</li><li>非常重要, 对于 Strongly Consistent Read 来说是 1 比 4 的, size 要 round up 到 4 的倍数</li><li>非常重要, 对于 Eventually Consistent Read 来说是 2 比 4 的, size 要 round up 到 4 的倍数</li><li>例子: 10 Strongly Consistent Reads with item size 4 KB: <code>10 * 4 / 4 = 10 RCU</code></li><li>例子: 16 Eventually Consistent Reads with item size 12 KB: <code>16 /2 * 12 / 4 = 24 RCU</code></li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img015532.png"></p><ul><li>DynamoDB - Partitions Internal<ul><li>Data is stored in partitions, use Partition Key to know which partition should go</li><li>WCUs and RCUs are spread evenly across partitions</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img015726.png"></p><ul><li>DynamoDB - Throttling (重要)<ul><li>Exceeded provisioned RCUs or WCUs, get <code>ProvisionedThroughputExceededException</code></li><li>原因: Hot Keys, Hot Paritions, Very large items (重要)</li><li>解决方案: Exponential backoff, Distribute partition keys, use DynamoDB DAX (重要)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img015936.png"></p><ul><li>R&#x2F;W Capacity Modes - On-Demand<ul><li>Read &#x2F; writes automatically scale up &#x2F; down with workloads</li><li>Read Request Units (RRU): throughput for reads (same as RCU)</li><li>Write Request Units (WRU): throughput for writes (same as WCU)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img020318.png"></p><hr><h4 id="DynamoDB-Basic-Operations"><a href="#DynamoDB-Basic-Operations" class="headerlink" title="DynamoDB Basic Operations"></a>DynamoDB Basic Operations</h4><ul><li>注意, DynamoDB <code>UpdateItem</code> 是更新 attribute 或者新创建一个 (如果不存在)</li><li>Writing Data<ul><li><code>PutItem</code>: Create a new item or fully replace an old item</li><li><code>UpdateItem</code>: Edit an existing item’s attributes or add new items if not exist (注意)</li><li><code>Conditional Writes:</code> Accept a <code>write/update/delete</code> only if condition met</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img020700.png"></p><ul><li>Reading Data<ul><li><code>GetItem</code>: Read based on Primary key</li><li><code>Query</code>: Return items based on <code>KeyConditionExpression</code>, <code>FilterExpression</code></li><li><code>Scan</code>: Scan the entire table and then filter out data (可以 parallel, 重要)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img020844.png"></p><ul><li>Deleting Data<ul><li><code>DeleteItem</code>: Delete an individual item</li><li><code>DeleteTable</code>: Delete the whole table and all its items</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img021027.png"></p><ul><li>DynamoDB Batch Operations<ul><li>Allow yout to save in latency by reducing the number of API cals</li><li><code>BatchWriteItem</code> 和 <code>BatchGetItem</code></li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img021208.png"></p><ul><li>Table Cleanup (2 种方法)<ul><li><code>Scan + DeleteItem</code> 或者 <code>Drop Table + Recreate Table</code></li></ul></li><li>Copying a DynamoDB Table (3 种方法)<ul><li>AWS Data Pipeline 或者 Backup + Restore 或者 <code>Scan + PutItem or BatchWriteItem</code></li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img033405.png"></p><hr><h4 id="DynamoDB-Conditional-Writes"><a href="#DynamoDB-Conditional-Writes" class="headerlink" title="DynamoDB Conditional Writes"></a>DynamoDB Conditional Writes</h4><ul><li>For <code>PutItem, UpdateItem, DeleteItem, BatchWriteItem</code></li><li>Specify a conditional expression to determine which item should be modified</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img022327.png"></p><hr><h4 id="DynamoDB-Indexes"><a href="#DynamoDB-Indexes" class="headerlink" title="DynamoDB Indexes"></a>DynamoDB Indexes</h4><ul><li>Local Secondary Index (LSI, 重要)<ul><li>Alternative Sort Key for your table (注意这里是 Partition Key)</li><li>Must be defined at table creation time (重要)</li><li>Attribute Projections: Contain some or all attributes of the base table</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img025528.png"></p><ul><li>Global Secondary Index (GSI, 重要)<ul><li>Alternative Primary Key from the base table (注意这里是 Primary Key)</li><li>Must provision RCUs &amp; WCUs for the index</li><li>Can be added or modified after table creation</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img025824.png"></p><ul><li>Indexes and Throttling<ul><li>GSI: If writes are throttled on the GSI, then the main table will be throttled</li><li>LSI: Use WCUs and RCUs of the main table, no throttling consideration</li><li>重要, 是 GSI 会造成 throttling, LSI 不用考虑 throttling</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img025950.png"></p><hr><h4 id="DynamoDB-PartiQL"><a href="#DynamoDB-PartiQL" class="headerlink" title="DynamoDB PartiQL"></a>DynamoDB PartiQL</h4><ul><li>Use a SQL-like syntax to manipulate DynamoDB tables (重要)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img030113.png"></p><hr><h4 id="DynamoDB-Optimistic-Locking"><a href="#DynamoDB-Optimistic-Locking" class="headerlink" title="DynamoDB Optimistic Locking"></a>DynamoDB Optimistic Locking</h4><ul><li>A strategy to ensure an item hasn’t changed before update or delete it (重要)</li><li>DynamoDB Optimistic Locking 是 Concurrency Model, 而且它用 Conditional Writes (重要)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img030304.png"></p><hr><h4 id="DynamoDB-DAX"><a href="#DynamoDB-DAX" class="headerlink" title="DynamoDB DAX"></a>DynamoDB DAX</h4><ul><li>DynamoDB Accelerator (DAX, 可以处理 cache, 但是 DAX 不是 relational 的)<ul><li>Help solve read congestion by caching (microseconds latency, 缓存)</li><li>DAX 不支持 SQL query caching</li><li>可以提高 DynamoDB 的 performance (提高的是 read 而不是 write, 重要)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img233440.png"></p><hr><h4 id="DynamoDB-Stream"><a href="#DynamoDB-Stream" class="headerlink" title="DynamoDB Stream"></a>DynamoDB Stream</h4><ul><li>DynamoDB Stream: 目标是 Lambda 和 Kinesis Data Streams, 没有 SQS (注意)<ul><li>Ordered stream of item-level modifications in table (重要)</li><li>用来处理 Stream 的, 可以 Invoke Lambda function (比如发邮件)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img030626.png"></p><ul><li>DynamoDB Streams are made of shards, like Kinesis Data Streams</li><li>Records are not retroactively populated in a stream after enabling it</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img030940.png"></p><hr><h4 id="DynamoDB-TTL"><a href="#DynamoDB-TTL" class="headerlink" title="DynamoDB TTL"></a>DynamoDB TTL</h4><ul><li>Automatic delete items after an expiry timestamp (定时删除 DynamoDB 里的 item)</li><li>Expired items deleted within 48 hours of expiration</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img031135.png"></p><hr><h4 id="DynamoDB-CLI"><a href="#DynamoDB-CLI" class="headerlink" title="DynamoDB CLI"></a>DynamoDB CLI</h4><ul><li><code>projection-expression</code>: Select a subset of attribute to retrieve (subset of attribute)</li><li><code>filter-expression</code>: Filter items to retrieve a subset of the items (subset of items)</li><li>Minimize the items returned in CLI: <code>max-items &amp; starting-token</code></li><li>注意, 如果问到和 attribute 有关的就是 <code>projection-expression</code></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img031324.png"></p><hr><h4 id="DynamoDB-Transcations"><a href="#DynamoDB-Transcations" class="headerlink" title="DynamoDB Transcations"></a>DynamoDB Transcations</h4><ul><li>Coordinated operations to multiple items across one or more tables (金融, 游戏)</li><li>Provides Atomcity, Consistency, Isolation, and Durability (ACID)</li><li>Consume 2 times of WCUs &amp; RCUs (注意, DynamoDB Transcation 消耗 2 倍 WCU 和 RCU)</li><li>Two operations: <code>TransactGetItems</code> 和 <code>TransactWriteItems</code></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img031646.png"></p><ul><li>DynamoDB Transactions Capacity Computation<ul><li>3 Transcational writes with item size 5 KB: need 3 * 5 &#x2F; 1 * 2 &#x3D; 30 WCUs</li><li>5 Transcation reads with items size 5 KB: need 5 * 8 &#x2F; 4 * 2 &#x3D; 20 RCUs</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img032052.png"></p><hr><h4 id="DynamoDB-Session-State"><a href="#DynamoDB-Session-State" class="headerlink" title="DynamoDB Session State"></a>DynamoDB Session State</h4><ul><li>To use DynamoDB to store the session state</li><li>ElastiCache is in-memory, DynamoDB is serverless (both are key&#x2F;value pair)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img032422.png"></p><hr><h4 id="DynamoDB-Write-Sharding"><a href="#DynamoDB-Write-Sharding" class="headerlink" title="DynamoDB Write Sharding"></a>DynamoDB Write Sharding</h4><ul><li>A strategy that allow better distribution of items evenly across partitions <ul><li>To solve the issue of <code>Hot Partition</code></li></ul></li><li>Add a suffix to Partition Key value</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img032640.png"></p><hr><h4 id="DynamoDB-Other-Features"><a href="#DynamoDB-Other-Features" class="headerlink" title="DynamoDB Other Features"></a>DynamoDB Other Features</h4><ul><li>Backup and Restore: Point-in-time recovery (PITR) like RDS</li><li>Global Tables: Multi-region, fully replicated, high performance</li><li>DynamoDB Local: Develop and test app locally with out accessing internet</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img033717.png"></p><ul><li>DynamoDB Fine-Grained Access Control<ul><li>Assign IAM Role to users with a Condition to limit their API access DynamoDB</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img033855.png"></p><hr><h3 id="21-API-Gateway"><a href="#21-API-Gateway" class="headerlink" title="21. API Gateway"></a>21. API Gateway</h3><h4 id="AWS-API-Gateway"><a href="#AWS-API-Gateway" class="headerlink" title="AWS API Gateway"></a>AWS API Gateway</h4><ul><li>Invoke Lambda function, expose REST API (stateless client-server communication)</li><li>Lambda + API Gateway &#x3D; No infrastructure to manage</li><li>API Gateway 可以防止 API overwhelmed by too many requests (防抖)</li><li>API Gateway Caching (可以 improve latency, 重要)<ul><li>With caching, you can reduce the number of calls made to your endpoint and also improve the latency of requests to your API</li></ul></li><li>注意, API Gateway 不 support STS, 可以用 Congito User Pool, IAM permissions with sigv4 和 Lambda Authorizer</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img164125.png"></p><ul><li>API Gateway Endpoint Types<ul><li>Edge-Optimized (默认): For global clients, API Gateway live in one region</li><li>Regional: For client in same region</li><li>Private: Can only be accessed from VPC using ENI</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img164338.png"></p><ul><li>API Gateway 可以用 Cognito User Pools, AWS IAM roles and policies 和 Lambda Authorizer 来进行 authenticate</li></ul><hr><h4 id="API-Gateway-Stages"><a href="#API-Gateway-Stages" class="headerlink" title="API Gateway Stages"></a>API Gateway Stages</h4><ul><li>Making changes in the API Gateway does not mean they’re effective (重要)<ul><li>You need to make a “deployment” for them to be in effect</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img173311.png"></p><ul><li>API Gateway - Stage Variables<ul><li>Stage variables are like environment variables for API Gateway</li><li>Use case: Create a stage variable to indicate the Lambda alias (重要)</li><li>如果要把 test promote 成 prod, 而且当前 prod 存在, 直接 update stage variable 就行</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img190149.png"></p><hr><h4 id="API-Gateway-Canary-Deployment"><a href="#API-Gateway-Canary-Deployment" class="headerlink" title="API Gateway Canary Deployment"></a>API Gateway Canary Deployment</h4><ul><li>Choose the <code>%</code> of traffic the canary channel receives<ul><li>Canary deployment: 逐步发布新版本，先小规模测试，再全面推广的策略</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img190857.png"></p><hr><h4 id="API-Gateway-Integration-Tyeps"><a href="#API-Gateway-Integration-Tyeps" class="headerlink" title="API Gateway Integration Tyeps"></a>API Gateway Integration Tyeps</h4><ul><li><code>MOCK</code><ul><li>API Gateway returns a response without sending the request to backend</li></ul></li><li><code>HTTP / AWS</code><ul><li>Configure both the integration request and integration response</li><li>Set up data mapping using mapping templates for request &amp; response</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img191239.png"></p><ul><li><code>AWS_PROXY</code> (Lambda Proxy)<ul><li>Incoming request from the client is the input to Lambda</li><li>No mapping template, headers, query string parameters are passed as arguments</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img191413.png"></p><ul><li><code>HTTP_PROXY</code><ul><li>No mapping template, the HTTP request is passed to the backend</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img191520.png"></p><hr><h4 id="API-Gateway-Mapping-Templates"><a href="#API-Gateway-Mapping-Templates" class="headerlink" title="API Gateway Mapping Templates"></a>API Gateway Mapping Templates</h4><ul><li>Mapping templates can be used to modify request &#x2F; responses<ul><li>可以用来屏蔽 output data 中的某些字段</li></ul></li><li>Modify query string parameters, modify body content, add headers</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img191718.png"></p><hr><h4 id="API-Gateway-OpenAPI"><a href="#API-Gateway-OpenAPI" class="headerlink" title="API Gateway OpenAPI"></a>API Gateway OpenAPI</h4><ul><li>Common way to define REST APIs, using API defintion as code</li><li>Request Validation: reduce unnecessary calls to the backend</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img201259.png"></p><hr><h4 id="API-Gateway-Caching"><a href="#API-Gateway-Caching" class="headerlink" title="API Gateway Caching"></a>API Gateway Caching</h4><ul><li>Caching reduces the number of calls made to the backend</li><li>Caches are defined per <code>stage</code>, default TTL is <code>300</code> sec, max TTL is <code>3600</code> sec (重要)</li><li>Client can invalidate the cache with header: <code>Cache-Control:max-age=0</code> (重要)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img201709.png"></p><hr><h4 id="API-Gateway-Usage-Plans-amp-API-Keys"><a href="#API-Gateway-Usage-Plans-amp-API-Keys" class="headerlink" title="API Gateway Usage Plans &amp; API Keys"></a>API Gateway Usage Plans &amp; API Keys</h4><ul><li>Make an API availiable as an offering to your customers (重要)</li><li>Usage Plan: who can access, how much and how fast can access, use API keys to identify</li><li>API Keys: use with usage plans to control access</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img202109.png"></p><ul><li>To configure a usage plan<ul><li>Create one or more APIs, configure methods to require API key, deploy API to stage</li><li>Generate or import API keys to distribute to application developer</li><li>Create the usage plan with desired throttle and quota limits</li><li>Associate API stages and API keys with the usage plan</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img202324.png"></p><hr><h4 id="API-Gateway-Monitoring"><a href="#API-Gateway-Monitoring" class="headerlink" title="API Gateway Monitoring"></a>API Gateway Monitoring</h4><ul><li><code>CacheHitCount &amp; CacheMissCount</code>: efficiency of the cache </li><li><code>IntegrationLatency</code>: 用来测 timeout issue </li><li><code>4XX</code> means Client errors, <code>5XX </code>means Server errors, <code>429</code> 是 too many requests</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img202658.png"></p><hr><h4 id="API-Gateway-CORS"><a href="#API-Gateway-CORS" class="headerlink" title="API Gateway CORS"></a>API Gateway CORS</h4><ul><li>CORS must be enabled when you receive API calls from another domain</li><li>CORS 也可以用来限制一些 domain 来防止它们 access API</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img202855.png"></p><hr><h4 id="API-Gateway-Security"><a href="#API-Gateway-Security" class="headerlink" title="API Gateway Security"></a>API Gateway Security</h4><ul><li>IAM Permissions (for within your AWS account)<ul><li>Authentication is IAM, Authorization is IAM Policy</li><li>Create an IAM policy authorization and attch to User or Role</li><li>If need Cross Account Access, use Resource Policies</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img203055.png"></p><ul><li>Cognito User Pools (for your own user pool, 重要)<ul><li>Authentication is Cognito User Pools, Authorization is API Gateway Methods</li><li>API Gateway verifies identity automatically from AWS Cognito</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img203446.png"></p><ul><li>Lambda Authorizer (use 3rd party tokens, 重要)<ul><li>Authentication is External, Authorization is Lambda function</li><li>Token-based authorizer, JWT or Oauth</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img203612.png"></p><hr><h4 id="API-Gateway-WebSocket-API"><a href="#API-Gateway-WebSocket-API" class="headerlink" title="API Gateway WebSocket API"></a>API Gateway WebSocket API</h4><ul><li>WebSocket APIs are often used in real time applications such as chat or trading<ul><li>WebSocket is two ways commmunication</li></ul></li><li>形式 <code>wss://[uniqueid].execute-api.[region].amazonaws.com/[stage-name]</code></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img204056.png"></p><ul><li>WebSocket API - Routing<ul><li>Request a route selection expression to select the field on JSON to route from</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img204735.png"></p><hr><h3 id="22-AWS-CICD"><a href="#22-AWS-CICD" class="headerlink" title="22. AWS CICD"></a>22. AWS CICD</h3><h4 id="AWS-CodeCommit"><a href="#AWS-CodeCommit" class="headerlink" title="AWS CodeCommit"></a>AWS CodeCommit</h4><ul><li>A version control tool that helps to understand the changes happened to the code</li><li>CodeCommit is a Private Git repository (就是个 Github, 但是私人的)</li><li>如果问到 migrate repository 到 CodeCommit 使用 HTTPS, 那么用到的是 Git credentials generated from IAM (重要)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img213239.png"></p><ul><li>CodeCommit 可以使用 Git credentials, SSH Keys, AWS Access Keys</li><li>Data in AWS CodeCommit repositories is encrypted in transit and at rest</li></ul><hr><h4 id="AWS-CodePipeline"><a href="#AWS-CodePipeline" class="headerlink" title="AWS CodePipeline"></a>AWS CodePipeline</h4><ul><li>CodePipeline 是一种自动化 CICD 服务, 用于构建、测试和部署应用程序和基础设施<ul><li>如果看到 orchestrate CICD, 就是 CodePipeline</li></ul></li><li>可以 create one CodePipline for entire flow and add a manual approval step</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img215659.png"></p><ul><li>Each pipeline stage can create artifacts</li><li>Artifaces stored in an S3 bucket and passed on to the next stage</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img215817.png"></p><hr><h4 id="AWS-CodeBuild"><a href="#AWS-CodeBuild" class="headerlink" title="AWS CodeBuild"></a>AWS CodeBuild</h4><ul><li>CodeBuild 是一种完全托管的持续集成服务, 用于自动化构建、测试和生成软件包</li><li>CodeBuild 算是 Jenkins 的替代品</li><li>Build instructions: Code file <code>buildspec.yml</code> (重要) or insert manually in Console</li><li>Automated tests on application before the deployment process (遇到需要 test 的就是 CodeBuild, 重要)</li><li>CodeBuild scales automatically, 所以遇到什么 scaling 和 run build parallel 都不用担心</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img220508.png"></p><ul><li><code>buildspec.yml</code> file must be at the root of your code (重要)</li><li>记住, CodeBuild 可以用 KMS key 来加密 build artifacts (重要)</li><li>可以使用 CodeBuild timeouts 去防止过长的 building process</li><li>We bundle dependencies in the source code during the build stage of CodeBuild</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img220651.png"></p><hr><h4 id="AWS-CodeDeploy"><a href="#AWS-CodeDeploy" class="headerlink" title="AWS CodeDeploy"></a>AWS CodeDeploy</h4><ul><li>CodeDeploy 是一种自动化部署服务, 用于在各种计算环境中部署应用程序代码</li><li>Automated rollback in case failed deployment (可以自动 roll back 如果部署失败)<ul><li>If a rollback happens, CodeDeploy redeploys the last good revision</li></ul></li><li>A file named <code>appspec.yml</code> defines how the deployment happens</li><li>如果问到 CodeDeploy 和 EC2, 那么就只有 <code>in-place</code> 和 <code>blue/green</code><ul><li><code>blue/green</code> 可以 re-route traffic from original environment to new environment</li></ul></li><li>如果遇到要 archive number of applicaiton revision, 用 CodeDeploy Agent</li><li>如果 CodeDeploy 失败并且 rollback, A new deployment of the last known working version of the application is deployed with a new deployment ID</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img220850.png"></p><ul><li>CodeDeploy - EC2 &#x2F; On-premises Platform (需要 Agent)<ul><li>Perform <code>in-place</code> deployment or <code>blue/green</code> deployments (非常重要)</li><li>Must run the CodeDeploy Agent on the target instances (重要)</li><li>Order of Lifecycle Events: <code>ApplicationStop, DownloadBundle, BeforeInstall, Install, AfterInstall, ApplicationStart, ValidateService</code></li><li>四种 deployment speed: <code>AllAtOnce, HalfAtATime, OneAtATime, Custom</code></li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img221100.png"></p><ul><li>CodeDeploy - Lambda Platform<ul><li>Automate traffic shift for Lambda aliases</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img221326.png"></p><ul><li>CodeDeploy - ECS Platform<ul><li>Automate the deployment of a new ECS Task Definition</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img221501.png"></p><hr><h4 id="AWS-CodeStar-CodeCatalyst"><a href="#AWS-CodeStar-CodeCatalyst" class="headerlink" title="AWS CodeStar (CodeCatalyst)"></a>AWS CodeStar (CodeCatalyst)</h4><ul><li>Quickly create <code>CICD-ready</code> projects for EC2, Lambda, Elastic Beanstalk</li><li>One dashboard to view all your componenets (重要, 和 dashboard 有关)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img224413.png"></p><hr><h4 id="AWS-CodeArtifact"><a href="#AWS-CodeArtifact" class="headerlink" title="AWS CodeArtifact"></a>AWS CodeArtifact</h4><ul><li>CodeArtifact is a secure and cost-effective artifact management for software development (类似 npm)</li><li>Developers and CodeBuild can retrieve dependencies straight from CodeArtifact</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img221957.png"></p><ul><li>CodeArtifact Resource Policy (Resource Policy 就是允许别人访问)<ul><li>Authorize another account to access CodeArtifact</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img222141.png"></p><hr><h4 id="AWS-CodeGuru"><a href="#AWS-CodeGuru" class="headerlink" title="AWS CodeGuru"></a>AWS CodeGuru</h4><ul><li>An ML-powered service for code reviews and performance recommendations (重要)</li><li>CodeGuru Reviewer: Automated code reviews for static code analysis (development)</li><li>CodeGuru Profiler: Recommendations about application performance (production)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img222415.png"></p><hr><h4 id="AWS-Cloud9"><a href="#AWS-Cloud9" class="headerlink" title="AWS Cloud9"></a>AWS Cloud9</h4><ul><li>Cloud-based IDE, 类似 VSCode</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img222601.png"></p><hr><h3 id="23-AWS-Serverless-Application-Model-SAM"><a href="#23-AWS-Serverless-Application-Model-SAM" class="headerlink" title="23. AWS Serverless Application Model (SAM)"></a>23. AWS Serverless Application Model (SAM)</h3><h4 id="AWS-SAM"><a href="#AWS-SAM" class="headerlink" title="AWS SAM"></a>AWS SAM</h4><ul><li>SAM &#x3D; Serverless Application Model</li><li>A framework for developing and deploying serverless applications</li><li>可以将 AWS SAM 模板直接部署到 AWS CloudFormation</li><li>使用 AWS Serverless Application Repository (SAR) 来共享 SAM 和其他 AWS 账户 (重要)<ul><li>如果想找 pre-built serverless applications 就用 SAR</li></ul></li><li>Develop the SAM template locally &#x3D;&gt; upload the template to S3 &#x3D;&gt; deploy your application to the cloud (注意)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img153636.png"></p><ul><li>SAM Recipe<ul><li><code>Transform</code> Header for SAM template: <code>AWS::Serverless-2016-10-31</code></li><li>注意, <code>Transform</code> 对于 SAM 来说是 mandatory 的</li><li>SAM supports the following resource types: <code>Function, Api, SimpleTable</code> (重要)</li><li>Upload SAM 到 AWS 用到的是 <code>sam deploy</code></li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img155435.png"></p><ul><li>SAM Accelerate <code>sam sync</code><ul><li>A set of features to reduce latency while deploying resources to AWS</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img154010.png"></p><hr><h4 id="SAM-Policy-Templates"><a href="#SAM-Policy-Templates" class="headerlink" title="SAM Policy Templates"></a>SAM Policy Templates</h4><ul><li>List of templates to apply permissions to Lambda Functions<ul><li><code>S3ReadPolicy</code>: Give read only permission to objects in S3</li><li><code>SQSPollerPolicy</code>: Allow to poll an SQS queue</li><li><code>DynamoDBCrudPolicy</code>: create, read, update, delete</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img154539.png"></p><hr><h4 id="SAM-Local-Capabilities"><a href="#SAM-Local-Capabilities" class="headerlink" title="SAM Local Capabilities"></a>SAM Local Capabilities</h4><ul><li>SAM Local 用于本地模拟、测试和调试无服务器应用程序, 支持 Lambda 和 API Gateway</li><li>Locally start AWS Lambda (记住这里都是 SAM CLI + AWS Toolkits)</li><li>Locally invoke Lambda Function</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img154914.png"></p><ul><li>Locally start an API Gateway Endpoint</li><li>Generate AWS Events for Lambda Functions</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img155003.png"></p><hr><h3 id="24-Cloud-Deployment-Kit-CDK"><a href="#24-Cloud-Deployment-Kit-CDK" class="headerlink" title="24. Cloud Deployment Kit (CDK)"></a>24. Cloud Deployment Kit (CDK)</h3><h4 id="AWS-Cloud-Development-Kit"><a href="#AWS-Cloud-Development-Kit" class="headerlink" title="AWS Cloud Development Kit"></a>AWS Cloud Development Kit</h4><ul><li>Define your cloud infrastructure using a familiar language (Java, Python)</li><li>Can deploy infrastructure and application runtime code together</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img160250.png"></p><ul><li>CDK 和 SAM 的不同 (虽然它们都用 CloudFormation)<ul><li>SAM 主要关注的是 Serverless 和 Lambda, 而且只能用 JSON 或者 YAML 的形式</li><li>CDK 可以用在所有 AWS services 上, 可以用所有编程语言</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img160532.png"></p><ul><li>注意, CDK 才会提供 app template, 而不是 CloudFormation (重要)</li></ul><hr><h3 id="25-Cognito"><a href="#25-Cognito" class="headerlink" title="25. Cognito"></a>25. Cognito</h3><h4 id="AWS-Cognito"><a href="#AWS-Cognito" class="headerlink" title="AWS Cognito"></a>AWS Cognito</h4><ul><li>AWS Cognito 是一种用户身份管理服务, 用于安全地添加用户注册、登录和访问控制功能<ul><li>Cognito User Pools: Sign in for app, integraet with API Gateway &amp; ALB</li><li>Cognito Identity Pools: Integrate with Cognito User Pools as identity provider</li></ul></li><li>CUP + CIP &#x3D; authentication + authorization</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img181012.png"></p><ul><li>Cognito Sync: Enable cross-device syncing of application related user data</li></ul><hr><h4 id="Cognito-User-Pools-CUP"><a href="#Cognito-User-Pools-CUP" class="headerlink" title="Cognito User Pools (CUP)"></a>Cognito User Pools (CUP)</h4><ul><li>与 API Gateway 和 Application Load Balancer 集成 (重要)</li><li>After a successful login using Cognito User Pools, it sends a JWT token (重要)</li><li>Adaptive Authentication<ul><li>Block sign-ins or require MFA if the login appears suspicious (重要)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img181142.png"></p><hr><h4 id="Cognito-Identity-Pools-CIP"><a href="#Cognito-Identity-Pools-CIP" class="headerlink" title="Cognito Identity Pools (CIP)"></a>Cognito Identity Pools (CIP)</h4><ul><li>Get identities for <code>users</code> so they obtain temporary AWS credentials</li><li>如果需要 integrate user-specific file upload and download feature, 使用 IAM policy with AWS Cognito identity prefix to restrict users to use their own folders in S3</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img20555%EF%BC%95.png"></p><hr><h3 id="26-Step-Functions-amp-AppSync"><a href="#26-Step-Functions-amp-AppSync" class="headerlink" title="26. Step Functions &amp; AppSync"></a>26. Step Functions &amp; AppSync</h3><h4 id="AWS-Step-Functions"><a href="#AWS-Step-Functions" class="headerlink" title="AWS Step Functions"></a>AWS Step Functions</h4><ul><li>AWS Step Functions 是一种可视化工作流服务, 用于协调和管理分布式应用程序和微服务</li><li>有两种 Workflows: Standard 和 Express (Express 里有 Sync 和 Async)<ul><li>Standard 适合 long-running, durable, and auditable workflow</li><li>Express 适合 high event rates and short duration workflow</li></ul></li><li>Task States: Do some work in the state machine (比如 invoke Lambda function)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img215042.png"></p><ul><li>Parallel State: Begin parallel branches of execution</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img215355.png"></p><ul><li>A Task state <code>(&quot;Type&quot;: &quot;Task&quot;)</code> represents a single unit of work performed by a state machine (重要)</li></ul><hr><h4 id="Step-Functions-Error-Handling"><a href="#Step-Functions-Error-Handling" class="headerlink" title="Step Functions Error Handling"></a>Step Functions Error Handling</h4><ul><li>Any state can encounter runtime errors for various reasons</li><li>Use <code>Retry</code> and <code>Catch</code> in the State Machine to handle error instead of application code</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img215654.png"></p><hr><h4 id="Step-Functions-Wait-for-Task-Token"><a href="#Step-Functions-Wait-for-Task-Token" class="headerlink" title="Step Functions Wait for Task Token"></a>Step Functions Wait for Task Token</h4><ul><li>Allow to pause Step Functions during a Task until a Task Token is returned</li><li>Append <code>.waitForTaskToken</code> to the Resource field</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img220013.png"></p><hr><h4 id="Step-Functions-Activity-Tasks"><a href="#Step-Functions-Activity-Tasks" class="headerlink" title="Step Functions Activity Tasks"></a>Step Functions Activity Tasks</h4><ul><li>Task performed by an Activity Worker (Acitvity Worker 可以在 EC2, Lambda 上跑)</li><li>After Activity Worker complete its work, it sends a response back to Step Functions</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img220441.png"></p><hr><h4 id="AWS-AppSync"><a href="#AWS-AppSync" class="headerlink" title="AWS AppSync"></a>AWS AppSync</h4><ul><li>AppSync is a managed service that use GraphQL (重要)</li><li>Retrieve data in real-time with WebSocket or MQTT on WebSocket (重要)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img221024.png"></p><hr><h4 id="AWS-Amplify"><a href="#AWS-Amplify" class="headerlink" title="AWS Amplify"></a>AWS Amplify</h4><ul><li>A set of tools to create mobile and web applications (就类似 firebase, 重要)<ul><li>Authentication: leverage AWS Cognito</li><li>Datastore: leverage AWS AppSync and DynamoDB</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img22%EF%BC%96024.png"></p><hr><h3 id="27-Advanced-Identity"><a href="#27-Advanced-Identity" class="headerlink" title="27. Advanced Identity"></a>27. Advanced Identity</h3><h4 id="AWS-STS"><a href="#AWS-STS" class="headerlink" title="AWS STS"></a>AWS STS</h4><ul><li>AWS STS (Security Token Service) 是一种用于临时生成访问密钥以访问 AWS 资源的服务<ul><li>Allow to grant limited and temporary access to AWS up to 1 hour</li></ul></li><li>注意, 遇到 <code>decode-authorization-message</code> 的就是 STS</li><li>STS 的有效期从 15 分钟到 1 小时, 有效期过后需要 renew</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img230636.png"></p><hr><h4 id="Advanced-IAM"><a href="#Advanced-IAM" class="headerlink" title="Advanced IAM"></a>Advanced IAM</h4><ul><li>Evaluation of Policies (重要)<ul><li>先查是不是 Deny, 是就直接 Deny,不是就查是不是 Allow, 是就直接 Allow, 否则直接 Deny</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img231838.png"></p><ul><li>IAM Policies &amp; S3 Bucket Policies<ul><li>需要同时 evaluate IAM 和 S3 的 Polciy, 只要两个里面没有 Deny 就行</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img232221.png"></p><ul><li>Dynamic Policies with IAM (重要)<ul><li>Give IAM policy to a specific user, using <code>$&#123;aws:username&#125; </code>(dynamic variable)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img232539.png"></p><hr><h4 id="IAM-Access-Analyzer"><a href="#IAM-Access-Analyzer" class="headerlink" title="IAM Access Analyzer"></a>IAM Access Analyzer</h4><ul><li>IAM Access Analyzer simplifies inspecting unused access to guide you toward least privilege (重要, 可以 remove 一些不需要的 IAM Roles)</li><li>IAM Access Analyzer also lets you identify unintended access to your resources and data, which is a security risk (减少 security issues)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img012837.png"></p><hr><h4 id="AWS-Directory-Services-AD"><a href="#AWS-Directory-Services-AD" class="headerlink" title="AWS Directory Services (AD)"></a>AWS Directory Services (AD)</h4><ul><li>AWS Directory Services (AD) 是一种托管服务, 用于在 AWS 云中运行 Microsoft Active Directory,简化身份验证和资源管理<ul><li>AWS Managed Microsoft AD: AD in AWS, supports MFA (重要，AD 在 AWS )</li><li>AD Connector: Redirect to on-premise AD, supports MFA (重要, AD 在 on premise)</li><li>Simple AD: AD-compatible managed directory on AWS</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img232910.png"></p><hr><h3 id="28-AWS-Security-amp-Encryption"><a href="#28-AWS-Security-amp-Encryption" class="headerlink" title="28. AWS Security &amp; Encryption"></a>28. AWS Security &amp; Encryption</h3><h4 id="Encryption-101"><a href="#Encryption-101" class="headerlink" title="Encryption 101"></a>Encryption 101</h4><ul><li>Encryption in flight<ul><li>Data is encrypted before sending and decrypted after receive (重要)</li></ul></li><li>Server-side encryption<ul><li>Both encryption and decryption happen on the server (重要)</li></ul></li><li>Client-side encryption<ul><li>Data is encrypted by client and never decrypted by the server (重要)</li></ul></li></ul><blockquote><p>IAM policy to enforce SSL request to objects stored in S3: <code>aws:SecureTransport</code></p></blockquote><hr><h4 id="AWS-KMS"><a href="#AWS-KMS" class="headerlink" title="AWS KMS"></a>AWS KMS</h4><ul><li>Anytime you hear <code>encryption</code> for an AWS service, it’s most likely KMS</li><li>AWS managed encryption keys for us, 比如 EBS, S3, RDS, SSM (不需要自己创建)</li><li>KMS Keys are scoped per Region, Automatic Key Rotation is 1 year</li><li>注意, KMS 并不适合保存 secret, 加密的东西不一定是 secret</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img175137.png"></p><ul><li>Types of KMS Keys (3 种): AWS Owned, AWS Managed, CMK (Custom Managed)<ul><li>KMS stores the CMK and receives data from client, which it encrypt and send back</li></ul></li><li>两种 Key 的形式: Symmetric (Single) &amp; Asymmetric (Public &amp; Private)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img171058.png"></p><ul><li>KMS Key Policies<ul><li>KMS Key Policy 可以用来管理 KMS CMK (重要)</li><li>Custom KMS Key Policy: Define who can access the key (Cross Account Access)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img175606.png"></p><blockquote><p>Deleting an AWS KMS key in AWS Key Management Service (AWS KMS) is destructive and potentially dangerous. Therefore, AWS KMS enforces a waiting period. (Pending state)</p></blockquote><hr><h4 id="KMS-Envelope-Encryption"><a href="#KMS-Envelope-Encryption" class="headerlink" title="KMS Envelope Encryption"></a>KMS Envelope Encryption</h4><ul><li>KMS <code>Encrypt</code> API call has a limit of 4 KB (重要)</li><li>If encrypt &gt; 4 KM, we need to use Envelope Encryption (<code>GenerateDataKey</code> API)</li><li>Envelope Encryption 是 reference data as file within the code</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img175943.png"></p><ul><li>KMS Symmetric API Summary<ul><li><code>Encrypt</code>: encrypt up to 4KB of data through KMS</li><li><code>GenerateDataKey</code>: generates a unique symmetric data key (DEK)</li><li><code>GemerateDataKeyWithoutPlaintext</code>: generate a DEK to use later</li><li><code>Decrypt</code>: decrypt up to 4 KB of data</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img180803.png"></p><hr><h4 id="KMS-Limits"><a href="#KMS-Limits" class="headerlink" title="KMS Limits"></a>KMS Limits</h4><ul><li>KMS Request Quotas: Exceed a request quota, get a <code>ThrottlingException</code></li><li>Request a Requst Quotas increase through API or AWS support</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img184019.png"></p><hr><h4 id="AWS-CloudHSM"><a href="#AWS-CloudHSM" class="headerlink" title="AWS CloudHSM"></a>AWS CloudHSM</h4><ul><li>AWS CloudHSM 是一种托管硬件安全模块服务, 用于安全存储和管理加密密钥<ul><li>We have to manage the encryption keys entirely</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img184859.png"></p><hr><h4 id="SSM-Parameter-Store"><a href="#SSM-Parameter-Store" class="headerlink" title="SSM Parameter Store"></a>SSM Parameter Store</h4><ul><li>SSM Parameter Store 是一种安全的存储服务, 管理配置数据和密钥, 如密码和数据库字符串<ul><li>比起 Secrets Manager 有更广的用途, 比如 URLs, AMI IDs, License keys 等等</li><li>SSM 没有 Automatic key rotation (非常重要)</li></ul></li><li>Have built-in verion tracking (每次 edit secret 都会被记录, 重要)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img173611.png"></p><ul><li>可以将 secret 储存成 SecureString 在 SSM Parameter Store 里 (重要)</li></ul><hr><h4 id="AWS-Secrets-Manager"><a href="#AWS-Secrets-Manager" class="headerlink" title="AWS Secrets Manager"></a>AWS Secrets Manager</h4><ul><li>Store secrets, integrated with RDS &amp; Aurora (非常重要, 存数据库 secrets 的)<ul><li>是给 confidential information (like database credentials, API keys) 用的</li><li>比起 SSM Parameter Store, Secrets Manager 支持 Key 的轮换 (90 天)</li><li>注意, Secrets Manager 的 Key Rotateion 是 90 天, KMS 的 Key Rotateion 是一年</li></ul></li><li>比起 KMS, Secrets Manager 更适合去保存 secret, 比如 database credential, 而且 Secrets Manager 也有 Automatic key rotation</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img185726.png"></p><ul><li>Multi-Region Secrets (和 Multi-Region Key 类似)<ul><li>Replicate Secrets across multiple AWS Regions (disaster recovery)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img174258.png"></p><hr><h4 id="CloudWatch-Logs-Encryption"><a href="#CloudWatch-Logs-Encryption" class="headerlink" title="CloudWatch Logs Encryption"></a>CloudWatch Logs Encryption</h4><ul><li>Encrypt CloudWatch Logs with KMS keys<ul><li>Encryption is enabled at the log group level, by associating a CMK</li></ul></li><li><code>associate-kms-key</code>: if log group already exists (重要, CloudWatch 存在的情况)</li><li><code>create-log-group</code>: if the log group doesn’t exist</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img190545.png"></p><hr><h4 id="AWS-Nitro-Enclaves"><a href="#AWS-Nitro-Enclaves" class="headerlink" title="AWS Nitro Enclaves"></a>AWS Nitro Enclaves</h4><ul><li>Process highly sensitive data in an isolated compute environment</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img190809.png"></p><hr><h3 id="29-Other-AWS-Services"><a href="#29-Other-AWS-Services" class="headerlink" title="29. Other AWS Services"></a>29. Other AWS Services</h3><h4 id="AWS-SES-Simple-Email-Service"><a href="#AWS-SES-Simple-Email-Service" class="headerlink" title="AWS SES (Simple Email Service)"></a>AWS SES (Simple Email Service)</h4><ul><li>Managed service to send email securely (发邮件的)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img004334.png"></p><hr><h4 id="AWS-OpenSearch"><a href="#AWS-OpenSearch" class="headerlink" title="AWS OpenSearch"></a>AWS OpenSearch</h4><ul><li>With OpenSearch, you can search any field, even partially matches<ul><li>原来叫做 ElasticSearch (就是做查询的)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img192053.png"></p><hr><h4 id="AWS-Athena"><a href="#AWS-Athena" class="headerlink" title="AWS Athena"></a>AWS Athena</h4><ul><li>Athena is an query service that analyze data in Amazon S3 using standard SQL<ul><li>Athena 支持 SQL query 去处理 S3 数据的</li><li>Athena cannot be used to analyze data in real time (没办法实时处理数据, 重要)</li></ul></li><li>Use Athena to process logs, perform ad-hoc analysis, and run interactive queries (重要)</li><li>Use columnar data for cost-saving (省钱, less scan)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img192218.png"></p><ul><li>Federated Query<ul><li>Allow to run SQL queries across data stored on AWS or On-Premise</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img200427.png"></p><hr><h4 id="AWS-MSK"><a href="#AWS-MSK" class="headerlink" title="AWS MSK"></a>AWS MSK</h4><ul><li>Managed Apache Kafka on AWS (Have Serverless)<ul><li>Kinesis 的代替 (同样处理 Stream data), 但是针对 Apache Kafka</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img230056.png"></p><hr><h4 id="AWS-Certificate-Manager-ACM"><a href="#AWS-Certificate-Manager-ACM" class="headerlink" title="AWS Certificate Manager (ACM)"></a>AWS Certificate Manager (ACM)</h4><ul><li>AWS Certificate Manager (ACM) 是一种管理 SSL&#x2F;TLS 证书的服务, 用于安全地保护和管理网站和应用程序的通信<ul><li>如果是 third party SSL 就没办法使用 automatic certificate rotation</li></ul></li><li>可以用 EventBridge 来检查 ACM Certificates 是否过期 (过期 Invoke SNS)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img174451.png"></p><hr><h4 id="AWS-Macie"><a href="#AWS-Macie" class="headerlink" title="AWS Macie"></a>AWS Macie</h4><ul><li>Use ML to protect sensitive data (PII) in AWS (用 ML 保护敏感信息)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img192617.png"></p><hr><h4 id="AWS-AppConfig"><a href="#AWS-AppConfig" class="headerlink" title="AWS AppConfig"></a>AWS AppConfig</h4><ul><li>Configurate, validate, and deploy dynamic configurations</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img192722.png"></p><hr><h3 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h3><blockquote><p>请勿随意修改, 谢谢</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Certification </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AWS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>考证：AWS SAA-C03</title>
      <link href="/posts/fa4ed4d8.html"/>
      <url>/posts/fa4ed4d8.html</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p>一些我整理的资料:</p><ul><li>官网: <a href="https://aws.amazon.com/certification/certified-solutions-architect-associate/">https://aws.amazon.com/certification/certified-solutions-architect-associate/</a></li><li>网课：<a href="https://www.udemy.com/course/aws-certified-solutions-architect-associate-saa-c03/">https://www.udemy.com/course/aws-certified-solutions-architect-associate-saa-c03/</a></li><li>题库: <a href="https://www.udemy.com/course/practice-exams-aws-certified-solutions-architect-associate/">https://www.udemy.com/course/practice-exams-aws-certified-solutions-architect-associate/</a></li><li>题库: <a href="https://www.examtopics.com/exams/amazon/aws-certified-solutions-architect-associate-saa-c03/">https://www.examtopics.com/exams/amazon/aws-certified-solutions-architect-associate-saa-c03/</a> (前 200 题免费)</li><li>准备时间: 1 月 13 号准备, 中间上课推迟到 2 月 20 号准备, 3 月 29 号考试 (考过, 真的花了我 2 小时 🧠)</li></ul></blockquote><hr><h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><h3 id="1-AWS-Cloud-Overview"><a href="#1-AWS-Cloud-Overview" class="headerlink" title="1. AWS Cloud Overview"></a>1. AWS Cloud Overview</h3><ul><li>Global Services: IAM, Route53, CloudFront, WAF 等等</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img140948.png"></p><h4 id="AWS-Regions"><a href="#AWS-Regions" class="headerlink" title="AWS Regions"></a>AWS Regions</h4><ul><li>A Region is a cluster of data centers </li><li>考虑 Compliance (合规), Proximity (临近用户), Available Services 和 Pricing</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img231130.png"></p><hr><h4 id="AWS-Availability-Zone-AZ"><a href="#AWS-Availability-Zone-AZ" class="headerlink" title="AWS Availability Zone (AZ)"></a>AWS Availability Zone (AZ)</h4><ul><li>一个 Region 可以有 3 - 6 个 AZ (每个 AZ 都是分开的)</li><li>To coordinate Availability Zones across accounts, you must use the AZ ID (注意)<ul><li>A 在 us-west-2a 和 B 在 us-west-2a 是不一样的</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img140727.png"></p><hr><h4 id="AWS-Edge-Locations"><a href="#AWS-Edge-Locations" class="headerlink" title="AWS Edge Locations"></a>AWS Edge Locations</h4><ul><li>Deliver content to user with low latency (离用户越近, deliver 速度越快)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img140903.png"></p><hr><h3 id="2-IAM"><a href="#2-IAM" class="headerlink" title="2. IAM"></a>2. IAM</h3><h4 id="AWS-IAM"><a href="#AWS-IAM" class="headerlink" title="AWS IAM"></a>AWS IAM</h4><ul><li>Root Account: Created by default, 不要和别人分享</li><li>Users: People within the organization</li><li>Groups: Only contain Users, not other Groups (User 可以属于多个 Group)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img145736.png"></p><hr><h4 id="IAM-Permissions"><a href="#IAM-Permissions" class="headerlink" title="IAM Permissions"></a>IAM Permissions</h4><ul><li>定义了 User 或者 Group 的 Permission</li><li>记得遵守 Least Privilege Principle</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img160124.png"></p><hr><h4 id="IAM-Polices"><a href="#IAM-Polices" class="headerlink" title="IAM Polices"></a>IAM Polices</h4><blockquote><p>IAM policies define permissions for an action regardless of the method that you use to perform the operation.</p></blockquote><ul><li>Statements 里面必须包含: Effect, Principal, Action, Resource<ul><li>Inline Policy 是 assign 给个人的</li></ul></li><li>注意, The only resource-based policy IAM support is Trust policy</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img175653.png"></p><hr><h4 id="IAM-MFA"><a href="#IAM-MFA" class="headerlink" title="IAM MFA"></a>IAM MFA</h4><ul><li>Protect Root Accounts and IAM Users</li><li>MFA options: Virtual MFA Device, U2F Sercurity Key (USB)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img180624.png"></p><hr><h4 id="IAM-CLI-amp-SDK"><a href="#IAM-CLI-amp-SDK" class="headerlink" title="IAM CLI &amp; SDK"></a>IAM CLI &amp; SDK</h4><ul><li>可以用 AWS Management Console, AWS CLI, AWS SDK 来访问 AWS</li><li>AWS CLI, AWS SDK 由 Access Keys 保护<ul><li>Set the DeleteOnTermination attribute to False using the command line</li><li>如果考试遇到不会的就选 CLI</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img193342.png"></p><hr><h4 id="IAM-Roles"><a href="#IAM-Roles" class="headerlink" title="IAM Roles"></a>IAM Roles</h4><ul><li>授权 AWS 服务去做某些事 (比如 EB 需要 EC2 Role 和 Service Role)</li><li>常见的 Role: EC2 Instance Role, Lambda Function Role 等等</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img203306.png"></p><hr><h4 id="IAM-Security-Tools"><a href="#IAM-Security-Tools" class="headerlink" title="IAM Security Tools"></a>IAM Security Tools</h4><ul><li>IAM Credentials Report: 返回用户数据和他们的 credentials (凭据)</li><li>IAM Access Advisor: 显示当前用户被授权的服务和使用时间</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img203553.png"></p><hr><h4 id="IAM-Extra"><a href="#IAM-Extra" class="headerlink" title="IAM Extra"></a>IAM Extra</h4><ul><li>Trust Policy (唯一的 resource-based policy)<ul><li>Trust policies define which principal entities can assume the role.</li></ul></li><li>AWS Organizations Service Control Policies (SCP, 针对 Organization 的)<ul><li>SCPs are JSON policies that specify the maximum permissions for an organization or organizational unit (OU)</li></ul></li><li>Access Control List (ACL, 管理别人的 account 的)<ul><li>Access control lists (ACLs) are service policies that allow you to control which principals in another account can access a resource</li></ul></li><li>Permissions Boundary (管理一个 account 最多有什么权限)<ul><li>A permissions boundary is an advanced feature for using a managed policy to set the maximum permissions that an identity-based policy can grant to an IAM entity.</li></ul></li></ul><hr><h3 id="3-EC2-Fundamentals"><a href="#3-EC2-Fundamentals" class="headerlink" title="3. EC2 Fundamentals"></a>3. EC2 Fundamentals</h3><h4 id="AWS-EC2"><a href="#AWS-EC2" class="headerlink" title="AWS EC2"></a>AWS EC2</h4><ul><li>属于 Infrastructure as Service (IaaS) , 绑定 AZ</li><li>User Data: EC2 启动的时候运行的代码 (比如往 EC2 Instance 里面装 Appache)<ul><li>By default, user data runs only during boot cycle when first lauch instance</li><li>By default, scripts entered as user data are executed with root user privileges</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img214749.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img214956.png"></p><ul><li>SSH 到 EC2 Instance 的 public IP (记住, 169, meta-data)<ul><li><a href="http://169.254.169.254/latest/meta-data/public-ipv4">http://169.254.169.254/latest/meta-data/public-ipv4</a></li></ul></li></ul><hr><h4 id="EC2-Instance-Type"><a href="#EC2-Instance-Type" class="headerlink" title="EC2 Instance Type"></a>EC2 Instance Type</h4><ul><li>一共 7 种 EC2 Instance Type, 但 4 种用的最多<ul><li>General Purpose, Compute Optimized, Memory Optimized, Storage Optimized</li></ul></li><li>General Purpose: Balanced (平衡的)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img221846.png"></p><ul><li>Compute Optimized: High performance (处理 Batch, 视频和 HPC)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img221936.png"></p><ul><li>Memory Optimized: Process data in memory (处理 In memory database, cache)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img222020.png"></p><ul><li>Storage Optimized: Read and write data on local storage (OLTP)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img222129.png"></p><hr><h4 id="EC2-Security-Groups"><a href="#EC2-Security-Groups" class="headerlink" title="EC2 Security Groups"></a>EC2 Security Groups</h4><ul><li>Control how traffic is allowed into or out of EC2 instance (类似防火墙)<ul><li>Can be attached to multiple instances (可以复用)</li><li>Locked down to Region &#x2F; VPC</li></ul></li><li>可以作为 Security Group 的 Inbound Rule 有<ul><li>IP address, CIDR block, Security Group</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img222531.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img223020.png"></p><hr><h4 id="EC2-Instance-Purchasing-Options"><a href="#EC2-Instance-Purchasing-Options" class="headerlink" title="EC2 Instance Purchasing Options"></a>EC2 Instance Purchasing Options</h4><ul><li>On-Demand Intances: Short workload, pay by second (短期内紧急使用)</li><li>Reserved: 1 - 3 years (72% discount, reserve capacity in an AZ)<ul><li>Reserved Instance: Long workload (1 - 3 年, discount 随年份增加)</li><li>Convertible Reserved Instances (RI): Long workload with flexible instance (66% discount, 但是可以自由改变 Instance Type)</li></ul></li><li>Saving Plans: 1 - 3 years, commitment to an amount of usage (72% discount, 要定一个使用上限, 超过上限就变成 On-Demand)<ul><li>还有 Compute Saving Plan, 66% discount, work with Lambda and Fargate</li></ul></li><li>Spot Instance: Short workload, can lose instance (最便宜, 90% discount)</li><li>Dedicated Host: The physical server is yours (最贵, 可以控制 how Instance placed)</li><li>Dedicated Instance: Run hardware, but not lockdown to you (服务器大部分是你的)</li><li>Capacity Reservation: Reserve capacity in AZ (比如一天中只有几个小时需要 EC2)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img224149.png"></p><hr><h4 id="EC2-Spot-Instance"><a href="#EC2-Spot-Instance" class="headerlink" title="EC2 Spot Instance"></a>EC2 Spot Instance</h4><ul><li>只能在 open, active 或者 disabled 的状态下 cancel Spot Instance</li><li>需要先 cancel Spot Instance, 然后再 terminate (Cancel 不代表 Terminate)</li><li>Spot Instance 有 one-time 和 persistent 两种 request type</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img225943.png"></p><ul><li>Spot Fleets: Automatically request Spot Instance with lowest price (Spot + On-Demand)<ul><li>拿到最便宜的 Spot Instances</li></ul></li><li>Spot Fleets are set to maintain target capacity (可以保证一定数量的 Instance)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img230258.png"></p><hr><h3 id="4-EC2-SAA-Level"><a href="#4-EC2-SAA-Level" class="headerlink" title="4. EC2 SAA Level"></a>4. EC2 SAA Level</h3><h4 id="Elastic-IP"><a href="#Elastic-IP" class="headerlink" title="Elastic IP"></a>Elastic IP</h4><ul><li>Public IP: Unique across the whole web</li><li>Private IP: Unique across the private network</li><li>Elastic IP: Fixed Public IP for EC2 instance (不会改变)<ul><li>为什么要 Elastic IP, 因为 EC2 的 Public IP 会在重启后改变</li><li>而且 Elastic IP 可以节省 EC2 的开支, Private IP 也可以 (在 private internet 条件下)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img165706.png"></p><hr><h4 id="EC2-Placement-Groups"><a href="#EC2-Placement-Groups" class="headerlink" title="EC2 Placement Groups"></a>EC2 Placement Groups</h4><ul><li>Cluster: Low-latency, single AZ, 网速快但 AZ 可能 fail (处理 HPC)</li><li>Spread: High availability, critical application, 风险小但有限制, 每个 AZ 最多 7 个实例<ul><li>处理 small number of critical instances that need seperate from each other</li></ul></li><li>Partition: Partition instances across many partitions within an AZ, 7 partitions per AZ, up to 100 instances, span multiple region (Big Data, 风险小, 限制低)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img170342.png"></p><ul><li>Cluster: Low-latency, single AZ, 网速快但 AZ 可能 fail (适合 HPC)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img170525.png"></p><ul><li>Spread: High availability, critical application, 风险小但有限制, 每个 AZ 最多 7 个实例</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img170652.png"></p><ul><li>Partition: Spreads instances across many partitions within an AZ, 7 partitions per AZ, up to 100 instances, span multiple region (Big Data, 风险小, 限制低)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img170936.png"></p><hr><h4 id="Elatic-Network-Interfaces-ENI"><a href="#Elatic-Network-Interfaces-ENI" class="headerlink" title="Elatic Network Interfaces (ENI)"></a>Elatic Network Interfaces (ENI)</h4><ul><li>Virtual network card in a VPC</li><li>处理 EC2 Instance failover (故障转移), 绑定 AZ (不可以 attach 到其他 AZ 上)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img182407.png"></p><hr><h4 id="EC2-Hibernate"><a href="#EC2-Hibernate" class="headerlink" title="EC2 Hibernate"></a>EC2 Hibernate</h4><ul><li>EC2 Hibernate: Make EC2 instance boot faster (不是 stoped, 而是 hibernated)</li><li>EC2 Instance Root Volume type must be an EBS volume</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img183846.png"></p><hr><h3 id="5-EC2-Instance-Storage"><a href="#5-EC2-Instance-Storage" class="headerlink" title="5. EC2 Instance Storage"></a>5. EC2 Instance Storage</h3><h4 id="AWS-EBS"><a href="#AWS-EBS" class="headerlink" title="AWS EBS"></a>AWS EBS</h4><ul><li>Block-level storage, 类似 network drive, 绑定 AZ, provisioned capacity<ul><li>By default, Root Volume will be deleted on termination (重要)</li><li>By default, other EBS volume will not be deleted on termination (重要)</li></ul></li><li>可以从一个 EC2 Instance 取下来装到另一个上</li><li>EBS 是绑定 AZ 的 (重要)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img191440.png"></p><hr><h4 id="EBS-Snapshots"><a href="#EBS-Snapshots" class="headerlink" title="EBS Snapshots"></a>EBS Snapshots</h4><ul><li>Make a backup of EBS volume (备份 EBS)</li><li>可以将这个 snapshot 用在其他 AZ 或者 Region 上</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img195715.png"></p><ul><li>EBS Snapchot Archive: 便宜 75%</li><li>Recycle Bin: Setup rules to retain deleted snapshots (可以 recover)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img195833.png"></p><hr><h4 id="AWS-AMI"><a href="#AWS-AMI" class="headerlink" title="AWS AMI"></a>AWS AMI</h4><ul><li>AMI: Amazon Machine Image (Customization of an EC2 Instance)<ul><li>可以更好的管理和启动 EC2 Instance</li></ul></li><li>Built for a specific region and can copy across regions (AMI 跨域复制)</li></ul><blockquote><p>When the new AMI is copied from Region A into Region B, it automatically creates a snapshot in Region B (注意, 跨域 copy AMI 会产生 snapshot)</p></blockquote><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img200249.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img200341.png"></p><hr><h4 id="EC2-Instance-Store"><a href="#EC2-Instance-Store" class="headerlink" title="EC2 Instance Store"></a>EC2 Instance Store</h4><ul><li>Block-level storage, 物理硬盘 (Physical drive, temporary storage)</li><li>High random I&#x2F;O performance, good for cache &amp; buffer at low cost (重要)</li><li>EC2 Instance Store lose when stopped (Ephemeral, 数据在 Instance Store 关闭时消失)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img203146.png"></p><ul><li>You can’t detach an Instance Store volume from one instance and attach it to a different instance</li><li>If you create an Amazon Machine Image (AMI) from an instance, the data on its instance store volumes isn’t preserved</li></ul><hr><h4 id="EBS-Volume-Types"><a href="#EBS-Volume-Types" class="headerlink" title="EBS Volume Types"></a>EBS Volume Types</h4><ul><li>General Purpose (gp2 &#x2F; gp3): Balanced, cost-effective</li><li>Provisioned IOPS (io1 &#x2F; io2): High-performance, support Multi-Attach<ul><li>记住, io 的比 gp 的贵, 但是 io 的 IOPS 也比 gp 高</li></ul></li><li>Hard Disk Drives (HDD): Data intensive (st1) 或者 less frequent access (sc1)<ul><li>HDD 不可以用来创建 EC2</li></ul></li><li>上面这些都没有超过 300,000 IOPS</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img203437.png"></p><hr><h4 id="EBS-Multi-Attach"><a href="#EBS-Multi-Attach" class="headerlink" title="EBS Multi-Attach"></a>EBS Multi-Attach</h4><ul><li>Attach same EBS volume to multiple EC2 instance in same AZ (记住是相同的 AZ)</li><li>Only for io1 &#x2F; io2 family (Provisioned IOPS SSD, 重要)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img203956.png"></p><hr><h4 id="EBS-Encryption"><a href="#EBS-Encryption" class="headerlink" title="EBS Encryption"></a>EBS Encryption</h4><ul><li>EBS Encryption (所有环节都是 encrypted 的)<ul><li>Data at rest is encrypted &amp; Data in flight is encrypted &amp; Snapshot is encrypted</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img204137.png"></p><ul><li>首先 create snapshot, 然后 encrypt snapshot, 然后创建一个新的 EBS Volume (从 encrypted snapshot),  然后将这个 volume 加入到原来的 Instance 上</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img204208.png"></p><hr><h4 id="EBS-RAID"><a href="#EBS-RAID" class="headerlink" title="EBS RAID"></a>EBS RAID</h4><ul><li>RAID 0 (看重 I&#x2F;O performance)<ul><li>Use RAID 0 when I&#x2F;O performance is more important than fault tolerance</li></ul></li><li>RAID 1 (看重 falut tolerance)<ul><li>Use RAID 1 when fault tolerance is more important than I&#x2F;O performance</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/imgpt6-q37-i1.jpg"></p><hr><h4 id="AWS-EFS"><a href="#AWS-EFS" class="headerlink" title="AWS EFS"></a>AWS EFS</h4><ul><li>NFS (Network file system), 可以 mount 到多个 EC2 Instance<ul><li>Scale automatically, no capacity planning</li></ul></li><li>EC2 Instances can access files on an EFS file system across AZs, Regions and VPCs<ul><li>重要, 可以从不同的 AZ, Region, VPC 来 access</li></ul></li><li>可以用 VPC Security Group 或者 IAM Policy 来 control access to EFS</li><li>EFS Infrequent Access (如果遇到 POSIX compliant file storage)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img233415.png"></p><ul><li>NFS 有 2 种 Performance Mode<ul><li>General Purpose: Default (web server)</li><li>Max I&#x2F;O: High latency, throughput, parallel (Big Data, media process, 重要)</li></ul></li><li>NFS 有 3 种 Throughput Mode (重要)<ul><li>Bursting: 很快</li><li>Provisioned: 设置上限 (high throughput, 处理大量文件 migrate 时候使用)</li><li>Elastic: 根据 workload 来 scale</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img233732.png"></p><blockquote><p>EFS 适合存储大型文件, 从价格的角度来看, 存 100 GB 的文件, EBS &gt; EFS &gt; S3 (价格)<br>EFS 并不是永远最贵的, 但 S3 永远是最便宜的</p></blockquote><hr><h3 id="6-ELB-amp-ASG"><a href="#6-ELB-amp-ASG" class="headerlink" title="6. ELB &amp; ASG"></a>6. ELB &amp; ASG</h3><h4 id="Scalability-amp-High-Availability"><a href="#Scalability-amp-High-Availability" class="headerlink" title="Scalability &amp; High Availability"></a>Scalability &amp; High Availability</h4><ul><li>Vertical (竖直) Scale: Increase the size of the Instance (但是有 hardware limit)</li><li>Horizontal (水平) Scale: Increase the number of the Instance</li><li>High Availability: Rrunning application in at least 2 AZ (Disaster recovery, DR, 重要)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img080120.png"></p><hr><h4 id="AWS-ELB"><a href="#AWS-ELB" class="headerlink" title="AWS ELB"></a>AWS ELB</h4><ul><li>Foward traffic to multiple EC2 Instances (流量控制)<ul><li>High Availability across AZs, handle failures of downstream instances</li></ul></li><li>Health Check: 可以知道 EC2 Instance 是否是 Healthy 的<ul><li>ASG 是用 EC2 based health check, ALB 用的是 ALB based health check</li><li>ELB 应该在 public subnet, ASG 应该在 private subnet (重要)</li></ul></li><li>ELB cannot distribute traffic for targets deployed in different region</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img141400.png"></p><ul><li>Application Load Balancer (HTTP &#x2F; HTTPS, Layer 7)</li><li>Network Load Balancer (TCP &#x2F; UDP, Layer 4)<ul><li>NLB provide static DNS and static IP, ALB only provide static DNS</li></ul></li><li>Gateway Load Balancer (Security, Layer 3, 要特别注意)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img090125.png"></p><hr><h4 id="Application-Load-Balancer-ALB"><a href="#Application-Load-Balancer-ALB" class="headerlink" title="Application Load Balancer (ALB)"></a>Application Load Balancer (ALB)</h4><ul><li>Deal with Layer 7 (HTTP &#x2F; HTTPS)</li><li>Route base on Path (&#x2F;Home) or Query (?Platform&#x3D;Mobile)</li><li>ALB adds an additional header called “X-Forwarded-For” contains the client’s IP</li><li>可以 configure ALB to redirect HTTP to HTTPS (重要)</li><li>ALB 无法被 assign Elstaic IP</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img192523.png"></p><ul><li>Routing tables to different target groups<ul><li>Route based on path in URL</li><li>Route based on hostname in URL</li><li>Route based on Query String, Headers, Client IP</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img142631.png"></p><ul><li>ALB Target Groups:<ul><li>EC2 Instance, ECS, Lambda, IP Address</li></ul></li></ul><blockquote><p>To forward all requests to the website so that the requests will use HTTPS, a solutions architect can create a listener rule on the ALB that redirects HTTP traffic to HTTPS. </p></blockquote><hr><h4 id="Network-Load-Balancer-NLB"><a href="#Network-Load-Balancer-NLB" class="headerlink" title="Network Load Balancer (NLB)"></a>Network Load Balancer (NLB)</h4><ul><li>Deal with Layer 4 (TCP &#x2F; UDP), 很快, 处理有大量 request 的情况</li><li>One static IP per AZ or use Elastic IP</li><li>NLB supports HTTP health checks as well as TCP and HTTPS</li><li>注意, NLB best suited for use-cases involving low latency and high throughput workloads, 比如银行, 游戏</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img144359.png"></p><blockquote><p>If you specify targets using an instance ID, traffic is routed to instances using the primary private IP address specified in the primary network interface for the instance.</p></blockquote><hr><h4 id="Gateway-Load-Balancer-GWLB"><a href="#Gateway-Load-Balancer-GWLB" class="headerlink" title="Gateway Load Balancer (GWLB)"></a>Gateway Load Balancer (GWLB)</h4><ul><li>Deal with Layer 3 (Security, 3rd Party)</li><li>GWLB allows perform inline inspection of traffic from multiple spoke VPCs in a simplified and scalable fashion</li><li>Use GENEVE protocol on port 6081</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img223042.png"></p><hr><h4 id="Sticky-Sessions-Session-Affinity"><a href="#Sticky-Sessions-Session-Affinity" class="headerlink" title="Sticky Sessions (Session Affinity)"></a>Sticky Sessions (Session Affinity)</h4><ul><li>Same client is always redirect to the same instance behind a load balancer</li><li>Make sure user doesn’t loss session data (比如用户登录)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img223425.png"></p><ul><li>Application-based Cookies: Don’t use AWSALB, AWSALBAPP, AWSALBTG</li><li>Duration-based Cookies: AWSALB for ALB, AWSELB for CLB</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img223604.png"></p><hr><h4 id="Cross-Zone-Load-Balancing"><a href="#Cross-Zone-Load-Balancing" class="headerlink" title="Cross Zone Load Balancing"></a>Cross Zone Load Balancing</h4><ul><li>ELB distributes traffic evenly across all registered EC2 instances in all AZs<ul><li>所有 Instance 分到的 traffic 一定是一样的</li><li>如果没有 enable, 那么 AZ 内部就是平均分</li></ul></li><li>ALB enabled by default, NLB disabled by default (重要)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img230059.png"></p><hr><h4 id="SSL-Certificates"><a href="#SSL-Certificates" class="headerlink" title="SSL Certificates"></a>SSL Certificates</h4><ul><li>Allow traffic between client and load balancer encrypted in transit (HTTPS)<ul><li>Manage SSL certificates using ACM (AWS Certificate Manager)</li></ul></li><li>如果问到需要管理很多个 SSL 或者 TSL, 选择 SNI (重要)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img230614.png"></p><ul><li>Could be used in ALB &amp; NLB, use SNI to make it work</li><li>SNI: Load multiple SSL certificates onto one web server (Server Name Indication)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img230910.png"></p><hr><h4 id="Connection-Draining"><a href="#Connection-Draining" class="headerlink" title="Connection Draining"></a>Connection Draining</h4><ul><li>Waiting for existing connections to complete</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img231418.png"></p><blockquote><p>Connection Draining enables the load balancer to complete in-flight requests made to instances that are de-registering or unhealthy</p></blockquote><hr><h4 id="AWS-ASG"><a href="#AWS-ASG" class="headerlink" title="AWS ASG"></a>AWS ASG</h4><ul><li>ASG 可以和 ELB 一起用, 来 scale out 或者 in 基于服务器压力 (免费)</li><li>ASG 可以保证最少或最多有多少 EC2 Instance 在工作 (min, max)<ul><li>ASG 是在一个 Region 里面去根据 availiable 的 AZ 进行 scale</li></ul></li><li>当一个 Instance 是 unhealthy 的时候, ASG 会 terminate 这个 Instance<ul><li>ASG 在一个 AZ 里最早 terminate 的是那个最早被 launch 的 Instance</li><li>遇到 unbalanced 的情况, ASG 是先 launch new instance 然后 terminate old instance</li><li>但是在 unhealthy 的情况下是先 terminate unhealth Instance 然后 create new</li></ul></li><li>如果问到在某个节日前去 scale, 那就是 ASG scheduled action</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img232350.png"></p><ul><li>可以和 ELB 一起用, 来 scale out 或者 in 基于服务器压力</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img232615.png"></p><ul><li>Launch Template: 可以作为 template 来生成 EC2 Instance<ul><li>Launch Template 是管要生成什么 Instance 的 (eg. Spot, On-Demand)</li><li>Launch Configuration 是管生成的 Instance 的信息的 (eg. AMI, security group)</li></ul></li><li>如果要更新 Launch Template, 需要删掉旧的然后使用新的 (注意)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img232823.png"></p><ul><li>可以和 CloudWatch Alarm 一起根据服务器压力 scale out 或 scale in</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img232959.png"></p><ul><li>ASG 不 terminate Instance 的情况<ul><li>The health check grace period for the instance has not expired</li><li>The instance maybe in Impaired status</li><li>The instance has failed the Elastic Load Balancing (ELB) health check status</li></ul></li></ul><hr><h4 id="Scaling-Policies"><a href="#Scaling-Policies" class="headerlink" title="Scaling Policies"></a>Scaling Policies</h4><ul><li>Dynamic Scaling<ul><li>Target Tracking Scaling: 根据 CPU 用量或者 SQS 长度来 scale</li><li>Simple &#x2F; Step Scaling: 和 CloudWatch Alarm 关联</li><li>Scheduled Actions: 比如在感恩节那天进行 scale</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img233532.png"></p><ul><li>Predictive Scaling<ul><li>Forecast load and schedule scaling ahead</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img233711.png"></p><hr><h3 id="7-AWS-Fundamentals"><a href="#7-AWS-Fundamentals" class="headerlink" title="7. AWS Fundamentals"></a>7. AWS Fundamentals</h3><h4 id="AWS-RDS"><a href="#AWS-RDS" class="headerlink" title="AWS RDS"></a>AWS RDS</h4><ul><li>使用 RDS 的好处 (对比将数据库存在 EC2 上)<ul><li>Automated provisioning, auto-scaling, backup</li><li>Read Replicas (最多 15 个) 和 Multi-AZ</li></ul></li><li>RDS RIs: 类似 EC2 RIs</li><li>RDS Read Replica: If master database is encrypted, the replica is also encrypted<ul><li>注意, Read Replica 提高的是 read, 而不是 scale 数据库的 storage (而且 Replica 贵), 处理类似 report 或者 analytics 的就是 Read Replica</li><li>Read Replica 不是提高 High Availability, Multi-AZ 才是</li><li>Cross-Region Read Replica: 当 disaster 发生, 可以作为 DB backup</li></ul></li><li>RDS Multi-AZ: RDS create a primary DB Instance and synchronously replicates the data to a standby instance in a different AZ (High Availability)<ul><li>RDS Multi-AZ update 是 standby 和 primary 一起 update (会有 downtime)</li></ul></li><li>Support MySQL, PostgreSQL, MariaDB, Oracle, MS SQL Server, and Amazon Aurora</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img161720.png"></p><ul><li>Storage Auto Scaling (自动 scale)<ul><li>For application with unpredictable workloads</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img161952.png"></p><ul><li>Disaster Recovery<ul><li>Create a Read Replica in different region and enable Multi-AZ on Read Replica</li></ul></li><li>IAM Database Authentication: 可以用来访问 RDS</li><li>可以从 RDS Read Replica 迁移到 Aurora Read Replica, 这个做法可以 minimal change</li></ul><hr><h4 id="Read-Replicas-vs-Multi-AZ"><a href="#Read-Replicas-vs-Multi-AZ" class="headerlink" title="Read Replicas vs. Multi AZ"></a>Read Replicas vs. Multi AZ</h4><ul><li>Read Replicas: Scalability, Async Replication<ul><li>Within AZ, Cross AZ or Cross Region</li></ul></li><li>Read Replicas in Same Region is free (Replication in AZs), Cross Region is not free</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img173522.png"></p><ul><li>用 Production databse 处理日常, 用 Read Replica 来建一个副本处理数据分析</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img173820.png"></p><ul><li>Multi AZ: High Availability, Disaster Recovery, Sync Replication<ul><li>在 Multi-AZ 的情况下, 当 RDS 数据库 goes down, CNAME 会更新指向 standby</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img174148.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img174357.png"></p><hr><h4 id="RDS-Custom"><a href="#RDS-Custom" class="headerlink" title="RDS Custom"></a>RDS Custom</h4><ul><li>Could access the underlying database and OS <ul><li>只有 Oracle 和 Microsoft SQL Server 可以</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img174702.png"></p><hr><h4 id="AWS-Aurora"><a href="#AWS-Aurora" class="headerlink" title="AWS Aurora"></a>AWS Aurora</h4><ul><li>Support PostgreSQL and MySQL (不需要管理 storage)</li><li>Aurora 没有 standby database, Aurora Replica 可以作为 failover target</li><li>一般来说, Aurora 比 RDS 快</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img183915.png"></p><ul><li>High Availiability &amp; Read Scaling (Aurora Read Replica)<ul><li>One Master Write, Multiple Read Replicas (Up to 15 Replica), 一共 16 个</li><li>如果问到和 Aurora 有关, 且关于处理网络请求激增的问题, 选 Aurora Replica</li><li>Replica Tier 越高, failover 时被 promote</li></ul></li><li>如果问到关于 Aurora 的 Auto-Scaling, 那就是 Aurora Serverless</li><li>如果问到 Aurora 而且是 test database, 选择 Aurora Database Cloning</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img184105.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img184221.png"></p><hr><h4 id="Aurora-Advanced"><a href="#Aurora-Advanced" class="headerlink" title="Aurora Advanced"></a>Aurora Advanced</h4><ul><li>Aurora Replicas Auto Scaling: 和 EC2 的 Auto Scaling 类似</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img184516.png"></p><ul><li>Aurora Custom Endpoints: 可以在上面跑数据分析</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img184559.png"></p><ul><li>Aurora Serverless: Automated database instantiation and auto scaling (重要)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img184700.png"></p><ul><li>Aurora Global: Cross Region replication takes less than 1 second <ul><li>同时保证至少有一个 Replica 可以用 (重要)</li><li>Designed for globally distributed application, with fast local reads with low latency</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img184847.png"></p><ul><li>Aurora Machine Learning: ML prediction</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img184942.png"></p><ul><li>Aurora Database Cloning<ul><li>可以快速 access Aurora DB, 比 snapshot &amp; retore 快</li><li>当需要制作 test database 的时候选 Aurora Database Cloning</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img185556.png"></p><hr><h4 id="Backup-amp-Monitoring"><a href="#Backup-amp-Monitoring" class="headerlink" title="Backup &amp; Monitoring"></a>Backup &amp; Monitoring</h4><ul><li>RDS Backups (有两种)<ul><li>Automated backups: 每天自动 backup</li><li>Manual DB Snapshots: 手动 backup</li></ul></li><li>注意, 如果是为了省钱, 可以在用完数据库后制作数据库 snapshot, 然后 terminate 数据库, 在需要的时候再把数据库 snapshot restore 回去</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img185223.png"></p><ul><li>Aurora Backups (和上面一样)<ul><li>Automated backups: 每天自动 backup</li><li>Manual DB Snapshots: 手动 backup</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img185353.png"></p><ul><li>RDS &amp; Aurora Restore options<ul><li>最基本的就是用 snapshot 来 restore</li><li>如果是从 On-Premise, 可以做一个 backup 然后存到 S3, 再从 S3 来 restore</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img185459.png"></p><hr><h4 id="RDS-Security"><a href="#RDS-Security" class="headerlink" title="RDS Security"></a>RDS Security</h4><ul><li>At-rest encryption: AWS KMS (Key Management Service)</li><li>In-flight encryption: AWS TLS Certificates</li><li>IAM Authentication: IAM roles to connect to database</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img133048.png"></p><hr><h4 id="RDS-Proxy"><a href="#RDS-Proxy" class="headerlink" title="RDS Proxy"></a>RDS Proxy</h4><ul><li>Have a proxy for access RDS or Aurora, 缓解数据库压力, minimize open connections<ul><li>Allow apps to pool and share DB connections (提高 DB efficiency)</li><li>Reduced RDS &amp; Aurora failover time by up 66%</li><li>No code change (重要)</li></ul></li><li>Serverless, auto scaling, Highly Avaliable (Multi-AZ)</li><li>Not publicly accessible (Need to use VPC)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img184531.png"></p><hr><h4 id="AWS-ElastiCache"><a href="#AWS-ElastiCache" class="headerlink" title="AWS ElastiCache"></a>AWS ElastiCache</h4><ul><li>Manage Redis or Memcached (ElastiCache 解决的是数据库高频读取的问题, 重要)<ul><li>ElastiCache 也是 in-memory data store, 而且支持 SQL query caching</li></ul></li><li>Cache are in-memory database with high performance and low latency (compute-intensive)</li><li>Cache helps reduce load off of database for read intensive workload (read heavy)</li><li>Help to make application stateless (AWS 负责大部分工作)</li><li>处理 S3 的是 CloudFront, 而不是 ElastiCache (记住)</li><li>支持 multi-threading 的是 ElastiCache for Memcached</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img184841.png"></p><ul><li>DB Cache: Get data from ElastiCache<ul><li>If not avaliable, get from RDS and store in ElastiCache</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img185024.png"></p><ul><li>User Session: Write Session data into ElastiCache<ul><li>User in another instance could still be logged in</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img185153.png"></p><ul><li>Redis vs Memcahed<ul><li>Redis: Read Replicas, High Availiablity, Backup and restore (非常重要)</li><li>Memcached: Not High Availiablity, No Backup, Have Risk to Lose Data, Multi-threaded</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img185310.png"></p><hr><h4 id="ElastiCache-SAA"><a href="#ElastiCache-SAA" class="headerlink" title="ElastiCache SAA"></a>ElastiCache SAA</h4><ul><li>ElastiCache supports IAM Authentication for Redis</li><li>Memcached supports SASL-based authentication</li><li>IAM Database Authentication does not support Oracle</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img200638.png"></p><ul><li>Patterns for ElastiCache<ul><li>Lazy Loading, Write Through, Session Store</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img200822.png"></p><ul><li>ElastiCache Use Case<ul><li>Gaming Leaderboards (用 Redis 的 Sorted Sets, 重要)</li><li>Manage and store session data</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img200907.png"></p><hr><h3 id="8-Route-53"><a href="#8-Route-53" class="headerlink" title="8. Route 53"></a>8. Route 53</h3><h4 id="What’s-DNS"><a href="#What’s-DNS" class="headerlink" title="What’s DNS"></a>What’s DNS</h4><ul><li>Translate hostname into IP address<ul><li><a href="http://www.google.com/">www.google.com</a> &#x3D; 172.217.18.36</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img213136.png"></p><hr><h4 id="AWS-Route-53"><a href="#AWS-Route-53" class="headerlink" title="AWS Route 53"></a>AWS Route 53</h4><ul><li>User can update the DNS records (High available, scalable)</li><li>Route 53 is a Domain Registrar</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img213527.png"></p><ul><li>Route 53 Records:<ul><li>Domain Name, Record Type, Value, Routing Policy, TTL</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img213613.png"></p><ul><li>Route 53 Record Types<ul><li>A: IPv4</li><li>AAAA: IPv6</li><li>CNAME: Map hostname to another hostname</li><li>NS: Name Servers for the Hosted Zone</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img213753.png"></p><ul><li>Route 53: Hosted Zones<ul><li>Public Hosted Zones: Public domain name</li><li>Private Hosted Zones: Private domain name (VPC)</li></ul></li></ul><blockquote><p>注意, DNS hostnames and DNS resolution are required settings for private hosted zones</p></blockquote><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img234126.png"></p><ul><li>GoDaddy + Route 53 (As DNS Service Provider)<ul><li>Create a Public Hosted Zone and update the 3rd party Registrar NS records</li></ul></li><li>Route 53 Health Check<ul><li>如果 ELB 出问题, 就去找 Route 53 Health Check</li></ul></li></ul><hr><h4 id="Route-53-TTL"><a href="#Route-53-TTL" class="headerlink" title="Route 53 TTL"></a>Route 53 TTL</h4><ul><li>TTL: Time To Live (生存时间)<ul><li>How long the value should be cached (后端更新不代表 cache 更新了)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img232659.png"></p><hr><h4 id="CNAME-vs-Alias"><a href="#CNAME-vs-Alias" class="headerlink" title="CNAME vs Alias"></a>CNAME vs Alias</h4><ul><li>CNAME: Point a hostname to another hostname<ul><li>从 acme.example.com 到 zenith.example.org 或者 example.com 到 example.net</li></ul></li><li>Alias: Point a hostname to an AWS Resource (对象是 CloudFront, S3 这些)<ul><li>从 covid19survey.com 到 <a href="http://www.covid19survey.com/">www.covid19survey.com</a></li><li>从 app.mydomain.com 到 app.amazonaws.com</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img233313.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img233425.png"></p><hr><h4 id="Health-Checks"><a href="#Health-Checks" class="headerlink" title="Health Checks"></a>Health Checks</h4><ul><li>Health Checks are only for public resources</li><li>Health Check 检测: Endpoints, 其他 Health Checks, CloudWatch Alarms</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img000106.png"></p><hr><h4 id="Routing-Policy-Simple"><a href="#Routing-Policy-Simple" class="headerlink" title="Routing Policy (Simple)"></a>Routing Policy (Simple)</h4><ul><li>Define how Route 53 responds to DNS queries</li><li>一共 7 种 Routing Policies</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img234623.png"></p><ul><li>Simple: Route traffic to a single resource<ul><li>If multiple values returned, a random one is chosen by client</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img234350.png"></p><hr><h4 id="Routing-Policy-Weighted"><a href="#Routing-Policy-Weighted" class="headerlink" title="Routing Policy (Weighted)"></a>Routing Policy (Weighted)</h4><ul><li>Weighted: Control the % of the request go to each resource</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img234856.png"></p><hr><h4 id="Routing-Policy-Latency"><a href="#Routing-Policy-Latency" class="headerlink" title="Routing Policy (Latency)"></a>Routing Policy (Latency)</h4><ul><li>Latency: Redirect to the resource that has the least latency close to us</li><li>Latency is based on traffic between users and AWS Regions</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img235654.png"></p><hr><h4 id="Routing-Policy-Failover"><a href="#Routing-Policy-Failover" class="headerlink" title="Routing Policy (Failover)"></a>Routing Policy (Failover)</h4><ul><li>Failover: Have a Primary Instance and a Secondary Instance (重要)<ul><li>When failover, switch to Secondary Instance</li></ul></li><li>注意, 当问到 failover 的时候, 选择的是 active-passive failover routing policy<ul><li>没有什么 active-active, 只有 active-passive</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img150940.png"></p><hr><h4 id="Routing-Policy-Geolocation"><a href="#Routing-Policy-Geolocation" class="headerlink" title="Routing Policy (Geolocation)"></a>Routing Policy (Geolocation)</h4><ul><li>Geolocation: Routing based on user location<ul><li>Need to create a “Default” record</li><li>Use cases: website localization, restrict content distribution 等等</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img151650.png"></p><hr><h4 id="Routing-Policy-Geoproximity"><a href="#Routing-Policy-Geoproximity" class="headerlink" title="Routing Policy (Geoproximity)"></a>Routing Policy (Geoproximity)</h4><ul><li>Geoproximity: Route traffic to resource based on geolocation<ul><li>But have the ability to shift more traffic to resource based on bias (重要)</li><li>可以做到 route more traffic or less</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img152310.png"></p><hr><h4 id="Routing-Policy-IP-Based"><a href="#Routing-Policy-IP-Based" class="headerlink" title="Routing Policy (IP-Based)"></a>Routing Policy (IP-Based)</h4><ul><li>IP-Based: Routing based on client’s IP address<ul><li>Provide a list of CIDRs for your client</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img153711.png"></p><hr><h4 id="Routing-Policy-Multi-Value"><a href="#Routing-Policy-Multi-Value" class="headerlink" title="Routing Policy (Multi-Value)"></a>Routing Policy (Multi-Value)</h4><ul><li>Multi-Value: Route traffic to multiple resources<ul><li>Not a subsitute for ELB</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img153842.png"></p><hr><h3 id="9-Beanstalk"><a href="#9-Beanstalk" class="headerlink" title="9. Beanstalk"></a>9. Beanstalk</h3><h4 id="Instantiate-App"><a href="#Instantiate-App" class="headerlink" title="Instantiate App"></a>Instantiate App</h4><ul><li>EC2 Instance<ul><li>Golden AMI: Install all applications beforehand and launch EC2 Instance</li><li>User Data: Dynamic configuration (记住是 dynamic)</li></ul></li><li>RDS Database: Restore from a snapshot (Data &amp; Schema ready)</li><li>EBS Volume: Restore from a snapshot</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img173401.png"></p><hr><h4 id="Elastic-Beanstalk"><a href="#Elastic-Beanstalk" class="headerlink" title="Elastic Beanstalk"></a>Elastic Beanstalk</h4><ul><li>只需要负责 Code, 其他都由 AWS 负责</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img210323.png"></p><ul><li>Web Server Tier vs. Worker Tier<ul><li>一个管 Web Server, 另一个处理 Process (SQS, SNS 等等)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img210711.png"></p><hr><h3 id="10-AWS-S3"><a href="#10-AWS-S3" class="headerlink" title="10. AWS S3"></a>10. AWS S3</h3><h4 id="AWS-S3"><a href="#AWS-S3" class="headerlink" title="AWS S3"></a>AWS S3</h4><ul><li>S3 Buckets (S3 是 Global 的, 但是 Bucket 是 Regional 的)<ul><li>Store objects (files) in “buckets”</li><li>Buckets must have globally unique name (名字必须独特)</li><li>Buckets are defined at region level</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img171839.png"></p><ul><li>Objects (files) have a key, max object size is 5TB</li><li>The key is the FULL path (prefix + object name)</li><li>如果上传超过 5 GB, 就要用 Multi-Part Upload (还有 S3 Transfer Acceleration)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img172025.png"></p><ul><li>S3 sync command: Uses the CopyObject APIs to copy objects between S3 buckets</li><li>S3 always return the lastest version of the object (重要)</li><li>S3 没办法加密 metadata</li><li>S3 是 serverless 的</li><li>如果遇到需要处理 static content 的, 就一定是 S3 + CloudFront (重要)</li><li>如果问到 S3 而且是关于图片上传, 选择 S3 Event Notification, 不是 EventBridge (重要)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/imglifecycle-transitions-v2.png"></p><ul><li>如果发现 S3 的传输功能出问题, 那么就给 S3 bucket 加上 prefix</li><li>注意, S3 和 Database 是不沾边的, S3 不是数据库</li></ul><blockquote><p>By default, an Amazon S3 object is owned by the AWS account that uploaded it. This is true even when the bucket is owned by another account (重要)</p></blockquote><ul><li>Host 在 S3 上面的网站一般是以下两种后缀 (dash Region 或者 dot Region)<ul><li>s3-website dash (-) Region ‐ <a href="http://bucket-name.s3-website.region.amazonaws.com/">http://bucket-name.s3-website.Region.amazonaws.com</a></li><li>s3-website dot (.) Region ‐ <a href="http://bucket-name.s3-website-region.amazonaws.com/">http://bucket-name.s3-website-Region.amazonaws.com</a></li></ul></li></ul><hr><h4 id="S3-Bucket-Policy"><a href="#S3-Bucket-Policy" class="headerlink" title="S3 Bucket Policy"></a>S3 Bucket Policy</h4><ul><li>User-Based Security<ul><li>IAM Policies: Which API calls should be allowed for a user from IAM (重要)</li></ul></li><li>Resource-Based Security<ul><li>Bucket Policies: Bucket rules (比如让 Object public, 重要)</li><li>Object Access Control List (ACL)</li><li>Bucket Access Control List (ACL)</li></ul></li><li>Encryption: Encrypt objects in S3 with encryption keys</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img173050.png"></p><ul><li>S3 Bucket Policies (JSON based policies)<ul><li>Resoruces: buckets and objects</li><li>Effect: Allow &#x2F; Deny</li><li>Actions: API to Allow or Deny</li><li>Principal: The account or user to apply the policy to</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img173325.png"></p><hr><h4 id="S3-Versioning"><a href="#S3-Versioning" class="headerlink" title="S3 Versioning"></a>S3 Versioning</h4><ul><li>Enabled at the bucket level (Default is null)</li><li>Best pratice to version the buckets (可以 roll back, 可以防止误删, 重要)<ul><li>可以防止 accidental deletion of objects</li></ul></li><li>Once version-enable a bucket, it can never return to an unversioned state (重要)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img174246.png"></p><hr><h4 id="S3-Replication-CRR-amp-SRR"><a href="#S3-Replication-CRR-amp-SRR" class="headerlink" title="S3 Replication (CRR &amp; SRR)"></a>S3 Replication (CRR &amp; SRR)</h4><ul><li>CRR: Cross Region Replication (compliance, lower latency access)</li><li>SRR: Same Region Replication (create test environment)<ul><li>Must enable Versioning</li><li>The Copying is asynchronous</li><li>Must give IAM permissions to S3</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img174840.png"></p><ul><li>Only new objects are replicated, existing objects need S3 Batch Replication<ul><li>也就是说只有新的 object 会被 Replicate, 老的 object 要 S3 Batch Replication</li></ul></li><li>No “chaining” in replication<ul><li>比如把 A 复制到 B 和 C, 需要 A 复制到 B 和 A 复制到 C</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img175004.png"></p><hr><h4 id="S3-Storage-Classes"><a href="#S3-Storage-Classes" class="headerlink" title="S3 Storage Classes"></a>S3 Storage Classes</h4><ul><li>一共 7 种 Storage Class: General + 2 IA + 3 Glacier + Intelligent</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img175742.png"></p><ul><li>S3 Standard - General Purpose<ul><li>Used for frequently accessed data (最常见)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img175932.png"></p><ul><li>S3 Infrequent Access (Standard IA &amp; One Zone IA)<ul><li>For data is less frequent access but require rapid access when needed (重要)</li><li>Lower cost than Standard </li><li>从 Standard 转到 One Zone IA 最少要 30 天</li><li>One Zone IA 不是 High Availability 的选择 (注意, 因为 AZ 会 down)</li><li>如果遇到 access is always required 就不能选 One Zone IA, 因为 AZ 可能会 down</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img180147.png"></p><ul><li>S3 Glacier Storage Classes (Archive 专用)<ul><li>Low-cost object storage for archiving &#x2F; backup</li><li>Price: storage + retrieval</li><li>S3 Glacier Instant Retrieval: Glacier 里最快但也最贵</li><li>S3 Glacier Flexible Retrieval: 三种模式 (Expedited 加急, Standard, Bulk 批量)</li><li>S3 Glacier Deep Archive: 存的时间最久, 两种模式 (Standard, Bulk), 48 小时 retrieval</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img180642.png"></p><ul><li>S3 Intelligent Tiering<ul><li>Move objects automatically between Access Tiers based on usage</li><li>就是自动帮你把 Object 移到不同的 Storage Class 里</li><li>Intelligent Tier 是在 Standard 和 Standard IA 下面的, 不能从下往上转移</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img180806.png"></p><hr><h3 id="11-AWS-S3-Advance"><a href="#11-AWS-S3-Advance" class="headerlink" title="11. AWS S3 Advance"></a>11. AWS S3 Advance</h3><h4 id="S3-Lifecycle-Rules"><a href="#S3-Lifecycle-Rules" class="headerlink" title="S3 Lifecycle Rules"></a>S3 Lifecycle Rules</h4><ul><li>Transition objects between storage classes (比如从 IA 到 Glacier)<ul><li>Transition 需要 Lifecycle Rules (重要)</li></ul></li><li>比如从 Snowball 到 Glacier 就需要 Lifecycle Rule</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img235516.png"></p><ul><li>Transition Actions: Configure objects to transition to another storage class (转移)</li><li>Expiration Actions: Configure objects to expire after some time (删除)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img235639.png"></p><ul><li>S3 Analytics: Help decide when to transition objects to the right storage class</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img000151.png"></p><hr><h4 id="S3-Requester-Pays"><a href="#S3-Requester-Pays" class="headerlink" title="S3 Requester Pays"></a>S3 Requester Pays</h4><ul><li>The requester pays the cost of the request intead of the bucket owner<ul><li>反而是用户付钱, 但是用户得是 AWS 用户</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img000532.png"></p><hr><h4 id="S3-Event-Notifications"><a href="#S3-Event-Notifications" class="headerlink" title="S3 Event Notifications"></a>S3 Event Notifications</h4><ul><li>Automatically react to certain event happened in S3 (比如图片上传)<ul><li>Need to have IAM Permissions</li><li>S3 Event Notification 的 destination 是 SQS, SNS, Lambda (记住)</li></ul></li><li>大部分和 S3 事件相关的都是 S3 Event Notification, 而不是 EventBridge (重要)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img000725.png"></p><hr><h4 id="S3-Performance"><a href="#S3-Performance" class="headerlink" title="S3 Performance"></a>S3 Performance</h4><ul><li>For Upload 上传 (重要)<ul><li>Multi-Part Upload: 当上传文件大于 5 GB, 可以 parallelize uploads</li><li>S3 Transfer Acceleration: 将文件传到 AWS edge location, 可以和 Multi-Part 一起用</li><li>S3 Transfer Acceleration (S3TA) can speed up content transfers to and from S3 (针对关于 S3 的上传和下载)</li><li>注意, S3 Transfer Acceleration 没办法 copy object between buckets</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img001645.png"></p><ul><li>For Download 下载<ul><li>S3 Byte-Range Fetches: Parallelize GETs, retrieve partial data (拿部分数据, 重要)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img001828.png"></p><hr><h4 id="S3-Select-amp-Glacier-Select"><a href="#S3-Select-amp-Glacier-Select" class="headerlink" title="S3 Select &amp; Glacier Select"></a>S3 Select &amp; Glacier Select</h4><ul><li>S3 Select 使用 SQL 来做 server-side filtering, 过滤从而减少数据量</li><li>400% Faster, 80% Cheaper (性能优化)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img002050.png"></p><hr><h4 id="S3-Batch-Operations"><a href="#S3-Batch-Operations" class="headerlink" title="S3 Batch Operations"></a>S3 Batch Operations</h4><ul><li>Perform bulk operations (批量操作) on existing S3 objects<ul><li>例如 encrypt all un-encrypted objects (加密所有没有加密的文件)</li></ul></li><li>在处理 Batch 之前, 用 S3 Inventory to get object list and use S3 Select to filter objects</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img022334.png"></p><hr><h3 id="12-AWS-S3-Security"><a href="#12-AWS-S3-Security" class="headerlink" title="12. AWS S3 Security"></a>12. AWS S3 Security</h3><h4 id="S3-Encryption"><a href="#S3-Encryption" class="headerlink" title="S3 Encryption"></a>S3 Encryption</h4><ul><li>一共有 4 种方法 (SSE-S3 免费, SSE-KMS 要钱)<ul><li>Server-Side Encryption (SSE-S3, SSE-KMS, SSE-C)</li><li>Client-Side Encryption (如果用户已经有 encryption method)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img223133.png"></p><ul><li>Server-Side Encryption with Amazon S3-Managed Keys (SSE-S3)<ul><li>Enabled by default for new buckets &amp; objects</li><li>SSE-S3 的 header 是 x-amz-server-side-encryption</li><li>使用 SSE-S3, 每一个 Object 都是由 unique key 来 encrypt 的</li><li>SSE-S3 使用 256-bit Advanced Encryption Standard (AES-256)</li><li>SSE-S3 是没有 automatic key rotation 的, 要用 SSE-KMS (重要)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img223242.png"></p><ul><li>Server-Side Encryption with KMS Keys stored in AWS KMS (SSE-KMS)<ul><li>User control + audit key usage in CloudTrail (可以管理 key rotation)</li><li>SSE-KMS 的 header 是 x-amz-server-side-encryption + aws:kms</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img223417.png"></p><ul><li>Server-Side Encryption with Customer-Provided Keys (SSE-C)<ul><li>用户自己有 keys, AWS will not store the key, HTTPS must be used</li><li>当问题中提到用户需要使用自己的 key, 但是打算在 AWS 端做 encryption</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img223602.png"></p><ul><li>Client-Side Encryption<ul><li>User fully manages the keys and encryption cycle</li><li>数据在送到 AWS 之前就是加密好的</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img223715.png"></p><ul><li>Encryption in Transit (SSL&#x2F;TLS)<ul><li>可以用 aws:SecureTransport 来 enforce (不过有 SSL 基本上就是 HTTPS)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img223811.png"></p><hr><h4 id="S3-CORS"><a href="#S3-CORS" class="headerlink" title="S3 CORS"></a>S3 CORS</h4><ul><li>CORS: Cross-Origin Resource Sharing (跨域问题)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img224630.png"></p><ul><li>S3 CORS (重要)<ul><li>A client makes a cross-origin request on S3 bucket, need the correct CORS headers</li><li>Can allow specific origin or *</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img224951.png"></p><hr><h4 id="S3-MFA-Delete"><a href="#S3-MFA-Delete" class="headerlink" title="S3 MFA Delete"></a>S3 MFA Delete</h4><ul><li>MFA Delete: 防止不小心删除文件, 用户需要先验证身份 (重要)<ul><li>To use MFA Delete: Versioning must be enabled</li></ul></li><li>Only the bucket owner (root user) can enable&#x2F;disable MFA Delete (重要)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img225415.png"></p><hr><h4 id="S3-Access-Logs"><a href="#S3-Access-Logs" class="headerlink" title="S3 Access Logs"></a>S3 Access Logs</h4><ul><li>Any request made to S3 will be logged to another S3 bucket (数据分析)<ul><li>可以作为 Data Analysis 的工具</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img230251.png"></p><hr><h4 id="S3-Pre-signed-URLs"><a href="#S3-Pre-signed-URLs" class="headerlink" title="S3 Pre-signed URLs"></a>S3 Pre-signed URLs</h4><ul><li>Have URL expiration (过期)<ul><li>用在 Private Bucket 上, 一段时间后 URL 过期</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img230702.png"></p><hr><h4 id="Glacier-Vault-Lock-amp-S3-Object-Lock"><a href="#Glacier-Vault-Lock-amp-S3-Object-Lock" class="headerlink" title="Glacier Vault Lock &amp; S3 Object Lock"></a>Glacier Vault Lock &amp; S3 Object Lock</h4><ul><li>S3 Glacier Vault Lock<ul><li>Adopt a WORM (Write Once Read Many), 信息一旦写入就无法修改</li><li>The object can’t be deleted (无法修改)</li></ul></li><li>可以用 Glacier Vault Lock 储存 sensitive 数据, 然后用 Vault Lock Policy 去管理</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img230941.png"></p><ul><li>S3 Object Lock (Must have Versioning, 重要)<ul><li>Block an object version deletion for an amount of time (有时限)</li><li>两个 Retention mode (重要)<ul><li>Compliance: 所有人都没法删, Root user 也不行</li><li>Governance: 有些人可以删, 有权限的人可以</li></ul></li><li>Legal Hold: 防止 Object Version 被改, 除非你自己把 Legal Hold 移除 (重要)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img231203.png"></p><hr><h4 id="S3-Access-Points"><a href="#S3-Access-Points" class="headerlink" title="S3 Access Points"></a>S3 Access Points</h4><ul><li>Access Points simplify security management for S3 Buckets (根据用户属性)</li><li>Each Access Point: DNS name + Access Point Policy</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img231500.png"></p><hr><h4 id="S3-Object-Lambda"><a href="#S3-Object-Lambda" class="headerlink" title="S3 Object Lambda"></a>S3 Object Lambda</h4><ul><li>Use AWS Lambda to change object before retrieve by caller (在到达 caller 之前)<ul><li>用途: 可以给图片打水印</li></ul></li><li>需要 S3 Access Point 和 S3 Object Lambda Access Points</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img231810.png"></p><hr><h3 id="13-CloudFront-amp-AWS-Global-Accelerator"><a href="#13-CloudFront-amp-AWS-Global-Accelerator" class="headerlink" title="13. CloudFront &amp; AWS Global Accelerator"></a>13. CloudFront &amp; AWS Global Accelerator</h3><h4 id="AWS-CloudFront"><a href="#AWS-CloudFront" class="headerlink" title="AWS CloudFront"></a>AWS CloudFront</h4><ul><li>Content Delivery Network (CDN), 可以 serve static &amp; dynamic content<ul><li>Improve read performance, content is cached at the edge</li></ul></li><li>可以防止 DDoS protection (搭配 AWS Shield), 可以根据 content type 来 route, 可以指定 primary &amp; secondary origins 来做 High Availiability &amp; Failover</li><li>CloudFront Origins: S3 Bucket (OAC) 或者 Custom Origin (HTTP)<ul><li>OAC: Origin Access Control (重要, 如果涉及到 S3 的问题)</li></ul></li><li>如果问到 CloudFront 而且需要 encryption, 选择 field level encryption (不是 KMS)<ul><li>Field-level encryption allows you to enable your users to securely upload sensitive information to your web servers.</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img232701.png"></p><ul><li>CloudFront vs S3 Cross Region Replication<ul><li>CloudFront: 使用 global edge network, 有 TTL, 用于 static content</li><li>S3 Cross Region Replication (CRR): 每个 Region 都要设置, 但是没有 TTL, 用于 dynamic content (updated in near real-time, 只读)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img233016.png"></p><ul><li>Price Classes: 不同地区的价格不一样<ul><li>可以用来 cost reduction (降低价格)</li></ul></li><li>CloudFront 允许 Proxy methods 和 Dynamic content 跳过 regional edge cache</li><li>除了 WAF 可以去 block IP, 还可以使用 OAI (origin access identity, 重要)<ul><li>OAI 也可以用来 secure communication between CloudFront &amp; S3</li></ul></li><li>可以用 CloudFront signed URLs 和 CloudFront signed cookies 来 restrict access to documents (比如 subscription)</li><li>Can configure CloudFront to require HTTPS from clients (可以用 CloudFront 要求 client 必须使用 HTTPS)</li></ul><hr><h4 id="CloudFront-Geo-Restriction"><a href="#CloudFront-Geo-Restriction" class="headerlink" title="CloudFront Geo Restriction"></a>CloudFront Geo Restriction</h4><ul><li>Allowlist &amp; Blocklist (针对 IP, 国家进行访问限制)<ul><li>CloudFront Geo Restriction 没办法和 VPC 一起使用</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img233638.png"></p><hr><h4 id="CloudFront-Cache-Invalidation"><a href="#CloudFront-Cache-Invalidation" class="headerlink" title="CloudFront Cache Invalidation"></a>CloudFront Cache Invalidation</h4><ul><li>让 CloudFront 跳过 TTL 立即更新<ul><li>比如你更新了后端, 但是 CloudFront 不会立即更新, 需要 CloudFront Invalidation 来跳过 TTL 来立即更新</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img234007.png"></p><hr><h4 id="AWS-Global-Accelerator"><a href="#AWS-Global-Accelerator" class="headerlink" title="AWS Global Accelerator"></a>AWS Global Accelerator</h4><ul><li>利用 AWS internal network to route application<ul><li>Provide 2 global static anycast IPs (重要)</li><li>Improve availability and performance of the applications (globally)</li></ul></li><li>Global Accelerator improves performance for applications over TCP or UDP</li><li>Global Accelerator has automatic failover </li><li>Global Accelerator is more expensive as it adds an extra layer of infrastructure (对比 CloudFront 不是一个 cost-effective 的选择)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img234527.png"></p><ul><li>AWS Global Accelerator vs CloudFront<ul><li>CloudFront: Content is served at edge, 比如图片和视频 (cacheable), Dynamic content such as API acceleration &amp; dynamic site delivery</li><li>Global Accelerator: 适合 TCP 或者 UDP, 比如游戏和 IoT (static IP)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img000939.png"></p><blockquote><p>AWS Global Accelerator is a network service that can provide a global traffic management solution. By creating a standard accelerator in AWS Global Accelerator, you can guide user traffic to the endpoint closest to them, thereby improving the performance and availability of the application. </p></blockquote><hr><h3 id="14-AWS-Storage-Extra"><a href="#14-AWS-Storage-Extra" class="headerlink" title="14. AWS Storage Extra"></a>14. AWS Storage Extra</h3><h4 id="AWS-Snow-Family"><a href="#AWS-Snow-Family" class="headerlink" title="AWS Snow Family"></a>AWS Snow Family</h4><ul><li>整个 Snow Family 都是硬件形式</li><li>Data migration (in &amp; out AWS) &amp; Edge Computing (process data at edge)<ul><li>Snowcone (体积小, 适合带到特殊环境, 没有 Snowball 内存大)</li><li>Snowball Edge (Storage Optimized 和 Compute Optimized, 推荐处理 10 - 100 TB)<ul><li>Compute Optimized 是支持 storage clustering 的</li><li>Terabytes, low costs, limited time &#x3D; AWS Snowball devices</li></ul></li><li>Snowmobile (不算在 Edge Computing 里, 数据传输最大, 推荐处理 10 PB 以上)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img200544.png"></p><ul><li>Edge Location: 比如海上或者矿洞里, 没有网络的情况下<ul><li>所以需要 Edge Computing 和 Snow Family</li></ul></li><li>AWS OpsHub: 用来管理 AWS Snow Family</li><li>Snowball to Glacier: Use S3 lifecycle policy (Snowball 兼容 S3 但是 Glacier 不行, 重要)<ul><li>注意, 这里的 Glacier 指的是整个 Glacier Family (eg. Glacier Deep Archive)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img201918.png"></p><hr><h4 id="AWS-FSx"><a href="#AWS-FSx" class="headerlink" title="AWS FSx"></a>AWS FSx</h4><ul><li>Third party high-performance file systems on AWS (第三方文件系统)<ul><li>FSx for Windows: Window file system, support SMB &amp; Windows NTFS</li><li>FSx for Lustre (Linux): 可以 maximize IOPS, 适合 HPC, 可以和 S3 Integrate</li><li>FSx for NetApp ONTAP: File system for NFS, SMB, iSCSI</li><li>FSx for OpenZFS: OpenZFS file system (和它名字一样)</li></ul></li></ul><blockquote><p>FSx for Lustre provides the ability to both process the ‘hot data’ in a parallel and distributed fashion as well as easily store the ‘cold data’ on Amazon S3.</p></blockquote><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img202205.png"></p><ul><li>两种 Deployment Options<ul><li>Scratch File System: Temporary storage, data not replicated</li><li>Persistent File System: Long term storage, data replicated (Same AZ, 重要)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img202555.png"></p><hr><h4 id="AWS-Storage-Gateway"><a href="#AWS-Storage-Gateway" class="headerlink" title="AWS Storage Gateway"></a>AWS Storage Gateway</h4><ul><li>Bridge between On-Premise data and cloud data (Hybrid cloud, 重要)<ul><li>On-Premise 和 AWS Cloud 之间的桥梁 (保留从 On-Premise 去访问 AWS 数据的能力)</li><li>重点, Hybrid Cloud, give On-Premise ability to access cloud storage</li></ul></li><li>提到 NFS 的就是 File Gateway, 问 S3 大部分都是 File Gateway</li><li>DataSync 是用来移数据的, File Gateway 是用来维持 access 的 (重要)</li><li>File Gateway 是 file storage, Volume Gateway 是 block storage (重要)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img203211.png"></p><ul><li>一共有 4 种 Gateway (注意, Storage Gateway 泛指下面这 4 个 Gateway)<ul><li>S3 File Gateway: 从 On-Premise 访问 S3 Buckets (NFS, SMB), file storage</li><li>FSx File Gateway: 从 On-Premise 访问 FSx (SMB, NTFS)</li><li>Volume Gateway: 从 On-Premise 访问 S3 和 EBS (iSCSI), block storage<ul><li>Cached volumes: Access most recent data (eg. logs) 如果问到 S3 的话</li><li>Stored volumes: Entire dataset is On-Premise, backup at S3</li></ul></li><li>Tap Gateway: 从 On-Premise 访问 Archieved Taps stored in AWS Glacier<ul><li>如果问题里面有 Tap 就是 Tap Gateway</li></ul></li></ul></li></ul><hr><h4 id="AWS-Transfer-Family"><a href="#AWS-Transfer-Family" class="headerlink" title="AWS Transfer Family"></a>AWS Transfer Family</h4><ul><li>Use FTP protocol to transfer files into or out S3 或 EFS <ul><li>有三种 Protocols: FTP, FTPS, SFTP (重要, 如果问到关于 FTP 或者 SFTP 的问题)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img203933.png"></p><hr><h4 id="AWS-DataSync"><a href="#AWS-DataSync" class="headerlink" title="AWS DataSync"></a>AWS DataSync</h4><ul><li>可以从 On-Premise 或者 AWS 转移大量数据 (to &amp; from)<ul><li>On-Premise 到 AWS S3, EFS, FSx 等等 (need agent)</li><li>AWS 到 AWS (no agent)</li></ul></li><li>Scheduled replication tasks (比如每周五都会 replicate 一次)</li><li>File permissions and metadata are perserved (重要)</li><li>DataSync 是用来移数据的, File Gateway 是用来维持 access 的</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img204155.png"></p><blockquote><p>AWS DataSync is an online data transfer service that simplifies, automates, and accelerates copying large amounts of data between on-premises storage systems and AWS Storage services, as well as between AWS Storage services.</p></blockquote><hr><h3 id="15-SQS-SNS-Kinesis-Active-MQ"><a href="#15-SQS-SNS-Kinesis-Active-MQ" class="headerlink" title="15. SQS, SNS, Kinesis, Active MQ"></a>15. SQS, SNS, Kinesis, Active MQ</h3><h4 id="AWS-SQS"><a href="#AWS-SQS" class="headerlink" title="AWS SQS"></a>AWS SQS</h4><ul><li>用来 decouple applications (比如处理视频, 属于多对多模型)</li><li>SQS scale automatically (Unlimited throughput, unlimited message, can retry)<ul><li>遇到说 decouple microservice (但是没有 3rd party 的) 就是 SQS</li></ul></li><li>Standard SQS 允许将 S3 作为 event notification destination, SQS FIFO 则不行</li><li>如果遇到 SQS message process failure, 选择 DLQ 来解决 (重要)</li><li>如果遇到需要处理 high-throughput request-reponse message pattern 的, 选择 temporary queue (重要)</li><li>如果遇到需要 SQS 去 postpone the delivery of new messages, 那么就是 delay queue</li><li>遇到 parallel 选 SQS 而不是 SNS</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img235912.png"></p><ul><li>可以有很多 consumer 来同时 parallel 处理 messages<ul><li>Consumer delete messages after processing them (处理完就删掉)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img000504.png"></p><ul><li>SQS Message Visibility Timeout (重要)<ul><li>Visibility Timeout is high: Consumer crash, re-process take time</li><li>Visibility Timeout is low: Get duplicate (防止 read duplicate, 增加 Timeout, 重要)</li><li>Use the ChangeMessageVisibility API call to increase the visibility timeout</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img020440.png"></p><ul><li>当遇到 SQS 而且需要 priority 的时候, Create two Amazon SQS standard queues, Set up Amazon EC2 instances to prioritize polling</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/imgpt6-q32-i1.jpg"></p><ul><li>把 SQS 转成 FIFO queue<ul><li>Delete the existing SQS and recreate it as FIFO queue</li><li>Make sure the name of the FIFO queue ends with .fifo suffix</li><li>Make sure the throughput for the FIFO queue not exceed 3000 meesage &#x2F; second</li></ul></li></ul><hr><h4 id="SQS-Long-Polling"><a href="#SQS-Long-Polling" class="headerlink" title="SQS Long Polling"></a>SQS Long Polling</h4><ul><li>Decrease latency &amp; decrease API call (减少 API 请求, 更好的 performance)<ul><li>Minimize the cost of using SQS (省钱)</li><li>Long Polling 不能处理 SQS duplicate, 还是要用 Visibility Timeout</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img003255.png"></p><hr><h4 id="SQS-FIFO-Queue"><a href="#SQS-FIFO-Queue" class="headerlink" title="SQS FIFO Queue"></a>SQS FIFO Queue</h4><ul><li>按顺序传递 message (SNS 也可以做到)<ul><li>By default, FIFO queues support up to 300 messages per second</li></ul></li><li>如果没有 GroupID, 那只能有 1 个 consumer, 如果有 GroupID, 可以有多个 consumer</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img003507.png"></p><hr><h4 id="AWS-SNS"><a href="#AWS-SNS" class="headerlink" title="AWS SNS"></a>AWS SNS</h4><ul><li>Send one message to many receivers (可以给用户发 email)<ul><li>Publisher &amp; Subscriber 模型 (属于一对多模型)</li><li>Subscriber: SQS, Lambda, Kinesis Data Firehose, HTTPS endpoints, Email</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img010634.png"></p><hr><h4 id="Fan-Out-Pattern"><a href="#Fan-Out-Pattern" class="headerlink" title="Fan Out Pattern"></a>Fan Out Pattern</h4><ul><li>Push once in SNS, receive in all SQS (由 SNS 传递 message 给 SQS 来接收)<ul><li>Fully decoupled, no data loss</li><li>可以用于 message filtering (信息过滤, 根据不同的 filter policy)</li></ul></li><li>Kinesis 也可以使用 Fan Out Pattern (使用 Shard)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img011026.png"></p><hr><h4 id="AWS-Kinesis"><a href="#AWS-Kinesis" class="headerlink" title="AWS Kinesis"></a>AWS Kinesis</h4><ul><li>Process, ingest, buffer streaming data in real-time (处理实时数据)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img150053.png"></p><ul><li>Kinesis Data Streams: Capture, process, store data streams</li><li>Kinesis Data Firehose: Load data streams into AWS data stores (S3, Redshift)</li><li>当 Kinesis Data Streams 作为数据源写数据到 Kinesis Data Firehose 是不用 agent 的</li></ul><blockquote><p>Kinesis Agent cannot write to Amazon Kinesis Firehose for which the delivery stream source is already set as Amazon Kinesis Data Streams</p></blockquote><hr><h4 id="Kinesis-Data-Streams"><a href="#Kinesis-Data-Streams" class="headerlink" title="Kinesis Data Streams"></a>Kinesis Data Streams</h4><ul><li>Have the ability to reprocess &amp; replay stream data (replay, 处理数据, 重要)<ul><li>处理 real-time data stream, 比如 clickstreams, transactions, media (金融数据)</li><li>Consumer 有 Lambda, Kinesis Firehose, Kinesis Data Analytics</li><li>Kinesis Data Streams 有助于每秒从多个来源连续收集数 GB 的数据</li></ul></li><li>Once data is inserted in Kinesis, it can’t be deleted (immutability)</li><li>如果问到 Kinesis Data Stream 加上 SQL, 那么答案里一定有 Kinesis Data Analytics</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img014850.png"></p><ul><li>Data share the same partition goes the same shard (有顺序的)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img151123.png"></p><ul><li>Capacity Mode (Provisioned 设置上限, On-Demand 自动 scale)<ul><li>Provisioned mode: Choose a number of shards provisioned, scale manually</li><li>On-demand mode: No need to provision or manage capacity (自动)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img151507.png"></p><blockquote><p>如果遇到 ProvisionedThroughputExceededException 问题, 选择 batch messages 解决</p></blockquote><hr><h4 id="Kinesis-Data-Firehose"><a href="#Kinesis-Data-Firehose" class="headerlink" title="Kinesis Data Firehose"></a>Kinesis Data Firehose</h4><ul><li>Kinesis Data Firehose load streaming data into data stores and analytics tools<ul><li>Managed service, auto scaling, serverless, support data transformation</li><li>Kinesis Data Firehose 提供将数据流传进数据存储或者数据分析的功能</li></ul></li><li>Firehose 的对象是 S3, Redshift 这种 (Serverless, 专门处理 log 数据)<ul><li>Firehose 不支持 DynamoDB 的</li></ul></li><li>Near Real Time, 而且 Firehose 只支持一个 consumer (dump data in a single data repo)<ul><li>但是不要被 Near Real Time 忽悠, 要根据题目选择 Data Stream 或者 Data Firehose</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img015040.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img151812.png"></p><ul><li>Kinesis Data Streams vs Firehose<ul><li>Data Streams: Write custom code, real-time, have data storage, have replay</li><li>Firehose: Fully managed, near real-time, no data storage, no replay</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img152247.png"></p><hr><h4 id="Data-ordering-for-Kinesis"><a href="#Data-ordering-for-Kinesis" class="headerlink" title="Data ordering for Kinesis"></a>Data ordering for Kinesis</h4><ul><li>Same key (Partition) will always go to the same shard (有顺序)</li><li>相比之下 SQS 只有 FIFO (针对于需要大量 consumer)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img154939.png"></p><hr><h4 id="AWS-MQ"><a href="#AWS-MQ" class="headerlink" title="AWS MQ"></a>AWS MQ</h4><ul><li>管理第三方消息代理 (Message Broker) 软件<ul><li>RabbitMQ and ActiveMQ</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img170638.png"></p><hr><h3 id="16-Containers-on-AWS"><a href="#16-Containers-on-AWS" class="headerlink" title="16. Containers on AWS"></a>16. Containers on AWS</h3><h4 id="AWS-ECS"><a href="#AWS-ECS" class="headerlink" title="AWS ECS"></a>AWS ECS</h4><ul><li>Elastic Container Service (Manage Docker containers on AWS)</li><li>ECS 有两种 Launch Type: EC2 和 Fargate (Fargate 是 serverless 的)</li><li>EC2 Launch Type: Need Provision, 需要 ECS Agent (重点)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img212508.png"></p><ul><li>Fargate Launch Type: Serverless, No Provision (重点)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img212546.png"></p><ul><li>IAM Roles for ECS (重要, 是 IAM)<ul><li>EC2 Instance Profile: 只针对 EC2 Launch Type</li><li>ECS Task Role: 每个 Task 都有自己的 Role (负责)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img212709.png"></p><ul><li>ECS 可以和 Load Balancer 一起用</li><li>ECS 可以和 EFS 一起用 (Fargate + EFS &#x3D; Serverless, 管理文件)</li></ul><blockquote><p>Amazon ECS with EC2 launch type is charged based on EC2 instances and EBS volumes used. Amazon ECS with Fargate launch type is charged based on vCPU and memory resources that the containerized application requests</p></blockquote><hr><h4 id="ECS-Auto-Scaling"><a href="#ECS-Auto-Scaling" class="headerlink" title="ECS Auto Scaling"></a>ECS Auto Scaling</h4><ul><li>Automatically increase &#x2F; decrease the number of ECS tasks<ul><li>Target Scaling: Scale based on target value for CloudWatch metric</li><li>Step Scaling: Scale based on CloudWatch Alarm</li><li>Scheduled Scaling: Scale based on specific time (重要)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img222247.png"></p><hr><h4 id="AWS-ECR"><a href="#AWS-ECR" class="headerlink" title="AWS ECR"></a>AWS ECR</h4><ul><li>Elastic Container Registry (ECR, 管理 Docker Image, 不是 Docker Container)<ul><li>Store and manage Docker images on AWS</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img222836.png"></p><hr><h4 id="AWS-EKS"><a href="#AWS-EKS" class="headerlink" title="AWS EKS"></a>AWS EKS</h4><ul><li>Elastic Kubernetes Service (Manage Kubernetes clusters on AWS)<ul><li>Support 2 deployment mode: EC2 &amp; Fargate (和 ECS 一样)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img223132.png"></p><ul><li>EKS Data Volumes (需要 StorageClass)<ul><li>Leverages a Container Storage Interface (CSI) compliant driver</li><li>支持 EBS, EFS, FSx</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img223503.png"></p><ul><li>EKS Node Type (一共三种)<ul><li>Managed Node Groups (针对 EC2 Instance)</li><li>Self-Managed Nodes (自己创建)</li><li>AWS Fargate (不需要管理)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img022321.png"></p><hr><h4 id="AWS-App-Runner"><a href="#AWS-App-Runner" class="headerlink" title="AWS App Runner"></a>AWS App Runner</h4><ul><li>Deploy web application and APIs (Build 和 Deploy)</li><li>No infrasture experience required (不需要 AWS 经验)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img223649.png"></p><hr><h3 id="17-Serverless"><a href="#17-Serverless" class="headerlink" title="17. Serverless"></a>17. Serverless</h3><h4 id="AWS-Lambda"><a href="#AWS-Lambda" class="headerlink" title="AWS Lambda"></a>AWS Lambda</h4><ul><li>Virtual functions, Serverless, limited by time (short executions, 15 mins)<ul><li>Run on-demand, scaling is automated</li></ul></li><li>Could be Event-Driven, could handle CRON job (Jobs on a repeating schedule)<ul><li>Use EventBridge to trigger Lambda every hour</li></ul></li><li>Lambda 是有 account quota (配额限制) 的, 需要联系 AWS 来提高上限</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img212846.png"></p><ul><li>Lambda Limits (限制)<ul><li>Execution: Memory, Execution Time</li><li>Deployment: Size</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img213554.png"></p><blockquote><p>By default, AWS Lambda functions always operate from an AWS-owned VPC and hence have access to any public internet address or public AWS APIs. Once an AWS Lambda function is VPC-enabled, it will need a route through a Network Address Translation gateway (NAT gateway) in a public subnet to access public resources</p></blockquote><hr><h4 id="Lambda-SnapStart"><a href="#Lambda-SnapStart" class="headerlink" title="Lambda SnapStart"></a>Lambda SnapStart</h4><ul><li>对于 Java 11 以上, Function is invoked from a pre-initialized state</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img213945.png"></p><hr><h4 id="CloudFront-Functions-amp-Lambda-Edge"><a href="#CloudFront-Functions-amp-Lambda-Edge" class="headerlink" title="CloudFront Functions &amp; Lambda@Edge"></a>CloudFront Functions &amp; Lambda@Edge</h4><ul><li>Execute logic at the edge (Edge Function, Serverless)</li><li>两种方法: CloudFront Functions, Lambda@Edge (它们支持的语言不同)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img214215.png"></p><ul><li>CloudFront Functions (Javascript)<ul><li>Native feature of CloudFront, short execution time</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img214350.png"></p><ul><li>Lambda@Edge (NodeJS or Python)<ul><li>Longer execution time</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img214545.png"></p><ul><li>CloudFront Functions vs Lambda@Edge</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img214716.png"></p><hr><h4 id="Lambda-in-VPC"><a href="#Lambda-in-VPC" class="headerlink" title="Lambda in VPC"></a>Lambda in VPC</h4><ul><li>正常情况下, Lambda 无法访问 VPC (所以要 Lambda in VPC)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img214940.png"></p><hr><h4 id="RDS-with-Lambda"><a href="#RDS-with-Lambda" class="headerlink" title="RDS with Lambda"></a>RDS with Lambda</h4><ul><li>Invoke Lambda functions from DB instance <ul><li>RDS for PostgreSQL, Aurora for MySQL, 需要 permission</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img215442.png"></p><hr><h4 id="AWS-DynamoDB"><a href="#AWS-DynamoDB" class="headerlink" title="AWS DynamoDB"></a>AWS DynamoDB</h4><ul><li>NoSQL database, with replication across multiple AZs, auto-scaling, no provision</li><li>两种 Class: Standard &amp; Infrequent Access (IA)</li><li>如果问到 DynamoDB 而且是处理 Email 的, 就是 DynamoDB Stream<ul><li>如果问到关于 Stream 的, 也要去考虑 DynamoDB Stream</li></ul></li><li>如果问到 DynamoDB 而且是处理 unpredictable 数据的时候, 选择 On-Demand table</li><li>By default, DynamoDB tables are encrypted with AWS owned key</li><li>不要用 DB 去存 Image (不知道为啥)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img224558.png"></p><ul><li>Read &#x2F; Write Capacity Mode<ul><li>RCU 和 WCU 没有关联 (可以只加 RCU 不加 WCU)</li><li>Provisioned Mode: 自己定义需要多少 RCU 和 WCU</li><li>On-Demand Mode: 自动 Scale 需要的 RCU 和 WCU (贵)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img225117.png"></p><ul><li>Point-In-Time Recovery (PITR, 重要)<ul><li>When enable PITR, DynamoDB backs up table data automatically with per-second granularity so that you can restore to any given second in the preceding 35 days.</li></ul></li></ul><hr><h4 id="DynamoDB-Advance"><a href="#DynamoDB-Advance" class="headerlink" title="DynamoDB Advance"></a>DynamoDB Advance</h4><ul><li>DynamoDB Accelerator (DAX, 可以处理 cache, 但是 DAX 不是 relational 的)<ul><li>Help solve read congestion by caching (microseconds latency, 缓存)</li><li>DAX 不支持 SQL query caching</li><li>可以提高 DynamoDB 的 performance (提高的是 read 而不是 write, 重要)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img233440.png"></p><ul><li>DynamoDB Stream Processing (处理 Stream)<ul><li>Ordered stream of item-level modifications in table </li><li>用来处理 Stream 的, 可以 Invoke Lambda function (比如发邮件)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img233610.png"></p><ul><li>DynamoDB Global Tables (重要)<ul><li>Make DynamoDB table accessible with low latency in multiple regions</li><li>需要先有 DynamoDB Stream 作为前提</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img233729.png"></p><ul><li>DynamoDB Time To Live (TTL, 重要)<ul><li>Automatic delete items after an expiry timestamp (定时删除 DynamoDB 里的 item)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img233830.png"></p><hr><h4 id="AWS-API-Gateway"><a href="#AWS-API-Gateway" class="headerlink" title="AWS API Gateway"></a>AWS API Gateway</h4><ul><li>Invoke Lambda function, expose REST API (Stateless client-server communication)</li><li>Lambda + API Gateway &#x3D; No infrastructure to manage</li><li>API Gateway 可以防止 API overwhelmed by too many requests (防抖)</li><li>API Gateway Caching (可以 improve latency)<ul><li>With caching, you can reduce the number of calls made to your endpoint and also improve the latency of requests to your API</li><li>反正记住, Read Replica 是要加钱的</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img234222.png"></p><ul><li>API Gateway Endpoint Types<ul><li>Edge-Optimized (default): For global clients, API Gateway live in one region</li><li>Regional: For client in same region</li><li>Private: 针对 VPC</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img174118.png"></p><hr><h4 id="AWS-Step-Functions"><a href="#AWS-Step-Functions" class="headerlink" title="AWS Step Functions"></a>AWS Step Functions</h4><ul><li>Build serverless visual workflow to orchestrate Lambda functions <ul><li>搭建 Serverless 可视化 Workflow (重要)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img234352.png"></p><hr><h4 id="AWS-Cognito"><a href="#AWS-Cognito" class="headerlink" title="AWS Cognito"></a>AWS Cognito</h4><ul><li>Give users identity to interact with web or mobile application<ul><li>Cognito User Pools: 负责用户登录, have built-in user management</li><li>Cognito Identity Pools: 给临时 AWS credentials 来 access AWS 服务</li></ul></li><li>注意, ALB + Cognito User Pool 才是做 Auth 的, 而不是 CloudFront</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img234512.png"></p><hr><h3 id="18-Database-Summary"><a href="#18-Database-Summary" class="headerlink" title="18. Database Summary"></a>18. Database Summary</h3><h4 id="AWS-RDS-SM"><a href="#AWS-RDS-SM" class="headerlink" title="AWS RDS (SM)"></a>AWS RDS (SM)</h4><ul><li>Manage PostgreSQL, MySQL, Oracle, SQL Server 等等</li><li>Provisioned, Auto Scaling, Backup</li><li>Have Read Replica &amp; Multi-AZ (回去看第七章)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img151151.png"></p><hr><h4 id="AWS-Aurora-SM"><a href="#AWS-Aurora-SM" class="headerlink" title="AWS Aurora (SM)"></a>AWS Aurora (SM)</h4><ul><li>Manage PostgreSQL &amp; MySQL (只有这两个, 回去看第七章)</li><li>Data stored in 6 replias, across 3 AZ, high available, auto-scaling</li><li>Aurora Serverless: For unpredictable workloads (Auto Scaling)</li><li>Aurora Global: Less than 1 second storage replication (保证至少有一个 Replica 可以用)</li><li>Aurora Database Cloning: 快速 access Aurora DB, 适合 test database 生成</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img151441.png"></p><hr><h4 id="AWS-ElastiCache-SM"><a href="#AWS-ElastiCache-SM" class="headerlink" title="AWS ElastiCache (SM)"></a>AWS ElastiCache (SM)</h4><ul><li>Manage Redis &#x2F; Memcached (In-memory data store, 回去看第七章)</li><li>Support Clustering (Redis), Multi-AZ and Read Replicas (Shard)</li><li>Require some application code change to be leveraged (重点)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img151732.png"></p><hr><h4 id="AWS-DynamoDB-SM"><a href="#AWS-DynamoDB-SM" class="headerlink" title="AWS DynamoDB (SM)"></a>AWS DynamoDB (SM)</h4><ul><li>Severless, NoSQL database (For rapidly evolve schemas, 回去看第十七章)</li><li>Capacity modes: Provisioned capacity or On-Demand capacity</li><li>DAX cluster for read cache, microsecond read latency (缓存)</li><li>Event Processing: DynamoDB Stream with Lambda or Kinesis Data Streams</li><li>Export to S3 without using RCU, Import from S3 without WCU</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img152140.png"></p><hr><h4 id="AWS-S3-SM"><a href="#AWS-S3-SM" class="headerlink" title="AWS S3 (SM)"></a>AWS S3 (SM)</h4><ul><li>S3 is a key &#x2F; value store for objects (适合文件体积大的, 回去看第十章)</li><li>Tiers: Standard, IA, Glacier 等等</li><li>Features: Versioning, Encryption, Replication 等等</li><li>Encryption: SSE-S3, SSE-KMS, SSE-C</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img152526.png"></p><hr><h4 id="AWS-DocumentDB"><a href="#AWS-DocumentDB" class="headerlink" title="AWS DocumentDB"></a>AWS DocumentDB</h4><ul><li>DocumentDB is for MongoDB (Also a NoSQL database, 但是只负责 MongoDB)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img152629.png"></p><hr><h4 id="AWS-Neptune"><a href="#AWS-Neptune" class="headerlink" title="AWS Neptune"></a>AWS Neptune</h4><ul><li>Graph database (For social network, 图数据库)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img152726.png"></p><hr><h4 id="AWS-Keyspaces"><a href="#AWS-Keyspaces" class="headerlink" title="AWS Keyspaces"></a>AWS Keyspaces</h4><ul><li>Manage Apache Cassandra (also NoSQL) database (阿帕奇卡桑德拉)</li><li>Use cases: Store IoT devices info, time-series data</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img153058.png"></p><hr><h4 id="AWS-QLDB"><a href="#AWS-QLDB" class="headerlink" title="AWS QLDB"></a>AWS QLDB</h4><ul><li>QLDB: Quantum Ledger Database (Immutable, 无法删除)<ul><li>For recording financial transactions (Serverless, 加密资产)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img153301.png"></p><hr><h4 id="AWS-Timestream"><a href="#AWS-Timestream" class="headerlink" title="AWS Timestream"></a>AWS Timestream</h4><ul><li>Serverless Time series database (时间序列数据库)</li><li>Use cases: IoT apps, real-time analytics</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img153436.png"></p><hr><h3 id="19-Data-amp-Analytics"><a href="#19-Data-amp-Analytics" class="headerlink" title="19. Data &amp; Analytics"></a>19. Data &amp; Analytics</h3><h4 id="AWS-Athena"><a href="#AWS-Athena" class="headerlink" title="AWS Athena"></a>AWS Athena</h4><ul><li>Athena is an interactive query service that makes it easy to analyze data directly in Amazon S3 using standard SQL (Athena is Serverless)<ul><li>Athena 支持 SQL query 去处理 S3 数据的</li><li>Athena cannot be used to analyze data in real time (没办法实时处理数据, 重要)</li></ul></li><li>Use Athena to process logs, perform ad-hoc analysis, and run interactive queries (重要)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img200048.png"></p><ul><li>Performance Improvement<ul><li>Use columnar data for cost-saving (可以有更少的 scan)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img200302.png"></p><ul><li>Federated Query<ul><li>Allow to run SQL queries across data stored on AWS or On-Premise</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img200427.png"></p><hr><h4 id="AWS-Redshift"><a href="#AWS-Redshift" class="headerlink" title="AWS Redshift"></a>AWS Redshift</h4><ul><li>Based on PostgreSQL, but it’s OLAP (Online analytical processing)</li><li>处理 BI 数据, 和 AWS Quicksight 或者 Tableau 一起用<ul><li>Petabyte scale - Redshift (重要)</li></ul></li><li>如果问到 Redshift 且和 S3 有关, 就是 Redshift Spectrum (重要)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img201036.png"></p><ul><li>Snapshots &amp; DR<ul><li>Redshift has “Multi-AZ” mode for clusters</li><li>Enable Automated Snapshots, copy the Redshift cluster to another AWS region</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img201212.png"></p><ul><li>Load data into Redshift (将数据存到 Redshift 里)<ul><li>Kinesis Data Firehose, S3 with Enhanced VPC Routing (注意), EC2 Instance</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img230656.png"></p><ul><li>Redshift Spectrum (和 S3 有关)<ul><li>Query data that is already in S3 without loading it (重要)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img201418.png"></p><hr><h4 id="AWS-OpenSearch"><a href="#AWS-OpenSearch" class="headerlink" title="AWS OpenSearch"></a>AWS OpenSearch</h4><ul><li>With OpenSearch, you can search any field, even partially matches<ul><li>原来叫做 ElasticSearch (就是做查询的)</li></ul></li><li>可以用 OpenSearch 实时处理和搜索 Logs</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img203117.png"></p><hr><h4 id="AWS-EMR"><a href="#AWS-EMR" class="headerlink" title="AWS EMR"></a>AWS EMR</h4><ul><li>EMR: Elastic MapReduce (处理大数据的)<ul><li>EMR helps to creating Hadoop clusters (Big Data, 大数据)</li><li>有 Hadoop, Apache Spark 啥的就是 EMR</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img203405.png"></p><ul><li>Node types &amp; purchasing<ul><li>Node: Master, Core, Task</li><li>Purchasing options: On-Demand, Reserved, Spot Instance</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img203545.png"></p><hr><h4 id="AWS-QuickSight"><a href="#AWS-QuickSight" class="headerlink" title="AWS QuickSight"></a>AWS QuickSight</h4><ul><li>Serverless machine learning business intelligence service to create dashboard<ul><li>简单来说就是用 ML 来分析商业数据并搭建 Dashboard</li></ul></li><li>In-memory computation using SPICE engine</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img203724.png"></p><ul><li>Dashboard &amp; Analysis<ul><li>Share analysis or dashboard with Users or Groups (可以选择性的分享数据)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img203954.png"></p><hr><h4 id="AWS-Glue"><a href="#AWS-Glue" class="headerlink" title="AWS Glue"></a>AWS Glue</h4><ul><li>Managed extract, transform and load (ETL) service (Serverless)<ul><li>For customers to prepare and load their data for analytics</li><li>遇到处理 ETL 的就是 Glue, 用到 Apache Spark</li><li>Use AWS Glue to process the raw data in Amazon S3 (重要)</li></ul></li></ul><blockquote><p>AWS Glue ETL jobs can use Amazon S3, data stores in a VPC, or on-premises JDBC data stores as a source. AWS Glue jobs extract data, transform it, and load the resulting data back to S3, data stores in a VPC, or on-premises JDBC data stores as a target.</p></blockquote><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img224509.png"></p><ul><li>Convert data into Apache Parquet format (转数据格式, 很奇怪, 但是会考)<ul><li>看到这个 Apache Parquet 就要想起 Glue</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img224817.png"></p><ul><li>Glue Job Bookmarks: 防止 re-process 旧数据 (重要)</li><li>Glue Elastic Views: Combine and replicate data accross multiple data stores with SQL</li><li>Glue DataBrew: Clean and normalize data</li></ul><hr><h4 id="AWS-Lake-Formation"><a href="#AWS-Lake-Formation" class="headerlink" title="AWS Lake Formation"></a>AWS Lake Formation</h4><ul><li>Managed services to setup Data Lake (数据湖)<ul><li>Central place to have all data for analytics purpose</li><li>注意, 如果题目里提到 Fine-grained Access Control for application, 就要想起 Lake Foramtion</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img224948.png"></p><hr><h4 id="Kinesis-Data-Analytics"><a href="#Kinesis-Data-Analytics" class="headerlink" title="Kinesis Data Analytics"></a>Kinesis Data Analytics</h4><ul><li>Real-time analytics on Kinesis Data Streams &amp; Firehose using SQL (重要)<ul><li>Fully managed, auto-scaling, serverless</li><li>以 Kinesis Data Streams &amp; Firehose 作为目标使用 SQL 进行数据分析</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img225813.png"></p><ul><li>Amazon Managed Service for Apache Flink</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img225906.png"></p><hr><h4 id="AWS-MSK"><a href="#AWS-MSK" class="headerlink" title="AWS MSK"></a>AWS MSK</h4><ul><li>Managed Apache Kafka on AWS (Have Serverless)<ul><li>Kinesis 的代替 (同样处理 Stream data), 但是针对 Apache Kafka</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img230056.png"></p><ul><li>Kinesis Data Streams (第十五章) vs AWS MSK</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img230216.png"></p><hr><h3 id="20-Machine-Learning"><a href="#20-Machine-Learning" class="headerlink" title="20. Machine Learning"></a>20. Machine Learning</h3><h4 id="AWS-Rekognition"><a href="#AWS-Rekognition" class="headerlink" title="AWS Rekognition"></a>AWS Rekognition</h4><ul><li>Find object, people, text, scenes in images and videos using ML (识别物品)</li><li>Facial analysis and facial search</li><li>Content Moderation: Detect content that is inappropriate (重要)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img004131.png"></p><hr><h4 id="AWS-Transcribe"><a href="#AWS-Transcribe" class="headerlink" title="AWS Transcribe"></a>AWS Transcribe</h4><ul><li>Convert speech to text (语音转文字, Transcribe 是转录的意思)</li><li>Automatically remove Personally Identifiable Information (PII, 重要)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img004337.png"></p><hr><h4 id="AWS-Polly"><a href="#AWS-Polly" class="headerlink" title="AWS Polly"></a>AWS Polly</h4><ul><li>Convert text to speech (文字转语音)</li><li>Pronunciation Lexicons: Customize the pronunciation of words</li><li>Speech Synthesis Markup Language (SSML): Emphasize words (小声)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img004547.png"></p><hr><h4 id="AWS-Translate"><a href="#AWS-Translate" class="headerlink" title="AWS Translate"></a>AWS Translate</h4><ul><li>Language translation (翻译)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img004816.png"></p><hr><h4 id="AWS-Lex-amp-Connect"><a href="#AWS-Lex-amp-Connect" class="headerlink" title="AWS Lex &amp; Connect"></a>AWS Lex &amp; Connect</h4><ul><li>AWS Lex: Build chatbot (所有和 chatbot 有关的都是 Lex)</li><li>AWS Connect: Build cloud contact center</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img004954.png"></p><hr><h4 id="AWS-Comprehend"><a href="#AWS-Comprehend" class="headerlink" title="AWS Comprehend"></a>AWS Comprehend</h4><ul><li>Natural Language Processing (NLP)</li><li>Comprehend Medical: for clinical text (医疗方面, 非常重要)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img005107.png"></p><hr><h4 id="AWS-SageMaker"><a href="#AWS-SageMaker" class="headerlink" title="AWS SageMaker"></a>AWS SageMaker</h4><ul><li>Build ML models (建 ML 模型)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img005342.png"></p><hr><h4 id="AWS-Forecast"><a href="#AWS-Forecast" class="headerlink" title="AWS Forecast"></a>AWS Forecast</h4><ul><li>Use ML to deliver highly accurate forecasts (做预测用的)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img012641.png"></p><hr><h4 id="AWS-Kendra"><a href="#AWS-Kendra" class="headerlink" title="AWS Kendra"></a>AWS Kendra</h4><ul><li>Managed document search service (文档查找)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img012746.png"></p><hr><h4 id="AWS-Personalize"><a href="#AWS-Personalize" class="headerlink" title="AWS Personalize"></a>AWS Personalize</h4><ul><li>ML with real-time personalized recommendations (做推荐用的)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img012921.png"></p><hr><h4 id="AWS-Textract"><a href="#AWS-Textract" class="headerlink" title="AWS Textract"></a>AWS Textract</h4><ul><li>ML to extract text (提取文字用的, 重要)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img013008.png"></p><hr><h3 id="21-AWS-Mointoring-amp-Audit"><a href="#21-AWS-Mointoring-amp-Audit" class="headerlink" title="21. AWS Mointoring &amp; Audit"></a>21. AWS Mointoring &amp; Audit</h3><h4 id="CloudWatch-Metrics"><a href="#CloudWatch-Metrics" class="headerlink" title="CloudWatch Metrics"></a>CloudWatch Metrics</h4><ul><li>CloudWatch Metrics helps to monitor every services in AWS</li><li>可以用 CloudWatch Metrics 处理 CloudTrail logs 来监视异常</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img150021.png"></p><ul><li>CloudWatch Metric Streams<ul><li>Stream CloudWatch Metrics with near-real-time delivery (注意)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img150150.png"></p><hr><h4 id="CloudWatch-Logs"><a href="#CloudWatch-Logs" class="headerlink" title="CloudWatch Logs"></a>CloudWatch Logs</h4><ul><li>A place to store application logs in AWS (S3, Kinesis, Lambda)<ul><li>Logs are encrypted by default</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img150343.png"></p><ul><li>CloudWatch Logs Insights<ul><li>Search and analyze log data stored in CloudWatch Logs</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img150531.png"></p><ul><li>CloudWatch Logs Subscriptions (可以 Export 给 S3)<ul><li>Get a real-time log events from CloudWatch Logs for processing and analysis</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img150643.png"></p><blockquote><p>You can configure a CloudWatch Logs log group to stream data it receives to your Amazon OpenSearch Service cluster in NEAR REAL-TIME through a CloudWatch Logs subscription</p></blockquote><hr><h4 id="CloudWatch-Agent"><a href="#CloudWatch-Agent" class="headerlink" title="CloudWatch Agent"></a>CloudWatch Agent</h4><ul><li>可以把 EC2 的 log 传递给 CloudWatch (By default, EC2 不传递 log, 重要)</li><li>CloudWatch Logs Agent: 传递给 CloudWatch</li><li>CloudWatch Unified Agent: 可以传递更多信息, 比如 CPU, RAM 等等</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img151251.png"></p><hr><h4 id="CloudWatch-Alarms"><a href="#CloudWatch-Alarms" class="headerlink" title="CloudWatch Alarms"></a>CloudWatch Alarms</h4><ul><li>CloudWatch Alarms are used to trigger notifications for any metric (用 SNS 发消息)<ul><li>比如 EC2 的 Health 出问题</li><li>Target: EC2, ASG, SNS</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img151423.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img151514.png"></p><ul><li>Composite Alarams (监视当前所有 Alarm 的情况)<ul><li>Composite Alarams are mointoring the states of multiple other alarms</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img151615.png"></p><hr><h4 id="AWS-EventBridge"><a href="#AWS-EventBridge" class="headerlink" title="AWS EventBridge"></a>AWS EventBridge</h4><ul><li>Schedule CRON jobs (Jobs on a repeating schedule, event-driven)</li><li>React to events from SaaS application (AWS services)<ul><li>如果提到 3rd party application, 考虑 EventBridge</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img185605.png"></p><ul><li>基本上所有 event 都要经过 EventBridge</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img185712.png"></p><ul><li>Event Bus (Replay archived events, 注意)<ul><li>有 Default Event Bus 和 Partner Event Bus (Datadog)</li><li>可以 Archive Events 并且 Replay (Good for debug)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img190403.png"></p><ul><li>Schema Registry<ul><li>Analyze events in Event Bus and infer schema</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img190004.png"></p><ul><li>Resource-based Policy<ul><li>Manage permissions (allow &#x2F; deny) for a specific Event Bus</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img190215.png"></p><hr><h4 id="CloudWatch-Insights"><a href="#CloudWatch-Insights" class="headerlink" title="CloudWatch Insights"></a>CloudWatch Insights</h4><ul><li>这里的 CloudWatch Insights 有好几种不同的 Insights (4 种)<ul><li>Container, Lambda, Contributor, Application</li></ul></li><li>CloudWatch Container Insights (处理 Container 容器的)<ul><li>Collect, aggregate, summarize metrics and logs from container</li><li>ECS, EKS, Kubernetes, Fargate 等等</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img190651.png"></p><ul><li>CloudWatch Lambda Insights<ul><li>Monitoring solutions for serverless application running on Lambda</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img190750.png"></p><ul><li>CloudWatch Contributor Insights (注意, 可以查 IP)<ul><li>Analyze log data and display contributor data (for system performance)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img190854.png"></p><ul><li>CloudWatch Application Insights<ul><li>Provide dashboard to show the potential application issue related to AWS service</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img191050.png"></p><hr><h4 id="AWS-CloudTrail"><a href="#AWS-CloudTrail" class="headerlink" title="AWS CloudTrail"></a>AWS CloudTrail</h4><ul><li>Provide governance, compliance and audit for AWS account (审计 events 和 API call)<ul><li>比如 History of events 或者 API calls</li></ul></li><li>CloudTrail 是 Global Service, 如果东西被误删, 第一时间看 CloudTrail</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img191802.png"></p><ul><li>CloudTrail Events<ul><li>Management Events: Performed on resources in AWS account</li><li>Data Events: S3 object-level activity (GetObject, DeleteObject)</li><li>CloudTrail Insigths Events: Detect unusual activity (安全)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img192042.png"></p><ul><li>CloudTrail Insights (重要)<ul><li>CloudTaril Insights to detect unusual activity in account</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img192157.png"></p><ul><li>CloudTrail Event Retention (保存 events)<ul><li>Keep events to S3 after they stored 90 days</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img192301.png"></p><hr><h4 id="AWS-Config"><a href="#AWS-Config" class="headerlink" title="AWS Config"></a>AWS Config</h4><ul><li>AWS Config provides a detailed view of the configuration of AWS resources (重要)<ul><li>Record configurations and changes over time (记录 config 是否被修改)</li></ul></li><li>可以用 Config 去检查 ACM 的 certificate 有没有临近过期</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img192656.png"></p><ul><li>Config Rules: 可以自定义 Rule 来检查 (也有 AWS managed rules, 比如下面两个)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img045705.png"></p><ul><li>Config Remediations <ul><li>Automate remediation (纠正) of non-compliant resource using SSM Automation Documents (eg. unrestricted SSH access)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img192951.png"></p><ul><li>Config Notifications<ul><li>Use EventBridge to trigger notifications when AWS resources are noncompliant</li><li>相当于当有不合规的 Resource 出现时, 可以 Trigger Notifications</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img193119.png"></p><hr><h3 id="22-IAM-Advanced"><a href="#22-IAM-Advanced" class="headerlink" title="22. IAM Advanced"></a>22. IAM Advanced</h3><h4 id="AWS-Organizations"><a href="#AWS-Organizations" class="headerlink" title="AWS Organizations"></a>AWS Organizations</h4><ul><li>Manage multiple AWS accounts, global service</li><li>Consolidated Billing across all accounts (合并账单, 重要)<ul><li>如果问到和 Shield Advance 有关的钱的问题, 那就是没有设置 Consolidated Billing</li></ul></li><li>Shared reserved instance and Saving Plans discounts across accounts (重要)</li><li>如果要把一个 Account 转到另一个 Organization, 要先把它从原来的 Organization 移除</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img235557.png"></p><ul><li>Service Control Policies (SCP, 限制用户)<ul><li>IAM policies applied to OU (Organization Unit) or Accounts to restrict Users and Roles (Blocklist and Allowlist)</li><li>IAM Roles 是针对 Service, SCP 针对 Organization</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img013921.png"></p><ul><li><p>IAM Permission Boundary (回去看第二章)</p><ul><li>A permissions boundary is an advanced feature for using a managed policy to set the maximum permissions that an identity-based policy can grant to an IAM entity.</li></ul></li><li><p>Service Control Policies (SCPs)</p><ul><li>If a user or role has an IAM permission policy that grants access to an action that is either not allowed or explicitly denied by the applicable service control policy (SCP), the user or role can’t perform that action</li><li>Service control policy (SCP) affects all users and roles in the member accounts, including root user of the member accounts</li><li>Service control policy (SCP) does not affect service-linked role</li></ul></li></ul><hr><h4 id="IAM-Conditions"><a href="#IAM-Conditions" class="headerlink" title="IAM Conditions"></a>IAM Conditions</h4><ul><li>要分清楚 bucket level permissions 和 object level permissions (&#x2F;*)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img022652.png"></p><hr><h4 id="IAM-Roles-vs-Resource-Based-Policies"><a href="#IAM-Roles-vs-Resource-Based-Policies" class="headerlink" title="IAM Roles vs Resource Based Policies"></a>IAM Roles vs Resource Based Policies</h4><ul><li>Role: Give up original permissions and take the permissions assigned to the Role</li><li>Resource Based Policy: The principal doesn’t have to give up permissions</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img015940.png"></p><ul><li>EventBridge 例子<ul><li>Resource based policy: Lambda, SNS, SQS 等等</li><li>IAM Roles: Kinesis stream, ECS 等等</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img023321.png"></p><hr><h4 id="Policy-Evaluation-Logic"><a href="#Policy-Evaluation-Logic" class="headerlink" title="Policy Evaluation Logic"></a>Policy Evaluation Logic</h4><ul><li>IAM Permission Boundaries<ul><li>A feature to set the maximum permissions an IAM entity can get</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img020209.png"></p><ul><li>答案 No, No, No (Evaluate 逻辑是先来后到, 先 Deny 就算后面 Allow 也没有用)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img161535.png"></p><hr><h4 id="IAM-Identity-Center"><a href="#IAM-Identity-Center" class="headerlink" title="IAM Identity Center"></a>IAM Identity Center</h4><ul><li>One login for all (SSO) <ul><li>AWS accounts in AWS Organizations</li><li>Business cloud applications (Salesforce)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img020909.png"></p><ul><li>Fine-grained Permissions and Assignments<ul><li>Multi-Account Permissions: Manage access across AWS accounts</li><li>Application Assignments: SSO access to business applications</li><li>Attribute-Based Access Control (ABAC): Permission based on user’s attribute (tags)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img021246.png"></p><hr><h4 id="AWS-Directory-Services"><a href="#AWS-Directory-Services" class="headerlink" title="AWS Directory Services"></a>AWS Directory Services</h4><ul><li>Create Active Directory (AD, 目录服务) in AWS (重要)<ul><li>AWS Managed Microsoft AD: Create own AD in AWS </li><li>AD Connector: Proxy to redirect to On-Premise AD</li><li>Simple AD: AD-compatible managed directory on AWS</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img021607.png"></p><hr><h4 id="AWS-Control-Tower"><a href="#AWS-Control-Tower" class="headerlink" title="AWS Control Tower"></a>AWS Control Tower</h4><ul><li>Set up and govern a secure and compliant multi-account AWS environment (重要)<ul><li>管理 AWS 多账户环境, 而且是 Best Practice</li></ul></li><li>ControlTower use AWS Organizations to create accounts</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img021857.png"></p><ul><li>ControlTower - Guardrails (管理 ControlTower)<ul><li>Preventive Guardrail: Use SCPs (Restrict REgions across all accounts)</li><li>Detective Guardrail: Use AWS Config (identify untagged resources)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img022019.png"></p><hr><h3 id="23-AWS-Security-amp-Encryption"><a href="#23-AWS-Security-amp-Encryption" class="headerlink" title="23. AWS Security &amp; Encryption"></a>23. AWS Security &amp; Encryption</h3><h4 id="AWS-KMS"><a href="#AWS-KMS" class="headerlink" title="AWS KMS"></a>AWS KMS</h4><ul><li>Anytime you hear “encryption” for an AWS service, it’s most likely KMS</li><li>AWS managed encryption keys for us (Integrated with most AWS services)<ul><li>比如 EBS, S3, RDS, SSM (AWS managed keys),</li></ul></li><li>KMS Keys are scoped per Region</li><li>注意, KMS 并不适合保存 secret, 加密的东西不一定是 secret</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img170646.png"></p><ul><li>Types of KMS Keys (3 种): AWS Owned, AWS Managed, CMK (Custom Managed)</li><li>两种 Key 的形式: Symmetric (Single) &amp; Asymmetric (Public &amp; Private)</li><li>Automatic Key Rotation: 1 year</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img171058.png"></p><ul><li>KMS Key Policies (Control access to KMS keys)<ul><li>Default KMS Key Policy: Entire AWS account</li><li>Custom KMS Key Policy: Define who can access the key (Cross Account Access)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img171356.png"></p><blockquote><p>Deleting an AWS KMS key in AWS Key Management Service (AWS KMS) is destructive and potentially dangerous. Therefore, AWS KMS enforces a waiting period. (Pending state)</p></blockquote><hr><h4 id="KMS-Multi-Region-Keys"><a href="#KMS-Multi-Region-Keys" class="headerlink" title="KMS Multi-Region Keys"></a>KMS Multi-Region Keys</h4><ul><li>Identical KMS keys in different AWS Regions (在其他 Region 也能用同样的 KMS Key)<ul><li>Encrypt in one Region and decrypt in other Regions</li></ul></li><li>Use cases: DynamoDB Global Tables &amp; Global Aurora</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img172433.png"></p><hr><h4 id="S3-Replication-with-Encryption"><a href="#S3-Replication-with-Encryption" class="headerlink" title="S3 Replication with Encryption"></a>S3 Replication with Encryption</h4><ul><li>Unencrypted objects and objects encrypted with SSE-S3 are replicated by default</li><li>For objects encrypted with SSE-KMS, you need more options<ul><li>也就是说 SSE-S3 在复制的时候会保持, 但是 SSE-KMS 需要设置</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img172816.png"></p><hr><h4 id="Encrypted-AMI-Sharing-Process"><a href="#Encrypted-AMI-Sharing-Process" class="headerlink" title="Encrypted AMI Sharing Process"></a>Encrypted AMI Sharing Process</h4><ul><li>需要 Launch Permission, 需要 Share KMS Keys, 需要 Permission to decrypte<ul><li>反正只要知道 AMI 也是可以 Encrypt 并 Share 的</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img173020.png"></p><hr><h4 id="SSM-Parameter-Store"><a href="#SSM-Parameter-Store" class="headerlink" title="SSM Parameter Store"></a>SSM Parameter Store</h4><ul><li>Secure storage for configuration and secrets <ul><li>比起 Secrets Manager 有更广的用途, 比如 URLs, AMI IDs, License keys 等等</li></ul></li><li>Have built-in verion tracking (每次 edit secret 都会被记录)</li><li>SSM 没有 Automatic key rotation (重要)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img173611.png"></p><hr><h4 id="AWS-Secrets-Manager"><a href="#AWS-Secrets-Manager" class="headerlink" title="AWS Secrets Manager"></a>AWS Secrets Manager</h4><ul><li>Store secrets, integrated with RDS &amp; Aurora (非常重要, 存数据库 secrets 的)<ul><li>是给 confidential information (like database credentials, API keys) 用的</li><li>比起 SSM Parameter Store, Secrets Manager 支持 Key 的轮换 (90 天)</li><li>注意, Secret Manager 的 Key Rotateion 是 90 天, KMS 的 Key Rotateion 是一年</li></ul></li><li>比起 KMS, Secrets Manager 更适合去保存 secret, 比如 database credential, 而且 Secrets Manager 也有 Automatic key rotation</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img174132.png"></p><ul><li>Multi-Region Secrets (和 Multi-Region Key 类似)<ul><li>Replicate Secrets across multiple AWS Regions (disaster recovery)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img174258.png"></p><hr><h4 id="AWS-Certificate-Manager-ACM"><a href="#AWS-Certificate-Manager-ACM" class="headerlink" title="AWS Certificate Manager (ACM)"></a>AWS Certificate Manager (ACM)</h4><ul><li>Easily provision, manage, and deploy TLS Certificates (HTTPS)<ul><li>如果你要给 EB 上 HTTPS 就要用到 ACM</li><li>如果是 third party SSL 就没办法使用 automatic certificate rotation</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img174451.png"></p><ul><li>可以用 EventBridge 来检查 ACM Certificates 是否过期 (过期 Invoke SNS)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img172923.png"></p><hr><h4 id="AWS-WAF"><a href="#AWS-WAF" class="headerlink" title="AWS WAF"></a>AWS WAF</h4><ul><li>WAF: Web Application Firewall (防火墙)</li><li>Protect web application in Layer 7 (HTTP &#x2F; HTTPS)<ul><li>Layer 4 是 TCP &#x2F; UDP, Layer 3 处理 VPC 之类的</li></ul></li><li>如果要 block countries, 可以用 WAF Geo Match 或者 WAF IP Set Statement (重要)</li><li>WAF 可以设置 rate-based rules, Shield 不可以</li><li>如果需要在不同的 accout 或者 region 用 WAF, 考虑 Firewall Manager (重要)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img174857.png"></p><ul><li>Web ACL: 可以根据 IP, HTTP Headers, Size 来决定谁可以 Access<ul><li>也就是说, WAF 可以 block access from certain countries</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img175006.png"></p><blockquote><p>If you want to use AWS WAF across accounts, accelerate WAF configuration, automate the protection of new resources, use Firewall Manager with AWS WAF</p></blockquote><hr><h4 id="AWS-Shield"><a href="#AWS-Shield" class="headerlink" title="AWS Shield"></a>AWS Shield</h4><ul><li>Protect from DDoS attack (WAF 也可以, 但是考试遇到 DDoS 的时候选 Shield)</li><li>有 Shield Standard (免费) 和 Shield Advanced (付费)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img175302.png"></p><hr><h4 id="AWS-Firewall-Manager"><a href="#AWS-Firewall-Manager" class="headerlink" title="AWS Firewall Manager"></a>AWS Firewall Manager</h4><ul><li>Manage security rules in all accounts of an AWS Organization<ul><li>比如 WAF rules, AWS Shield Advanced, Security Group for EC2 &amp; VPC 等等</li></ul></li><li>Rules are applied to new resources as they are created</li><li>如果需要在不同的 accout 或者 region 用 WAF, 考虑 Firewall Manager (重要)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img175531.png"></p><ul><li>WAF vs Firewall Manager vs Shield<ul><li>它们一起用来做大型安全保护 (WAF + Firewall Manager + Shield)</li><li>如果只是日常保护, 就用 WAF</li><li>如果遇到 DDoS 攻击, 考虑使用 Shield</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img175631.png"></p><hr><h4 id="AWS-GuardDuty"><a href="#AWS-GuardDuty" class="headerlink" title="AWS GuardDuty"></a>AWS GuardDuty</h4><ul><li>Intelligent threat discovery (ML) to protect AWS account (用 ML 防止加密攻击)<ul><li>Input data: CloudTrail, VPC, DNS (重要)</li></ul></li><li>Use case: CryptoCurrency attacks</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img175935.png"></p><hr><h4 id="AWS-Inspector"><a href="#AWS-Inspector" class="headerlink" title="AWS Inspector"></a>AWS Inspector</h4><ul><li>Automated Security Assessments (自动安全评估)<ul><li>EC2 Instance &amp; Container Images (ECR) &amp; Lambda Functions</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img180110.png"></p><hr><h4 id="AWS-Macie"><a href="#AWS-Macie" class="headerlink" title="AWS Macie"></a>AWS Macie</h4><ul><li>Use ML to protect sensitive data (PII) in AWS (用 ML 保护敏感信息)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img180224.png"></p><hr><h3 id="24-Networking-VPC"><a href="#24-Networking-VPC" class="headerlink" title="24. Networking VPC"></a>24. Networking VPC</h3><ul><li>CIDR &#x3D; Base IP + Subnet Mask<ul><li>例子: CIDR 10.0.4.0&#x2F;28, &#x2F;28 代表 16 IPs &#x3D; (2^(32-28) &#x3D; 2^4), 8 的倍数大过28只有32, 所以答案是10.0.4.0到10.0.4.15 (0-15 一共有16个)</li></ul></li><li>CIDR should not overlap, max CIDR size in AWS is &#x2F;16, min CIDR size in AWS is &#x2F;28</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img002822.png"></p><hr><h4 id="AWS-VPC"><a href="#AWS-VPC" class="headerlink" title="AWS VPC"></a>AWS VPC</h4><ul><li>VPC: Virtual Private Cloud<ul><li>All new AWS account have a default VPC</li></ul></li><li>CIDR should not overlap, max CIDR size in AWS is &#x2F;16, min CIDR size in AWS is &#x2F;28</li><li>要让 VPC 使用 custom domain 需要 enableDnsHostnames 和 enableDnsSupport</li><li>可以创建 Shared Service VPC, 这样每个 VPC 都可以 access 到需要的 services (重要)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img201530.png"></p><ul><li>Each Amazon EC2 instance that you launch into a VPC has a tenancy attribute (重要)<ul><li>可以在 dedicated 和 host 之间互相切换</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img042420.png"></p><hr><h4 id="VPC-Subnet"><a href="#VPC-Subnet" class="headerlink" title="VPC Subnet"></a>VPC Subnet</h4><ul><li>Can have Public Subnet and Private Subnet</li><li>AWS reserves 5 IP addresses in each subnet (first 4 &amp; last 1, 重要)<ul><li>记得前四个是从 0 开始算的, 也就是 0 - 3</li><li>比如我要做一个可以处理 28 个的, 我需要 28 + 5 + 26 + 5 &#x3D; 64</li></ul></li><li>Subnet is always associated with Route Table (重要)<ul><li>问关于 Subnet 的问题就和 Route Table 没有关系</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img201819.png"></p><hr><h4 id="Internet-Gateway-IGW-amp-Route-Table"><a href="#Internet-Gateway-IGW-amp-Route-Table" class="headerlink" title="Internet Gateway (IGW) &amp; Route Table"></a>Internet Gateway (IGW) &amp; Route Table</h4><ul><li>IGW allow resource (eg. EC2 Instance) in a VPC connect to internet<ul><li>相当于让 VPC 里的 resource 可以连上网</li><li>IGW 需要 Route Table (重要)</li></ul></li><li>如果 IGW 出问题<ul><li>Need to also have Route Table (首先检查 Route Table, 因为 IGW 需要)</li><li>检查 Security Group 是否允许通过</li></ul></li><li>处理 Network Address Translation 的就是 Internet Gateway</li><li>Internet Gateway 无法直接在 private subnet 里面使用 (重要)</li><li>NAT 针对的是 Subnet 层面, IGW 针对的是 VPC 层面 (重要)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img202043.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img193121.png"></p><hr><h4 id="Bastion-Hosts"><a href="#Bastion-Hosts" class="headerlink" title="Bastion Hosts"></a>Bastion Hosts</h4><ul><li>Use Bastion Host to SSH into private EC2 instance (SSH 进入 EC2)</li><li>Bastion Host is in the public subnet and is connected to the private subnet<ul><li>简单来说就是 Public Internet 到 Private Subnet</li></ul></li><li>Bastion Host security group must restrict internet access (port 22)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img202553.png"></p><blockquote><p>Create a public Network Load Balancer that links to Amazon EC2 instances that are bastion hosts managed by an Auto Scaling Group</p></blockquote><hr><h4 id="NAT-Instances-Outdated"><a href="#NAT-Instances-Outdated" class="headerlink" title="NAT Instances (Outdated)"></a>NAT Instances (Outdated)</h4><ul><li>NAT: Network Address Translation</li><li>Allow EC2 Instance in Private Subnet to connect to the Internet<ul><li>但现在都是用 NAT Gateway (NAT Gateway is the prefered solution now)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img202940.png"></p><ul><li>NAT instance can be used as a bastion server</li><li>Security Groups can be associated with a NAT instance</li><li>NAT instance supports port forwarding</li></ul><hr><h4 id="NAT-Gateway-NATGW"><a href="#NAT-Gateway-NATGW" class="headerlink" title="NAT Gateway (NATGW)"></a>NAT Gateway (NATGW)</h4><ul><li>AWS managed NAT, AZ specific, use Elastic IP (针对 IPv4, Egress 是 IPv6)<ul><li>Allow EC2 Instance in Private Subnet to connect to the Internet</li><li>Requires an IGW, NATGW 是处于 public subnet 的 (注意)</li></ul></li><li>NAT 针对的是 Subnet 层面, IGW 针对的是 VPC 层面</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img203409.png"></p><ul><li>Resilient within single AZ, Multiple-AZ need multiple NATGW <ul><li>每个 AZ 都要一个 NATGW, 用来 fault-tolerance (容错能力)</li></ul></li><li>Highly availiable within AZ (create in another AZ)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img203654.png"></p><hr><h4 id="NACL-amp-Security-Groups"><a href="#NACL-amp-Security-Groups" class="headerlink" title="NACL &amp; Security Groups"></a>NACL &amp; Security Groups</h4><ul><li>The request has to go over NACL before go to Subnet (Subnet level)<ul><li>NACL is stateless (inbound outbound 都要检测)</li></ul></li><li>The request has to go over Security Group before go to EC2 Instance (Instance level)<ul><li>Security Group (SG) is stateful (inbound accepted &#x3D; outbound accepted)</li></ul></li><li>反正记住 NACL 是 Subnet level (stateless), Security Group 是 Instance level (stateful)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img204310.png"></p><ul><li>Network Access Control List (NACL)<ul><li>NACL control traffic from and to subnets (eg. block IP)</li><li>One NACL per subnet, each subnet have default NACL (注意)<ul><li>Default NACL accept every inbound and outbound</li></ul></li><li>NACL Rules have number, higher precedence with lower number (越优先数字越低)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img204553.png"></p><hr><h4 id="VPC-Peering-amp-Sharing"><a href="#VPC-Peering-amp-Sharing" class="headerlink" title="VPC Peering &amp; Sharing"></a>VPC Peering &amp; Sharing</h4><ul><li>VPC Peering: Privately connect two VPCs using AWS network (只适合少量 VPC, 重要)<ul><li>每一对 VPC 都要 VPC Peering, 和 S3 Replication 类似</li></ul></li><li>Can create VPC Peering between VPCs in different AWS accounts &#x2F; regions</li><li>Need to update Route Table in each VPC subnet to make sure they can communicate<ul><li>出问题就检查 Route Table</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img205313.png"></p><ul><li>VPC Sharing: Allows multiple AWS accounts to create resources (eg. EC2, RDS) into shared and centrally-managed AWS VPC (重要)<ul><li>遇到 centrally managed 的就是 VPC Sharing</li><li>而且是 owner 需要 share one or more subnet (注意)</li></ul></li></ul><hr><h4 id="VPC-Endpoints-AWS-PrivateLink"><a href="#VPC-Endpoints-AWS-PrivateLink" class="headerlink" title="VPC Endpoints (AWS PrivateLink)"></a>VPC Endpoints (AWS PrivateLink)</h4><ul><li>VPC Endpoints allow private access to AWS services within a VPC (重要)<ul><li>用 Private Network 连接 AWS 服务, 和 On-Premise 没有关系</li><li>Interface Endpoint 支持大部分 AWS 服务 (付费)</li><li>Gateway Endpoint 只支持 S3 和 DynamoDB (很容易考, 免费)</li></ul></li><li>注意, VPC Gateway Endpoint 专门处理 S3 和 DynamoDB (不要去选择 NAT 或者 IGW)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img205719.png"></p><ul><li>两种 Types of Endpoints (Interface &#x2F; Gateway)<ul><li>Interface Endpoints: Supports most AWS services (付费)</li><li>Gateway Endpoints: Must be used as a target in a route table (免费, 重要)<ul><li>Only support S3 and DynamoDB (只支持 S3 和 DynamoDB)</li></ul></li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img205939.png"></p><hr><h4 id="VPC-Flow-Logs"><a href="#VPC-Flow-Logs" class="headerlink" title="VPC Flow Logs"></a>VPC Flow Logs</h4><ul><li>Capture information about IP traffic going into interfaces (监视 IP 流量的)<ul><li>Monitor &amp; troubleshoot connectivity issues (网络连接问题)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img231819.png"></p><hr><h4 id="Site-to-Site-VPN-VPN-Connection"><a href="#Site-to-Site-VPN-VPN-Connection" class="headerlink" title="Site-to-Site VPN (VPN Connection)"></a>Site-to-Site VPN (VPN Connection)</h4><ul><li>Site-to-Site VPN: Connect AWS to Corporate Data Center over public internet (重点, public internet, On-Premise to AWS)<ul><li>Need a Virtual Private Gateway (VGW) on VPC (AWS 方)</li><li>Need a Customer Gateway (CGW) on DC (On-Premise 方)</li></ul></li><li>对比 DX, Site-to-Site VPN 没有提供 low latency, and high throughput connection</li><li>Site-to-Site VPN 有 encrypted network connectivity between On-Premise and VPC</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img232320.png"></p><ul><li>需要 VPN Gateway 和 Customer Gateway 来连接 VPC 和 On-Premise</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img232649.png"></p><hr><h4 id="VPN-CloudHub"><a href="#VPN-CloudHub" class="headerlink" title="VPN CloudHub"></a>VPN CloudHub</h4><ul><li>Provide secure communication for multiple VPN Connections (Site-to-Site VPN)<ul><li>在需要管理多个 Site-to-Site VPN 的时候</li><li>可以作为 backup connection 使用 public internet 去防止 failover</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img202141.png"></p><blockquote><p>If you have multiple AWS Site-to-Site VPN connections, you can provide secure communication between sites using the AWS VPN CloudHub.</p></blockquote><hr><h4 id="Direct-Connect-DX"><a href="#Direct-Connect-DX" class="headerlink" title="Direct Connect (DX)"></a>Direct Connect (DX)</h4><ul><li>Provide a dedicated private connection from a remote network to VPC (重点, private internet, On-Premise to AWS)<ul><li>需要设置 VGW, 如果给 DX 找 backup, 那么就选择 Site-to-Site VPN (这两个服务类似)</li><li>对比 Site-to-Site VPN, DX provide low latency, and high throughput connection</li><li>DX 不支持 encrypted network connectivity, Site-to-Site VPN 可以, 但是如果需要 encrypt DX connection 可以和 AWS VPN 一起用 (注意)</li><li>DX 的 set up 时间很长 (所以 DX 不算什么 quick solution)</li></ul></li><li>All private, no public network involve (注意, 如果问到 all Private 就是 DX)<ul><li>Direct Connect does not involve the Internet</li></ul></li><li>可以 access public resources (S3) 和 private resources (EC2)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img233024.png"></p><ul><li>两种 Connection Type (带宽选项, Dedicated 最快)<ul><li>Dedicated Connections: 1Gbps 到 100Gbps</li><li>Hosted Connections: 50Mbps 到 10 Gbps</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img004140.png"></p><ul><li>Direct Connect Gateway (连接许多 VPC 在不同的 Region)<ul><li>Direct Connection to one or more VPC in many different regions</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img233531.png"></p><ul><li>PrivateLink vs DX<ul><li><p>AWS PrivateLink provides a connection between VPCs (Virtual Private Clouds) and AWS services while bypassing the public Internet. It is a private network connection that securely transfers data without leaving the AWS network</p></li><li><p>AWS Direct Connect is a dedicated, private connection between the customer’s on-premises infrastructure at a data center and an AWS location. The main features of the connection are ultra-fast data transfer rates, low latency, and improved security since it bypasses the public Internet</p></li></ul></li></ul><hr><h4 id="Transite-Gateway"><a href="#Transite-Gateway" class="headerlink" title="Transite Gateway"></a>Transite Gateway</h4><ul><li>Have transitive peering between thousands of VPCs, On-Premise 等等 (重要)<ul><li>Regional resource, 可以 Cross-Region (Transite Gateway 连接了大量的 VPC)</li><li>可以通过 ECMP 去 maximize the VPN throughput (重要)</li></ul></li><li>Support IP Multicast, IP 多播可以在单次传输中向一组感兴趣的接收者发送互联网协议</li><li>如果问到关于 star network 或者 hub-and-spoke 的就是 Transite Gateway</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img334237.png"></p><ul><li>Site-to-Site VPN ECMP (重要)<ul><li>ECMP &#x3D; Equal-cost multi-path routing (increase bandwidth)</li><li>路由策略, 将数据包转发到单个目的地可以通过具有相同路由优先级的多条最佳路径</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img234354.png"></p><hr><h4 id="VPC-Traffic-Mirroring"><a href="#VPC-Traffic-Mirroring" class="headerlink" title="VPC Traffic Mirroring"></a>VPC Traffic Mirroring</h4><ul><li>Capture and inspect network traffic in VPC (监测 VPC 网络流量)</li><li>Use cases: content inspection, threat monitoring 等等</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img002627.png"></p><hr><h4 id="IPv6-in-VPC"><a href="#IPv6-in-VPC" class="headerlink" title="IPv6 in VPC"></a>IPv6 in VPC</h4><ul><li>IPv4 cannot be disabled for VPC and subnets</li><li>Eg. EC2 Instance get at least 1 private IPv4 and a public IPv6<ul><li>所以如果无法启动 EC2 Instance, 那么 IPv4 一定有问题</li><li>Create a new IPv4 CIDR in subnet (注意)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img001017.png"></p><hr><h4 id="Egress-only-Internet-Gateway"><a href="#Egress-only-Internet-Gateway" class="headerlink" title="Egress-only Internet Gateway"></a>Egress-only Internet Gateway</h4><ul><li>Use for IPv6 only (Similar to NAT Gateway, but NATGW only for IPv4)<ul><li>只允许 outbound connection 从 VPC 到 Internet, 不允许 inbound 从 Internt 到 VPC</li><li>也需要 Update Route Table</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img001334.png"></p><hr><h4 id="AWS-Network-Firewall"><a href="#AWS-Network-Firewall" class="headerlink" title="AWS Network Firewall"></a>AWS Network Firewall</h4><ul><li>Protect entire AWS VPC (相当于 VPC 的防火墙, 千万要记住)<ul><li>From Layer 3 to Layer 7 protection (全方面, 重要)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img002037.png"></p><ul><li>Have traffic filtering: Allow, drop, or alert traffic that match the rules</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img002200.png"></p><ul><li>AWS Network Firewall is a managed firewall service that provides filtering for both inbound and outbound network traffic. It allows you to create rules for traffic inspection and filtering, which can help protect your production VPC</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img234322.png"></p><hr><h3 id="25-Disaster-Recovery-amp-Migrations"><a href="#25-Disaster-Recovery-amp-Migrations" class="headerlink" title="25. Disaster Recovery &amp; Migrations"></a>25. Disaster Recovery &amp; Migrations</h3><h4 id="Disaster-Recovery"><a href="#Disaster-Recovery" class="headerlink" title="Disaster Recovery"></a>Disaster Recovery</h4><ul><li>RPO: Recovery Point Objective (这段时间的数据丢失)</li><li>RTO: Recovery Time Objective (这段时间 App 停机)</li><li>遇到 DR 就应该去想 Multi-Region 的处理方法 (注意)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img002206.png"></p><ul><li>Disaster Recovery Startegies<ul><li>Backup and Restore: High RPO &amp; RTO, 将 On-Premise 数据备份在 Cloud 上</li><li>Pilot Light: 一部分 app 在 Cloud 上跑 (Only the critical infrastructure)<ul><li>注意, 遇到有提到 DR (Disaster Recovery) with minimum 的就是 Pilot Light</li></ul></li><li>Warm Standby: 一部分 app 在 Cloud 上跑 (Scale-down version, scale-up quickly)<ul><li>注意, 遇到有提到 DR (Disaster Recovery) with scale-down 的就是 Warm Standby</li></ul></li><li>Multi-Site: Every Low RTO &amp; RPO, 全部 app 在 Cloud 上跑 (最贵)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img142543.png"></p><hr><h4 id="Database-Migration-Service-DMS"><a href="#Database-Migration-Service-DMS" class="headerlink" title="Database Migration Service (DMS)"></a>Database Migration Service (DMS)</h4><ul><li>Migrate database to AWS (将数据库迁移到 AWS, 非常重要)</li><li>Support Homogeneous migration &amp; Heterogeneous migration<ul><li>Homogeneous 就是相同的数据库类型, Heterogeneous 就是不同的数据库类型</li></ul></li><li>Need to have an EC2 Instance to perform DMS to make it work</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img143551.png"></p><ul><li>AWS Schema Conversion Tool (SCT, 重要)<ul><li>Covert Database Schema from one engine to another (如果要迁移的数据库类型不同)</li><li>If same DB engine, don’t need SCT (比如 PostgreSQL 到 AWS RDS PostgreSQL)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img143914.png"></p><ul><li>DMS Multi-AZ Deployement<ul><li>DMS provisions and maintains a synchronously stand replica in different AZ</li><li>相当于你在数据库迁移的时候可以在另外一个 AZ 有一个备份</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img144109.png"></p><hr><h4 id="RDS-amp-Aurora-Migration"><a href="#RDS-amp-Aurora-Migration" class="headerlink" title="RDS &amp; Aurora Migration"></a>RDS &amp; Aurora Migration</h4><ul><li>RDS MySQL to Aurora MySQL (PostgreSQL 也是一样的道理)<ul><li>Op1. DB Snapshots from RDS MySQL restored as Aurora MySQL</li><li>Op2. Create Aurora Read Replica from RDS MySQL</li></ul></li><li>External MySQL to Aurora MySQL<ul><li>Op1. Create backup file in S3, and create Aurora MySQL from S3</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img144459.png"></p><hr><h4 id="On-Premise-Strategy-with-AWS"><a href="#On-Premise-Strategy-with-AWS" class="headerlink" title="On-Premise Strategy with AWS"></a>On-Premise Strategy with AWS</h4><ul><li>AWS Application Discovery Service (DS)</li><li>AWS Database Migration Service (DMS)</li><li>AWS Server Migration Service (SMS)</li><li>VM Import &amp; Export (以上这些都要依赖 On-Premise)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img145118.png"></p><hr><h4 id="AWS-Backup"><a href="#AWS-Backup" class="headerlink" title="AWS Backup"></a>AWS Backup</h4><ul><li>Fully managed service to automate backups across AWS services (做备份的, 重要)<ul><li>支持 EC2, EBS, S3, RDS, EFS 等等</li></ul></li><li>Support Cross-Region backups and Cross-Account backups</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img145310.png"></p><ul><li>AWS Backup Valut Lock (相当于给 backup 上锁)<ul><li>Enforce a WORM state for all backups (意思就是所有 backup 都删不了)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img145549.png"></p><hr><h4 id="Application-Migration-Service-MGN"><a href="#Application-Migration-Service-MGN" class="headerlink" title="Application Migration Service (MGN)"></a>Application Migration Service (MGN)</h4><ul><li>AWS Application Discovery Service (相当于在 MGN 之前要先做计划)<ul><li>Plan migration projects by gathering information about On-Premise data centers</li><li>有 Agentless Discovery 和 Agent-based Discovery</li></ul></li><li>Result is viewed in AWS Migration Hub</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img145820.png"></p><ul><li>AWS Application Migration Service (MGN)<ul><li>Simplify migrating applications to AWS (将 App 迁移到 AWS)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img145954.png"></p><hr><h4 id="VMware-Cloud-on-AWS"><a href="#VMware-Cloud-on-AWS" class="headerlink" title="VMware Cloud on AWS"></a>VMware Cloud on AWS</h4><ul><li>Use VMware Cloud to manage and extend On-Premise Data Center</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img150508.png"></p><hr><h3 id="26-More-SAA"><a href="#26-More-SAA" class="headerlink" title="26. More SAA"></a>26. More SAA</h3><h4 id="Event-Processing"><a href="#Event-Processing" class="headerlink" title="Event Processing"></a>Event Processing</h4><ul><li>Fan Out Pattern: Have SNS in the middle and subscribe to multiple SQS (重要)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img185229.png"></p><ul><li>S3 Event Notifications: Trigger Lambda or SNS when S3 event happen (在第十一章)<ul><li>如果遇到需要 set up DLQ (Dead Letter Queue), 选择 Lambda</li><li>DLQ 是处理当 message 没有办法被 processed (consumed) successfully</li></ul></li><li>也可以和 EventBridge 一起用, 有 advanced filtering<ul><li>EventBridge 可以和 CloudTrail 一起用来 Intercept API call</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img185348.png"></p><hr><h4 id="Caching-Strategies"><a href="#Caching-Strategies" class="headerlink" title="Caching Strategies"></a>Caching Strategies</h4><ul><li>Cache: 离用户越近越快, 但是可能 outdated, 所以需要 TTL (Time to Live)</li><li>API Gateway: Regional Caching (因为 API Gateway 是 Regional 的)</li><li>App Logic: 防止频繁调用数据库</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img185932.png"></p><hr><h4 id="Block-IP-Address"><a href="#Block-IP-Address" class="headerlink" title="Block IP Address"></a>Block IP Address</h4><ul><li>NACL: Decline the client IP</li><li>WAF: IP address filtering</li><li>总之, 可以用 NACL 在处理, 也可以用 WAF 处理 (二者选一, 但是一般选择 WAF)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img190513.png"></p><hr><h4 id="HPC-in-AWS"><a href="#HPC-in-AWS" class="headerlink" title="HPC in AWS"></a>HPC in AWS</h4><ul><li>Cloud is the perfect place to perform HPC (High Performance Computing)</li><li>Data Management &amp; Transfer (数据处理和迁移)<ul><li>AWS Direct Connect, Snowball, AWS DataSync</li></ul></li><li>提到 HPC 就应该想到 EFA, Cluster Placement, FSx Lustre</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img190820.png"></p><ul><li>Compute &amp; Networking<ul><li>EC2 Instance + EC2 Placement Group (Cluster, 因为 network 快)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img190944.png"></p><ul><li>Compute &amp; Networking (Cont.)<ul><li>EC2 Enhanced Networking (SR-IOV): 需要 Elastic Network Adapter (ENA)</li><li>Elastic Fabric Adapter (EFA): Improved ENA for HPC, only work for Linux</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img191112.png"></p><ul><li>Storage<ul><li>Instance-attached storage: EBS, Instance Store</li><li>Network storage: S3, EFS, FSx</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img191328.png"></p><ul><li>Automation &amp; Orchestration<ul><li>AWS Batch: Run multi-node pararllel jobs in multiple EC2 instances</li><li>AWS ParallelCluster: Deploy HPC on AWS, can enable EFA on cluster</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img191502.png"></p><hr><h4 id="EC2-Instance-High-Availability"><a href="#EC2-Instance-High-Availability" class="headerlink" title="EC2 Instance High Availability"></a>EC2 Instance High Availability</h4><ul><li>Elastic IP + Standby EC2 Instance + CloudWatch + Lambda<ul><li>当 failover, 转到 standby EC2 Instance</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img191841.png"></p><ul><li>Elastic IP + Auto Scaling Group (min, max)<ul><li>当 failover, 有 replacement EC2 Instance (不需要 CloudWatch 了)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img192115.png"></p><hr><h3 id="27-Other-AWS-Services"><a href="#27-Other-AWS-Services" class="headerlink" title="27. Other AWS Services"></a>27. Other AWS Services</h3><h4 id="AWS-CloudFormation"><a href="#AWS-CloudFormation" class="headerlink" title="AWS CloudFormation"></a>AWS CloudFormation</h4><ul><li>A declarative way of outlining AWS Infrastructure (相当于有一个模板帮你生成你想要的)<ul><li>需要什么 (eg. EC2 Instance, S3), CloudFormation 给你 create 什么</li><li>CloudFormation 是 IaaS (Infrastructure as a Service)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img003448.png"></p><ul><li>Infrastructure as a Service (IaaS, no need to manually create)</li><li>Good if we need to repeat architecture in different environment</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img003657.png"></p><hr><h4 id="CloudFormation-StackSets"><a href="#CloudFormation-StackSets" class="headerlink" title="CloudFormation StackSets"></a>CloudFormation StackSets</h4><ul><li>使用 StackSets, 如果需要 cross account 或者 region 去使用 CloudFormation</li><li>AWS CloudFormation StackSet extends the functionality of stacks by enabling you to create, update, or delete stacks across multiple accounts and regions with a single operation</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img013227.png"></p><hr><h4 id="CloudFormation-Service-Role"><a href="#CloudFormation-Service-Role" class="headerlink" title="CloudFormation Service Role"></a>CloudFormation Service Role</h4><ul><li>Service Role: IAM role that allows CloudFormation to create &#x2F; update &#x2F; delete resource</li><li>Give ability to user to do the above (安全方面)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img004103.png"></p><hr><h4 id="AWS-SES-Simple-Email-Service"><a href="#AWS-SES-Simple-Email-Service" class="headerlink" title="AWS SES (Simple Email Service)"></a>AWS SES (Simple Email Service)</h4><ul><li>Managed service to send email securely (发邮件的)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img004334.png"></p><hr><h4 id="AWS-Pinpoint"><a href="#AWS-Pinpoint" class="headerlink" title="AWS Pinpoint"></a>AWS Pinpoint</h4><ul><li>Scalable 2-way (outbound &#x2F; inbound) marketing communication serivce (重要)<ul><li>给客户发消息用的</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img004519.png"></p><hr><h4 id="AWS-SSM-Session-Manager"><a href="#AWS-SSM-Session-Manager" class="headerlink" title="AWS SSM Session Manager"></a>AWS SSM Session Manager</h4><ul><li>SSM Session Manager: Systems Manager Session Manager</li><li>Allow to start a secure shell on EC2 and On-Premise (更好的从 On-Premise access EC2)<ul><li>No need SSH access (Better security)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img004759.png"></p><hr><h4 id="AWS-Cost-Explorer"><a href="#AWS-Cost-Explorer" class="headerlink" title="AWS Cost Explorer"></a>AWS Cost Explorer</h4><ul><li>Visualize &amp; manage AWS costs and usage over time (可以生成消费报告)</li><li>Can choose a optimal Saving Plan</li><li>如果问和钱相关的很大程度就是 Cost Explorer (重要)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img005425.png"></p><hr><h4 id="AWS-Compute-Optimizer"><a href="#AWS-Compute-Optimizer" class="headerlink" title="AWS Compute Optimizer"></a>AWS Compute Optimizer</h4><ul><li>简单来说, Cost Explorer + Compute Optimizer 一起就是来省钱的</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img173241.png"></p><blockquote><p>AWS Compute Optimizer recommends optimal AWS Compute resources for your workloads to reduce costs and improve performance by using machine learning to analyze historical utilization metrics.</p></blockquote><hr><h4 id="AWS-Batch"><a href="#AWS-Batch" class="headerlink" title="AWS Batch"></a>AWS Batch</h4><ul><li>Managed batch processing at any scale (批量处理)<ul><li>Batch can dynamically launch EC2 Instance or Spot Instance</li></ul></li><li>Batch jobs are defined as Docker images and run on ECS</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img005610.png"></p><ul><li>Batch vs Lambda<ul><li>Lambda: Time limit, Serverless</li><li>Batch: No time limit, Not Serverless</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img005741.png"></p><hr><h4 id="AWS-AppFlow"><a href="#AWS-AppFlow" class="headerlink" title="AWS AppFlow"></a>AWS AppFlow</h4><ul><li>Transfer data between Software-as-a-Service (SaaS) applications and AWS (重要)<ul><li>如果题目问到 SaaS 就要想起 AppFlow</li><li>Source: Salesforce, Slack 等等 (遇到 SaaS 就是 AppFlow)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img005910.png"></p><hr><h4 id="AWS-Amplify"><a href="#AWS-Amplify" class="headerlink" title="AWS Amplify"></a>AWS Amplify</h4><ul><li>A set of tools to develop and deploy full stack web and mobile application<ul><li>搭建全栈项目的</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img010043.png"></p><hr><h4 id="AWS-Resource-Access-Manager-RAM"><a href="#AWS-Resource-Access-Manager-RAM" class="headerlink" title="AWS Resource Access Manager (RAM)"></a>AWS Resource Access Manager (RAM)</h4><ul><li>RAM is a service that enables easily and securely share AWS resources with any AWS account or within AWS Organization. (eg. Transite Gateway, Subnets)<ul><li>选择 RAM 的主要原因是它便宜</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img043006.png"></p><hr><h4 id="AWS-Systems-Manager"><a href="#AWS-Systems-Manager" class="headerlink" title="AWS Systems Manager"></a>AWS Systems Manager</h4><ul><li>AWS Systems Manager is an AWS service that you can use to view and control your infrastructure on AWS (比如 group resources, eg. EC2, S3 等等)</li><li>Use AWS Systems Manager Run Command to run a custom command that applies the patch to all EC2 instances</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img013522.png"></p><hr><h3 id="28-WhitePapers"><a href="#28-WhitePapers" class="headerlink" title="28. WhitePapers"></a>28. WhitePapers</h3><ul><li>Well Architected Framework: 有 6 个 Pillars 要记</li><li>Operational Excellence (运营) + Security (安全) + Reliability (可靠) + Performance Efficiency (性能效率) + Cost Optimization (省钱) + Sustainability (持续发展)</li><li>Maximum resilience is achieved by separate connections terminating on separate devices in more than one location</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img911011.png"></p><ul><li>AWS Well-Architected Tool<ul><li>Review architectures against 6 pillars (best practice)</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img010508.png"> </p><hr><h4 id="AWS-Trusted-Advisor"><a href="#AWS-Trusted-Advisor" class="headerlink" title="AWS Trusted Advisor"></a>AWS Trusted Advisor</h4><ul><li>High level AWS account assessment (AWS 账户评估)<ul><li>Learn the best practices on cost optimization, performance, and security</li></ul></li><li>根据上面的 6 Pillars 来判断 (要记住)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img010724.png"></p><hr><h3 id="29-Extra"><a href="#29-Extra" class="headerlink" title="29. Extra"></a>29. Extra</h3><ul><li><p>DNS queries</p><ul><li>To resolve any DNS queries for resources in the AWS VPC from the on-premises network, you can create an inbound endpoint on Amazon Route 53 Resolver and then DNS resolvers on the on-premises network can forward DNS queries to Amazon Route 53 Resolver via this endpoint.</li><li>To resolve DNS queries for any resources in the on-premises network from the AWS VPC, you can create an outbound endpoint on Amazon Route 53 Resolver and then Amazon Route 53 Resolver can conditionally forward queries to resolvers on the on-premises network via this endpoint.</li></ul></li><li><p>EC2 Instance recover from impaired state</p><ul><li>A recovered instance is identical to the original instance, including the instance ID, private IP addresses, Elastic IP addresses, and all instance metadata</li><li>If your instance has a public IPv4 address, it retains the public IPv4 address after recovery</li></ul></li><li><p>Spot Instance &amp; Spot Fleet</p><ul><li>If a spot request is persistent, then it is opened again after your Spot Instance is interrupted</li><li>Spot Fleets can maintain target capacity by launching replacement instances after Spot Instances in the fleet are terminated</li><li>When you cancel an active spot request, it does not terminate the associated instance</li></ul></li><li><p>Improve the security at the authentication level by leveraging short-lived credentials</p><ul><li>Use IAM authentication from AWS Lambda to Amazon RDS PostgreSQL</li><li>Attach an AWS Identity and Access Management (IAM) role to AWS Lambda</li></ul></li><li><p>Only root user account can do</p><ul><li>Some of the AWS tasks that only a root account user can do are as follows: change account name or root password or root email address, change AWS support plan, close AWS account, enable AWS Multi-Factor Authentication (AWS MFA) on S3 bucket delete, create Cloudfront key pair, register for GovCloud.</li></ul></li></ul><hr><h3 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h3><blockquote><p>请勿随意修改, 谢谢</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Certification </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AWS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>考证：AWS CLF-C02</title>
      <link href="/posts/ced5b880.html"/>
      <url>/posts/ced5b880.html</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p>一些我整理的资料:</p><ul><li>官网: <a href="https://aws.amazon.com/certification/certified-cloud-practitioner/">https://aws.amazon.com/certification/certified-cloud-practitioner/</a></li><li>参考笔记: <a href="https://cong-onion.cn/archives/acp-prepare-note">https://cong-onion.cn/archives/acp-prepare-note</a></li><li>白皮书: <a href="https://d0.awsstatic.com/whitepapers/aws-overview.pdf">https://d0.awsstatic.com/whitepapers/aws-overview.pdf</a></li><li>网课：<a href="https://www.udemy.com/course/aws-certified-cloud-practitioner-new/">https://www.udemy.com/course/aws-certified-cloud-practitioner-new/</a> (个人比较推荐，课比较新，Whizlabs 的课有些内容并不是基于新的 AWS)</li><li>网课: <a href="https://www.whizlabs.com/aws-certified-cloud-practitioner/">https://www.whizlabs.com/aws-certified-cloud-practitioner/</a> (不推荐)</li><li>题库: Whizlabs 购买的课有 4 套题 (Whizlabs 的题还行)</li><li>题库: <a href="https://www.udemy.com/course/practice-exams-aws-certified-cloud-practitioner/">https://www.udemy.com/course/practice-exams-aws-certified-cloud-practitioner/</a> (推荐)</li><li>题库: <a href="https://www.examtopics.com/exams/amazon/aws-certified-cloud-practitioner-clf-c02/view/">https://www.examtopics.com/exams/amazon/aws-certified-cloud-practitioner-clf-c02/view/</a> (这个是免费的)</li><li>准备时间: 1 月 1 号准备，1 月 8 号考过 (有一定 AWS 的基础)</li></ul></blockquote><hr><h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><p>重点: Pay-as-you-go，on-demand delivery<br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img105337.png"></p><ul><li>There are three fundamental drivers of cost with AWS: compute, storage, and outbound data transfer. In most cases, there is no charge for inbound data transfer or data transfer between other AWS services within the same region.</li></ul><hr><h4 id="Types-of-Cloud-Computing"><a href="#Types-of-Cloud-Computing" class="headerlink" title="Types of Cloud Computing"></a>Types of Cloud Computing</h4><p>重点: 3 types of cloud computing</p><ul><li>IaaS: 比如 EC2</li><li>PaaS: 比如 Elastic Beanstalk</li><li>SaaS: 比如 Rekognition</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img110812.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img110945.png"></p><hr><h4 id="Six-Advantages-of-Cloud-Computing"><a href="#Six-Advantages-of-Cloud-Computing" class="headerlink" title="Six Advantages of Cloud Computing"></a>Six Advantages of Cloud Computing</h4><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img084401.png"></p><hr><h4 id="AWS-Global-Infrastructure"><a href="#AWS-Global-Infrastructure" class="headerlink" title="AWS Global Infrastructure"></a>AWS Global Infrastructure</h4><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img114544.png"></p><p>AWS Region</p><ul><li>A region is a cluster of data centers</li><li>一个 Region 至少有三个 AZ</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img114639.png"></p><p>AWS Availability Zones</p><ul><li>Each availiablity zone (AZ) is one or more discrete data centers in the same location</li><li>AZ 组合起来就是 Region</li><li>All traffic between Availability Zones (AZ) is encrypted</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img114958.png"></p><p>AWS Points of Presence (Edge Locations)</p><ul><li>Content is delivered to end users with low latency</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img115255.png"></p><hr><h4 id="AWS-Shared-Responsibility-Model"><a href="#AWS-Shared-Responsibility-Model" class="headerlink" title="AWS Shared Responsibility Model"></a>AWS Shared Responsibility Model</h4><ul><li>AWS 负责什么，Customer 负责什么</li><li>AWS is responsible for Security “of” the Cloud</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img120115.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img103332.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img103410.png"></p><hr><h3 id="1-Identity-and-Access-Management"><a href="#1-Identity-and-Access-Management" class="headerlink" title="1. Identity and Access Management"></a>1. Identity and Access Management</h3><h4 id="IAM-Users-amp-Group"><a href="#IAM-Users-amp-Group" class="headerlink" title="IAM Users &amp; Group"></a>IAM Users &amp; Group</h4><ul><li>Global service</li><li>Root account: don’t share with others</li><li>Root user access credentials are the email address and password used to create the AWS account</li><li>Users: people within organization</li><li>Groups: a group of people</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img134540.png"></p><p>IAM Permissions</p><ul><li>least privilege principle</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img134928.png"></p><h4 id="IAM-Policies"><a href="#IAM-Policies" class="headerlink" title="IAM Policies"></a>IAM Policies</h4><ul><li>Inline Policy 是 Attach 给个人的 Policy</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img135808.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img140013.png"></p><p>IAM Password Policy &amp; MFA</p><ul><li>MFA 是 Root Account 的 Best Practice</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img142523.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img142218.png"></p><p>AWS Access Keys &amp; CLI &amp; SDK</p><ul><li>有 3 种方法 Access AWS: AWS Management Console，AWS CLI，AWS SDK</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img143439.png"></p><h4 id="IAM-Roles"><a href="#IAM-Roles" class="headerlink" title="IAM Roles"></a>IAM Roles</h4><ul><li>Assign permissions to AWS services with IAM Roles</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img150558.png"></p><p>IAM Guildlines &amp; Best Parctices</p><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img153158.png"></p><p>Shared Responsibility Model for IAM</p><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img153447.png"></p><h4 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h4><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img154627.png"></p><hr><h3 id="2-Elastic-Compute-Cloud"><a href="#2-Elastic-Compute-Cloud" class="headerlink" title="2. Elastic Compute Cloud"></a>2. Elastic Compute Cloud</h3><h4 id="AWS-EC2"><a href="#AWS-EC2" class="headerlink" title="AWS EC2"></a>AWS EC2</h4><ul><li>60 seconds - There is a one-minute minimum charge for Linux based EC2 instances</li><li>Convertible reserved instance (RI): Purchase convertible reserved instance (RI) if you need additional flexibility, such as the ability to use different instance families, operating systems, or tenancies over the reserved instance (RI) term.</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img193350.png"></p><p>User Data:</p><ul><li>EC2 Instance 第一次跑的时候会 Run，用来做 Task (比如安装 Apache)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img194029.png"></p><h4 id="EC2-Instance-Types"><a href="#EC2-Instance-Types" class="headerlink" title="EC2 Instance Types"></a>EC2 Instance Types</h4><ul><li>General Purpose: Balance between Compute，Memory，Networking</li><li>Compute Optimized: Great for compute-intensive tasks</li><li>Memory Optimized: Fast performance for workloads that process large data sets</li><li>Storage Optimized: Great for storage-intensive tasks</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img195856.png"></p><h4 id="Security-Groups"><a href="#Security-Groups" class="headerlink" title="Security Groups"></a>Security Groups</h4><ul><li>Security Group 就是 EC2 的防火墙</li><li>Security Group 可以 Attach 给多个 Instances</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img200755.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img201255.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img201629.png"></p><h4 id="EC2-Instances-Purchasing-Options"><a href="#EC2-Instances-Purchasing-Options" class="headerlink" title="EC2 Instances Purchasing Options"></a>EC2 Instances Purchasing Options</h4><ul><li>On-Demand Instances: Pay for what you use</li><li>Reserved: 长期使用 (1-3 年)</li><li>Saving Plans: 有固定的 Billing，超过的进入 On-Demand</li><li>Spot Instances: 最便宜，但是可能 Lose Instance</li><li>Dedicated Hosts: 完全 Control 一个 Server</li><li>Capacity Reservations: 短期内保证有 Instance 可以使用，即使不使用</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img024118.png"></p><p>Shared Responsibility Model for EC2</p><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img025826.png"></p><h4 id="Summary-1"><a href="#Summary-1" class="headerlink" title="Summary"></a>Summary</h4><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img025957.png"></p><hr><h3 id="3-EC2-Instance-Storage"><a href="#3-EC2-Instance-Storage" class="headerlink" title="3. EC2 Instance Storage"></a>3. EC2 Instance Storage</h3><h4 id="AWS-EBS"><a href="#AWS-EBS" class="headerlink" title="AWS EBS"></a>AWS EBS</h4><ul><li>Attach EBS to EC2 instance like a USB drive</li><li>EBS Volume tied to AZ</li><li>Persist data even after termination</li><li>Block-level storage</li><li>Charge for EBS Volumes: Provisioned IOPS，Volume type</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img030842.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img032719.png"></p><p>EBS Snapshots (备份)</p><ul><li>Make a backup (snapshot) of EBS volume</li><li>Recycle Bin 可以防止 Accidental Delete</li><li>Amazon Elastic Block Store (Amazon EBS) Snapshots are stored incrementally, which means you are billed only for the changed blocks stored</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img035925.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img040322.png"></p><p>EC2 Instance Store</p><ul><li>物理硬盘</li><li>Block-level storage</li><li>Fast I&#x2F;O performance</li><li>Good for cache</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img054643.png"></p><p>Shared Responsibility Model for EC2 Storage</p><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img055927.png"></p><hr><h4 id="AWS-EFS"><a href="#AWS-EFS" class="headerlink" title="AWS EFS"></a>AWS EFS</h4><ul><li>可以 Mount 到多个 EC2 Instance</li><li>Provides a simple, scalable, fully managed elastic NFS file system for use with AWS Cloud services and on-premises resources.</li><li>EBS volume can be attached to a single instance in the same Availability Zone (AZ) whereas EFS file system can be mounted on instances across multiple Availability Zones (AZ)</li><li>EC2 instances can access files on an Amazon Elastic File System (Amazon EFS) file system across many Availability Zones (AZ), Regions and VPCs</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img055110.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img055536.png"></p><p>EFS Infrequent Access (EFS-IA)</p><ul><li>Storing files in an accessible location to satisfy audit requirements</li><li>You will pay a fee each time you read from or write data stored on the Amazon Elastic File System (Amazon EFS) - Infrequent Access storage class</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img055437.png"></p><hr><h4 id="AWS-AMI"><a href="#AWS-AMI" class="headerlink" title="AWS AMI"></a>AWS AMI</h4><ul><li>Amazon Machine Image</li><li>可以更好的 Configure 和 Launch EC2 Instance (比如不需要重装 Apache)</li><li>Region specific</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img053649.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img053738.png"></p><p>EC2 Image Builder</p><ul><li>Automatically build，test and distribute AMIs</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img054433.png"></p><hr><h4 id="AWS-FSx"><a href="#AWS-FSx" class="headerlink" title="AWS FSx"></a>AWS FSx</h4><ul><li>第三方文件管理系统</li><li>FSx for Windows</li><li>FSx for Lustre</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img060300.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img060312.png"></p><hr><h4 id="Summary-2"><a href="#Summary-2" class="headerlink" title="Summary"></a>Summary</h4><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img060513.png"></p><hr><h3 id="4-ELB-amp-ASG"><a href="#4-ELB-amp-ASG" class="headerlink" title="4. ELB &amp; ASG"></a>4. ELB &amp; ASG</h3><h4 id="Scalability-amp-High-Availability"><a href="#Scalability-amp-High-Availability" class="headerlink" title="Scalability &amp; High Availability"></a>Scalability &amp; High Availability</h4><ul><li>Vertical Scale: increase the size of the instance</li><li>Horizontal Scale: increase the number of instances (elastic)</li><li>High Availability: running application in at least 2 AZ (disaster recovery)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img065903.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img080120.png"></p><hr><h4 id="AWS-ELB"><a href="#AWS-ELB" class="headerlink" title="AWS ELB"></a>AWS ELB</h4><ul><li>Spread load across multiple downstream instances</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img085521.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img085832.png"></p><ul><li>Application Load Balancer (HTTP&#x2F;HTTPS)</li><li>Network Load Balancer (Allow TCP&#x2F;UDP)</li><li>Gateway Load Balancer (Security)</li><li>Classic Load Balancer (retired in 2023)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img090125.png"></p><hr><h4 id="AWS-ASG"><a href="#AWS-ASG" class="headerlink" title="AWS ASG"></a>AWS ASG</h4><ul><li>可以作为 Template 来生成 EC2 Instance (Launch Template)</li><li>可以和 ELB 一起用，来 Scale Up or Down 基于服务器压力</li><li>可以自动 Replace Unhealth Instance (Meet desired Instances)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img091045.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img091228.png"></p><p>Scaling Strategies</p><ul><li>Manual Scaling</li><li>Dynamic Scaling</li><li>Predictive Scaling (Use ML)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img092355.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img092454.png"></p><hr><h4 id="Summary-3"><a href="#Summary-3" class="headerlink" title="Summary"></a>Summary</h4><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img092733.png"></p><hr><h3 id="5-Simple-Storage-Service"><a href="#5-Simple-Storage-Service" class="headerlink" title="5. Simple Storage Service"></a>5. Simple Storage Service</h3><h4 id="AWS-S3"><a href="#AWS-S3" class="headerlink" title="AWS S3"></a>AWS S3</h4><ul><li><p>Buckets have a globally unique name</p></li><li><p>Buckets are defined at the region level</p></li><li><p>All Amazon S3 buckets have encryption configured by default, and objects are automatically encrypted by using server-side encryption with Amazon S3 managed keys (SSE-S3).</p></li><li><p>Amazon Simple Storage Service (Amazon S3) is a key value based object storage service</p></li><li><p>Amazon Simple Storage Service (Amazon S3) stores data in a flat non-hierarchical structure</p></li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img093348.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img093802.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img093849.png"></p><p>Bucket Policies</p><ul><li>User Access to S3: Use IAM permission</li><li>EC2 Instance Access: Use IAM Roles</li><li>Cross-Account Access: Use Bucket Policy</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img102509.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img102630.png"></p><p>S3 Website (Static Website Hosting)</p><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img104755.png"></p><p>S3 Versioning</p><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img105035.png"></p><p>S3 Replication (CRR &amp; SRR)</p><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img105607.png"></p><p>S3 Storage Classes</p><ul><li>Standard</li><li>Infrequent Access (IA)</li><li>Glacier</li><li>Intelligent Tiering</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img110113.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img110226.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img110336.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img110708.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img110810.png"></p><p>S3 Encryption</p><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img111248.png"></p><p>Shared Responsibility Model for S3</p><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img111547.png"></p><hr><h4 id="AWS-Snow-Family"><a href="#AWS-Snow-Family" class="headerlink" title="AWS Snow Family"></a>AWS Snow Family</h4><ul><li>Snowcone，Snowball (TB &amp; Petabyte-scale)，Snowmobile (Exabytes-scale)</li><li>Transfer data to AWS physically</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img122700.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img175223.png"></p><p>Edge Computing</p><ul><li>在任何地方处理数据</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img123338.png"></p><hr><h4 id="AWS-OpsHub"><a href="#AWS-OpsHub" class="headerlink" title="AWS OpsHub"></a>AWS OpsHub</h4><ul><li>Manage Snow Family Device</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img123604.png"></p><hr><h4 id="AWS-Storage-Gateway"><a href="#AWS-Storage-Gateway" class="headerlink" title="AWS Storage Gateway"></a>AWS Storage Gateway</h4><ul><li>处理 Hybrid Storage on Cloud</li><li>Automatically enabled data encryption</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img132624.png"></p><hr><h4 id="Summary-4"><a href="#Summary-4" class="headerlink" title="Summary"></a>Summary</h4><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img132831.png"></p><hr><h3 id="6-Database-amp-Analytics"><a href="#6-Database-amp-Analytics" class="headerlink" title="6. Database &amp; Analytics"></a>6. Database &amp; Analytics</h3><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img134205.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img242377.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img134415.png"></p><hr><h4 id="AWS-RDS"><a href="#AWS-RDS" class="headerlink" title="AWS RDS"></a>AWS RDS</h4><ul><li>负责 Relational Database</li><li>Amazon RDS RIs: Like Amazon EC2 RIs</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img124658.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img134210.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img134849.png"></p><p>AWS Aurora</p><ul><li>AWS 开发的数据库</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img134956.png"></p><p>RDS Deployments Options</p><ul><li>Read Replicas: Scale</li><li>Multi-AZ: Failover</li><li>Multi-Region: Disaster recovery</li><li>You can use both read replicas and multi-AZ deployment for disaster recovery</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img140045.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img148104.png"></p><hr><h4 id="AWS-Elastic-Cache"><a href="#AWS-Elastic-Cache" class="headerlink" title="AWS Elastic Cache"></a>AWS Elastic Cache</h4><ul><li>In-memory database (类似 Redis)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img140153.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img140242.png"></p><hr><h4 id="AWS-DynamoDB"><a href="#AWS-DynamoDB" class="headerlink" title="AWS DynamoDB"></a>AWS DynamoDB</h4><ul><li>NoSQL Database</li><li>DynamoDB Reserved Capacity</li><li>Support High Availability by default</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img142315.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img143342.png"></p><p>DynamoDB Accelerator (DAX)</p><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img142430.png"></p><p>DynamoDB Global Tables</p><ul><li>Low latency in multiple-regions</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img142815.png"></p><hr><h4 id="AWS-Redshift"><a href="#AWS-Redshift" class="headerlink" title="AWS Redshift"></a>AWS Redshift</h4><ul><li>Analytics and data warehousing</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img143251.png"></p><p>Redshift Serverless</p><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img123392.png"></p><hr><h4 id="AWS-EMR"><a href="#AWS-EMR" class="headerlink" title="AWS EMR"></a>AWS EMR</h4><ul><li>Help creating Hadoop clusters (Big Data) to analyze vast amount of data</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img242278.png"></p><hr><h4 id="AWS-Athena"><a href="#AWS-Athena" class="headerlink" title="AWS Athena"></a>AWS Athena</h4><ul><li>Perform analytics against S3 objects</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img144857.png"></p><hr><h4 id="AWS-QuickSight"><a href="#AWS-QuickSight" class="headerlink" title="AWS QuickSight"></a>AWS QuickSight</h4><ul><li>生成 Visualization Dashboard (处理 BI)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img145053.png"></p><hr><h4 id="AWS-DocumentDB"><a href="#AWS-DocumentDB" class="headerlink" title="AWS DocumentDB"></a>AWS DocumentDB</h4><ul><li>For MongoDB，NoSQL</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img145305.png"></p><hr><h4 id="AWS-Neptune"><a href="#AWS-Neptune" class="headerlink" title="AWS Neptune"></a>AWS Neptune</h4><ul><li>Graph database</li><li>NoSQL</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img145437.png"></p><hr><h4 id="AWS-Timestream"><a href="#AWS-Timestream" class="headerlink" title="AWS Timestream"></a>AWS Timestream</h4><ul><li>Time series database</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img145616.png"></p><hr><h4 id="AWS-QLDB"><a href="#AWS-QLDB" class="headerlink" title="AWS QLDB"></a>AWS QLDB</h4><ul><li>Immutable，for financial transcations</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img122316.png"></p><hr><h4 id="AWS-Managed-Blockchain"><a href="#AWS-Managed-Blockchain" class="headerlink" title="AWS Managed Blockchain"></a>AWS Managed Blockchain</h4><ul><li>Decentralized</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img150042.png"></p><hr><h4 id="AWS-Glue"><a href="#AWS-Glue" class="headerlink" title="AWS Glue"></a>AWS Glue</h4><ul><li>AWS Glue is a fully managed extract, transform, and load (ETL) service that makes it easy for customers to prepare and load their data for analytics.</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img150226.png"></p><hr><h4 id="AWS-DMS"><a href="#AWS-DMS" class="headerlink" title="AWS DMS"></a>AWS DMS</h4><ul><li>Database Migration Service</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img120404.png"></p><hr><h4 id="Summary-5"><a href="#Summary-5" class="headerlink" title="Summary"></a>Summary</h4><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img622313.png"></p><hr><h3 id="7-Other-Compute-Services"><a href="#7-Other-Compute-Services" class="headerlink" title="7. Other Compute Services"></a>7. Other Compute Services</h3><h4 id="AWS-ECS"><a href="#AWS-ECS" class="headerlink" title="AWS ECS"></a>AWS ECS</h4><ul><li>Launch Docker containers on AWS</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img185536.png"></p><hr><h4 id="AWS-Fargate"><a href="#AWS-Fargate" class="headerlink" title="AWS Fargate"></a>AWS Fargate</h4><ul><li>Launch Docker containers on AWS (Serverless)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img185649.png"></p><hr><h4 id="AWS-ECR"><a href="#AWS-ECR" class="headerlink" title="AWS ECR"></a>AWS ECR</h4><ul><li>Docker Registry on AWS</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img185752.png"></p><hr><h4 id="AWS-Lambda"><a href="#AWS-Lambda" class="headerlink" title="AWS Lambda"></a>AWS Lambda</h4><ul><li>Could be Event-Driven</li><li>Could use EventBridge trigger Lambda every hour (CRON)</li><li>You pay for the compute time you consume for AWS Lambda</li><li>Serverless</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img190238.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img022933.png"></p><hr><h4 id="AWS-API-Gateway"><a href="#AWS-API-Gateway" class="headerlink" title="AWS API Gateway"></a>AWS API Gateway</h4><ul><li>Expose Lambda as HTTP API</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img031238.png"></p><hr><h4 id="AWS-Batch"><a href="#AWS-Batch" class="headerlink" title="AWS Batch"></a>AWS Batch</h4><ul><li>A job with a start and an end</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img035927.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img040028.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img040129.png"></p><hr><h4 id="AWS-Lightsail"><a href="#AWS-Lightsail" class="headerlink" title="AWS Lightsail"></a>AWS Lightsail</h4><ul><li>For people with little cloud experience</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img042248.png"></p><hr><h4 id="Summary-6"><a href="#Summary-6" class="headerlink" title="Summary"></a>Summary</h4><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img042816.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img042914.png"></p><hr><h3 id="8-Deployment-amp-Manage-Infrastructure"><a href="#8-Deployment-amp-Manage-Infrastructure" class="headerlink" title="8. Deployment &amp; Manage Infrastructure"></a>8. Deployment &amp; Manage Infrastructure</h3><h4 id="AWS-CloudFormation"><a href="#AWS-CloudFormation" class="headerlink" title="AWS CloudFormation"></a>AWS CloudFormation</h4><ul><li>Infrastructure as code (不需要手动 Config EC2 之类的)</li><li>作为 Template 来生成各种 Services</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img044630.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img044747.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img044837.png"></p><hr><h4 id="AWS-CDK"><a href="#AWS-CDK" class="headerlink" title="AWS CDK"></a>AWS CDK</h4><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img045950.png"></p><hr><h4 id="AWS-Elastic-Beanstalk"><a href="#AWS-Elastic-Beanstalk" class="headerlink" title="AWS Elastic Beanstalk"></a>AWS Elastic Beanstalk</h4><ul><li>PaaS (只负责写 Application，其他都由 EB 来处理)</li><li>Free of cost</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img064808.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img064855.png"></p><hr><h4 id="AWS-CodeDeploy"><a href="#AWS-CodeDeploy" class="headerlink" title="AWS CodeDeploy"></a>AWS CodeDeploy</h4><ul><li>Deploy application automatically</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img074724.png"></p><hr><h4 id="AWS-CodeCommit"><a href="#AWS-CodeCommit" class="headerlink" title="AWS CodeCommit"></a>AWS CodeCommit</h4><ul><li>类似 Github</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img074839.png"></p><hr><h4 id="AWS-CodeBuild"><a href="#AWS-CodeBuild" class="headerlink" title="AWS CodeBuild"></a>AWS CodeBuild</h4><ul><li>Automatically build and test</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img075430.png"></p><hr><h4 id="AWS-CodePipeline"><a href="#AWS-CodePipeline" class="headerlink" title="AWS CodePipeline"></a>AWS CodePipeline</h4><ul><li>CICD</li><li>AWS CodePipeline uses Amazon CloudWatch Events to detect changes in CodeCommit repositories used as a source for a pipeline</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img081356.png"></p><hr><h4 id="AWS-CodeArtifact"><a href="#AWS-CodeArtifact" class="headerlink" title="AWS CodeArtifact"></a>AWS CodeArtifact</h4><ul><li>Manage packages (dependencies)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img082203.png"></p><hr><h4 id="AWS-CodeStar"><a href="#AWS-CodeStar" class="headerlink" title="AWS CodeStar"></a>AWS CodeStar</h4><ul><li>Each AWS CodeStar project includes development tools, including AWS CodePipeline, AWS CodeCommit, AWS CodeBuild, and AWS CodeDeploy, that can be used on their own and with existing AWS applications</li><li>You can use AWS CodeStar and AWS Cloud9 to develop, build, and deploy a serverless web application</li></ul><hr><h4 id="AWS-Cloud9"><a href="#AWS-Cloud9" class="headerlink" title="AWS Cloud9"></a>AWS Cloud9</h4><ul><li>Cloud IDE</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img082707.png"></p><hr><h4 id="AWS-SSM"><a href="#AWS-SSM" class="headerlink" title="AWS SSM"></a>AWS SSM</h4><ul><li>Manage a fleet of EC2 Instances</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img135524.png"></p><hr><h4 id="Summary-7"><a href="#Summary-7" class="headerlink" title="Summary"></a>Summary</h4><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img140426.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img140520.png"></p><hr><h3 id="9-AWS-Global-Infrastructure"><a href="#9-AWS-Global-Infrastructure" class="headerlink" title="9. AWS Global Infrastructure"></a>9. AWS Global Infrastructure</h3><p>Why make a global application?</p><ul><li>Decreased Latency</li><li>Disaster Recovery (DR)</li></ul><p>Global Applications in AWS</p><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img142534.png"></p><hr><h4 id="AWS-Route53"><a href="#AWS-Route53" class="headerlink" title="AWS Route53"></a>AWS Route53</h4><ul><li>DNS (Domain Name System)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img142637.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img142729.png"></p><p>Routing Policies</p><ul><li>Simple Routing Policy (No health check)</li><li>Weighted Routing Policy (Distribute traffic)</li><li>Latency Routing Policy (Minimize Latency)</li><li>Failover Routing Policy (Disaster recovery，active-passive)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img142821.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img142907.png"></p><hr><h4 id="AWS-CloudFront"><a href="#AWS-CloudFront" class="headerlink" title="AWS CloudFront"></a>AWS CloudFront</h4><ul><li>Global service</li><li>CDN</li><li>Cached in edged location</li><li>Integrated with WAF (Network Firewall) and Shield (DDoS)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img144056.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img144157.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img144238.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img144434.png"></p><hr><h4 id="AWS-Global-Accelerator"><a href="#AWS-Global-Accelerator" class="headerlink" title="AWS Global Accelerator"></a>AWS Global Accelerator</h4><ul><li>AWS Internal Network (No cache)</li><li>AWS Global Accelerator is a good fit for non-HTTP use cases</li><li>AWS Global Accelerator provides static IP addresses that act as a fixed entry point to your applications</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img184614.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img184642.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img184736.png"></p><hr><h4 id="AWS-Outposts"><a href="#AWS-Outposts" class="headerlink" title="AWS Outposts"></a>AWS Outposts</h4><ul><li>Server Rack (物理层面)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img185046.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img185126.png"></p><hr><h4 id="AWS-WaveLength"><a href="#AWS-WaveLength" class="headerlink" title="AWS WaveLength"></a>AWS WaveLength</h4><ul><li>5G</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img185306.png"></p><hr><h4 id="AWS-Local-Zones"><a href="#AWS-Local-Zones" class="headerlink" title="AWS Local Zones"></a>AWS Local Zones</h4><ul><li>AWS Local Zones allow you to use select AWS services, like compute and storage services, closer to more end-users, providing them very low latency access to the applications running locally.</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img185415.png"></p><hr><h4 id="Global-Applications-Architecture"><a href="#Global-Applications-Architecture" class="headerlink" title="Global Applications Architecture"></a>Global Applications Architecture</h4><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img185706.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img185814.png"></p><hr><h4 id="Summary-8"><a href="#Summary-8" class="headerlink" title="Summary"></a>Summary</h4><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img185939.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img190014.png"></p><hr><h3 id="10-Cloud-Integration"><a href="#10-Cloud-Integration" class="headerlink" title="10.Cloud Integration"></a>10.Cloud Integration</h3><ul><li>SQS，SNS，Kinesis</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img191712.png"></p><hr><h4 id="AWS-SQS"><a href="#AWS-SQS" class="headerlink" title="AWS SQS"></a>AWS SQS</h4><ul><li>Decouple application</li><li>Message deleted after Customer read</li><li>Guarantee message will be processed</li><li>Queue Model</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img192002.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img192052.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img192138.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img192214.png"></p><hr><h4 id="AWS-Kinesis"><a href="#AWS-Kinesis" class="headerlink" title="AWS Kinesis"></a>AWS Kinesis</h4><ul><li>Real-time big data streaming</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img200432.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img200512.png"></p><hr><h4 id="AWS-SNS"><a href="#AWS-SNS" class="headerlink" title="AWS SNS"></a>AWS SNS</h4><ul><li>Send one message to many receivers</li><li>Pub&#x2F;Sub Model</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img200634.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img200723.png"></p><hr><h4 id="AWS-MQ"><a href="#AWS-MQ" class="headerlink" title="AWS MQ"></a>AWS MQ</h4><ul><li>管理第三方软件</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img201142.png"></p><hr><h4 id="Summary-9"><a href="#Summary-9" class="headerlink" title="Summary"></a>Summary</h4><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img201319.png"></p><hr><h3 id="11-Cloud-Monitoring"><a href="#11-Cloud-Monitoring" class="headerlink" title="11. Cloud Monitoring"></a>11. Cloud Monitoring</h3><h4 id="AWS-CloudWatch"><a href="#AWS-CloudWatch" class="headerlink" title="AWS CloudWatch"></a>AWS CloudWatch</h4><ul><li>Application performance</li><li>Resource utilization</li></ul><p>CloudWatch Metric</p><ul><li>Billing metric data is stored in the US East (N. Virginia) Region and represents worldwide charges.</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img202020.png"></p><p>CloudWatch Alarms</p><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img202259.png"></p><p>CloudWatch Logs</p><ul><li>Use CloudWatch Logs for both the EC2 instance and the on-premises servers</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img203214.png"></p><hr><h4 id="AWS-EventBridge"><a href="#AWS-EventBridge" class="headerlink" title="AWS EventBridge"></a>AWS EventBridge</h4><ul><li>定制 Event 来触发某些功能 (Lambda，SNS)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img203642.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img203712.png"></p><hr><h4 id="AWS-CloudTrail"><a href="#AWS-CloudTrail" class="headerlink" title="AWS CloudTrail"></a>AWS CloudTrail</h4><ul><li>Governance，compliance and audit for AWS account</li><li>AWS CloudTrail Insights helps AWS users identify and respond to unusual activity associated with write API calls by continuously analyzing CloudTrail management events.</li><li>By default, AWS CloudTrail logs all management events and does not include data events or Insights events.</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img064634.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img064712.png"></p><hr><h4 id="AWS-X-Ray"><a href="#AWS-X-Ray" class="headerlink" title="AWS X-Ray"></a>AWS X-Ray</h4><ul><li>You can use AWS X-Ray to analyze and debug serverless and distributed applications such as those built using a microservices architecture.</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img070456.png"></p><hr><h4 id="AWS-CodeGuru"><a href="#AWS-CodeGuru" class="headerlink" title="AWS CodeGuru"></a>AWS CodeGuru</h4><ul><li>ML for code review</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img073052.png"></p><hr><h4 id="AWS-Health-Dashboard"><a href="#AWS-Health-Dashboard" class="headerlink" title="AWS Health Dashboard"></a>AWS Health Dashboard</h4><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img073557.png"></p><hr><h4 id="Summary-10"><a href="#Summary-10" class="headerlink" title="Summary"></a>Summary</h4><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img074126.png"></p><hr><h3 id="12-VPC-amp-Networking"><a href="#12-VPC-amp-Networking" class="headerlink" title="12. VPC &amp; Networking"></a>12. VPC &amp; Networking</h3><h4 id="AWS-VPC"><a href="#AWS-VPC" class="headerlink" title="AWS VPC"></a>AWS VPC</h4><p>IP Address in AWS</p><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img075533.png"></p><p>VPC &amp; Subnets</p><ul><li>VPC: Virtual Private Network</li><li>Subnets: Partition network inside VPC</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img075637.png"></p><p>Internet Gateway &amp; NAT Gateways</p><ul><li>IGW: Public</li><li>NAT: Private</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img075859.png"></p><p>Security Groups &amp; Network Access Control List (NACL)</p><ul><li>NACL: Firewall for Allow and Deny rules</li><li>Security Group: Firewall for Allow rules</li><li>A security group is stateful, that is, it automatically allows the return traffic</li><li>Security Group acts as a firewall at the instance level whereas Network Access Control List (Network ACL) acts as a firewall at the subnet level</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img080543.png"></p><p>VPC Flow Logs</p><ul><li>Capture log information</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img080849.png"></p><p>VPC Peering</p><ul><li>Connect two VPC</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img080936.png"></p><p>VPC Endpoints</p><ul><li>Access services privately</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img101047.png"></p><hr><h4 id="AWS-PrivateLink"><a href="#AWS-PrivateLink" class="headerlink" title="AWS PrivateLink"></a>AWS PrivateLink</h4><ul><li>第三方 VPC 连接到 AWS VPC</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img101255.png"></p><hr><h4 id="Site-to-Site-VPN-amp-Direct-Connect"><a href="#Site-to-Site-VPN-amp-Direct-Connect" class="headerlink" title="Site to Site VPN &amp; Direct Connect"></a>Site to Site VPN &amp; Direct Connect</h4><ul><li>AWS Direct Connect is a cloud service solution that makes it easy to establish a dedicated network connection from your premises to AWS. </li><li>Components of AWS Site to Site VPN: Virtual private gateway (VGW)，Customer gateway</li><li>A customer gateway device is a physical or software appliance on your side of a Site-to-Site VPN connection. You or your network administrator must configure the device to work with the Site-to-Site VPN connection.</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img101436.png"></p><hr><h4 id="AWS-ClientVPN"><a href="#AWS-ClientVPN" class="headerlink" title="AWS ClientVPN"></a>AWS ClientVPN</h4><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img101635.png"></p><hr><h4 id="AWS-Transit-Gateway"><a href="#AWS-Transit-Gateway" class="headerlink" title="AWS Transit Gateway"></a>AWS Transit Gateway</h4><ul><li>AWS Transit Gateway connects Amazon Virtual Private Clouds (Amazon VPC) and on-premises networks through a central hub.</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img101746.png"></p><hr><h4 id="AWS-VPN"><a href="#AWS-VPN" class="headerlink" title="AWS VPN"></a>AWS VPN</h4><ul><li>AWS Virtual Private Network (VPN) solutions establish secure connections between on-premises networks, remote offices, client devices, and the AWS global network.</li></ul><hr><h4 id="Summary-11"><a href="#Summary-11" class="headerlink" title="Summary"></a>Summary</h4><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img101912.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img102013.png"></p><hr><h3 id="13-Security-amp-Compliance"><a href="#13-Security-amp-Compliance" class="headerlink" title="13. Security &amp; Compliance"></a>13. Security &amp; Compliance</h3><h4 id="AWS-WAF-amp-Shield"><a href="#AWS-WAF-amp-Shield" class="headerlink" title="AWS WAF &amp; Shield"></a>AWS WAF &amp; Shield</h4><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img103546.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img103621.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img103650.png"></p><p>AWS Shield</p><ul><li>防止 DDoS 攻击</li><li>Shield Advance 用在 Route53 和 AWS Global Accelerator 上</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img103738.png"></p><p>AWS WAF</p><ul><li>Define Web ACL (Access Control List)</li><li>Can be deployed on Amazon CloudFront, Application Load Balancer, Amazon API Gateway, AWS AppSync</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img103839.png"></p><hr><h4 id="AWS-Network-Firewall"><a href="#AWS-Network-Firewall" class="headerlink" title="AWS Network Firewall"></a>AWS Network Firewall</h4><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img103945.png"></p><hr><h4 id="AWS-Firewall-Manager"><a href="#AWS-Firewall-Manager" class="headerlink" title="AWS Firewall Manager"></a>AWS Firewall Manager</h4><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img105934.png"></p><hr><h4 id="AWS-KMS-amp-CloudHSM"><a href="#AWS-KMS-amp-CloudHSM" class="headerlink" title="AWS KMS &amp; CloudHSM"></a>AWS KMS &amp; CloudHSM</h4><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img120236.png"></p><p>KMS: Manage Encryption keys</p><ul><li>Use AWS managed master keys that are automatically created in your account for each service</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img120343.png"></p><p>CloudHSM: Encryption Hardware (物理层面)</p><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img120433.png"></p><hr><h4 id="AWS-ACM"><a href="#AWS-ACM" class="headerlink" title="AWS ACM"></a>AWS ACM</h4><ul><li>Manage certificates</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img124350.png"></p><hr><h4 id="AWS-Secrets-Manager"><a href="#AWS-Secrets-Manager" class="headerlink" title="AWS Secrets Manager"></a>AWS Secrets Manager</h4><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img124445.png"></p><hr><h4 id="AWS-Artifact"><a href="#AWS-Artifact" class="headerlink" title="AWS Artifact"></a>AWS Artifact</h4><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img124706.png"></p><hr><h4 id="AWS-GuardDuty"><a href="#AWS-GuardDuty" class="headerlink" title="AWS GuardDuty"></a>AWS GuardDuty</h4><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img125533.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img125621.png"></p><hr><h4 id="AWS-Inspector"><a href="#AWS-Inspector" class="headerlink" title="AWS Inspector"></a>AWS Inspector</h4><ul><li>Amazon Inspector is an automated security assessment service that helps improve the security and compliance of applications deployed on AWS. </li><li>Only for EC2, Container Image &amp; Lambda</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img125801.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img125844.png"></p><hr><h4 id="AWS-Config"><a href="#AWS-Config" class="headerlink" title="AWS Config"></a>AWS Config</h4><ul><li>AWS Config is a service that enables you to assess, audit, and evaluate the configurations of your AWS resources.</li><li>Think resource-specific history, audit, and compliance; think Config.</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img125948.png"></p><hr><h4 id="AWS-Macie"><a href="#AWS-Macie" class="headerlink" title="AWS Macie"></a>AWS Macie</h4><ul><li>Find sensitive data</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img130515.png"></p><hr><h4 id="AWS-Security-Hub"><a href="#AWS-Security-Hub" class="headerlink" title="AWS Security Hub"></a>AWS Security Hub</h4><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img131533.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img131605.png"></p><hr><h4 id="AWS-Detective"><a href="#AWS-Detective" class="headerlink" title="AWS Detective"></a>AWS Detective</h4><ul><li>Analyze AWS CloudTrail logs, Amazon VPC Flow Logs, and Amazon GuardDuty findings</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img132824.png"></p><hr><h4 id="IAM-Access-Analyzer"><a href="#IAM-Access-Analyzer" class="headerlink" title="IAM Access Analyzer"></a>IAM Access Analyzer</h4><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img133559.png"></p><hr><h4 id="Summary-12"><a href="#Summary-12" class="headerlink" title="Summary"></a>Summary</h4><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img152124.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img155139.png"></p><hr><h3 id="14-Machine-Learning"><a href="#14-Machine-Learning" class="headerlink" title="14. Machine Learning"></a>14. Machine Learning</h3><h4 id="AWS-Rekognition"><a href="#AWS-Rekognition" class="headerlink" title="AWS Rekognition"></a>AWS Rekognition</h4><ul><li>Find text or image using ML</li><li>Regional in scope</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img164327.png"></p><hr><h4 id="AWS-Transcribe"><a href="#AWS-Transcribe" class="headerlink" title="AWS Transcribe"></a>AWS Transcribe</h4><ul><li>Convert speech to text</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img164826.png"></p><hr><h4 id="Amazon-Elastic-Transcoder"><a href="#Amazon-Elastic-Transcoder" class="headerlink" title="Amazon Elastic Transcoder"></a>Amazon Elastic Transcoder</h4><ul><li>Amazon Elastic Transcoder lets you convert media files that you have stored in Amazon Simple Storage Service (Amazon S3) into media files in the formats required by consumer playback devices.</li></ul><hr><h4 id="AWS-Polly"><a href="#AWS-Polly" class="headerlink" title="AWS Polly"></a>AWS Polly</h4><ul><li>Convert text to speech</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img165059.png"></p><hr><h4 id="AWS-Translate"><a href="#AWS-Translate" class="headerlink" title="AWS Translate"></a>AWS Translate</h4><ul><li>Translate language</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img171433.png"></p><hr><h4 id="AWS-Lex-amp-Connect"><a href="#AWS-Lex-amp-Connect" class="headerlink" title="AWS Lex &amp; Connect"></a>AWS Lex &amp; Connect</h4><p>Lex: Conversational bots<br>Connect: Cloud contact center</p><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img171703.png"></p><hr><h4 id="AWS-Comprehend"><a href="#AWS-Comprehend" class="headerlink" title="AWS Comprehend"></a>AWS Comprehend</h4><ul><li>NLP</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img171904.png"></p><hr><h4 id="AWS-SageMaker"><a href="#AWS-SageMaker" class="headerlink" title="AWS SageMaker"></a>AWS SageMaker</h4><ul><li>Build ML</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img175503.png"></p><hr><h4 id="AWS-Forecast"><a href="#AWS-Forecast" class="headerlink" title="AWS Forecast"></a>AWS Forecast</h4><ul><li>Forecast things using ML</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img180029.png"></p><hr><h4 id="AWS-Kendra"><a href="#AWS-Kendra" class="headerlink" title="AWS Kendra"></a>AWS Kendra</h4><ul><li>Document search service</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img180235.png"></p><hr><h4 id="AWS-Personalize"><a href="#AWS-Personalize" class="headerlink" title="AWS Personalize"></a>AWS Personalize</h4><ul><li>Personal Recommendation</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img180943.png"></p><hr><h4 id="AWS-Textract"><a href="#AWS-Textract" class="headerlink" title="AWS Textract"></a>AWS Textract</h4><ul><li>Extract text</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img181533.png"></p><hr><h4 id="Summary-13"><a href="#Summary-13" class="headerlink" title="Summary"></a>Summary</h4><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img181025.png"></p><hr><h3 id="15-Account-Management，Billing-amp-Support"><a href="#15-Account-Management，Billing-amp-Support" class="headerlink" title="15. Account Management，Billing &amp; Support"></a>15. Account Management，Billing &amp; Support</h3><h4 id="AWS-Organization"><a href="#AWS-Organization" class="headerlink" title="AWS Organization"></a>AWS Organization</h4><ul><li>Manage multiple AWS accounts</li><li>Consolidated Billing</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img215935.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img220144.png"></p><hr><h4 id="AWS-Control-Tower"><a href="#AWS-Control-Tower" class="headerlink" title="AWS Control Tower"></a>AWS Control Tower</h4><ul><li>Running on top of AWS Organization</li><li>AWS Control Tower is an AWS native service providing a pre-defined set of blueprints and guardrails to help customers implement a landing zone for new AWS accounts</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img230602.png"></p><hr><h4 id="AWS-Service-Catalog"><a href="#AWS-Service-Catalog" class="headerlink" title="AWS Service Catalog"></a>AWS Service Catalog</h4><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img230820.png"></p><hr><h4 id="Pricing-Models-in-AWS"><a href="#Pricing-Models-in-AWS" class="headerlink" title="Pricing Models in AWS"></a>Pricing Models in AWS</h4><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img231117.png"></p><hr><h4 id="AWS-Compute-Optimizer"><a href="#AWS-Compute-Optimizer" class="headerlink" title="AWS Compute Optimizer"></a>AWS Compute Optimizer</h4><ul><li>Reduce cost and improve performance</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img232258.png"></p><hr><h4 id="Cost-Allocation-Tags"><a href="#Cost-Allocation-Tags" class="headerlink" title="Cost Allocation Tags"></a>Cost Allocation Tags</h4><ul><li>For each resource, each tag key must be unique, and each tag key can have only one value</li><li>You must activate both AWS generated tags and user-defined tags separately before they can appear in Cost Explorer or on a cost allocation report</li></ul><hr><h4 id="AWS-Budgets"><a href="#AWS-Budgets" class="headerlink" title="AWS Budgets"></a>AWS Budgets</h4><ul><li>Create alarm when exceed budget</li><li>Budget Types: Cost budget，Usage budget，Reservation budget </li><li>AWS Budgets gives you the ability to set custom budgets that alert you when your costs or usage exceed (or are forecasted to exceed) your budgeted amount.</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img233133.png"></p><hr><h4 id="AWS-Pricing-Calculator"><a href="#AWS-Pricing-Calculator" class="headerlink" title="AWS Pricing Calculator"></a>AWS Pricing Calculator</h4><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img075527.png"></p><hr><h4 id="Cost-and-Usage-Reports"><a href="#Cost-and-Usage-Reports" class="headerlink" title="Cost and Usage Reports"></a>Cost and Usage Reports</h4><ul><li>AWS Cost &amp; Usage Report (AWS CUR) contains the most comprehensive set of cost and usage data available.</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img075737.png"></p><hr><h4 id="Cost-Explorer"><a href="#Cost-Explorer" class="headerlink" title="Cost Explorer"></a>Cost Explorer</h4><ul><li>AWS Cost Explorer has an easy-to-use interface that lets you visualize, understand, and manage your AWS costs and usage over time.</li><li>Can be used to forecast your AWS account usage and costs</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img075833.png"></p><hr><h4 id="AWS-Trusted-Advisor"><a href="#AWS-Trusted-Advisor" class="headerlink" title="AWS Trusted Advisor"></a>AWS Trusted Advisor</h4><ul><li>AWS Trusted Advisor is an online tool that provides you real-time guidance to help you provision your resources following AWS best practices on cost optimization</li><li>Identify unattached or underutilized EBS volumes</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img233600.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img175558.png"></p><hr><h4 id="AWS-Service-Quotas"><a href="#AWS-Service-Quotas" class="headerlink" title="AWS Service Quotas"></a>AWS Service Quotas</h4><ul><li>Service Quotas enables you to view and manage your quotas for AWS services from a central location.</li></ul><hr><h4 id="AWS-Support-Plans-Pricing"><a href="#AWS-Support-Plans-Pricing" class="headerlink" title="AWS Support Plans Pricing"></a>AWS Support Plans Pricing</h4><ul><li>Free，Developer，Business，Enterprise On-Ramp，Enterprise</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img233819.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img234952.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img235020.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img235048.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img235117.png"></p><hr><h4 id="Summary-14"><a href="#Summary-14" class="headerlink" title="Summary"></a>Summary</h4><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img234240.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img234349.png"></p><hr><h3 id="16-Adavanced-Identity"><a href="#16-Adavanced-Identity" class="headerlink" title="16. Adavanced Identity"></a>16. Adavanced Identity</h3><h4 id="AWS-STS"><a href="#AWS-STS" class="headerlink" title="AWS STS"></a>AWS STS</h4><ul><li>Security Token Service</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img072649.png"></p><hr><h4 id="AWS-Cognito"><a href="#AWS-Cognito" class="headerlink" title="AWS Cognito"></a>AWS Cognito</h4><ul><li>处理用户登录 (Google，Facebook)</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img072756.png"></p><hr><h4 id="AWS-IAM-Identity-Center"><a href="#AWS-IAM-Identity-Center" class="headerlink" title="AWS IAM Identity Center"></a>AWS IAM Identity Center</h4><ul><li>One login for multiple accounts</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img073056.png"></p><hr><h4 id="Summary-15"><a href="#Summary-15" class="headerlink" title="Summary"></a>Summary</h4><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img073540.png"></p><hr><h3 id="17-Other-AWS-Services"><a href="#17-Other-AWS-Services" class="headerlink" title="17. Other AWS Services"></a>17. Other AWS Services</h3><h4 id="AWS-WorkSpace"><a href="#AWS-WorkSpace" class="headerlink" title="AWS WorkSpace"></a>AWS WorkSpace</h4><ul><li>Global cloud-based products</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img083303.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img083335.png"></p><hr><h4 id="AWS-AppStream"><a href="#AWS-AppStream" class="headerlink" title="AWS AppStream"></a>AWS AppStream</h4><ul><li>Deliver application within web</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img083422.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img083502.png"></p><hr><h4 id="AWS-IoT"><a href="#AWS-IoT" class="headerlink" title="AWS IoT"></a>AWS IoT</h4><ul><li>物联网</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img083607.png"></p><hr><h4 id="AWS-AppSync"><a href="#AWS-AppSync" class="headerlink" title="AWS AppSync"></a>AWS AppSync</h4><ul><li>GraphQL</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img083702.png"></p><hr><h4 id="AWS-Amplify"><a href="#AWS-Amplify" class="headerlink" title="AWS Amplify"></a>AWS Amplify</h4><ul><li>Deploy fullstack web or mobile app</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img085244.png"></p><hr><h4 id="AWS-Application-Composer"><a href="#AWS-Application-Composer" class="headerlink" title="AWS Application Composer"></a>AWS Application Composer</h4><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img085340.png"></p><hr><h4 id="AWS-Device-Farm"><a href="#AWS-Device-Farm" class="headerlink" title="AWS Device Farm"></a>AWS Device Farm</h4><ul><li>Test web app in different devices</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img085508.png"></p><hr><h4 id="AWS-Backup"><a href="#AWS-Backup" class="headerlink" title="AWS Backup"></a>AWS Backup</h4><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img085539.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img085603.png"></p><hr><h4 id="Disaster-Recovery-Strategies"><a href="#Disaster-Recovery-Strategies" class="headerlink" title="Disaster Recovery Strategies"></a>Disaster Recovery Strategies</h4><ul><li>最便宜: Back and Restore</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img085705.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img085729.png"></p><hr><h4 id="AWS-DRS"><a href="#AWS-DRS" class="headerlink" title="AWS DRS"></a>AWS DRS</h4><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img085904.png"></p><hr><h4 id="AWS-DataSync"><a href="#AWS-DataSync" class="headerlink" title="AWS DataSync"></a>AWS DataSync</h4><ul><li>Incremental</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img085958.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img090038.png"></p><hr><h4 id="AWS-Application-Discovery-Service"><a href="#AWS-Application-Discovery-Service" class="headerlink" title="AWS Application Discovery Service"></a>AWS Application Discovery Service</h4><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img090147.png"></p><hr><h4 id="AWS-Application-Migration-Service"><a href="#AWS-Application-Migration-Service" class="headerlink" title="AWS Application Migration Service"></a>AWS Application Migration Service</h4><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img090259.png"></p><hr><h4 id="AWS-Migration-Hub"><a href="#AWS-Migration-Hub" class="headerlink" title="AWS Migration Hub"></a>AWS Migration Hub</h4><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img090459.png"></p><hr><h4 id="AWS-Migration-Evaluator"><a href="#AWS-Migration-Evaluator" class="headerlink" title="AWS Migration Evaluator"></a>AWS Migration Evaluator</h4><ul><li>AWS Migration Evaluator (Formerly TSO Logic) is a complimentary service to create data-driven business cases for AWS Cloud planning and migration.</li></ul><hr><h4 id="AWS-FIS"><a href="#AWS-FIS" class="headerlink" title="AWS FIS"></a>AWS FIS</h4><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img090535.png"></p><hr><h4 id="AWS-Step-Functions"><a href="#AWS-Step-Functions" class="headerlink" title="AWS Step Functions"></a>AWS Step Functions</h4><ul><li>Serverless</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img090614.png"></p><hr><h4 id="AWS-Ground-Station"><a href="#AWS-Ground-Station" class="headerlink" title="AWS Ground Station"></a>AWS Ground Station</h4><ul><li>Satellite</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img090709.png"></p><hr><h4 id="AWS-Pinpoint"><a href="#AWS-Pinpoint" class="headerlink" title="AWS Pinpoint"></a>AWS Pinpoint</h4><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img090818.png"></p><hr><h4 id="AWS-Systems-Manager"><a href="#AWS-Systems-Manager" class="headerlink" title="AWS Systems Manager"></a>AWS Systems Manager</h4><ul><li>AWS Systems Manager allows you to centralize operational data from multiple AWS services and automate tasks across your AWS resources.</li><li>Get operational insights of its resources to quickly identify any issues that might impact applications using those resources</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img075954.png"></p><hr><h4 id="AWS-Systems-Manager-Session-Manager-SSM"><a href="#AWS-Systems-Manager-Session-Manager-SSM" class="headerlink" title="AWS Systems Manager Session Manager (SSM)"></a>AWS Systems Manager Session Manager (SSM)</h4><ul><li>AWS SSM Session Manager is a fully-managed service that provides you with an interactive browser-based shell and CLI experience.</li><li>Runs on a fleet of Amazon EC2 instances</li></ul><hr><h4 id="AWS-SSO"><a href="#AWS-SSO" class="headerlink" title="AWS SSO"></a>AWS SSO</h4><ul><li>AWS SSO is an AWS service that enables you to makes it easy to centrally manage access to multiple AWS accounts and business applications and provide users with single sign-on access to all their assigned accounts and applications from one place.</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img080225.png"></p><hr><h4 id="AWS-Quick-Starts-references"><a href="#AWS-Quick-Starts-references" class="headerlink" title="AWS Quick Starts references"></a>AWS Quick Starts references</h4><ul><li>Quick Starts are built by AWS solutions architects and partners to help you deploy popular technologies on AWS, based on AWS best practices for security and high availability.</li></ul><hr><h4 id="APN-Consulting-Partner"><a href="#APN-Consulting-Partner" class="headerlink" title="APN Consulting Partner"></a>APN Consulting Partner</h4><ul><li>APN Consulting Partners are professional services firms that help customers of all types and sizes design, architect, build, migrate, and manage their workloads and applications on AWS, accelerating their migration to AWS cloud.</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img080758.png"></p><hr><h4 id="Penetration-Testing"><a href="#Penetration-Testing" class="headerlink" title="Penetration Testing"></a>Penetration Testing</h4><ul><li>AWS customers can carry out security assessments or penetration tests against their AWS infrastructure without prior approval for few common AWS services.</li></ul><hr><h4 id="AWS-Personal-Health-Dashboard"><a href="#AWS-Personal-Health-Dashboard" class="headerlink" title="AWS Personal Health Dashboard"></a>AWS Personal Health Dashboard</h4><ul><li>AWS Personal Health Dashboard provides alerts and remediation guidance when AWS is experiencing events that may impact you.</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img083000.png"></p><hr><h4 id="AWS-Service-Health-Dashboard"><a href="#AWS-Service-Health-Dashboard" class="headerlink" title="AWS Service Health Dashboard"></a>AWS Service Health Dashboard</h4><ul><li>AWS Service Health Dashboard publishes most up-to-the-minute information on the status and availability of all AWS services in tabular form for all Regions that AWS is present in.</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img083127.png"></p><hr><h4 id="AWS-Marketplace"><a href="#AWS-Marketplace" class="headerlink" title="AWS Marketplace"></a>AWS Marketplace</h4><ul><li>Sell Software as a Service (SaaS) solutions to AWS customers</li><li>AWS customer can buy software that has been bundled into customized AMIs by the AWS Marketplace sellers</li></ul><hr><h4 id="AWS-Service-Catalog-1"><a href="#AWS-Service-Catalog-1" class="headerlink" title="AWS Service Catalog"></a>AWS Service Catalog</h4><ul><li>AWS Service Catalog allows organizations to create and manage catalogs of IT services that are approved for use on AWS.</li></ul><hr><h4 id="AWS-Well-Architected-Tool"><a href="#AWS-Well-Architected-Tool" class="headerlink" title="AWS Well-Architected Tool"></a>AWS Well-Architected Tool</h4><ul><li>The AWS Well-Architected Tool helps you review the state of your workloads and compares them to the latest AWS architectural best practices.</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img175558.png"></p><hr><h4 id="AWS-Resource-Groups"><a href="#AWS-Resource-Groups" class="headerlink" title="AWS Resource Groups"></a>AWS Resource Groups</h4><ul><li>You can use AWS Resource Groups to organize your AWS resources. Resource groups make it easier to manage and automate tasks on large numbers of resources at a time.</li></ul><hr><h4 id="AWS-Cloud-Foundations"><a href="#AWS-Cloud-Foundations" class="headerlink" title="AWS Cloud Foundations"></a>AWS Cloud Foundations</h4><ul><li>Cloud Foundations provides a guided path to help customers deploy, configure, and secure their new workloads while ensuring they are ready for on-going operations in the cloud.</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img170401.png"></p><hr><h4 id="Credentials-Report"><a href="#Credentials-Report" class="headerlink" title="Credentials Report"></a>Credentials Report</h4><ul><li>You can generate and download a credentials report that lists all users in your account and the status of their various credentials, including passwords, access keys, and MFA devices.</li></ul><hr><h4 id="CloudEndure-Disaster-Recovery"><a href="#CloudEndure-Disaster-Recovery" class="headerlink" title="CloudEndure Disaster Recovery"></a>CloudEndure Disaster Recovery</h4><ul><li>CloudEndure Disaster Recovery enables you to use AWS Cloud as a disaster recovery Region for an on-premises workload and its environment.</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img091100.png"></p><hr><h3 id="18-AWS-Architecting-amp-Ecosystem"><a href="#18-AWS-Architecting-amp-Ecosystem" class="headerlink" title="18. AWS Architecting &amp; Ecosystem"></a>18. AWS Architecting &amp; Ecosystem</h3><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img091239.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img091320.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img091347.png"></p><hr><h4 id="Operation-Excellence"><a href="#Operation-Excellence" class="headerlink" title="Operation Excellence"></a>Operation Excellence</h4><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img091439.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img091513.png"></p><hr><h4 id="Security"><a href="#Security" class="headerlink" title="Security"></a>Security</h4><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img091656.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img091735.png"></p><hr><h4 id="Reliability"><a href="#Reliability" class="headerlink" title="Reliability"></a>Reliability</h4><ul><li>AWS Config，AWS CloudTrail，Amazon CloudWatch</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img091813.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img091848.png"></p><hr><h4 id="Performance-Efficiency"><a href="#Performance-Efficiency" class="headerlink" title="Performance Efficiency"></a>Performance Efficiency</h4><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img091927.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img091956.png"></p><hr><h4 id="Cost-Optimization"><a href="#Cost-Optimization" class="headerlink" title="Cost Optimization"></a>Cost Optimization</h4><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img092031.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img092058.png"></p><hr><h4 id="Sustainability"><a href="#Sustainability" class="headerlink" title="Sustainability"></a>Sustainability</h4><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img092133.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img092201.png"></p><hr><h4 id="Cloud-Adoption-Framework-CAF"><a href="#Cloud-Adoption-Framework-CAF" class="headerlink" title="Cloud Adoption Framework (CAF)"></a>Cloud Adoption Framework (CAF)</h4><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img092346.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img092416.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img092445.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img151051.png"><br><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img151120.png"></p><hr><h4 id="AWS-IQ"><a href="#AWS-IQ" class="headerlink" title="AWS IQ"></a>AWS IQ</h4><ul><li>找人帮忙</li></ul><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img092907.png"></p><hr><h4 id="AWS-AMS"><a href="#AWS-AMS" class="headerlink" title="AWS AMS"></a>AWS AMS</h4><p><img src="https://raw.githubusercontent.com/Hongda-OSU/PicGo-2.3.1/master/img093104.png"></p><hr><h3 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h3><blockquote><p>请勿随意修改，谢谢</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Certification </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AWS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端</title>
      <link href="/posts/bfacd5b7.html"/>
      <url>/posts/bfacd5b7.html</url>
      
        <content type="html"><![CDATA[<h3 id="滚动视差"><a href="#滚动视差" class="headerlink" title="滚动视差"></a>滚动视差</h3><iframe width="100%" height="400px" src="//jsfiddle.net/HDL52/fnhrbse2/101/embedded/result/dark/" allowfullscreen="allowfullscreen" allowpaymentrequest frameborder="0"></iframe><h3 id="打字效果"><a href="#打字效果" class="headerlink" title="打字效果"></a>打字效果</h3><p>从前后端的角度应该用 Stream 来做</p><iframe width="100%" height="400px" src="//jsfiddle.net/HDL52/qgaywfs8/55/embedded/result/dark/" allowfullscreen="allowfullscreen" allowpaymentrequest frameborder="0"></iframe><iframe src="https://codesandbox.io/embed/fw94fg?view=preview&module=%2Fsrc%2Findex.js"     style="width:100%; height: 500px; border:0; border-radius: 4px; overflow:hidden;"     title="inspiring-violet"     allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"     sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"   ></iframe><h3 id="3D-卡片效果"><a href="#3D-卡片效果" class="headerlink" title="3D 卡片效果"></a>3D 卡片效果</h3><p>Reference: <code>https://www.cnblogs.com/coco1s/p/17979602</code></p><iframe width="100%" height="400px" src="//jsfiddle.net/HDL52/cswk73b2/41/embedded/result/dark/" allowfullscreen="allowfullscreen" allowpaymentrequest frameborder="0"></iframe><iframe src="https://codesandbox.io/embed/cwy6d7?view=preview&module=%2Fsrc%2FCard.js"     style="width:100%; height: 500px; border:0; border-radius: 4px; overflow:hidden;"     title="crazy-lumiere-cwy6d7"     allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"     sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"   ></iframe><h3 id="卡片效果"><a href="#卡片效果" class="headerlink" title="卡片效果"></a>卡片效果</h3><iframe width="100%" height="400px" src="//jsfiddle.net/HDL52/9czbrops/46/embedded/result/dark/" allowfullscreen="allowfullscreen" allowpaymentrequest frameborder="0"></iframe><h3 id="下划线特效"><a href="#下划线特效" class="headerlink" title="下划线特效"></a>下划线特效</h3><iframe width="100%" height="400px" src="//jsfiddle.net/HDL52/xpq1g3eu/63/embedded/result/dark/" allowfullscreen="allowfullscreen" allowpaymentrequest frameborder="0"></iframe><h3 id="Zoom-效果"><a href="#Zoom-效果" class="headerlink" title="Zoom 效果"></a>Zoom 效果</h3><iframe width="100%" height="400px" src="//jsfiddle.net/HDL52/cpuLzsfm/137/embedded/result/dark/" allowfullscreen="allowfullscreen" allowpaymentrequest frameborder="0"></iframe><h3 id="视频背景"><a href="#视频背景" class="headerlink" title="视频背景"></a>视频背景</h3><iframe width="100%" height="400px" src="//jsfiddle.net/HDL52/wdehmqgp/50/embedded/result/dark/" allowfullscreen="allowfullscreen" allowpaymentrequest frameborder="0"></iframe><h3 id="头像特效"><a href="#头像特效" class="headerlink" title="头像特效"></a>头像特效</h3><iframe width="100%" height="400px" src="//jsfiddle.net/HDL52/56y0gqzw/37/embedded/result/dark/" allowfullscreen="allowfullscreen" allowpaymentrequest frameborder="0"></iframe><h3 id="鼠标效果"><a href="#鼠标效果" class="headerlink" title="鼠标效果"></a>鼠标效果</h3><iframe width="100%" height="400px" src="//jsfiddle.net/HDL52/qxndvehu/21/embedded/result/dark/" allowfullscreen="allowfullscreen" allowpaymentrequest frameborder="0"></iframe><iframe width="100%" height="400px" src="//jsfiddle.net/HDL52/8trua6n4/16/embedded/result/dark/" allowfullscreen="allowfullscreen" allowpaymentrequest frameborder="0"></iframe><iframe src="https://codesandbox.io/embed/fgrc6y?view=preview&module=%2Fsrc%2Fstyles.css"     style="width:100%; height: 500px; border:0; border-radius: 4px; overflow:hidden;"     title="鼠标特效"     allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"     sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"   ></iframe><h3 id="图片倒影"><a href="#图片倒影" class="headerlink" title="图片倒影"></a>图片倒影</h3><iframe width="100%" height="400px" src="//jsfiddle.net/HDL52/v5Loj9b1/74/embedded/result/dark/" allowfullscreen="allowfullscreen" allowpaymentrequest frameborder="0"></iframe><h3 id="噪音"><a href="#噪音" class="headerlink" title="噪音"></a>噪音</h3><iframe width="100%" height="400px" src="//jsfiddle.net/HDL52/ksyx497p/4/embedded/result/dark/" allowfullscreen="allowfullscreen" allowpaymentrequest frameborder="0"></iframe><h3 id="简单图片堆叠"><a href="#简单图片堆叠" class="headerlink" title="简单图片堆叠"></a>简单图片堆叠</h3><iframe width="100%" height="400px" src="//jsfiddle.net/HDL52/sfc0anmu/85/embedded/result/dark/" allowfullscreen="allowfullscreen" allowpaymentrequest frameborder="0"></iframe><h3 id="视差滚动"><a href="#视差滚动" class="headerlink" title="视差滚动"></a>视差滚动</h3><iframe width="100%" height="400px" src="//jsfiddle.net/HDL52/28rnshqx/88/embedded/result/dark/" allowfullscreen="allowfullscreen" allowpaymentrequest frameborder="0"></iframe><h3 id="人潮汹涌"><a href="#人潮汹涌" class="headerlink" title="人潮汹涌"></a>人潮汹涌</h3><iframe width="100%" height="400px" src="//jsfiddle.net/HDL52/dyhzrxpm/35/embedded/result/dark/" allowfullscreen="allowfullscreen" allowpaymentrequest frameborder="0"></iframe><h3 id="文字特效"><a href="#文字特效" class="headerlink" title="文字特效"></a>文字特效</h3><iframe width="100%" height="400px" src="//jsfiddle.net/HDL52/0ezmgf81/253/embedded/result/dark/" allowfullscreen="allowfullscreen" allowpaymentrequest frameborder="0"></iframe><h3 id="图片消失"><a href="#图片消失" class="headerlink" title="图片消失"></a>图片消失</h3><iframe width="100%" height="400px" src="//jsfiddle.net/HDL52/e9kzqtop/228/embedded/result/dark/" allowfullscreen="allowfullscreen" allowpaymentrequest frameborder="0"></iframe><h3 id="奇怪的特效"><a href="#奇怪的特效" class="headerlink" title="奇怪的特效"></a>奇怪的特效</h3><iframe width="100%" height="400px" src="//jsfiddle.net/HDL52/cyL2t579/34/embedded/result/dark/" allowfullscreen="allowfullscreen" allowpaymentrequest frameborder="0"></iframe><h3 id="横幅效果"><a href="#横幅效果" class="headerlink" title="横幅效果"></a>横幅效果</h3><iframe width="100%" height="400px" src="//jsfiddle.net/HDL52/s8r6qtmg/153/embedded/result/dark/" allowfullscreen="allowfullscreen" allowpaymentrequest frameborder="0"></iframe><h3 id="Hover-效果"><a href="#Hover-效果" class="headerlink" title="Hover 效果"></a>Hover 效果</h3><iframe width="100%" height="400px" src="//jsfiddle.net/HDL52/bf476zy1/11/embedded/result/dark/" allowfullscreen="allowfullscreen" allowpaymentrequest frameborder="0"></iframe><iframe width="100%" height="400px" src="//jsfiddle.net/HDL52/ok27hLs1/8/embedded/result/dark/" allowfullscreen="allowfullscreen" allowpaymentrequest frameborder="0"></iframe><iframe width="100%" height="400px" src="//jsfiddle.net/HDL52/fw9reojc/105/embedded/result/dark/" allowfullscreen="allowfullscreen" allowpaymentrequest frameborder="0"></iframe><iframe width="100%" height="400px" src="//jsfiddle.net/HDL52/anumv6g4/87/embedded/result/dark/" allowfullscreen="allowfullscreen" allowpaymentrequest frameborder="0"></iframe><h3 id="Dragable"><a href="#Dragable" class="headerlink" title="Dragable"></a>Dragable</h3><iframe width="100%" height="400px" src="//jsfiddle.net/HDL52/x4s5dnrq/74/embedded/result/dark/" allowfullscreen="allowfullscreen" allowpaymentrequest frameborder="0"></iframe><h3 id="无限图片"><a href="#无限图片" class="headerlink" title="无限图片"></a>无限图片</h3><iframe src="https://codesandbox.io/embed/k98xf4?view=Editor+%2B+Preview&module=%2Fstyles.css"     style="width:100%; height: 500px; border:0; border-radius: 4px; overflow:hidden;"     title="reverent-benz (forked)"     allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"     sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"   ></iframe><h3 id="神光"><a href="#神光" class="headerlink" title="神光"></a>神光</h3><iframe width="100%" height="400px" src="//jsfiddle.net/HDL52/cLmaf6tu/60/embedded/result/dark/" allowfullscreen="allowfullscreen" allowpaymentrequest frameborder="0"></iframe><h3 id="kokomi-js-用例"><a href="#kokomi-js-用例" class="headerlink" title="kokomi.js 用例"></a>kokomi.js 用例</h3><iframe src="https://codesandbox.io/embed/p4xxc9?view=Editor+%2B+Preview&module=%2Findex.html"     style="width:100%; height: 500px; border:0; border-radius: 4px; overflow:hidden;"     title="inspiring-violet"     allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"     sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"   ></iframe><h3 id="跑马灯效果"><a href="#跑马灯效果" class="headerlink" title="跑马灯效果"></a>跑马灯效果</h3><h3 id="字体翻转"><a href="#字体翻转" class="headerlink" title="字体翻转"></a>字体翻转</h3><iframe src="https://codesandbox.io/embed/xhs6ws?view=preview&module=%2Fsrc%2FApp.js&hidenavigation=1"     style="width:100%; height: 500px; border:0; border-radius: 4px; overflow:hidden;"     title="翻转"     allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"     sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"   ></iframe><h3 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h3><blockquote><p>请勿随意修改，谢谢</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 练习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法 Algorithm • 下</title>
      <link href="/posts/3b015f5e.html"/>
      <url>/posts/3b015f5e.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>本读书笔记节选自<code>krahets</code>大佬编写的<a href="https://www.hello-algo.com/">《Hello 算法》</a>。勉励自己开始系统的算法学习。</p></blockquote><hr><h2 id="10-搜索"><a href="#10-搜索" class="headerlink" title="10. 搜索"></a>10. 搜索</h2><h3 id="10-1-二分查找"><a href="#10-1-二分查找" class="headerlink" title="10.1 二分查找"></a>10.1 二分查找</h3><p>「二分查找<code>binary search</code>」是一种基于分治策略的高效搜索算法。它利用数据的有序性，每轮减少一半搜索范围，直至找到目标元素或搜索区间为空为止。</p><blockquote><p>给定一个长度为<code>n</code>的数组<code>nums</code>，元素按从小到大的顺序排列，数组不包含重复元素。请查找并返回元素<code>target</code>在该数组中的索引。若数组不包含该元素，则返回<code>-1</code>。</p></blockquote><p><img src="https://www.hello-algo.com/chapter_searching/binary_search.assets/binary_search_example.png"></p><p>如下图所示，先初始化指针<code>i = 0</code>和<code>j = n - 1</code>，分别指向数组首元素和尾元素，代表搜索区间<code>[0, n - 1]</code>。请注意，中括号表示闭区间，其包含边界值本身。</p><p>接下来，循环执行以下两步。</p><ul><li>计算中点索引<code>m = [(i + j) / 2]</code>，其中<code>[]</code>表示向下取整操作。</li><li>判断<code>nums[m]</code>和<code>target</code>的大小关系，分为以下三种情况。<ul><li>当<code>nums[m] &lt; target</code>时，说明<code>target</code>在区间<code>[m + 1, j]</code>中，执行<code>i = m + 1</code>。</li><li>当<code>nums[m] &gt; target</code>时，说明<code>target</code>在区间<code>[i, m - 1]</code>中，执行<code>j = m - 1</code>。</li><li>当<code>nums[m] = target</code>时，说明找到<code>target</code>，因此返回索引<code>m</code>。</li></ul></li></ul><p>若数组不包含目标元素，搜索区间最终会缩小为空。此时返回<code>-1</code>。</p><div class="tabs" id="placeholder"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#placeholder-1"><1></button></li><li class="tab"><button type="button" data-href="#placeholder-2"><2></button></li><li class="tab"><button type="button" data-href="#placeholder-3"><3></button></li><li class="tab"><button type="button" data-href="#placeholder-4"><4></button></li><li class="tab"><button type="button" data-href="#placeholder-5"><5></button></li><li class="tab"><button type="button" data-href="#placeholder-6"><6></button></li><li class="tab"><button type="button" data-href="#placeholder-7"><7></button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="placeholder-1"><p><img src="https://www.hello-algo.com/chapter_searching/binary_search.assets/binary_search_step1.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="placeholder-2"><p><img src="https://www.hello-algo.com/chapter_searching/binary_search.assets/binary_search_step2.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="placeholder-3"><p><img src="https://www.hello-algo.com/chapter_searching/binary_search.assets/binary_search_step3.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="placeholder-4"><p><img src="https://www.hello-algo.com/chapter_searching/binary_search.assets/binary_search_step4.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="placeholder-5"><p><img src="https://www.hello-algo.com/chapter_searching/binary_search.assets/binary_search_step5.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="placeholder-6"><p><img src="https://www.hello-algo.com/chapter_searching/binary_search.assets/binary_search_step6.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="placeholder-7"><p><img src="https://www.hello-algo.com/chapter_searching/binary_search.assets/binary_search_step7.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>值得注意的是，由于<code>i</code>和<code>j</code>都是<code>int</code>类型，因此<code>i + j</code>可能会超出<code>int</code>类型的取值范围。为了避免大数越界，通常采用公式<code>m = [i + (j - i) / 2]</code>来计算中点。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 二分查找（双闭区间） */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="comment">// 初始化双闭区间 [0, n-1] ，即 i, j 分别指向数组首元素、尾元素</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 循环，当搜索区间为空时跳出（当 i &gt; j 时为空）</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= j) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> i + (j - i) / <span class="number">2</span>; <span class="comment">// 计算中点索引 m</span></span><br><span class="line">        <span class="keyword">if</span> (nums[m] &lt; target) <span class="comment">// 此情况说明 target 在区间 [m+1, j] 中</span></span><br><span class="line">            i = m + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[m] &gt; target) <span class="comment">// 此情况说明 target 在区间 [i, m-1] 中</span></span><br><span class="line">            j = m - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">// 找到目标元素，返回其索引</span></span><br><span class="line">            <span class="keyword">return</span> m;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 未找到目标元素，返回 -1</span></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：在二分循环中，区间每轮缩小一半，循环次数为<code>O(log2n)</code>。<br>空间复杂度：指针<code>i</code>和<code>j</code>使用常数大小空间。</p><h4 id="区间表示方法"><a href="#区间表示方法" class="headerlink" title="区间表示方法"></a>区间表示方法</h4><p>除了上述的双闭区间外，常见的区间表示还有“左闭右开”区间，定义为<code>[0, n)</code>，即左边界包含自身，右边界不包含自身。在该表示下，区间<code>[i, j]</code>在<code>i = j</code>时为空。</p><p>基于该表示实现具有相同功能的二分查找算法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 二分查找（左闭右开） */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">binarySearchLCRO</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="comment">// 初始化左闭右开 [0, n) ，即 i, j 分别指向数组首元素、尾元素+1</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = nums.length;</span><br><span class="line">    <span class="comment">// 循环，当搜索区间为空时跳出（当 i = j 时为空）</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> i + (j - i) / <span class="number">2</span>; <span class="comment">// 计算中点索引 m</span></span><br><span class="line">        <span class="keyword">if</span> (nums[m] &lt; target) <span class="comment">// 此情况说明 target 在区间 [m+1, j) 中</span></span><br><span class="line">            i = m + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[m] &gt; target) <span class="comment">// 此情况说明 target 在区间 [i, m) 中</span></span><br><span class="line">            j = m;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">// 找到目标元素，返回其索引</span></span><br><span class="line">            <span class="keyword">return</span> m;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 未找到目标元素，返回 -1</span></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如下图所示，在两种区间表示下，二分查找算法的初始化、循环条件和缩小区间操作皆有所不同。</p><p>由于“双闭区间”表示中的左右边界都被定义为闭区间，因此指针<code>i</code>和<code>j</code>缩小区间操作也是对称的。这样更不容易出错，因此一般建议采用“双闭区间”的写法。</p><p><img src="https://www.hello-algo.com/chapter_searching/binary_search.assets/binary_search_ranges.png"></p><hr><h3 id="10-2-二分查找插入点"><a href="#10-2-二分查找插入点" class="headerlink" title="10.2 二分查找插入点"></a>10.2 二分查找插入点</h3><p>二分查找不仅可用于搜索目标元素，还具有许多变种问题，比如搜索目标元素的插入位置。</p><h4 id="无重复元素的情况"><a href="#无重复元素的情况" class="headerlink" title="无重复元素的情况"></a>无重复元素的情况</h4><blockquote><p>给定一个长度为<code>n</code>的有序数组<code>nums</code>和一个元素<code>target</code>，数组不存在重复元素。现将<code>target</code>插入到数组<code>nums</code>中，并保持其有序性。若数组中已存在元素<code>target</code>，则插入到其左方。请返回插入后<code>target</code>在数组中的索引。</p></blockquote><p><img src="https://www.hello-algo.com/chapter_searching/binary_search_insertion.assets/binary_search_insertion_example.png"></p><p>如果想要复用上节的二分查找代码，则需要回答以下两个问题。</p><ul><li>当数组中包含<code>target</code>时，插入点的索引是否是该元素的索引？<ul><li>题目要求将<code>target</code>插入到相等元素的左边，这意味着新插入的<code>target</code>替换了原来<code>target</code>的位置。当数组包含<code>target</code>时，插入点的索引就是该<code>target</code>的索引。</li></ul></li><li>当数组中不存在<code>target</code>时，插入点是哪个元素的索引？<ul><li>思考二分查找过程，当<code>nums[m] &lt; target</code>时<code>i</code>移动，这意味着指针<code>i</code>在向大于等于<code>target</code>的元素靠近。同理，指针 <code>j</code>始终在向小于等于<code>target</code>的元素靠近。</li><li>因此二分结束时一定有，<code>i</code>指向首个大于<code>target</code>的元素，<code>j</code>指向首个小于<code>target</code>的元素。易得当数组不包含<code>target</code>时，插入索引为<code>i</code>。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 二分查找插入点（无重复元素） */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">binarySearchInsertionSimple</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = nums.length - <span class="number">1</span>; <span class="comment">// 初始化双闭区间 [0, n-1]</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= j) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> i + (j - i) / <span class="number">2</span>; <span class="comment">// 计算中点索引 m</span></span><br><span class="line">        <span class="keyword">if</span> (nums[m] &lt; target) &#123;</span><br><span class="line">            i = m + <span class="number">1</span>; <span class="comment">// target 在区间 [m+1, j] 中</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[m] &gt; target) &#123;</span><br><span class="line">            j = m - <span class="number">1</span>; <span class="comment">// target 在区间 [i, m-1] 中</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> m; <span class="comment">// 找到 target ，返回插入点 m</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 未找到 target ，返回插入点 i</span></span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="存在重复元素的情况"><a href="#存在重复元素的情况" class="headerlink" title="存在重复元素的情况"></a>存在重复元素的情况</h4><blockquote><p>在上一题的基础上，规定数组可能包含重复元素，其余不变。</p></blockquote><p>假设数组中存在多个<code>target</code>，则普通二分查找只能返回其中一个<code>target</code>的索引，而无法确定该元素的左边和右边还有多少<code>target</code>。</p><p>题目要求将目标元素插入到最左边，所以需要查找数组中最左一个<code>target</code>的索引。初步考虑通过下图所示的步骤实现。</p><ul><li>执行二分查找，得到任意一个<code>target</code>的索引，记为<code>k</code>。</li><li>从索引<code>k</code>开始，向左进行线性遍历，当找到最左边的<code>target</code>时返回。</li></ul><p><img src="https://www.hello-algo.com/chapter_searching/binary_search_insertion.assets/binary_search_insertion_naive.png"></p><p>此方法虽然可用，但其包含线性查找，因此时间复杂度为<code>O(n)</code>。当数组中存在很多重复的<code>target</code>时，该方法效率很低。</p><p>考虑拓展二分查找代码。如下图所示，整体流程保持不变，每轮先计算中点索引<code>m</code>，再判断<code>target</code>和<code>nums[m]</code>大小关系，分为以下几种情况。</p><ul><li>当<code>nums[m] &lt; target</code>或<code>nums[m] &gt; target</code>时，说明还没有找到<code>target</code>，因此采用普通二分查找的缩小区间操作，从而使指针<code>i</code>和<code>j</code>向<code>target</code>靠近。</li><li>当<code>nums[m] == target</code>时，说明小于<code>target</code>的元素在区间<code>[i, m - 1]</code>中，因此采用<code>j = m - 1</code>来缩小区间，从而使指针<code>j</code>向小于<code>target</code>的元素靠近。</li></ul><p>循环完成后，<code>i</code>指向最左边的<code>target</code>，<code>j</code>指向首个小于<code>target</code>的元素，索引<code>i</code>就是插入点。</p><div class="tabs" id="placeholder"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#placeholder-1"><1></button></li><li class="tab"><button type="button" data-href="#placeholder-2"><2></button></li><li class="tab"><button type="button" data-href="#placeholder-3"><3></button></li><li class="tab"><button type="button" data-href="#placeholder-4"><4></button></li><li class="tab"><button type="button" data-href="#placeholder-5"><5></button></li><li class="tab"><button type="button" data-href="#placeholder-6"><6></button></li><li class="tab"><button type="button" data-href="#placeholder-7"><7></button></li><li class="tab"><button type="button" data-href="#placeholder-8"><8></button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="placeholder-1"><p><img src="https://www.hello-algo.com/chapter_searching/binary_search_insertion.assets/binary_search_insertion_step1.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="placeholder-2"><p><img src="https://www.hello-algo.com/chapter_searching/binary_search_insertion.assets/binary_search_insertion_step2.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="placeholder-3"><p><img src="https://www.hello-algo.com/chapter_searching/binary_search_insertion.assets/binary_search_insertion_step3.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="placeholder-4"><p><img src="https://www.hello-algo.com/chapter_searching/binary_search_insertion.assets/binary_search_insertion_step4.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="placeholder-5"><p><img src="https://www.hello-algo.com/chapter_searching/binary_search_insertion.assets/binary_search_insertion_step5.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="placeholder-6"><p><img src="https://www.hello-algo.com/chapter_searching/binary_search_insertion.assets/binary_search_insertion_step6.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="placeholder-7"><p><img src="https://www.hello-algo.com/chapter_searching/binary_search_insertion.assets/binary_search_insertion_step7.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="placeholder-8"><p><img src="https://www.hello-algo.com/chapter_searching/binary_search_insertion.assets/binary_search_insertion_step8.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>观察以下代码，判断分支<code>nums[m] &gt; target</code>和<code>nums[m] == target</code>的操作相同，因此两者可以合并。但是因为逻辑性，故此保留。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 二分查找插入点（存在重复元素） */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">binarySearchInsertion</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = nums.length - <span class="number">1</span>; <span class="comment">// 初始化双闭区间 [0, n-1]</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= j) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> i + (j - i) / <span class="number">2</span>; <span class="comment">// 计算中点索引 m</span></span><br><span class="line">        <span class="keyword">if</span> (nums[m] &lt; target) &#123;</span><br><span class="line">            i = m + <span class="number">1</span>; <span class="comment">// target 在区间 [m+1, j] 中</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[m] &gt; target) &#123;</span><br><span class="line">            j = m - <span class="number">1</span>; <span class="comment">// target 在区间 [i, m-1] 中</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            j = m - <span class="number">1</span>; <span class="comment">// 首个小于 target 的元素在区间 [i, m-1] 中</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回插入点 i</span></span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总的来看，二分查找无非就是给指针<code>i</code>和<code>j</code>分别设定搜索目标，目标可能是一个具体的元素（例如<code>target</code>），也可能是一个元素范围（例如小于<code>target</code>的元素）。</p><p>在不断的循环二分中，指针<code>i</code>和<code>j</code>都逐渐逼近预先设定的目标。最终，它们或是成功找到答案，或是越过边界后停止。</p><hr><h3 id="10-3-二分查找边界"><a href="#10-3-二分查找边界" class="headerlink" title="10.3 二分查找边界"></a>10.3 二分查找边界</h3><h4 id="查找左边界"><a href="#查找左边界" class="headerlink" title="查找左边界"></a>查找左边界</h4><blockquote><p>给定一个长度为<code>n</code>的有序数组<code>nums</code>，数组可能包含重复元素。请返回数组中最左一个元素<code>target</code>的索引。若数组中不包含该元素，则返回<code>-1</code>。</p></blockquote><p>回忆二分查找插入点的方法，搜索完成后<code>i</code>指向最左一个<code>target</code>，因此查找插入点本质上是在查找最左一个<code>target</code>的索引。</p><p>通过查找插入点的函数实现查找左边界。请注意，数组中可能不包含<code>target</code>，这种情况可能导致以下两种结果。</p><ul><li>插入点的索引<code>i</code>越界。</li><li>元素<code>nums[i]</code>与<code>target</code>不相等。</li></ul><p>当遇到以上两种情况时，直接返回<code>-1</code>即可。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 二分查找最左一个 target */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">binarySearchLeftEdge</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="comment">// 等价于查找 target 的插入点 （10.2）</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> binary_search_insertion.binarySearchInsertion(nums, target);</span><br><span class="line">    <span class="comment">// 未找到 target ，返回 -1</span></span><br><span class="line">    <span class="keyword">if</span> (i == nums.length || nums[i] != target) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 找到 target ，返回索引 i</span></span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="查找右边界"><a href="#查找右边界" class="headerlink" title="查找右边界"></a>查找右边界</h4><p>那么如何查找最右一个<code>target</code>呢？最直接的方式是修改代码，替换在<code>nums[m] == target</code>情况下的指针收缩操作。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">binarySearchRightmost</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = nums.length - <span class="number">1</span>; <span class="comment">// 初始化双闭区间 [0, n-1]</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> -<span class="number">1</span>; <span class="comment">// 存储找到的最右边的目标值索引，初始为 -1 表示未找到</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= j) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> i + (j - i) / <span class="number">2</span>; <span class="comment">// 计算中点索引 m</span></span><br><span class="line">        <span class="keyword">if</span> (nums[m] &lt; target) &#123;</span><br><span class="line">            i = m + <span class="number">1</span>; <span class="comment">// target 在区间 [m+1, j] 中</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[m] &gt; target) &#123;</span><br><span class="line">            j = m - <span class="number">1</span>; <span class="comment">// target 在区间 [i, m-1] 中</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result = m; <span class="comment">// 找到一个目标值的实例，保存索引</span></span><br><span class="line">            i = m + <span class="number">1</span>; <span class="comment">// 继续在右边区间 [m+1, j] 中查找</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回找到的最右边的目标值索引，如果没有找到返回 -1</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面介绍两种更加取巧的方法。</p><p><strong>（1）复用查找左边界</strong></p><p>实际上，可以利用查找最左元素的函数来查找最右元素，具体方法为，将查找最右一个<code>target</code>转化为查找最左一个<code>target + 1</code>。</p><p>如下图所示，查找完成后，指针<code>i</code>指向最左一个<code>target + 1</code>（如果存在），而<code>j</code>指向最右一个<code>target</code>，因此返回<code>j</code>即可。</p><p><img src="https://www.hello-algo.com/chapter_searching/binary_search_edge.assets/binary_search_right_edge_by_left_edge.png"></p><p>请注意，返回的插入点是<code>i</code>，因此需要将其减<code>1</code>，从而获得<code>j</code>。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 二分查找最右一个 target */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">binarySearchRightEdge</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="comment">// 转化为查找最左一个 target + 1</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> binary_search_insertion.binarySearchInsertion(nums, target + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// j 指向最右一个 target ，i 指向首个大于 target 的元素</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 未找到 target ，返回 -1</span></span><br><span class="line">    <span class="keyword">if</span> (j == -<span class="number">1</span> || nums[j] != target) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 找到 target ，返回索引 j</span></span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>（2）转化为查找元素</strong></p><p>当数组不包含<code>target</code>时，最终<code>i</code>和<code>j</code>会分别指向首个大于、小于<code>target</code>的元素。</p><p>因此，如下图所示，可以构造一个数组中不存在的元素，用于查找左右边界。</p><ul><li>查找最左一个<code>target</code>：可以转化为查找<code>target - 0.5</code>，并返回指针<code>i</code>。</li><li>查找最右一个<code>target</code>：可以转化为查找<code>target + 0.5</code>，并返回指针<code>j</code>。</li></ul><p><img src="https://www.hello-algo.com/chapter_searching/binary_search_edge.assets/binary_search_edge_by_element.png"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// i 指向最左一个 target</span></span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> binary_search_insertion.binarySearchInsertion(nums, target - <span class="number">0.5</span>);</span><br><span class="line"><span class="comment">// j 指向最右一个 target</span></span><br><span class="line"><span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> binary_search_insertion.binarySearchInsertion(nums, target + <span class="number">0.5</span>);</span><br></pre></td></tr></table></figure><p>值得注意以下两点。</p><ul><li>给定数组不包含小数，这意味着无须关心如何处理相等的情况。</li><li>因为该方法引入了小数，所以需要将函数中的变量<code>target</code>改为浮点数类型。</li></ul><hr><h3 id="10-4-哈希优化策略"><a href="#10-4-哈希优化策略" class="headerlink" title="10.4 哈希优化策略"></a>10.4 哈希优化策略</h3><p>在算法题中，常通过将线性查找替换为哈希查找来降低算法的时间复杂度。</p><blockquote><p>给定一个整数数组<code>nums</code>和一个目标元素<code>target</code>，请在数组中搜索“和”为<code>target</code>的两个元素，并返回它们的数组索引。返回任意一个解即可。</p></blockquote><h4 id="线性查找：时间换空间"><a href="#线性查找：时间换空间" class="headerlink" title="线性查找：时间换空间"></a>线性查找：时间换空间</h4><p>考虑直接遍历所有可能的组合。如下图所示，开启一个两层循环，在每轮中判断两个整数的和是否为<code>target</code>，若是则返回它们的索引。</p><p><img src="https://www.hello-algo.com/chapter_searching/replace_linear_by_hashing.assets/two_sum_brute_force.png"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 方法一：暴力枚举 */</span></span><br><span class="line"><span class="type">int</span>[] twoSumBruteForce(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="comment">// 两层循环，时间复杂度 O(n^2)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; size; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] + nums[j] == target)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[] &#123; i, j &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此方法的时间复杂度为<code>O(n^2)</code>，空间复杂度为<code>O(1)</code>，在大数据量下非常耗时。</p><h4 id="哈希查找：空间换时间"><a href="#哈希查找：空间换时间" class="headerlink" title="哈希查找：空间换时间"></a>哈希查找：空间换时间</h4><p>借助一个哈希表，键值对分别为数组元素和元素索引。循环遍历数组，每轮执行下图所示的步骤。</p><ul><li>判断数字<code>target - nums[i]</code>是否在哈希表中，若是则直接返回这两个元素的索引。</li><li>将键值对<code>nums[i]</code>和索引<code>i</code>添加进哈希表。</li></ul><div class="tabs" id="placeholder"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#placeholder-1"><1></button></li><li class="tab"><button type="button" data-href="#placeholder-2"><2></button></li><li class="tab"><button type="button" data-href="#placeholder-3"><3></button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="placeholder-1"><p><img src="https://www.hello-algo.com/chapter_searching/replace_linear_by_hashing.assets/two_sum_hashtable_step1.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="placeholder-2"><p><img src="https://www.hello-algo.com/chapter_searching/replace_linear_by_hashing.assets/two_sum_hashtable_step2.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="placeholder-3"><p><img src="https://www.hello-algo.com/chapter_searching/replace_linear_by_hashing.assets/two_sum_hashtable_step3.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>实现代码如下所示，仅需单层循环即可。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 方法二：辅助哈希表 */</span></span><br><span class="line"><span class="type">int</span>[] twoSumHashTable(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="comment">// 辅助哈希表，空间复杂度 O(n)</span></span><br><span class="line">    Map&lt;Integer, Integer&gt; dic = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 单层循环，时间复杂度 O(n)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dic.containsKey(target - nums[i])) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[] &#123; dic.get(target - nums[i]), i &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        dic.put(nums[i], i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此方法通过哈希查找将时间复杂度从<code>O(n^2)</code>降低至<code>O(n)</code>，大幅提升运行效率。</p><p>由于需要维护一个额外的哈希表，因此空间复杂度为<code>O(n)</code>。尽管如此，该方法的整体时空效率更为均衡，因此它是本题的最优解法。</p><hr><h3 id="10-5-重识搜索算法"><a href="#10-5-重识搜索算法" class="headerlink" title="10.5 重识搜索算法"></a>10.5 重识搜索算法</h3><p>搜索算法可根据实现思路分为以下两类。</p><ul><li>通过遍历数据结构来定位目标元素，例如数组、链表、树和图的遍历等。</li><li>利用数据组织结构或数据包含的先验信息，实现高效元素查找，例如二分查找、哈希查找和二叉搜索树查找等。</li></ul><h4 id="暴力搜索"><a href="#暴力搜索" class="headerlink" title="暴力搜索"></a>暴力搜索</h4><p>暴力搜索通过遍历数据结构的每个元素来定位目标元素。</p><ul><li>“线性搜索”适用于数组和链表等线性数据结构。它从数据结构的一端开始，逐个访问元素，直到找到目标元素或到达另一端仍没有找到目标元素为止。</li><li>“广度优先搜索”和“深度优先搜索”是图和树的两种遍历策略。广度优先搜索从初始节点开始逐层搜索，由近及远地访问各个节点。深度优先搜索是从初始节点开始，沿着一条路径走到头为止，再回溯并尝试其他路径，直到遍历完整个数据结构。</li></ul><p>暴力搜索的优点是简单且通用性好，无须对数据做预处理和借助额外的数据结构。</p><p>然而，此类算法的时间复杂度为<code>O(n)</code>，其中<code>n</code>为元素数量，因此在数据量较大的情况下性能较差。</p><h4 id="自适应搜索"><a href="#自适应搜索" class="headerlink" title="自适应搜索"></a>自适应搜索</h4><p>自适应搜索利用数据的特有属性（例如有序性）来优化搜索过程，从而更高效地定位目标元素。</p><ul><li>“二分查找”利用数据的有序性实现高效查找，仅适用于数组。</li><li>“哈希查找”利用哈希表将搜索数据和目标数据建立为键值对映射，从而实现查询操作。</li><li>“树查找”在特定的树结构（例如二叉搜索树）中，基于比较节点值来快速排除节点，从而定位目标元素。</li></ul><p>此类算法的优点是效率高，时间复杂度可达到<code>O(logn)</code>甚至<code>O(1)</code>。</p><p>然而，使用这些算法往往需要对数据进行预处理。例如，二分查找需要预先对数组进行排序，哈希查找和树查找都需要借助额外的数据结构，维护这些数据结构也需要额外的时间和空间开支。</p><h4 id="搜索方法选取"><a href="#搜索方法选取" class="headerlink" title="搜索方法选取"></a>搜索方法选取</h4><p>给定大小为<code>n</code>的一组数据，可以使用线性搜索、二分查找、树查找、哈希查找等多种方法在该数据中搜索目标元素。</p><p><img src="https://www.hello-algo.com/chapter_searching/searching_algorithm_revisited.assets/searching_algorithms.png"></p><p>上述几种方法的操作效率与特性如下表所示。</p><table><thead><tr><th align="left"></th><th align="left">线性搜索</th><th align="left">二分查找</th><th align="left">树查找</th><th align="left">哈希查找</th></tr></thead><tbody><tr><td align="left">查找元素</td><td align="left"><code>O(n)</code></td><td align="left"><code>O(logn)</code></td><td align="left"><code>O(logn)</code></td><td align="left"><code>O(1)</code></td></tr><tr><td align="left">插入元素</td><td align="left"><code>O(1)</code></td><td align="left"><code>O(n)</code></td><td align="left"><code>O(logn)</code></td><td align="left"><code>O(1)</code></td></tr><tr><td align="left">删除元素</td><td align="left"><code>O(n)</code></td><td align="left"><code>O(n)</code></td><td align="left"><code>O(logn)</code></td><td align="left"><code>O(1)</code></td></tr><tr><td align="left">额外空间</td><td align="left"><code>O(1)</code></td><td align="left"><code>O(1)</code></td><td align="left"><code>O(n)</code></td><td align="left"><code>O(n)</code></td></tr><tr><td align="left">数据预处理</td><td align="left"><code>/</code></td><td align="left">排序<code>O(nlogn)</code></td><td align="left">建树<code>O(nlogn)</code></td><td align="left">建哈希表<code>O(n)</code></td></tr><tr><td align="left">数据是否有序</td><td align="left">无序</td><td align="left">有序</td><td align="left">有序</td><td align="left">无序</td></tr></tbody></table><p>具体适用<a href="https://www.hello-algo.com/chapter_searching/searching_algorithm_revisited/#1053">参照</a>，这里就不再讨论。</p><hr><h2 id="11-排序"><a href="#11-排序" class="headerlink" title="11. 排序"></a>11. 排序</h2><h3 id="11-1-排序算法"><a href="#11-1-排序算法" class="headerlink" title="11.1 排序算法"></a>11.1 排序算法</h3><p>「排序算法<code>sorting algorithm</code>」用于对一组数据按照特定顺序进行排列。它有着广泛的应用，因为有序数据通常能够被更有效地查找、分析和处理。</p><p>排序算法中的数据类型可以是整数、浮点数、字符或字符串等。排序的判断规则可根据需求设定，如数字大小、字符<code>ASCII</code>码顺序或自定义规则。</p><p><img src="https://www.hello-algo.com/chapter_sorting/sorting_algorithm.assets/sorting_examples.png"></p><p><strong>评价维度</strong></p><p>排序算法通常根据多个维度来进行评价。下面是一些常见的评价指标。</p><ul><li>运行效率：期望的排序算法时间复杂度尽量低，且总体操作数量较少（即时间复杂度中的常数项降低）。对于大数据量情况，运行效率显得尤为重要。</li><li>就地性：「原地排序」通过在原数组上直接操作实现排序，无须借助额外的辅助数组，从而节省内存。通常情况下，原地排序的数据搬运操作较少，运行速度也更快。</li><li>稳定性：「稳定排序」在完成排序后，相等元素在数组中的相对顺序不发生改变。</li></ul><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line"># 输入数据是按照姓名排序好的</span><br><span class="line"># (name, age)</span><br><span class="line">  (&#x27;A&#x27;, 19)</span><br><span class="line">  (&#x27;B&#x27;, 18)</span><br><span class="line">  (&#x27;C&#x27;, 21)</span><br><span class="line">  (&#x27;D&#x27;, 19)</span><br><span class="line">  (&#x27;E&#x27;, 23)</span><br><span class="line"></span><br><span class="line"># 假设使用非稳定排序算法按年龄排序列表，</span><br><span class="line"># 结果中 (&#x27;D&#x27;, 19) 和 (&#x27;A&#x27;, 19) 的相对位置改变，</span><br><span class="line"># 输入数据按姓名排序的性质丢失</span><br><span class="line">  (&#x27;B&#x27;, 18)</span><br><span class="line">  (&#x27;D&#x27;, 19)</span><br><span class="line">  (&#x27;A&#x27;, 19)</span><br><span class="line">  (&#x27;C&#x27;, 21)</span><br><span class="line">  (&#x27;E&#x27;, 23)</span><br></pre></td></tr></table></figure><ul><li>自适应性：「自适应排序」的时间复杂度会受输入数据的影响，即最佳、最差、平均时间复杂度并不完全相等。</li><li>是否基于比较：「基于比较的排序」依赖于比较运算符（<code>&lt;</code>、<code>=</code>、<code>&gt;</code>）来判断元素的相对顺序，从而排序整个数组，理论最优时间复杂度为<code>O(nlogn)</code>。而「非比较排序」不使用比较运算符，时间复杂度可达<code>O(n)</code>，但其通用性相对较差。</li></ul><p>运行快、原地、稳定、正向自适应、通用性好。显然，迄今为止尚未发现兼具以上所有特性的排序算法。因此，在选择排序算法时，需要根据具体的数据特点和问题需求来决定。</p><hr><h3 id="11-2-选择排序"><a href="#11-2-选择排序" class="headerlink" title="11.2 选择排序"></a>11.2 选择排序</h3><p>「选择排序<code>selection sort</code>」的工作原理非常直接，开启一个循环，每轮从未排序区间选择最小的元素，将其放到已排序区间的末尾。</p><p>设数组的长度为<code>n</code>，选择排序的算法流程如下图所示。</p><ul><li>初始状态下，所有元素未排序，即未排序（索引）区间为<code>[0, n - 1]</code>。</li><li>选取区间<code>[0, n - 1]</code>中的最小元素，将其与索引<code>0</code>处元素交换。数组前<code>1</code>个元素已排序。</li><li>选取区间<code>[1, n - 1]</code>中的最小元素，将其与索引<code>1</code>处元素交换。数组前<code>2</code>个元素已排序。</li><li>以此类推。经过<code>n - 1</code>轮选择与交换后，数组前<code>n - 1</code>个元素已排序。</li><li>仅剩的一个元素必定是最大元素，无须排序，因此数组排序完成。</li></ul><div class="tabs" id="placeholder"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#placeholder-1">1</button></li><li class="tab"><button type="button" data-href="#placeholder-2">2</button></li><li class="tab"><button type="button" data-href="#placeholder-3">3</button></li><li class="tab"><button type="button" data-href="#placeholder-4">4</button></li><li class="tab"><button type="button" data-href="#placeholder-5">5</button></li><li class="tab"><button type="button" data-href="#placeholder-6">6</button></li><li class="tab"><button type="button" data-href="#placeholder-7">7</button></li><li class="tab"><button type="button" data-href="#placeholder-8">8</button></li><li class="tab"><button type="button" data-href="#placeholder-9">9</button></li><li class="tab"><button type="button" data-href="#placeholder-10">10</button></li><li class="tab"><button type="button" data-href="#placeholder-11">11</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="placeholder-1"><p><img src="https://www.hello-algo.com/chapter_sorting/selection_sort.assets/selection_sort_step1.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="placeholder-2"><p><img src="https://www.hello-algo.com/chapter_sorting/selection_sort.assets/selection_sort_step2.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="placeholder-3"><p><img src="https://www.hello-algo.com/chapter_sorting/selection_sort.assets/selection_sort_step3.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="placeholder-4"><p><img src="https://www.hello-algo.com/chapter_sorting/selection_sort.assets/selection_sort_step4.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="placeholder-5"><p><img src="https://www.hello-algo.com/chapter_sorting/selection_sort.assets/selection_sort_step5.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="placeholder-6"><p><img src="https://www.hello-algo.com/chapter_sorting/selection_sort.assets/selection_sort_step6.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="placeholder-7"><p><img src="https://www.hello-algo.com/chapter_sorting/selection_sort.assets/selection_sort_step7.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="placeholder-8"><p><img src="https://www.hello-algo.com/chapter_sorting/selection_sort.assets/selection_sort_step8.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="placeholder-9"><p><img src="https://www.hello-algo.com/chapter_sorting/selection_sort.assets/selection_sort_step9.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="placeholder-10"><p><img src="https://www.hello-algo.com/chapter_sorting/selection_sort.assets/selection_sort_step10.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="placeholder-11"><p><img src="https://www.hello-algo.com/chapter_sorting/selection_sort.assets/selection_sort_step11.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>在代码中，使用<code>k</code>来记录未排序区间内的最小元素。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 选择排序 */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">selectionSort</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="comment">// 外循环：未排序区间为 [i, n-1]</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 内循环：找到未排序区间内的最小元素</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[j] &lt; nums[k])</span><br><span class="line">                k = j; <span class="comment">// 记录最小元素的索引</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将该最小元素与未排序区间的首个元素交换</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[i];</span><br><span class="line">        nums[i] = nums[k];</span><br><span class="line">        nums[k] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>算法特性</strong></p><ul><li>时间复杂度为<code>O(n^2)</code>、非自适应排序：外循环共<code>n - 1</code>轮，第一轮的未排序区间长度为<code>n</code>，最后一轮的未排序区间长度为<code>2</code>，即各轮外循环分别包含<code>n</code>、<code>n - 1</code>、<code>...</code>、<code>3</code>、<code>2</code>轮内循环，求和为<code>((n - 1)(n - 2)) / 2</code>。</li><li>空间复杂度<code>O(1)</code>、原地排序：指针<code>i</code>和<code>j</code>使用常数大小的额外空间。</li><li>非稳定排序：如下图所示，元素<code>nums[i]</code>有可能被交换至与其相等的元素的右边，导致两者相对顺序发生改变。</li></ul><p><img src="https://www.hello-algo.com/chapter_sorting/selection_sort.assets/selection_sort_instability.png"></p><hr><h3 id="11-3-冒泡排序"><a href="#11-3-冒泡排序" class="headerlink" title="11.3 冒泡排序"></a>11.3 冒泡排序</h3><p>「冒泡排序<code>bubble sort</code>」通过连续地比较与交换相邻元素实现排序。这个过程就像气泡从底部升到顶部一样，因此得名冒泡排序。</p><p>如下图所示，冒泡过程可以利用元素交换操作来模拟。从数组最左端开始向右遍历，依次比较相邻元素大小，如果“左元素 <code>&gt;</code> 右元素”就交换它俩。遍历完成后，最大的元素会被移动到数组的最右端。</p><div class="tabs" id="placeholder"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#placeholder-1"><1></button></li><li class="tab"><button type="button" data-href="#placeholder-2"><2></button></li><li class="tab"><button type="button" data-href="#placeholder-3"><3></button></li><li class="tab"><button type="button" data-href="#placeholder-4"><4></button></li><li class="tab"><button type="button" data-href="#placeholder-5"><5></button></li><li class="tab"><button type="button" data-href="#placeholder-6"><6></button></li><li class="tab"><button type="button" data-href="#placeholder-7"><7></button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="placeholder-1"><p><img src="https://www.hello-algo.com/chapter_sorting/bubble_sort.assets/bubble_operation_step1.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="placeholder-2"><p><img src="https://www.hello-algo.com/chapter_sorting/bubble_sort.assets/bubble_operation_step2.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="placeholder-3"><p><img src="https://www.hello-algo.com/chapter_sorting/bubble_sort.assets/bubble_operation_step3.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="placeholder-4"><p><img src="https://www.hello-algo.com/chapter_sorting/bubble_sort.assets/bubble_operation_step4.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="placeholder-5"><p><img src="https://www.hello-algo.com/chapter_sorting/bubble_sort.assets/bubble_operation_step5.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="placeholder-6"><p><img src="https://www.hello-algo.com/chapter_sorting/bubble_sort.assets/bubble_operation_step6.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="placeholder-7"><p><img src="https://www.hello-algo.com/chapter_sorting/bubble_sort.assets/bubble_operation_step7.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p><strong>算法流程</strong></p><p>设数组的长度为<code>n</code>，冒泡排序的步骤如下图所示。</p><ul><li>首先，对<code>n</code>个元素执行“冒泡”，将数组的最大元素交换至正确位置。</li><li>接下来，对剩余<code>n - 1</code>个元素执行“冒泡”，将第二大元素交换至正确位置。</li><li>以此类推，经过<code>n - 1</code>轮“冒泡”后，前<code>n - 1</code>大的元素都被交换至正确位置。</li><li>仅剩的一个元素必定是最小元素，无须排序，因此数组排序完成。</li></ul><p><img src="https://www.hello-algo.com/chapter_sorting/bubble_sort.assets/bubble_sort_overview.png"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 冒泡排序 */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">bubbleSort</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="comment">// 外循环：未排序区间为 [0, i]</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> nums.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="comment">// 内循环：将未排序区间 [0, i] 中的最大元素交换至该区间的最右端</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[j] &gt; nums[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="comment">// 交换 nums[j] 与 nums[j + 1]</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> nums[j];</span><br><span class="line">                nums[j] = nums[j + <span class="number">1</span>];</span><br><span class="line">                nums[j + <span class="number">1</span>] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>效率优化</strong></p><p>如果某轮“冒泡”中没有执行任何交换操作，说明数组已经完成排序，可直接返回结果。因此，可以增加一个标志位<code>flag</code>来监测这种情况，一旦出现就立即返回。</p><p>经过优化，冒泡排序的最差和平均时间复杂度仍为<code>O(n^2)</code>。但当输入数组完全有序时，可达到最佳时间复杂度<code>O(n)</code>。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 冒泡排序（标志优化） */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">bubbleSortWithFlag</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="comment">// 外循环：未排序区间为 [0, i]</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> nums.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>; <span class="comment">// 初始化标志位</span></span><br><span class="line">        <span class="comment">// 内循环：将未排序区间 [0, i] 中的最大元素交换至该区间的最右端</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[j] &gt; nums[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="comment">// 交换 nums[j] 与 nums[j + 1]</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> nums[j];</span><br><span class="line">                nums[j] = nums[j + <span class="number">1</span>];</span><br><span class="line">                nums[j + <span class="number">1</span>] = tmp;</span><br><span class="line">                flag = <span class="literal">true</span>; <span class="comment">// 记录交换元素</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!flag)</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">// 此轮冒泡未交换任何元素，直接跳出</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>算法特性</strong></p><ul><li>时间复杂度为<code>O(n^2)</code>、自适应排序：各轮“冒泡”遍历的数组长度依次为<code>n - 1</code>、<code>n - 2</code>、<code>...</code>、<code>2</code>、<code>1</code>，总和为<code>(n - 1) n / 2</code>。在引入<code>flag</code>优化后，最佳时间复杂度可达到<code>O(n)</code>。</li><li>空间复杂度为<code>O(1)</code>、原地排序：指针<code>i</code>和<code>j</code>使用常数大小的额外空间。</li><li>稳定排序：由于在“冒泡”中遇到相等元素不交换。</li></ul><hr><h3 id="11-4-插入排序"><a href="#11-4-插入排序" class="headerlink" title="11.4 插入排序"></a>11.4 插入排序</h3><p>「插入排序<code>insertion sort</code>」的工作原理与手动整理一副牌的过程非常相似。</p><p>具体来说，在未排序区间选择一个基准元素，将该元素与其左侧已排序区间的元素逐一比较大小，并将该元素插入到正确的位置。</p><p>下图展示了数组插入元素的操作流程。设基准元素为<code>base</code>，需要将从目标索引到<code>base</code>之间的所有元素向右移动一位，然后再将<code>base</code>赋值给目标索引。</p><p><img src="https://www.hello-algo.com/chapter_sorting/insertion_sort.assets/insertion_operation.png"></p><p><strong>算法流程</strong></p><p>插入排序的整体流程如下图所示。</p><ul><li>初始状态下，数组的第<code>1</code>个元素已完成排序。</li><li>选取数组的第<code>2</code>个元素作为<code>base</code>，将其插入到正确位置后，数组的前<code>2</code>个元素已排序。</li><li>选取第<code>3</code>个元素作为<code>base</code>，将其插入到正确位置后，数组的前<code>3</code>个元素已排序。</li><li>以此类推，在最后一轮中，选取最后一个元素作为<code>base</code>，将其插入到正确位置后，所有元素均已排序。</li></ul><p><img src="https://www.hello-algo.com/chapter_sorting/insertion_sort.assets/insertion_sort_overview.png"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 插入排序 */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">insertionSort</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="comment">// 外循环：已排序元素数量为 1, 2, ..., n</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">base</span> <span class="operator">=</span> nums[i], j = i - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 内循环：将 base 插入到已排序部分的正确位置</span></span><br><span class="line">        <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; nums[j] &gt; base) &#123;</span><br><span class="line">            nums[j + <span class="number">1</span>] = nums[j]; <span class="comment">// 将 nums[j] 向右移动一位</span></span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        nums[j + <span class="number">1</span>] = base;        <span class="comment">// 将 base 赋值到正确位置</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>算法特性</strong></p><ul><li>时间复杂度<code>O(n^2)</code>、自适应排序：最差情况下，每次插入操作分别需要循环<code>n - 1</code>、<code>n - 2</code>、<code>...</code>、<code>2</code>、<code>1</code>次，求和得到<code>(n - 1) n / 2</code>，因此时间复杂度为<code>O(n^2)</code>。在遇到有序数据时，插入操作会提前终止。当输入数组完全有序时，插入排序达到最佳时间复杂度<code>O(n)</code>。</li><li>空间复杂度<code>O(1)</code>、原地排序：指针<code>i</code>和<code>j</code>使用常数大小的额外空间。</li><li>稳定排序：在插入操作过程中，会将元素插入到相等元素的右侧，不会改变它们的顺序。</li></ul><p><strong>插入排序优势</strong></p><p>插入排序的时间复杂度为<code>O(n^2)</code>，快速排序的时间复杂度为<code>O(nlogn)</code>。尽管插入排序的时间复杂度相比快速排序更高，但在数据量较小的情况下，插入排序通常更快。</p><p>虽然冒泡排序、选择排序和插入排序的时间复杂度都为<code>O(n^2)</code>，但在实际情况中，插入排序的使用频率显著高于冒泡排序和选择排序，主要有以下原因。</p><ul><li>冒泡排序基于元素交换实现，需要借助一个临时变量，共涉及<code>3</code>个单元操作。插入排序基于元素赋值实现，仅需<code>1</code>个单元操作。因此，冒泡排序的计算开销通常比插入排序更高。</li><li>选择排序在任何情况下的时间复杂度都为<code>O(n^2)</code>。如果给定一组部分有序的数据，插入排序通常比选择排序效率更高。</li></ul><hr><h3 id="11-5-快速排序"><a href="#11-5-快速排序" class="headerlink" title="11.5 快速排序"></a>11.5 快速排序</h3><p>「快速排序<code>quick sort</code>」是一种基于分治策略的排序算法，运行高效，应用广泛。</p><p>快速排序的核心操作是“哨兵划分”，其目标是，选择数组中的某个元素作为“基准数”，将所有小于基准数的元素移到其左侧，而大于基准数的元素移到其右侧。具体来说，哨兵划分的流程如下图所示。</p><ul><li>选取数组最左端元素作为基准数，初始化两个指针<code>i</code>和<code>j</code>分别指向数组的两端。</li><li>循环，在每轮中使用<code>i</code>，<code>j</code>分别寻找第一个比基准数大，小的元素，然后交换这两个元素。</li><li>循环执行上一个步骤，直到<code>i</code>和<code>j</code>相遇时停止，最后将基准数交换至两个子数组的分界线。</li></ul><div class="tabs" id="placeholder"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#placeholder-1"><1></button></li><li class="tab"><button type="button" data-href="#placeholder-2"><2></button></li><li class="tab"><button type="button" data-href="#placeholder-3"><3></button></li><li class="tab"><button type="button" data-href="#placeholder-4"><4></button></li><li class="tab"><button type="button" data-href="#placeholder-5"><5></button></li><li class="tab"><button type="button" data-href="#placeholder-6"><6></button></li><li class="tab"><button type="button" data-href="#placeholder-7"><7></button></li><li class="tab"><button type="button" data-href="#placeholder-8"><8></button></li><li class="tab"><button type="button" data-href="#placeholder-9"><9></button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="placeholder-1"><p><img src="https://www.hello-algo.com/chapter_sorting/quick_sort.assets/pivot_division_step1.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="placeholder-2"><p><img src="https://www.hello-algo.com/chapter_sorting/quick_sort.assets/pivot_division_step2.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="placeholder-3"><p><img src="https://www.hello-algo.com/chapter_sorting/quick_sort.assets/pivot_division_step3.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="placeholder-4"><p><img src="https://www.hello-algo.com/chapter_sorting/quick_sort.assets/pivot_division_step4.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="placeholder-5"><p><img src="https://www.hello-algo.com/chapter_sorting/quick_sort.assets/pivot_division_step5.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="placeholder-6"><p><img src="https://www.hello-algo.com/chapter_sorting/quick_sort.assets/pivot_division_step6.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="placeholder-7"><p><img src="https://www.hello-algo.com/chapter_sorting/quick_sort.assets/pivot_division_step7.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="placeholder-8"><p><img src="https://www.hello-algo.com/chapter_sorting/quick_sort.assets/pivot_division_step8.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="placeholder-9"><p><img src="https://www.hello-algo.com/chapter_sorting/quick_sort.assets/pivot_division_step9.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>哨兵划分完成后，原数组被划分成三部分，左子数组、基准数、右子数组，且满足“左子数组任意元素<code>&lt;=</code>基准数<code>&lt;=</code>右子数组任意元素”。因此，接下来只需对这两个子数组进行排序。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 元素交换 */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> nums[i];</span><br><span class="line">    nums[i] = nums[j];</span><br><span class="line">    nums[j] = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 哨兵划分 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">    <span class="comment">// 以 nums[left] 作为基准数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left, j = right;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; nums[j] &gt;= nums[left])</span><br><span class="line">            j--;          <span class="comment">// 从右向左找首个小于基准数的元素</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; nums[i] &lt;= nums[left])</span><br><span class="line">            i++;          <span class="comment">// 从左向右找首个大于基准数的元素</span></span><br><span class="line">        swap(nums, i, j); <span class="comment">// 交换这两个元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    swap(nums, i, left);  <span class="comment">// 将基准数交换至两子数组的分界线</span></span><br><span class="line">    <span class="keyword">return</span> i;             <span class="comment">// 返回基准数的索引</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>算法流程</strong></p><p>快速排序的整体流程如下图所示。</p><ul><li>首先，对原数组执行一次“哨兵划分”，得到未排序的左子数组和右子数组。</li><li>然后，对左子数组和右子数组分别递归执行“哨兵划分”。</li><li>持续递归，直至子数组长度为<code>1</code>时终止，从而完成整个数组的排序。</li></ul><p><img src="https://www.hello-algo.com/chapter_sorting/quick_sort.assets/quick_sort_overview.png"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 快速排序 */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">    <span class="comment">// 子数组长度为 1 时终止递归</span></span><br><span class="line">    <span class="keyword">if</span> (left &gt;= right)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 哨兵划分</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> partition(nums, left, right);</span><br><span class="line">    <span class="comment">// 递归左子数组、右子数组</span></span><br><span class="line">    quickSort(nums, left, pivot - <span class="number">1</span>);</span><br><span class="line">    quickSort(nums, pivot + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>算法特性</strong></p><ul><li>时间复杂度<code>O(nlogn)</code>、自适应排序：在平均情况下，哨兵划分的递归层数为<code>logn</code>，每层中的总循环数为 <code>n</code>，总体使用<code>O(nlogn)</code>时间。在最差情况下，每轮哨兵划分操作都将长度为<code>n</code>的数组划分为长度为<code>0</code>和<code>n - 1</code>的两个子数组，此时递归层数达到<code>n</code>层，每层中的循环数为<code>n</code>，总体使用<code>O(n^2)</code>时间。</li><li>空间复杂度<code>O(n)</code>、原地排序：在输入数组完全倒序的情况下，达到最差递归深度<code>n</code>，使用<code>O(n)</code>栈帧空间。排序操作是在原数组上进行的，未借助额外数组。</li><li>非稳定排序：在哨兵划分的最后一步，基准数可能会被交换至相等元素的右侧。</li></ul><hr><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><blockquote><p>文件还未上传 Github</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法 Algorithm • 中</title>
      <link href="/posts/e90cdaa3.html"/>
      <url>/posts/e90cdaa3.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>本读书笔记节选自<code>krahets</code>大佬编写的<a href="https://www.hello-algo.com/">《Hello 算法》</a>。勉励自己开始系统的算法学习。</p></blockquote><hr><h2 id="7-树"><a href="#7-树" class="headerlink" title="7. 树"></a>7. 树</h2><h3 id="7-1-二叉树"><a href="#7-1-二叉树" class="headerlink" title="7.1 二叉树"></a>7.1 二叉树</h3><p>「二叉树 <code>binary tree</code>」是一种非线性数据结构，代表着祖先与后代之间的派生关系，体现着“一分为二”的分治逻辑。二叉树的基本单元是节点，每个节点包含值、左子节点引用、右子节点引用。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 二叉树节点类 */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;         <span class="comment">// 节点值</span></span><br><span class="line">    TreeNode left;   <span class="comment">// 左子节点引用</span></span><br><span class="line">    TreeNode right;  <span class="comment">// 右子节点引用</span></span><br><span class="line">    TreeNode(<span class="type">int</span> x) &#123; val = x; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个节点都有两个引用。当给定一个二叉树的节点时，该节点的左子节点及其以下节点形成的树称为该节点的「左子树 <code>left subtree</code>」，同理可得「右子树 <code>right subtree</code>」。</p><p>在二叉树中，<ins>除叶节点外，其他所有节点都包含子节点和非空子树</ins>。</p><p><img src="https://www.hello-algo.com/chapter_tree/binary_tree.assets/binary_tree_definition.png"></p><h4 id="二叉树常见术语"><a href="#二叉树常见术语" class="headerlink" title="二叉树常见术语"></a>二叉树常见术语</h4><p>二叉树的常用术语如下面所示。</p><ul><li>根节点 <code>root node</code>：位于二叉树顶层的节点，没有父节点。</li><li>叶节点 <code>leaf node</code>：没有子节点的节点，其两个指针均指向<code>None</code>。</li><li>边 <code>edge</code>：连接两个节点的线段，即节点引用（<code>left</code>，<code>right</code>）。</li><li>节点所在的层 <code>level</code>：从顶至底递增，根节点所在层为<code>1</code>。</li><li>节点的度 <code>degree</code>：节点的子节点的数量。在二叉树中，度的取值范围是<code>0</code>、<code>1</code>、<code>2</code>。</li><li>二叉树的高度 <code>height</code>：从根节点到最远叶节点所经过的边的数量。</li><li>节点的深度 <code>depth</code>：从根节点到该节点所经过的边的数量。</li><li>节点的高度 <code>height</code>：从最远叶节点到该节点所经过的边的数量。</li></ul><p><img src="https://www.hello-algo.com/chapter_tree/binary_tree.assets/binary_tree_terminology.png"></p><blockquote><p>注意，我们通常将“高度”和“深度”定义为“走过边的数量”，但有些题目或教材可能会将其定义为“走过节点的数量”。在这种情况下，高度和深度都需要加<code>1</code>。</p></blockquote><h4 id="二叉树常见问题"><a href="#二叉树常见问题" class="headerlink" title="二叉树常见问题"></a>二叉树常见问题</h4><p>（1）二叉树某节点所在的深度（层数）</p><p>在递归方案中，从根节点开始，如果当前节点是目标节点，返回当前的深度。否则，递归地搜索该节点的左右子节点，同时深度加一。如果在左或右子树中找到了目标节点，返回找到的深度。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">findLevel</span><span class="params">(TreeNode root, <span class="type">int</span> targetVal, <span class="type">int</span> level)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(root.val == targetVal) &#123;</span><br><span class="line">        <span class="keyword">return</span> level;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">leftLevel</span> <span class="operator">=</span> findLevel(root.left, targetVal, level + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(leftLevel != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> leftLevel;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> findLevel(root.right, targetVal, level + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">level</span> <span class="operator">=</span> findLevel(root, targetVal, <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>除了递归遍历法，还可以通过迭代的方式进行层次遍历（广度优先搜索，<code>BFS</code>）来找到节点的深度。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">findLevelBFS</span><span class="params">(TreeNode root, <span class="type">int</span> targetVal)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    Queue&lt;Integer&gt; levels = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    queue.add(root);</span><br><span class="line">    levels.add(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">currentNode</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">        <span class="type">int</span> <span class="variable">currentLevel</span> <span class="operator">=</span> levels.poll();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(currentNode.val == targetVal) &#123;</span><br><span class="line">            <span class="keyword">return</span> currentLevel;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(currentNode.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            queue.add(currentNode.left);</span><br><span class="line">            levels.add(currentLevel + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(currentNode.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            queue.add(currentNode.right);</span><br><span class="line">            levels.add(currentLevel + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）二叉树的节点总数 | 边总数</p><p>二叉树的节点总数等于根节点加上左子树的节点总数和右子树的节点总数。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">countNodes</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + countNodes(root.left) + countNodes(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了递归，还可以通过迭代的方式来计算节点总数，通常使用层次遍历。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">countNodesIterative</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    queue.add(root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">currentNode</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">        count++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (currentNode.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            queue.add(currentNode.left);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (currentNode.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            queue.add(currentNode.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于边总数，<ins>一个包含<code>N</code>个节点的非空二叉树，其边数<code>E</code>为<code>E = N − 1</code></ins>。</p><p>（3）二叉树的高度 | 某节点高度</p><p>二叉树的高度是从根节点到最远叶子节点的最长路径上的节点数。可以使用递归方法从根节点开始，递归地计算左子树和右子树的高度，然后取两者中的较大值，并加上<code>1</code>（根节点自身）。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">getHeight</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">leftHeight</span> <span class="operator">=</span> getHeight(root.left);</span><br><span class="line">    <span class="type">int</span> <span class="variable">rightHeight</span> <span class="operator">=</span> getHeight(root.right);</span><br><span class="line">    <span class="keyword">return</span> Math.max(leftHeight, rightHeight) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用迭代的方法来计算二叉树的高度通常涉及层次遍历，下面是实现方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">getHeightIterative</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    queue.offer(root);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">height</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">levelSize</span> <span class="operator">=</span> queue.size(); <span class="comment">// 当前层的节点数量</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历当前层的所有节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; levelSize; i++) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">current</span> <span class="operator">=</span> queue.poll(); <span class="comment">// 从队列中移除节点</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将子节点加入队列</span></span><br><span class="line">            <span class="keyword">if</span> (current.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                queue.offer(current.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (current.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                queue.offer(current.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 完成一层的遍历，高度加 1</span></span><br><span class="line">        height++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> height;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（4）二叉树的子叶总数</p><p>在递归方法中，从根节点开始遍历。如果遇到一个<code>null</code>节点，返回<code>0</code>。如果遇到一个叶子节点，返回<code>1</code>。然后，递归地计算左子树和右子树的叶子节点数，并将它们相加以得到总数。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">countLeaves</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// 是一个叶子节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> countLeaves(root.left) + countLeaves(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用迭代的方法来计算二叉树的子叶总数涉及层次遍历，下面是实现方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">countLeavesIterative</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    queue.offer(root);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">leafCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">current</span> <span class="operator">=</span> queue.poll();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (current.left == <span class="literal">null</span> &amp;&amp; current.right == <span class="literal">null</span>) &#123;</span><br><span class="line">            leafCount++; <span class="comment">// 是一个叶子节点</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (current.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            queue.offer(current.left);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (current.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            queue.offer(current.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> leafCount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="多叉树（扩展）"><a href="#多叉树（扩展）" class="headerlink" title="多叉树（扩展）"></a>多叉树（扩展）</h4><p>多叉树（也称为多路树或<code>K</code>叉树）是一种树形数据结构，其中每个节点可以有多于两个子节点。这与二叉树形成对比，在二叉树中，每个节点最多只能有两个子节点。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    List&lt;TreeNode&gt; children;</span><br><span class="line">    TreeNode(<span class="type">int</span> x) &#123;</span><br><span class="line">        val = x;</span><br><span class="line">        children = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（1）多叉树某节点所在的深度（层数）</p><p>在多叉树中，一个节点的深度是从根节点到该节点的唯一路径上的边的数量。根节点的深度为<code>0</code>，其直接子节点的深度为<code>1</code>，依此类推。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 递归写法</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">findDepth</span><span class="params">(TreeNode root, <span class="type">int</span> target, <span class="type">int</span> depth)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>; <span class="comment">// 节点未找到</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (root.val == target) &#123;</span><br><span class="line">        <span class="keyword">return</span> depth; <span class="comment">// 节点找到，返回深度</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (TreeNode child : root.children) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> findDepth(child, target, depth + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (result != -<span class="number">1</span>) &#123; <span class="comment">// 如果在子树中找到节点，返回结果</span></span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>; <span class="comment">// 在这个子树中没有找到节点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 迭代写法</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">findNodeDepthIterative</span><span class="params">(TreeNode root, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Queue&lt;TreeNode&gt; nodeQueue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    Queue&lt;Integer&gt; depthQueue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    nodeQueue.offer(root);</span><br><span class="line">    depthQueue.offer(<span class="number">0</span>);  <span class="comment">// 根节点的深度是0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!nodeQueue.isEmpty()) &#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">currentNode</span> <span class="operator">=</span> nodeQueue.poll();</span><br><span class="line">        <span class="type">int</span> <span class="variable">currentDepth</span> <span class="operator">=</span> depthQueue.poll();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果找到了目标节点</span></span><br><span class="line">        <span class="keyword">if</span> (currentNode.val == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> currentDepth;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将子节点加入队列</span></span><br><span class="line">        <span class="keyword">for</span> (TreeNode child : currentNode.children) &#123;</span><br><span class="line">            nodeQueue.offer(child);</span><br><span class="line">            depthQueue.offer(currentDepth + <span class="number">1</span>);  <span class="comment">// 子节点的深度是当前节点深度+1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;  <span class="comment">// 如果未找到目标节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）多叉树的节点总数</p><p>多叉树的节点总数等于根节点自身（<code>1</code>个节点）加上所有子树的节点总数。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 递归写法</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">countNodes</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>; <span class="comment">// 计算根节点</span></span><br><span class="line">    <span class="keyword">for</span> (TreeNode child : root.children) &#123;</span><br><span class="line">        count += countNodes(child); <span class="comment">// 递归计算每个子树的节点数，并累加</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 迭代写法</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">countNodesIterative</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    queue.offer(root);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">current</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">        count++; <span class="comment">// 计算当前节点</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (TreeNode child : current.children) &#123;</span><br><span class="line">            queue.offer(child); <span class="comment">// 将子节点加入队列，以便后续遍历</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（3）多叉树的高度 | 某节点高度</p><p>在递归方案中，从根节点开始，递归地计算所有子树的高度，取其中的最大值，并加<code>1</code>（包括当前节点自己）。若遇到空节点，返回<code>0</code>。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 递归写法</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">height</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">maxHeight</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (TreeNode child : root.children) &#123;</span><br><span class="line">        maxHeight = Math.max(maxHeight, height(child));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + maxHeight;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 迭代写法</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">findHeightIterative</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    queue.offer(root);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">height</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">levelSize</span> <span class="operator">=</span> queue.size(); <span class="comment">// 当前层的节点数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; levelSize; i++) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">current</span> <span class="operator">=</span> queue.poll();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (TreeNode child : current.children) &#123;</span><br><span class="line">                queue.offer(child);  <span class="comment">// 将子节点加入队列，以便后续遍历</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        height++;  <span class="comment">// 完成一层的遍历后，高度加1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> height;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（4）多叉树的子叶总数</p><p>在递归方案中，从根节点开始，递归地遍历每个子树。如果一个节点没有子节点，则它是一个叶子节点，计数器加一。递归结束后，计数器的值即为叶子节点的总数。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 递归写法</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">countLeaves</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root.children.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// 是一个叶子节点</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (TreeNode child : root.children) &#123;</span><br><span class="line">        count += countLeaves(child);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 迭代写法</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">countLeafNodesIterative</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    queue.offer(root);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">leafCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">current</span> <span class="operator">=</span> queue.poll();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果是叶子节点</span></span><br><span class="line">        <span class="keyword">if</span> (current.children.isEmpty()) &#123;</span><br><span class="line">            leafCount++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将子节点加入队列</span></span><br><span class="line">        <span class="keyword">for</span> (TreeNode child : current.children) &#123;</span><br><span class="line">            queue.offer(child);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> leafCount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二叉树基本操作"><a href="#二叉树基本操作" class="headerlink" title="二叉树基本操作"></a>二叉树基本操作</h4><p>（1）初始化二叉树</p><p>与链表类似，首先初始化节点，然后构建引用（指针）。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化节点</span></span><br><span class="line"><span class="type">TreeNode</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(<span class="number">1</span>);</span><br><span class="line"><span class="type">TreeNode</span> <span class="variable">n2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(<span class="number">2</span>);</span><br><span class="line"><span class="type">TreeNode</span> <span class="variable">n3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(<span class="number">3</span>);</span><br><span class="line"><span class="type">TreeNode</span> <span class="variable">n4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(<span class="number">4</span>);</span><br><span class="line"><span class="type">TreeNode</span> <span class="variable">n5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(<span class="number">5</span>);</span><br><span class="line"><span class="comment">// 构建引用指向（即指针）</span></span><br><span class="line">n1.left = n2;</span><br><span class="line">n1.right = n3;</span><br><span class="line">n2.left = n4;</span><br><span class="line">n2.right = n5;</span><br></pre></td></tr></table></figure><p>（2）插入与删除节点</p><p>与链表类似，在二叉树中插入与删除节点可以通过修改指针来实现。下图给出了一个示例。</p><p><img src="https://www.hello-algo.com/chapter_tree/binary_tree.assets/binary_tree_add_remove.png"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">TreeNode</span> <span class="variable">P</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(<span class="number">0</span>);</span><br><span class="line"><span class="comment">// 在 n1 -&gt; n2 中间插入节点 P</span></span><br><span class="line">n1.left = P;</span><br><span class="line">P.left = n2;</span><br><span class="line"><span class="comment">// 删除节点 P</span></span><br><span class="line">n1.left = n2;</span><br></pre></td></tr></table></figure><blockquote><p>需要注意的是，插入节点可能会改变二叉树的原有逻辑结构，而删除节点通常意味着删除该节点及其所有子树。因此，在二叉树中，插入与删除操作通常是由一套操作配合完成的，以实现有实际意义的操作。</p></blockquote><h4 id="常见二叉树类型"><a href="#常见二叉树类型" class="headerlink" title="常见二叉树类型"></a>常见二叉树类型</h4><p><strong>完美二叉树</strong></p><p>「完美二叉树 <code>perfect binary tree</code>」<ins>除了最底层外，其余所有层的节点都被完全填满</ins>。在完美二叉树中，叶节点的度为<code>0</code>，其余所有节点的度都为<code>2</code>。若树高度为<code>h</code>，则节点总数为<code>2^(h + 1) - 1</code>，呈现标准的指数级关系，反映了自然界中常见的细胞分裂现象。</p><p><img src="https://www.hello-algo.com/chapter_tree/binary_tree.assets/perfect_binary_tree.png"></p><p><strong>完全二叉树</strong></p><p>「完全二叉树 <code>complete binary tree</code>」<ins>只有最底层的节点未被填满，且最底层节点尽量靠左填充</ins>。</p><p><img src="https://www.hello-algo.com/chapter_tree/binary_tree.assets/complete_binary_tree.png"></p><p><strong>完满二叉树</strong></p><p>「完满二叉树 <code>full binary tree</code>」<ins>除了叶节点之外，其余所有节点都有两个子节点</ins>。</p><p><img src="https://www.hello-algo.com/chapter_tree/binary_tree.assets/full_binary_tree.png"></p><p><strong>平衡二叉树</strong></p><p>「平衡二叉树 <code>balanced binary tree</code>」中<ins>任意节点的左子树和右子树高度之差的绝对值不超过<code>1</code></ins>。</p><p><img src="https://www.hello-algo.com/chapter_tree/binary_tree.assets/balanced_binary_tree.png"></p><h4 id="二叉树的退化"><a href="#二叉树的退化" class="headerlink" title="二叉树的退化"></a>二叉树的退化</h4><p>当二叉树的每层节点都被填满时，达到“完美二叉树”。完美二叉树是理想情况，可以充分发挥二叉树“分治”的优势。而当所有节点都偏向一侧时，二叉树就会退化为“链表”，各项操作都变为线性操作，时间复杂度退化至<code>O(n)</code>。</p><p><img src="https://www.hello-algo.com/chapter_tree/binary_tree.assets/binary_tree_best_worst_cases.png"></p><p>如下表所示，在最佳和最差结构下，二叉树的叶节点数量、节点总数、高度等达到极大或极小值。</p><table><thead><tr><th align="left"></th><th align="left">完美二叉树</th><th align="left">链表</th></tr></thead><tbody><tr><td align="left">第<code>i</code>层的节点数量</td><td align="left"><code>2^(i - 1)</code></td><td align="left"><code>1</code></td></tr><tr><td align="left">高度<code>h</code>树的叶节点数量</td><td align="left"><code>2^h</code></td><td align="left"><code>1</code></td></tr><tr><td align="left">高度<code>h</code>树的节点总数</td><td align="left"><code>2^(h + 1) - 1</code></td><td align="left"><code>h + 1</code></td></tr><tr><td align="left">节点总数<code>n</code>树的高度</td><td align="left"><code>log2(n + 1) - 1</code></td><td align="left"><code>n + 1</code></td></tr></tbody></table><hr><h3 id="7-2-二叉树遍历"><a href="#7-2-二叉树遍历" class="headerlink" title="7.2 二叉树遍历"></a>7.2 二叉树遍历</h3><p>二叉树常见的遍历方式包括层序遍历、前序遍历、中序遍历和后序遍历等。</p><h4 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h4><p>如下图所示，「层序遍历 <code>level-order traversal</code>」从顶部到底部逐层遍历二叉树，并在每一层按照从左到右的顺序访问节点。</p><p>层序遍历本质上属于「广度优先遍历 <code>breadth-first traversal</code>」，它体现了一种“一圈一圈向外扩展”的逐层遍历方式。</p><p><img src="https://www.hello-algo.com/chapter_tree/binary_tree_traversal.assets/binary_tree_bfs.png"></p><p><ins>广度优先遍历通常借助“队列”来实现</ins>。队列遵循“先进先出”的规则，而广度优先遍历则遵循“逐层推进”的规则，两者背后的思想是一致的。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 层序遍历 */</span></span><br><span class="line">List&lt;Integer&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="comment">// 初始化队列，加入根节点</span></span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    queue.add(root);</span><br><span class="line">    <span class="comment">// 初始化一个列表，用于保存遍历序列</span></span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll(); <span class="comment">// 队列出队</span></span><br><span class="line">        list.add(node.val);           <span class="comment">// 保存节点值</span></span><br><span class="line">        <span class="keyword">if</span> (node.left != <span class="literal">null</span>)</span><br><span class="line">            queue.offer(node.left);   <span class="comment">// 左子节点入队</span></span><br><span class="line">        <span class="keyword">if</span> (node.right != <span class="literal">null</span>)</span><br><span class="line">            queue.offer(node.right);  <span class="comment">// 右子节点入队</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：所有节点被访问一次，使用<code>O(n)</code>时间，其中<code>n</code>为节点数量。</li><li>空间复杂度：在最差情况下，即满二叉树时，遍历到最底层之前，队列中最多同时存在<code>(n + 1) / 2</code>个节点，占用<code>O(n)</code>空间。</li></ul><h4 id="前序、中序、后序遍历"><a href="#前序、中序、后序遍历" class="headerlink" title="前序、中序、后序遍历"></a>前序、中序、后序遍历</h4><p>相应地，前序、中序和后序遍历都属于「深度优先遍历 <code>depth-first traversal</code>」，它体现了一种“先走到尽头，再回溯继续”的遍历方式。</p><p>下图展示了对二叉树进行深度优先遍历的工作原理。深度优先遍历就像是绕着整个二叉树的外围“走”一圈，在每个节点都会遇到三个位置，分别对应前序遍历、中序遍历和后序遍历。</p><p><img src="https://www.hello-algo.com/chapter_tree/binary_tree_traversal.assets/binary_tree_dfs.png"></p><p><ins>深度优先搜索通常基于递归实现</ins>。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 前序遍历 */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">preOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 访问优先级：根节点 -&gt; 左子树 -&gt; 右子树</span></span><br><span class="line">    list.add(root.val);</span><br><span class="line">    preOrder(root.left);</span><br><span class="line">    preOrder(root.right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 中序遍历 */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">inOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 访问优先级：左子树 -&gt; 根节点 -&gt; 右子树</span></span><br><span class="line">    inOrder(root.left);</span><br><span class="line">    list.add(root.val);</span><br><span class="line">    inOrder(root.right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 后序遍历 */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">postOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 访问优先级：左子树 -&gt; 右子树 -&gt; 根节点</span></span><br><span class="line">    postOrder(root.left);</span><br><span class="line">    postOrder(root.right);</span><br><span class="line">    list.add(root.val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下图展示了前序遍历二叉树的递归过程，其可分为“递”和“归”两个逆向的部分。</p><ul><li>“递”表示开启新方法，程序在此过程中访问下一个节点。</li><li>“归”表示函数返回，代表当前节点已经访问完毕。</li></ul><div class="tabs" id="placeholder"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#placeholder-1">1</button></li><li class="tab"><button type="button" data-href="#placeholder-2">2</button></li><li class="tab"><button type="button" data-href="#placeholder-3">3</button></li><li class="tab"><button type="button" data-href="#placeholder-4">4</button></li><li class="tab"><button type="button" data-href="#placeholder-5">5</button></li><li class="tab"><button type="button" data-href="#placeholder-6">6</button></li><li class="tab"><button type="button" data-href="#placeholder-7">7</button></li><li class="tab"><button type="button" data-href="#placeholder-8">8</button></li><li class="tab"><button type="button" data-href="#placeholder-9">9</button></li><li class="tab"><button type="button" data-href="#placeholder-10">10</button></li><li class="tab"><button type="button" data-href="#placeholder-11">11</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="placeholder-1"><p><img src="https://www.hello-algo.com/chapter_tree/binary_tree_traversal.assets/preorder_step1.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="placeholder-2"><p><img src="https://www.hello-algo.com/chapter_tree/binary_tree_traversal.assets/preorder_step2.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="placeholder-3"><p><img src="https://www.hello-algo.com/chapter_tree/binary_tree_traversal.assets/preorder_step3.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="placeholder-4"><p><img src="https://www.hello-algo.com/chapter_tree/binary_tree_traversal.assets/preorder_step4.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="placeholder-5"><p><img src="https://www.hello-algo.com/chapter_tree/binary_tree_traversal.assets/preorder_step5.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="placeholder-6"><p><img src="https://www.hello-algo.com/chapter_tree/binary_tree_traversal.assets/preorder_step6.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="placeholder-7"><p><img src="https://www.hello-algo.com/chapter_tree/binary_tree_traversal.assets/preorder_step7.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="placeholder-8"><p><img src="https://www.hello-algo.com/chapter_tree/binary_tree_traversal.assets/preorder_step8.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="placeholder-9"><p><img src="https://www.hello-algo.com/chapter_tree/binary_tree_traversal.assets/preorder_step9.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="placeholder-10"><p><img src="https://www.hello-algo.com/chapter_tree/binary_tree_traversal.assets/preorder_step10.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="placeholder-11"><p><img src="https://www.hello-algo.com/chapter_tree/binary_tree_traversal.assets/preorder_step11.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><ul><li>时间复杂度：所有节点被访问一次，使用<code>O(n)</code>时间，其中<code>n</code>为节点数量。</li><li>空间复杂度：在最差情况下，即树退化为链表时，递归深度达到<code>n</code>，系统占用<code>O(n)</code>栈帧空间。</li></ul><hr><h3 id="7-3-二叉树数组表示"><a href="#7-3-二叉树数组表示" class="headerlink" title="7.3 二叉树数组表示"></a>7.3 二叉树数组表示</h3><p>在链表表示下，二叉树的存储单元为节点<code>TreeNode</code>，节点之间通过指针相连接。那么，能否用数组来表示二叉树呢？答案是肯定的。</p><h4 id="表示完美二叉树"><a href="#表示完美二叉树" class="headerlink" title="表示完美二叉树"></a>表示完美二叉树</h4><p>给定一个完美二叉树，将所有节点按照层序遍历的顺序存储在一个数组中，则每个节点都对应唯一的数组索引。</p><p>根据层序遍历的特性，可以推导出父节点索引与子节点索引之间的“映射公式”。<ins>若节点的索引为<code>i</code>，则该节点的左子节点索引为<code>2i + 1</code>，右子节点索引为<code>2i + 2</code></ins>。</p><p><img src="https://www.hello-algo.com/chapter_tree/array_representation_of_tree.assets/array_representation_binary_tree.png"></p><h4 id="表示任意二叉树"><a href="#表示任意二叉树" class="headerlink" title="表示任意二叉树"></a>表示任意二叉树</h4><p>完美二叉树是一个特例，在二叉树的中间层通常存在许多<code>None</code>。由于层序遍历序列并不包含这些<code>None</code>，因此无法仅凭该序列来推测<code>None</code>的数量和分布位置。这意味着存在多种二叉树结构都符合该层序遍历序列。</p><p><img src="https://www.hello-algo.com/chapter_tree/array_representation_of_tree.assets/array_representation_without_empty.png"></p><p>为了解决此问题，<ins>可以考虑在层序遍历序列中显式地写出所有<code>None</code></ins>。如下图所示，这样处理后，层序遍历序列就可以唯一表示二叉树了。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 二叉树的数组表示 */</span></span><br><span class="line"><span class="comment">// 使用 int 的包装类 Integer ，就可以使用 null 来标记空位</span></span><br><span class="line">Integer[] tree = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="literal">null</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="number">12</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="number">15</span> &#125;;</span><br></pre></td></tr></table></figure><p><img src="https://www.hello-algo.com/chapter_tree/array_representation_of_tree.assets/array_representation_with_empty.png"></p><h4 id="表示完全二叉树"><a href="#表示完全二叉树" class="headerlink" title="表示完全二叉树"></a>表示完全二叉树</h4><p>完全二叉树非常适合使用数组来表示。根据完全二叉树的定义，<code>None</code>只出现在最底层且靠右的位置，因此所有<code>None</code>一定出现在层序遍历序列的末尾。这意味着<ins>使用数组表示完全二叉树时，可以省略存储所有<code>None</code></ins>，非常方便。</p><p><img src="https://www.hello-algo.com/chapter_tree/array_representation_of_tree.assets/array_representation_complete_binary_tree.png"></p><p>以下代码实现了一个基于数组表示的二叉树，包括以下几种操作。</p><ul><li>给定某节点，获取它的值、左（右）子节点、父节点。</li><li>获取前序遍历、中序遍历、后序遍历、层序遍历序列。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 数组表示下的二叉树类 */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ArrayBinaryTree</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; tree;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 构造方法 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArrayBinaryTree</span><span class="params">(List&lt;Integer&gt; arr)</span> &#123;</span><br><span class="line">        tree = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(arr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 节点数量 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> tree.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取索引为 i 节点的值 */</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">val</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="comment">// 若索引越界，则返回 null ，代表空位</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= size())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">return</span> tree.get(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取索引为 i 节点的左子节点的索引 */</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">left</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取索引为 i 节点的右子节点的索引 */</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">right</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> * i + <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取索引为 i 节点的父节点的索引 */</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">parent</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (i - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 层序遍历 */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">levelOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 直接遍历数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (val(i) != <span class="literal">null</span>)</span><br><span class="line">                res.add(val(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 深度优先遍历 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(Integer i, String order, List&lt;Integer&gt; res)</span> &#123;</span><br><span class="line">        <span class="comment">// 若为空位，则返回</span></span><br><span class="line">        <span class="keyword">if</span> (val(i) == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 前序遍历</span></span><br><span class="line">        <span class="keyword">if</span> (order == <span class="string">&quot;pre&quot;</span>)</span><br><span class="line">            res.add(val(i));</span><br><span class="line">        dfs(left(i), order, res);</span><br><span class="line">        <span class="comment">// 中序遍历</span></span><br><span class="line">        <span class="keyword">if</span> (order == <span class="string">&quot;in&quot;</span>)</span><br><span class="line">            res.add(val(i));</span><br><span class="line">        dfs(right(i), order, res);</span><br><span class="line">        <span class="comment">// 后序遍历</span></span><br><span class="line">        <span class="keyword">if</span> (order == <span class="string">&quot;post&quot;</span>)</span><br><span class="line">            res.add(val(i));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 前序遍历 */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">preOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        dfs(<span class="number">0</span>, <span class="string">&quot;pre&quot;</span>, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 中序遍历 */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">inOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        dfs(<span class="number">0</span>, <span class="string">&quot;in&quot;</span>, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 后序遍历 */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">postOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        dfs(<span class="number">0</span>, <span class="string">&quot;post&quot;</span>, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="7-4-二叉搜索树"><a href="#7-4-二叉搜索树" class="headerlink" title="7.4 二叉搜索树"></a>7.4 二叉搜索树</h3><p>「二叉搜索树 <code>binary search tree</code>」满足以下条件。</p><ul><li>对于根节点，左子树中所有节点的值 <code>&lt;</code> 根节点的值 <code>&lt;</code> 右子树中所有节点的值。</li><li>任意节点的左、右子树也是二叉搜索树，即同样满足上面条件。</li></ul><p><img src="https://www.hello-algo.com/chapter_tree/binary_search_tree.assets/binary_search_tree.png"></p><h4 id="二叉搜索树的操作"><a href="#二叉搜索树的操作" class="headerlink" title="二叉搜索树的操作"></a>二叉搜索树的操作</h4><p>将二叉搜索树封装为一个类<code>ArrayBinaryTree</code>，并声明一个成员变量<code>root</code>，指向树的根节点。</p><p>（1）查找节点</p><p>给定目标节点值<code>num</code>，可以根据二叉搜索树的性质来查找。如下图所示，声明一个节点<code>cur</code>，从二叉树的根节点<code>root</code>出发，循环比较节点值<code>cur.val</code>和<code>num</code>之间的大小关系。</p><ul><li>若<code>cur.val &lt; num</code>，说明目标节点在<code>cur</code>的右子树中，因此执行<code>cur = cur.right</code>。</li><li>若<code>cur.val &gt; num</code>，说明目标节点在<code>cur</code>的左子树中，因此执行<code>cur = cur.left</code>。</li><li>若<code>cur.val = num</code>，说明找到目标节点，跳出循环并返回该节点。</li></ul><div class="tabs" id="placeholder"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#placeholder-1"><1></button></li><li class="tab"><button type="button" data-href="#placeholder-2"><2></button></li><li class="tab"><button type="button" data-href="#placeholder-3"><3></button></li><li class="tab"><button type="button" data-href="#placeholder-4"><4></button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="placeholder-1"><p><img src="https://www.hello-algo.com/chapter_tree/binary_search_tree.assets/bst_search_step1.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="placeholder-2"><p><img src="https://www.hello-algo.com/chapter_tree/binary_search_tree.assets/bst_search_step2.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="placeholder-3"><p><img src="https://www.hello-algo.com/chapter_tree/binary_search_tree.assets/bst_search_step3.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="placeholder-4"><p><img src="https://www.hello-algo.com/chapter_tree/binary_search_tree.assets/bst_search_step4.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>二叉搜索树的查找操作与二分查找算法的工作原理一致，都是每轮排除一半情况。循环次数最多为二叉树的高度，当二叉树平衡时，使用<code>O(logn)</code>时间。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 查找节点 */</span></span><br><span class="line">TreeNode <span class="title function_">search</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> root;</span><br><span class="line">    <span class="comment">// 循环查找，越过叶节点后跳出</span></span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 目标节点在 cur 的右子树中</span></span><br><span class="line">        <span class="keyword">if</span> (cur.val &lt; num)</span><br><span class="line">            cur = cur.right;</span><br><span class="line">        <span class="comment">// 目标节点在 cur 的左子树中</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cur.val &gt; num)</span><br><span class="line">            cur = cur.left;</span><br><span class="line">        <span class="comment">// 找到目标节点，跳出循环</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回目标节点</span></span><br><span class="line">    <span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）插入节点</p><p>给定一个待插入元素<code>num</code>，根据二叉搜索树“左子树 <code>&lt;</code> 根节点 <code>&lt;</code> 右子树”的性质，插入流程如下。</p><ul><li>查找插入位置：与查找操作相似，从根节点出发，根据当前节点值和<code>num</code>的大小关系循环向下搜索，直到越过叶节点（遍历至<code>None</code>）时跳出循环。</li><li>在该位置插入节点：初始化节点<code>num</code>，将该节点置于<code>None</code>的位置。</li></ul><p><img src="https://www.hello-algo.com/chapter_tree/binary_search_tree.assets/bst_insert.png"></p><p>在代码实现中，需要注意以下两点。</p><ul><li>二叉搜索树不允许存在重复节点，否则将违反其定义。因此，若待插入节点在树中已存在，则不执行插入，直接返回。</li><li><ins>为了实现插入节点，需要借助节点<code>pre</code>保存上一轮循环的节点</ins>。这样在遍历至<code>None</code>时，可以获取到其父节点，从而完成节点插入操作。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 插入节点 */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">    <span class="comment">// 若树为空，则初始化根节点</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        root = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(num);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> root, pre = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 循环查找，越过叶节点后跳出</span></span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 找到重复节点，直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (cur.val == num)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        pre = cur;</span><br><span class="line">        <span class="comment">// 插入位置在 cur 的右子树中</span></span><br><span class="line">        <span class="keyword">if</span> (cur.val &lt; num)</span><br><span class="line">            cur = cur.right;</span><br><span class="line">        <span class="comment">// 插入位置在 cur 的左子树中</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cur = cur.left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 插入节点</span></span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(num);</span><br><span class="line">    <span class="keyword">if</span> (pre.val &lt; num)</span><br><span class="line">        pre.right = node;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        pre.left = node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与查找节点相同，插入节点使用<code>O(logn)</code>时间。</p><p>（3）删除节点</p><p>先在二叉树中查找到目标节点，再将其从二叉树中删除。与插入节点类似，需要保证在删除操作完成后，二叉搜索树的“左子树 <code>&lt;</code> 根节点 <code>&lt;</code> 右子树”的性质仍然满足。</p><p>因此，<ins>需要根据目标节点的子节点数量，共分为<code>0</code>、<code>1</code>和<code>2</code>这三种情况</ins>，执行对应的删除节点操作。</p><blockquote><p><ins>当待删除节点的度为<code>0</code>时，表示该节点是叶节点，可以直接删除</ins>。</p></blockquote><p><img src="https://www.hello-algo.com/chapter_tree/binary_search_tree.assets/bst_remove_case1.png"></p><blockquote><p><ins>当待删除节点的度为<code>1</code>时，将待删除节点替换为其子节点即可</ins>。</p></blockquote><p><img src="https://www.hello-algo.com/chapter_tree/binary_search_tree.assets/bst_remove_case2.png"></p><blockquote><p><ins>当待删除节点的度为<code>2</code>时，无法直接删除它，而需要使用一个节点替换该节点</ins>。由于要保持二叉搜索树“左 <code>&lt;</code> 根 <code>&lt;</code> 右”的性质，因此<ins>这个节点可以是右子树的最小节点或左子树的最大节点</ins>。</p></blockquote><p><ins>假设选择右子树的最小节点，即中序遍历的下一个节点</ins>，删除操作流程下图所示。</p><ul><li>找到待删除节点在“中序遍历序列”中的下一个节点，记为<code>tmp</code>。</li><li>将<code>tmp</code>的值覆盖待删除节点的值，并在树中递归删除节点<code>tmp</code>。</li></ul><blockquote><p>实际上，右子树的最小值和左子树的最大值都可以通过中序遍历来找。只需要找到给定节点在该序列中的位置，然后查看它的前一个（左子树最大）或后一个节点（右子树最小）即可。原因是二叉搜索树中序遍历有序。</p></blockquote><div class="tabs" id="placeholder"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#placeholder-1"><1></button></li><li class="tab"><button type="button" data-href="#placeholder-2"><2></button></li><li class="tab"><button type="button" data-href="#placeholder-3"><3></button></li><li class="tab"><button type="button" data-href="#placeholder-4"><4></button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="placeholder-1"><p><img src="https://www.hello-algo.com/chapter_tree/binary_search_tree.assets/bst_remove_case3_step1.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="placeholder-2"><p><img src="https://www.hello-algo.com/chapter_tree/binary_search_tree.assets/bst_remove_case3_step2.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="placeholder-3"><p><img src="https://www.hello-algo.com/chapter_tree/binary_search_tree.assets/bst_remove_case3_step3.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="placeholder-4"><p><img src="https://www.hello-algo.com/chapter_tree/binary_search_tree.assets/bst_remove_case3_step4.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>删除节点操作同样使用<code>O(logn)</code>时间，其中查找待删除节点需要<code>O(logn)</code>时间，获取中序遍历后继节点需要<code>O(logn)</code>时间。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 删除节点 */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">    <span class="comment">// 若树为空，直接提前返回</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> root, pre = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 循环查找，越过叶节点后跳出</span></span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 找到待删除节点，跳出循环</span></span><br><span class="line">        <span class="keyword">if</span> (cur.val == num)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        pre = cur;</span><br><span class="line">        <span class="comment">// 待删除节点在 cur 的右子树中</span></span><br><span class="line">        <span class="keyword">if</span> (cur.val &lt; num)</span><br><span class="line">            cur = cur.right;</span><br><span class="line">        <span class="comment">// 待删除节点在 cur 的左子树中</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cur = cur.left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 若无待删除节点，则直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (cur == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 子节点数量 = 0 or 1</span></span><br><span class="line">    <span class="keyword">if</span> (cur.left == <span class="literal">null</span> || cur.right == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 当子节点数量 = 0 / 1 时， child = null / 该子节点</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">child</span> <span class="operator">=</span> cur.left != <span class="literal">null</span> ? cur.left : cur.right;</span><br><span class="line">        <span class="comment">// 删除节点 cur</span></span><br><span class="line">        <span class="keyword">if</span> (cur != root) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pre.left == cur)</span><br><span class="line">                pre.left = child;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                pre.right = child;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 若删除节点为根节点，则重新指定根节点</span></span><br><span class="line">            root = child;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 子节点数量 = 2</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 获取中序遍历中 cur 的下一个节点</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">tmp</span> <span class="operator">=</span> cur.right;</span><br><span class="line">        <span class="keyword">while</span> (tmp.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            tmp = tmp.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 递归删除节点 tmp</span></span><br><span class="line">        remove(tmp.val);</span><br><span class="line">        <span class="comment">// 用 tmp 覆盖 cur</span></span><br><span class="line">        cur.val = tmp.val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="中序遍历有序"><a href="#中序遍历有序" class="headerlink" title="中序遍历有序"></a>中序遍历有序</h4><p>二叉树的中序遍历遵循“左 <code>-&gt;</code> 根 <code>-&gt;</code> 右”的遍历顺序，而二叉搜索树满足“左子节点 <code>&lt;</code> 根节点 <code>&lt;</code> 右子节点”的大小关系。</p><p>这意味着在二叉搜索树中进行中序遍历时，总是会优先遍历下一个最小节点，从而得出一个重要性质，<ins>二叉搜索树的中序遍历序列是升序的</ins>。</p><p>利用中序遍历升序的性质，我们在二叉搜索树中获取有序数据仅需<code>O(n)</code>时间，无须进行额外的排序操作，非常高效。</p><p><img src="https://www.hello-algo.com/chapter_tree/binary_search_tree.assets/bst_inorder_traversal.png"></p><h4 id="二叉搜索树的效率"><a href="#二叉搜索树的效率" class="headerlink" title="二叉搜索树的效率"></a>二叉搜索树的效率</h4><p>给定一组数据，可以考虑使用数组或二叉搜索树存储。二叉搜索树的各项操作的时间复杂度都是对数阶，具有稳定且高效的性能表现。只有在高频添加、低频查找删除的数据适用场景下，数组比二叉搜索树的效率更高。</p><table><thead><tr><th align="left"></th><th align="left">无序数组</th><th align="left">二叉搜索树</th></tr></thead><tbody><tr><td align="left">查找元素</td><td align="left"><code>O(n)</code></td><td align="left"><code>O(logn)</code></td></tr><tr><td align="left">插入元素</td><td align="left"><code>O(1)</code></td><td align="left"><code>O(logn)</code></td></tr><tr><td align="left">删除元素</td><td align="left"><code>O(n)</code></td><td align="left"><code>O(logn)</code></td></tr></tbody></table><p>在理想情况下，二叉搜索树是“平衡”的，这样就可以在<code>logn</code>轮循环内查找任意节点。</p><p>然而，如果在二叉搜索树中不断地插入和删除节点，可能导致二叉树退化为链表，这时各种操作的时间复杂度也会退化为<code>O(n)</code>。</p><p><img src="https://www.hello-algo.com/chapter_tree/binary_search_tree.assets/bst_degradation.png"></p><hr><h3 id="7-5-AVL-树"><a href="#7-5-AVL-树" class="headerlink" title="7.5 AVL 树"></a>7.5 AVL 树</h3><p>在二叉搜索树章节中，提到了在多次插入和删除操作后，二叉搜索树可能退化为链表。这种情况下，所有操作的时间复杂度将从<code>O(logn)</code>恶化为<code>O(n)</code>。</p><div class="tabs" id="placeholder"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#placeholder-1"><1></button></li><li class="tab"><button type="button" data-href="#placeholder-2"><2></button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="placeholder-1"><p><img src="https://www.hello-algo.com/chapter_tree/avl_tree.assets/avltree_degradation_from_removing_node.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="placeholder-2"><p><img src="https://www.hello-algo.com/chapter_tree/avl_tree.assets/avltree_degradation_from_inserting_node.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>与二叉搜索树不同，<code>AVL</code>树不会退化，各种操作的时间复杂度保持在<code>O(logn)</code>级别。换句话说，在需要频繁进行增删查改操作的场景中，<code>AVL</code>树能始终保持高效的数据操作性能，具有很好的应用价值。</p><h4 id="AVL-树常见术语"><a href="#AVL-树常见术语" class="headerlink" title="AVL 树常见术语"></a>AVL 树常见术语</h4><p><ins><code>AVL</code>树既是二叉搜索树也是平衡二叉树，同时满足这两类二叉树的所有性质</ins>，因此也被称为「平衡二叉搜索树 <code>balanced binary search tree</code>」。</p><p>（1）节点高度</p><p>由于<code>AVL</code>树的相关操作需要获取节点高度，因此需要为节点类添加<code>height</code>变量。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* AVL 树节点类 */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> val;        <span class="comment">// 节点值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> height;     <span class="comment">// 节点高度</span></span><br><span class="line">    <span class="keyword">public</span> TreeNode left;  <span class="comment">// 左子节点</span></span><br><span class="line">    <span class="keyword">public</span> TreeNode right; <span class="comment">// 右子节点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TreeNode</span><span class="params">(<span class="type">int</span> x)</span> &#123; val = x; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><ins>“节点高度”是指从该节点到最远叶节点的距离，即所经过的“边”的数量</ins>。需要特别注意的是，叶节点的高度为<code>0</code>，而空节点的高度为<code>-1</code>。下面创建两个工具函数，分别用于获取和更新节点的高度。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 获取节点高度 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">height</span><span class="params">(TreeNode node)</span> &#123;</span><br><span class="line">    <span class="comment">// 空节点高度为 -1 ，叶节点高度为 0</span></span><br><span class="line">    <span class="keyword">return</span> node == <span class="literal">null</span> ? -<span class="number">1</span> : node.height;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 更新节点高度 */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">updateHeight</span><span class="params">(TreeNode node)</span> &#123;</span><br><span class="line">    <span class="comment">// 节点高度等于最高子树高度 + 1</span></span><br><span class="line">    node.height = Math.max(height(node.left), height(node.right)) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）节点平衡因子</p><p>节点的<ins>「平衡因子 <code>balance factor</code>」定义为节点左子树的高度减去右子树的高度</ins>，同时规定空节点的平衡因子为<code>0</code>。同样将获取节点平衡因子的功能封装成函数，方便后续使用。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 获取平衡因子 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">balanceFactor</span><span class="params">(TreeNode node)</span> &#123;</span><br><span class="line">    <span class="comment">// 空节点平衡因子为 0</span></span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 节点平衡因子 = 左子树高度 - 右子树高度</span></span><br><span class="line">    <span class="keyword">return</span> height(node.left) - height(node.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><ins>设平衡因子为<code>f</code>，则一棵<code>AVL</code>树的任意节点的平衡因子皆满足<code>-1 &lt;= f &lt;= 1</code></ins>。</p></blockquote><h4 id="AVL-树旋转"><a href="#AVL-树旋转" class="headerlink" title="AVL 树旋转"></a>AVL 树旋转</h4><p><ins><code>AVL</code>树的特点在于“旋转”操作，它能够在不影响二叉树的中序遍历序列的前提下，使失衡节点重新恢复平衡</ins>。换句话说，旋转操作既能保持“二叉搜索树”的性质，也能使树重新变为“平衡二叉树”。</p><p>规定，平衡因子绝对值<code>&gt; 1</code>的节点称为“失衡节点”。根据节点失衡情况的不同，旋转操作分为四种，<ins>右旋、左旋、先右旋后左旋、先左旋后右旋</ins>。下面将详细介绍这些旋转操作。</p><p>（1）右旋</p><p>如下图所示，节点下方为平衡因子。从底至顶看，二叉树中首个失衡节点是“节点 <code>3</code>”（左子树高度减右子树高度）。<ins>找出以该失衡节点为根节点的子树，将该节点记为<code>node</code>，其左子节点记为<code>child</code>，执行“右旋”操作。完成右旋后，子树已经恢复平衡，并且仍然保持二叉搜索树的特性</ins>。</p><div class="tabs" id="placeholder"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#placeholder-1"><1></button></li><li class="tab"><button type="button" data-href="#placeholder-2"><2></button></li><li class="tab"><button type="button" data-href="#placeholder-3"><3></button></li><li class="tab"><button type="button" data-href="#placeholder-4"><4></button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="placeholder-1"><p><img src="https://www.hello-algo.com/chapter_tree/avl_tree.assets/avltree_right_rotate_step1.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="placeholder-2"><p><img src="https://www.hello-algo.com/chapter_tree/avl_tree.assets/avltree_right_rotate_step2.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="placeholder-3"><p><img src="https://www.hello-algo.com/chapter_tree/avl_tree.assets/avltree_right_rotate_step3.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="placeholder-4"><p><img src="https://www.hello-algo.com/chapter_tree/avl_tree.assets/avltree_right_rotate_step4.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><blockquote><p>注意，<ins>当节点<code>child</code>有右子节点（记为<code>grandChild</code>）时，需要在右旋中添加一步，将<code>grandChild</code>作为<code>node</code>的左子节点</ins>。</p></blockquote><p><img src="https://www.hello-algo.com/chapter_tree/avl_tree.assets/avltree_right_rotate_with_grandchild.png"></p><p>“向右旋转”是一种形象化的说法，实际上需要通过修改节点指针来实现，代码如下所示。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 右旋操作 */</span></span><br><span class="line">TreeNode <span class="title function_">rightRotate</span><span class="params">(TreeNode node)</span> &#123;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">child</span> <span class="operator">=</span> node.left;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">grandChild</span> <span class="operator">=</span> child.right;</span><br><span class="line">    <span class="comment">// 以 child 为原点，将 node 向右旋转</span></span><br><span class="line">    child.right = node;</span><br><span class="line">    node.left = grandChild;</span><br><span class="line">    <span class="comment">// 更新节点高度</span></span><br><span class="line">    updateHeight(node);</span><br><span class="line">    updateHeight(child);</span><br><span class="line">    <span class="comment">// 返回旋转后子树的根节点</span></span><br><span class="line">    <span class="keyword">return</span> child;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）左旋</p><p>相应的，如果考虑上述失衡二叉树的“镜像”，则需要执行下图所示的“左旋”操作。</p><p><img src="https://www.hello-algo.com/chapter_tree/avl_tree.assets/avltree_left_rotate.png"></p><blockquote><p>同理，当节点<code>child</code>有左子节点（记为<code>grandChild</code>）时，需要在左旋中添加一步，将<code>grandChild</code>作为<code>node</code>的右子节点。</p></blockquote><p><img src="https://www.hello-algo.com/chapter_tree/avl_tree.assets/avltree_left_rotate_with_grandchild.png"></p><p>实际上，右旋和左旋操作在逻辑上是镜像对称的，它们分别解决的两种失衡情况也是对称的。<ins>基于对称性，只需将右旋的实现代码中的所有的<code>left</code>替换为<code>right</code>，将所有的<code>right</code>替换为<code>left</code>，即可得到左旋的实现代码</ins>。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 左旋操作 */</span></span><br><span class="line">TreeNode <span class="title function_">leftRotate</span><span class="params">(TreeNode node)</span> &#123;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">child</span> <span class="operator">=</span> node.right;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">grandChild</span> <span class="operator">=</span> child.left;</span><br><span class="line">    <span class="comment">// 以 child 为原点，将 node 向左旋转</span></span><br><span class="line">    child.left = node;</span><br><span class="line">    node.right = grandChild;</span><br><span class="line">    <span class="comment">// 更新节点高度</span></span><br><span class="line">    updateHeight(node);</span><br><span class="line">    updateHeight(child);</span><br><span class="line">    <span class="comment">// 返回旋转后子树的根节点</span></span><br><span class="line">    <span class="keyword">return</span> child;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（3）先左旋后右旋</p><p>对于下图中的失衡节点<code>3</code>，仅使用左旋或右旋都无法使子树恢复平衡。此时需要<ins>先对<code>child</code>执行“左旋”，再对<code>node</code>执行“右旋”</ins>。</p><p><img src="https://www.hello-algo.com/chapter_tree/avl_tree.assets/avltree_left_right_rotate.png"></p><p>（4）先右旋后左旋</p><p>对于上述失衡二叉树的镜像情况，需要先对<code>child</code>执行“右旋”，然后对<code>node</code>执行“左旋”。</p><p><img src="https://www.hello-algo.com/chapter_tree/avl_tree.assets/avltree_right_left_rotate.png"></p><p>（5）旋转的选择</p><p>下面展示的四种失衡情况，分别需要采用右旋、左旋、先右后左、先左后右的旋转操作。</p><p><img src="https://www.hello-algo.com/chapter_tree/avl_tree.assets/avltree_rotation_cases.png"></p><p>如下表所示，<ins>通过判断失衡节点的平衡因子以及较高一侧子节点的平衡因子的正负号，来确定失衡节点属于哪种情况</ins>。</p><table><thead><tr><th align="left">失衡节点的平衡因子</th><th align="left">子节点的平衡因子</th><th align="left">应采用的旋转方法</th></tr></thead><tbody><tr><td align="left"><code>&gt; 1</code> 即左偏树</td><td align="left"><code>&gt;= 0</code></td><td align="left">右旋</td></tr><tr><td align="left"><code>&gt; 1</code> 即左偏树</td><td align="left"><code>&lt; 0</code></td><td align="left">先左旋后右旋</td></tr><tr><td align="left"><code>&lt; -1</code> 即右偏树</td><td align="left"><code>&lt;= 0</code></td><td align="left">左旋</td></tr><tr><td align="left"><code>&lt; -1</code> 即右偏树</td><td align="left"><code>&gt; 0</code></td><td align="left">先右旋后左旋</td></tr></tbody></table><p>为了便于使用，可以将旋转操作封装成一个函数。有了这个函数，就能对各种失衡情况进行旋转，使失衡节点重新恢复平衡。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 执行旋转操作，使该子树重新恢复平衡 */</span></span><br><span class="line">TreeNode <span class="title function_">rotate</span><span class="params">(TreeNode node)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取节点 node 的平衡因子</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">balanceFactor</span> <span class="operator">=</span> balanceFactor(node);</span><br><span class="line">    <span class="comment">// 左偏树</span></span><br><span class="line">    <span class="keyword">if</span> (balanceFactor &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (balanceFactor(node.left) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 右旋</span></span><br><span class="line">            <span class="keyword">return</span> rightRotate(node);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 先左旋后右旋</span></span><br><span class="line">            node.left = leftRotate(node.left);</span><br><span class="line">            <span class="keyword">return</span> rightRotate(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 右偏树</span></span><br><span class="line">    <span class="keyword">if</span> (balanceFactor &lt; -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (balanceFactor(node.right) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 左旋</span></span><br><span class="line">            <span class="keyword">return</span> leftRotate(node);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 先右旋后左旋</span></span><br><span class="line">            node.right = rightRotate(node.right);</span><br><span class="line">            <span class="keyword">return</span> leftRotate(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 平衡树，无须旋转，直接返回</span></span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="AVL-树常用操作"><a href="#AVL-树常用操作" class="headerlink" title="AVL 树常用操作"></a>AVL 树常用操作</h4><p>（1）插入节点</p><p><code>AVL</code>树的节点插入操作与二叉搜索树在主体上类似。唯一的区别在于，<ins>在<code>AVL</code>树中插入节点后，从该节点到根节点的路径上可能会出现一系列失衡节点。因此，需要从这个节点开始，自底向上执行旋转操作，使所有失衡节点恢复平衡</ins>。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 插入节点 */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">    root = insertHelper(root, val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 递归插入节点（辅助方法） */</span></span><br><span class="line">TreeNode <span class="title function_">insertHelper</span><span class="params">(TreeNode node, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(val);</span><br><span class="line">    <span class="comment">/* 1. 查找插入位置，并插入节点 */</span></span><br><span class="line">    <span class="keyword">if</span> (val &lt; node.val)</span><br><span class="line">        node.left = insertHelper(node.left, val);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (val &gt; node.val)</span><br><span class="line">        node.right = insertHelper(node.right, val);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> node; <span class="comment">// 重复节点不插入，直接返回</span></span><br><span class="line">    updateHeight(node); <span class="comment">// 更新节点高度</span></span><br><span class="line">    <span class="comment">/* 2. 执行旋转操作，使该子树重新恢复平衡 */</span></span><br><span class="line">    node = rotate(node);</span><br><span class="line">    <span class="comment">// 返回子树的根节点</span></span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）删除节点</p><p><ins>在二叉搜索树的删除节点方法的基础上，需要从底至顶地执行旋转操作，使所有失衡节点恢复平衡</ins>。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 删除节点 */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">    root = removeHelper(root, val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 递归删除节点（辅助方法） */</span></span><br><span class="line">TreeNode <span class="title function_">removeHelper</span><span class="params">(TreeNode node, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">/* 1. 查找节点，并删除之 */</span></span><br><span class="line">    <span class="keyword">if</span> (val &lt; node.val)</span><br><span class="line">        node.left = removeHelper(node.left, val);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (val &gt; node.val)</span><br><span class="line">        node.right = removeHelper(node.right, val);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node.left == <span class="literal">null</span> || node.right == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">child</span> <span class="operator">=</span> node.left != <span class="literal">null</span> ? node.left : node.right;</span><br><span class="line">            <span class="comment">// 子节点数量 = 0 ，直接删除 node 并返回</span></span><br><span class="line">            <span class="keyword">if</span> (child == <span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="comment">// 子节点数量 = 1 ，直接删除 node</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                node = child;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 子节点数量 = 2 ，则将中序遍历的下个节点删除，并用该节点替换当前节点</span></span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">temp</span> <span class="operator">=</span> node.right;</span><br><span class="line">            <span class="keyword">while</span> (temp.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                temp = temp.left;</span><br><span class="line">            &#125;</span><br><span class="line">            node.right = removeHelper(node.right, temp.val);</span><br><span class="line">            node.val = temp.val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    updateHeight(node); <span class="comment">// 更新节点高度</span></span><br><span class="line">    <span class="comment">/* 2. 执行旋转操作，使该子树重新恢复平衡 */</span></span><br><span class="line">    node = rotate(node);</span><br><span class="line">    <span class="comment">// 返回子树的根节点</span></span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（3）查找节点</p><p><code>AVL</code>树的节点查找操作与二叉搜索树一致，在此不再赘述。</p><hr><h2 id="8-堆"><a href="#8-堆" class="headerlink" title="8. 堆"></a>8. 堆</h2><h3 id="8-1-堆"><a href="#8-1-堆" class="headerlink" title="8.1 堆"></a>8.1 堆</h3><p>「堆 <code>heap</code>」是一种满足特定条件的完全二叉树，主要分为两种类型。</p><ul><li>「大顶堆 <code>max heap</code>」：任意节点的值<code>&gt;=</code>其子节点的值。</li><li>「小顶堆 <code>min heap</code>」：任意节点的值<code>&lt;=</code>其子节点的值。</li></ul><p><img src="https://www.hello-algo.com/chapter_heap/heap.assets/min_heap_and_max_heap.png"></p><p>堆作为完全二叉树的一个特例，具有以下特性。</p><ul><li>最底层节点靠左填充，其他层的节点都被填满。</li><li>二叉树的根节点称为“堆顶”，底层最靠右的节点称为“堆底”。</li><li><ins>对于大顶堆（小顶堆），堆顶元素（即根节点）的值分别是最大（最小）的</ins>。</li></ul><h4 id="堆常用操作"><a href="#堆常用操作" class="headerlink" title="堆常用操作"></a>堆常用操作</h4><p><ins>堆通常用作实现优先队列</ins>，可以将“优先队列”和“堆”看作等价的数据结构。许多编程语言提供的是「优先队列 <code>priority queue</code>」，这是一种抽象数据结构，定义为具有优先级排序的队列。</p><p>堆的常用操作见下表，方法名需要根据编程语言来确定。</p><table><thead><tr><th align="left">方法名</th><th align="left">描述</th><th align="left">时间复杂度</th></tr></thead><tbody><tr><td align="left"><code>push()</code></td><td align="left">元素入堆</td><td align="left"><code>O(logn)</code></td></tr><tr><td align="left"><code>pop()</code></td><td align="left">堆顶元素出堆</td><td align="left"><code>O(logn)</code></td></tr><tr><td align="left"><code>peek()</code></td><td align="left">访问堆顶元素（大 &#x2F; 小顶堆分别为最大 &#x2F; 小值）</td><td align="left"><code>O(1)</code></td></tr><tr><td align="left"><code>size()</code></td><td align="left">获取堆的元素数量</td><td align="left"><code>O(1)</code></td></tr><tr><td align="left"><code>isEmpty()</code></td><td align="left">判断堆是否为空</td><td align="left"><code>O(1)</code></td></tr></tbody></table><blockquote><p>类似于排序算法中的“从小到大排列”和“从大到小排列”，<ins>通过修改<code>Comparator</code>来实现“小顶堆”与“大顶堆”之间的转换</ins>。</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 初始化堆 */</span></span><br><span class="line"><span class="comment">// 初始化小顶堆</span></span><br><span class="line">Queue&lt;Integer&gt; minHeap = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;();</span><br><span class="line"><span class="comment">// 初始化大顶堆（使用 lambda 表达式修改 Comparator 即可）</span></span><br><span class="line">Queue&lt;Integer&gt; maxHeap = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((a, b) -&gt; b - a);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 元素入堆 */</span></span><br><span class="line">maxHeap.offer(<span class="number">1</span>);</span><br><span class="line">maxHeap.offer(<span class="number">3</span>);</span><br><span class="line">maxHeap.offer(<span class="number">2</span>);</span><br><span class="line">maxHeap.offer(<span class="number">5</span>);</span><br><span class="line">maxHeap.offer(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取堆顶元素 */</span></span><br><span class="line"><span class="type">int</span> <span class="variable">peek</span> <span class="operator">=</span> maxHeap.peek(); <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 堆顶元素出堆 */</span></span><br><span class="line"><span class="comment">// 出堆元素会形成一个从大到小的序列</span></span><br><span class="line">peek = maxHeap.poll(); <span class="comment">// 5</span></span><br><span class="line">peek = maxHeap.poll(); <span class="comment">// 4</span></span><br><span class="line">peek = maxHeap.poll(); <span class="comment">// 3</span></span><br><span class="line">peek = maxHeap.poll(); <span class="comment">// 2</span></span><br><span class="line">peek = maxHeap.poll(); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取堆大小 */</span></span><br><span class="line"><span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> maxHeap.size();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 判断堆是否为空 */</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">isEmpty</span> <span class="operator">=</span> maxHeap.isEmpty();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 输入列表并建堆 */</span></span><br><span class="line">minHeap = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(Arrays.asList(<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">4</span>));</span><br></pre></td></tr></table></figure><h4 id="堆的实现"><a href="#堆的实现" class="headerlink" title="堆的实现"></a>堆的实现</h4><blockquote><p>下面实现的是大顶堆。若要将其转换为小顶堆，只需将所有大小逻辑判断取逆。</p></blockquote><p>（1）堆的存储与表示</p><p>在二叉树章节中学习到，<ins>完全二叉树非常适合用数组来表示。由于堆正是一种完全二叉树，可以采用数组来存储堆</ins>。当使用数组表示二叉树时，元素代表节点值，索引代表节点在二叉树中的位置。节点指针通过索引映射公式来实现。</p><p>如下图所示，给定索引<code>i</code>，其左子节点索引为<code>2i + 1</code>，右子节点索引为<code>2i + 2</code>，父节点索引为<code>(i - 1) / 2</code>（向下取整）。当索引越界时，表示空节点或节点不存在。</p><p><img src="https://www.hello-algo.com/chapter_heap/heap.assets/representation_of_heap.png"></p><p>先将索引映射公式封装成函数，方便后续使用。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 获取左子节点索引 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">left</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取右子节点索引 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">right</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * i + <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取父节点索引 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">parent</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (i - <span class="number">1</span>) / <span class="number">2</span>; <span class="comment">// 向下整除</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）访问堆顶元素</p><p>堆顶元素即为二叉树的根节点，也就是列表的首个元素。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 访问堆顶元素 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">peek</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> maxHeap.get(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(3) 元素入堆</p><p>给定元素<code>val</code>，首先将其添加到堆底。由于<code>val</code>可能大于堆中其他元素，堆的成立条件可能已被破坏。因此，需要修复从插入节点到根节点的路径上的各个节点，这个操作被称为「堆化 <code>heapify</code>」。</p><p><ins>从入堆节点开始，从底至顶执行堆化</ins>。如下图所示，<ins>比较插入节点与其父节点的值，如果插入节点更大，则将它们交换。然后继续执行此操作，从底至顶修复堆中的各个节点</ins>，直至越过根节点或遇到无须交换的节点时结束。（二叉树数组表示可以帮助理解）</p><div class="tabs" id="placeholder"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#placeholder-1"><1></button></li><li class="tab"><button type="button" data-href="#placeholder-2"><2></button></li><li class="tab"><button type="button" data-href="#placeholder-3"><3></button></li><li class="tab"><button type="button" data-href="#placeholder-4"><4></button></li><li class="tab"><button type="button" data-href="#placeholder-5"><5></button></li><li class="tab"><button type="button" data-href="#placeholder-6"><6></button></li><li class="tab"><button type="button" data-href="#placeholder-7"><7></button></li><li class="tab"><button type="button" data-href="#placeholder-8"><8></button></li><li class="tab"><button type="button" data-href="#placeholder-9"><9></button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="placeholder-1"><p><img src="https://www.hello-algo.com/chapter_heap/heap.assets/heap_push_step1.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="placeholder-2"><p><img src="https://www.hello-algo.com/chapter_heap/heap.assets/heap_push_step2.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="placeholder-3"><p><img src="https://www.hello-algo.com/chapter_heap/heap.assets/heap_push_step3.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="placeholder-4"><p><img src="https://www.hello-algo.com/chapter_heap/heap.assets/heap_push_step4.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="placeholder-5"><p><img src="https://www.hello-algo.com/chapter_heap/heap.assets/heap_push_step5.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="placeholder-6"><p><img src="https://www.hello-algo.com/chapter_heap/heap.assets/heap_push_step6.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="placeholder-7"><p><img src="https://www.hello-algo.com/chapter_heap/heap.assets/heap_push_step7.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="placeholder-8"><p><img src="https://www.hello-algo.com/chapter_heap/heap.assets/heap_push_step8.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="placeholder-9"><p><img src="https://www.hello-algo.com/chapter_heap/heap.assets/heap_push_step9.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>设节点总数为<code>n</code>，则树的高度为<code>O(logn)</code>。由此可知，堆化操作的循环轮数最多为<code>O(logn)</code>，元素入堆操作的时间复杂度为<code>O(logn)</code>。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 元素入堆 */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="comment">// 添加节点</span></span><br><span class="line">    maxHeap.add(val);</span><br><span class="line">    <span class="comment">// 从底至顶堆化</span></span><br><span class="line">    siftUp(size() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 从节点 i 开始，从底至顶堆化 */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">siftUp</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 获取节点 i 的父节点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> parent(i);</span><br><span class="line">        <span class="comment">// 当“越过根节点”或“节点无须修复”时，结束堆化</span></span><br><span class="line">        <span class="keyword">if</span> (p &lt; <span class="number">0</span> || maxHeap.get(i) &lt;= maxHeap.get(p))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 交换两节点</span></span><br><span class="line">        swap(i, p);</span><br><span class="line">        <span class="comment">// 循环向上堆化</span></span><br><span class="line">        i = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（4）堆顶元素出堆</p><p>堆顶元素是二叉树的根节点，即列表首元素。<ins>如果直接从列表中删除首元素，那么二叉树中所有节点的索引都会发生变化</ins>，这将使得后续使用堆化修复变得困难。为了尽量减少元素索引的变动，采用以下操作步骤。</p><ul><li>交换堆顶元素与堆底元素（即交换根节点与最右叶节点）。</li><li>交换完成后，将堆底从列表中删除（注意，由于已经交换，实际上删除的是原来的堆顶元素）。</li><li>从根节点开始，从顶至底执行堆化。</li></ul><p>如下图所示，<ins>“从顶至底堆化”的操作方向与“从底至顶堆化”相反</ins>，将根节点的值与其两个子节点的值进行比较，将最大的子节点与根节点交换。然后循环执行此操作，直到越过叶节点或遇到无须交换的节点时结束。</p><div class="tabs" id="placeholder"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#placeholder-1"><1></button></li><li class="tab"><button type="button" data-href="#placeholder-2"><2></button></li><li class="tab"><button type="button" data-href="#placeholder-3"><3></button></li><li class="tab"><button type="button" data-href="#placeholder-4"><4></button></li><li class="tab"><button type="button" data-href="#placeholder-5"><5></button></li><li class="tab"><button type="button" data-href="#placeholder-6"><6></button></li><li class="tab"><button type="button" data-href="#placeholder-7"><7></button></li><li class="tab"><button type="button" data-href="#placeholder-8"><8></button></li><li class="tab"><button type="button" data-href="#placeholder-9"><9></button></li><li class="tab"><button type="button" data-href="#placeholder-10"><10></button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="placeholder-1"><p><img src="https://www.hello-algo.com/chapter_heap/heap.assets/heap_pop_step1.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="placeholder-2"><p><img src="https://www.hello-algo.com/chapter_heap/heap.assets/heap_pop_step2.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="placeholder-3"><p><img src="https://www.hello-algo.com/chapter_heap/heap.assets/heap_pop_step3.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="placeholder-4"><p><img src="https://www.hello-algo.com/chapter_heap/heap.assets/heap_pop_step4.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="placeholder-5"><p><img src="https://www.hello-algo.com/chapter_heap/heap.assets/heap_pop_step5.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="placeholder-6"><p><img src="https://www.hello-algo.com/chapter_heap/heap.assets/heap_pop_step6.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="placeholder-7"><p><img src="https://www.hello-algo.com/chapter_heap/heap.assets/heap_pop_step7.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="placeholder-8"><p><img src="https://www.hello-algo.com/chapter_heap/heap.assets/heap_pop_step8.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="placeholder-9"><p><img src="https://www.hello-algo.com/chapter_heap/heap.assets/heap_pop_step9.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="placeholder-10"><p><img src="https://www.hello-algo.com/chapter_heap/heap.assets/heap_pop_step10.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>与元素入堆操作相似，堆顶元素出堆操作的时间复杂度也为<code>O(logn)</code>。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 元素出堆 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 判空处理</span></span><br><span class="line">    <span class="keyword">if</span> (isEmpty())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>();</span><br><span class="line">    <span class="comment">// 交换根节点与最右叶节点（即交换首元素与尾元素）</span></span><br><span class="line">    swap(<span class="number">0</span>, size() - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 删除节点</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">val</span> <span class="operator">=</span> maxHeap.remove(size() - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 从顶至底堆化</span></span><br><span class="line">    siftDown(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 返回堆顶元素</span></span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 从节点 i 开始，从顶至底堆化 */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">siftDown</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 判断节点 i, l, r 中值最大的节点，记为 ma</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> left(i), r = right(i), ma = i;</span><br><span class="line">        <span class="keyword">if</span> (l &lt; size() &amp;&amp; maxHeap.get(l) &gt; maxHeap.get(ma))</span><br><span class="line">            ma = l;</span><br><span class="line">        <span class="keyword">if</span> (r &lt; size() &amp;&amp; maxHeap.get(r) &gt; maxHeap.get(ma))</span><br><span class="line">            ma = r;</span><br><span class="line">        <span class="comment">// 若节点 i 最大或索引 l, r 越界，则无须继续堆化，跳出</span></span><br><span class="line">        <span class="keyword">if</span> (ma == i)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 交换两节点</span></span><br><span class="line">        swap(i, ma);</span><br><span class="line">        <span class="comment">// 循环向下堆化</span></span><br><span class="line">        i = ma;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="8-2-建堆操作"><a href="#8-2-建堆操作" class="headerlink" title="8.2 建堆操作"></a>8.2 建堆操作</h3><p>在某些情况下，我们希望使用一个列表的所有元素来构建一个堆，这个过程被称为“建堆操作”。</p><h4 id="自上而下构建"><a href="#自上而下构建" class="headerlink" title="自上而下构建"></a>自上而下构建</h4><p>首先创建一个空堆，然后遍历列表，依次对每个元素执行“入堆操作”，即先将元素添加至堆的尾部，再对该元素执行“从底至顶”堆化。</p><p>每当一个元素入堆，堆的长度就加一，因此堆是“自上而下”地构建的。</p><p>设元素数量为<code>n</code>，每个元素的入堆操作使用<code>O(logn)</code>时间，因此该建堆方法的时间复杂度为<code>O(logn)</code>。</p><h4 id="自下而上构建"><a href="#自下而上构建" class="headerlink" title="自下而上构建"></a>自下而上构建</h4><p>实际上，可以实现一种更为高效的建堆方法，共分为两步。</p><ul><li>将列表所有元素原封不动添加到堆中。</li><li><ins>倒序遍历堆（即层序遍历的倒序），依次对每个非叶节点执行“从顶至底堆化”</ins>。</li></ul><p>在倒序遍历中，堆是“自下而上”地构建的，需要重点理解以下两点。</p><ul><li>叶节点没有子节点，无需对它们执行堆化。<ins>最后一个节点的父节点是最后一个非叶节点</ins>。</li><li>在倒序遍历中，能够保证当前节点之下的子树已经完成堆化（已经是合法的堆），而这是堆化当前节点的前置条件。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 构造方法，根据输入列表建堆 */</span></span><br><span class="line">MaxHeap(List&lt;Integer&gt; nums) &#123;</span><br><span class="line">    <span class="comment">// 将列表元素原封不动添加进堆</span></span><br><span class="line">    maxHeap = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(nums);</span><br><span class="line">    <span class="comment">// 堆化除叶节点以外的其他所有节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> parent(size() - <span class="number">1</span>); i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        siftDown(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="8-3-Top-K-问题"><a href="#8-3-Top-K-问题" class="headerlink" title="8.3 Top-K 问题"></a>8.3 Top-K 问题</h3><blockquote><p>给定一个长度为<code>n</code>无序数组<code>nums</code>，请返回数组中前<code>k</code>大的元素。</p></blockquote><p><strong>遍历解法</strong></p><p>通过<code>k</code>轮遍历，分别在每轮中提取第<code>1</code>、<code>2</code>、<code>...</code>、<code>k</code>大的元素，时间复杂度为<code>O(nk)</code>。此方法只适用于<code>k &lt;&lt; n</code>的情况，因为当<code>k</code>与<code>n</code>比较接近时，其时间复杂度趋向于<code>O(n^2)</code>。</p><p><img src="https://www.hello-algo.com/chapter_heap/top_k.assets/top_k_traversal.png"></p><p><strong>排序解法</strong></p><p>可以先对数组<code>nums</code>进行排序，再返回最右边的<code>k</code>个元素，时间复杂度为<code>O(nlogn)</code>。显然，该方法“超额”完成任务了，因为只需要找出最大的<code>k</code>个元素即可，而不需要排序其他元素。</p><p><img src="https://www.hello-algo.com/chapter_heap/top_k.assets/top_k_sorting.png"></p><p><strong>堆解法</strong></p><p>可以基于堆更加高效地解决<code>Top-K</code>问题，流程如下所示。</p><ul><li>初始化一个小顶堆，其堆顶元素最小。</li><li>先将数组的前<code>k</code>个元素依次入堆。</li><li>从第<code>k + 1</code>个元素开始，若当前元素大于堆顶元素，则将堆顶元素出堆，并将当前元素入堆。</li><li>遍历完成后，堆中保存的就是最大的<code>k</code>个元素。</li></ul><div class="tabs" id="placeholder"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#placeholder-1"><1></button></li><li class="tab"><button type="button" data-href="#placeholder-2"><2></button></li><li class="tab"><button type="button" data-href="#placeholder-3"><3></button></li><li class="tab"><button type="button" data-href="#placeholder-4"><4></button></li><li class="tab"><button type="button" data-href="#placeholder-5"><5></button></li><li class="tab"><button type="button" data-href="#placeholder-6"><6></button></li><li class="tab"><button type="button" data-href="#placeholder-7"><7></button></li><li class="tab"><button type="button" data-href="#placeholder-8"><8></button></li><li class="tab"><button type="button" data-href="#placeholder-9"><9></button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="placeholder-1"><p><img src="https://www.hello-algo.com/chapter_heap/top_k.assets/top_k_heap_step1.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="placeholder-2"><p><img src="https://www.hello-algo.com/chapter_heap/top_k.assets/top_k_heap_step2.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="placeholder-3"><p><img src="https://www.hello-algo.com/chapter_heap/top_k.assets/top_k_heap_step3.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="placeholder-4"><p><img src="https://www.hello-algo.com/chapter_heap/top_k.assets/top_k_heap_step4.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="placeholder-5"><p><img src="https://www.hello-algo.com/chapter_heap/top_k.assets/top_k_heap_step5.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="placeholder-6"><p><img src="https://www.hello-algo.com/chapter_heap/top_k.assets/top_k_heap_step6.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="placeholder-7"><p><img src="https://www.hello-algo.com/chapter_heap/top_k.assets/top_k_heap_step7.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="placeholder-8"><p><img src="https://www.hello-algo.com/chapter_heap/top_k.assets/top_k_heap_step8.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="placeholder-9"><p><img src="https://www.hello-algo.com/chapter_heap/top_k.assets/top_k_heap_step9.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>总共执行了<code>n</code>轮入堆和出堆，堆的最大长度为<code>k</code>，因此时间复杂度为<code>O(nlogk)</code>。该方法的效率很高，当 <code>k</code>较小时，时间复杂度趋向<code>O(n)</code>。当<code>k</code>较大时，时间复杂度不会超过<code>O(nlogn)</code>。</p><p>另外，该方法适用于动态数据流的使用场景。在不断加入数据时，可以持续维护堆内的元素，从而实现最大<code>k</code>个元素的动态更新。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 基于堆查找数组中最大的 k 个元素 */</span></span><br><span class="line">Queue&lt;Integer&gt; <span class="title function_">topKHeap</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    Queue&lt;Integer&gt; heap = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;Integer&gt;();</span><br><span class="line">    <span class="comment">// 将数组的前 k 个元素入堆</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">        heap.offer(nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从第 k+1 个元素开始，保持堆的长度为 k</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> k; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="comment">// 若当前元素大于堆顶元素，则将堆顶元素出堆、当前元素入堆</span></span><br><span class="line">        <span class="keyword">if</span> (nums[i] &gt; heap.peek()) &#123;</span><br><span class="line">            heap.poll();</span><br><span class="line">            heap.offer(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> heap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="9-图"><a href="#9-图" class="headerlink" title="9. 图"></a>9. 图</h2><h3 id="9-1-图"><a href="#9-1-图" class="headerlink" title="9.1 图"></a>9.1 图</h3><p>「图 <code>graph</code>」是一种非线性数据结构，由「顶点 <code>vertex</code>」和「边 <code>edge</code>」组成。我们可以将图<code>G</code>抽象地表示为一组顶点<code>V</code>和一组边<code>E</code>的集合。以下示例展示了一个包含<code>5</code>个顶点和<code>7</code>条边的图。</p><ul><li><code>V = &#123;1, 2, 3, 4, 5&#125;</code></li><li><code>E = &#123;(1, 2), (1, 3), (1, 5), (2, 3), (2, 4), (2, 5), (4, 5)&#125;</code></li><li><code>G = &#123;V, E&#125;</code></li></ul><p>如果将顶点看作节点，将边看作连接各个节点的引用，就可以将图看作是一种从链表拓展而来的数据结构。相较于线性关系（链表）和分治关系（树），网络关系（图）的自由度更高，从而更为复杂。</p><p><img src="https://www.hello-algo.com/chapter_graph/graph.assets/linkedlist_tree_graph.png"></p><h4 id="图常见类型与术语"><a href="#图常见类型与术语" class="headerlink" title="图常见类型与术语"></a>图常见类型与术语</h4><p>根据边是否具有方向，可分为「无向图 <code>undirected graph</code>」和「有向图 <code>directed graph</code>」。</p><ul><li>在无向图中，边表示两顶点之间的“双向”连接关系，例如微信中的“好友关系”。</li><li>在有向图中，边具有方向性，即<code>A -&gt; B</code>和<code>B -&gt; A</code>两个方向的边是相互独立的，例如微博或抖音上的“关注”与“被关注”关系。</li></ul><p><img src="https://www.hello-algo.com/chapter_graph/graph.assets/directed_graph.png"></p><p>根据所有顶点是否连通，可分为「连通图 <code>connected graph</code>」和「非连通图 <code>disconnected graph</code>」。</p><ul><li>对于连通图，从某个顶点出发，可以到达其余任意顶点。</li><li>对于非连通图，从某个顶点出发，至少有一个顶点无法到达。</li></ul><p><img src="https://www.hello-algo.com/chapter_graph/graph.assets/connected_graph.png"></p><p>还可以为边添加“权重”变量，从而得到「有权图 <code>weighted graph</code>」。</p><p><img src="https://www.hello-algo.com/chapter_graph/graph.assets/weighted_graph.png"></p><p>图数据结构包含以下常用术语。</p><ul><li>「邻接 <code>adjacency</code>」：当两顶点之间存在边相连时，称这两顶点“邻接”。上图中，顶点<code>1</code>的邻接顶点为顶点<code>2</code>、<code>3</code>、<code>5</code>。</li><li>「路径 <code>path</code>」：从顶点<code>A</code>到顶点<code>B</code>经过的边构成的序列被称为从<code>A</code>到<code>B</code>的“路径”。上图中，边序列<code>1-5-2-4</code>是顶点<code>1</code>到顶点<code>4</code>的一条路径。</li><li>「度 <code>degree</code>」：一个顶点拥有的边数。对于有向图，「入度 <code>In-Degree</code>」表示有多少条边指向该顶点，「出度 <code>Out-Degree</code>」表示有多少条边从该顶点指出。</li></ul><h4 id="图的表示"><a href="#图的表示" class="headerlink" title="图的表示"></a>图的表示</h4><p>图的常用表示方式包括“邻接矩阵”和“邻接表”。以下使用无向图进行举例。</p><p><strong>（1）邻接矩阵</strong></p><p>设图的顶点数量为<code>n</code>，「邻接矩阵 <code>adjacency matrix</code>」使用一个<code>n * n</code>大小的矩阵来表示图，每一行（列）代表一个顶点，矩阵元素代表边，用<code>1</code>或<code>0</code>表示两个顶点之间是否存在边。</p><p>如下图所示，设邻接矩阵为<code>M</code>、顶点列表为<code>V</code>，那么矩阵元素<code>M[i, j] = 1</code>表示顶点<code>V[i]</code>到顶点<code>V[j]</code>之间存在边，反之<code>M[i, j] = 0</code>表示两顶点之间无边。</p><p><img src="https://www.hello-algo.com/chapter_graph/graph.assets/adjacency_matrix.png"></p><p>邻接矩阵具有以下特性。</p><ul><li>顶点不能与自身相连，因此邻接矩阵主对角线元素没有意义。</li><li>对于无向图，两个方向的边等价，此时邻接矩阵关于主对角线对称。</li><li>将邻接矩阵的元素从<code>1</code>和<code>0</code>替换为权重，则可表示有权图。</li></ul><p>使用邻接矩阵表示图时，可以直接访问矩阵元素以获取边，因此增删查操作的效率很高，时间复杂度均为<code>O(1)</code>。然而，矩阵的空间复杂度为<code>O(n^2)</code>，内存占用较多。</p><p><strong>（2）邻接表</strong></p><p>「邻接表 <code>adjacency list</code>」使用<code>n</code>个链表来表示图，链表节点表示顶点。第<code>i</code>条链表对应顶点<code>i</code>，其中存储了该顶点的所有邻接顶点（即与该顶点相连的顶点）。</p><p><img src="https://www.hello-algo.com/chapter_graph/graph.assets/adjacency_list.png"></p><p>邻接表仅存储实际存在的边，而边的总数通常远小于<code>n^2</code>，因此它更加节省空间。然而，在邻接表中需要通过遍历链表来查找边，因此其时间效率不如邻接矩阵。</p><p>观察上图，邻接表结构与哈希表中的“链式地址”非常相似，因此也可以采用类似方法来优化效率。比如当链表较长时，可以将链表转化为<code>AVL</code>树或红黑树，从而将时间效率从<code>O(n)</code>优化至<code>O(logn)</code>。还可以把链表转换为哈希表，从而将时间复杂度降低至<code>O(1)</code>。</p><hr><h3 id="9-2-图基础操作"><a href="#9-2-图基础操作" class="headerlink" title="9.2 图基础操作"></a>9.2 图基础操作</h3><p>图的基础操作可分为对“边”的操作和对“顶点”的操作。在“邻接矩阵”和“邻接表”两种表示方法下，实现方式有所不同。</p><h4 id="基于邻接矩阵的实现"><a href="#基于邻接矩阵的实现" class="headerlink" title="基于邻接矩阵的实现"></a>基于邻接矩阵的实现</h4><p>给定一个顶点数量为<code>n</code>的无向图，则各种操作的实现方式如下图所示。</p><ul><li>添加或删除边：直接在邻接矩阵中修改指定的边即可，使用<code>O(1)</code>时间。而由于是无向图，因此需要同时更新两个方向的边。</li><li>添加顶点：在邻接矩阵的尾部添加一行一列，并全部填<code>0</code>即可，使用<code>O(n)</code>时间。</li><li>删除顶点：在邻接矩阵中删除一行一列。当删除首行首列时达到最差情况，需要将<code>(n - 1)^2</code>个元素“向左上移动”，从而使用<code>O(n^2)</code>时间。</li><li>初始化：传入<code>n</code>个顶点，初始化长度为<code>n</code>的顶点列表<code>vertices</code>，使用<code>O(n)</code>时间。初始化<code>n * n</code>大小的邻接矩阵<code>adjMat</code>，使用<code>O(n^2)</code>时间。</li></ul><div class="tabs" id="placeholder"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#placeholder-1">初始化邻接矩阵</button></li><li class="tab"><button type="button" data-href="#placeholder-2">添加边</button></li><li class="tab"><button type="button" data-href="#placeholder-3">删除边</button></li><li class="tab"><button type="button" data-href="#placeholder-4">添加顶点</button></li><li class="tab"><button type="button" data-href="#placeholder-5">删除顶点</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="placeholder-1"><p><img src="https://www.hello-algo.com/chapter_graph/graph_operations.assets/adjacency_matrix_initialization.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="placeholder-2"><p><img src="https://www.hello-algo.com/chapter_graph/graph_operations.assets/adjacency_matrix_add_edge.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="placeholder-3"><p><img src="https://www.hello-algo.com/chapter_graph/graph_operations.assets/adjacency_matrix_remove_edge.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="placeholder-4"><p><img src="https://www.hello-algo.com/chapter_graph/graph_operations.assets/adjacency_matrix_add_vertex.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="placeholder-5"><p><img src="https://www.hello-algo.com/chapter_graph/graph_operations.assets/adjacency_matrix_remove_vertex.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>以下是基于邻接矩阵表示图的实现代码。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 基于邻接矩阵实现的无向图类 */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GraphAdjMat</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; vertices; <span class="comment">// 顶点列表，元素代表“顶点值”，索引代表“顶点索引”</span></span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; adjMat; <span class="comment">// 邻接矩阵，行列索引对应“顶点索引”</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 构造方法 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">GraphAdjMat</span><span class="params">(<span class="type">int</span>[] vertices, <span class="type">int</span>[][] edges)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.vertices = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="built_in">this</span>.adjMat = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 添加顶点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> val : vertices) &#123;</span><br><span class="line">            addVertex(val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 添加边</span></span><br><span class="line">        <span class="comment">// 请注意，edges 元素代表顶点索引，即对应 vertices 元素索引</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] e : edges) &#123;</span><br><span class="line">            addEdge(e[<span class="number">0</span>], e[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取顶点数量 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> vertices.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 添加顶点 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addVertex</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> size();</span><br><span class="line">        <span class="comment">// 向顶点列表中添加新顶点的值</span></span><br><span class="line">        vertices.add(val);</span><br><span class="line">        <span class="comment">// 在邻接矩阵中添加一行</span></span><br><span class="line">        List&lt;Integer&gt; newRow = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            newRow.add(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        adjMat.add(newRow);</span><br><span class="line">        <span class="comment">// 在邻接矩阵中添加一列</span></span><br><span class="line">        <span class="keyword">for</span> (List&lt;Integer&gt; row : adjMat) &#123;</span><br><span class="line">            row.add(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 删除顶点 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeVertex</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= size())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>();</span><br><span class="line">        <span class="comment">// 在顶点列表中移除索引 index 的顶点</span></span><br><span class="line">        vertices.remove(index);</span><br><span class="line">        <span class="comment">// 在邻接矩阵中删除索引 index 的行</span></span><br><span class="line">        adjMat.remove(index);</span><br><span class="line">        <span class="comment">// 在邻接矩阵中删除索引 index 的列</span></span><br><span class="line">        <span class="keyword">for</span> (List&lt;Integer&gt; row : adjMat) &#123;</span><br><span class="line">            row.remove(index);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 添加边 */</span></span><br><span class="line">    <span class="comment">// 参数 i, j 对应 vertices 元素索引</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addEdge</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="comment">// 索引越界与相等处理</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span> || i &gt;= size() || j &gt;= size() || i == j)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>();</span><br><span class="line">        <span class="comment">// 在无向图中，邻接矩阵沿主对角线对称，即满足 (i, j) == (j, i)</span></span><br><span class="line">        adjMat.get(i).set(j, <span class="number">1</span>);</span><br><span class="line">        adjMat.get(j).set(i, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 删除边 */</span></span><br><span class="line">    <span class="comment">// 参数 i, j 对应 vertices 元素索引</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeEdge</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="comment">// 索引越界与相等处理</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span> || i &gt;= size() || j &gt;= size() || i == j)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>();</span><br><span class="line">        adjMat.get(i).set(j, <span class="number">0</span>);</span><br><span class="line">        adjMat.get(j).set(i, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 打印邻接矩阵 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;顶点列表 = &quot;</span>);</span><br><span class="line">        System.out.println(vertices);</span><br><span class="line">        System.out.println(<span class="string">&quot;邻接矩阵 =&quot;</span>);</span><br><span class="line">        PrintUtil.printMatrix(adjMat);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="基于邻接表的实现"><a href="#基于邻接表的实现" class="headerlink" title="基于邻接表的实现"></a>基于邻接表的实现</h4><p>设无向图的顶点总数为<code>n</code>、边总数为<code>m</code>，则可根据下图所示的方法实现各种操作。</p><ul><li>添加边：在顶点对应链表的末尾添加边即可，使用<code>O(1)</code>时间。因为是无向图，所以需要同时添加两个方向的边。</li><li>删除边：在顶点对应链表中查找并删除指定边，使用<code>O(m)</code>时间。在无向图中，需要同时删除两个方向的边。</li><li>添加顶点：在邻接表中添加一个链表，并将新增顶点作为链表头节点，使用<code>O(1)</code>时间。</li><li>删除顶点：需遍历整个邻接表，删除包含指定顶点的所有边，使用<code>O(n + m)</code>时间。</li><li>初始化：在邻接表中创建<code>n</code>个顶点和<code>m</code>条边，使用<code>O(n + m)</code>时间。</li></ul><div class="tabs" id="placeholder"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#placeholder-1">初始化邻接表</button></li><li class="tab"><button type="button" data-href="#placeholder-2">添加边</button></li><li class="tab"><button type="button" data-href="#placeholder-3">删除边</button></li><li class="tab"><button type="button" data-href="#placeholder-4">添加顶点</button></li><li class="tab"><button type="button" data-href="#placeholder-5">删除顶点</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="placeholder-1"><p><img src="https://www.hello-algo.com/chapter_graph/graph_operations.assets/adjacency_list_initialization.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="placeholder-2"><p><img src="https://www.hello-algo.com/chapter_graph/graph_operations.assets/adjacency_list_add_edge.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="placeholder-3"><p><img src="https://www.hello-algo.com/chapter_graph/graph_operations.assets/adjacency_list_remove_edge.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="placeholder-4"><p><img src="https://www.hello-algo.com/chapter_graph/graph_operations.assets/adjacency_list_add_vertex.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="placeholder-5"><p><img src="https://www.hello-algo.com/chapter_graph/graph_operations.assets/adjacency_list_remove_vertex.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>下面是基于邻接表实现图的代码示例。注意，在邻接表中使用<code>Vertex</code>节点类来表示顶点，这样做是有原因的。</p><ul><li>如果选择通过顶点值来区分不同顶点，那么值重复的顶点将无法被区分。</li><li>如果类似邻接矩阵那样，使用顶点列表索引来区分不同顶点。那么，想要删除索引为<code>i</code>的顶点，则需要遍历整个邻接表，将其中<code>&gt; i</code>的索引全部减<code>1</code>，这样操作效率较低。</li><li>引入顶点类<code>Vertex</code>，使得每个顶点都是唯一的对象，此时删除顶点时就无须改动其余顶点了。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 基于邻接表实现的无向图类 */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GraphAdjList</span> &#123;</span><br><span class="line">    <span class="comment">// 邻接表，key: 顶点，value：该顶点的所有邻接顶点</span></span><br><span class="line">    Map&lt;Vertex, List&lt;Vertex&gt;&gt; adjList;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 构造方法 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">GraphAdjList</span><span class="params">(Vertex[][] edges)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.adjList = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 添加所有顶点和边</span></span><br><span class="line">        <span class="keyword">for</span> (Vertex[] edge : edges) &#123;</span><br><span class="line">            addVertex(edge[<span class="number">0</span>]);</span><br><span class="line">            addVertex(edge[<span class="number">1</span>]);</span><br><span class="line">            addEdge(edge[<span class="number">0</span>], edge[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取顶点数量 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> adjList.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 添加边 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addEdge</span><span class="params">(Vertex vet1, Vertex vet2)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!adjList.containsKey(vet1) || !adjList.containsKey(vet2) || vet1 == vet2)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">        <span class="comment">// 添加边 vet1 - vet2</span></span><br><span class="line">        adjList.get(vet1).add(vet2);</span><br><span class="line">        adjList.get(vet2).add(vet1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 删除边 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeEdge</span><span class="params">(Vertex vet1, Vertex vet2)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!adjList.containsKey(vet1) || !adjList.containsKey(vet2) || vet1 == vet2)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">        <span class="comment">// 删除边 vet1 - vet2</span></span><br><span class="line">        adjList.get(vet1).remove(vet2);</span><br><span class="line">        adjList.get(vet2).remove(vet1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 添加顶点 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addVertex</span><span class="params">(Vertex vet)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (adjList.containsKey(vet))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 在邻接表中添加一个新链表</span></span><br><span class="line">        adjList.put(vet, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 删除顶点 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeVertex</span><span class="params">(Vertex vet)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!adjList.containsKey(vet))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">        <span class="comment">// 在邻接表中删除顶点 vet 对应的链表</span></span><br><span class="line">        adjList.remove(vet);</span><br><span class="line">        <span class="comment">// 遍历其他顶点的链表，删除所有包含 vet 的边</span></span><br><span class="line">        <span class="keyword">for</span> (List&lt;Vertex&gt; list : adjList.values()) &#123;</span><br><span class="line">            list.remove(vet);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 打印邻接表 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;邻接表 =&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Vertex, List&lt;Vertex&gt;&gt; pair : adjList.entrySet()) &#123;</span><br><span class="line">            List&lt;Integer&gt; tmp = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (Vertex vertex : pair.getValue())</span><br><span class="line">                tmp.add(vertex.val);</span><br><span class="line">            System.out.println(pair.getKey().val + <span class="string">&quot;: &quot;</span> + tmp + <span class="string">&quot;,&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="效率对比"><a href="#效率对比" class="headerlink" title="效率对比"></a>效率对比</h4><p>设图中共有<code>n</code>个顶点和<code>m</code>条边，下表对比了邻接矩阵和邻接表的时间和空间效率。</p><table><thead><tr><th align="left"></th><th align="left">邻接矩阵</th><th align="left">邻接表（链表）</th><th align="left">邻接表（哈希表）</th></tr></thead><tbody><tr><td align="left">判断是否邻接</td><td align="left"><code>O(1)</code></td><td align="left"><code>O(m)</code></td><td align="left"><code>O(1)</code></td></tr><tr><td align="left">添加边</td><td align="left"><code>O(1)</code></td><td align="left"><code>O(1)</code></td><td align="left"><code>O(1)</code></td></tr><tr><td align="left">删除边</td><td align="left"><code>O(1)</code></td><td align="left"><code>O(m)</code></td><td align="left"><code>O(1)</code></td></tr><tr><td align="left">添加顶点</td><td align="left"><code>O(n)</code></td><td align="left"><code>O(1)</code></td><td align="left"><code>O(1)</code></td></tr><tr><td align="left">删除顶点</td><td align="left"><code>O(n^2)</code></td><td align="left"><code>O(n + m)</code></td><td align="left"><code>O(n)</code></td></tr><tr><td align="left">内存空间占用</td><td align="left"><code>O(n^2)</code></td><td align="left"><code>O(n + m)</code></td><td align="left"><code>O(n + m)</code></td></tr></tbody></table><p>观察上表 ，似乎邻接表（哈希表）的时间与空间效率最优。但实际上，在邻接矩阵中操作边的效率更高，只需要一次数组访问或赋值操作即可。综合来看，邻接矩阵体现了“以空间换时间”的原则，而邻接表体现了“以时间换空间”的原则。</p><hr><h3 id="9-3-图的遍历"><a href="#9-3-图的遍历" class="headerlink" title="9.3 图的遍历"></a>9.3 图的遍历</h3><p>树代表的是“一对多”的关系，而图则具有更高的自由度，可以表示任意的“多对多”关系。因此，可以把树看作是图的一种特例。显然，树的遍历操作也是图的遍历操作的一种特例。</p><p>图和树都都需要应用搜索算法来实现遍历操作。图的遍历方式可分为两种，「广度优先搜索 <code>breadth-first search</code>」和「深度优先搜索 <code>depth-first search</code>」，简称<code>BFS</code>和<code>DFS</code>。</p><h4 id="广度优先遍历"><a href="#广度优先遍历" class="headerlink" title="广度优先遍历"></a>广度优先遍历</h4><p>广度优先遍历是一种由近及远的遍历方式，从某个节点出发，始终优先访问距离最近的顶点，并一层层向外扩张。如下图所示，从左上角顶点出发，先遍历该顶点的所有邻接顶点，然后遍历下一个顶点的所有邻接顶点，以此类推，直至所有顶点访问完毕。</p><p><img src="https://www.hello-algo.com/chapter_graph/graph_traversal.assets/graph_bfs.png"></p><p><strong>（1）算法实现</strong></p><p><code>BFS</code>通常借助队列来实现。队列具有“先入先出”的性质，这与<code>BFS</code>的“由近及远”的思想异曲同工。</p><ul><li>将遍历起始顶点<code>startVet</code>加入队列，并开启循环。</li><li>每轮迭代中，弹出队首顶点并记录访问，然后将该顶点的所有邻接顶点加入到队列尾部。</li><li>循环上面步骤，直到所有顶点被访问完成后结束。</li></ul><p>为了防止重复遍历顶点，需要借助一个哈希表<code>visited</code>来记录哪些节点已被访问。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 广度优先遍历 BFS */</span></span><br><span class="line"><span class="comment">// 使用邻接表来表示图，以便获取指定顶点的所有邻接顶点</span></span><br><span class="line">List&lt;Vertex&gt; <span class="title function_">graphBFS</span><span class="params">(GraphAdjList graph, Vertex startVet)</span> &#123;</span><br><span class="line">    <span class="comment">// 顶点遍历序列</span></span><br><span class="line">    List&lt;Vertex&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 哈希表，用于记录已被访问过的顶点</span></span><br><span class="line">    Set&lt;Vertex&gt; visited = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    visited.add(startVet);</span><br><span class="line">    <span class="comment">// 队列用于实现 BFS</span></span><br><span class="line">    Queue&lt;Vertex&gt; que = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    que.offer(startVet);</span><br><span class="line">    <span class="comment">// 以顶点 vet 为起点，循环直至访问完所有顶点</span></span><br><span class="line">    <span class="keyword">while</span> (!que.isEmpty()) &#123;</span><br><span class="line">        <span class="type">Vertex</span> <span class="variable">vet</span> <span class="operator">=</span> que.poll(); <span class="comment">// 队首顶点出队</span></span><br><span class="line">        res.add(vet);            <span class="comment">// 记录访问顶点</span></span><br><span class="line">        <span class="comment">// 遍历该顶点的所有邻接顶点</span></span><br><span class="line">        <span class="keyword">for</span> (Vertex adjVet : graph.adjList.get(vet)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (visited.contains(adjVet))</span><br><span class="line">                <span class="keyword">continue</span>;        <span class="comment">// 跳过已被访问过的顶点</span></span><br><span class="line">            que.offer(adjVet);   <span class="comment">// 只入队未访问的顶点</span></span><br><span class="line">            visited.add(adjVet); <span class="comment">// 标记该顶点已被访问</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回顶点遍历序列</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="tabs" id="placeholder"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#placeholder-1">1</button></li><li class="tab"><button type="button" data-href="#placeholder-2">2</button></li><li class="tab"><button type="button" data-href="#placeholder-3">3</button></li><li class="tab"><button type="button" data-href="#placeholder-4">4</button></li><li class="tab"><button type="button" data-href="#placeholder-5">5</button></li><li class="tab"><button type="button" data-href="#placeholder-6">6</button></li><li class="tab"><button type="button" data-href="#placeholder-7">7</button></li><li class="tab"><button type="button" data-href="#placeholder-8">8</button></li><li class="tab"><button type="button" data-href="#placeholder-9">9</button></li><li class="tab"><button type="button" data-href="#placeholder-10">10</button></li><li class="tab"><button type="button" data-href="#placeholder-11">11</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="placeholder-1"><p><img src="https://www.hello-algo.com/chapter_graph/graph_traversal.assets/graph_bfs_step1.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="placeholder-2"><p><img src="https://www.hello-algo.com/chapter_graph/graph_traversal.assets/graph_bfs_step2.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="placeholder-3"><p><img src="https://www.hello-algo.com/chapter_graph/graph_traversal.assets/graph_bfs_step3.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="placeholder-4"><p><img src="https://www.hello-algo.com/chapter_graph/graph_traversal.assets/graph_bfs_step4.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="placeholder-5"><p><img src="https://www.hello-algo.com/chapter_graph/graph_traversal.assets/graph_bfs_step5.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="placeholder-6"><p><img src="https://www.hello-algo.com/chapter_graph/graph_traversal.assets/graph_bfs_step6.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="placeholder-7"><p><img src="https://www.hello-algo.com/chapter_graph/graph_traversal.assets/graph_bfs_step7.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="placeholder-8"><p><img src="https://www.hello-algo.com/chapter_graph/graph_traversal.assets/graph_bfs_step8.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="placeholder-9"><p><img src="https://www.hello-algo.com/chapter_graph/graph_traversal.assets/graph_bfs_step9.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="placeholder-10"><p><img src="https://www.hello-algo.com/chapter_graph/graph_traversal.assets/graph_bfs_step10.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="placeholder-11"><p><img src="https://www.hello-algo.com/chapter_graph/graph_traversal.assets/graph_bfs_step11.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><blockquote><p>广度优先遍历的序列是否唯一? 答案是不唯一。广度优先遍历只要求按“由近及远”的顺序遍历，而多个相同距离的顶点的遍历顺序是允许被任意打乱的。顶点<code>1</code>、<code>3</code>的访问顺序可以交换。</p></blockquote><p><strong>（2）复杂度分析</strong></p><p>时间复杂度：所有顶点都会入队并出队一次，使用<code>O(|V|)</code>时间。在遍历邻接顶点的过程中，由于是无向图，因此所有边都会被访问<code>2</code>次，使用<code>O(2|E|)</code>时间。总体使用<code>O(|V| + |E|)</code>时间。</p><p>空间复杂度：列表<code>res</code>，哈希表<code>visited</code>，队列<code>queue</code>中的顶点数量最多为<code>|V|</code>，使用<code>O(|V|)</code>空间。</p><h4 id="深度优先遍历"><a href="#深度优先遍历" class="headerlink" title="深度优先遍历"></a>深度优先遍历</h4><p>深度优先遍历是一种优先走到底、无路可走再回头的遍历方式。如下图所示，从左上角顶点出发，访问当前顶点的某个邻接顶点，直到走到尽头时返回，再继续走到尽头并返回，以此类推，直至所有顶点遍历完成。</p><p><img src="https://www.hello-algo.com/chapter_graph/graph_traversal.assets/graph_dfs.png"></p><p><strong>（1）算法实现</strong></p><p>这种“走到尽头再返回”的算法范式通常基于递归来实现。与广度优先遍历类似，在深度优先遍历中也需要借助一个哈希表<code>visited</code>来记录已被访问的顶点，以避免重复访问顶点。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 深度优先遍历 DFS 辅助函数 */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(GraphAdjList graph, Set&lt;Vertex&gt; visited, List&lt;Vertex&gt; res, Vertex vet)</span> &#123;</span><br><span class="line">    res.add(vet);     <span class="comment">// 记录访问顶点</span></span><br><span class="line">    visited.add(vet); <span class="comment">// 标记该顶点已被访问</span></span><br><span class="line">    <span class="comment">// 遍历该顶点的所有邻接顶点</span></span><br><span class="line">    <span class="keyword">for</span> (Vertex adjVet : graph.adjList.get(vet)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (visited.contains(adjVet))</span><br><span class="line">            <span class="keyword">continue</span>; <span class="comment">// 跳过已被访问过的顶点</span></span><br><span class="line">        <span class="comment">// 递归访问邻接顶点</span></span><br><span class="line">        dfs(graph, visited, res, adjVet);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 深度优先遍历 DFS */</span></span><br><span class="line"><span class="comment">// 使用邻接表来表示图，以便获取指定顶点的所有邻接顶点</span></span><br><span class="line">List&lt;Vertex&gt; <span class="title function_">graphDFS</span><span class="params">(GraphAdjList graph, Vertex startVet)</span> &#123;</span><br><span class="line">    <span class="comment">// 顶点遍历序列</span></span><br><span class="line">    List&lt;Vertex&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 哈希表，用于记录已被访问过的顶点</span></span><br><span class="line">    Set&lt;Vertex&gt; visited = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    dfs(graph, visited, res, startVet);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>深度优先遍历的算法流程如上图所示。</p><ul><li>直虚线代表向下递推，表示开启了一个新的递归方法来访问新顶点。</li><li>曲虚线代表向上回溯，表示此递归方法已经返回，回溯到了开启此递归方法的位置。</li></ul><div class="tabs" id="placeholder"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#placeholder-1">1</button></li><li class="tab"><button type="button" data-href="#placeholder-2">2</button></li><li class="tab"><button type="button" data-href="#placeholder-3">3</button></li><li class="tab"><button type="button" data-href="#placeholder-4">4</button></li><li class="tab"><button type="button" data-href="#placeholder-5">5</button></li><li class="tab"><button type="button" data-href="#placeholder-6">6</button></li><li class="tab"><button type="button" data-href="#placeholder-7">7</button></li><li class="tab"><button type="button" data-href="#placeholder-8">8</button></li><li class="tab"><button type="button" data-href="#placeholder-9">9</button></li><li class="tab"><button type="button" data-href="#placeholder-10">10</button></li><li class="tab"><button type="button" data-href="#placeholder-11">11</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="placeholder-1"><p><img src="https://www.hello-algo.com/chapter_graph/graph_traversal.assets/graph_dfs_step1.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="placeholder-2"><p><img src="https://www.hello-algo.com/chapter_graph/graph_traversal.assets/graph_dfs_step2.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="placeholder-3"><p><img src="https://www.hello-algo.com/chapter_graph/graph_traversal.assets/graph_dfs_step3.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="placeholder-4"><p><img src="https://www.hello-algo.com/chapter_graph/graph_traversal.assets/graph_dfs_step4.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="placeholder-5"><p><img src="https://www.hello-algo.com/chapter_graph/graph_traversal.assets/graph_dfs_step5.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="placeholder-6"><p><img src="https://www.hello-algo.com/chapter_graph/graph_traversal.assets/graph_dfs_step6.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="placeholder-7"><p><img src="https://www.hello-algo.com/chapter_graph/graph_traversal.assets/graph_dfs_step7.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="placeholder-8"><p><img src="https://www.hello-algo.com/chapter_graph/graph_traversal.assets/graph_dfs_step8.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="placeholder-9"><p><img src="https://www.hello-algo.com/chapter_graph/graph_traversal.assets/graph_dfs_step9.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="placeholder-10"><p><img src="https://www.hello-algo.com/chapter_graph/graph_traversal.assets/graph_dfs_step10.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="placeholder-11"><p><img src="https://www.hello-algo.com/chapter_graph/graph_traversal.assets/graph_dfs_step11.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><blockquote><p>与广度优先遍历类似，深度优先遍历序列的顺序也不是唯一的。给定某顶点，先往哪个方向探索都可以，即邻接顶点的顺序可以任意打乱，都是深度优先遍历。（树的前序、中序、后序遍历）</p></blockquote><p><strong>（2）复杂度分析</strong></p><p>时间复杂度：所有顶点都会被访问<code>1</code>次，使用<code>O(|V|)</code>时间。所有边都会被访问<code>2</code>次，使用<code>O(2|E|)</code>时间。总体使用<code>O(|V| + |E|)</code>时间。</p><p>空间复杂度：列表<code>res</code>，哈希表<code>visited</code>顶点数量最多为<code>|V|</code>，递归深度最大为<code>|V|</code>，因此使用<code>O(|V|)</code>空间。</p><hr><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><blockquote><p>文件还未上传 Github</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法 Algorithm • 上</title>
      <link href="/posts/14dce348.html"/>
      <url>/posts/14dce348.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>本读书笔记节选自<code>krahets</code>大佬编写的<a href="https://www.hello-algo.com/">《Hello 算法》</a>。勉励自己开始系统的算法学习。</p></blockquote><hr><h2 id="1-初识算法"><a href="#1-初识算法" class="headerlink" title="1. 初识算法"></a>1. 初识算法</h2><p>当我们听到“算法”这个词时，很自然地会想到数学。然而实际上，许多算法并不涉及复杂数学，而是更多地依赖于基本逻辑，这些逻辑在我们的日常生活中处处可见。</p><p>（1）查阅字典</p><p>在字典里，每个汉字都对应一个拼音，而字典是按照拼音的英文字母顺序排列的。假设需要查找一个拼音首字母为<code>r</code>的字，通常会这样操作。</p><ul><li>翻开字典约一半的页数，查看该页首字母是什么，假设首字母为<code>m</code>。</li><li>由于在英文字母表中<code>r</code>位于<code>m</code>之后，所以排除字典前半部分，查找范围缩小到后半部分。</li><li>不断重复上面两个步骤，直至找到拼音首字母为<code>r</code>的页码为止。</li></ul><div class="tabs" id="placeholder"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#placeholder-1"><1></button></li><li class="tab"><button type="button" data-href="#placeholder-2"><2></button></li><li class="tab"><button type="button" data-href="#placeholder-3"><3></button></li><li class="tab"><button type="button" data-href="#placeholder-4"><4></button></li><li class="tab"><button type="button" data-href="#placeholder-5"><5></button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="placeholder-1"><p><img src="https://cdn.jsdelivr.net/gh/Hongda-OSU/PicGo/image/binary_search_dictionary_step1.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="placeholder-2"><p><img src="https://cdn.jsdelivr.net/gh/Hongda-OSU/PicGo/image/binary_search_dictionary_step2.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="placeholder-3"><p><img src="https://cdn.jsdelivr.net/gh/Hongda-OSU/PicGo/image/binary_search_dictionary_step3.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="placeholder-4"><p><img src="https://cdn.jsdelivr.net/gh/Hongda-OSU/PicGo/image/binary_search_dictionary_step4.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="placeholder-5"><p><img src="https://cdn.jsdelivr.net/gh/Hongda-OSU/PicGo/image/binary_search_dictionary_step5.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>查阅字典这个必备技能，实际上就是「二分查找」。从数据结构的角度，我们可以把字典视为一个<ins>已排序</ins>的「数组」。从算法的角度，我们可以将上述查字典的一系列操作看作是「二分查找」算法。</p><p>（2）整理扑克</p><p>打牌时，每局都需要整理扑克牌，使其从小到大排列，实现流程如下。</p><ul><li>将扑克牌划分为“有序”和“无序”两部分，并假设初始状态下最左<code>1</code>张扑克牌已经有序。</li><li>在无序部分抽出一张扑克牌，插入至有序部分的正确位置。此时最左<code>2</code>张扑克已经有序。</li><li>不断循环上面步骤，每一轮将一张扑克牌从无序部分插入至有序部分，直至所有扑克牌都有序。</li></ul><p><img src="https://www.hello-algo.com/chapter_introduction/algorithms_are_everywhere.assets/playing_cards_sorting.png"></p><p>上述整理扑克牌的方法本质上是「插入排序」算法，它在处理小型数据集时非常高效。许多编程语言的排序库函数中都存在插入排序的身影。</p><p>（3）货币找零</p><p>假设我们在超市购买了<code>69</code>元的商品，给收银员付了<code>100</code>元，则收银员需要给我们找<code>31</code>元。他会很自然地完成以下思考。</p><ul><li>可选项是比<code>31</code>元面值更小的货币，包括<code>1</code>，<code>5</code>，<code>10</code>，<code>20</code>元。</li><li>从可选项中拿出最大的<code>20</code>元，剩余<code>11</code> 元。</li><li>从剩余可选项中拿出最大的<code>10</code>元，剩余<code>1</code> 元。</li><li>从剩余可选项中拿出最大的<code>1</code>元，剩余<code>0</code> 元。</li><li>完成找零，方案为<code>20 + 10 + 1 = 31</code>元。</li></ul><p><img src="https://www.hello-algo.com/chapter_introduction/algorithms_are_everywhere.assets/greedy_change.png"></p><p>在以上步骤中，我们每一步都采取当前看来最好的选择（尽可能用大面额的货币），最终得到了可行的找零方案。从数据结构与算法的角度看，这种方法本质上是「贪心算法」。</p><p><img src="https://www.hello-algo.com/chapter_introduction/what_is_dsa.assets/relationship_between_data_structure_and_algorithm.png"></p><hr><h2 id="2-复杂度"><a href="#2-复杂度" class="headerlink" title="2. 复杂度"></a>2. 复杂度</h2><h3 id="2-1-迭代与递归"><a href="#2-1-迭代与递归" class="headerlink" title="2.1 迭代与递归"></a>2.1 迭代与递归</h3><p>在数据结构与算法中，重复执行某个任务是很常见的，通常会选用两种基本的程序结构。</p><p>「迭代 <code>iteration</code>」是一种重复执行某个任务的控制结构。在迭代中，程序会在满足一定的条件下重复执行某段代码，直到这个条件不再满足。（例如常见的<code>for</code>循环和<code>while</code>循环）</p><p>「递归 <code>recursion</code>」是一种算法策略，<ins>通过函数调用自身来解决问题</ins>。它主要包含两个阶段。</p><ul><li>递：程序不断深入地调用自身，通常传入更小或更简化的参数，直到达到“终止条件”。</li><li>归：触发“终止条件”后，程序从最深层的递归函数开始逐层返回，汇聚每一层的结果。</li></ul><p>下面代码中，只需调用函数<code>recur(n)</code>，就可以完成<code>1 + 2 + ... + n</code>的计算。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 递归 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">recur</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="comment">// 终止条件</span></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 递：递归调用</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> recur(n - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 归：返回结果</span></span><br><span class="line">    <span class="keyword">return</span> n + res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://www.hello-algo.com/chapter_computational_complexity/iteration_and_recursion.assets/recursion_sum.png"></p><p>从计算角度看，迭代与递归可以得到相同的结果，但代表了两种不同的思考和解决问题的方式。</p><ul><li>迭代：从最基础的步骤开始，然后不断重复或累加这些步骤，直到任务完成。</li><li>递归：将原问题分解为更小的子问题，这些子问题和原问题具有相同的形式。接下来将子问题继续分解为更小的子问题，直到基本情况时停止。</li></ul><hr><h3 id="2-2-时间复杂度"><a href="#2-2-时间复杂度" class="headerlink" title="2.2 时间复杂度"></a>2.2 时间复杂度</h3><p>「时间复杂度分析」统计的是算法运行时间随着数据量变大时的增长趋势。下面例子中，假设输入数据大小为<code>n</code>，给定三个算法函数<code>A</code>，<code>B</code>，<code>C</code>。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 算法 A 时间复杂度：常数阶</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">algorithm_A</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    System.out.println(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 算法 B 时间复杂度：线性阶</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">algorithm_B</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        System.out.println(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 算法 C 时间复杂度：常数阶</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">algorithm_C</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++) &#123;</span><br><span class="line">        System.out.println(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>算法<code>A</code>只有<code>1</code>个打印操作，算法运行时间不随着<code>n</code>增大而增长。此算法的时间复杂度为「常数阶」。</li><li>算法<code>B</code>中的打印操作要循环<code>n</code>次，算法运行时间随着<code>n</code>增大呈线性增长。此算法的时间复杂度被称为「线性阶」。</li><li>算法<code>C</code>中的打印操作要循环<code>1000000</code>次，虽然运行时间很长，但它与输入数据大小<code>n</code>无关。因此<code>C</code>的时间复杂度和<code>A</code>相同，仍为「常数阶」。</li></ul><p><img src="https://www.hello-algo.com/chapter_computational_complexity/time_complexity.assets/time_complexity_simple_example.png"></p><p>时间复杂度分析有哪些特点呢？</p><ul><li><p>时间复杂度能够有效评估算法效率。算法<code>B</code>的运行时间呈线性增长，在<code>n &gt; 1</code>时比算法<code>A</code>更慢，在<code>n &gt; 1000000</code>时比算法<code>C</code>更慢。而且只要输入数据大小<code>n</code>足够大，复杂度为“常数阶”的算法一定优于“线性阶”的算法。</p></li><li><p>时间复杂度也存在一定的局限性。算法<code>A</code>和<code>C</code>的时间复杂度相同，但实际运行时间差别很大。同样，算法<code>B</code>的时间复杂度比<code>C</code>高，但在输入数据大小<code>n</code>较小时，算法<code>B</code>明显优于<code>C</code>。</p></li></ul><h4 id="函数渐近上界"><a href="#函数渐近上界" class="headerlink" title="函数渐近上界"></a>函数渐近上界</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">algorithm</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;  <span class="comment">// +1</span></span><br><span class="line">    a = a + <span class="number">1</span>;  <span class="comment">// +1</span></span><br><span class="line">    a = a * <span class="number">2</span>;  <span class="comment">// +1</span></span><br><span class="line">    <span class="comment">// 循环 n 次</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123; <span class="comment">// +1（每轮都执行 i ++）</span></span><br><span class="line">        System.out.println(<span class="number">0</span>);    <span class="comment">// +1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设上面函数的计算操作数量是一个关于输入数据大小<code>n</code>的函数，记为<code>T(n)</code>，则其操作数量为<code>T(n) = 3 + 2n</code>。其中<code>T(n)</code>是一次函数，说明时间的增长趋势是线性的，时间复杂度是线性阶。</p><p>我们将线性阶的时间复杂度记为<code>O(n)</code>，这个数学符号称为「<code>Big-O Notation</code>」，用来表示函数<code>T(n)</code>的「渐近上界 <code>Asymptotic Upper Bound</code>」。</p><p><img src="https://www.hello-algo.com/chapter_computational_complexity/time_complexity.assets/asymptotic_upper_bound.png"></p><p>总的来说，计算渐近上界就是寻找一个函数<code>f(n)</code>，使得当<code>n</code>趋向于无穷大时，<code>T(n)</code>和<code>f(n)</code>处于相同的增长级别，仅相差一个常数项<code>c</code>的倍数。</p><h4 id="推算方法"><a href="#推算方法" class="headerlink" title="推算方法"></a>推算方法</h4><p>根据定义，确定<code>f(n)</code>之后，我们便可推算时间复杂度<code>O(f(n))</code>。那么如何确定渐近上界<code>f(n)</code>呢？总体分为两步，统计操作数量，判断渐近上界。</p><p><strong>第一步：统计操作数量</strong></p><p>针对代码，逐行从上到下计算即可。然而，由于上述<code>c·f(n)</code>中的常数项<code>c</code>可以取任意大小，因此操作数量 <code>T(n)</code>中的各种系数、常数项都可以被忽略。</p><ul><li>忽略常数项。因为它们都与<code>n</code>无关，所以对时间复杂度不产生影响。</li><li>省略所有系数。例如，循环<code>2n</code>次、<code>5n + 1</code>次等，都可以简化记为<code>n</code>次，因为<code>n</code>前面的系数对时间复杂度没有影响。</li><li>循环嵌套时使用乘法。总操作数量等于外层循环和内层循环操作数量之积，每一层循环依然可以分别套用上述两个技巧。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">algorithm</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;  <span class="comment">// +0（技巧 1）</span></span><br><span class="line">    a = a + n;  <span class="comment">// +0（技巧 1）</span></span><br><span class="line">    <span class="comment">// +n（技巧 2）</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span> * n + <span class="number">1</span>; i++) &#123;</span><br><span class="line">        System.out.println(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// +n*n（技巧 3）</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">2</span> * n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n + <span class="number">1</span>; j++) &#123;</span><br><span class="line">            System.out.println(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面展示了使用上述技巧前、后的统计结果。两者推出的时间复杂度相同，即为<code>O(n^2)</code>。</p><ul><li><code>T(n) = 2n(n + 1) + (5n + 1) + 2 = 2n^2 + 7n + 3</code>（完整统计）</li><li><code>T(n) = n^2 + n</code>（偷懒统计）</li></ul><p><strong>第二步：判断渐近上界</strong></p><p>时间复杂度由多项式<code>T(n)</code>中最高阶的项来决定。这是因为在<code>n</code>趋于无穷大时，最高阶的项将发挥主导作用，其他项的影响都可以被忽略。</p><table><thead><tr><th align="left">操作数量<code>T(n)</code></th><th align="left">时间复杂度<code>O(f(n))</code></th></tr></thead><tbody><tr><td align="left"><code>100000</code></td><td align="left"><code>O(1)</code></td></tr><tr><td align="left"><code>3n + 2</code></td><td align="left"><code>O(n)</code></td></tr><tr><td align="left"><code>2n^2 + 3n + 2</code></td><td align="left"><code>O(n^2)</code></td></tr><tr><td align="left"><code>n^3 + 100000n^2</code></td><td align="left"><code>O(n^3)</code></td></tr><tr><td align="left"><code>2^n + 100000n^100000</code></td><td align="left"><code>O(2^n)</code></td></tr></tbody></table><h4 id="常见类型"><a href="#常见类型" class="headerlink" title="常见类型"></a>常见类型</h4><p>设输入数据大小为<code>n</code>，常见的时间复杂度类型包括（按照从低到高的顺序排列）</p><p><img src="https://cdn.jsdelivr.net/gh/Hongda-OSU/PicGo/image/pic.png"></p><p><img src="https://www.hello-algo.com/chapter_computational_complexity/time_complexity.assets/time_complexity_common_types.png"></p><p><strong>常数阶<code>O(1)</code></strong></p><p>常数阶的操作数量与输入数据大小<code>n</code>无关，不会随着<code>n</code>的变化而变化。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 常数阶 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">constant</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">100000</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">        count++;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，尽管操作数量<code>size</code>很大，但由于其与数据大小<code>n</code>无关，因此时间复杂度仍为<code>O(1)</code>。</p><p><strong>线性阶<code>O(n)</code></strong></p><p>线性阶的操作数量相对于输入数据大小以线性级别增长。线性阶通常出现在单层循环中。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 线性阶 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">linear</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        count++;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>遍历数组和遍历链表等操作的时间复杂度均为<code>O(n)</code>，其中<code>n</code>为数组或链表的长度。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 线性阶（遍历数组） */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">arrayTraversal</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 循环次数与数组长度成正比</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，数据大小<code>n</code>需根据输入数据的类型来具体确定。比如在第一个示例中，变量<code>n</code>为输入数据大小。在第二个示例中，<code>n</code>为数组长度大小。</p><p><strong>平方阶<code>O(n^2)</code></strong></p><p>平方阶的操作数量相对于输入数据大小以平方级别增长。平方阶通常出现在嵌套循环中，外层循环和内层循环都为<code>O(n)</code>，因此总体为<code>O(n^2)</code>。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 平方阶 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">quadratic</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 循环次数与数组长度成平方关系</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://www.hello-algo.com/chapter_computational_complexity/time_complexity.assets/time_complexity_constant_linear_quadratic.png"></p><p>以「冒泡排序」为例，外层循环执行<code>n - 1</code>次，内层循环执行<code>n - 1, n - 2, ... , 2, 1</code>次，平均为<code>n / 2</code>次，因此时间复杂度为<code>O(n^2)</code>。</p><p>时间复杂度: <code>O((n - 1) · n / 2) = O(n^2)</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 平方阶（冒泡排序） */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">bubbleSort</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 计数器</span></span><br><span class="line">    <span class="comment">// 外循环：未排序区间为 [0, i]</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> nums.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="comment">// 内循环：将未排序区间 [0, i] 中的最大元素交换至该区间的最右端</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[j] &gt; nums[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="comment">// 交换 nums[j] 与 nums[j + 1]</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> nums[j];</span><br><span class="line">                nums[j] = nums[j + <span class="number">1</span>];</span><br><span class="line">                nums[j + <span class="number">1</span>] = tmp;</span><br><span class="line">                count += <span class="number">3</span>; <span class="comment">// 元素交换包含 3 个单元操作</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>指数阶<code>O(2^n)</code></strong></p><p>生物学中的“细胞分裂”是指数阶增长的典型例子。初始状态为<code>1</code>个细胞，分裂一轮后变为<code>2</code>个，分裂两轮后变为<code>4</code>个，以此类推，分裂<code>n</code>轮后有<code>2^n</code>个细胞。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 指数阶（循环实现） */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">exponential</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>, base = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 细胞每轮一分为二，形成数列 1, 2, 4, 8, ..., 2^(n-1)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; base; j++) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        base *= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// count = 1 + 2 + 4 + 8 + .. + 2^(n-1) = 2^n - 1</span></span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://www.hello-algo.com/chapter_computational_complexity/time_complexity.assets/time_complexity_exponential.png"></p><p>实际算法中，指数阶常出现于递归函数。例如以下代码，其递归地一分为二，经过<code>n</code>次分裂后停止。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 指数阶（递归实现） */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">expRecur</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> expRecur(n - <span class="number">1</span>) + expRecur(n - <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>指数阶增长非常迅速，在穷举法（暴力搜索、回溯等）中比较常见。对于数据规模较大的问题，指数阶是不可接受的，通常需要使用「动态规划」或「贪心」等算法来解决。</p><p><strong>对数阶<code>O(logn)</code></strong></p><p>与指数阶相反，对数阶反映了“每轮缩减到一半”的情况。设输入数据大小为<code>n</code>，由于每轮缩减到一半，因此循环次数是<code>log2(n)</code>，即<code>2^n</code>的反函数。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 对数阶（循环实现） */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">logarithmic</span><span class="params">(<span class="type">float</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        n = n / <span class="number">2</span>;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://www.hello-algo.com/chapter_computational_complexity/time_complexity.assets/time_complexity_logarithmic.png"></p><p>与指数阶类似，对数阶也常出现于递归函数。以下代码形成了一个高度为<code>log2(n)</code>的递归树。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 对数阶（递归实现） */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">logRecur</span><span class="params">(<span class="type">float</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> logRecur(n / <span class="number">2</span>) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对数阶常出现于基于「分治」的算法中，体现了“一分为多”和“化繁为简”的算法思想。它增长缓慢，是理想的时间复杂度，仅次于常数阶。</p><p><strong>线性对数阶<code>O(nlogn)</code></strong></p><p>线性对数阶常出现于嵌套循环中，两层循环的时间复杂度分别为<code>O(logn)</code>和<code>O(n)</code>。主流排序算法的时间复杂度通常为<code>O(nlogn)</code>，例如快速排序、归并排序、堆排序等。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 线性对数阶 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">linearLogRecur</span><span class="params">(<span class="type">float</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> linearLogRecur(n / <span class="number">2</span>) +</span><br><span class="line">            linearLogRecur(n / <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://www.hello-algo.com/chapter_computational_complexity/time_complexity.assets/time_complexity_logarithmic_linear.png"></p><p><strong>阶乘阶<code>O(n!)</code></strong></p><p>阶乘阶对应数学上的“全排列”问题。给定<code>n</code>个互不重复的元素，求其所有可能的排列方案，方案数量为<code>n! = n * (n - 1) * (n - 2) * ... * 2 * 1</code>。</p><p>阶乘通常使用递归实现。例如以下代码，第一层分裂出<code>n</code>个，第二层分裂出<code>n-1</code>个，以此类推，直至第<code>n</code>层时终止分裂。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 阶乘阶（递归实现） */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">factorialRecur</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 从 1 个分裂出 n 个</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        count += factorialRecur(n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://www.hello-algo.com/chapter_computational_complexity/time_complexity.assets/time_complexity_factorial.png"></p><p>请注意，因为<code>n! &gt; 2^n</code>，所以阶乘阶比指数阶增长地更快，在<code>n</code>较大时也是不可接受的。</p><h4 id="最差、最佳、平均"><a href="#最差、最佳、平均" class="headerlink" title="最差、最佳、平均"></a>最差、最佳、平均</h4><p>算法的时间效率往往不是固定的，而是与输入数据的分布有关。假设输入一个长度为<code>n</code>的数组<code>nums</code>，其中<code>nums</code>由从<code>1</code>至<code>n</code>的数字组成，但元素顺序是随机打乱的，任务目标是返回元素<code>1</code>的索引。可以得出以下结论。</p><ul><li>当末尾元素是<code>1</code>时，需要完整遍历数组，达到最差时间复杂度<code>O(n)</code>。</li><li>当首个数字为<code>1</code>时，无论数组多长都不需要继续遍历，达到最佳时间复杂度<code>Ω(1)</code>。</li></ul><p>「最差时间复杂度」对应函数渐近上界，使用<code>O</code>记号表示。相应地，「最佳时间复杂度」对应函数渐近下界，用<code>Ω</code>记号表示。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 查找数组 nums 中数字 1 所在索引 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">findOne</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="comment">// 当元素 1 在数组头部时，达到最佳时间复杂度 O(1)</span></span><br><span class="line">        <span class="comment">// 当元素 1 在数组尾部时，达到最差时间复杂度 O(n)</span></span><br><span class="line">        <span class="keyword">if</span> (nums[i] == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然而，实际中很少使用「最佳时间复杂度」，因为通常只有在很小概率下才能达到，并且可能会带来一定的误导性。<ins>因此「最差时间复杂度」更为实用，因为它给出了一个效率安全值</ins>。</p><p>从上面代码可以看出，最差或最佳时间复杂度只出现于“特殊的数据分布”，这些情况的出现概率可能很小。相比之下，「平均时间复杂度」可以体现算法在随机输入数据下的运行效率，用<code>Θ</code>记号来表示。</p><ul><li>上面代码中，输入数组是被打乱的，元素<code>1</code>出现在任意索引的概率都是相等的，那么算法的平均循环次数则是数组长度的一半<code>n / 2</code>，平均时间复杂度为<code>Θ(n / 2) = Θ(n)</code>。</li></ul><p>值得说明的是，由于计算平均时间复杂度往往比较困难，因为很难分析出在数据分布下的整体数学期望。所以，<ins>我们通常使用最差时间复杂度作为算法效率的评判标准</ins>。</p><hr><h3 id="2-3-空间复杂度"><a href="#2-3-空间复杂度" class="headerlink" title="2.3 空间复杂度"></a>2.3 空间复杂度</h3><p>「空间复杂度」用于衡量算法占用内存空间随着数据量变大时的增长趋势。这个概念与时间复杂度非常类似，只需将“运行时间”替换为“占用内存空间”。</p><p><img src="https://www.hello-algo.com/chapter_computational_complexity/space_complexity.assets/space_types.png"></p><h4 id="推算方法-1"><a href="#推算方法-1" class="headerlink" title="推算方法"></a>推算方法</h4><p>空间复杂度的推算方法与时间复杂度大致相同，只需将统计对象从“操作数量”转为“使用空间大小”。</p><p>而与时间复杂度不同的是，<ins>通常只关注最差空间复杂度</ins>。因为内存空间是一项硬性要求，必须确保在所有输入数据下都有足够的内存空间预留。</p><p>下面代码中，最差空间复杂度中的“最差”有两层含义。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">algorithm</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;                   <span class="comment">// O(1)</span></span><br><span class="line">    <span class="type">int</span>[] b = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10000</span>];    <span class="comment">// O(1)</span></span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">10</span>)</span><br><span class="line">        <span class="type">int</span>[] nums = <span class="keyword">new</span> <span class="title class_">int</span>[n]; <span class="comment">// O(n)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>以最差输入数据为准。当<code>n &lt; 10</code>时，空间复杂度为<code>O(1)</code>。当<code>n &gt; 10</code>时，初始化的数组<code>nums</code>占用<code>O(n)</code>空间，因此最差空间复杂度为<code>O(n)</code>。</li><li>以算法运行中的峰值内存为准。程序在执行最后一行之前，占用<code>O(1)</code>空间。当初始化数组<code>nums</code>时，程序占用<code>O(n)</code>空间；因此最差空间复杂度为<code>O(n)</code>。</li></ul><p>在递归函数中，则需要注意统计栈帧空间。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">function</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 执行某些操作</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 循环 O(1) */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">loop</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        function();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 递归 O(n) */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">recur</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">return</span> recur(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>函数<code>loop()</code>在循环中调用了<code>n</code>次<code>function()</code>，每轮中<code>function()</code>都返回并释放了栈帧空间，因此空间复杂度仍为<code>O(1)</code>。</li><li>递归函数<code>recur()</code>在运行过程中会同时存在<code>n</code>个未返回的<code>recur()</code>，从而占用<code>O(n)</code>的栈帧空间。</li></ul><h4 id="常见类型-1"><a href="#常见类型-1" class="headerlink" title="常见类型"></a>常见类型</h4><p>设输入数据大小为<code>n</code>，下图展示了常见的空间复杂度类型（从低到高排列）。</p><p><img src="https://cdn.jsdelivr.net/gh/Hongda-OSU/PicGo/image/pic2.png"></p><p><img src="https://www.hello-algo.com/chapter_computational_complexity/space_complexity.assets/space_complexity_common_types.png"></p><p><strong>常数阶<code>O(1)</code></strong></p><p>常数阶常见于数量与输入数据大小<code>n</code>无关的常量、变量、对象。</p><p>注意，在循环中初始化变量或调用函数而占用的内存，在进入下一循环后就会被释放，因此不会累积占用空间，空间复杂度仍为<code>O(1)</code>。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 函数 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">function</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 执行某些操作</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 常数阶 */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">constant</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="comment">// 常量、变量、对象占用 O(1) 空间</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span>[] nums = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10000</span>];</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 循环中的变量占用 O(1) 空间</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 循环中的函数占用 O(1) 空间</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        function();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>线性阶<code>O(n)</code></strong></p><p>线性阶常见于元素数量与<code>n</code>成正比的数组、链表、栈、队列等。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 线性阶 */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">linear</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="comment">// 长度为 n 的数组占用 O(n) 空间</span></span><br><span class="line">    <span class="type">int</span>[] nums = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    <span class="comment">// 长度为 n 的列表占用 O(n) 空间</span></span><br><span class="line">    List&lt;ListNode&gt; nodes = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        nodes.add(<span class="keyword">new</span> <span class="title class_">ListNode</span>(i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 长度为 n 的哈希表占用 O(n) 空间</span></span><br><span class="line">    Map&lt;Integer, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        map.put(i, String.valueOf(i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如下图所示，下面代码的递归深度为<code>n</code>，即同时存在<code>n</code>个未返回的<code>linear_recur()</code>函数，使用<code>O(n)</code>大小的栈帧空间。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 线性阶（递归实现） */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">linearRecur</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;递归 n = &quot;</span> + n);</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    linearRecur(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://www.hello-algo.com/chapter_computational_complexity/space_complexity.assets/space_complexity_recursive_linear.png"></p><p><strong>平方阶<code>O(n^2)</code></strong></p><p>平方阶常见于矩阵和图，元素数量与<code>n</code>成平方关系。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 平方阶 */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">quadratic</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="comment">// 矩阵占用 O(n^2) 空间</span></span><br><span class="line">    <span class="type">int</span>[][] numMatrix = <span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line">    <span class="comment">// 二维列表占用 O(n^2) 空间</span></span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; numList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        List&lt;Integer&gt; tmp = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            tmp.add(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        numList.add(tmp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如下图所示，下面代码的递归深度为<code>n</code>，每个递归函数中都初始化了一个数组，长度分别为<code>n, n - 1, n - 2, ..., 2, 1</code>，平均长度为<code>n / 2</code>，因此总体占用<code>O(n^2)</code>空间。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 平方阶（递归实现） */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">quadraticRecur</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 数组 nums 长度为 n, n-1, ..., 2, 1</span></span><br><span class="line">    <span class="type">int</span>[] nums = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    System.out.println(<span class="string">&quot;递归 n = &quot;</span> + n + <span class="string">&quot; 中的 nums 长度 = &quot;</span> + nums.length);</span><br><span class="line">    <span class="keyword">return</span> quadraticRecur(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://www.hello-algo.com/chapter_computational_complexity/space_complexity.assets/space_complexity_recursive_quadratic.png"></p><p><strong>指数阶<code>O(2^n)</code></strong></p><p>指数阶常见于二叉树。下图，高度为<code>n</code>的“满二叉树”的节点数量为<code>2^n - 1</code>，占用<code>O(2^n)</code>空间。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 指数阶（建立满二叉树） */</span></span><br><span class="line">TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(<span class="number">0</span>);</span><br><span class="line">    root.left = buildTree(n - <span class="number">1</span>);</span><br><span class="line">    root.right = buildTree(n - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://www.hello-algo.com/chapter_computational_complexity/space_complexity.assets/space_complexity_exponential.png"></p><p><strong>对数阶<code>O(logn)</code></strong></p><p>对数阶常见于分治算法。例如归并排序，输入长度为<code>n</code>的数组，每轮递归将数组从中点划分为两半，形成高度为<code>logn</code>的递归树，使用<code>O(logn)</code>栈帧空间。</p><h4 id="权衡时间与空间"><a href="#权衡时间与空间" class="headerlink" title="权衡时间与空间"></a>权衡时间与空间</h4><p>理想情况下，我们希望算法的时间复杂度和空间复杂度都能达到最优。然而在实际情况中，同时优化时间复杂度和空间复杂度通常是非常困难的。</p><p><strong>降低时间复杂度通常需要以提升空间复杂度为代价，反之亦然。</strong>在大多数情况下，时间比空间更宝贵，因此“以空间换时间”通常是更常用的策略。当然，在数据量很大的情况下，控制空间复杂度也是非常重要的。</p><hr><h2 id="3-数据结构"><a href="#3-数据结构" class="headerlink" title="3. 数据结构"></a>3. 数据结构</h2><p>常见的数据结构包括数组（<code>Array</code>）、链表（<code>List</code>）、栈（<code>Stack</code>）、队列（<code>Queue</code>）、哈希表（<code>Hash Table</code>）、树（<code>Tree</code>）、堆（<code>Heap</code>）、图（<code>Graph</code>），它们可以从“逻辑结构”和“物理结构”两个维度进行分类。</p><h3 id="3-1-数据结构分类"><a href="#3-1-数据结构分类" class="headerlink" title="3.1 数据结构分类"></a>3.1 数据结构分类</h3><p><strong>逻辑结构揭示了数据元素之间的逻辑关系</strong>。在数组和链表中，数据按照顺序依次排列，体现了数据之间的线性关系。而在树中，数据从顶部向下按层次排列，表现出祖先与后代之间的派生关系。图则由节点和边构成，反映了复杂的网络关系。</p><p>如下图所示，逻辑结构可被分为“线性”和“非线性”两大类。线性结构比较直观，指数据在逻辑关系上呈线性排列。非线性结构则相反，呈非线性排列。</p><ul><li>线性数据结构：数组、链表、栈、队列、哈希表。</li><li>非线性数据结构：树、堆、图、哈希表。</li></ul><p><img src="https://www.hello-algo.com/chapter_data_structure/classification_of_data_structure.assets/classification_logic_structure.png"></p><p>非线性数据结构可以进一步被划分为树形结构和网状结构。</p><ul><li>线性结构：数组、链表、队列、栈、哈希表，元素之间是一对一的顺序关系。</li><li>树形结构：树、堆、哈希表，元素之间是一对多的关系。</li><li>网状结构：图，元素之间是多对多的关系。</li></ul><p><strong>物理结构反映了数据在计算机内存中的存储方式</strong>。在算法运行过程中，数据都存储在内存中，系统通过内存地址来访问目标位置的数据。如下图所示，存储方式可分为连续空间存储和离散空间存储。</p><p><img src="https://www.hello-algo.com/chapter_data_structure/classification_of_data_structure.assets/classification_phisical_structure.png"></p><hr><h3 id="3-2-基本数据类型"><a href="#3-2-基本数据类型" class="headerlink" title="3.2 基本数据类型"></a>3.2 基本数据类型</h3><p>基本数据类型是<code>CPU</code>可以直接进行运算的类型，在算法中直接被使用。</p><ul><li>整数类型<code>byte</code>,<code>short</code>,<code>int</code>,<code>long</code>。</li><li>浮点数类型<code>float</code>,<code>double</code>，用于表示小数。</li><li>字符类型<code>char</code>，用于表示各种语言的字母、标点符号、甚至表情符号等。</li><li>布尔类型<code>bool</code>，用于表示“是”与“否”判断。</li></ul><p>基本数据类型以二进制的形式存储在计算机中。一个二进制位即为<code>1</code>比特。在绝大多数现代系统中，<code>1</code>字节（<code>byte</code>）由<code>8</code>比特（<code>bits</code>）组成。</p><p><img src="https://cdn.jsdelivr.net/gh/Hongda-OSU/PicGo/image/pic4.png"></p><hr><h2 id="4-数组与链表"><a href="#4-数组与链表" class="headerlink" title="4. 数组与链表"></a>4. 数组与链表</h2><h3 id="4-1-数组"><a href="#4-1-数组" class="headerlink" title="4.1 数组"></a>4.1 数组</h3><p>「数组 <code>array</code>」是一种线性数据结构，其将相同类型元素存储在连续的内存空间中。而元素在数组中的位置称为该元素的「索引 <code>index</code>」。</p><p><img src="https://www.hello-algo.com/chapter_array_and_linkedlist/array.assets/array_definition.png"></p><h4 id="数组常用操作"><a href="#数组常用操作" class="headerlink" title="数组常用操作"></a>数组常用操作</h4><p>（1）初始化数组</p><p>可以根据需求选用数组的两种初始化方式，无初始值、给定初始值。在未指定初始值的情况下，大多数编程语言会将数组元素初始化为<code>0</code>。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">array.java</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始化数组 */</span></span><br><span class="line"><span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">5</span>]; <span class="comment">// &#123; 0, 0, 0, 0, 0 &#125;</span></span><br><span class="line"><span class="type">int</span>[] nums = &#123; <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">4</span> &#125;;</span><br></pre></td></tr></table></figure><p>（2）访问元素</p><p>数组元素被存储在连续的内存空间中，这意味着计算数组元素的内存地址非常容易。给定数组内存地址（即首元素内存地址）和某个元素的索引，可以使用以下公式计算得到该元素的内存地址，从而直接访问此元素。</p><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line"># 元素内存地址 = 数组内存地址 + 元素长度 * 元素索引</span><br><span class="line">elementAddr = firtstElementAddr + elementLength * elementIndex</span><br></pre></td></tr></table></figure><p><img src="https://www.hello-algo.com/chapter_array_and_linkedlist/array.assets/array_memory_location_calculation.png"></p><p>在数组中访问元素是非常高效的，我们可以在<code>O(1)</code>时间内随机访问数组中的任意一个元素。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 随机访问元素 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">randomAccess</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="comment">// 在区间 [0, nums.length) 中随机抽取一个数字</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">randomIndex</span> <span class="operator">=</span> ThreadLocalRandom.current().nextInt(<span class="number">0</span>, nums.length);</span><br><span class="line">    <span class="comment">// 获取并返回随机元素</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">randomNum</span> <span class="operator">=</span> nums[randomIndex];</span><br><span class="line">    <span class="keyword">return</span> randomNum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（3）插入元素</p><p>数组元素在内存中是“紧挨着的”，它们之间没有空间再存放任何数据。如下图所示，如果想要在数组中间插入一个元素，则需要将该元素之后的所有元素都向后移动一位，之后再把元素赋值给该索引。</p><p><img src="https://www.hello-algo.com/chapter_array_and_linkedlist/array.assets/array_insert_element.png"></p><p>注意，由于数组的长度是固定的，因此插入一个元素必定会导致数组尾部元素的“丢失”。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 在数组的索引 index 处插入元素 num */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> num, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="comment">// 把索引 index 以及之后的所有元素向后移动一位</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> nums.length - <span class="number">1</span>; i &gt; index; i--) &#123;</span><br><span class="line">        nums[i] = nums[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将 num 赋给 index 处元素</span></span><br><span class="line">    nums[index] = num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（4）删除元素</p><p>同理，如下图所示，若想要删除索引<code>i</code>处的元素，则需要把索引<code>i</code>之后的元素都向前移动一位。</p><p><img src="https://www.hello-algo.com/chapter_array_and_linkedlist/array.assets/array_remove_element.png"></p><p>注意，删除元素完成后，原先末尾的元素变得“无意义”了，所以我们无须特意去修改它。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 删除索引 index 处元素 */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="comment">// 把索引 index 之后的所有元素向前移动一位</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index; i &lt; nums.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        nums[i] = nums[i + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总的来看，数组的插入与删除操作有以下缺点。</p><ul><li>时间复杂度高：数组的插入和删除的平均时间复杂度均为<code>O(n)</code>，其中<code>n</code>为数组长度。</li><li>丢失元素：由于数组的长度不可变，因此在插入元素后，超出数组长度范围的元素会丢失。</li><li>内存浪费：我们可以初始化一个比较长的数组，只用前面一部分，这样在插入数据时，丢失的末尾元素都是“无意义”的，但这样做也会造成部分内存空间的浪费。</li></ul><p>（5）遍历数组</p><p>大多数编程语言中，我们既可以通过索引遍历数组，也可以直接遍历获取数组中的每个元素。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 遍历数组 */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 通过索引遍历数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 直接遍历数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（6）查找元素</p><p>在数组中查找指定元素需要遍历数组，每轮判断元素值是否匹配，若匹配则输出对应索引。因为数组是线性数据结构，所以上述查找操作被称为“线性查找”。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 在数组中查找指定元素 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] == target)</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（7）扩容数组</p><p>大多数编程语言中，<strong>数组的长度是不可变的</strong>。如果希望扩容数组，则需重新建立一个更大的数组，然后把原数组元素依次拷贝到新数组。这是一个<code>O(n)</code>的操作，在数组很大的情况下是非常耗时。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 扩展数组长度 */</span></span><br><span class="line"><span class="type">int</span>[] extend(<span class="type">int</span>[] nums, <span class="type">int</span> enlarge) &#123;</span><br><span class="line">    <span class="comment">// 初始化一个扩展长度后的数组</span></span><br><span class="line">    <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length + enlarge];</span><br><span class="line">    <span class="comment">// 将原数组中的所有元素复制到新数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        res[i] = nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回扩展后的新数组</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="4-2-链表"><a href="#4-2-链表" class="headerlink" title="4.2 链表"></a>4.2 链表</h3><p>「链表 <code>linked list</code>」是一种线性数据结构，其中的每个元素都是一个节点对象，各个节点通过“引用”相连接。引用记录了下一个节点的内存地址，通过它可以从当前节点访问到下一个节点。</p><p>链表的设计使得各个节点可以被分散存储在内存各处，它们的内存地址是无须连续的。链表的组成单位是「节点 <code>node</code>」对象。每个节点都包含两项数据，节点的“值”和指向下一节点的“引用”。</p><p><img src="https://www.hello-algo.com/chapter_array_and_linkedlist/linked_list.assets/linkedlist_definition.png"></p><h4 id="链表常用操作"><a href="#链表常用操作" class="headerlink" title="链表常用操作"></a>链表常用操作</h4><p>（1）初始化链表</p><p>建立链表分为两步，第一步是初始化各个节点对象，第二步是构建引用指向关系。初始化完成后，就可以从链表的头节点出发，通过引用指向<code>next</code>依次访问所有节点。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 初始化链表 1 -&gt; 3 -&gt; 2 -&gt; 5 -&gt; 4 */</span></span><br><span class="line"><span class="comment">// 初始化各个节点</span></span><br><span class="line"><span class="type">ListNode</span> <span class="variable">n0</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">1</span>);</span><br><span class="line"><span class="type">ListNode</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">3</span>);</span><br><span class="line"><span class="type">ListNode</span> <span class="variable">n2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">2</span>);</span><br><span class="line"><span class="type">ListNode</span> <span class="variable">n3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">5</span>);</span><br><span class="line"><span class="type">ListNode</span> <span class="variable">n4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">4</span>);</span><br><span class="line"><span class="comment">// 构建引用指向</span></span><br><span class="line">n0.next = n1;</span><br><span class="line">n1.next = n2;</span><br><span class="line">n2.next = n3;</span><br><span class="line">n3.next = n4;</span><br></pre></td></tr></table></figure><p>数组整体是一个变量，比如数组<code>nums</code>包含元素<code>nums[0]</code>，<code>nums[1]</code>等，而链表是由多个独立的节点对象组成的。我们通常将头节点当作链表的代称，比如以上代码中的链表可被记做链表<code>n0</code>。</p><p>（2）插入节点</p><p>在链表中插入节点非常容易。如下图所示，假设我们想在相邻的两个节点<code>n0</code>，<code>n1</code>之间插入一个新节点<code>P</code>，则只需要改变两个节点引用（指针）即可，时间复杂度为<code>O(1)</code>。</p><p>相比之下，在数组中插入元素的时间复杂度为<code>O(n)</code>，在大数据量下的效率较低。</p><p><img src="https://www.hello-algo.com/chapter_array_and_linkedlist/linked_list.assets/linkedlist_insert_node.png"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 在链表的节点 n0 之后插入节点 P */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(ListNode n0, ListNode P)</span> &#123;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">n1</span> <span class="operator">=</span> n0.next;</span><br><span class="line">    P.next = n1;</span><br><span class="line">    n0.next = P;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（3）删除节点</p><p>如下图所示，在链表中删除节点也非常方便，只需改变一个节点的引用（指针）即可。</p><p>虽然在删除操作完成后节点<code>P</code>仍然指向<code>n1</code>，但实际上遍历此链表已经无法访问到<code>P</code>，这意味着<code>P</code>已经不再属于该链表了。</p><p><img src="https://www.hello-algo.com/chapter_array_and_linkedlist/linked_list.assets/linkedlist_remove_node.png"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 删除链表的节点 n0 之后的首个节点 */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(ListNode n0)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n0.next == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// n0 -&gt; P -&gt; n1</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">P</span> <span class="operator">=</span> n0.next;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">n1</span> <span class="operator">=</span> P.next;</span><br><span class="line">    n0.next = n1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（4）访问节点</p><p>链表访问节点的效率较低。可以在<code>O(1)</code>时间下访问数组中的任意元素，链表则不行。程序需要从头节点出发，逐个向后遍历，直至找到目标节点。访问链表的第<code>n</code>个节点需要循环<code>n - 1</code>轮，时间复杂度为<code>O(n)</code>。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 访问链表中索引为 index 的节点 */</span></span><br><span class="line">ListNode <span class="title function_">access</span><span class="params">(ListNode head, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; index; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        head = head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（5）查找节点</p><p>遍历链表，查找链表内值为<code>target</code>的节点，输出节点在链表中的索引。此过程也属于线性查找。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 在链表中查找值为 target 的首个节点 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">find</span><span class="params">(ListNode head, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (head != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (head.val == target)</span><br><span class="line">            <span class="keyword">return</span> index;</span><br><span class="line">        head = head.next;</span><br><span class="line">        index++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="数组-VS-链表"><a href="#数组-VS-链表" class="headerlink" title="数组 VS 链表"></a>数组 VS 链表</h4><p>下面是数组和链表的各项特点与操作效率。由于它们采用两种相反的存储策略，因此各种性质和操作效率也呈现对立的特点。</p><table><thead><tr><th align="left"></th><th align="left">数组</th><th align="left">链表</th></tr></thead><tbody><tr><td align="left">存储方式</td><td align="left">连续内存空间</td><td align="left">离散内存空间</td></tr><tr><td align="left">缓存局部性</td><td align="left">友好</td><td align="left">不友好</td></tr><tr><td align="left">容量扩展</td><td align="left">长度不可变</td><td align="left">可灵活扩展</td></tr><tr><td align="left">内存效率</td><td align="left">占用内存少、浪费部分空间</td><td align="left">占用内存多</td></tr><tr><td align="left">访问元素</td><td align="left"><code>O(1)</code></td><td align="left"><code>O(n)</code></td></tr><tr><td align="left">添加元素</td><td align="left"><code>O(n)</code></td><td align="left"><code>O(1)</code></td></tr><tr><td align="left">删除元素</td><td align="left"><code>O(n)</code></td><td align="left"><code>O(1)</code></td></tr></tbody></table><h4 id="常见链表类型"><a href="#常见链表类型" class="headerlink" title="常见链表类型"></a>常见链表类型</h4><ul><li><strong>单向链表</strong>：即普通链表。单向链表的节点包含值和指向下一节点的引用两项数据。我们将首个节点称为头节点，将最后一个节点成为尾节点，尾节点指向空<code>Node</code>。</li><li><strong>环形链表</strong>：如果我们令单向链表的尾节点指向头节点（即首尾相接），则得到一个环形链表。在环形链表中，任意节点都可以视作头节点。</li><li><strong>双向链表</strong>：与单向链表相比，双向链表记录了两个方向的引用。双向链表的节点定义同时包含指向后继节点（下一个节点）和前驱节点（上一个节点）的引用（指针）。相较于单向链表，双向链表更具灵活性，可以朝两个方向遍历链表，但相应地也需要占用更多的内存空间。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 双向链表节点类 */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;        <span class="comment">// 节点值</span></span><br><span class="line">    ListNode next;  <span class="comment">// 指向后继节点的引用</span></span><br><span class="line">    ListNode prev;  <span class="comment">// 指向前驱节点的引用</span></span><br><span class="line">    ListNode(<span class="type">int</span> x) &#123; val = x; &#125;  <span class="comment">// 构造函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://www.hello-algo.com/chapter_array_and_linkedlist/linked_list.assets/linkedlist_common_types.png"></p><hr><h3 id="4-3-列表"><a href="#4-3-列表" class="headerlink" title="4.3 列表"></a>4.3 列表</h3><p>「动态数组 <code>dynamic array</code>」是长度可变的数组，也常被称为「列表 <code>list</code>」。它基于数组实现，继承了数组的优点，并且可以在程序运行过程中动态扩容。可以在列表中自由地添加元素，而无须担心超过容量限制。</p><h4 id="列表常用操作"><a href="#列表常用操作" class="headerlink" title="列表常用操作"></a>列表常用操作</h4><p>（1）初始化列表</p><p>可以使用“无初始值”和“有初始值”这两种初始化方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 初始化列表 */</span></span><br><span class="line"><span class="comment">// 无初始值</span></span><br><span class="line">List&lt;Integer&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="comment">// 有初始值（注意数组的元素类型需为 int[] 的包装类 Integer[]）</span></span><br><span class="line">Integer[] numbers = <span class="keyword">new</span> <span class="title class_">Integer</span>[] &#123; <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">4</span> &#125;;</span><br><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(numbers));</span><br></pre></td></tr></table></figure><p>（2）访问元素</p><p>列表本质上是数组，因此可以在<code>O(1)</code>时间内访问和更新元素，效率很高。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 访问元素 */</span></span><br><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> list.get(<span class="number">1</span>);  <span class="comment">// 访问索引 1 处的元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 更新元素 */</span></span><br><span class="line">list.set(<span class="number">1</span>, <span class="number">0</span>);  <span class="comment">// 将索引 1 处的元素更新为 0</span></span><br></pre></td></tr></table></figure><p>（3）插入与删除元素</p><p>相较于数组，列表可以自由地添加与删除元素。在列表尾部添加元素的时间复杂度为<code>O(1)</code>，但插入和删除元素的效率仍与数组相同，时间复杂度为<code>O(n)</code>。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 清空列表 */</span></span><br><span class="line">list.clear();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 尾部添加元素 */</span></span><br><span class="line">list.add(<span class="number">1</span>);</span><br><span class="line">list.add(<span class="number">3</span>);</span><br><span class="line">list.add(<span class="number">2</span>);</span><br><span class="line">list.add(<span class="number">5</span>);</span><br><span class="line">list.add(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 中间插入元素 */</span></span><br><span class="line">list.add(<span class="number">3</span>, <span class="number">6</span>);  <span class="comment">// 在索引 3 处插入数字 6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 删除元素 */</span></span><br><span class="line">list.remove(<span class="number">3</span>);  <span class="comment">// 删除索引 3 处的元素</span></span><br></pre></td></tr></table></figure><p>（4）遍历列表</p><p>与数组一样，列表可以根据索引遍历，也可以直接遍历各元素。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 通过索引遍历列表 */</span></span><br><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">    count++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 直接遍历列表元素 */</span></span><br><span class="line">count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> n : list) &#123;</span><br><span class="line">    count++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（5）拼接列表</p><p>给定一个新列表<code>list1</code>，我们可以将该列表拼接到原列表的尾部。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 拼接两个列表 */</span></span><br><span class="line">List&lt;Integer&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(<span class="keyword">new</span> <span class="title class_">Integer</span>[] &#123; <span class="number">6</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">10</span>, <span class="number">9</span> &#125;));</span><br><span class="line">list.addAll(list1);  <span class="comment">// 将列表 list1 拼接到 list 之后</span></span><br></pre></td></tr></table></figure><p>（6）排序列表</p><p>完成列表排序后，便可以使用在数组类算法题中经常考察的“二分查找”和“双指针”算法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 排序列表 */</span></span><br><span class="line">Collections.sort(list);  <span class="comment">// 排序后，列表元素从小到大排列</span></span><br></pre></td></tr></table></figure><hr><h2 id="5-栈与队列"><a href="#5-栈与队列" class="headerlink" title="5. 栈与队列"></a>5. 栈与队列</h2><h3 id="5-1-栈"><a href="#5-1-栈" class="headerlink" title="5.1 栈"></a>5.1 栈</h3><p>「栈 <code>stack</code>」是一种遵循先入后出<code>First In，Last Out</code>的逻辑的线性数据结构。我们可以将栈类比为桌面上的一摞盘子，<ins>如果需要拿出底部的盘子，则需要先将上面的盘子依次取出</ins>。</p><p><img src="https://www.hello-algo.com/chapter_stack_and_queue/stack.assets/stack_operations.png"></p><h4 id="栈常用操作"><a href="#栈常用操作" class="headerlink" title="栈常用操作"></a>栈常用操作</h4><p>栈的常用操作如下表所示，具体的方法名需要根据所使用的编程语言来确定。我们以常见的<code>push()</code>、<code>pop()</code>、<code>peek()</code>命名为例。</p><table><thead><tr><th align="left">方法</th><th align="left">描述</th><th align="left">时间复杂度</th></tr></thead><tbody><tr><td align="left"><code>push()</code></td><td align="left">元素入栈（添加至栈顶）</td><td align="left"><code>O(1)</code></td></tr><tr><td align="left"><code>pop()</code></td><td align="left">栈顶元素出栈</td><td align="left"><code>O(1)</code></td></tr><tr><td align="left"><code>peek()</code></td><td align="left">访问栈顶元素</td><td align="left"><code>O(1)</code></td></tr></tbody></table><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 初始化栈 */</span></span><br><span class="line">Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 元素入栈 */</span></span><br><span class="line">stack.push(<span class="number">1</span>);</span><br><span class="line">stack.push(<span class="number">3</span>);</span><br><span class="line">stack.push(<span class="number">2</span>);</span><br><span class="line">stack.push(<span class="number">5</span>);</span><br><span class="line">stack.push(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 访问栈顶元素 */</span></span><br><span class="line"><span class="type">int</span> <span class="variable">peek</span> <span class="operator">=</span> stack.peek();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 元素出栈 */</span></span><br><span class="line"><span class="type">int</span> <span class="variable">pop</span> <span class="operator">=</span> stack.pop();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取栈的长度 */</span></span><br><span class="line"><span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> stack.size();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 判断是否为空 */</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">isEmpty</span> <span class="operator">=</span> stack.isEmpty();</span><br></pre></td></tr></table></figure><h4 id="栈简单实现"><a href="#栈简单实现" class="headerlink" title="栈简单实现"></a>栈简单实现</h4><p>栈遵循先入后出的原则，因此只能在栈顶添加或删除元素。我们可以使用链表来实现栈。将链表的头节点视为栈顶，尾节点视为栈底。对于入栈操作，只需将元素插入链表头部，这种节点插入方法被称为“头插法”。而对于出栈操作，只需将头节点从链表中删除即可。</p><div class="tabs" id="placeholder"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#placeholder-1">LinkedListStack</button></li><li class="tab"><button type="button" data-href="#placeholder-2">push()</button></li><li class="tab"><button type="button" data-href="#placeholder-3">pop()</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="placeholder-1"><p><img src="https://www.hello-algo.com/chapter_stack_and_queue/stack.assets/linkedlist_stack.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="placeholder-2"><p><img src="https://www.hello-algo.com/chapter_stack_and_queue/stack.assets/linkedlist_stack_push.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="placeholder-3"><p><img src="https://www.hello-algo.com/chapter_stack_and_queue/stack.assets/linkedlist_stack_pop.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 基于链表实现的栈 */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LinkedListStack</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> ListNode stackPeek; <span class="comment">// 将头节点作为栈顶</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">stkSize</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 栈的长度</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LinkedListStack</span><span class="params">()</span> &#123;</span><br><span class="line">        stackPeek = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取栈的长度 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> stkSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 判断栈是否为空 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> size() == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 入栈 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(num);</span><br><span class="line">        node.next = stackPeek;</span><br><span class="line">        stackPeek = node;</span><br><span class="line">        stkSize++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 出栈 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> peek();</span><br><span class="line">        stackPeek = stackPeek.next;</span><br><span class="line">        stkSize--;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 访问栈顶元素 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">peek</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (size() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>();</span><br><span class="line">        <span class="keyword">return</span> stackPeek.val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 将 List 转化为 Array 并返回 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] toArray() &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">node</span> <span class="operator">=</span> stackPeek;</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[size()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> res.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            res[i] = node.val;</span><br><span class="line">            node = node.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="5-2-队列"><a href="#5-2-队列" class="headerlink" title="5.2 队列"></a>5.2 队列</h3><p>「队列 <code>queue</code>」是一种遵循先入先出<code>First In, First Out</code>规则的线性数据结构。顾名思义，<ins>队列模拟了排队现象，即新来的人不断加入队列的尾部，而位于队列头部的人逐个离开</ins>。</p><p><img src="https://www.hello-algo.com/chapter_stack_and_queue/queue.assets/queue_operations.png"></p><h4 id="队列常用操作"><a href="#队列常用操作" class="headerlink" title="队列常用操作"></a>队列常用操作</h4><p>队列的常用操作如下表所示，具体的方法名需要根据所使用的编程语言来确定。我们以常见的<code>push()</code>、<code>pop()</code>、<code>peek()</code>命名为例。</p><table><thead><tr><th align="left">方法</th><th align="left">描述</th><th align="left">时间复杂度</th></tr></thead><tbody><tr><td align="left"><code>push()</code></td><td align="left">元素入队，即将元素添加至队尾</td><td align="left"><code>O(1)</code></td></tr><tr><td align="left"><code>pop()</code></td><td align="left">队首元素出队</td><td align="left"><code>O(1)</code></td></tr><tr><td align="left"><code>peek()</code></td><td align="left">访问队首元素</td><td align="left"><code>O(1)</code></td></tr></tbody></table><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 初始化队列 */</span></span><br><span class="line">Queue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 元素入队 */</span></span><br><span class="line">queue.offer(<span class="number">1</span>);</span><br><span class="line">queue.offer(<span class="number">3</span>);</span><br><span class="line">queue.offer(<span class="number">2</span>);</span><br><span class="line">queue.offer(<span class="number">5</span>);</span><br><span class="line">queue.offer(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 访问队首元素 */</span></span><br><span class="line"><span class="type">int</span> <span class="variable">peek</span> <span class="operator">=</span> queue.peek();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 元素出队 */</span></span><br><span class="line"><span class="type">int</span> <span class="variable">pop</span> <span class="operator">=</span> queue.poll();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取队列的长度 */</span></span><br><span class="line"><span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 判断队列是否为空 */</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">isEmpty</span> <span class="operator">=</span> queue.isEmpty();</span><br></pre></td></tr></table></figure><h4 id="队列简单实现"><a href="#队列简单实现" class="headerlink" title="队列简单实现"></a>队列简单实现</h4><p>为了实现队列，需要一种数据结构，可以在一端添加元素，并在另一端删除元素。我们可以使用链表来实现队列。将链表的“头节点”和“尾节点”分别视为“队首”和“队尾”，规定队尾仅可添加节点，队首仅可删除节点。</p><div class="tabs" id="placeholder"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#placeholder-1">LinkedListQueue</button></li><li class="tab"><button type="button" data-href="#placeholder-2">push()</button></li><li class="tab"><button type="button" data-href="#placeholder-3">pop()</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="placeholder-1"><p><img src="https://www.hello-algo.com/chapter_stack_and_queue/queue.assets/linkedlist_queue.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="placeholder-2"><p><img src="https://www.hello-algo.com/chapter_stack_and_queue/queue.assets/linkedlist_queue_push.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="placeholder-3"><p><img src="https://www.hello-algo.com/chapter_stack_and_queue/queue.assets/linkedlist_queue_pop.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 基于链表实现的队列 */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LinkedListQueue</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> ListNode front, rear; <span class="comment">// 头节点 front ，尾节点 rear</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">queSize</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LinkedListQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        front = <span class="literal">null</span>;</span><br><span class="line">        rear = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取队列的长度 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> queSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 判断队列是否为空 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> size() == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 入队 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="comment">// 尾节点后添加 num</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(num);</span><br><span class="line">        <span class="comment">// 如果队列为空，则令头、尾节点都指向该节点</span></span><br><span class="line">        <span class="keyword">if</span> (front == <span class="literal">null</span>) &#123;</span><br><span class="line">            front = node;</span><br><span class="line">            rear = node;</span><br><span class="line">        <span class="comment">// 如果队列不为空，则将该节点添加到尾节点后</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            rear.next = node;</span><br><span class="line">            rear = node;</span><br><span class="line">        &#125;</span><br><span class="line">        queSize++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 出队 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> peek();</span><br><span class="line">        <span class="comment">// 删除头节点</span></span><br><span class="line">        front = front.next;</span><br><span class="line">        queSize--;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 访问队首元素 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">peek</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (size() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>();</span><br><span class="line">        <span class="keyword">return</span> front.val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 将链表转化为 Array 并返回 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] toArray() &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">node</span> <span class="operator">=</span> front;</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[size()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; res.length; i++) &#123;</span><br><span class="line">            res[i] = node.val;</span><br><span class="line">            node = node.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="5-3-双向队列"><a href="#5-3-双向队列" class="headerlink" title="5.3 双向队列"></a>5.3 双向队列</h3><p>在队列中，我们仅能在头部删除或在尾部添加元素。如下图所示，「双向队列 <code>deque</code>」提供了更高的灵活性，<ins>允许在头部和尾部执行元素的添加或删除操作</ins>。</p><p><img src="https://www.hello-algo.com/chapter_stack_and_queue/deque.assets/deque_operations.png"></p><h4 id="双向队列常用操作"><a href="#双向队列常用操作" class="headerlink" title="双向队列常用操作"></a>双向队列常用操作</h4><p>双向队列的常用操作如下表所示。</p><table><thead><tr><th align="left">方法</th><th align="left">描述</th><th align="left">时间复杂度</th></tr></thead><tbody><tr><td align="left"><code>pushFirst()</code></td><td align="left">将元素添加至队首</td><td align="left"><code>O(1)</code></td></tr><tr><td align="left"><code>pushLast()</code></td><td align="left">将元素添加至队尾</td><td align="left"><code>O(1)</code></td></tr><tr><td align="left"><code>popFirst()</code></td><td align="left">删除队首元素</td><td align="left"><code>O(1)</code></td></tr><tr><td align="left"><code>popLast()</code></td><td align="left">删除队尾元素</td><td align="left"><code>O(1)</code></td></tr><tr><td align="left"><code>peekFirst()</code></td><td align="left">访问队首元素</td><td align="left"><code>O(1)</code></td></tr><tr><td align="left"><code>peekLast()</code></td><td align="left">访问队尾元素</td><td align="left"><code>O(1)</code></td></tr></tbody></table><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 初始化双向队列 */</span></span><br><span class="line">Deque&lt;Integer&gt; deque = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 元素入队 */</span></span><br><span class="line">deque.offerLast(<span class="number">2</span>);   <span class="comment">// 添加至队尾</span></span><br><span class="line">deque.offerLast(<span class="number">5</span>);</span><br><span class="line">deque.offerLast(<span class="number">4</span>);</span><br><span class="line">deque.offerFirst(<span class="number">3</span>);  <span class="comment">// 添加至队首</span></span><br><span class="line">deque.offerFirst(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 访问元素 */</span></span><br><span class="line"><span class="type">int</span> <span class="variable">peekFirst</span> <span class="operator">=</span> deque.peekFirst();  <span class="comment">// 队首元素</span></span><br><span class="line"><span class="type">int</span> <span class="variable">peekLast</span> <span class="operator">=</span> deque.peekLast();    <span class="comment">// 队尾元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 元素出队 */</span></span><br><span class="line"><span class="type">int</span> <span class="variable">popFirst</span> <span class="operator">=</span> deque.pollFirst();  <span class="comment">// 队首元素出队</span></span><br><span class="line"><span class="type">int</span> <span class="variable">popLast</span> <span class="operator">=</span> deque.pollLast();    <span class="comment">// 队尾元素出队</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取双向队列的长度 */</span></span><br><span class="line"><span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> deque.size();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 判断双向队列是否为空 */</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">isEmpty</span> <span class="operator">=</span> deque.isEmpty();</span><br></pre></td></tr></table></figure><h4 id="双向队列简单实现"><a href="#双向队列简单实现" class="headerlink" title="双向队列简单实现"></a>双向队列简单实现</h4><p>对于双向队列而言，头部和尾部都可以执行入队和出队操作。换句话说，双向队列需要实现另一个对称方向的操作。为此，我们采用“双向链表”作为双向队列的底层数据结构。</p><div class="tabs" id="placeholder"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#placeholder-1">LinkedListDeque</button></li><li class="tab"><button type="button" data-href="#placeholder-2">pushLast()</button></li><li class="tab"><button type="button" data-href="#placeholder-3">pushFirst()</button></li><li class="tab"><button type="button" data-href="#placeholder-4">popLast()</button></li><li class="tab"><button type="button" data-href="#placeholder-5">popFirst()</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="placeholder-1"><p><img src="https://www.hello-algo.com/chapter_stack_and_queue/deque.assets/linkedlist_deque.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="placeholder-2"><p><img src="https://www.hello-algo.com/chapter_stack_and_queue/deque.assets/linkedlist_deque_push_last.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="placeholder-3"><p><img src="https://www.hello-algo.com/chapter_stack_and_queue/deque.assets/linkedlist_deque_push_first.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="placeholder-4"><p><img src="https://www.hello-algo.com/chapter_stack_and_queue/deque.assets/linkedlist_deque_pop_last.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="placeholder-5"><p><img src="https://www.hello-algo.com/chapter_stack_and_queue/deque.assets/linkedlist_deque_pop_first.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>由于实现比较复杂，这里暂时不记实现方法。</p><hr><h2 id="6-哈希表"><a href="#6-哈希表" class="headerlink" title="6. 哈希表"></a>6. 哈希表</h2><h3 id="6-1-哈希表"><a href="#6-1-哈希表" class="headerlink" title="6.1 哈希表"></a>6.1 哈希表</h3><p>「哈希表 <code>hash table</code>」，通过建立键<code>key</code>与值<code>value</code>之间的映射，实现高效的元素查询。简单来说，向哈希表输入一个键<code>key</code>，就可以在<code>O(1)</code>时间内获取对应的值<code>value</code>。</p><p>如下图所示，给定<code>n</code>个学生，每个学生都有“姓名”和“学号”两项数据。假如我们希望实现“输入一个学号，返回对应的姓名”的查询功能，则可以采用下图所示的哈希表来实现。</p><p><img src="https://www.hello-algo.com/chapter_hashing/hash_map.assets/hash_table_lookup.png"></p><p>除哈希表外，数组和链表也可以实现查询功能，它们的效率对比如下表所示。</p><table><thead><tr><th align="left"></th><th align="left">数组</th><th align="left">链表</th><th align="left">哈希表</th></tr></thead><tbody><tr><td align="left">查找元素</td><td align="left"><code>O(n)</code></td><td align="left"><code>O(n)</code></td><td align="left"><code>O(1)</code></td></tr><tr><td align="left">添加元素</td><td align="left"><code>O(1)</code></td><td align="left"><code>O(1)</code></td><td align="left"><code>O(1)</code></td></tr><tr><td align="left">删除元素</td><td align="left"><code>O(n)</code></td><td align="left"><code>O(n)</code></td><td align="left"><code>O(1)</code></td></tr></tbody></table><p>观察发现，在哈希表中进行增删查改的时间复杂度都是<code>O(1)</code>，非常高效。</p><h4 id="哈希表常用操作"><a href="#哈希表常用操作" class="headerlink" title="哈希表常用操作"></a>哈希表常用操作</h4><p>哈希表的常见操作包括，初始化、查询操作<code>get(key)</code>、添加键值对<code>put(key, value)</code>和删除键值对<code>remove(key)</code>等。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 初始化哈希表 */</span></span><br><span class="line">Map&lt;Integer, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 添加操作 */</span></span><br><span class="line"><span class="comment">// 在哈希表中添加键值对 (key, value)</span></span><br><span class="line">map.put(<span class="number">12836</span>, <span class="string">&quot;小哈&quot;</span>);</span><br><span class="line">map.put(<span class="number">15937</span>, <span class="string">&quot;小啰&quot;</span>);</span><br><span class="line">map.put(<span class="number">16750</span>, <span class="string">&quot;小算&quot;</span>);</span><br><span class="line">map.put(<span class="number">13276</span>, <span class="string">&quot;小法&quot;</span>);</span><br><span class="line">map.put(<span class="number">10583</span>, <span class="string">&quot;小鸭&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 查询操作 */</span></span><br><span class="line"><span class="comment">// 向哈希表输入键 key ，得到值 value</span></span><br><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> map.get(<span class="number">15937</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 删除操作 */</span></span><br><span class="line"><span class="comment">// 在哈希表中删除键值对 (key, value)</span></span><br><span class="line">map.remove(<span class="number">10583</span>);</span><br></pre></td></tr></table></figure><p>哈希表有三种常用遍历方式，遍历键值对、遍历键和遍历值。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 遍历哈希表 */</span></span><br><span class="line"><span class="comment">// 遍历键值对 key-&gt;value</span></span><br><span class="line"><span class="keyword">for</span> (Map.Entry &lt;Integer, String&gt; kv: map.entrySet()) &#123;</span><br><span class="line">    System.out.println(kv.getKey() + <span class="string">&quot; -&gt; &quot;</span> + kv.getValue());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 单独遍历键 key</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> key: map.keySet()) &#123;</span><br><span class="line">    System.out.println(key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 单独遍历值 value</span></span><br><span class="line"><span class="keyword">for</span> (String val: map.values()) &#123;</span><br><span class="line">    System.out.println(val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="哈希表简单实现"><a href="#哈希表简单实现" class="headerlink" title="哈希表简单实现"></a>哈希表简单实现</h4><p>我们可以用数组来实现哈希表。在哈希表中，数组中的每个空位称为「桶 <code>bucket</code>」，每个桶可存储一个键值对。因此，查询操作就是找到<code>key</code>对应的桶，并在桶中获取<code>value</code>。</p><p>那怎么基于<code>key</code>来定位对应的桶呢？这是通过「哈希函数 <code>hash function</code>」实现的。在哈希表中输入一个<code>key</code>，可以通过哈希函数得到该<code>key</code>对应的键值对在数组中的存储位置。计算过程分为两步。</p><ul><li>通过某种哈希算法<code>hash()</code>计算得到哈希值。</li><li>将哈希值对桶数量（数组长度）<code>capacity</code>取模，从而获取该<code>key</code>对应的数组索引<code>index</code>。</li></ul><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">index = hash(key) % capacity</span><br></pre></td></tr></table></figure><p>随后，就可以利用<code>index</code>在哈希表中访问对应的桶，从而获取<code>value</code>。</p><p>设数组长度<code>capacity = 100</code>、哈希算法<code>hash(key) = key</code>，哈希函数为<code>key % 100</code>。下图以<code>key</code>学号和<code>value</code>姓名为例，展示了哈希函数的工作原理。</p><p><img src="https://www.hello-algo.com/chapter_hashing/hash_map.assets/hash_function.png"></p><p>下面代码实现了一个简单哈希表。将<code>key</code>和<code>value</code>封装成一个类<code>Pair</code>，以表示键值对。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 键值对 */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Pair</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> key;</span><br><span class="line">    <span class="keyword">public</span> String val;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Pair</span><span class="params">(<span class="type">int</span> key, String val)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.key = key;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 基于数组简易实现的哈希表 */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ArrayHashMap</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Pair&gt; buckets;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArrayHashMap</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 初始化数组，包含 100 个桶</span></span><br><span class="line">        buckets = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            buckets.add(<span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 哈希函数 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">hashFunc</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> key % <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 查询操作 */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">get</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> hashFunc(key);</span><br><span class="line">        <span class="type">Pair</span> <span class="variable">pair</span> <span class="operator">=</span> buckets.get(index);</span><br><span class="line">        <span class="keyword">if</span> (pair == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">return</span> pair.val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 添加操作 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> key, String val)</span> &#123;</span><br><span class="line">        <span class="type">Pair</span> <span class="variable">pair</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Pair</span>(key, val);</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> hashFunc(key);</span><br><span class="line">        buckets.set(index, pair);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 删除操作 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> hashFunc(key);</span><br><span class="line">        <span class="comment">// 置为 null ，代表删除</span></span><br><span class="line">        buckets.set(index, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取所有键值对 */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Pair&gt; <span class="title function_">pairSet</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;Pair&gt; pairSet = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Pair pair : buckets) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pair != <span class="literal">null</span>)</span><br><span class="line">                pairSet.add(pair);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pairSet;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取所有键 */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">keySet</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; keySet = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Pair pair : buckets) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pair != <span class="literal">null</span>)</span><br><span class="line">                keySet.add(pair.key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> keySet;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取所有值 */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">valueSet</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;String&gt; valueSet = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Pair pair : buckets) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pair != <span class="literal">null</span>)</span><br><span class="line">                valueSet.add(pair.val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> valueSet;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 打印哈希表 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Pair kv : pairSet()) &#123;</span><br><span class="line">            System.out.println(kv.key + <span class="string">&quot; -&gt; &quot;</span> + kv.val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="哈希冲突与扩容"><a href="#哈希冲突与扩容" class="headerlink" title="哈希冲突与扩容"></a>哈希冲突与扩容</h4><p>本质上看，哈希函数的作用是将所有<code>key</code>构成的输入空间映射到数组所有索引构成的输出空间，而输入空间往往远大于输出空间。因此，理论上一定存在“多个输入对应相同输出”的情况。</p><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">12836 % 100 = 36</span><br><span class="line">20336 % 100 = 36</span><br></pre></td></tr></table></figure><p>如下图所示，两个学号指向了同一个姓名，这显然是不对的。我们将这种多个输入对应同一输出的情况称为「哈希冲突 <code>hash collision</code>」。</p><p><img src="https://www.hello-algo.com/chapter_hashing/hash_map.assets/hash_collision.png"></p><p>简单来说，可以通过扩容哈希表来减少哈希冲突。因为哈希表容量<code>n</code>越大，多个<code>key</code>被分配到同一个桶中的概率就越低，冲突就越少。如下图所示，扩容前键值对<code>(136, A)</code>和<code>(236, D)</code>发生冲突，扩容后冲突消失。</p><p><img src="https://www.hello-algo.com/chapter_hashing/hash_map.assets/hash_table_reshash.png"></p><p>类似于数组扩容，哈希表扩容需将所有键值对从原哈希表迁移至新哈希表，非常耗时。并且由于哈希表容量<code>capacity</code>改变，需要通过哈希函数来重新计算所有键值对的存储位置，这进一步提高了扩容过程的计算开销。</p><p>由于<a href="https://www.hello-algo.com/chapter_hashing/hash_collision/">哈希冲突</a>和<a href="https://www.hello-algo.com/chapter_hashing/hash_algorithm/">哈希算法</a>比较复杂，这里就不做过多解释，可以自行阅读。</p><hr><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><blockquote><p>文件还未上传 Github</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C# 关键字解析</title>
      <link href="/posts/cd5cb147.html"/>
      <url>/posts/cd5cb147.html</url>
      
        <content type="html"><![CDATA[<h2 id="C-中的关键字解析"><a href="#C-中的关键字解析" class="headerlink" title="C# 中的关键字解析"></a>C# 中的关键字解析</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p>最近在一个初创公司里做全栈开发。一开始以为去做<code>ASP.NET</code>，结果微信小程序开发缺人（汗）。反正闲着也是闲着，趁这个机会学习点<code>C#</code>中的基础知识。</p></blockquote><ul><li><p>结合<a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/">微软文档</a>，对<code>C#</code>中的关键字进行解析。</p></li><li><p>文章中，派生类默认为子类，基类默认为父类。</p></li><li><p>部分常见关键字省略：<a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/builtin-types/bool">bool</a>，<a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/statements/jump-statements#the-break-statement">break</a>，<a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/statements/selection-statements#the-switch-statement">case</a>，<a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/builtin-types/char">char</a>，<a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/const">const</a>，<a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/statements/jump-statements#the-continue-statement">continue</a>，<a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/default">default</a>，<a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/statements/iteration-statements#the-do-statement">do</a>，<a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/builtin-types/floating-point-numeric-types">double</a>，<a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/statements/selection-statements#the-if-statement">else</a>，<a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/builtin-types/bool">false</a>，<a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/builtin-types/floating-point-numeric-types">float</a>，<a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/statements/iteration-statements#the-for-statement">for</a>，<a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/statements/selection-statements#the-if-statement">if</a>，<a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/builtin-types/integral-numeric-types">int</a></p></li><li><p>不常用关键字省略（感觉不会用到）：<a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/statements/checked-and-unchecked">checked</a>，<a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/extern">extern</a>，<a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/statements/fixed">fixed</a>，<a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/statements/jump-statements#the-goto-statement">goto</a>，<a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/user-defined-conversion-operators">implicit</a>，<a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/in">in</a>，</p></li></ul><hr><h3 id="1-abstract-关键字"><a href="#1-abstract-关键字" class="headerlink" title="1. abstract 关键字"></a>1. abstract 关键字</h3><p>在<code>C#</code>中，关键字<a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/abstract"><code>abstract</code></a>用于<ins>声明抽象类或类中的抽象成员</ins>。</p><p>抽象类特点：</p><ol><li>抽象类不能实例化。</li><li>抽象类可能包含抽象成员（方法、属性）和非抽象成员的实现。</li><li>只有抽象类中才允许抽象方法声明。</li><li>抽象类不能使用<code>new</code>关键字。</li><li>抽象类通常作为基类被子类继承，子类必须使用<code>override</code>实现抽象类中声明的抽象成员。</li></ol><p>抽象方法特点：</p><ol><li>凡是包含抽象方法的类都是抽象类。</li><li>抽象方法声明不提供实际的实现，因此没有方法主体。（抽象属性同理）</li><li>在抽象方法声明中不能使用<code>static</code>或<code>virtual</code>关键字。<ul><li>抽象方法没有具体实现，所以不能使用<code>static</code>关键字来声明为静态方法。</li><li>抽象方法是隐式的虚拟方法，所以不需要<code>virtual</code>关键字。</li></ul></li></ol><p>举个例子：</p><ul><li>枪（抽象基类）是可以 Shoot 和 Reload 的（抽象方法）。</li><li>比如 AK47 和 M4（非抽象类子类），它们拥有 Shoot 和 Reload 的功能。</li><li>但具体是怎么 Shoot 和 Reload，AK47 和 M4 是不一样的（具体实现）。</li></ul><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 抽象类：Firearms</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Firearms</span></span><br><span class="line"> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">Shoot</span>()</span>; <span class="comment">// 抽象方法</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">Reload</span>()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">Init</span>()</span> &#123;...&#125; <span class="comment">// 非抽象方法</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="built_in">string</span> FireRate &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; <span class="comment">// 抽象属性</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类：AK47</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">AK47</span> : <span class="title">Firearms</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> fireRate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Shoot</span>()</span> &#123;...&#125; <span class="comment">// 具体实现</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Reload</span>()</span> &#123;...&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">override</span> <span class="built_in">string</span> FireRate</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> fireRate; &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123; fireRate = <span class="keyword">value</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么要用抽象类，而不是使用一般类或者接口<code>interface</code>？</p><ol><li>共享代码：<ins>抽象类可以定义一组相关类的通用行为和属性，并提供默认的实现。通过继承抽象类，子类可以继承和重用抽象类中的代码</ins>，减少代码的重复编写。这样可以提高代码的可维护性和扩展性。</li><li>代码扩展性：抽象类可以包含抽象方法，这些方法在抽象类中没有具体的实现。通过继承抽象类并实现这些抽象方法，子类可以在具体的业务逻辑中实现自己的代码。这种方式使得代码具有扩展性，可以适应未来需求的变化。</li><li>部分实现：抽象类既可以包含抽象方法，也可以包含具体的实现。这使得抽象类可以提供一些默认的行为，同时也给子类提供了一定的灵活性。子类可以选择性地覆盖抽象类中的方法，或者直接使用抽象类中的实现。</li><li>（待补充）</li></ol><hr><h3 id="2-as-关键字"><a href="#2-as-关键字" class="headerlink" title="2. as 关键字"></a>2. as 关键字</h3><p>在<code>C#</code>中，关键字<a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/type-testing-and-cast#as-operator"><code>as</code></a>用于类型转换。</p><p>在实际应用中，通常会与<code>null</code>检查一起使用<code>as</code>关键字。这是因为，如果转换不成功，<code>as</code>会返回<code>null</code>，而不是抛出异常。这使得<code>as</code>关键字在面对类型转换失败时的行为更加温和。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Animal</span> &#123; ... &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Dog</span> : <span class="title">Animal</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">Animal animal = <span class="keyword">new</span> Dog();</span><br><span class="line">Dog dog = animal <span class="keyword">as</span> Dog;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (dog != <span class="literal">null</span>)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Successful&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Failed&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>as</code>关键字尝试将<code>animal</code>转换为<code>Dog</code>类型。由于<code>animal</code>对象实际上是一个<code>Dog</code>类型的对象，所以转换成功。如果<code>animal</code>对象是<code>Animal</code>类型的对象，则上面代码会转换失败。</p><hr><h3 id="3-base-关键字"><a href="#3-base-关键字" class="headerlink" title="3. base 关键字"></a>3. base 关键字</h3><p>在<code>C#</code>中，<code>base</code>关键字用于<ins>在子类中引用基类的成员或调用基类的构造函数</ins>。</p><ul><li><code>base</code>关键字只能用于子类，而不是基类中。</li><li>如果基类成员是私有的，即使使用<code>base</code>关键字也无法访问。</li><li>在静态方法中使用 <code>base</code> 关键字将产生错误。</li><li>如果基类中有多个构造函数重载，子类在使用<code>base</code>关键字调用父类构造函数时，需要选择要调用的具体构造函数，并且提供与所选基类构造函数匹配的参数列表。</li></ul><p>下面是<code>base</code>关键字的几种常见用法：</p><p>（1）调用基类的构造函数</p><p>在派生类的构造函数中，可以使用<code>base</code>关键字调用基类的构造函数。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BaseClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 基类的构造函数 1</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BaseClass</span>(<span class="params"><span class="built_in">int</span> x</span>)</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 基类的构造函数 2</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BaseClass</span>(<span class="params"><span class="built_in">int</span> x, <span class="built_in">int</span> y</span>)</span> &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DerivedClass</span> : <span class="title">BaseClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 派生类的构造函数</span></span><br><span class="line">    <span class="comment">// 执行其他派生类的构造逻辑</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DerivedClass</span>(<span class="params"><span class="built_in">int</span> x</span>) : <span class="title">base</span>(<span class="params">x</span>)</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DerivedClass</span>(<span class="params"><span class="built_in">int</span> x, <span class="built_in">int</span> y</span>) : <span class="title">base</span>(<span class="params">x, y</span>)</span> &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x = <span class="keyword">new</span> DerivedClass(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">var</span> y = <span class="keyword">new</span> DerivedClass(<span class="number">1</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>上面代码中，<code>DerivedClass</code>继承自<code>BaseClass</code>。在<code>DerivedClass</code>的构造函数中，使用<code>base(x)</code>调用了基类<code>BaseClass</code>的构造函数，并传递参数<code>x</code>。</p><p>（2）引用基类的成员</p><p>当<ins>派生类中定义了一个与基类相同名称的成员变量或方法</ins>时，可以使用<code>base</code>关键字来访问它。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BaseClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 基类的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SomeMethod</span>()</span> &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DerivedClass</span> : <span class="title">BaseClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 调用基类的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SomeMethod</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">base</span>.SomeMethod();</span><br><span class="line">        <span class="comment">// ... 其他逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>DerivedClass</code>继承自<code>BaseClass</code>。在<code>DerivedClass</code>中的<code>SomeMethod</code>方法中，使用<code>base.SomeMethod()</code>调用了基类<code>BaseClass</code>的方法。</p><p>为什么要使用<code>base</code>去调用基类的构造函数？</p><ol><li>继承基类的行为和状态：通过调用基类的构造函数，子类可以继承基类的行为和状态。基类可能包含一些重要的初始化逻辑，以确保它的成员和属性处于正确的状态。</li><li>提供基类所需的初始化参数：如果基类的构造函数需要接收参数来进行初始化，派生类可以通过调用基类构造函数并传递适当的参数，来提供必要的信息。</li><li>避免冗余代码：如果基类的构造函数已经包含了一些通用的、所有派生类都需要的初始化代码，那么在派生类中通过使用 base 关键字调用基类构造函数，可以避免重复编写这些初始化代码。</li><li>（待补充）</li></ol><hr><h3 id="4-byte-关键字"><a href="#4-byte-关键字" class="headerlink" title="4. byte 关键字"></a>4. byte 关键字</h3><p>在<code>C#</code>中，<code>byte</code>关键字用于声明一个<code>8</code>位无符号（<code>unsigned</code>）整数类型的变量。</p><p><code>byte</code>关键字在<code>C#</code>中具有多种用途和应用场景：</p><ul><li>存储和处理二进制数据：<code>byte</code>类型是一个<code>8</code>位无符号整数，范围从<code>0</code>到<code>255</code>。因此，它非常适合用于存储和处理二进制数据，如图像、音频、视频、文件等。</li><li>网络编程：在网络编程中，常常需要使用<code>byte</code>类型来读取和写入数据流、处理网络字节序等。</li><li>数据序列化和反序列化：序列化是将对象转换为字节序列的过程，而反序列化则是将字节序列转换回对象。在数据序列化和反序列化过程中，<code>byte</code>类型通常用于表示和操作字节数据。</li><li>…</li></ul><p>举个例子：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 读取图像文件的字节数据</span></span><br><span class="line"><span class="built_in">byte</span>[] imageData = File.ReadAllBytes(<span class="string">&quot;image.jpg&quot;</span>);</span><br><span class="line"><span class="comment">// 对数据进行压缩，返回压缩后的字节数据</span></span><br><span class="line"><span class="built_in">byte</span>[] compressedData = CompressData(originalData);</span><br></pre></td></tr></table></figure><hr><h3 id="5-异常处理关键字"><a href="#5-异常处理关键字" class="headerlink" title="5. 异常处理关键字"></a>5. 异常处理关键字</h3><p>在<code>C#</code>中，<code>try</code>关键字用于定义一个<code>try</code>块，表示其中可能会出现异常。</p><p><code>try</code>块后面通常跟随一个或多个<code>catch</code>块，用于处理可能抛出的特定异常。最后还可以选择性地包含一个<code>finally</code>块，它包含的代码无论是否抛出异常都会被执行。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.IO;</span><br><span class="line"></span><br><span class="line">StreamReader reader = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    reader = <span class="keyword">new</span> StreamReader(<span class="string">&quot;nonexistent_file.txt&quot;</span>);</span><br><span class="line">    Console.WriteLine(reader.ReadToEnd());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (FileNotFoundException ex)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 处理文件找不到的异常</span></span><br><span class="line">    Console.WriteLine(<span class="string">&quot;File not found: &quot;</span> + ex.FileName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Exception ex)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 处理其他类型的异常</span></span><br><span class="line">    Console.WriteLine(<span class="string">&quot;An error occurred: &quot;</span> + ex.Message);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 确保关闭StreamReader对象，释放系统资源</span></span><br><span class="line">    <span class="keyword">if</span> (reader != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        reader.Close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，如果<code>try</code>块中的代码引发了异常，程序会立即跳转到<code>catch</code>块，寻找与异常类型匹配的<code>catch</code>块，并执行相应的代码块。每个<code>catch</code>块可以捕获并处理特定类型的异常。</p><p>处理异步函数的异常：</p><p>异步函数通常返回一个<code>Task</code>或<code>Task&lt;T&gt;</code>对象。可以在<code>try</code>块中<code>await</code>这个任务，并在<code>catch</code>块中处理可能的异常。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 有可能抛出异常的异步操作</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">SomeAsyncOperation</span>()</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">HandleAsyncOperation</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">await</span> SomeAsyncOperation();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Exception ex)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;An exception occurred: <span class="subst">&#123;ex.Message&#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外，不是所有的异常都应该被捕获。在大多数情况下，只应该捕获知道如何处理的异常。对于不知道如何处理的异常，最好让它们传播出去，这样调用者或者全局异常处理器可以捕获并处理它们。</p><p>（这里暂时省略处理迭代器方法中的异常，待补充）</p><hr><h3 id="6-class-关键字"><a href="#6-class-关键字" class="headerlink" title="6. class 关键字"></a>6. class 关键字</h3><p>在<code>C#</code>中，<a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/class"><code>class</code></a>关键字用于定义一个类。</p><p>类是一种引用类型，它定义了一组属性（字段、常量和事件）、方法和索引器的组合。类可以直接实例化，也可以作为基类继承。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 类的成员变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> myInt;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 类的构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyClass</span>(<span class="params"><span class="built_in">int</span> <span class="keyword">value</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        myInt = <span class="keyword">value</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 类的成员方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PrintValue</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;MyInt = &quot;</span> + myInt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><ins><code>C#</code> 中仅允许单一继承，即一个类仅能从一个基类继承实现。但是，一个类可拥有多个接口</ins>。</p><table><thead><tr><th align="left">继承</th><th align="left">示例</th></tr></thead><tbody><tr><td align="left">无</td><td align="left">class ClassA { }</td></tr><tr><td align="left">单一</td><td align="left">class DerivedClass : BaseClass { }</td></tr><tr><td align="left">无，实现两个接口</td><td align="left">class ImplClass : IFace1, IFace2 { }</td></tr><tr><td align="left">单一，实现一个接口</td><td align="left">class ImplDerivedClass : BaseClass, IFace1 { }</td></tr></tbody></table><p>下面是一些类的使用方法：</p><p>（1）访问修饰符：类的访问修饰符决定了它在代码中的可见性。默认情况下，类是<code>internal</code>的，意味着它只在同一程序集中可见。类的成员默认是<code>private</code>的，只能在类的内部访问。</p><p>（2）静态类：使用<code>static</code>关键字可以定义静态类和静态成员。静态类不能实例化，不能被继承，且只能包含静态成员。静态成员只有一份，属于类本身，而不属于类的任何实例。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">MathUtils</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">Add</span>(<span class="params"><span class="built_in">int</span> a, <span class="built_in">int</span> b</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">double</span> <span class="title">SquareRoot</span>(<span class="params"><span class="built_in">double</span> <span class="keyword">value</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> Math.Sqrt(<span class="keyword">value</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MathUtils.Add(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">MathUtils.SquareRoot(<span class="number">4.0</span>)</span><br></pre></td></tr></table></figure><p>（3）构造函数：类可以有一个或多个构造函数，用于创建类的实例。构造函数的名称必须与类名相同，且不返回任何值。</p><p>（4）静态构造函数：<ins>用于初始化静态成员或执行静态初始化代码</ins>。它没有参数列表，也不能直接调用。<ins>静态构造函数在类的第一个实例或静态成员被访问之前自动调用，并且只执行一次</ins>。</p><ul><li>访问静态成员时调用</li></ul><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">int</span> myStaticField;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">readonly</span> <span class="built_in">int</span> myStaticReadOnlyField;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="title">MyClass</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 静态构造函数用于初始化静态成员</span></span><br><span class="line">        myStaticField = <span class="number">10</span>;</span><br><span class="line">        myStaticReadOnlyField = <span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">MyMethod</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;MyStaticField: &quot;</span> + myStaticField);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;MyStaticReadOnlyField: &quot;</span> + myStaticReadOnlyField);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用静态方法，静态构造函数会在此时自动执行</span></span><br><span class="line">MyClass.MyMethod();</span><br><span class="line"></span><br><span class="line"><span class="comment">// MyStaticField: 10</span></span><br><span class="line"><span class="comment">// MyStaticReadOnlyField: 20</span></span><br></pre></td></tr></table></figure><ul><li>创建类的实例时调用</li></ul><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">int</span> myStaticField;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">readonly</span> <span class="built_in">int</span> myStaticReadOnlyField;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="title">MyClass</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        myStaticField = <span class="number">10</span>;</span><br><span class="line">        myStaticReadOnlyField = <span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyClass</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;MyStaticField: &quot;</span> + myStaticField);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;MyStaticReadOnlyField: &quot;</span> + myStaticReadOnlyField);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建类的第一个实例，静态构造函数会在此时自动调用</span></span><br><span class="line">MyClass obj = <span class="keyword">new</span> MyClass();</span><br><span class="line"></span><br><span class="line"><span class="comment">// MyStaticField: 10</span></span><br><span class="line"><span class="comment">// MyStaticReadOnlyField: 20</span></span><br></pre></td></tr></table></figure><p>（5）内部类：内部类是定义在另一个类内部的类。内部类拥有访问外部类成员的特权，可以用于实现更复杂的逻辑和封装。（注意，虽然内部类可以访问其外部类的所有成员，但反过来不成立。）</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">OuterClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> outerField = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">InnerClass</span></span><br><span class="line">    &#123;</span><br><span class="line">        OuterClass outer;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构造函数，通过参数将外部类实例传入</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">InnerClass</span>(<span class="params">OuterClass outer</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>.outer = outer;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">InnerMethod</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(outer.outerField);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> InnerClass <span class="title">CreateInnerClass</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> InnerClass(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">OuterClass outer = <span class="keyword">new</span> OuterClass();</span><br><span class="line">OuterClass.InnerClass inner = outer.CreateInnerClass();</span><br><span class="line">inner.InnerMethod(); <span class="comment">// 10</span></span><br></pre></td></tr></table></figure><p>（6）泛型类：泛型类具有在实例化时可以指定参数类型的特性，从而提供了更灵活和类型安全的代码重用方式。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyGenericClass</span>&lt;<span class="title">T</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> T myField;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyGenericClass</span>(<span class="params">T <span class="keyword">value</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        myField = <span class="keyword">value</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">MyMethod</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> myField;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyGenericClass&lt;<span class="built_in">int</span>&gt; intObj = <span class="keyword">new</span> MyGenericClass&lt;<span class="built_in">int</span>&gt;(<span class="number">10</span>);</span><br><span class="line"><span class="built_in">int</span> <span class="keyword">value</span> = intObj.MyMethod(); <span class="comment">// 返回值为 10</span></span><br><span class="line"></span><br><span class="line">MyGenericClass&lt;<span class="built_in">string</span>&gt; stringObj = <span class="keyword">new</span> MyGenericClass&lt;<span class="built_in">string</span>&gt;(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"><span class="built_in">string</span> text = stringObj.MyMethod(); <span class="comment">// 返回值为 &quot;Hello&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>（7）<code>C#</code>还有许多其他不同的类，比如之前介绍的抽象类，还有接口，密封类，枚举类，部分类，特性类，委托类等等。（待补充）</p><hr><h3 id="7-decimal-关键字"><a href="#7-decimal-关键字" class="headerlink" title="7. decimal 关键字"></a>7. decimal 关键字</h3><p>在<code>C#</code>中，当所需的精度由小数点右侧的位数决定时，<a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/builtin-types/floating-point-numeric-types"><code>decimal</code></a>关键字是合适的。</p><p>它是一种数据类型，用于存储精确的十进制数值（支持小数点后<code>28</code>的精确度），适用于需要高精度计算的场景，例如财务和货币计算。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">decimal</span> myDecimal = <span class="number">3.14</span>m; <span class="comment">// 使用后缀 &quot;m&quot; 表示 decimal 类型</span></span><br><span class="line"><span class="built_in">float</span> myFloat = <span class="number">3.14f</span>; <span class="comment">// 使用后缀 &quot;f&quot; 表示 float 类型</span></span><br><span class="line"><span class="built_in">double</span> myDouble = <span class="number">3.14</span>; <span class="comment">// 默认为 double 类型</span></span><br></pre></td></tr></table></figure><p>注意，<code>decimal</code>类型虽然具有较高的精度和准确性，它的计算速度通常比其他浮点类型（如 <code>float</code> 和 <code>double</code>）慢。</p><hr><h3 id="8-delegate-关键字"><a href="#8-delegate-关键字" class="headerlink" title="8. delegate 关键字"></a>8. delegate 关键字</h3><p>在<code>C#</code>中，<a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/programming-guide/delegates/"><code>delegate</code></a>关键字用于声明和使用委托。</p><p>它类似于一个装着方法的容器，可以将方法（实例方法，静态方法）作为对象进行传递，但<ins>前提是委托和对应传递方法的签名得是相同的，签名指的是他们的参数类型和返回值类型</ins>。（类似回调函数或者<code>Thunk</code>函数）</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 委托的声明，指定了返回值类型为 int，接收两个 int 类型的参数。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="built_in">int</span> <span class="title">MyDelegate</span>(<span class="params"><span class="built_in">int</span> num1, <span class="built_in">int</span> num2</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Calculator</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 使用委托的一个方法，这里的 method 参数是一个 Operation 类型的委托</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">Calculate</span>(<span class="params"><span class="built_in">int</span> num1, <span class="built_in">int</span> num2, MyDelegate callback</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 在Calculate方法中调用委托</span></span><br><span class="line">        <span class="keyword">return</span> callback(num1, num2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 两个符合 Operation 委托签名的方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">Add</span>(<span class="params"><span class="built_in">int</span> num1, <span class="built_in">int</span> num2</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">Subtract</span>(<span class="params"><span class="built_in">int</span> num1, <span class="built_in">int</span> num2</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 - num2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Calculator calculator = <span class="keyword">new</span> Calculator();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用委托将 Add 方法作为参数传入</span></span><br><span class="line"><span class="built_in">int</span> result = calculator.Calculate(<span class="number">10</span>, <span class="number">5</span>, Add);</span><br><span class="line">Console.WriteLine(result);  <span class="comment">// 输出：15</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用委托将 Subtract 方法作为参数传入</span></span><br><span class="line">result = calculator.Calculate(<span class="number">10</span>, <span class="number">5</span>, Subtract);</span><br><span class="line">Console.WriteLine(result);  <span class="comment">// 输出：5</span></span><br></pre></td></tr></table></figure><p>注意，在<code>C#</code>中创建委托对象时，并不一定需要使用<code>new</code>关键字来实例化委托。</p><p>（1）使用<code>new</code>关键字和委托类型的构造函数创建委托对象</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">MyDelegate myDelegate = <span class="keyword">new</span> MyDelegate(ShowMessage);</span><br></pre></td></tr></table></figure><p>在这种情况下，我们使用<code>new MyDelegate</code>语法创建了一个委托对象<code>myDelegate</code>，并将<code>ShowMessage</code>方法绑定到委托上。</p><p>（2）使用隐式方法组转换来创建委托对象</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">MyDelegate myDelegate = ShowMessage;</span><br></pre></td></tr></table></figure><p>在这种情况下，我们直接将方法名<code>ShowMessage</code>赋值给委托对象<code>myDelegate</code>，编译器会自动进行隐式方法组转换，将方法转换为委托对象。</p><p>（3）使用匿名方法创建委托对象</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">MyDelegate myDelegate = <span class="built_in">delegate</span>(<span class="built_in">string</span> message)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(message);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>匿名方法的语法是使用关键字<code>delegate</code>后跟一个参数列表和方法体。</p><p>（4）使用 Lambda 表达式创建委托对象</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Lambda表达式的参数部分只使用了参数名&quot;message&quot;，而没有指定参数类型。</span></span><br><span class="line"><span class="comment">// 编译器会根据委托类型推断出参数类型。</span></span><br><span class="line">MyDelegate myDelegate = (message) =&gt; Console.WriteLine(message);</span><br></pre></td></tr></table></figure><p>在这种情况下，我们使用<code>Lambda</code>表达式定义了一个匿名方法，将其赋值给委托对象<code>myDelegate</code>。</p><p>那什么情况下应该使用委托<code>delegate</code>？</p><p>（1）事件处理：委托广泛用于事件处理模型中。通过定义委托类型和事件，可以将事件与特定的处理方法关联起来。当事件发生时，委托会调用绑定的方法，从而实现事件的处理和响应。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明一个委托</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">EventHandler</span>(<span class="params"><span class="built_in">string</span> message</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">EventPublisher</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 声明一个事件，使用之前定义的委托</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">event</span> EventHandler Event;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TriggerEvent</span>(<span class="params"><span class="built_in">string</span> message</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 触发事件</span></span><br><span class="line">        Event?.Invoke(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">EventSubscriber</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Subscribe</span>(<span class="params">EventPublisher publisher</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 订阅事件</span></span><br><span class="line">        publisher.Event += HandleEvent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">HandleEvent</span>(<span class="params"><span class="built_in">string</span> message</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 处理事件</span></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Event received: &quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建事件发布者和订阅者</span></span><br><span class="line">EventPublisher publisher = <span class="keyword">new</span> EventPublisher();</span><br><span class="line">EventSubscriber subscriber = <span class="keyword">new</span> EventSubscriber();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 订阅事件</span></span><br><span class="line">subscriber.Subscribe(publisher);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 触发事件</span></span><br><span class="line">publisher.TriggerEvent(<span class="string">&quot;Hello, World!&quot;</span>);</span><br></pre></td></tr></table></figure><p>（2）回调函数：委托可用作回调函数的一种方式。当一个方法需要在完成后通知另一个方法时，可以将委托作为参数传递给该方法，并在适当的时候调用委托以执行回调操作。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">MyCallbackDelegate</span>(<span class="params"><span class="built_in">string</span> message</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Processor</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> MyCallbackDelegate callback;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Processor</span>(<span class="params">MyCallbackDelegate callback</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.callback = callback;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Process</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Processing...</span></span><br><span class="line">        <span class="comment">// Once processing is done, callback is called:</span></span><br><span class="line">        callback(<span class="string">&quot;Processing completed!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a new processor, passing it a callback function:</span></span><br><span class="line">Processor processor = <span class="keyword">new</span> Processor(MyCallback);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Start the processing:</span></span><br><span class="line">processor.Process();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">MyCallback</span>(<span class="params"><span class="built_in">string</span> message</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（3）多播委托（委托链）：委托还支持多播（<code>multicast</code>）的功能，即一个委托可以绑定多个方法。这使得可以将多个方法作为委托的调用列表，并按顺序依次调用它们。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">MyDelegate</span>()</span>;</span><br><span class="line"></span><br><span class="line">MyDelegate myDelegate = Method1;</span><br><span class="line">myDelegate += Method2;</span><br><span class="line">myDelegate += Method3;</span><br><span class="line">myDelegate -= Method4; <span class="comment">// 删除调用列表中的方法</span></span><br><span class="line">myDelegate();  <span class="comment">// 调用委托，依次执行绑定的方法</span></span><br></pre></td></tr></table></figure><p>（4）泛型委托：<code>C#</code>中的委托支持泛型，可以更好地支持类型安全性和代码重用。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">delegate</span> T <span class="title">MyGenericDelegate</span>&lt;<span class="title">T</span>&gt;(<span class="params">T <span class="keyword">value</span></span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="built_in">int</span> <span class="title">Square</span>(<span class="params"><span class="built_in">int</span> x</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyGenericDelegate&lt;<span class="built_in">int</span>&gt; squareDelegate = Square;</span><br><span class="line"><span class="built_in">int</span> result = squareDelegate(<span class="number">5</span>);</span><br></pre></td></tr></table></figure><p>（5）LINQ 和 Lambda 表达式：在<code>LINQ</code>（Language Integrated Query）中，委托用于定义查询操作。而<code>Lambda</code>表达式实质上是一种特殊的委托，以一种更简洁和强大的方式定义匿名函数。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        List&lt;<span class="built_in">int</span>&gt; numbers = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt; &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span> &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义一个委托，检查一个数是否为偶数</span></span><br><span class="line">        Func&lt;<span class="built_in">int</span>, <span class="built_in">bool</span>&gt; isEven = x =&gt; x % <span class="number">2</span> == <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用LINQ和委托找出所有偶数</span></span><br><span class="line">        IEnumerable&lt;<span class="built_in">int</span>&gt; evens = numbers.Where(isEven);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印所有的偶数</span></span><br><span class="line">        <span class="keyword">foreach</span> (<span class="built_in">int</span> number <span class="keyword">in</span> evens)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(number);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，在<code>C#</code>中，不一定非要使用<code>delegate</code>关键字来定义委托。其实，<code>Func&lt;T, TResult&gt;</code>、<code>Action&lt;T&gt;</code>等都是内置的委托类型，你可以直接使用它们，而无需使用<code>delegate</code>关键字。（<code>C#</code>中内置的委托类型）</p><p>（6）定制或扩展方法：在<code>C#</code>中，我们可以利用委托去定制或扩展方法，改变其行为或增加新的功能。例如，我们可以使用委托来定制比较方法，从而对集合进行自定义排序。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="built_in">int</span> <span class="title">Comparison</span>&lt;<span class="keyword">in</span> <span class="title">T</span>&gt;(<span class="params">T x, T y</span>)</span>;</span><br><span class="line"></span><br><span class="line">List&lt;<span class="built_in">int</span>&gt; numbers = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt; &#123; <span class="number">5</span>, <span class="number">10</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">6</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个委托实例，传入一个比较方法</span></span><br><span class="line">Comparison&lt;<span class="built_in">int</span>&gt; comparison = (x, y) =&gt; y.CompareTo(x);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 List&lt;T&gt; 类的 Sort 方法，将委托作为参数传入</span></span><br><span class="line">numbers.Sort(comparison);</span><br><span class="line"></span><br><span class="line"><span class="comment">// numbers: &#123; 10, 8, 6, 5, 3 &#125;</span></span><br></pre></td></tr></table></figure><p>（7）（待补充）</p><hr><h3 id="9-enum-关键字"><a href="#9-enum-关键字" class="headerlink" title="9. enum 关键字"></a>9. enum 关键字</h3><p>在 <code>C#</code> 中，<a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/builtin-types/enum"><code>enum</code></a> 关键字用于声明枚举类型。</p><ul><li>枚举是一种值类型，它表示一个固定的值集合。这些值被称为枚举成员，并且每一个都有一个关联的常量值。默认情况下，第一个枚举成员的值是<code>0</code>，后续的成员值依次递增<code>1</code>，但是可以显式地改变这个顺序。</li></ul><p>假设有一个枚举类型定义了一周的天数。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">enum</span> DayOfWeek</span><br><span class="line">&#123;</span><br><span class="line">    Sunday = <span class="number">0</span>,</span><br><span class="line">    Monday = <span class="number">1</span>,</span><br><span class="line">    Tuesday = <span class="number">2</span>,</span><br><span class="line">    Wednesday = <span class="number">3</span>,</span><br><span class="line">    Thursday = <span class="number">4</span>,</span><br><span class="line">    Friday = <span class="number">5</span>,</span><br><span class="line">    Saturday = <span class="number">6</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（1）可以创建一个变量来存储当前的星期几</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">DayOfWeek today = DayOfWeek.Monday;</span><br></pre></td></tr></table></figure><p>（2）可以将枚举值转换为其他类型，例如整数或字符串</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> dayNumber = (<span class="built_in">int</span>)DayOfWeek.Friday;  <span class="comment">// 5</span></span><br><span class="line"><span class="built_in">string</span> dayName = DayOfWeek.Friday.ToString();  <span class="comment">// &quot;Friday&quot;</span></span><br></pre></td></tr></table></figure><p>（3）反过来，我们也可以将其他类型转换为枚举值</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">DayOfWeek day = (DayOfWeek)<span class="number">5</span>;  <span class="comment">// DayOfWeek.Friday</span></span><br><span class="line">DayOfWeek day = Enum.Parse&lt;DayOfWeek&gt;(<span class="string">&quot;Friday&quot;</span>);  <span class="comment">// DayOfWeek.Friday</span></span><br><span class="line"></span><br><span class="line">DayOfWeek day;</span><br><span class="line"><span class="built_in">bool</span> success = Enum.TryParse&lt;DayOfWeek&gt;(<span class="string">&quot;Sunday&quot;</span>, <span class="keyword">out</span> day); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>如果枚举表示的是一组位标志，那么应该使用<code>[Flags]</code>属性，并为枚举成员指定<code>2</code>的幂次方值。这样就可以使用位运算符来组合、添加或移除枚举值。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">Flags</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">enum</span> AccessRights</span><br><span class="line">&#123;</span><br><span class="line">    None = <span class="number">0</span>,     <span class="comment">// 0000</span></span><br><span class="line">    Read = <span class="number">1</span>,     <span class="comment">// 0001</span></span><br><span class="line">    Write = <span class="number">2</span>,    <span class="comment">// 0010</span></span><br><span class="line">    Execute = <span class="number">4</span>,  <span class="comment">// 0100</span></span><br><span class="line">    FullControl = Read | Write | Execute <span class="comment">// 0111</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>AccessRights</code>枚举定义了一组访问权限，每个权限是二进制位的一个标志。这允许我们将不同的权限组合到一起，然后通过位运算检查特定的权限是否存在。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置读和写权限</span></span><br><span class="line">AccessRights rights = AccessRights.Read | AccessRights.Write;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查是否有写权限</span></span><br><span class="line"><span class="keyword">if</span> ((rights &amp; AccessRights.Write) == AccessRights.Write)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;有写权限&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;无写权限&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了位运算符的使用，也可以直接使用<code>HasFlag</code>方法来检查特定的权限是否存在。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">AccessRights rights = AccessRights.Read | AccessRights.Write;</span><br><span class="line"></span><br><span class="line">rights.HasFlag(AccessRights.Write) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><hr><h3 id="10-event-关键字"><a href="#10-event-关键字" class="headerlink" title="10. event 关键字"></a>10. event 关键字</h3><p>在<code>C#</code>中，<a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/event"><code>event</code></a>关键字用于声明一个事件。（<a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/programming-guide/events/how-to-publish-events-that-conform-to-net-framework-guidelines">如何发布符合 .NET 准则的事件</a>）</p><ul><li>事件是由对象在特殊情况下触发的一种机制，例如用户点击了一个按钮，或者某个操作已经完成。对象可以订阅这个事件，这样当事件发生时，就会调用订阅者定义的事件处理程序。</li></ul><p>在事件的定义中，通常会有两部分组成。一部分是声明事件的委托（<code>delegate</code>），另一部分是事件本身。下面是一个简单的<code>event</code>使用例子：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个委托</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">MyEventHandler</span>(<span class="params"><span class="built_in">string</span> message</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Publisher</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 声明一个事件</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">event</span> MyEventHandler MyEvent;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">RaiseEvent</span>(<span class="params"><span class="built_in">string</span> message</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 触发事件</span></span><br><span class="line">        MyEvent?.Invoke(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Subscriber</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Subscribe</span>(<span class="params">Publisher publisher</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 订阅事件</span></span><br><span class="line">        publisher.MyEvent += HandleEvent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">HandleEvent</span>(<span class="params"><span class="built_in">string</span> message</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;收到了来自Publisher的消息： <span class="subst">&#123;message&#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> publisher = <span class="keyword">new</span> Publisher();</span><br><span class="line">        <span class="keyword">var</span> subscriber = <span class="keyword">new</span> Subscriber();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 订阅事件</span></span><br><span class="line">        subscriber.Subscribe(publisher);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发布事件</span></span><br><span class="line">        publisher.RaiseEvent(<span class="string">&quot;Hello, World!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面例子可以看出，事件帮助了事件发布者和订阅者之间的解耦。发布者并不需要知道谁订阅了它的事件，也不需要知道事件将如何被处理。这使得我们可以独立地修改发布者和订阅者的代码，而不需要担心它们之间的依赖关系。</p><p><code>event</code>关键字使用注意点：</p><p>（1）如果一个对象订阅了另一个对象的事件，那么在不需要订阅事件时应当及时取消订阅，以避免发生内存泄漏。（只要事件发布者还在内存中，订阅者就不会被垃圾回收，即使订阅者已经不再使用）</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Subscriber</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Subscribe</span>(<span class="params">Publisher publisher</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        publisher.MyEvent += HandleEvent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Unsubscribe</span>(<span class="params">Publisher publisher</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        publisher.MyEvent -= HandleEvent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">HandleEvent</span>(<span class="params"><span class="built_in">object</span> sender, MyEventArgs e</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;收到了来自Publisher的消息： <span class="subst">&#123;e.Message&#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）还有事件的访问器（Event Accessors），委托类型（System.EventHandler）等等（待补充）</p><hr><h3 id="11-explicit-关键字"><a href="#11-explicit-关键字" class="headerlink" title="11. explicit 关键字"></a>11. explicit 关键字</h3><p>在<code>C#</code>中，<a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/user-defined-conversion-operators"><code>explicit</code></a>关键字用于类型转换。</p><ul><li><p><code>explicit</code>关键字通常用在用户定义的类型转换操作中，允许从一种数据类型转换到另一种数据类型，例如从类到接口，或者从父类到子类等等。</p></li><li><p>在某些情况下，转换操作可能导致数据丢失或抛出异常。使用<code>explicit</code>关键字可以强制开发者明确地处理转换，从而减少在转换过程中出现错误的可能性。</p></li></ul><p>下面是一个<code>explicit</code>关键字的例子：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Fahrenheit</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> Temperature &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 推荐用 lambda 表达式写</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">Celsius</span>(<span class="params">Fahrenheit f</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> ConvertToFahrenheit(f);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Celsius <span class="title">ConvertToFahrenheit</span>(<span class="params">Fahrenheit f</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">float</span> celsiusTemperature = (<span class="number">5.0f</span> / <span class="number">9.0f</span>) * (f.Temperature - <span class="number">32</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Celsius(celsiusTemperature);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Celsius</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> Temperature &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Celsius</span>(<span class="params"><span class="built_in">float</span> temp</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Temperature = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Fahrenheit f = <span class="keyword">new</span> Fahrenheit &#123; Temperature = <span class="number">100</span> &#125;;</span><br><span class="line">Celsius c = (Celsius)f;  <span class="comment">// 显式转换</span></span><br></pre></td></tr></table></figure><p>上面例子中，不能直接将<code>Fahrenheit</code>对象转换为<code>Celsius</code>，必须明确地进行转换。</p><hr><h3 id="12-foreach-关键字"><a href="#12-foreach-关键字" class="headerlink" title="12. foreach 关键字"></a>12. foreach 关键字</h3><p>在<code>C#</code>中，<code>foreach</code>关键字用于遍历集合（如数组，列表等）中的元素。</p><ul><li>它的工作原理是通过调用集合对象的<code>GetEnumerator</code>方法来获取<code>IEnumerator</code>或<code>IEnumerator&lt;T&gt;</code>对象，然后在每次迭代中调用<code>MoveNext</code>方法和<code>Current</code>属性。</li></ul><p>（注意，后面<code>IEnumerator</code>和<code>IEnumerator&lt;T&gt;</code>统称为枚举器）</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fibNumbers = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt; &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">13</span> &#125;;</span><br><span class="line"><span class="keyword">foreach</span> (<span class="built_in">int</span> element <span class="keyword">in</span> fibNumbers)</span><br><span class="line">&#123;</span><br><span class="line">    Console.Write(<span class="string">$&quot;<span class="subst">&#123;element&#125;</span> &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// 0 1 1 2 3 5 8 13</span></span><br></pre></td></tr></table></figure><p>下面是一些<code>foreach</code>关键字的使用方法：</p><p>（1）实现枚举器接口的集合</p><p>在<code>C#</code>中，许多内置集合类型都实现了枚举器接口，这使得它们可以使用<code>foreach</code>循环进行迭代。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Dictionary&lt;<span class="built_in">string</span>, <span class="built_in">int</span>&gt; dictionary = <span class="keyword">new</span> Dictionary&lt;<span class="built_in">string</span>, <span class="built_in">int</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    &#123; <span class="string">&quot;One&quot;</span>, <span class="number">1</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;Two&quot;</span>, <span class="number">2</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;Three&quot;</span>, <span class="number">3</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span> (KeyValuePair&lt;<span class="built_in">string</span>, <span class="built_in">int</span>&gt; item <span class="keyword">in</span> dictionary)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">$&quot;Key: <span class="subst">&#123;item.Key&#125;</span>, Value: <span class="subst">&#123;item.Value&#125;</span>&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类似结构：数组，列表(List<T>)，字典(Dictionary&lt;TKey, TValue&gt;)，哈希集(HashSet<T>)，队列(Queue<T>)，堆栈(Stack<T>)，链表(LinkedList<T>)等等。</p><p>（2）实现枚举器接口的自定义类</p><p>如果想要自定义类能够被<code>foreach</code>循环遍历，需要实现枚举器接口。这个接口定义了一个方法，<code>GetEnumerator</code>，返回一个实现了枚举器接口的对象。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyCollection</span> : <span class="title">IEnumerable</span>&lt;<span class="title">int</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span>[] data = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IEnumerator&lt;<span class="built_in">int</span>&gt; <span class="title">GetEnumerator</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; data.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">return</span> data[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    IEnumerator IEnumerable.GetEnumerator()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> GetEnumerator();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用自定义集合</span></span><br><span class="line">MyCollection collection = <span class="keyword">new</span> MyCollection();</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span> (<span class="built_in">int</span> number <span class="keyword">in</span> collection)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(number);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（3）异步流的迭代<br>异步流的迭代是<code>C# 8.0</code>新增的特性，这使得我们能够在处理异步操作时，写出更高效和更易于理解的代码。异步流的迭代通过<code>await foreach</code>关键字实现。它能够异步地迭代这样的序列，而不会阻塞主线程。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">async</span> IAsyncEnumerable&lt;<span class="built_in">int</span>&gt; <span class="title">GenerateSequence</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">await</span> Task.Delay(<span class="number">100</span>);  <span class="comment">// 模拟异步操作</span></span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">TestAsyncStream</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="keyword">foreach</span> (<span class="function"><span class="keyword">var</span> number <span class="keyword">in</span> <span class="title">GenerateSequence</span>())</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(number);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述示例中，<code>GenerateSequence</code>方法生成了一个异步序列。每个元素都是在等待一段时间后生成的，以模拟异步操作。<code>TestAsyncStream</code>方法使用<code>await foreach</code>语句来异步地迭代这个序列。每次迭代都会异步地等待下一个元素。</p><hr><h3 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h3><blockquote><p>文件还未上传 Github</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ES6学习笔记 • 下</title>
      <link href="/posts/461e57d3.html"/>
      <url>/posts/461e57d3.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>本读书笔记节选自阮一峰编写的 <a href="https://es6.ruanyifeng.com/">《ECMAScript 6 入门教程》</a>。适合已经掌握 <code>ES5</code> 的读者，用来了解这门语言的最新发展。笔记内容仅包括日常开发中可能会用到的概念，剩余部分请自行阅读。</p></blockquote><hr><h2 id="20-async-函数"><a href="#20-async-函数" class="headerlink" title="20. async 函数"></a>20. async 函数</h2><h3 id="20-1-含义"><a href="#20-1-含义" class="headerlink" title="20.1 含义"></a>20.1 含义</h3><p><code>ES6</code>引入的 <code>async</code> 函数，使得异步操作变得更加方便。简单来说，<code>async</code> 函数就是 <code>Generator</code> 函数的语法糖。它将 <code>Generator</code>函数的星号<code>*</code>替换成<code>async</code>，<code>yield</code>替换成<code>await</code>。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> readFile = <span class="keyword">function</span> (<span class="params">fileName</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">    fs.<span class="title function_">readFile</span>(fileName, <span class="keyword">function</span>(<span class="params">error, data</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (error) <span class="keyword">return</span> <span class="title function_">reject</span>(error);</span><br><span class="line">      <span class="title function_">resolve</span>(data);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> gen = <span class="keyword">function</span>* () &#123;</span><br><span class="line">  <span class="keyword">const</span> f1 = <span class="keyword">yield</span> <span class="title function_">readFile</span>(<span class="string">&#x27;/etc/fstab&#x27;</span>);</span><br><span class="line">  <span class="keyword">const</span> f2 = <span class="keyword">yield</span> <span class="title function_">readFile</span>(<span class="string">&#x27;/etc/shells&#x27;</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(f1.<span class="title function_">toString</span>());</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(f2.<span class="title function_">toString</span>());</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面代码中，函数<code>gen</code>依次读取两个文件，如果写成<code>async</code>函数，就是下面这样。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> asyncReadFile = <span class="keyword">async</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> f1 = <span class="keyword">await</span> <span class="title function_">readFile</span>(<span class="string">&#x27;/etc/fstab&#x27;</span>);</span><br><span class="line">  <span class="keyword">const</span> f2 = <span class="keyword">await</span> <span class="title function_">readFile</span>(<span class="string">&#x27;/etc/shells&#x27;</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(f1.<span class="title function_">toString</span>());</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(f2.<span class="title function_">toString</span>());</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>async</code>函数对 <code>Generator</code> 函数的改进，体现在以下四点：</p><ol><li>内置执行器: <code>Generator</code> 函数的执行必须靠执行器（<code>co</code>模块），而<code>async</code>函数自带执行器。也就是说，<code>async</code>函数的执行，与普通函数一模一样。</li><li>更好的语义: <code>async</code>和<code>await</code>，比起星号和<code>yield</code>，语义更清楚了。<code>async</code>表示函数里有异步操作，<code>await</code>表示紧跟在后面的表达式需要等待结果。</li><li>更广的适用性: <code>co</code>模块约定，<code>yield</code>命令后面只能是 <code>Thunk</code> 函数或 <code>Promise</code> 对象，而<code>async</code>函数的<code>await</code>命令后面，可以是 <code>Promise</code> 对象和原始类型的值。（数值、字符串和布尔值，但会自动转成立即 <code>resolved</code> 的 <code>Promise</code> 对象）</li><li>返回值是 Promise: <ins><code>async</code>函数的返回值是 <code>Promise</code> 对象</ins>，这比 <code>Generator</code> 函数的返回值是 <code>Iterator</code> 对象方便，可以用<code>then</code>方法指定下一步的操作。</li></ol><p>进一步说，<code>async</code>函数可以看作多个异步操作，包装成的一个 <code>Promise</code> 对象，而<code>await</code>命令就是可以替代<code>then</code>的语法糖。下面的 <code>Promise</code> 链可以被重写为一个 <code>async</code> 函数。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">fetch</span>(<span class="string">&#x27;https://api.example.com/data&#x27;</span>)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> response.<span class="title function_">json</span>())</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(data))</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function"><span class="params">error</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;Error:&#x27;</span>, error));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">fetchData</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> response = <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="string">&#x27;https://api.example.com/data&#x27;</span>);</span><br><span class="line">    <span class="keyword">let</span> data = <span class="keyword">await</span> response.<span class="title function_">json</span>();</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;Error:&#x27;</span>, error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="20-2-基本用法"><a href="#20-2-基本用法" class="headerlink" title="20.2 基本用法"></a>20.2 基本用法</h3><p><ins><code>async</code>函数返回一个 <code>Promise</code> 对象，可以使用<code>then</code>方法添加回调函数</ins>。当函数执行的时候，<ins>遇到<code>await</code>就会暂停当前的<code>async</code>函数执行，等到异步操作完成，再接着执行函数体内后面的语句</ins>。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">fetchUserData</span>(<span class="params">userId</span>) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 这里假设我们有一个返回Promise的fetch函数</span></span><br><span class="line">    <span class="keyword">const</span> response = <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="string">`https://api.example.com/user/<span class="subst">$&#123;userId&#125;</span>`</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 需要检查响应是否ok，如果不ok则抛出错误</span></span><br><span class="line">    <span class="keyword">if</span> (!response.<span class="property">ok</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">`HTTP error! status: <span class="subst">$&#123;response.status&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> user = <span class="keyword">await</span> response.<span class="title function_">json</span>(); <span class="comment">// 假设服务器响应的是JSON数据</span></span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">`There was a problem with the fetch operation: <span class="subst">$&#123;error.message&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用这个函数</span></span><br><span class="line"><span class="title function_">fetchUserData</span>(<span class="number">123</span>)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function"><span class="params">user</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(user))</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function"><span class="params">error</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">error</span>(error));</span><br></pre></td></tr></table></figure><p>上面代码中，<code>fetchUserData</code>是一个异步函数，它使用<code>fetchAPI</code>从服务器获取数据，然后使用<code>await</code>关键字等待<code>Promise</code>解决。注意，在异步函数中，我们应该始终使用<code>try/catch</code>来捕获可能出现的错误。</p><p><code>async</code>函数有多种使用形式。它可以作为声明，作为表达式，还可以用来定义对象或类的方法。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数表达式</span></span><br><span class="line"><span class="keyword">const</span> foo = <span class="keyword">async</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象的方法</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123; <span class="keyword">async</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;&#125; &#125;;</span><br><span class="line">obj.<span class="title function_">foo</span>().<span class="title function_">then</span>(...)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Class 的方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Storage</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">cachePromise</span> = caches.<span class="title function_">open</span>(<span class="string">&#x27;avatars&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">async</span> <span class="title function_">getAvatar</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> cache = <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="property">cachePromise</span>;</span><br><span class="line">    <span class="keyword">return</span> cache.<span class="title function_">match</span>(<span class="string">`/avatars/<span class="subst">$&#123;name&#125;</span>.jpg`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> storage = <span class="keyword">new</span> <span class="title class_">Storage</span>();</span><br><span class="line">storage.<span class="title function_">getAvatar</span>(<span class="string">&#x27;jake&#x27;</span>).<span class="title function_">then</span>(…);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 箭头函数</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">foo</span> = <span class="keyword">async</span> (<span class="params"></span>) =&gt; &#123;&#125;;</span><br></pre></td></tr></table></figure><hr><h3 id="20-3-语法"><a href="#20-3-语法" class="headerlink" title="20.3 语法"></a>20.3 语法</h3><p><code>async</code>函数的语法规则总体上比较简单，难点是错误处理机制。</p><p><strong>（1）返回 Promise 对象</strong></p><p><ins><code>async</code>函数返回一个 <code>Promise</code> 对象</ins>（不管有没有<code>return</code>语句，总是返回一个 <code>Promise</code> 对象）。<ins><code>async</code>函数内部<code>return</code>语句返回的值，会成为<code>then</code>方法回调函数的参数</ins>。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;hello world&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">f</span>().<span class="title function_">then</span>(<span class="function"><span class="params">v</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(v))</span><br><span class="line"><span class="comment">// &quot;hello world&quot;</span></span><br></pre></td></tr></table></figure><p>上面代码中，函数<code>f</code>内部<code>return</code>命令返回的值，会被<code>then</code>方法回调函数接收到。</p><p><ins><code>async</code>函数内部抛出错误，会导致返回的 <code>Promise</code> 对象变为<code>reject</code>状态</ins>。抛出的错误对象会被<code>catch</code>方法回调函数接收到。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;出错了&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">f</span>()</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function"><span class="params">v</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;resolve&#x27;</span>, v))</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function"><span class="params">e</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;reject&#x27;</span>, e))</span><br></pre></td></tr></table></figure><p><strong>（2）Promise 对象的状态变化</strong></p><p><code>async</code>函数返回的 <code>Promise</code> 对象，必须等到内部所有<code>await</code>命令后面的 <code>Promise</code> 对象执行完，才会发生状态改变，除非遇到<code>return</code>语句或者抛出错误。也就是说，<ins>只有<code>async</code>函数内部的异步操作执行完，才会执行<code>then</code>方法指定的回调函数</ins>。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">asyncFunc</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> response = <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="string">&#x27;https://api.example.com/data&#x27;</span>);</span><br><span class="line">    <span class="keyword">const</span> data = <span class="keyword">await</span> response.<span class="title function_">json</span>();</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">asyncFunc</span>()</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(data))</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function"><span class="params">error</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">error</span>(error));</span><br></pre></td></tr></table></figure><p>上面代码中，<code>then</code>方法的回调函数会等到<code>asyncFunc</code>函数内部的两个<code>await</code>操作都完成后才会被调用。</p><p><strong>（3）await 命令</strong></p><p>正常情况下，<ins><code>await</code>命令后面是一个 <code>Promise</code> 对象，返回该对象的结果。如果不是 <code>Promise</code> 对象，就直接返回对应的值</ins>。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 等同于</span></span><br><span class="line">  <span class="comment">// return 123;</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">await</span> <span class="number">123</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">f</span>().<span class="title function_">then</span>(<span class="function"><span class="params">v</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(v))</span><br><span class="line"><span class="comment">// 123</span></span><br></pre></td></tr></table></figure><p>另一种情况是，<code>await</code>命令后面是一个<code>thenable</code>对象（即定义了<code>then</code>方法的对象，详细请看<code>Promise</code>章节的<code>resolve()</code>方法），那么<code>await</code>会将其等同于 <code>Promise</code> 对象。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> thenable = &#123;</span><br><span class="line">  <span class="attr">then</span>: <span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="string">&#x27;Resolved!&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">asyncFunc</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="keyword">await</span> thenable;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(result);  <span class="comment">// &#x27;Resolved!&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">asyncFunc</span>();</span><br><span class="line"><span class="comment">// 1000</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>thenable</code>对象有一个<code>then</code>方法，所以可以在<code>asyncFunc</code>函数中使用<code>await</code>来等待它。<ins>当<code>JS</code>引擎看到我们试图等待一个<code>thenable</code>对象时，它会自动调用该对象的<code>then</code>方法</ins>，并等待该方法调用其<code>resolve</code>参数所传入的值。</p><p>如果<ins><code>await</code>命令后面的 <code>Promise</code> 对象如果变为<code>reject</code>状态，则<code>reject</code>的参数会被<code>catch</code>方法的回调函数接收到</ins>。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="string">&#x27;出错了&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">f</span>()</span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">v</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(v))</span><br><span class="line">.<span class="title function_">catch</span>(<span class="function"><span class="params">e</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(e))</span><br><span class="line"><span class="comment">// 出错了</span></span><br></pre></td></tr></table></figure><p>注意，上面代码中<code>await</code>语句前面没有<code>return</code>，但是<code>reject</code>方法的参数依然传入了<code>catch</code>方法的回调函数。这里如果在<code>await</code>前面加上<code>return</code>，效果是一样的。</p><p><ins>任何一个<code>await</code>语句后面的 <code>Promise</code> 对象变为<code>reject</code>状态，不会导致整个 <code>async</code> 函数立即停止执行，而是会抛出异常。我们可以用 <code>try/catch</code> 语句来捕获这个异常并处理它。</ins>（如果没有错误处理机制，<code>async</code>函数会中断执行）</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 情况 1</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="string">&#x27;出错了&#x27;</span>);</span><br><span class="line">  <span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&#x27;hello world&#x27;</span>); <span class="comment">// 不会执行</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 情况 2</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">asyncFunc</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> response = <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="string">&#x27;https://api.example.com/data&#x27;</span>);</span><br><span class="line">    <span class="keyword">let</span> data = <span class="keyword">await</span> response.<span class="title function_">json</span>();</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;Error:&#x27;</span>, error);</span><br><span class="line">    <span class="comment">// 这里可以处理错误，并决定如何继续执行</span></span><br><span class="line">    <span class="comment">// 比如可以重新抛出错误，或者返回一个默认值，等等</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有时我们希望<ins>即使前一个异步操作失败，也不要中断后面的异步操作</ins>。我们可以将<code>await</code>放在<code>try...catch</code>结构里面，这样不管这个异步操作是否成功，下一个<code>await</code>都会执行。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="string">&#x27;出错了&#x27;</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(e);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&#x27;hello world&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">f</span>()</span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">v</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(v))</span><br><span class="line"><span class="comment">// 出错了</span></span><br><span class="line"><span class="comment">// hello world</span></span><br></pre></td></tr></table></figure><p>另一种方法是<code>await</code>后面的 <code>Promise</code> 对象再跟一个<code>catch</code>方法，处理前面可能出现的错误。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="string">&#x27;出错了&#x27;</span>)</span><br><span class="line">    .<span class="title function_">catch</span>(<span class="function"><span class="params">e</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(e));</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&#x27;hello world&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">f</span>()</span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">v</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(v))</span><br><span class="line"><span class="comment">// 出错了</span></span><br><span class="line"><span class="comment">// hello world</span></span><br></pre></td></tr></table></figure><p>这种方法的优点是它更加紧凑，不需要显式地使用<code>try/catch</code>。但它的缺点是需要确保每个可能产生错误的<code>await</code>都有一个<code>catch</code>方法，否则错误可能会被忽视。</p><p><strong>（4）错误处理</strong></p><p>如果<ins><code>await</code>后面的异步操作出错，那么等同于<code>async</code>函数返回的 <code>Promise</code> 对象被<code>reject</code></ins>。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">asyncFunc</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> response = <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="string">&#x27;https://api.example.com/data&#x27;</span>);</span><br><span class="line">  <span class="comment">// 如果 fetch 出错（例如，由于网络问题），那么下面的代码将不会被执行</span></span><br><span class="line">  <span class="keyword">let</span> data = <span class="keyword">await</span> response.<span class="title function_">json</span>();</span><br><span class="line">  <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">asyncFunc</span>()</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(data))</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function"><span class="params">error</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;Error:&#x27;</span>, error));</span><br><span class="line">  <span class="comment">// 如果 asyncFunc 在任何地方抛出了一个错误，那么这个 .catch 将会捕获到</span></span><br></pre></td></tr></table></figure><p>上面代码中，如果<code>fetch</code>函数抛出一个错误，那么<code>asyncFunc</code>会立即停止执行并抛出一个错误，导致它返回的<code>Promise</code>变为<code>rejected</code>状态。这个错误然后被<code>catch</code>捕获并处理。</p><p>防止出错的方法，就是将其放在<code>try...catch</code>代码块之中。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;出错了&#x27;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(e);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">await</span>(<span class="string">&#x27;hello world&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果有多个<code>await</code>命令，可以统一放在<code>try...catch</code>结构中。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> val1 = <span class="keyword">await</span> <span class="title function_">firstStep</span>();</span><br><span class="line">    <span class="keyword">const</span> val2 = <span class="keyword">await</span> <span class="title function_">secondStep</span>(val1);</span><br><span class="line">    <span class="keyword">const</span> val3 = <span class="keyword">await</span> <span class="title function_">thirdStep</span>(val1, val2);</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Final: &#x27;</span>, val3);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(err);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，上面三个异步操作是串行处理，即<code>secondStep</code>将在<code>firstStep</code>完成后开始。如果这三个操作之间没有依赖关系，可以使用<code>Promise.all()</code>并行执行以提高效率。</p><p><strong>（5）使用注意点</strong></p><p>第一点，<code>await</code>命令后面的<code>Promise</code>对象，运行结果可能是<code>rejected</code>，所以<ins>最好把<code>await</code>命令放在<code>try...catch</code>代码块中</ins>。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">myFunction</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">somethingThatReturnsAPromise</span>();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(err);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 另一种写法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">myFunction</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="title function_">somethingThatReturnsAPromise</span>()</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="keyword">function</span> (<span class="params">err</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(err);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二点，<ins>多个<code>await</code>命令后面的异步操作，如果不存在继发关系，最好让它们同时触发</ins>。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> foo = <span class="keyword">await</span> <span class="title function_">getFoo</span>();</span><br><span class="line"><span class="keyword">let</span> bar = <span class="keyword">await</span> <span class="title function_">getBar</span>();</span><br></pre></td></tr></table></figure><p>上面代码中，<code>getFoo</code>和<code>getBar</code>是两个独立的异步操作（即互不依赖），被写成继发关系。这样比较耗时，因为只有<code>getFoo</code>完成以后，才会执行<code>getBar</code>，完全可以让它们同时触发。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="keyword">let</span> [foo, bar] = <span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">all</span>([<span class="title function_">getFoo</span>(), <span class="title function_">getBar</span>()]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="keyword">let</span> fooPromise = <span class="title function_">getFoo</span>();</span><br><span class="line"><span class="keyword">let</span> barPromise = <span class="title function_">getBar</span>();</span><br><span class="line"><span class="keyword">let</span> foo = <span class="keyword">await</span> fooPromise;</span><br><span class="line"><span class="keyword">let</span> bar = <span class="keyword">await</span> barPromise;</span><br></pre></td></tr></table></figure><p>上面两种写法，<code>getFoo</code>和<code>getBar</code>都是同时触发，这样就会缩短程序的执行时间。</p><p>第三点，<code>await</code>命令只能用在<code>async</code>函数之中，如果用在普通函数，就会报错。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">dbFuc</span>(<span class="params">db</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 报错</span></span><br><span class="line">  docs.<span class="title function_">forEach</span>(<span class="keyword">function</span> (<span class="params">doc</span>) &#123;</span><br><span class="line">    <span class="keyword">await</span> db.<span class="title function_">post</span>(doc);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码会报错，因为<code>await</code>用在普通函数之中。但是，就算将<code>forEach</code>方法的参数改成<code>async</code>函数也有问题。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">dbFuc</span>(<span class="params">db</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 可能得到错误结果</span></span><br><span class="line">  docs.<span class="title function_">forEach</span>(<span class="keyword">async</span> <span class="keyword">function</span> (<span class="params">doc</span>) &#123;</span><br><span class="line">    <span class="keyword">await</span> db.<span class="title function_">post</span>(doc);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码可能不会正常工作，原因是这时三个<code>db.post()</code>操作将是并发执行（<code>forEach</code> 不会等待回调函数），也就是同时执行，而不是继发执行。正确的写法是采用<code>for</code>循环。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">dbFuc</span>(<span class="params">db</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> doc <span class="keyword">of</span> docs) &#123;</span><br><span class="line">    <span class="keyword">await</span> db.<span class="title function_">post</span>(doc);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一种方法是使用数组的<a href="https://www.javascripttutorial.net/javascript-array-reduce/"><code>reduce()</code></a>方法来逐个顺序处理数组中的元素。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">dbFunc</span>(<span class="params">db</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> docs.<span class="title function_">reduce</span>(<span class="keyword">async</span> (prevPromise, doc) =&gt; &#123;</span><br><span class="line">        <span class="keyword">await</span> prevPromise;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">await</span> db.<span class="title function_">post</span>(doc);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&quot;An error occurred: &quot;</span>, error);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="title class_">Promise</span>.<span class="title function_">resolve</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，传递给<code>reduce()</code>的函数返回一个<code>Promise</code>，这个<code>Promise</code>在前一个 <code>Promise</code>解析之后开始另一项数据库操作。我们使用<code>Promise.resolve()</code>作为初始值，以开始 <code>Promise</code>链。</p><p>如果希望<ins>多个请求并发执行，可以使用<code>Promise.all()</code>方法</ins>。下面两种写法效果相同。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">dbFuc</span>(<span class="params">db</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];</span><br><span class="line">  <span class="keyword">let</span> promises = docs.<span class="title function_">map</span>(<span class="function">(<span class="params">doc</span>) =&gt;</span> db.<span class="title function_">post</span>(doc));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> results = <span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">all</span>(promises);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(results);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者使用下面的写法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">dbFuc</span>(<span class="params">db</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];</span><br><span class="line">  <span class="keyword">let</span> promises = docs.<span class="title function_">map</span>(<span class="function">(<span class="params">doc</span>) =&gt;</span> db.<span class="title function_">post</span>(doc));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> results = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> promise <span class="keyword">of</span> promises) &#123;</span><br><span class="line">    results.<span class="title function_">push</span>(<span class="keyword">await</span> promise);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(results);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第四点，<code>async</code> 函数可以保留运行堆栈。它会在等待<code>Promise</code>解析期间暂停函数的执行，而不是在全局范围内阻止执行，这使得调试工具能够在可能发生错误的地方停下来。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">a</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="title function_">b</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="title function_">c</span>());</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面代码中，假定函数<code>a</code>内部运行了一个异步任务<code>b()</code>。当<code>b()</code>运行的时候，函数<code>a()</code>不会中断，而是继续执行。<ins>等到<code>b()</code>运行结束，可能<code>a()</code>早就运行结束了，<code>b()</code>所在的上下文环境已经消失了</ins>。如果<code>b()</code>或<code>c()</code>报错，<a href="https://zhuanlan.zhihu.com/p/26637923">错误堆栈</a>将不包括<code>a()</code>。</p><p>现在将这个例子改成<code>async</code>函数。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">a</span> = <span class="keyword">async</span> (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="title function_">b</span>();</span><br><span class="line">  <span class="title function_">c</span>();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>b()</code>运行的时候，<code>a()</code>是暂停执行，上下文环境都保存着。一旦<code>b()</code>或<code>c()</code>报错，错误堆栈将包括<code>a()</code>。</p><hr><h3 id="20-4-async-函数实现原理"><a href="#20-4-async-函数实现原理" class="headerlink" title="20.4 async 函数实现原理"></a>20.4 async 函数实现原理</h3><p><code>async</code> 函数的实现原理，就是将 <code>Generator</code> 函数和自动执行器，包装在一个函数里。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">args</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">args</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">spawn</span>(<span class="keyword">function</span>* () &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所有的<code>async</code>函数都可以写成上面的第二种形式，其中的<code>spawn</code>函数就是自动执行器。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">spawn</span>(<span class="params">genF</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> gen = <span class="title function_">genF</span>(); <span class="comment">// 建立 Generater 函数</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">step</span>(<span class="params">nextF</span>) &#123; <span class="comment">// nextF 是一个 Generater 函数</span></span><br><span class="line">      <span class="keyword">let</span> next;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        next = <span class="title function_">nextF</span>(); <span class="comment">// 启动 Generater，返回当前状态，运行至下一个 yield</span></span><br><span class="line">      &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">reject</span>(e);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(next.<span class="property">done</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">resolve</span>(next.<span class="property">value</span>); <span class="comment">// 结束执行器</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(next.<span class="property">value</span>).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">v</span>) &#123;</span><br><span class="line">        <span class="title function_">step</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123; <span class="keyword">return</span> gen.<span class="title function_">next</span>(v); &#125;); <span class="comment">// 开始递归</span></span><br><span class="line">      &#125;, <span class="keyword">function</span>(<span class="params">e</span>) &#123;</span><br><span class="line">        <span class="title function_">step</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123; <span class="keyword">return</span> gen.<span class="keyword">throw</span>(e); &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 传递一个 function，用来启动 Generater，第一次传参是无效的</span></span><br><span class="line">    <span class="title function_">step</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123; <span class="keyword">return</span> gen.<span class="title function_">next</span>(<span class="literal">undefined</span>); &#125;); </span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="20-5-异步处理方法的比较"><a href="#20-5-异步处理方法的比较" class="headerlink" title="20.5 异步处理方法的比较"></a>20.5 异步处理方法的比较</h3><p>通过一个例子，我们来看看 <code>async</code> 函数与 <code>Promise</code>、<code>Generator</code> 函数的比较。</p><ul><li>假定某个 <code>DOM</code> 元素上面，部署了一系列的动画，前一个动画结束，才能开始后一个。如果当中有一个动画出错，就不再往下执行，返回上一个成功执行的动画的返回值。</li></ul><p>首先是 <code>Promise</code> 的写法。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">chainAnimationsPromise</span>(<span class="params">elem, animations</span>) &#123;</span><br><span class="line">  <span class="comment">// 变量 ret 用来保存上一个动画的返回值</span></span><br><span class="line">  <span class="keyword">let</span> ret = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始化一个已解决的 Promise</span></span><br><span class="line">  <span class="keyword">let</span> p = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 遍历 animations 数组中的每个动画</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> anim <span class="keyword">of</span> animations) &#123;</span><br><span class="line">    <span class="comment">// 将每个动画链接到 Promise 链</span></span><br><span class="line">    p = p.<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">val</span>) &#123; </span><br><span class="line">      <span class="comment">// 保存前一个动画的解决值</span></span><br><span class="line">      ret = val; </span><br><span class="line">      <span class="comment">// 执行当前动画并返回新的 Promise</span></span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">anim</span>(elem);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 任何一个动画的 Promise 被拒绝，将被 catch 捕捉</span></span><br><span class="line">  <span class="keyword">return</span> p.<span class="title function_">catch</span>(<span class="keyword">function</span>(<span class="params">e</span>) &#123;</span><br><span class="line">    <span class="comment">/* 忽略错误，继续执行 */</span></span><br><span class="line">  &#125;).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然 <code>Promise</code> 的写法比回调函数的写法大大改进，但是一眼看上去，代码完全都是 <code>Promise</code> 的 <code>API</code>，操作本身的语义反而不容易看出来。</p><p>接着是 <code>Generator</code> 函数的写法。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">chainAnimationsGenerator</span>(<span class="params">elem, animations</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">spawn</span>(<span class="keyword">function</span>*() &#123;</span><br><span class="line">    <span class="keyword">let</span> ret = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> anim <span class="keyword">of</span> animations) &#123;</span><br><span class="line">        ret = <span class="keyword">yield</span> <span class="title function_">anim</span>(elem);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="comment">/* 忽略错误，继续执行 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码使用 <code>Generator</code> 函数遍历了每个动画，语义比 <code>Promise</code> 写法更清晰，用户定义的操作全部都写在<code>spawn</code>函数的内部。但是，这个写法必须提供一个任务运行器，自动执行 <code>Generator</code> 函数，而且必须保证<code>yield</code>语句后面的表达式返回一个 <code>Promise</code>。</p><p>最后是 <code>async</code> 函数的写法。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">chainAnimationsAsync</span>(<span class="params">elem, animations</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> ret = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> anim <span class="keyword">of</span> animations) &#123;</span><br><span class="line">      ret = <span class="keyword">await</span> <span class="title function_">anim</span>(elem);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">    <span class="comment">/* 忽略错误，继续执行 */</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到 <code>Async</code> 函数的实现最简洁，最符合语义。它将 <code>Generator</code> 写法中的自动执行器，改在语言层面提供，不暴露给用户，因此代码量最少。</p><hr><h3 id="20-6-按顺序完成异步操作"><a href="#20-6-按顺序完成异步操作" class="headerlink" title="20.6 按顺序完成异步操作"></a>20.6 按顺序完成异步操作</h3><p>实际开发中，会遇到一组异步操作需要按照顺序完成的情况。比如，依次远程读取一组 <code>URL</code>，然后按照读取的顺序输出结果。</p><p><code>Promise</code> 的写法如下。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">logInOrder</span>(<span class="params">urls</span>) &#123;</span><br><span class="line">  <span class="comment">// 远程读取所有URL</span></span><br><span class="line">  <span class="keyword">const</span> textPromises = urls.<span class="title function_">map</span>(<span class="function"><span class="params">url</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">fetch</span>(url).<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> response.<span class="title function_">text</span>());</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 按次序输出</span></span><br><span class="line">  <span class="comment">// chain 代表当前的 Promise 链，初始值是 Promise.resolve()</span></span><br><span class="line">  textPromises.<span class="title function_">reduce</span>(<span class="function">(<span class="params">chain, textPromise</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 返回的是一个新的 Promise</span></span><br><span class="line">    <span class="keyword">return</span> chain.<span class="title function_">then</span>(<span class="function">() =&gt;</span> textPromise) <span class="comment">// 返回当前正在处理的 textPromise</span></span><br><span class="line">      .<span class="title function_">then</span>(<span class="function"><span class="params">text</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(text));</span><br><span class="line">  &#125;, <span class="title class_">Promise</span>.<span class="title function_">resolve</span>()); <span class="comment">// 初始化 Promise 链</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码使用<code>fetch</code>方法，同时远程读取一组 <code>URL</code>。每个<code>fetch</code>操作都返回一个 <code>Promise</code> 对象，放入<code>textPromises</code>数组。然后，<code>reduce</code>方法依次处理每个 <code>Promise</code> 对象，然后使用<code>then</code>，将所有 <code>Promise</code> 对象连起来，因此就可以依次输出结果。</p><p>这种写法可读性比较差。下面是 <code>async</code> 函数实现。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">logInOrder</span>(<span class="params">urls</span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> url <span class="keyword">of</span> urls) &#123;</span><br><span class="line">    <span class="keyword">const</span> response = <span class="keyword">await</span> <span class="title function_">fetch</span>(url);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">await</span> response.<span class="title function_">text</span>());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码确实大大简化，<ins>问题是所有远程操作都是继发。只有前一个 <code>URL</code> 返回结果，才会去读取下一个 <code>URL</code></ins>，这样做效率很差，我们需要的是并发发出远程请求。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">logInOrder</span>(<span class="params">urls</span>) &#123;</span><br><span class="line">  <span class="comment">// 并发读取远程URL</span></span><br><span class="line">  <span class="keyword">const</span> textPromises = urls.<span class="title function_">map</span>(<span class="keyword">async</span> url =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> response = <span class="keyword">await</span> <span class="title function_">fetch</span>(url);</span><br><span class="line">    <span class="keyword">return</span> response.<span class="title function_">text</span>();</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 按次序输出</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> textPromise <span class="keyword">of</span> textPromises) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">await</span> textPromise);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>urls.map</code> 方法会对 <code>urls</code> 数组的每个元素执行一个异步函数，这个异步函数会远程读取<code>URL</code>，然后等待响应。所有的这些操作都在 <code>map</code> 方法调用的同时开始，所以这些操作是并发的。</p><p>注意，在这个异步函数中，<code>await fetch(url)</code> 会暂停函数的执行，直到 <code>fetch</code> 操作完成。但是，这并不会阻止其他操作，因为每个元素都在自己的异步函数中处理。因此，<code>textPromises</code> 是一个包含<code>Promise</code>的数组，每个<code>Promise</code>都代表一个正在进行的异步操作。</p><hr><h3 id="20-7-异步操作继发与并发"><a href="#20-7-异步操作继发与并发" class="headerlink" title="20.7 异步操作继发与并发"></a>20.7 异步操作继发与并发</h3><p>继发执行异步操作意味着等待一个操作完成后再执行下一个操作。</p><p>（1）使用 Promise 链</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>();</span><br><span class="line"></span><br><span class="line">[func1, func2, func3].<span class="title function_">forEach</span>(<span class="function"><span class="params">func</span> =&gt;</span> &#123;</span><br><span class="line">    promise = promise.<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="title function_">func</span>());</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise.<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;All async operations finished.&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，<code>func1</code>, <code>func2</code> 和 <code>func3</code> 是返回<code>Promise</code>的异步函数。这个代码段创建了一个<code>Promise</code>链，依次调用每个函数，并在所有函数都完成后输出一条消息。</p><p>（2）使用 Promise 链 II</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">doAsyncOperation1</span>()</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function"><span class="params">result1</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(result1);</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">doAsyncOperation2</span>();</span><br><span class="line">    &#125;)</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function"><span class="params">result2</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(result2);</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">doAsyncOperation3</span>();</span><br><span class="line">    &#125;)</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function"><span class="params">result3</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(result3);</span><br><span class="line">    &#125;)</span><br><span class="line">    .<span class="title function_">catch</span>(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(error);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，每一个 <code>then</code> 里面返回一个新的 <code>Promise</code>，这样只有前一个 <code>Promise</code> 状态变为 <code>resolved</code>，后一个 <code>Promise</code> 才会开始执行。</p><p>（3）使用 async&#x2F;await</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">runInSequence</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">func1</span>();</span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">func2</span>();</span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">func3</span>();</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;All async operations finished.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">runInSequence</span>();</span><br></pre></td></tr></table></figure><p>上面代码中，<code>func1</code>, <code>func2</code> 和 <code>func3</code>也是返回<code>Promise</code>的异步函数。<code>runInSequence</code>函数使用<code>await</code>关键字依次等待每个函数完成，然后输出一条消息。</p><p>（4）使用 for…of 循环</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">runInSequence</span>(<span class="params">functions</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> func <span class="keyword">of</span> functions) &#123;</span><br><span class="line">        <span class="keyword">await</span> <span class="title function_">func</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;All async operations finished.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">runInSequence</span>([func1, func2, func3]);</span><br></pre></td></tr></table></figure><p>这个例子和前一个例子类似，但是<code>runInSequence</code>函数接受一个函数数组，并使用<code>for...of</code>循环来依次调用它们。</p><p>并发执行异步操作是指同时开始多个异步操作，并在它们都完成后进行下一步。</p><p>（1）使用 Promise.all() </p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> promise1 = <span class="title function_">doAsyncOperation1</span>();</span><br><span class="line"><span class="keyword">let</span> promise2 = <span class="title function_">doAsyncOperation2</span>();</span><br><span class="line"><span class="keyword">let</span> promise3 = <span class="title function_">doAsyncOperation3</span>();</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">all</span>([promise1, promise2, promise3])</span><br><span class="line">.<span class="title function_">then</span>(<span class="function">(<span class="params">[result1, result2, result3]</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(result1, result2, result3);</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">catch</span>(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">error</span>(err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，三个<code>promise</code>会同时开始，并行执行。只有当这三个操作都成功完成，<code>Promise.all()</code> 才会解决。如果任何一个操作失败，那么 <code>Promise.all()</code> 也会立即被 <code>reject</code>，不再等待其他操作。</p><p>（2）使用 Promise.allSettled() </p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> promise1 = <span class="title function_">doAsyncOperation1</span>();</span><br><span class="line"><span class="keyword">let</span> promise2 = <span class="title function_">doAsyncOperation2</span>();</span><br><span class="line"><span class="keyword">let</span> promise3 = <span class="title function_">doAsyncOperation3</span>();</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">allSettled</span>([promise1, promise2, promise3])</span><br><span class="line">.<span class="title function_">then</span>(<span class="function">(<span class="params">results</span>) =&gt;</span> &#123;</span><br><span class="line">  results.<span class="title function_">forEach</span>(<span class="function">(<span class="params">result, index</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (result.<span class="property">status</span> === <span class="string">&quot;fulfilled&quot;</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Operation <span class="subst">$&#123;index + <span class="number">1</span>&#125;</span> succeeded with <span class="subst">$&#123;result.value&#125;</span>`</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Operation <span class="subst">$&#123;index + <span class="number">1</span>&#125;</span> failed with <span class="subst">$&#123;result.reason&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>Promise.allSettled()</code> 的行为与 <code>Promise.all()</code> 类似，但是它会等待所有操作完成，无论成功还是失败。这对于希望了解所有操作的结果，而不仅仅是第一个失败的操作很有用。</p><p>（3）使用 async&#x2F;await 结合 for..of</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> urls = [<span class="string">&#x27;url1&#x27;</span>, <span class="string">&#x27;url2&#x27;</span>, <span class="string">&#x27;url3&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> requests = urls.<span class="title function_">map</span>(<span class="function"><span class="params">url</span> =&gt;</span> <span class="title function_">fetch</span>(url));</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> request <span class="keyword">of</span> requests) &#123;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="keyword">await</span> request;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方法可以并发启动多个异步操作，但等待结果的顺序依然是串行的。也就是说，这种方法不会阻止异步操作的启动，但会按顺序等待每个异步操作的结果。</p><hr><h3 id="20-8-顶层-await"><a href="#20-8-顶层-await" class="headerlink" title="20.8 顶层 await"></a>20.8 顶层 await</h3><p>早期的语法规定，<code>await</code>命令只能出现在 <code>async</code> 函数内部，否则报错。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">const</span> data = <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="string">&#x27;https://api.example.com&#x27;</span>);</span><br></pre></td></tr></table></figure><p>上面代码中，<code>await</code>命令独立使用，没有放在 <code>async</code> 函数里面，就会报错。</p><p>从 <a href="https://github.com/tc39/proposal-top-level-await">ES6</a> 开始，允许在模块的顶层独立使用<code>await</code>命令，使得上面那行代码不会报错了。它的主要目的是使用<code>await</code>解决模块异步加载的问题。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// awaiting.js</span></span><br><span class="line"><span class="keyword">let</span> output;</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> dynamic = <span class="keyword">await</span> <span class="keyword">import</span>(someMission);</span><br><span class="line">  <span class="keyword">const</span> data = <span class="keyword">await</span> <span class="title function_">fetch</span>(url);</span><br><span class="line">  output = <span class="title function_">someProcess</span>(dynamic.<span class="property">default</span>, data);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">main</span>();</span><br><span class="line"><span class="keyword">export</span> &#123; output &#125;;</span><br></pre></td></tr></table></figure><p>上面代码中，模块<code>awaiting.js</code>的输出值<code>output</code>，取决于异步操作。我们把异步操作包装在一个 <code>async</code> 函数里面，然后调用这个函数，只有等里面的异步操作都执行，变量<code>output</code>才会有值，否则就返回<code>undefined</code>。</p><p>下面是加载这个模块的写法。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// usage.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; output &#125; <span class="keyword">from</span> <span class="string">&quot;./awaiting.js&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">outputPlusValue</span>(<span class="params">value</span>) &#123; <span class="keyword">return</span> output + value &#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">outputPlusValue</span>(<span class="number">100</span>));</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">outputPlusValue</span>(<span class="number">100</span>)), <span class="number">1000</span>);</span><br></pre></td></tr></table></figure><p>上面代码中，<ins><code>outputPlusValue()</code>的执行结果，完全取决于执行的时间。如果<code>awaiting.js</code>里面的异步操作没执行完，加载进来的<code>output</code>的值就是<code>undefined</code></ins>。</p><p>目前的解决方法，就是让原始模块输出一个 <code>Promise</code> 对象，从这个 <code>Promise</code> 对象判断异步操作有没有结束（检查当前状态是否为<code>resolved</code>，即使用<code>then</code>的回调函数）。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// awaiting.js</span></span><br><span class="line"><span class="keyword">let</span> output;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> (<span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> dynamic = <span class="keyword">await</span> <span class="keyword">import</span>(someMission);</span><br><span class="line">  <span class="keyword">const</span> data = <span class="keyword">await</span> <span class="title function_">fetch</span>(url);</span><br><span class="line">  output = <span class="title function_">someProcess</span>(dynamic.<span class="property">default</span>, data);</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="keyword">export</span> &#123; output &#125;;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>awaiting.js</code>除了输出<code>output</code>，还默认输出一个 <code>Promise</code> 对象（<code>async</code> 函数立即执行后，返回一个 <code>Promise</code> 对象），从这个对象判断异步操作是否结束。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// usage.js</span></span><br><span class="line"><span class="keyword">import</span> promise, &#123; output &#125; <span class="keyword">from</span> <span class="string">&quot;./awaiting.js&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">outputPlusValue</span>(<span class="params">value</span>) &#123; <span class="keyword">return</span> output + value &#125;</span><br><span class="line"></span><br><span class="line">promise.<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">outputPlusValue</span>(<span class="number">100</span>));</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">outputPlusValue</span>(<span class="number">100</span>)), <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，将<code>awaiting.js</code>对象的输出，放在<code>promise.then()</code>里面，这样就能保证异步操作完成以后，才去读取<code>output</code>。</p><p>这种写法比较麻烦，<ins>等于要求模块的使用者遵守一个额外的使用协议</ins>，按照特殊的方法使用这个模块。一旦忘记使用 <code>Promise</code> 加载，这个模块的代码就可能出错。</p><p><ins>顶层的<code>await</code>命令，就是为了解决这个问题。它保证只有异步操作完成，模块才会输出值</ins>。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// awaiting.js</span></span><br><span class="line"><span class="keyword">const</span> dynamic = <span class="keyword">import</span>(someMission);</span><br><span class="line"><span class="keyword">const</span> data = <span class="title function_">fetch</span>(url);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> output = <span class="title function_">someProcess</span>((<span class="keyword">await</span> dynamic).<span class="property">default</span>, <span class="keyword">await</span> data);</span><br></pre></td></tr></table></figure><p>上面代码中，<ins>两个异步操作在输出的时候，都加上了<code>await</code>命令。只有等到异步操作完成，这个模块才会输出值</ins>。加载这个模块的写法如下。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// usage.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; output &#125; <span class="keyword">from</span> <span class="string">&quot;./awaiting.js&quot;</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">outputPlusValue</span>(<span class="params">value</span>) &#123; <span class="keyword">return</span> output + value &#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">outputPlusValue</span>(<span class="number">100</span>));</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">outputPlusValue</span>(<span class="number">100</span>)), <span class="number">1000</span>);</span><br></pre></td></tr></table></figure><p>上面代码的写法，与普通的模块加载完全一样。也就是说，模块的使用者完全不用关心，依赖模块的内部有没有异步操作，正常加载即可。</p><p>这时，模块的加载会等待依赖模块的异步操作完成，才执行后面的代码。所以，它总是会得到正确的<code>output</code>，不会因为加载时机的不同，而得到不一样的值。</p><p>注意，顶层<code>await</code>只能用在 <code>ES6</code> 模块。</p><hr><h2 id="21-Class-的基本语法"><a href="#21-Class-的基本语法" class="headerlink" title="21. Class 的基本语法"></a>21. Class 的基本语法</h2><h3 id="21-1-类的由来"><a href="#21-1-类的由来" class="headerlink" title="21.1 类的由来"></a>21.1 类的由来</h3><p>在<code>JS</code>中，生成实例对象的传统方法是通过构造函数。下面是一个例子。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Point</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">x</span> = x;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">y</span> = y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Point</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;(&#x27;</span> + <span class="variable language_">this</span>.<span class="property">x</span> + <span class="string">&#x27;, &#x27;</span> + <span class="variable language_">this</span>.<span class="property">y</span> + <span class="string">&#x27;)&#x27;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="title class_">Point</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>上面这种写法跟传统的面向对象语言（比如 <code>C++</code> 和 <code>Java</code>）差异很大，很容易感到困惑。</p><p><code>ES6</code> 引入了 <code>Class</code>（类）这个概念。通过<code>class</code>关键字，可以定义类。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">x</span> = x;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">y</span> = y;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">toString</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;(&#x27;</span> + <span class="variable language_">this</span>.<span class="property">x</span> + <span class="string">&#x27;, &#x27;</span> + <span class="variable language_">this</span>.<span class="property">y</span> + <span class="string">&#x27;)&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码定义了一个“类”，<ins>可以看到里面有一个<code>constructor()</code>方法，这就是构造方法，而<code>this</code>关键字则代表实例对象</ins>。新的<code>class</code>写法让对象原型的写法更加清晰、更像面向对象编程。</p><p><code>Point</code>类除了构造方法，还定义了一个<code>toString()</code>方法。注意，定义<code>toString()</code>方法的时候，前面不需要加上<code>function</code>这个关键字，直接把函数定义放进去了就可以了。</p><p>使用的时候，也是直接对类使用<code>new</code>命令，跟构造函数的用法完全一致。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">x</span> = x;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">y</span> = y;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">toString</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;(&#x27;</span> + <span class="variable language_">this</span>.<span class="property">x</span> + <span class="string">&#x27;, &#x27;</span> + <span class="variable language_">this</span>.<span class="property">y</span> + <span class="string">&#x27;)&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> point = <span class="keyword">new</span> <span class="title class_">Point</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">point.<span class="title function_">toString</span>();</span><br></pre></td></tr></table></figure><p>事实上，类的所有方法都定义在类的<code>prototype</code>属性上面（也称为原型对象）。因此，在类的实例上面调用方法，其实就是调用原型上的方法。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Car</span>(<span class="params">make, model, year</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">make</span> = make;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">model</span> = model;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">year</span> = year;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Car</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">start</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">make</span> + <span class="string">&quot; &quot;</span> + <span class="variable language_">this</span>.<span class="property">model</span> + <span class="string">&quot; engine started.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> car1 = <span class="keyword">new</span> <span class="title class_">Car</span>(<span class="string">&#x27;Eagle&#x27;</span>, <span class="string">&#x27;Talon TSi&#x27;</span>, <span class="number">1993</span>);</span><br><span class="line">car1.<span class="title function_">start</span>();  <span class="comment">// 输出：&quot;Eagle Talon TSi engine started.&quot;</span></span><br></pre></td></tr></table></figure><p>由于类的方法都定义在<code>prototype</code>对象上面，所以类的新方法可以添加在<code>prototype</code>对象上面。<code>Object.assign()</code>方法可以很方便地一次向类添加多个方法。（<code>class</code> 直接添加就行）</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Car</span>(<span class="params">make, model, year</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">make</span> = make;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">model</span> = model;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">year</span> = year;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">assign</span>(<span class="title class_">Car</span>.<span class="property"><span class="keyword">prototype</span></span>, &#123;</span><br><span class="line">  <span class="attr">start</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">make</span> + <span class="string">&quot; &quot;</span> + <span class="variable language_">this</span>.<span class="property">model</span> + <span class="string">&quot; engine started.&quot;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">stop</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">make</span> + <span class="string">&quot; &quot;</span> + <span class="variable language_">this</span>.<span class="property">model</span> + <span class="string">&quot; engine stopped.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> car1 = <span class="keyword">new</span> <span class="title class_">Car</span>(<span class="string">&#x27;Eagle&#x27;</span>, <span class="string">&#x27;Talon TSi&#x27;</span>, <span class="number">1993</span>);</span><br><span class="line">car1.<span class="title function_">start</span>();  <span class="comment">// 输出：&quot;Eagle Talon TSi engine started.&quot;</span></span><br><span class="line">car1.<span class="title function_">stop</span>();   <span class="comment">// 输出：&quot;Eagle Talon TSi engine stopped.&quot;</span></span><br></pre></td></tr></table></figure><p>在<code>JS</code>中，每一个函数（包括类，因为在<code>JS</code>中类也是函数）都有一个<code>prototype</code>属性，它是一个对象，这个对象有一个<code>constructor</code>属性，默认指向函数本身。也就是说，<code>prototype</code>对象的 <code>constructor</code>属性直接指向“类”的本身。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">make, model, year</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">make</span> = make;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">model</span> = model;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">year</span> = year;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Car</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> === <span class="title class_">Car</span>);  <span class="comment">// 输出：true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> car = <span class="keyword">new</span> <span class="title class_">Car</span>(<span class="string">&#x27;Eagle&#x27;</span>, <span class="string">&#x27;Talon TSi&#x27;</span>, <span class="number">1993</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(car.<span class="property">constructor</span> === <span class="title class_">Car</span>);  <span class="comment">// 输出：true</span></span><br></pre></td></tr></table></figure><hr><h3 id="21-2-constructor-方法"><a href="#21-2-constructor-方法" class="headerlink" title="21.2 constructor 方法"></a>21.2 constructor 方法</h3><p><code>constructor()</code>方法是类的默认方法，<ins>通过<code>new</code>命令生成对象实例时，自动调用该方法</ins>。一个类必须有<code>constructor()</code>方法，如果没有显式定义，一个空的<code>constructor()</code>方法会被默认添加。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果想在创建对象时进行一些初始化操作，比如设置对象的属性，那么需要显式定义你自己的 <code>constructor()</code>方法。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">make, model, year</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">make</span> = make;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">model</span> = model;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">year</span> = year;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">start</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">make</span> + <span class="string">&quot; &quot;</span> + <span class="variable language_">this</span>.<span class="property">model</span> + <span class="string">&quot; engine started.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> car = <span class="keyword">new</span> <span class="title class_">Car</span>(<span class="string">&#x27;Eagle&#x27;</span>, <span class="string">&#x27;Talon TSi&#x27;</span>, <span class="number">1993</span>);</span><br><span class="line">car.<span class="title function_">start</span>();  <span class="comment">// 输出：&quot;Eagle Talon TSi engine started.&quot;</span></span><br></pre></td></tr></table></figure><p><code>constructor()</code>方法默认返回实例对象（即<code>this</code>），但完全可以指定返回另外一个对象。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">make, model, year</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">make</span> = make;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">model</span> = model;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">year</span> = year;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个新对象，并返回它</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">make</span>: <span class="string">&#x27;Ford&#x27;</span>,</span><br><span class="line">      <span class="attr">model</span>: <span class="string">&#x27;F-150&#x27;</span>,</span><br><span class="line">      <span class="attr">year</span>: <span class="number">2020</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> car = <span class="keyword">new</span> <span class="title class_">Car</span>(<span class="string">&#x27;Eagle&#x27;</span>, <span class="string">&#x27;Talon TSi&#x27;</span>, <span class="number">1993</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(car.<span class="property">make</span>);  <span class="comment">// 输出：&quot;Ford&quot;</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>constructor()</code>方法返回了一个完全不同的对象。因此，当我们打印<code>car.make</code>时，输出的是<code>&#39;Ford&#39;</code>而不是<code>&#39;Eagle&#39;</code>。</p><hr><h3 id="21-3-类的实例"><a href="#21-3-类的实例" class="headerlink" title="21.3 类的实例"></a>21.3 类的实例</h3><p>生成类的实例的写法，与<code>ES5</code>完全一样，也是使用<code>new</code>命令。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">let</span> point = <span class="title class_">Point</span>(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">let</span> point = <span class="keyword">new</span> <span class="title class_">Point</span>(<span class="number">2</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure><p><ins>类的属性和方法，除非显式定义在其本身（即定义在<code>this</code>对象上，通过实例访问），否则都是定义在原型上（即定义在<code>class</code>上，静态属性或者静态方法）</ins>。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">make, model, year</span>) &#123;</span><br><span class="line">    <span class="comment">// 实例属性</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">make</span> = make;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">model</span> = model;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">year</span> = year;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 原型方法</span></span><br><span class="line">  <span class="title function_">start</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">make</span> + <span class="string">&quot; &quot;</span> + <span class="variable language_">this</span>.<span class="property">model</span> + <span class="string">&quot; engine started.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 静态方法</span></span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">isCar</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> obj <span class="keyword">instanceof</span> <span class="title class_">Car</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态属性</span></span><br><span class="line"><span class="title class_">Car</span>.<span class="property">manu</span> = <span class="string">&quot;Unknown&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> car = <span class="keyword">new</span> <span class="title class_">Car</span>(<span class="string">&#x27;Eagle&#x27;</span>, <span class="string">&#x27;Talon TSi&#x27;</span>, <span class="number">1993</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(car.<span class="property">make</span>);  <span class="comment">// 输出：&quot;Eagle&quot;</span></span><br><span class="line">car.<span class="title function_">start</span>();  <span class="comment">// 输出：&quot;Eagle Talon TSi engine started.&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Car</span>.<span class="title function_">isCar</span>(car));  <span class="comment">// 输出：true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Car</span>.<span class="property">manu</span>);  <span class="comment">// 输出：&quot;Unknown&quot;</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>make</code>、<code>model</code>和<code>year</code>是实例属性，<code>start</code>是原型方法，<code>isCar</code>是静态方法，<code>manu</code>是静态属性。可以看到，<code>make</code>和<code>start</code>可以通过实例<code>car</code>访问，而<code>isCar</code>和<code>manu</code>只能通过类名<code>Car</code>访问。</p><p>与<code>ES5</code>一样，<ins>类的所有实例共享一个原型对象</ins>。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="title class_">Point</span>(<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="title class_">Point</span>(<span class="number">3</span>,<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">p1.<span class="property">__proto__</span> === p2.<span class="property">__proto__</span></span><br><span class="line"><span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>p1</code>和<code>p2</code>都是<code>Point</code>的实例，它们的原型都是<code>Point.prototype</code>，所以<code>__proto__</code>属性是相等的。这也意味着，可以通过实例的<code>__proto__</code>属性为“类”添加方法。</p><p>然而，使用 <code>__proto__</code> 通常是不推荐的，因为这并不是语言的一个标准特性，而且在不同的 <code>JS</code> 环境中可能表现不同。更好的方式是直接使用 <code>Object.getPrototypeOf(obj)</code> 函数获取一个对象的原型，或者使用 <code>Object.setPrototypeOf(obj, prototype)</code> 函数设置一个对象的原型。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="title class_">Point</span>(<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="title class_">Point</span>(<span class="number">3</span>,<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">p1.<span class="property">__proto__</span>.<span class="property">printName</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="keyword">return</span> <span class="string">&#x27;Oops&#x27;</span> &#125;;</span><br><span class="line"></span><br><span class="line">p1.<span class="title function_">printName</span>() <span class="comment">// &quot;Oops&quot;</span></span><br><span class="line">p2.<span class="title function_">printName</span>() <span class="comment">// &quot;Oops&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p3 = <span class="keyword">new</span> <span class="title class_">Point</span>(<span class="number">4</span>,<span class="number">2</span>);</span><br><span class="line">p3.<span class="title function_">printName</span>() <span class="comment">// &quot;Oops&quot;</span></span><br></pre></td></tr></table></figure><p>上面代码在<code>p1</code>的原型上添加了一个<code>printName()</code>方法，由于<code>p1</code>的原型就是<code>p2</code>的原型，因此<code>p2</code>也可以调用这个方法。而且，此后新建的实例<code>p3</code>也可以调用这个方法。<ins>这意味着，使用实例的<code>__proto__</code>属性改写原型，必须相当谨慎，不推荐使用，因为这会改变“类”的原始定义，影响到所有实例</ins>。</p><hr><h3 id="21-4-实例属性的新写法"><a href="#21-4-实例属性的新写法" class="headerlink" title="21.4 实例属性的新写法"></a>21.4 实例属性的新写法</h3><p><a href="https://github.com/tc39/proposal-class-fields">ES6</a> 为类的实例属性，又规定了一种新写法。实例属性现在除了可以定义在<code>constructor()</code>方法里面的<code>this</code>上面，<ins>也可以定义在类内部的最顶层</ins>。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 原来的写法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IncreasingCounter</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_count</span> = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">value</span>() &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Getting the current value!&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_count</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">increment</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_count</span>++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面示例中，实例属性<code>_count</code>定义在<code>constructor()</code>方法里面的<code>this</code>上面。现在的新写法是，这个属性也可以定义在类的最顶层，其他都不变。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">IncreasingCounter</span> &#123;</span><br><span class="line">  _count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">value</span>() &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Getting the current value!&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_count</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">increment</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_count</span>++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，实例属性<code>_count</code>与取值函数<code>value()</code>和<code>increment()</code>方法，处于同一个层级。这时，不需要在实例属性前面加上<code>this</code>。</p><p>注意，<ins>新写法定义的属性是实例对象自身的属性，而不是定义在实例对象的原型<code>prototype</code>上面</ins>。因为如果原型变了，比如这里的<code>_count</code>我们做计数处理，那么所有实例的<code>_count</code>属性都会改变，这就会出现与我们预期不同的结果。</p><p>这种新写法的好处是，所有实例对象自身的属性都定义在类的头部，看上去比较整齐，一眼就能看出这个类有哪些实例属性。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">foo</span> &#123;</span><br><span class="line">  bar = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">  baz = <span class="string">&#x27;world&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码，<code>foo</code>类有两个实例属性，一目了然。另外，写起来也比较简洁。</p><hr><h3 id="21-5-取值函数-getter-和存值函数-setter"><a href="#21-5-取值函数-getter-和存值函数-setter" class="headerlink" title="21.5 取值函数 getter 和存值函数 setter"></a>21.5 取值函数 getter 和存值函数 setter</h3><p>与<code>ES5</code>一样，<ins>在“类”的内部可以使用<code>get</code>和<code>set</code>关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为</ins>。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_myProperty</span> = <span class="string">&#x27;Default value&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Getter</span></span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">myProperty</span>() &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Getting myProperty&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_myProperty</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Setter</span></span><br><span class="line">  <span class="keyword">set</span> <span class="title function_">myProperty</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Setting myProperty&#x27;</span>);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_myProperty</span> = value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">myProperty</span>);  <span class="comment">// 输出：&quot;Getting myProperty&quot; 和 &quot;Default value&quot;</span></span><br><span class="line">obj.<span class="property">myProperty</span> = <span class="string">&#x27;New value&#x27;</span>; <span class="comment">// 输出：&quot;Setting myProperty&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">myProperty</span>);  <span class="comment">// 输出：&quot;Getting myProperty&quot; 和 &quot;New value&quot;</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>myProperty</code>属性有对应的存值函数和取值函数，因此赋值和读取行为都被自定义了。注意，<ins>存值函数和取值函数是设置在属性的 <code>Descriptor</code> 对象上的</ins>。</p><hr><h3 id="21-6-Class-表达式"><a href="#21-6-Class-表达式" class="headerlink" title="21.6 Class 表达式"></a>21.6 Class 表达式</h3><p>与函数一样，类也可以使用表达式的形式定义。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 命名类表达式</span></span><br><span class="line"><span class="keyword">let</span> <span class="title class_">User</span> = <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">sayHello</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hello, my name is <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> user = <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&#x27;Alice&#x27;</span>);</span><br><span class="line">user.<span class="title function_">sayHello</span>(); <span class="comment">// 输出 &quot;Hello, my name is Alice&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">MyClass</span>); <span class="comment">// 报错，MyClass 在类外部不可用</span></span><br></pre></td></tr></table></figure><p>上面代码使用表达式定义了一个类。<ins>需要注意的是，这个类的名字是<code>MyClass</code>，但是<code>MyClass</code>只在 <code>Class</code> 的内部可用，指代当前类。在 <code>Class</code> 外部，这个类只能用<code>User</code>引用</ins>。</p><p>如果类的内部没用到的话，可以省略<code>MyClass</code>，也就是可以写成下面的形式。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 匿名类表达式</span></span><br><span class="line"><span class="keyword">let</span> <span class="title class_">User</span> = <span class="keyword">class</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">sayHello</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hello, my name is <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> user = <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&#x27;Alice&#x27;</span>);</span><br><span class="line">user.<span class="title function_">sayHello</span>(); <span class="comment">// 输出 &quot;Hello, my name is Alice&quot;</span></span><br></pre></td></tr></table></figure><p>采用 <code>Class</code> 表达式，可以写出立即执行的 <code>Class</code>。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user = <span class="keyword">new</span> <span class="keyword">class</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">sayHello</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hello, my name is <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;(<span class="string">&#x27;Alice&#x27;</span>);</span><br><span class="line"></span><br><span class="line">user.<span class="title function_">sayHello</span>(); <span class="comment">// 输出 &quot;Hello, my name is Alice&quot;</span></span><br></pre></td></tr></table></figure><hr><h3 id="21-7-静态方法"><a href="#21-7-静态方法" class="headerlink" title="21.7 静态方法"></a>21.7 静态方法</h3><p>类相当于实例的原型，所有在类中定义的方法都会被实例继承。<ins>如果在一个方法前，加上<code>static</code>关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”</ins>。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">classMethod</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Foo</span>.<span class="title function_">classMethod</span>() <span class="comment">// &#x27;hello&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> foo = <span class="keyword">new</span> <span class="title class_">Foo</span>();</span><br><span class="line">foo.<span class="title function_">classMethod</span>()</span><br><span class="line"><span class="comment">// TypeError: foo.classMethod is not a function</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>Foo</code>类的<code>classMethod</code>方法前有<code>static</code>关键字，表明该方法是一个静态方法，可以直接在<code>Foo</code>类上调用，而不是在<code>Foo</code>类的实例上调用。如果在实例上调用静态方法，会抛出一个错误，表示不存在该方法。</p><p>注意，<ins>如果静态方法包含<code>this</code>关键字，这个<code>this</code>指的是类，而不是实例</ins>。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">myStaticMethod</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">myInstanceMethod</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">MyClass</span>.<span class="title function_">myStaticMethod</span>(); <span class="comment">// 输出 MyClass [Function: MyClass]，this 指向类</span></span><br><span class="line"><span class="keyword">let</span> instance = <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line">instance.<span class="title function_">myInstanceMethod</span>(); <span class="comment">// 输出 MyClass &#123;&#125;，this 指向实例</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>myStaticMethod</code>是<code>MyClass</code>的静态方法，<code>this</code>指向的是类<code>MyClass</code>。<code>myInstanceMethod</code>是实例方法，<code>this</code>指向的是类的实例。另外，从这个例子还可以看出，<ins>静态方法可以与非静态方法重名</ins>。</p><p><ins>父类的静态方法，可以被子类继承</ins>。同时，<ins>静态方法也是可以从<code>super</code>对象上调用的</ins>。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ParentClass</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">greeting</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello from ParentClass&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ChildClass</span> <span class="keyword">extends</span> <span class="title class_ inherited__">ParentClass</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">ChildClass</span>.<span class="title function_">greeting</span>(); <span class="comment">// 输出 &quot;Hello from ParentClass&quot;</span></span><br><span class="line"></span><br><span class="line">-----------------------------------------</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ParentClass</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">greeting</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello from ParentClass&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ChildClass</span> <span class="keyword">extends</span> <span class="title class_ inherited__">ParentClass</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">greeting</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>.<span class="title function_">greeting</span>();</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello from ChildClass&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">ChildClass</span>.<span class="title function_">greeting</span>(); </span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// &quot;Hello from ParentClass&quot;</span></span><br><span class="line"><span class="comment">// &quot;Hello from ChildClass&quot;</span></span><br></pre></td></tr></table></figure><hr><h3 id="21-8-私有方法和私有属性"><a href="#21-8-私有方法和私有属性" class="headerlink" title="21.8 私有方法和私有属性"></a>21.8 私有方法和私有属性</h3><p><a href="https://github.com/tc39/proposal-class-fields">ES6</a>为<code>class</code>添加了私有属性，<ins>方法是在属性名之前使用<code>#</code>表示</ins>。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">IncreasingCounter</span> &#123;</span><br><span class="line">  #count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">value</span>() &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Getting the current value!&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.#count;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">increment</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.#count++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> counter = <span class="keyword">new</span> <span class="title class_">IncreasingCounter</span>();</span><br><span class="line">counter.#count <span class="comment">// 报错</span></span><br><span class="line">counter.#count = <span class="number">42</span> <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>#count</code>就是私有属性，只能在类的内部使用（<code>this.#count</code>）。如果在类的外部使用，就会报错。</p><p>另外，<ins>不管在类的内部或外部，读取一个不存在的私有属性，都会报错</ins>。这跟公开属性的行为完全不同，如果读取一个不存在的公开属性，不会报错，只会返回<code>undefined</code>。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">IncreasingCounter</span> &#123;</span><br><span class="line">  #count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">value</span>() &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Getting the current value!&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.#myCount; <span class="comment">// 报错</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">increment</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.#count++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> counter = <span class="keyword">new</span> <span class="title class_">IncreasingCounter</span>();</span><br><span class="line">counter.#myCount <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><p>上面示例中，<code>#myCount</code>是一个不存在的私有属性，不管在函数内部或外部，读取该属性都会导致报错。注意，私有属性的属性名必须包括<code>#</code>，如果不带<code>#</code>，会被当作另一个属性。</p><p><code>ES6</code>中<ins>不仅可以写私有属性，还可以用来写私有方法</ins>。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">  #a;</span><br><span class="line">  #b;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.#a = a;</span><br><span class="line">    <span class="variable language_">this</span>.#b = b;</span><br><span class="line">  &#125;</span><br><span class="line">  #<span class="title function_">sum</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.#a + <span class="variable language_">this</span>.#b;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">printSum</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.#<span class="title function_">sum</span>());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外，<ins>私有属性也可以设置 <code>getter</code> 和 <code>setter</code> 方法</ins>。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">  #xValue = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.#x);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  get #<span class="title function_">x</span>(<span class="params"></span>) &#123; <span class="keyword">return</span> <span class="variable language_">this</span>.#xValue; &#125;</span><br><span class="line">  set #<span class="title function_">x</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.#xValue = value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>#x</code>是一个私有属性，它的读写都通过<code>get #x()</code>和<code>set #x()</code>操作另一个私有属性<code>#xValue</code>来完成。</p><p><ins>私有属性不限于从<code>this</code>引用，只要是在类的内部，实例也可以引用私有属性</ins>。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">  #privateProperty = <span class="string">&quot;I&#x27;m private&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">checkPrivateProperty</span>(<span class="params">otherInstance</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> otherInstance.#privateProperty;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> instance1 = <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line"><span class="keyword">const</span> instance2 = <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(instance1.<span class="title function_">checkPrivateProperty</span>(instance2)); </span><br><span class="line"><span class="comment">// 输出 &quot;I&#x27;m private&quot;</span></span><br></pre></td></tr></table></figure><p><ins>私有属性和私有方法也可以加上<code>static</code>关键字，表示这是一个静态的私有属性或私有方法</ins>。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> #<span class="title function_">privateStaticMethod</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Hello from private static method&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">callPrivateStaticMethod</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.#<span class="title function_">privateStaticMethod</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">MyClass</span>.<span class="title function_">callPrivateStaticMethod</span>()); </span><br><span class="line"><span class="comment">// 输出 &quot;Hello from private static method&quot;</span></span><br></pre></td></tr></table></figure><hr><h3 id="21-9-in-运算符"><a href="#21-9-in-运算符" class="headerlink" title="21.9 in 运算符"></a>21.9 in 运算符</h3><p>前面说过，<ins>直接访问某个类不存在的私有属性会报错，但是访问不存在的公开属性不会报错。这个特性可以用来判断，某个对象是否为类的实例</ins>。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line">  #brand;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">isC</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      obj.#brand;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面示例中，类<code>C</code>的静态方法<code>isC()</code>就用来判断，某个对象是否为<code>C</code>的实例。它采用的方法就是，访问该对象的私有属性<code>#brand</code>。如果不报错，就会返回<code>true</code>；如果报错，就说明该对象不是当前类的实例，从而<code>catch</code>部分返回<code>false</code>。</p><p>因此，<code>try...catch</code>结构可以用来判断某个私有属性是否存在。但是，这样的写法很麻烦，代码可读性很差，<a href="https://github.com/tc39/proposal-private-fields-in-in">ES6</a> 改进了<ins><code>in</code>运算符，使它也可以用来判断私有属性。它不会报错，而是返回一个布尔值</ins>。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line">  #brand;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">isC</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (#brand <span class="keyword">in</span> obj) &#123;</span><br><span class="line">      <span class="comment">// 私有属性 #brand 存在</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 私有属性 #foo 不存在</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>in</code>也可以跟<code>this</code>一起配合使用，用来检查一个对象是否拥有某个属性的，无论这个属性是在实例本身还是在它的原型链中。注意，<ins>判断私有属性时，<code>in</code>只能用在类的内部</ins>。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  #foo = <span class="number">0</span>;</span><br><span class="line">  <span class="title function_">m</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(#foo <span class="keyword">in</span> <span class="variable language_">this</span>); <span class="comment">// true</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(#bar <span class="keyword">in</span> <span class="variable language_">this</span>); <span class="comment">// false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="21-10-静态块"><a href="#21-10-静态块" class="headerlink" title="21.10 静态块"></a>21.10 静态块</h3><p>静态属性的一个问题是，如果它有初始化逻辑，这个逻辑要么写在类的外部，要么写在<code>constructor()</code>方法里面。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">MyClass</span>.<span class="property">myStaticProperty</span> = <span class="string">&quot;some value&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="title class_">MyClass</span>.<span class="property">myStaticProperty</span>) &#123;</span><br><span class="line">      <span class="title class_">MyClass</span>.<span class="property">myStaticProperty</span> = <span class="string">&quot;some value&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了解决这个问题，<code>ES2022</code> 引入了<a href="https://github.com/tc39/proposal-class-static-block">静态块</a>（<code>static block</code>），允许在类的内部设置一个代码块，<ins>在类生成时运行且只运行一次，主要作用是对静态属性进行初始化</ins>。以后，<ins>新建类的实例时，这个块就不运行了</ins>。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> a;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">a</span> = <span class="title function_">doSomethingThatMightFail</span>();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">a</span> = <span class="string">&quot;default value&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个类允许有多个静态块，每个静态块中只能访问之前声明的静态属性。同时，静态块的内部不能有<code>return</code>语句，但是可以使用类名或<code>this</code>，指代当前类。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> prop1;</span><br><span class="line">  <span class="keyword">static</span> prop2;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="comment">// 第一个静态块</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">prop1</span> = <span class="string">&quot;value1&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="comment">// 第二个静态块</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">prop2</span> = <span class="variable language_">this</span>.<span class="property">prop1</span> + <span class="string">&quot; value2&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">MyClass</span>.<span class="property">prop1</span>); <span class="comment">// 输出 &quot;value1&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">MyClass</span>.<span class="property">prop2</span>); <span class="comment">// 输出 &quot;value1 value2&quot;</span></span><br></pre></td></tr></table></figure><p>除了静态属性的初始化，静态块还有一个作用，就是<ins>将私有属性与类的外部代码分享</ins>。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">  <span class="comment">// 私有属性</span></span><br><span class="line">  <span class="keyword">static</span> #privateProp = <span class="string">&quot;private value&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="comment">// 在静态块中定义公开方法</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">getPrivateProp</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title class_">MyClass</span>.#privateProp;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">MyClass</span>.<span class="title function_">getPrivateProp</span>()); <span class="comment">// 输出 &quot;private value&quot;</span></span><br></pre></td></tr></table></figure><p>这个特性提供了一种灵活的方式来控制类的私有属性的访问，可以根据需要决定哪些私有属性应该对外部代码开放，以及在何种条件下开放。</p><hr><h3 id="21-11-类的注意点"><a href="#21-11-类的注意点" class="headerlink" title="21.11 类的注意点"></a>21.11 类的注意点</h3><p><strong>（1）Generator 方法</strong></p><p>如果某个方法之前加上星号<code>*</code>，就表示该方法是一个 <code>Generator</code> 函数。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">lass <span class="title class_">MyClass</span> &#123;</span><br><span class="line">  * <span class="title function_">generatorMethod</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&#x27;Hello,&#x27;</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&#x27;world!&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> myInstance = <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line"><span class="keyword">const</span> gen = myInstance.<span class="title function_">generatorMethod</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(gen.<span class="title function_">next</span>().<span class="property">value</span>); <span class="comment">// 输出 &quot;Hello,&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(gen.<span class="title function_">next</span>().<span class="property">value</span>); <span class="comment">// 输出 &quot;world!&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(gen.<span class="title function_">next</span>().<span class="property">value</span>); <span class="comment">// 输出 undefined</span></span><br></pre></td></tr></table></figure><p><strong>（2）this 的指向</strong></p><p>类的方法内部如果含有<code>this</code>，它默认指向类的实例。但是，如果将类的方法提取出来单独使用，那么<code>this</code>可能就不再指向原来的对象了。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">  <span class="title function_">myMethod</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> myInstance = <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line">myInstance.<span class="title function_">myMethod</span>();  <span class="comment">// MyClass的实例</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; method &#125; = myInstance</span><br><span class="line"><span class="title function_">method</span>();  <span class="comment">// undefined或者全局对象（在非严格模式下）</span></span><br></pre></td></tr></table></figure><p>在上述代码中，<code>myMethod</code>方法中的<code>this</code>默认指向<code>MyClass</code>的实例。但当我们将<code>myMethod</code>方法赋值给变量<code>method</code>，并单独调用<code>method()</code>时，<code>this</code>就变成了<code>undefined</code>。</p><p>解决方法是，<ins>在构造方法中绑定<code>this</code></ins>，或者使用箭头函数。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">myMethod</span> = <span class="variable language_">this</span>.<span class="property">myMethod</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="title function_">myMethod</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">  myMethod = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="22-Class-的继承"><a href="#22-Class-的继承" class="headerlink" title="22. Class 的继承"></a>22. Class 的继承</h2><p><a href="https://es6.ruanyifeng.com/#docs/class-extends">本章</a>内容复杂，故先跳过一部分。</p><h3 id="22-1-简介"><a href="#22-1-简介" class="headerlink" title="22.1 简介"></a>22.1 简介</h3><p><ins><code>Class</code> 可以通过<code>extends</code>关键字实现继承，让子类继承父类的属性和方法</ins>。<code>extends</code> 的写法比 <code>ES5</code> 的原型链继承，要清晰和方便很多。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ColorPoint</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Point</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面示例中，<ins><code>Point</code>是父类，<code>ColorPoint</code>是子类，它通过<code>extends</code>关键字，继承了<code>Point</code>类的所有属性和方法</ins>。下面，我们在<code>ColorPoint</code>内部加上代码。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ColorPoint</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Point</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">x, y, color</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(x, y); <span class="comment">// 调用父类的 constructor(x, y)</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">color</span> = color;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">toString</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">color</span> + <span class="string">&#x27; &#x27;</span> + <span class="variable language_">super</span>.<span class="title function_">toString</span>(); <span class="comment">// 调用父类的 toString()</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面示例中，<code>constructor()</code>方法和<code>toString()</code>方法内部，都出现了<code>super</code>关键字。<ins><code>super</code>在这里表示父类的构造函数，用来新建一个父类的实例对象</ins>。</p><p><code>ES6</code> 规定，<ins>子类必须在<code>constructor()</code>方法中调用<code>super()</code></ins>，否则就会报错。这是因为子类自己的<code>this</code>对象，必须先通过父类的构造函数完成塑造，得到与父类同样的实例属性和方法，然后再添加子类自己的实例属性和方法。如果不调用<code>super()</code>方法，子类就得不到自己的<code>this</code>对象。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ColorPoint</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Point</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> cp = <span class="keyword">new</span> <span class="title class_">ColorPoint</span>(); <span class="comment">// ReferenceError</span></span><br></pre></td></tr></table></figure><p>为什么子类的构造函数，一定要调用<code>super()</code>？原因就在于 <code>ES6</code> 的继承机制，与 <code>ES5</code> 完全不同。</p><ul><li><code>ES5</code> 的继承机制，是先创造一个独立的子类的实例对象，然后再将父类的方法添加到这个对象上面，即“实例在前，继承在后”。</li><li><code>ES6</code> 的继承机制，则是先将父类的属性和方法，加到一个空的对象上面，然后再将该对象作为子类的实例，即“继承在前，实例在后”。</li></ul><p>这就是为什么 <code>ES6</code> 的继承必须先调用<code>super()</code>方法，因为这一步会生成一个继承父类的<code>this</code>对象，没有这一步就无法继承父类。</p><p>注意，这意味着<ins>新建子类实例时，父类的构造函数必定会先运行一次</ins>。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bar</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Foo</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>();</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> bar = <span class="keyword">new</span> <span class="title class_">Bar</span>();</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>上面示例中，子类 <code>Bar</code> 新建实例时，会输出<code>1</code>和<code>2</code>。原因就是子类构造函数调用<code>super()</code>时，会执行一次父类构造函数。</p><p>另一个需要注意的地方是，<ins>在子类的构造函数中，只有调用<code>super()</code>之后，才可以使用<code>this</code>关键字</ins>，否则会报错。这是因为子类实例的构建，必须先完成父类的继承，只有<code>super()</code>方法才能让子类实例继承父类。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;Parent&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Parent</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// Error: Must call super constructor in derived class before accessing &#x27;this&#x27;</span></span><br><span class="line">    <span class="comment">// console.log(this.name); </span></span><br><span class="line"></span><br><span class="line">    <span class="variable language_">super</span>(); <span class="comment">// 正确初始化子类实例</span></span><br><span class="line"></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>); <span class="comment">// 输出: &#x27;Parent&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Child</span>();</span><br></pre></td></tr></table></figure><p>上面代码中，子类的<code>constructor()</code>方法没有调用<code>super()</code>之前，就使用<code>this</code>关键字，结果报错，而放在<code>super()</code>之后就是正确的。</p><p><ins>如果子类没有定义<code>constructor()</code>方法，这个方法会默认添加，并且里面会调用<code>super()</code></ins>。也就是说，不管有没有显式定义，任何一个子类都有<code>constructor()</code>方法。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Parent</span> &#123;</span><br><span class="line">  <span class="comment">// 这里我们没有显式定义 constructor()</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> child = <span class="keyword">new</span> <span class="title class_">Child</span>(<span class="string">&#x27;John&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(child.<span class="property">name</span>); <span class="comment">// 输出: &#x27;John&#x27;</span></span><br></pre></td></tr></table></figure><p>有了子类的定义，就可以生成子类的实例了。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">child <span class="keyword">instanceof</span> <span class="title class_">Child</span> <span class="comment">// true</span></span><br><span class="line">child <span class="keyword">instanceof</span> <span class="title class_">Parent</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>注意，<ins>如果父类和子类有同名属性，子类的属性会覆盖父类的属性</ins>。这是因为在子类中定义的属性和方法具有更高的优先级。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;Parent&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Parent</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>();</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;Child&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="title function_">showName</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> child = <span class="keyword">new</span> <span class="title class_">Child</span>();</span><br><span class="line">child.<span class="title function_">showName</span>(); <span class="comment">// 输出: &#x27;Child&#x27;</span></span><br></pre></td></tr></table></figure><hr><h3 id="22-2-私有属性和私有方法的继承"><a href="#22-2-私有属性和私有方法的继承" class="headerlink" title="22.2 私有属性和私有方法的继承"></a>22.2 私有属性和私有方法的继承</h3><p><ins>父类所有的属性和方法，都会被子类继承，除了私有的属性和方法</ins>。子类无法继承父类的私有属性，或者说，<ins>私有属性只能在定义它的 <code>class</code> 里面使用</ins>。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">  #p = <span class="number">1</span>;</span><br><span class="line">  #<span class="title function_">m</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bar</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Foo</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>();</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.#p); <span class="comment">// 报错</span></span><br><span class="line">    <span class="variable language_">this</span>.#<span class="title function_">m</span>(); <span class="comment">// 报错</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果<ins>父类定义了私有属性的读写方法，子类就可以通过这些方法，读写私有属性</ins>。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">  #p = <span class="number">1</span>;</span><br><span class="line">  <span class="title function_">getP</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.#p;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bar</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Foo</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>();</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="title function_">getP</span>()); <span class="comment">// 1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面示例中，<code>getP()</code>是父类用来读取私有属性的方法，子类可以用这个方法读到父类的私有属性。</p><hr><h3 id="22-3-静态属性和静态方法的继承"><a href="#22-3-静态属性和静态方法的继承" class="headerlink" title="22.3 静态属性和静态方法的继承"></a>22.3 静态属性和静态方法的继承</h3><p><ins>父类的静态属性和静态方法，也会被子类继承</ins>。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">hello</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hello world&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_ inherited__">A</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">B.<span class="title function_">hello</span>()  <span class="comment">// hello world</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>hello()</code>是<code>A</code>类的静态方法，<code>B</code>继承<code>A</code>，也继承了<code>A</code>的静态方法。</p><p>注意，<ins>静态属性是通过<a href="https://vue3js.cn/interview/JavaScript/copy.html">软拷贝</a>实现继承的</ins>。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123; <span class="keyword">static</span> foo = <span class="number">100</span>; &#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_ inherited__">A</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>();</span><br><span class="line">    B.<span class="property">foo</span>--;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> b = <span class="keyword">new</span> <span class="title function_">B</span>();</span><br><span class="line">B.<span class="property">foo</span> <span class="comment">// 99</span></span><br><span class="line">A.<span class="property">foo</span> <span class="comment">// 100</span></span><br></pre></td></tr></table></figure><p>上面示例中，<code>foo</code>是 <code>A</code> 类的静态属性，<code>B</code> 类继承了 <code>A</code> 类，因此也继承了这个属性。但是，<ins>在 <code>B</code> 类内部操作<code>B.foo</code>这个静态属性，影响不到<code>A.foo</code></ins>，原因就是 <code>B</code> 类继承静态属性时，会采用浅拷贝，拷贝父类静态属性的值，因此<code>A.foo</code>和<code>B.foo</code>是两个彼此独立的属性。</p><p>但是，由于这种拷贝是浅拷贝，<ins>如果父类的静态属性的值是一个对象，那么子类的静态属性也会指向这个对象</ins>，因为浅拷贝只会拷贝对象的内存地址。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> foo = &#123; <span class="attr">n</span>: <span class="number">100</span> &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_ inherited__">A</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>();</span><br><span class="line">    B.<span class="property">foo</span>.<span class="property">n</span>--;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> b = <span class="keyword">new</span> <span class="title function_">B</span>();</span><br><span class="line">B.<span class="property">foo</span>.<span class="property">n</span> <span class="comment">// 99</span></span><br><span class="line">A.<span class="property">foo</span>.<span class="property">n</span> <span class="comment">// 99</span></span><br></pre></td></tr></table></figure><p>上面示例中，<code>A.foo</code>的值是一个对象，浅拷贝导致<code>B.foo</code>和<code>A.foo</code>指向同一个对象。所以，子类<code>B</code>修改这个对象的属性值，会影响到父类<code>A</code>。</p><hr><h3 id="22-4-super-关键字"><a href="#22-4-super-关键字" class="headerlink" title="22.4 super 关键字"></a>22.4 super 关键字</h3><p><code>super</code>这个关键字，既可以当作函数使用，也可以当作对象使用。</p><p>（1）当<code>super</code><ins>作为函数调用时，代表父类的构造函数</ins>。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_ inherited__">A</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用<code>super()</code>的作用是形成子类的<code>this</code>对象，把父类的实例属性和方法放到这个<code>this</code>对象上面。子类在调用<code>super()</code>之前，是没有<code>this</code>对象的，任何对<code>this</code>的操作都要放在<code>super()</code>的后面。</p><p>注意，<ins>这里的<code>super</code>虽然代表了父类的构造函数，但是因为返回的是子类的<code>this</code>（即子类的实例对象），所以<code>super</code>内部的<code>this</code>代表子类的实例，而不是父类的实例</ins>。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span>.<span class="property">target</span>.<span class="property">name</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_ inherited__">A</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> <span class="title function_">A</span>() <span class="comment">// A</span></span><br><span class="line"><span class="keyword">new</span> <span class="title function_">B</span>() <span class="comment">// B </span></span><br></pre></td></tr></table></figure><p>上面示例中，<code>new.target</code>指向当前正在执行的函数。可以看到，在<code>super()</code>执行时，它指向的是子类<code>B</code>的构造函数，而不是父类<code>A</code>的构造函数。也就是说，<code>super()</code>内部的<code>this</code>指向的是<code>B</code>。</p><p>不过，<ins>由于<code>super()</code>在子类构造方法中执行时，子类的属性和方法还没有绑定到<code>this</code>，所以如果存在同名属性，此时拿到的是父类的属性</ins>。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  name = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;My name is &#x27;</span> + <span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_ inherited__">A</span> &#123;</span><br><span class="line">  name = <span class="string">&#x27;B&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> b = <span class="keyword">new</span> <span class="title function_">B</span>(); <span class="comment">// My name is A</span></span><br></pre></td></tr></table></figure><p>上面示例中，最后一行输出的是<code>A</code>，而不是<code>B</code>，原因就在于<code>super()</code>执行时，<code>B</code>的<code>name</code>属性还没有绑定到<code>this</code>，所以<code>this.name</code>拿到的是<code>A</code>类的<code>name</code>属性。</p><p><ins>作为函数时，<code>super()</code>只能用在子类的构造函数之中</ins>，用在其他地方就会报错。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_ inherited__">A</span> &#123;</span><br><span class="line">  <span class="title function_">m</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(); <span class="comment">// 报错</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）当<code>super</code><ins>作为对象时，在普通方法中指向父类的原型对象，在静态方法中指向父类</ins>。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;Parent&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">greet</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hello, <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">sayHello</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello from Parent class&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Parent</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>();</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;Child&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">greet</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>.<span class="title function_">greet</span>(); <span class="comment">// 使用super在普通方法中调用父类方法</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hello, <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span> from child class`</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">sayHello</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>.<span class="title function_">sayHello</span>(); <span class="comment">// 在静态方法中使用super调用父类静态方法</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello from Child class&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> c = <span class="keyword">new</span> <span class="title class_">Child</span>();</span><br><span class="line">c.<span class="title function_">greet</span>(); </span><br><span class="line"><span class="title class_">Child</span>.<span class="title function_">sayHello</span>(); </span><br></pre></td></tr></table></figure><p>如果<code>super</code>指向父类的原型对象，那么定义在父类实例上的方法或属性（即定义在<code>constructor</code>里），是无法通过<code>super</code>调用的。这时候想在子类中访问到父类实例上的属性，则需要在父类中定义一个方法来返回这个属性，然后在子类中调用这个方法。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;Parent&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">getName</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Parent</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>();</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">super</span>.<span class="property">name</span>);  <span class="comment">// TypeError ...</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">super</span>.<span class="title function_">getName</span>());  <span class="comment">// &#x27;Parent&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><ins>在子类普通方法中通过<code>super</code>调用父类的方法时，方法内部的<code>this</code>指向当前的子类实例</ins>。所以通过<code>super</code>对某个属性赋值，<code>super</code>就是<code>this</code>，赋值的属性会变成子类实例的属性。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">x</span> = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">print</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">x</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_ inherited__">A</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>();</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">x</span> = <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">m</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>.<span class="title function_">print</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> <span class="title function_">B</span>();</span><br><span class="line">b.<span class="title function_">m</span>() <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>super.print()</code>虽然调用的是<code>A.prototype.print()</code>，但是<code>A.prototype.print()</code>内部的<code>this</code>指向子类<code>B</code>的实例，导致输出的是<code>2</code>，而不是<code>1</code>。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">x</span> = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_ inherited__">A</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>();</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">x</span> = <span class="number">2</span>;</span><br><span class="line">    <span class="variable language_">super</span>.<span class="property">x</span> = <span class="number">3</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">super</span>.<span class="property">x</span>); <span class="comment">// undefined</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">x</span>); <span class="comment">// 3</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> <span class="title function_">B</span>();</span><br></pre></td></tr></table></figure><p>上面代码中，<code>super.x</code>赋值为<code>3</code>，这时等同于对<code>this.x</code>赋值为<code>3</code>。而当读取<code>super.x</code>的时候，读的是<code>A.prototype.x</code>，所以返回<code>undefined</code>。</p><p><ins>如果<code>super</code>作为对象，用在静态方法之中，这时<code>super</code>将指向父类，而不是父类的原型对象</ins>。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">myMethod</span>(<span class="params">msg</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;static&#x27;</span>, msg);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">myMethod</span>(<span class="params">msg</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;instance&#x27;</span>, msg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Parent</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">myMethod</span>(<span class="params">msg</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>.<span class="title function_">myMethod</span>(msg);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">myMethod</span>(<span class="params">msg</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>.<span class="title function_">myMethod</span>(msg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Child</span>.<span class="title function_">myMethod</span>(<span class="number">1</span>); <span class="comment">// static 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child = <span class="keyword">new</span> <span class="title class_">Child</span>();</span><br><span class="line">child.<span class="title function_">myMethod</span>(<span class="number">2</span>); <span class="comment">// instance 2</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>super</code>在静态方法之中指向父类，在普通方法之中指向父类的原型对象。</p><p>另外，<ins>在子类的静态方法中通过<code>super</code>调用父类的方法时，方法内部的<code>this</code>指向当前的子类，而不是子类的实例</ins>。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">x</span> = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">print</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">x</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_ inherited__">A</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>();</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">x</span> = <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">m</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>.<span class="title function_">print</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">B.<span class="property">x</span> = <span class="number">3</span>;</span><br><span class="line">B.<span class="title function_">m</span>() <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>上面代码中，静态方法<code>B.m</code>里面，<code>super.print</code>指向父类的静态方法。这个方法里面的<code>this</code>指向的是<code>B</code>，而不是<code>B</code>的实例。</p><hr><h3 id="22-5-类的-prototype-属性和-proto-属性"><a href="#22-5-类的-prototype-属性和-proto-属性" class="headerlink" title="22.5 类的 prototype 属性和 __proto__ 属性"></a>22.5 类的 prototype 属性和 __proto__ 属性</h3><p>大多数浏览器的 <code>ES5</code> 实现之中，每一个对象都有<code>__proto__</code>属性，指向对应的构造函数的<code>prototype</code>属性。<code>Class</code> 作为构造函数的语法糖，同时有<code>prototype</code>属性和<code>__proto__</code>属性，因此同时存在两条继承链。</p><ul><li>子类的<code>__proto__</code>属性，<ins>表示构造函数的继承，总是指向父类</ins>。</li><li>子类<code>prototype</code>属性的<code>__proto__</code>属性，<ins>表示方法的继承，总是指向父类的<code>prototype</code>属性</ins>。</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_ inherited__">A</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">B.<span class="property">__proto__</span> === A <span class="comment">// true</span></span><br><span class="line">B.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">__proto__</span> === A.<span class="property"><span class="keyword">prototype</span></span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面代码中，<ins>子类<code>B</code>的<code>__proto__</code>属性指向父类<code>A</code>，子类<code>B</code>的<code>prototype</code>属性的<code>__proto__</code>属性指向父类<code>A</code>的<code>prototype</code>属性</ins>。</p><p>这两条继承链，可以这样理解：</p><ul><li>作为一个对象，子类（<code>B</code>）的原型（<code>__proto__</code>属性）是父类（<code>A</code>）。</li><li>作为一个构造函数，子类（<code>B</code>）的原型对象（<code>prototype</code>属性）是父类的原型对象（<code>prototype</code>属性）的实例。</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">B.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(A.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">B.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">__proto__</span> = A.<span class="property"><span class="keyword">prototype</span></span>;</span><br></pre></td></tr></table></figure><hr><h3 id="22-6-原生构造函数的继承"><a href="#22-6-原生构造函数的继承" class="headerlink" title="22.6 原生构造函数的继承"></a>22.6 原生构造函数的继承</h3><p><code>ES6</code> 允许继承原生构造函数定义子类，因为 <code>ES6</code> 是先新建父类的实例对象<code>this</code>，然后再用子类的构造函数修饰<code>this</code>，使得父类的所有行为都可以继承。下面是一个继承<code>Array</code>的例子。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyArray</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Array</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(...args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="title class_">MyArray</span>();</span><br><span class="line">arr[<span class="number">0</span>] = <span class="number">12</span>;</span><br><span class="line">arr.<span class="property">length</span> <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">arr.<span class="property">length</span> = <span class="number">0</span>;</span><br><span class="line">arr[<span class="number">0</span>] <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>上面代码定义了一个<code>MyArray</code>类，继承了<code>Array</code>构造函数，因此就可以从<code>MyArray</code>生成数组的实例。这意味着，<code>ES6</code> 可以自定义原生数据结构（比如<code>Array</code>、<code>String</code>等）的子类，这是 <code>ES5</code> 无法做到的。</p><p>上面这个例子也说明，<code>extends</code>关键字不仅可以用来继承类，还可以用来继承原生的构造函数。因此可以在原生数据结构的基础上，定义自己的数据结构。下面就是定义了一个带版本功能的数组。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">VersionedArray</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Array</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>();</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">history</span> = [[]];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">commit</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">history</span>.<span class="title function_">push</span>(<span class="variable language_">this</span>.<span class="title function_">slice</span>());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">revert</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">splice</span>(<span class="number">0</span>, <span class="variable language_">this</span>.<span class="property">length</span>, ...<span class="variable language_">this</span>.<span class="property">history</span>[<span class="variable language_">this</span>.<span class="property">history</span>.<span class="property">length</span> - <span class="number">1</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x = <span class="keyword">new</span> <span class="title class_">VersionedArray</span>();</span><br><span class="line"></span><br><span class="line">x.<span class="title function_">push</span>(<span class="number">1</span>);</span><br><span class="line">x.<span class="title function_">push</span>(<span class="number">2</span>);</span><br><span class="line">x <span class="comment">// [1, 2]</span></span><br><span class="line">x.<span class="property">history</span> <span class="comment">// [[]]</span></span><br><span class="line"></span><br><span class="line">x.<span class="title function_">commit</span>();</span><br><span class="line">x.<span class="property">history</span> <span class="comment">// [[], [1, 2]]</span></span><br><span class="line"></span><br><span class="line">x.<span class="title function_">push</span>(<span class="number">3</span>);</span><br><span class="line">x <span class="comment">// [1, 2, 3]</span></span><br><span class="line">x.<span class="property">history</span> <span class="comment">// [[], [1, 2]]</span></span><br><span class="line"></span><br><span class="line">x.<span class="title function_">revert</span>();</span><br><span class="line">x <span class="comment">// [1, 2]</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>VersionedArray</code>会通过<code>commit</code>方法，将自己的当前状态生成一个版本快照，存入<code>history</code>属性。<code>revert</code>方法用来将数组重置为最新一次保存的版本。除此之外，<code>VersionedArray</code>依然是一个普通数组，所有原生的数组方法都可以在它上面调用。</p><p>注意，继承<code>Object</code>的子类，有一个<a href="https://stackoverflow.com/questions/36203614/super-does-not-pass-arguments-when-instantiating-a-class-extended-from-object">行为差异</a>。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NewObj</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Object</span>&#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">super</span>(...<span class="variable language_">arguments</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="title class_">NewObj</span>(&#123;<span class="attr">attr</span>: <span class="literal">true</span>&#125;);</span><br><span class="line">o.<span class="property">attr</span> === <span class="literal">true</span>  <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>NewObj</code>继承了<code>Object</code>，但是无法通过<code>super</code>方法向父类<code>Object</code>传参。这是因为 <code>ES6</code> 改变了<code>Object</code>构造函数的行为，一旦发现<code>Object</code>方法不是通过<code>new Object()</code>这种形式调用，<code>ES6</code> 规定<code>Object</code>构造函数会忽略参数。</p><hr><h3 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h3><blockquote><p>该学习笔记的所有章节均保存在<a href="https://github.com/Hongda-OSU/ES6-Journey">Github</a>中，如有需要，可下载并在<a href="https://typora.io/">Typora</a>中阅读。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> ES6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ES6学习笔记 • 中</title>
      <link href="/posts/9413d22e.html"/>
      <url>/posts/9413d22e.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>本读书笔记节选自阮一峰编写的 <a href="https://es6.ruanyifeng.com/">《ECMAScript 6 入门教程》</a>。适合已经掌握 <code>ES5</code> 的读者，用来了解这门语言的最新发展。笔记内容仅包括日常开发中可能会用到的概念，剩余部分请自行阅读。</p></blockquote><hr><h2 id="16-Promise-对象"><a href="#16-Promise-对象" class="headerlink" title="16. Promise 对象"></a>16. Promise 对象</h2><h3 id="16-1-事件循环"><a href="#16-1-事件循环" class="headerlink" title="16.1 事件循环"></a>16.1 事件循环</h3><p>推荐阅读：<a href="https://segmentfault.com/a/1190000038928521">js事件循环机制event-loop</a></p><hr><h3 id="16-2-Promise-的含义"><a href="#16-2-Promise-的含义" class="headerlink" title="16.2 Promise 的含义"></a>16.2 Promise 的含义</h3><p><code>Promise</code> 是异步编程的一种解决方案，比传统的<a href="https://segmentfault.com/a/1190000021942060">回调函数</a>和<a href="https://zh.javascript.info/introduction-browser-events">事件</a>，更合理和更强大。它类似于一个容器，里面保存着某个未来才会结束的事件，通常是一个异步操作的结果。</p><p><code>Promise</code>对象有以下两个特点：</p><ul><li><ins><code>Promise</code>对象的状态不受外界影响</ins>。<code>Promise</code>对象代表一个异步操作，有三种状态：<code>pending</code>（进行中）、<code>fulfilled</code>（已成功）和<code>rejected</code>（已失败）。<ins>只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态</ins>。</li><li><ins><code>Promise</code>对象一旦状态改变，就不会再变</ins>。<code>Promise</code>对象的状态改变，只有两种可能：从<code>pending</code>变为<code>fulfilled</code>和从<code>pending</code>变为<code>rejected</code>。只要这两种情况发生，状态就凝固了，这时就称为 <code>resolved</code>（已定型）。</li></ul><p><code>Promise</code>对象的好处，是可以<ins>将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数</ins>。此外，<code>Promise</code>对象提供统一的接口，使得控制异步操作更加容易。</p><p><code>Promise</code>也有缺点。首先，<ins>无法取消<code>Promise</code>，一旦新建它就会立即执行，无法中途取消</ins>。其次，<ins>如果不设置回调函数，<code>Promise</code>内部抛出的错误，不会反应到外部</ins>。第三，当处于<code>pending</code>状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。</p><hr><h3 id="16-3-基本用法"><a href="#16-3-基本用法" class="headerlink" title="16.3 基本用法"></a>16.3 基本用法</h3><p><code>Promise</code>的构造函数接受一个函数作为参数，该函数的两个参数分别是<code>resolve</code>和<code>reject</code>。它们是两个函数，由 <code>JavaScript</code> 引擎提供，不用自己部署。</p><ul><li><code>resolve</code>函数的作用是，将<code>Promise</code>对象的状态从“未完成”变为“成功”（即从 <code>pending</code> 变为 <code>resolved</code>），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去。</li><li><code>reject</code>函数的作用是，将<code>Promise</code>对象的状态从“未完成”变为“失败”（即从 <code>pending</code> 变为 <code>rejected</code>），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">  <span class="comment">// ... </span></span><br><span class="line">  <span class="keyword">if</span> (<span class="comment">/* 异步操作成功 */</span>)&#123;</span><br><span class="line">    <span class="title function_">resolve</span>(value);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="title function_">reject</span>(error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>Promise</code>实例生成后可以<ins>用<code>then</code>方法指定<code>resolved</code>和<code>rejected</code>的回调函数。这两个函数都是可选的，不一定要提供。它们都接受<code>Promise</code>对象传出的值作为参数</ins>。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">promise.<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">value</span>) &#123;</span><br><span class="line">  <span class="comment">// success</span></span><br><span class="line">&#125;, <span class="keyword">function</span>(<span class="params">error</span>) &#123;</span><br><span class="line">  <span class="comment">// failure</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>下面是一个<code>Promise</code>对象的例子。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">timeout</span>(<span class="params">ms</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// https://developer.mozilla.org/en-US/docs/Web/API/setTimeout</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(resolve, ms, <span class="string">&#x27;done&#x27;</span>); <span class="comment">// &#x27;done&#x27; 会传入回调函数 resolve</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">timeout</span>(<span class="number">1000</span>).<span class="title function_">then</span>(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 1秒后 &quot;done&quot;</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>timeout</code>方法返回一个<code>Promise</code>实例，表示一段时间以后才会发生的结果。过了指定的时间后，<code>Promise</code>实例的状态变为<code>resolved</code>，就会触发<code>then</code>方法绑定的回调函数。</p><p><ins><code>Promise</code> 新建后就会立即执行</ins>。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello&#x27;</span>);</span><br><span class="line">  <span class="title function_">resolve</span>(); </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise.<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;resolved.&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hi!&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Hello</span></span><br><span class="line"><span class="comment">// Hi!</span></span><br><span class="line"><span class="comment">// resolved</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>Promise</code> 新建后立即执行，所以首先输出的是<code>Hello</code>。然后，<ins><code>then</code>方法指定的回调函数，将在当前脚本所有同步任务执行完才会执行</ins>，所以<code>resolved</code>最后输出。</p><p>如果<ins>调用<code>resolve</code>函数和<code>reject</code>函数时带有参数</ins>，那么它们的<ins>参数会被传递给回调函数</ins>。</p><ul><li><code>reject</code>函数的参数通常是<code>Error</code>对象的实例，表示抛出的错误。</li><li><code>resolve</code>函数的参数除了正常的值以外，还可能是另一个 <code>Promise</code> 实例。</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="title function_">resolve</span>(p1);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>上面代码中，<code>p1</code>和<code>p2</code>都是 <code>Promise</code> 的实例，但是<code>p2</code>的<code>resolve</code>方法将<code>p1</code>作为参数，即一个异步操作的结果是返回另一个异步操作。这时<code>p1</code>的状态就会传递给<code>p2</code>，此时<code>p1</code>的状态决定了<code>p2</code>的状态。</p><ul><li>如果<code>p1</code>的状态是<code>pending</code>，那么<code>p2</code>的回调函数就会等待<code>p1</code>的状态改变。</li><li>如果<code>p1</code>的状态已经是<code>resolved</code>或者<code>rejected</code>，那么<code>p2</code>的回调函数将会立刻执行。</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;fail&#x27;</span>)), <span class="number">3000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">resolve</span>(p1), <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p2</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function"><span class="params">result</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(result))</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function"><span class="params">error</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(error))</span><br><span class="line"><span class="comment">// Error: fail</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>p1</code>是一个 <code>Promise</code>，<code>3</code> 秒之后变为<code>rejected</code>。<code>p2</code>的状态在 <code>1</code> 秒之后改变，而且<code>resolve</code>方法返回的是<code>p1</code>。</p><ul><li>由于<code>p2</code>返回的是另一个 <code>Promise</code>，导致<code>p2</code>自己的状态无效了，<ins>由<code>p1</code>的状态决定<code>p2</code>的状态</ins>。所以，后面的<code>then</code>语句都变成针对后者<code>p1</code>。又过了 <code>2</code> 秒，<code>p1</code>变为<code>rejected</code>，导致触发<code>catch</code>方法指定的回调函数。</li></ul><p>注意，调用<code>resolve</code>或<code>reject</code>并不会终结 <code>Promise</code> 的参数函数的执行。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">r</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(r);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>上面代码中，调用<code>resolve(1)</code>以后，后面的<code>console.log(2)</code>还是会执行，<ins>并且会首先打印出来。这是因为立即 <code>resolved</code> 的 <code>Promise</code> 是在本轮事件循环的末尾执行，总是晚于本轮循环的同步任务</ins>。</p><p>一般来说，调用<code>resolve</code>或<code>reject</code>以后，<code>Promise</code> 的使命就完成了，后继操作应该放到<code>then</code>方法里面，而不应该直接写在<code>resolve</code>或<code>reject</code>的后面。所以，<ins>最好在它们前面加上<code>return</code>语句</ins>，这样就不会有意外。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">resolve</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="comment">// 后面的语句不会执行</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><hr><h3 id="16-4-then-方法"><a href="#16-4-then-方法" class="headerlink" title="16.4 then 方法"></a>16.4 then 方法</h3><p><code>Promise.then()</code>方法的作用是为 <code>Promise</code> 实例添加状态改变时的回调函数。<ins><code>then</code>方法的第一个参数是<code>resolved</code>状态的回调函数，第二个参数是<code>rejected</code>状态的回调函数</ins>，它们都是可选的。</p><p><ins><code>then</code>方法返回的是一个新的<code>Promise</code>实例</ins>，因此可以采用链式写法，即<code>then</code>方法后面再调用另一个<code>then</code>方法。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">getJSON</span>(<span class="string">&quot;/posts.json&quot;</span>).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">json</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> json.<span class="property">post</span>;</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">post</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面的代码使用<code>then</code>方法，依次指定了两个回调函数。<ins>第一个回调函数完成以后，会将返回结果作为参数，传入第二个回调函数</ins>。</p><p>链式写法的<code>then</code>，可以指定一组按照次序调用的回调函数。<ins>这时，前一个回调函数，有可能返回的还是一个<code>Promise</code>对象（即有异步操作），这时后一个回调函数，就会等待该<code>Promise</code>对象的状态发生变化，才会被调用</ins>。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">getJSON</span>(<span class="string">&quot;/post/1.json&quot;</span>).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">post</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">getJSON</span>(post.<span class="property">commentURL</span>);</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">comments</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;resolved: &quot;</span>, comments);</span><br><span class="line">&#125;, <span class="keyword">function</span> (<span class="params">err</span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;rejected: &quot;</span>, err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，第一个<code>then</code>方法指定的回调函数，返回的是另一个<code>Promise</code>对象。<ins>这时，第二个<code>then</code>方法指定的回调函数，就会等待这个新的<code>Promise</code>对象状态发生变化</ins>。</p><ul><li>如果变为<code>resolved</code>，第二个<code>then</code>方法就调用第一个回调函数。</li><li>如果状态变为<code>rejected</code>，第二个<code>then</code>方法就调用第二个回调函数。</li></ul><p>如果采用箭头函数，上面的代码可以写得更简洁。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">getJSON</span>(<span class="string">&quot;/post/1.json&quot;</span>).<span class="title function_">then</span>(</span><br><span class="line">  <span class="function"><span class="params">post</span> =&gt;</span> <span class="title function_">getJSON</span>(post.<span class="property">commentURL</span>)</span><br><span class="line">).<span class="title function_">then</span>(</span><br><span class="line">  <span class="function"><span class="params">comments</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;resolved: &quot;</span>, comments),</span><br><span class="line">  <span class="function"><span class="params">err</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;rejected: &quot;</span>, err)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><hr><h3 id="16-5-catch-方法"><a href="#16-5-catch-方法" class="headerlink" title="16.5 catch 方法"></a>16.5 catch 方法</h3><p><code>Promise.catch()</code>方法用于指定发生错误时的回调函数。<ins>它返回的是一个新的<code>Promise</code>对象</ins>。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">getJSON</span>(<span class="string">&#x27;/posts.json&#x27;</span>).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">posts</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="keyword">function</span>(<span class="params">error</span>) &#123;</span><br><span class="line">  <span class="comment">// 处理 getJSON 和 前一个回调函数运行时发生的错误</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;发生错误！&#x27;</span>, error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，<code>getJSON()</code>方法返回一个 <code>Promise</code> 对象。</p><ul><li>如果该对象状态变为<code>resolved</code>，则会调用<code>then()</code>方法指定的回调函数。</li><li>如果异步操作抛出错误，状态就会变为<code>rejected</code>，就会调用<code>catch()</code>方法指定的回调函数处理这个错误。</li></ul><p>注意，<ins><code>then()</code>方法指定的回调函数，如果运行中抛出错误，也会被<code>catch()</code>方法捕获</ins>。</p><p>下面代码中，<code>promise</code>抛出一个错误，被<code>catch()</code>方法指定的回调函数捕获。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;test&#x27;</span>); <span class="comment">// or reject(new Error(&#x27;test&#x27;));</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise.<span class="title function_">catch</span>(<span class="keyword">function</span>(<span class="params">error</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(error);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// Error: test</span></span><br></pre></td></tr></table></figure><p>下面两种写法与上面是等价的。（比较喜欢<code>try...catch...</code>的写法）</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;test&#x27;</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">    <span class="title function_">reject</span>(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise.<span class="title function_">catch</span>(<span class="keyword">function</span>(<span class="params">error</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(error);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">  <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;test&#x27;</span>));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise.<span class="title function_">catch</span>(<span class="keyword">function</span>(<span class="params">error</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>注意，如果<code>Promise</code>状态已经变成<code>resolved</code>，再抛出错误是无效的。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="string">&#x27;ok&#x27;</span>);</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;test&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise</span><br><span class="line">  .<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">value</span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(value) &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="keyword">function</span>(<span class="params">error</span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(error) &#125;);</span><br><span class="line"><span class="comment">// ok</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>Promise</code> 在<code>resolve</code>语句后面，再抛出错误，并不会被捕获。因为 <code>Promise</code> 的状态一旦改变，就永久保持该状态。</p><p><code>Promise</code> 对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止。也就是说，错误总是会被下一个<code>catch</code>语句捕获。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">getJSON</span>(<span class="string">&#x27;/post/1.json&#x27;</span>).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">post</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">getJSON</span>(post.<span class="property">commentURL</span>);</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">comments</span>) &#123;</span><br><span class="line">  <span class="comment">// some code</span></span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="keyword">function</span>(<span class="params">error</span>) &#123;</span><br><span class="line">  <span class="comment">// 处理前面三个Promise产生的错误</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，一共有三个 <code>Promise</code> 对象：一个由<code>getJSON()</code>产生，两个由<code>then()</code>产生。它们之中任何一个抛出的错误，都会被最后一个<code>catch()</code>捕获。</p><p>一般来说，<ins>不要在<code>then()</code>方法里面定义 <code>Reject</code> 状态的回调函数，总是使用<code>catch</code>方法</ins>。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line">promise</span><br><span class="line">  .<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">data</span>) &#123;</span><br><span class="line">    <span class="comment">// success</span></span><br><span class="line">  &#125;, <span class="keyword">function</span>(<span class="params">err</span>) &#123;</span><br><span class="line">    <span class="comment">// error</span></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line">promise</span><br><span class="line">  .<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">data</span>) &#123; </span><br><span class="line">    <span class="comment">// success</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="keyword">function</span>(<span class="params">err</span>) &#123;</span><br><span class="line">    <span class="comment">// error</span></span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>跟传统的<code>try/catch</code>代码块不同的是，<ins>如果没有使用<code>catch()</code>方法指定错误处理的回调函数，<code>Promise</code> 对象抛出的错误不会传递到外层代码</ins>，即不会有任何反应。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> someAsyncThing = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">    <span class="comment">// 下面一行会报错，因为 x 没有声明</span></span><br><span class="line">    <span class="title function_">resolve</span>(x + <span class="number">2</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">someAsyncThing</span>().<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;everything is great&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">123</span>) &#125;, <span class="number">2000</span>);</span><br><span class="line"><span class="comment">// Uncaught (in promise) ReferenceError: x is not defined</span></span><br><span class="line"><span class="comment">// 123</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>someAsyncThing()</code>函数产生的 <code>Promise</code> 对象，内部有语法错误。运行到这一行时，会打印出错误提示，但是不会终止脚本执行，<code>2</code> 秒之后还是会输出<code>123</code>。这就是说，<ins><code>Promise</code> 内部的错误不会影响到 <code>Promise</code> 外部的代码</ins>，通俗的说法就是“<code>Promise</code> 会吃掉错误”。</p><p>所以建议，<code>Promise</code> 对象后面要跟<code>catch()</code>方法，这样可以处理 <code>Promise</code> 内部发生的错误。注意，<ins><code>catch()</code>方法返回的是一个新的<code>Promise</code>对象</ins>，因此后面还可以接着调用<code>then()</code>方法，或者<code>catch()</code>方法，去处理前一个<code>catch()</code>方法抛出的错误。</p><hr><h3 id="16-6-finally-方法"><a href="#16-6-finally-方法" class="headerlink" title="16.6 finally 方法"></a>16.6 finally 方法</h3><p><code>Promise.finally()</code>方法用于指定不管<code>Promise</code>对象最后状态如何，都会执行的操作。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">promise</span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">result</span> =&gt;</span> &#123;···&#125;)</span><br><span class="line">.<span class="title function_">catch</span>(<span class="function"><span class="params">error</span> =&gt;</span> &#123;···&#125;)</span><br><span class="line">.<span class="title function_">finally</span>(<span class="function">() =&gt;</span> &#123;···&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，不管<code>promise</code>最后的状态，在执行完<code>then</code>或<code>catch</code>指定的回调函数以后，都会执行<code>finally</code>方法指定的回调函数。</p><p>下面是一个例子，服务器使用 <code>Promise</code> 处理请求，然后使用<code>finally</code>方法关掉服务器。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">server.<span class="title function_">listen</span>(port)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">finally</span>(server.<span class="property">stop</span>);</span><br></pre></td></tr></table></figure><p>由于<ins><code>finally</code>方法的回调函数不接受任何参数</ins>，这表明<ins><code>finally</code>方法里面的操作，应该是与状态无关的，不依赖于<code>Promise</code>的执行结果</ins>。</p><hr><h3 id="16-7-all-方法"><a href="#16-7-all-方法" class="headerlink" title="16.7 all 方法"></a>16.7 all 方法</h3><p><code>Promise.all()</code>方法用于将多个<code>Promise</code>实例，包装成一个新的<code>Promise</code>实例。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="title class_">Promise</span>.<span class="title function_">all</span>([p1, p2, p3]); <span class="comment">// 接受一个数组作为参数</span></span><br></pre></td></tr></table></figure><p>上面<code>p</code>的状态由<code>p1</code>、<code>p2</code>、<code>p3</code>决定，分成两种情况：</p><ul><li>只有<code>p1</code>、<code>p2</code>、<code>p3</code>的<ins>状态都变成<code>fulfilled</code>，<code>p</code>的状态才会变成<code>fulfilled</code></ins>，此时<ins><code>p1</code>、<code>p2</code>、<code>p3</code>的返回值组成一个数组，传递给<code>p</code>的回调函数</ins>。</li><li>只要<code>p1</code>、<code>p2</code>、<code>p3</code>之中<ins>有一个被<code>rejected</code>，<code>p</code>的状态就变成<code>rejected</code></ins>，此时<ins>第一个被<code>reject</code>的实例的返回值，会传递给<code>p</code>的回调函数</ins>。</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 生成一个Promise对象的数组</span></span><br><span class="line"><span class="keyword">const</span> promises = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>].<span class="title function_">map</span>(<span class="keyword">function</span> (<span class="params">id</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">getJSON</span>(<span class="string">&#x27;/post/&#x27;</span> + id + <span class="string">&quot;.json&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">all</span>(promises).<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">posts</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="keyword">function</span>(<span class="params">reason</span>)&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，只有<code>promises</code>中<code>6</code>个<code>Promise</code>实例的状态都变成<code>fulfilled</code>，或者有一个变为<code>rejected</code>，才会调用<code>Promise.all()</code>方法后面的回调函数。</p><p>下面是另一个例子。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> databasePromise = <span class="title function_">connectDatabase</span>(); <span class="comment">// 这里应该是返回一个 Promise 实例</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> booksPromise = databasePromise</span><br><span class="line">  .<span class="title function_">then</span>(findAllBooks); <span class="comment">// 返回一个 Promise Object，为当前 Promise 的状态</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> userPromise = databasePromise</span><br><span class="line">  .<span class="title function_">then</span>(getCurrentUser);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">all</span>([ </span><br><span class="line">  booksPromise,</span><br><span class="line">  userPromise</span><br><span class="line">])</span><br><span class="line">.<span class="title function_">then</span>(<span class="function">(<span class="params">[books, user]</span>) =&gt;</span> <span class="title function_">pickTopRecommendations</span>(books, user));</span><br></pre></td></tr></table></figure><p>上面代码中，<code>booksPromise</code>和<code>userPromise</code>是两个异步操作，只有等到它们的结果都返回了，才会触发<code>pickTopRecommendations</code>这个回调函数。</p><p>注意，如果<ins>作为参数的 <code>Promise</code> 实例，自己定义了<code>catch</code>方法，那么它一旦被<code>rejected</code>，并不会触发<code>Promise.all()</code>的<code>catch</code>方法</ins>。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">result</span> =&gt;</span> result)</span><br><span class="line">.<span class="title function_">catch</span>(<span class="function"><span class="params">e</span> =&gt;</span> e);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;报错了&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">result</span> =&gt;</span> result)</span><br><span class="line">.<span class="title function_">catch</span>(<span class="function"><span class="params">e</span> =&gt;</span> e);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">all</span>([p1, p2])</span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">result</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(result))</span><br><span class="line">.<span class="title function_">catch</span>(<span class="function"><span class="params">e</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(e));</span><br><span class="line"><span class="comment">// [&quot;hello&quot;, Error: 报错了]</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>p1</code>是<code>resolved</code>，<code>p2</code>会被<code>rejected</code>。但是<code>p2</code>有自己的<code>catch</code>方法，返回一个新的 <code>Promise</code> 实例，<code>p2</code>实际指向的是这个新的实例。<ins>该实例执行完<code>catch</code>方法后，也会变成<code>resolved</code>，导致<code>Promise.all()</code>方法参数里面的两个实例都会<code>resolved</code>，因此会调用<code>then</code>方法指定的回调函数</ins>，而不会调用<code>catch</code>方法指定的回调函数。</p><p>如果<code>p2</code>没有自己的<code>catch</code>方法，就会调用<code>Promise.all()</code>的<code>catch</code>方法。</p><hr><h3 id="16-8-race-方法"><a href="#16-8-race-方法" class="headerlink" title="16.8 race 方法"></a>16.8 race 方法</h3><p><code>Promise.race()</code>方法同样是将多个 <code>Promise</code> 实例，包装成一个新的 <code>Promise</code> 实例。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="title class_">Promise</span>.<span class="title function_">race</span>([p1, p2, p3]);</span><br></pre></td></tr></table></figure><p>上面代码中，只要<code>p1</code>、<code>p2</code>、<code>p3</code>之中<ins>有一个实例率先改变状态，<code>p</code>的状态就跟着改变</ins>。那个率先改变的 <code>Promise</code> 实例的返回值，就传递给<code>p</code>的回调函数。</p><p>下面如果指定时间内没有获得结果，就将 <code>Promise</code> 的状态变为<code>reject</code>，否则变为<code>resolve</code>。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="title class_">Promise</span>.<span class="title function_">race</span>([</span><br><span class="line">  <span class="title function_">fetch</span>(<span class="string">&#x27;/resource-that-may-take-a-while&#x27;</span>),</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;request timeout&#x27;</span>)), <span class="number">5000</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line">p</span><br><span class="line">.<span class="title function_">then</span>(<span class="variable language_">console</span>.<span class="property">log</span>)</span><br><span class="line">.<span class="title function_">catch</span>(<span class="variable language_">console</span>.<span class="property">error</span>);</span><br></pre></td></tr></table></figure><p>上面代码中，如果 <code>5</code> 秒之内<code>fetch</code>方法无法返回结果，变量<code>p</code>的状态就会变为<code>rejected</code>，从而触发<code>catch</code>方法指定的回调函数。</p><hr><h3 id="16-9-allSettled-方法"><a href="#16-9-allSettled-方法" class="headerlink" title="16.9 allSettled 方法"></a>16.9 allSettled 方法</h3><p>有时候，我们希望等到一组异步操作都结束，不管每一个操作是成功还是失败，再进行下一步操作。为了解决这个问题，<code>ES6</code> 引入了<code>Promise.allSettled()</code>方法。</p><p><code>Promise.allSettled()</code>方法接受一个<code>Promise</code>数组作为参数，并<ins>返回一个新的 <code>Promise</code> 对象</ins>。只有等到参数数组的<ins>所有 <code>Promise</code> 对象都发生状态变更，不管是<code>fulfilled</code>还是<code>rejected</code>，返回的 <code>Promise</code> 对象才会发生状态变更</ins>。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promises = [</span><br><span class="line">  <span class="title function_">fetch</span>(<span class="string">&#x27;/api-1&#x27;</span>),</span><br><span class="line">  <span class="title function_">fetch</span>(<span class="string">&#x27;/api-2&#x27;</span>),</span><br><span class="line">  <span class="title function_">fetch</span>(<span class="string">&#x27;/api-3&#x27;</span>),</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">allSettled</span>(promises);</span><br><span class="line"><span class="title function_">removeLoadingIndicator</span>();</span><br></pre></td></tr></table></figure><p>上面示例中，数组<code>promises</code>包含了三个请求，只有等到这三个请求都结束了，不管请求成功还是失败，<code>removeLoadingIndicator()</code>才会执行。</p><p><code>Promise.allSettled()</code>返回的 <code>Promise</code> 实例，<ins>状态总是<code>fulfilled</code>，不会变成<code>rejected</code></ins>。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> resolved = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">42</span>);</span><br><span class="line"><span class="keyword">const</span> rejected = <span class="title class_">Promise</span>.<span class="title function_">reject</span>(-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> allSettledPromise = <span class="title class_">Promise</span>.<span class="title function_">allSettled</span>([resolved, rejected]);</span><br><span class="line"></span><br><span class="line">allSettledPromise.<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">results</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(results);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// [</span></span><br><span class="line"><span class="comment">//    &#123; status: &#x27;fulfilled&#x27;, value: 42 &#125;,</span></span><br><span class="line"><span class="comment">//    &#123; status: &#x27;rejected&#x27;, reason: -1 &#125;</span></span><br><span class="line"><span class="comment">// ]</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>Promise.allSettled()</code>的返回值<code>allSettledPromise</code>，状态只可能变成<code>fulfilled</code>。<ins>它的回调函数接收到的参数是数组<code>results</code>，对应传入<code>Promise.allSettled()</code>的数组里面的两个 <code>Promise</code> 对象</ins>。</p><p>上面<code>results</code>的每个成员是一个对象，对应异步操作的结果。（重点）</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 异步操作成功时</span></span><br><span class="line">&#123;<span class="attr">status</span>: <span class="string">&#x27;fulfilled&#x27;</span>, <span class="attr">value</span>: value&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步操作失败时</span></span><br><span class="line">&#123;<span class="attr">status</span>: <span class="string">&#x27;rejected&#x27;</span>, <span class="attr">reason</span>: reason&#125;</span><br></pre></td></tr></table></figure><p>成员对象的<code>status</code>属性的值只可能是字符串<code>fulfilled</code>或字符串<code>rejected</code>，用来区分异步操作是成功还是失败。<ins>如果是成功<code>fulfilled</code>，对象会有<code>value</code>属性，如果是失败<code>rejected</code>，会有<code>reason</code>属性</ins>，对应两种状态时前面异步操作的返回值。</p><hr><h3 id="16-10-any-方法"><a href="#16-10-any-方法" class="headerlink" title="16.10 any 方法"></a>16.10 any 方法</h3><p><code>Promise.any()</code> 接受一组 <code>Promise</code> 实例作为参数，包装成一个新的 <code>Promise</code> 实例返回。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">any</span>([</span><br><span class="line">  <span class="title function_">fetch</span>(<span class="string">&#x27;https://v8.dev/&#x27;</span>).<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="string">&#x27;home&#x27;</span>),</span><br><span class="line">  <span class="title function_">fetch</span>(<span class="string">&#x27;https://v8.dev/blog&#x27;</span>).<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="string">&#x27;blog&#x27;</span>),</span><br><span class="line">  <span class="title function_">fetch</span>(<span class="string">&#x27;https://v8.dev/docs&#x27;</span>).<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="string">&#x27;docs&#x27;</span>)</span><br><span class="line">]).<span class="title function_">then</span>(<span class="function">(<span class="params">first</span>) =&gt;</span> &#123;  <span class="comment">// 只要有一个 fetch() 请求成功</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(first);</span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123; <span class="comment">// 所有三个 fetch() 全部请求失败</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li>只要参数实例有一个变成<code>fulfilled</code>状态，包装实例就会变成<code>fulfilled</code>状态。</li><li>如果所有参数实例都变成<code>rejected</code>状态，包装实例就会变成<code>rejected</code>状态。</li></ul><p>下面是<code>Promise()</code>与<code>await</code>命令结合使用的例子。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promises = [</span><br><span class="line">  <span class="title function_">fetch</span>(<span class="string">&#x27;/endpoint-a&#x27;</span>).<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="string">&#x27;a&#x27;</span>),</span><br><span class="line">  <span class="title function_">fetch</span>(<span class="string">&#x27;/endpoint-b&#x27;</span>).<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="string">&#x27;b&#x27;</span>),</span><br><span class="line">  <span class="title function_">fetch</span>(<span class="string">&#x27;/endpoint-c&#x27;</span>).<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="string">&#x27;c&#x27;</span>),</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> first = <span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">any</span>(promises);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(first);</span><br><span class="line">&#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(error);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>Promise.any()</code>方法的参数包含三个 <code>Promise</code> 操作。其中只要有一个变成<code>fulfilled</code>，<code>Promise.any()</code>返回的 <code>Promise</code> 对象就变成<code>fulfilled</code>。如果所有三个操作都变成<code>rejected</code>，那么<code>await</code>命令就会抛出错误。</p><hr><h3 id="16-11-resolve-方法"><a href="#16-11-resolve-方法" class="headerlink" title="16.11 resolve 方法"></a>16.11 resolve 方法</h3><p>有时需要将现有对象转为 <code>Promise</code> 对象，<code>Promise.resolve()</code>方法就起到这个作用。</p><p><strong>（1）参数是一个thenable对象</strong></p><p><code>thenable</code>对象指的是具有<code>then</code>方法的对象，比如下面这个对象。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> thenable = &#123;</span><br><span class="line">  <span class="attr">then</span>: <span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="number">42</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(thenable);</span><br><span class="line"></span><br><span class="line">p1.<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">value</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(value);  <span class="comment">// 42</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，<ins><code>resolve()</code>方法会将这个对象转为 <code>Promise</code> 对象，然后立即执行<code>thenable</code>对象的<code>then()</code>方法</ins>。</p><p><strong>（2）参数不是具有then()方法的对象，或根本就不是对象</strong></p><p>如果参数是一个原始值，或者是一个不具有<code>then()</code>方法的对象，则<code>resolve()</code>方法返回一个新的 <code>Promise</code> 对象，状态为<code>resolved</code>。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&#x27;Hello&#x27;</span>);</span><br><span class="line"></span><br><span class="line">p.<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">s</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(s)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// Hello</span></span><br></pre></td></tr></table></figure><p><strong>（3）不带有任何参数</strong></p><p><code>resolve()</code>方法调用时可以<ins>不带参数，直接返回一个<code>resolved</code>状态的 <code>Promise</code> 对象</ins>。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>();</span><br><span class="line"></span><br><span class="line">p.<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><ins>立即<code>resolve()</code>的 <code>Promise</code> 对象，是在本轮“事件循环”的结束时执行，而不是在下一轮“事件循环”的开始时</ins>。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;three&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;two&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;one&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// one</span></span><br><span class="line"><span class="comment">// two</span></span><br><span class="line"><span class="comment">// three</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>setTimeout(fn, 0)</code>在下一轮“事件循环”开始时执行，<code>resolve()</code>在本轮“事件循环”结束时执行，<code>console.log(&#39;one&#39;)</code>则是立即执行，因此最先输出。</p><hr><h3 id="16-12-reject-方法"><a href="#16-12-reject-方法" class="headerlink" title="16.12 reject 方法"></a>16.12 reject 方法</h3><p><code>Promise.reject(reason)</code>方法也会返回一个新的 <code>Promise</code> 实例，该实例的状态为<code>rejected</code>。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="string">&#x27;出错了&#x27;</span>);</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="title function_">reject</span>(<span class="string">&#x27;出错了&#x27;</span>))</span><br><span class="line"></span><br><span class="line">p.<span class="title function_">then</span>(<span class="literal">null</span>, <span class="keyword">function</span> (<span class="params">s</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(s)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 出错了</span></span><br></pre></td></tr></table></figure><p><code>Promise.reject()</code>方法的参数，会原封不动地作为<code>reject</code>的理由，变成后续方法的参数。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="string">&#x27;出错了&#x27;</span>)</span><br><span class="line">.<span class="title function_">catch</span>(<span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(e === <span class="string">&#x27;出错了&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure><hr><h2 id="17-Iterator-和-for…of-循环"><a href="#17-Iterator-和-for…of-循环" class="headerlink" title="17. Iterator 和 for…of 循环"></a>17. Iterator 和 for…of 循环</h2><h3 id="17-1-Iterator-概念"><a href="#17-1-Iterator-概念" class="headerlink" title="17.1 Iterator 概念"></a>17.1 Iterator 概念</h3><p>遍历器<code>Iterator</code>是一种接口，<ins>为各种不同的数据结构提供统一的访问机制</ins>。任何数据结构只要部署 <code>Iterator</code> 接口，就可以完成遍历操作，依次处理该数据结构的所有成员。</p><p><code>Iterator</code> 的遍历过程：</p><ol><li>创建一个指针对象，指向当前数据结构的起始位置。</li><li>第一次调用指针对象的<code>next</code>方法，可以将指针指向数据结构的第一个成员。</li><li>第二次调用指针对象的<code>next</code>方法，指针就指向数据结构的第二个成员。</li><li>不断调用指针对象的<code>next</code>方法，直到它指向数据结构的结束位置。</li></ol><p>每一次调用<code>next</code>方法，都会返回数据结构的当前成员的信息。具体来说，就是返回一个包含<code>value</code>和<code>done</code>两个属性的对象。其中，<ins><code>value</code>属性是当前成员的值，<code>done</code>属性是一个布尔值，表示遍历是否结束</ins>。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = [<span class="number">1</span>,<span class="number">5</span>,<span class="number">15</span>,<span class="number">25</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> it = a[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]();</span><br><span class="line"></span><br><span class="line">it.<span class="title function_">next</span>().<span class="property">value</span> <span class="comment">// 1</span></span><br><span class="line">it.<span class="title function_">next</span>().<span class="property">value</span> <span class="comment">// 5</span></span><br><span class="line">it.<span class="title function_">next</span>().<span class="property">value</span> <span class="comment">// 15</span></span><br></pre></td></tr></table></figure><p><code>ES6</code> 规定，默认的 <code>Iterator</code> 接口部署在数据结构的<code>Symbol.iterator</code>属性，或者说，一个数据结构只要具有<code>Symbol.iterator</code>属性，就可以认为是“可遍历的”。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    <span class="attr">numbers</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">    [<span class="title class_">Symbol</span>.<span class="property">iterator</span>]: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> self = <span class="variable language_">this</span>;</span><br><span class="line">        <span class="keyword">let</span> idx = -<span class="number">1</span>; <span class="comment">// &lt;--- 抵消 ++ 的 side-effect</span></span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="attr">next</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">                idx++;</span><br><span class="line">                <span class="comment">// 可以尝试 log 出下面的 object</span></span><br><span class="line">                <span class="keyword">return</span> &#123;</span><br><span class="line">                    <span class="attr">value</span>: self.<span class="property">numbers</span>[idx],</span><br><span class="line">                    <span class="attr">done</span>: idx &gt;= self.<span class="property">numbers</span>.<span class="property">length</span>,</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> num <span class="keyword">of</span> obj) <span class="variable language_">console</span>.<span class="title function_">log</span>(num); <span class="comment">// 1 2 3</span></span><br></pre></td></tr></table></figure><p>上面代码中，对象<code>obj</code>是可遍历的，因为具有<code>Symbol.iterator</code>属性。执行这个属性，会返回一个遍历器对象。该对象的根本特征就是具有<code>next</code>方法。每次调用<code>next</code>方法，都会返回一个代表当前成员的信息对象，具有<code>value</code>和<code>done</code>两个属性。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 上面 iterator 打印出来的 objects</span></span><br><span class="line">&#123; <span class="attr">value</span>: <span class="number">1</span>, <span class="attr">done</span>: <span class="literal">false</span> &#125;</span><br><span class="line">&#123; <span class="attr">value</span>: <span class="number">2</span>, <span class="attr">done</span>: <span class="literal">false</span> &#125;</span><br><span class="line">&#123; <span class="attr">value</span>: <span class="number">3</span>, <span class="attr">done</span>: <span class="literal">false</span> &#125;</span><br><span class="line">&#123; <span class="attr">value</span>: <span class="literal">undefined</span>, <span class="attr">done</span>: <span class="literal">true</span> &#125;</span><br></pre></td></tr></table></figure><p>注意，<code>done</code> 不代表返回的值是否是最后一个，而是表示迭代器是否没有更多的值可以返回。</p><hr><h3 id="17-2-for…of-循环"><a href="#17-2-for…of-循环" class="headerlink" title="17.2 for…of 循环"></a>17.2 for…of 循环</h3><p><strong>（1）数组，Set 与 Map</strong> </p><p><code>ES6</code> 的数组，<code>Set</code> 和 <code>Map</code> 原生具有 <code>Iterator</code> 接口。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> color <span class="keyword">of</span> arr) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(color);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// red green blue</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>(arr);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> color <span class="keyword">of</span> set) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(color);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// red green blue</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>().<span class="title function_">set</span>(<span class="string">&#x27;a&#x27;</span>, <span class="number">1</span>).<span class="title function_">set</span>(<span class="string">&#x27;b&#x27;</span>, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> pair <span class="keyword">of</span> map) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(pair);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// [&#x27;a&#x27;, 1]</span></span><br><span class="line"><span class="comment">// [&#x27;b&#x27;, 2]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> map) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(key + <span class="string">&#x27; : &#x27;</span> + value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// a : 1</span></span><br><span class="line"><span class="comment">// b : 2</span></span><br></pre></td></tr></table></figure><p>上面代码可以看出，<code>Set</code> 和 <code>Map</code> 遍历的顺序是按照各个成员被添加进数据结构的顺序。</p><p><strong>（2）计算生成的数据结构</strong> </p><p>有些数据结构是在现有数据结构的基础上，计算生成的。比如，<code>ES6</code> 的数组、<code>Set</code>、<code>Map</code> 都部署了以下三个方法，调用后都返回遍历器对象。</p><ul><li><code>entries()</code> 返回一个遍历器对象，用来遍历[键名, 键值]组成的数组。</li><li><code>keys()</code> 返回一个遍历器对象，用来遍历所有的键名。</li><li><code>values()</code> 返回一个遍历器对象，用来遍历所有的键值。</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> pair <span class="keyword">of</span> arr.<span class="title function_">entries</span>()) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(pair);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// [0, &#x27;a&#x27;]</span></span><br><span class="line"><span class="comment">// [1, &#x27;b&#x27;]</span></span><br><span class="line"><span class="comment">// [2, &#x27;c&#x27;]</span></span><br></pre></td></tr></table></figure><p><strong>（3）类似数组的对象</strong> </p><p>字符串是一个类似数组的对象，也原生具有 <code>Iterator</code> 接口。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 字符串</span></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> s <span class="keyword">of</span> str) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(s); <span class="comment">// h e l l o</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// arguments对象</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">printArgs</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">of</span> <span class="variable language_">arguments</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">printArgs</span>(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>);</span><br><span class="line"><span class="comment">// &#x27;a&#x27;</span></span><br><span class="line"><span class="comment">// &#x27;b&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>（4）对象</strong> </p><p><code>for...of</code>不能直接使用于普通对象上，必须部署 <code>Iterator</code> 接口后才能使用。</p><ul><li>一种解决方法是，遍历<code>Object.keys()</code>生成的对象键名的数组。</li><li>一种解决方法是，使用 <code>Generator</code> 函数将对象重新包装。</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">c</span>: <span class="number">3</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方案一</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> <span class="title class_">Object</span>.<span class="title function_">keys</span>(obj)) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(key, <span class="string">&#x27;-&gt;&#x27;</span>, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方案二</span></span><br><span class="line"><span class="keyword">function</span>* <span class="title function_">entries</span>(<span class="params">obj</span>) &#123; </span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> <span class="title class_">Object</span>.<span class="title function_">keys</span>(obj)) &#123;</span><br><span class="line">    <span class="keyword">yield</span> [key, obj[key]];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> <span class="title function_">entries</span>(obj)) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(key, <span class="string">&#x27;-&gt;&#x27;</span>, value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// a -&gt; 1</span></span><br><span class="line"><span class="comment">// b -&gt; 2</span></span><br><span class="line"><span class="comment">// c -&gt; 3</span></span><br></pre></td></tr></table></figure><hr><h2 id="18-Generator-函数"><a href="#18-Generator-函数" class="headerlink" title="18. Generator 函数"></a>18. Generator 函数</h2><h3 id="18-1-基本概念"><a href="#18-1-基本概念" class="headerlink" title="18.1 基本概念"></a>18.1 基本概念</h3><p><code>Generator</code> 函数是 <code>ES6</code> 提供的一种异步编程解决方案，语法行为与传统函数完全不同。</p><ul><li><strong>语法上：</strong><ins><code>Generator</code> 函数类似一个状态机，封装了多个内部状态</ins>。执行 <code>Generator</code> 函数会返回一个遍历器对象，<ins>可以依次遍历 <code>Generator</code> 函数内部的每一个状态</ins>。</li><li><strong>形式上：</strong><code>Generator</code> 函数是一个普通函数，但是有两个特征。一是，<code>function</code>关键字与函数名之间有一个星号；二是，函数体内部使用<code>yield</code>表达式，定义不同的内部状态。</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">hwGenerator</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&#x27;world&#x27;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;ending&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> hw = <span class="title function_">hwGenerator</span>();</span><br></pre></td></tr></table></figure><p>上面代码定义了一个 <code>Generator</code> 函数<code>hwGenerator</code>，它内部有两个<code>yield</code>表达式<code>hello</code>和<code>world</code>，即该函数有三个状态：<code>hello</code>，<code>world</code> 和 <code>return</code> 语句。</p><p><code>Generator</code> 函数的调用方法与普通函数一样。不同的是，<ins>调用 <code>Generator</code> 函数后，该函数并不执行，返回的也不是函数运行结果，而是一个指向内部状态的指针对象</ins>。通过调用遍历器对象的<code>next</code>方法，<ins>使得指针移向下一个状态</ins>。</p><p>每次调用<code>next</code>方法，内部指针就从函数头部或上一次停下来的地方开始执行，直到遇到下一个<code>yield</code>表达式（或<code>return</code>语句）为止。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">hw.<span class="title function_">next</span>()</span><br><span class="line"><span class="comment">// &#123; value: &#x27;hello&#x27;, done: false &#125;</span></span><br><span class="line"></span><br><span class="line">hw.<span class="title function_">next</span>()</span><br><span class="line"><span class="comment">// &#123; value: &#x27;world&#x27;, done: false &#125;</span></span><br><span class="line"></span><br><span class="line">hw.<span class="title function_">next</span>()</span><br><span class="line"><span class="comment">// &#123; value: &#x27;ending&#x27;, done: true &#125;</span></span><br><span class="line"></span><br><span class="line">hw.<span class="title function_">next</span>()</span><br><span class="line"><span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure><p>总结，调用 <code>Generator</code> 函数，返回一个遍历器对象，代表 <code>Generator</code> 函数的内部指针。每次调用遍历器对象的<code>next</code>方法，就会返回一个有着<code>value</code>和<code>done</code>两个属性的对象。<code>value</code>属性表示当前的内部状态的值，是<code>yield</code>表达式后面那个表达式的值；<code>done</code>属性是一个布尔值，表示是否遍历结束。</p><hr><h3 id="18-2-yield-表达式"><a href="#18-2-yield-表达式" class="headerlink" title="18.2 yield 表达式"></a>18.2 yield 表达式</h3><p>由于 <code>Generator</code> 函数返回的<ins>遍历器对象，只有调用<code>next</code>方法才会遍历下一个内部状态</ins>，所以<code>Generator</code>其实<ins>提供了一种可以暂停执行的函数</ins>。<code>yield</code>表达式就是暂停标志。</p><p>遍历器对象的<code>next</code>方法的运行逻辑如下：</p><ul><li><ins>遇到<code>yield</code>表达式，就暂停执行后面的操作，并将紧跟在<code>yield</code>后面的那个表达式的值，作为返回的对象的<code>value</code>属性值</ins>。</li><li>下一次调用<code>next</code>方法时，再继续往下执行，直到遇到下一个<code>yield</code>表达式。</li><li>如果没有再遇到新的<code>yield</code>表达式，就一直运行到函数结束，直到<code>return</code>语句为止，并将<code>return</code>语句后面的表达式的值，作为返回的对象的<code>value</code>属性值。</li><li>如果该函数没有<code>return</code>语句，则返回的对象的<code>value</code>属性值为<code>undefined</code>。</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">gen</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">yield</span>  <span class="number">123</span> + <span class="number">456</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> g = <span class="title function_">gen</span>()</span><br><span class="line">g.<span class="title function_">next</span>() <span class="comment">// &#123;value: 579, done: false&#125;</span></span><br><span class="line">g.<span class="title function_">next</span>() <span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure><p><code>yield</code>表达式与<code>return</code>语句既有相似之处，也有区别。相似之处在于，都能返回紧跟在语句后面的那个表达式的值。<ins>区别在于每次遇到<code>yield</code>，函数暂停执行，下一次再从该位置继续向后执行，而<code>return</code>语句不具备位置记忆的功能</ins>。一个函数里面，只能执行一次<code>return</code>语句，但是可以执行多次<code>yield</code>表达式。</p><hr><h3 id="18-3-与-Iterator-接口的关系"><a href="#18-3-与-Iterator-接口的关系" class="headerlink" title="18.3 与 Iterator 接口的关系"></a>18.3 与 Iterator 接口的关系</h3><p>由于 <code>Generator</code> 函数就是遍历器生成函数，因此可以把 <code>Generator</code> 赋值给对象的<code>Symbol.iterator</code>属性，从而使得该对象具有 <code>Iterator</code> 接口。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> myIterable = &#123;&#125;;</span><br><span class="line">myIterable[<span class="title class_">Symbol</span>.<span class="property">iterator</span>] = <span class="keyword">function</span>* () &#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">[...myIterable] <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>Generator</code> 函数赋值给<code>Symbol.iterator</code>属性，从而使得<code>myIterable</code>对象具有了 <code>Iterator</code> 接口，可以被<code>...</code>运算符遍历了。</p><hr><h3 id="18-4-next-方法的参数"><a href="#18-4-next-方法的参数" class="headerlink" title="18.4 next 方法的参数"></a>18.4 next 方法的参数</h3><p><code>yield</code>表达式本身没有返回值，或者说总是返回<code>undefined</code>。<code>next</code>方法可以带一个参数，<ins>该参数就会被当作上一个<code>yield</code>表达式的返回值</ins>。（每一次调用<code>next</code>方法，都会返回数据结构的当前成员的信息）</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; <span class="literal">true</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> reset = <span class="keyword">yield</span> i;</span><br><span class="line">    <span class="keyword">if</span> (reset) &#123;</span><br><span class="line">      i = -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> g = <span class="title function_">f</span>(); <span class="comment">// 启动</span></span><br><span class="line"></span><br><span class="line">g.<span class="title function_">next</span>() <span class="comment">// &#123; value: 0, done: false &#125;</span></span><br><span class="line">g.<span class="title function_">next</span>() <span class="comment">// &#123; value: 1, done: false &#125;</span></span><br><span class="line">g.<span class="title function_">next</span>(<span class="literal">true</span>) <span class="comment">// &#123; value: 0, done: false &#125;</span></span><br><span class="line"><span class="comment">// 此时 rest 为 true，所以 i = -1，又因为 i++，</span></span><br><span class="line"><span class="comment">// 所以下一次运行到 yield i 的时候 i 就是 0 </span></span><br></pre></td></tr></table></figure><p>上面代码定义了一个可以无限运行的 <code>Generator</code> 函数<code>f</code>，如果<code>next</code>方法没有参数，每次运行到<code>yield</code>表达式，变量<code>reset</code>的值总是<code>undefined</code>。当<code>next</code>方法带一个参数<code>true</code>时，变量<code>reset</code>就被重置为这个参数，因此<code>i</code>会等于<code>-1</code>，下一轮循环就会从<code>-1</code>开始递增。</p><p>这个功能有很重要的意义。<code>Generator</code> 函数从暂停状态到恢复运行，它的上下文状态<code>context</code>是不变的。通过<code>next</code>方法的参数，就有办法在 <code>Generator</code> 函数开始运行之后，继续向函数体内部注入值。<ins>从而在 <code>Generator</code> 函数运行的不同阶段，调整函数行为</ins>。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">foo</span>(<span class="params">x</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> y = <span class="number">2</span> * (<span class="keyword">yield</span> (x + <span class="number">1</span>));</span><br><span class="line">  <span class="keyword">let</span> z = <span class="keyword">yield</span> (y / <span class="number">3</span>);</span><br><span class="line">  <span class="keyword">return</span> (x + y + z);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="title function_">foo</span>(<span class="number">5</span>);</span><br><span class="line">a.<span class="title function_">next</span>() <span class="comment">// &#123; value:6, done:false &#125;</span></span><br><span class="line">a.<span class="title function_">next</span>() <span class="comment">// 此时 y 为 undefined, &#123; value:NaN, done:false &#125;</span></span><br><span class="line">a.<span class="title function_">next</span>() <span class="comment">// 此时 z 为 undefined, &#123; value:NaN, done:true &#125;</span></span><br></pre></td></tr></table></figure><p>上面代码中，第二次运行<code>next()</code>的时候不带参数，导致 <code>y</code> 的值等于<code>2 * undefined</code>，除以 <code>3</code> 以后变成<code>NaN</code>，因此返回对象的<code>value</code>属性也等于<code>NaN</code>。第三次运行<code>next</code>方法的时候不带参数，所以<code>z</code>等于<code>undefined</code>，返回对象的<code>value</code>属性等于<code>5 + NaN + undefined</code>，即<code>NaN</code>。</p><p>如果向<code>next</code>方法提供参数，返回结果就完全不一样。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> b = <span class="title function_">foo</span>(<span class="number">5</span>);</span><br><span class="line">b.<span class="title function_">next</span>() <span class="comment">// &#123; value:6, done:false &#125;</span></span><br><span class="line">b.<span class="title function_">next</span>(<span class="number">12</span>) <span class="comment">// 此时 y 为 24, 因为 yield (x + 1) = 12, &#123; value:8, done:false &#125;</span></span><br><span class="line">b.<span class="title function_">next</span>(<span class="number">13</span>) <span class="comment">// 此时 z 为 13, 因为 yield (y / 3) = 13, &#123; value:42, done:true &#125;</span></span><br></pre></td></tr></table></figure><p>上面代码第一次调用<code>next</code>方法时，返回<code>x+1</code>的值<code>6</code>；第二次调用<code>next</code>方法，将上一次<code>yield</code>表达式的值设为<code>12</code>，因此<code>y</code>等于<code>24</code>，返回<code>y / 3</code>的值<code>8</code>；第三次调用<code>next</code>方法，将上一次<code>yield</code>表达式的值设为<code>13</code>，因此<code>z</code>等于<code>13</code>，这时<code>x</code>等于<code>5</code>，<code>y</code>等于<code>24</code>，所以<code>return</code>语句的值等于<code>42</code>。</p><p>注意，由于<code>next</code>方法的参数表示上一个<code>yield</code>表达式的返回值，所以在第一次使用<code>next</code>方法时，传递参数是无效的。</p><hr><h3 id="18-5-for…of-循环"><a href="#18-5-for…of-循环" class="headerlink" title="18.5 for…of 循环"></a>18.5 for…of 循环</h3><p><code>for...of</code>可以自动遍历 <code>Generator</code> 函数生成的<code>Iterator</code>对象，且不需要调用<code>next</code>方法。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> v <span class="keyword">of</span> <span class="title function_">foo</span>()) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1 2 3 (没有4)</span></span><br></pre></td></tr></table></figure><p>上面的代码可以看出，一旦返回对象的<code>done</code>属性为<code>true</code>，<code>for...of</code>循环就会中止，且不包含该返回对象。所以上面代码的<code>return</code>语句返回的<code>4</code>，不包括在<code>for...of</code>循环之中。</p><p>除了<code>for...of</code>循环以外，扩展运算符、解构赋值和<code>Array.from</code>方法内部调用的，都是遍历器接口。这意味着，它们都可以将 <code>Generator</code> 函数返回的遍历器对象，作为参数。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span>* numbers () &#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">3</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="number">4</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩展运算符</span></span><br><span class="line">[...<span class="title function_">numbers</span>()] <span class="comment">// [1, 2]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Array.from 方法</span></span><br><span class="line"><span class="title class_">Array</span>.<span class="title function_">from</span>(<span class="title function_">numbers</span>()) <span class="comment">// [1, 2]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 解构赋值</span></span><br><span class="line"><span class="keyword">let</span> [x, y] = <span class="title function_">numbers</span>();</span><br><span class="line">x <span class="comment">// 1</span></span><br><span class="line">y <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><hr><h3 id="18-6-throw-方法"><a href="#18-6-throw-方法" class="headerlink" title="18.6 throw 方法"></a>18.6 throw 方法</h3><p>遍历器对象的<code>throw()</code>方法，可以<ins>在函数体外抛出错误，然后在 <code>Generator</code> 函数体内捕获</ins>。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> g = <span class="keyword">function</span>* () &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">yield</span>;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;内部捕获&#x27;</span>, e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> i = <span class="title function_">g</span>();</span><br><span class="line">i.<span class="title function_">next</span>(); <span class="comment">// 初始化启动</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  i.<span class="keyword">throw</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">  i.<span class="keyword">throw</span>(<span class="string">&#x27;b&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;外部捕获&#x27;</span>, e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 内部捕获 a</span></span><br><span class="line"><span class="comment">// 外部捕获 b</span></span><br></pre></td></tr></table></figure><p>上面代码中，遍历器对象<code>i</code>连续抛出两个错误。<ins>第一个错误被 <code>Generator</code> 函数体内的<code>catch</code>语句捕获</ins>。<code>i</code>第二次抛出错误，由于 <code>Generator</code> 函数内部的<code>catch</code>语句已经执行过了，不会再捕捉到这个错误了，所以这个错误就<ins>被函数体外的<code>catch</code>语句捕获</ins>。</p><p>注意，不要混淆遍历器对象的<code>throw</code>方法和全局的<code>throw</code>命令。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;b&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;外部捕获&#x27;</span>, e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 外部捕获 [Error: a]</span></span><br></pre></td></tr></table></figure><p>上面代码之所以只捕获了<code>a</code>，是因为函数体外的<code>catch</code>语句块，捕获了抛出的<code>a</code>错误以后，就不会再继续<code>try</code>代码块里面剩余的语句了。</p><ul><li>如果 <code>Generator</code> 函数内部没有部署<code>try...catch</code>代码块，那么<code>throw</code>方法抛出的错误，<ins>将被外部<code>try...catch</code>代码块捕获</ins>。</li><li>如果 <code>Generator</code> 函数内部和外部，都没有部署<code>try...catch</code>代码块，那么程序将报错，直接中断执行。</li></ul><p><code>throw</code>方法抛出的错误要被内部捕获，<ins>前提是必须至少执行过一次<code>next</code>方法</ins>。同时，<ins><code>throw</code>方法被捕获后，会附带执行下一条<code>yield</code>表达式</ins>，等同于执行一次<code>next</code>方法。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> gen = <span class="keyword">function</span>* <span class="title function_">gen</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">yield</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;b&#x27;</span>);</span><br><span class="line">  <span class="keyword">yield</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;c&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> g = <span class="title function_">gen</span>();</span><br><span class="line">g.<span class="title function_">next</span>() <span class="comment">// a</span></span><br><span class="line">g.<span class="keyword">throw</span>() <span class="comment">// b</span></span><br><span class="line">g.<span class="title function_">next</span>() <span class="comment">// c</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>g.throw()</code>方法被捕获以后，自动执行了一次<code>next</code>方法，所以会打印<code>b</code>。这里可以看出，<ins>只要 <code>Generator</code> 函数内部部署了<code>try...catch</code>代码块，那么遍历器的<code>throw</code>方法抛出的错误，不影响下一次遍历</ins>。</p><p><code>Generator</code> 函数体外抛出的错误，可以在函数体内捕获；反过来，<code>Generator</code> 函数体内抛出的错误，也可以被函数体外的<code>catch</code>捕获。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> x = <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">let</span> y = x.<span class="title function_">toUpperCase</span>();</span><br><span class="line">  <span class="keyword">yield</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> it = <span class="title function_">foo</span>();</span><br><span class="line"></span><br><span class="line">it.<span class="title function_">next</span>(); <span class="comment">// &#123; value:3, done:false &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  it.<span class="title function_">next</span>(<span class="number">42</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(err);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，第二个<code>next</code>方法向函数体内传入一个参数 <code>42</code>，数值是没有<code>toUpperCase</code>方法的，所以会抛出一个 <code>TypeError</code> 错误，被函数体外的<code>catch</code>捕获。</p><hr><h3 id="18-7-return-方法"><a href="#18-7-return-方法" class="headerlink" title="18.7 return 方法"></a>18.7 return 方法</h3><p>遍历器对象的<code>return()</code>方法，可以返回给定的值，并且<ins>终结遍历 <code>Generator</code> 函数</ins>。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">gen</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> g = <span class="title function_">gen</span>();</span><br><span class="line"></span><br><span class="line">g.<span class="title function_">next</span>()        <span class="comment">// &#123; value: 1, done: false &#125;</span></span><br><span class="line">g.<span class="keyword">return</span>(<span class="string">&#x27;foo&#x27;</span>) <span class="comment">// &#123; value: &quot;foo&quot;, done: true &#125;</span></span><br><span class="line">g.<span class="title function_">next</span>()        <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure><p>上面代码中，遍历器对象<code>g</code>调用<code>return()</code>方法后，返回值的<code>value</code>属性就是<code>return()</code>方法的参数<code>foo</code>。并且，<code>Generator</code> 函数的遍历就终止了，返回值的<code>done</code>属性为<code>true</code>。</p><ul><li>如果<code>return()</code>方法调用时，不提供参数，则返回值的<code>value</code>属性为<code>undefined</code>。</li><li>如果 <code>Generator</code> 函数内部有<code>try...finally</code>代码块，且正在执行<code>try</code>代码块，那么<code>return()</code>方法会导致立刻进入<code>finally</code>代码块。</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span>* numbers () &#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">5</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">6</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> g = <span class="title function_">numbers</span>();</span><br><span class="line">g.<span class="title function_">next</span>() <span class="comment">// &#123; value: 1, done: false &#125;</span></span><br><span class="line">g.<span class="title function_">next</span>() <span class="comment">// &#123; value: 2, done: false &#125;</span></span><br><span class="line">g.<span class="keyword">return</span>(<span class="number">7</span>) <span class="comment">// &#123; value: 4, done: false &#125;</span></span><br><span class="line">g.<span class="title function_">next</span>() <span class="comment">// &#123; value: 5, done: false &#125;</span></span><br><span class="line">g.<span class="title function_">next</span>() <span class="comment">// &#123; value: 7, done: true &#125;</span></span><br></pre></td></tr></table></figure><p>上面代码中，调用<code>return()</code>方法后，就开始执行<code>finally</code>代码块，不执行<code>try</code>里面剩下的代码了，然后等到<code>finally</code>代码块执行完，再返回<code>return()</code>方法指定的返回值。</p><hr><h3 id="18-8-方法的共同点"><a href="#18-8-方法的共同点" class="headerlink" title="18.8 方法的共同点"></a>18.8 方法的共同点</h3><p><code>Generator</code> 函数返回的遍历器对象的<code>next()</code>、<code>throw()</code>、<code>return()</code>本质上是同一件事，它们的作用都是让 <code>Generator</code> 函数恢复执行，并且使用不同的语句替换<code>yield</code>表达式。</p><ul><li><code>next()</code>方法是将<code>yield</code>表达式替换成一个值。</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> g = <span class="keyword">function</span>* (x, y) &#123;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="keyword">yield</span> x + y;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> gen = <span class="title function_">g</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">gen.<span class="title function_">next</span>(); <span class="comment">// Object &#123;value: 3, done: false&#125;</span></span><br><span class="line"></span><br><span class="line">gen.<span class="title function_">next</span>(<span class="number">1</span>); <span class="comment">// Object &#123;value: 1, done: true&#125;</span></span><br><span class="line"><span class="comment">// 相当于将 let result = yield x + y</span></span><br><span class="line"><span class="comment">// 替换成 let result = 1;</span></span><br></pre></td></tr></table></figure><ul><li><code>throw()</code>方法是将<code>yield</code>表达式替换成一个<code>throw</code>语句。</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">gen.<span class="keyword">throw</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;出错了&#x27;</span>)); <span class="comment">// Uncaught Error: 出错了</span></span><br><span class="line"><span class="comment">// 相当于将 let result = yield x + y</span></span><br><span class="line"><span class="comment">// 替换成 let result = throw(new Error(&#x27;出错了&#x27;));</span></span><br></pre></td></tr></table></figure><ul><li><code>return()</code>方法是将<code>yield</code>表达式替换成一个<code>return</code>语句。</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">gen.<span class="keyword">return</span>(<span class="number">2</span>); <span class="comment">// Object &#123;value: 2, done: true&#125;</span></span><br><span class="line"><span class="comment">// 相当于将 let result = yield x + y</span></span><br><span class="line"><span class="comment">// 替换成 let result = return 2;</span></span><br></pre></td></tr></table></figure><hr><h3 id="18-9-yield-表达式"><a href="#18-9-yield-表达式" class="headerlink" title="18.9 yield* 表达式"></a>18.9 yield* 表达式</h3><p><code>ES6</code> 提供的<code>yield*</code>表达式，可以在一个 <code>Generator</code> 函数里面执行另一个 <code>Generator</code> 函数。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> delegatedIterator = (<span class="keyword">function</span>* () &#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&#x27;Hello!&#x27;</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&#x27;Bye!&#x27;</span>;</span><br><span class="line">&#125;());</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> delegatingIterator = (<span class="keyword">function</span>* () &#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&#x27;Greetings!&#x27;</span>;</span><br><span class="line">  <span class="keyword">yield</span>* delegatedIterator;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&#x27;Ok, bye.&#x27;</span>;</span><br><span class="line">&#125;());</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> value <span class="keyword">of</span> delegatingIterator) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &quot;Greetings!</span></span><br><span class="line"><span class="comment">// &quot;Hello!&quot;</span></span><br><span class="line"><span class="comment">// &quot;Bye!&quot;</span></span><br><span class="line"><span class="comment">// &quot;Ok, bye.&quot;</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>delegatingIterator</code>是代理者，<code>delegatedIterator</code>是被代理者。如果被代理的 <code>Generator</code> 函数有<code>return</code>语句，那么就可以向代理它的 <code>Generator</code> 函数返回数据。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">genFuncWithReturn</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;The result&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span>* <span class="title function_">logReturned</span>(<span class="params">genObj</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="keyword">yield</span>* genObj;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[...<span class="title function_">logReturned</span>(<span class="title function_">genFuncWithReturn</span>())]</span><br><span class="line"><span class="comment">// The result</span></span><br><span class="line"><span class="comment">// 值为 [ &#x27;a&#x27;, &#x27;b&#x27; ]</span></span><br></pre></td></tr></table></figure><p>上面代码中，存在两次遍历。</p><ul><li>第一次是扩展运算符遍历函数<code>logReturned</code>返回的遍历器对象。</li><li>第二次是<code>yield*</code>语句遍历函数<code>genFuncWithReturn</code>返回的遍历器对象。</li></ul><p>这两次遍历的效果是叠加的，最终表现为扩展运算符遍历函数<code>genFuncWithReturn</code>返回的遍历器对象。所以最后的数据表达式得到的值等于<code>[ &#39;a&#39;, &#39;b&#39; ]</code>。同时，函数<code>genFuncWithReturn</code>的<code>return</code>语句的返回值<code>The result</code>，会返回给函数<code>logReturned</code>内部的<code>result</code>变量。</p><hr><h3 id="18-10-作为对象的属性"><a href="#18-10-作为对象的属性" class="headerlink" title="18.10 作为对象的属性"></a>18.10 作为对象的属性</h3><p>如果一个对象的属性是 <code>Generator</code> 函数，可以简写成下面的形式。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  * <span class="title function_">myGeneratorMethod</span>(<span class="params"></span>) &#123;</span><br><span class="line">    ···</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>它的完整形式如下，与上面的写法是等价的。（详细请见上一章的属性的简洁表示法）</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">myGeneratorMethod</span>: <span class="keyword">function</span>* () &#123;</span><br><span class="line">    <span class="comment">// ···</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h3 id="18-11-含义"><a href="#18-11-含义" class="headerlink" title="18.11 含义"></a>18.11 含义</h3><p><strong>（1）Generator 与状态机</strong></p><p><code>Generator</code> 是实现状态机的最佳结构。比如，下面的<code>clock</code>函数就是一个状态机。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> ticking = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">let</span> clock = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (ticking)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Tick!&#x27;</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Tock!&#x27;</span>);</span><br><span class="line">  ticking = !ticking;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码的<code>clock</code>函数一共有两种状态<code>Tick</code>和<code>Tock</code>，每运行一次，就改变一次状态。这个函数如果用 <code>Generator</code> 实现，就是下面这样。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> clock = <span class="keyword">function</span>* () &#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Tick!&#x27;</span>);</span><br><span class="line">    <span class="keyword">yield</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Tock!&#x27;</span>);</span><br><span class="line">    <span class="keyword">yield</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面的 <code>Generator</code> 实现与 <code>ES5</code> 实现对比，可以看到少了用来保存状态的外部变量<code>ticking</code>，这样就更简洁，更安全，在写法上也更优雅。</p><p><strong>（2）Generator 与协程</strong></p><p>协程 <code>coroutine</code> 是一种程序运行的方式，可以理解成“协作的线程”或“协作的函数”。协程既可以用单线程实现，也可以用多线程实现。</p><ul><li><p><strong>协程与子例程的差异</strong><br>  传统的“子例程” <code>subroutine</code> 采用堆栈式“后进先出”的执行方式，只有当调用的子函数完全执行完毕，才会结束执行父函数。<ins>协程与其不同，多个线程（单线程情况下，即多个函数）可以并行执行，但是只有一个线程（或函数）处于正在运行的状态，其他线程（或函数）都处于暂停态 <code>suspended</code>，线程（或函数）之间可以交换执行权</ins>。这种可以并行执行、交换执行权的线程（或函数），就称为协程。</p></li><li><p><strong>协程与普通线程的差异</strong><br>  协程适合用于多任务运行的环境。在这个意义上，它与普通的线程很相似，都有自己的执行上下文、可以分享全局变量。它们的不同之处在于，<ins>同一时间可以有多个线程处于运行状态，但是运行的协程只能有一个，其他协程都处于暂停状态</ins>。此外，<ins>普通的线程是抢先式的，到底哪个线程优先得到资源，必须由运行环境决定，但是协程是合作式的，执行权由协程自己分配</ins>。</p></li></ul><p><code>Generator</code> 函数是 <code>ES6</code> 对协程的实现，<ins>但属于不完全实现</ins>。<code>Generator</code> 函数被称为“半协程”，意思是只有 <code>Generator</code> 函数的调用者，才能将程序的执行权还给 <code>Generator</code> 函数。如果是完全实现的协程，任何函数都可以让暂停的协程继续执行。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">A</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;我是A&quot;</span>);</span><br><span class="line">  <span class="keyword">yield</span> <span class="title function_">B</span>(); <span class="comment">// A停住，在这里转交线程执行权给B</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;结束了&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">B</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;我是B&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">100</span>;<span class="comment">// 返回，并且将线程执行权还给A</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> gen = <span class="title function_">A</span>();</span><br><span class="line">gen.<span class="title function_">next</span>();</span><br><span class="line">gen.<span class="title function_">next</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我是A</span></span><br><span class="line"><span class="comment">// 我是B</span></span><br><span class="line"><span class="comment">// 结束了</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>A</code>将执行权交给<code>B</code>，我们称<code>A</code>是<code>B</code>的父协程。那么现在<code>B</code>执行，<code>A</code>就相当于处于暂停的状态。等到<code>B</code>最后<code>return 100</code>，执行权就会还给<code>A</code>。</p><p><strong>（3）Generator 与上下文</strong></p><p>执行 <code>JS</code> 代码时，会产生一个全局的上下文环境，包含了当前所有的变量和对象。执行函数或块级代码时，又会<mark class="hl-label red">在当前上下文环境的上层</mark> ，产生一个 <mark class="hl-label blue">函数运行的上下文</mark> ，作为 <mark class="hl-label green">当前active的上下文</mark> ，由此形成一个上下文环境的堆栈。</p><p>这个堆栈是“后进先出”的数据结构，最后产生的上下文环境首先执行完成，退出堆栈，然后再执行完成它下层的上下文，直至所有代码执行完成，堆栈清空。</p><p><code>Generator</code> 函数不一样，它执行产生的上下文环境，一旦<ins>遇到<code>yield</code>命令，就会暂时退出堆栈，但是并不消失，里面的所有变量和对象会冻结在当前状态</ins>。等到对它执行<code>next</code>命令时，这个上下文环境又会重新加入调用栈，冻结的变量和对象恢复执行。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">gen</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> g = <span class="title function_">gen</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(</span><br><span class="line">  g.<span class="title function_">next</span>().<span class="property">value</span>,</span><br><span class="line">  g.<span class="title function_">next</span>().<span class="property">value</span>,</span><br><span class="line">); <span class="comment">// 1, 2</span></span><br></pre></td></tr></table></figure><p>上面代码中，第一次执行<code>g.next()</code>时，<code>Generator</code> 函数<code>gen</code>的上下文会加入堆栈，即开始运行<code>gen</code>内部的代码。等遇到<code>yield 1</code>时，<code>gen</code>上下文退出堆栈，内部状态冻结。第二次执行<code>g.next()</code>时，<code>gen</code>上下文重新加入堆栈，变成当前的上下文，重新恢复执行。</p><hr><h3 id="18-12-应用"><a href="#18-12-应用" class="headerlink" title="18.12 应用"></a>18.12 应用</h3><p><strong>（1）异步操作的同步化表达</strong></p><p><code>Generator</code> 函数的暂停执行的效果，意味着<ins>可以把异步操作写在<code>yield</code>表达式里面</ins>，等到调用<code>next</code>方法时再往后执行。所以，<code>Generator</code> 函数的一个重要实际意义就是用来处理异步操作，改写回调函数。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">loadUI</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title function_">showLoadingScreen</span>();</span><br><span class="line">  <span class="keyword">yield</span> <span class="title function_">loadUIDataAsynchronously</span>();</span><br><span class="line">  <span class="title function_">hideLoadingScreen</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> loader = <span class="title function_">loadUI</span>();</span><br><span class="line"><span class="comment">// 加载UI</span></span><br><span class="line">loader.<span class="title function_">next</span>()</span><br><span class="line"><span class="comment">// 卸载UI</span></span><br><span class="line">loader.<span class="title function_">next</span>()</span><br></pre></td></tr></table></figure><p>上面代码中，第一次调用<code>loadUI</code>函数时，该函数不会执行，仅返回一个遍历器。下一次对该遍历器调用<code>next</code>方法，则会显示<code>Loading</code>界面，并且异步加载数据。等到数据加载完成，再一次使用<code>next</code>方法，则会隐藏<code>Loading</code>界面。</p><p><strong>（2）控制流管理</strong></p><p>如果有一个多步操作，采用回调函数，可能会写成下面这样。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">step1</span>(<span class="keyword">function</span> (<span class="params">value1</span>) &#123;</span><br><span class="line">  <span class="title function_">step2</span>(value1, <span class="keyword">function</span>(<span class="params">value2</span>) &#123;</span><br><span class="line">    <span class="title function_">step3</span>(value2, <span class="keyword">function</span>(<span class="params">value3</span>) &#123;</span><br><span class="line">      <span class="title function_">step4</span>(value3, <span class="keyword">function</span>(<span class="params">value4</span>) &#123;</span><br><span class="line">        <span class="comment">// Do something with value4</span></span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>采用 <code>Promise</code> 改写上面的代码。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>(step1)</span><br><span class="line">  .<span class="title function_">then</span>(step2)</span><br><span class="line">  .<span class="title function_">then</span>(step3)</span><br><span class="line">  .<span class="title function_">then</span>(step4)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">value4</span>) &#123;</span><br><span class="line">    <span class="comment">// Do something with value4</span></span><br><span class="line">  &#125;, <span class="keyword">function</span> (<span class="params">error</span>) &#123;</span><br><span class="line">    <span class="comment">// Handle any error from step1 through step4</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">done</span>();</span><br></pre></td></tr></table></figure><p>上面代码已经把回调函数，改成了直线执行的形式，但是加入了大量 <code>Promise</code> 的语法。<code>Generator</code> 函数可以进一步改善代码运行流程。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">longRunningTask</span>(<span class="params">value1</span>) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> value2 = <span class="keyword">yield</span> <span class="title function_">step1</span>(value1);</span><br><span class="line">    <span class="keyword">let</span> value3 = <span class="keyword">yield</span> <span class="title function_">step2</span>(value2);</span><br><span class="line">    <span class="keyword">let</span> value4 = <span class="keyword">yield</span> <span class="title function_">step3</span>(value3);</span><br><span class="line">    <span class="keyword">let</span> value5 = <span class="keyword">yield</span> <span class="title function_">step4</span>(value4);</span><br><span class="line">    <span class="comment">// Do something with value4</span></span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="comment">// Handle any error from step1 through step4</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，<ins>使用一个函数，按次序自动执行所有步骤</ins>。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">scheduler</span>(<span class="title function_">longRunningTask</span>(initialValue));</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">scheduler</span>(<span class="params">task</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> taskObj = task.<span class="title function_">next</span>(task.<span class="property">value</span>);</span><br><span class="line">  <span class="comment">// 如果Generator函数未结束，就继续调用</span></span><br><span class="line">  <span class="keyword">if</span> (!taskObj.<span class="property">done</span>) &#123;</span><br><span class="line">    task.<span class="property">value</span> = taskObj.<span class="property">value</span></span><br><span class="line">    <span class="title function_">scheduler</span>(task);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，上面这种做法，只适合同步操作，即所有的<code>task</code>都必须是同步的，不能有异步操作。因为这里的代码一得到返回值，就继续往下执行，没有判断异步操作何时完成。</p><p><strong>（3）控制流管理 II</strong></p><p>利用<code>for...of</code>循环会自动依次执行<code>yield</code>命令的特性，能提供一种更一般的控制流管理的方法。</p><p>首先，用数组<code>steps</code>封装了一个任务的多个步骤，并依次为这些步骤加上<code>yield</code>命令。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> steps = [step1Func, step2Func, step3Func];</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span>* <span class="title function_">iterateSteps</span>(<span class="params">steps</span>)&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; steps.<span class="property">length</span>; i++)&#123;</span><br><span class="line">    <span class="keyword">let</span> step = steps[i];</span><br><span class="line">    <span class="keyword">yield</span> <span class="title function_">step</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，将任务分解成步骤之后，还可以再将项目分解成多个依次执行的任务<code>jobs</code>。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> jobs = [job1, job2, job3];</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span>* <span class="title function_">iterateJobs</span>(<span class="params">jobs</span>)&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; jobs.<span class="property">length</span>; i++)&#123;</span><br><span class="line">    <span class="keyword">let</span> job = jobs[i];</span><br><span class="line">    <span class="keyword">yield</span>* <span class="title function_">iterateSteps</span>(job.<span class="property">steps</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，就可以用<code>for...of</code>循环一次性依次执行所有任务的所有步骤。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> step <span class="keyword">of</span> <span class="title function_">iterateJobs</span>(jobs))&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(step.<span class="property">id</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再次提醒，上面的做法只能用于所有步骤都是同步操作的情况，不能有异步操作的步骤。</p><hr><h2 id="19-Generator-函数异步应用"><a href="#19-Generator-函数异步应用" class="headerlink" title="19. Generator 函数异步应用"></a>19. Generator 函数异步应用</h2><h3 id="19-1-基本概念"><a href="#19-1-基本概念" class="headerlink" title="19.1 基本概念"></a>19.1 基本概念</h3><p><strong>（1）异步</strong> </p><p>所谓”异步”，可以理解成一个任务被人为分成两段，先执行第一段，然后转而执行其他任务，等做好了准备，再回过头执行第二段</ins>。</p><ul><li>比如，有一个任务是读取文件进行处理，任务的第一段向操作系统发出请求，要求读取文件。然后，程序执行其他任务，等到操作系统返回文件，再接着执行任务的第二段处理文件。</li></ul><p>相应地，连续的执行就叫做同步。由于是连续执行，不能插入其他任务，所以操作系统从硬盘读取文件的这段时间，程序只能干等着。</p><p><strong>（2）回调函数</strong> </p><p><code>JS</code> 语言对异步编程的实现，就是回调函数。所谓<ins>回调函数，就是把任务的第二段单独写在一个函数里面，等到重新执行这个任务的时候，就直接调用这个函数</ins>。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">fs.<span class="title function_">readFile</span>(<span class="string">&#x27;/etc/passwd&#x27;</span>, <span class="string">&#x27;utf-8&#x27;</span>, <span class="keyword">function</span> (<span class="params">err, data</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，<code>readFile</code>函数的第三个参数，就是回调函数，也就是任务的第二段。等到操作系统返回了<code>/etc/passwd</code>这个文件以后，回调函数才会执行。</p><p><strong>（3）Promise</strong> </p><p>回调函数的问题出现在多个回调函数嵌套。假定读取<code>A</code>文件之后，再读取<code>B</code>文件。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">fs.<span class="title function_">readFile</span>(fileA, <span class="string">&#x27;utf-8&#x27;</span>, <span class="keyword">function</span> (<span class="params">err, data</span>) &#123;</span><br><span class="line">  fs.<span class="title function_">readFile</span>(fileB, <span class="string">&#x27;utf-8&#x27;</span>, <span class="keyword">function</span> (<span class="params">err, data</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>不难想象，如果依次读取两个以上的文件，就会出现多重嵌套。因为多个异步操作形成了强耦合，只要有一个操作需要修改，它的上层回调函数和下层回调函数，可能都要跟着修改。</p><p><code>Promise</code> 对象就是为了解决这个问题而提出的。它不是新的语法功能，而是一种新的写法，<ins>允许将回调函数的嵌套，改成链式调用</ins>。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> readFile = <span class="built_in">require</span>(<span class="string">&#x27;fs-readfile-promise&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_">readFile</span>(fileA)</span><br><span class="line">.<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">data</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(data.<span class="title function_">toString</span>());</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">readFile</span>(fileB);</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">data</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(data.<span class="title function_">toString</span>());</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">catch</span>(<span class="keyword">function</span> (<span class="params">err</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中的<code>fs-readfile-promise</code>模块，返回一个 <code>Promise</code> 版本的<code>readFile</code>函数，并通过<code>then</code>方法加载回调函数，<code>catch</code>方法捕捉执行过程中抛出的错误。</p><p><code>Promise</code> 的写法只是回调函数的改进，使用<code>then</code>方法以后，异步任务的两段执行看得更清楚了。但是，<code>Promise</code> 的最大问题是代码冗余，原来的任务被 <code>Promise</code> 包装了一下，不管什么操作，一眼看去许多<code>then</code>，原来的语义变得很不清楚。</p><p><strong>（4）Generator 函数</strong> </p><p>“协程” <code>coroutine</code>，是多个线程互相协作，完成异步任务。协程有点像函数，又有点像线程。它的运行流程大致如下：</p><ul><li>第一步，协程<code>A</code>开始执行。</li><li>第二步，<ins>协程<code>A</code>执行到一半，进入暂停，执行权转移到协程<code>B</code></ins>。</li><li>第三步，一段时间后，协程<code>B</code>交还执行权。</li><li>第四步，协程<code>A</code>恢复执行。</li></ul><p>上面流程的协程<code>A</code>，就是异步任务，因为它分成两段或多段执行。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">asyncJob</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// ...其他代码</span></span><br><span class="line">  <span class="keyword">let</span> f = <span class="keyword">yield</span> <span class="title function_">readFile</span>(fileA);</span><br><span class="line">  <span class="comment">// ...其他代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码的函数<code>asyncJob</code>是一个协程，它的奥妙就在其中的<code>yield</code>命令，<ins>表示执行到此处，执行权将交给其他协程。也就是说，<code>yield</code>命令是异步两个阶段的分界线</ins>。</p><p><code>Generator</code> 函数是协程在 <code>ES6</code> 的实现，最大特点就是可以交出函数的执行权（即暂停执行）。它是一个封装的异步任务，或者说是异步任务的容器。异步操作需要暂停的地方，都用<code>yield</code>语句注明。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">gen</span>(<span class="params">x</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> y = <span class="keyword">yield</span> x + <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> g = <span class="title function_">gen</span>(<span class="number">1</span>);</span><br><span class="line">g.<span class="title function_">next</span>() <span class="comment">// &#123; value: 3, done: false &#125;</span></span><br><span class="line">g.<span class="title function_">next</span>() <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure><p>上面代码中，调用 <code>Generator</code> 函数，会返回一个内部指针（即遍历器）<code>g</code>。这是 <code>Generator</code> 函数不同于普通函数的另一个地方，即执行它不会返回结果，返回的是指针对象。调用指针<code>g</code>的<code>next</code>方法，会移动内部指针（即执行异步任务的第一段），指向第一个遇到的<code>yield</code>语句，上例是执行到<code>x + 2</code>为止。</p><p>换言之，<code>next</code>方法的作用是分阶段执行<code>Generator</code>函数。每次调用<code>next</code>方法，会返回一个对象，表示当前阶段的信息（<code>value</code>属性和<code>done</code>属性）。<code>value</code>属性是<code>yield</code>语句后面表达式的值，表示当前阶段的值；<code>done</code>属性是一个布尔值，表示 <code>Generator</code> 函数是否执行完毕，即是否还有下一个阶段。</p><hr><h3 id="19-2-数据交换和错误处理"><a href="#19-2-数据交换和错误处理" class="headerlink" title="19.2 数据交换和错误处理"></a>19.2 数据交换和错误处理</h3><p><code>Generator</code> 函数可以暂停和恢复执行，这是它能封装异步任务的根本原因。除此之外，它还有两个特性，使它可以作为异步编程的完整解决方案：<ins>函数体内外的数据交换和错误处理机制</ins>。</p><p><code>next</code>返回值的 <code>value</code> 属性，是 <code>Generator</code> 函数向外输出数据。<code>next</code>方法还可以接受参数，向 <code>Generator</code> 函数体内输入数据。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">gen</span>(<span class="params">x</span>)&#123;</span><br><span class="line">  <span class="keyword">let</span> y = <span class="keyword">yield</span> x + <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> g = <span class="title function_">gen</span>(<span class="number">1</span>);</span><br><span class="line">g.<span class="title function_">next</span>() <span class="comment">// &#123; value: 3, done: false &#125;</span></span><br><span class="line">g.<span class="title function_">next</span>(<span class="number">2</span>) <span class="comment">// &#123; value: 2, done: true &#125;</span></span><br></pre></td></tr></table></figure><p>上面代码中，第一个<code>next</code>方法的<code>value</code>属性，返回表达式<code>x + 2</code>的值。第二个<code>next</code>方法带有参数，这个参数被传入 <code>Generator</code> 函数，作为上个阶段异步任务的返回结果，也就是<code>y</code>的值。因此，这一步的<code>value</code>属性，返回的就是<code>2</code>。</p><p><code>Generator</code> 函数内部还可以部署错误处理代码，捕获函数体外抛出的错误。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">gen</span>(<span class="params">x</span>)&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> y = <span class="keyword">yield</span> x + <span class="number">2</span>;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(e);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> g = <span class="title function_">gen</span>(<span class="number">1</span>);</span><br><span class="line">g.<span class="title function_">next</span>();</span><br><span class="line">g.<span class="keyword">throw</span>(<span class="string">&#x27;出错了&#x27;</span>);</span><br><span class="line"><span class="comment">// 出错了</span></span><br></pre></td></tr></table></figure><p>上面代码的最后一行，<code>Generator</code> 函数体外，<ins>使用指针对象的<code>throw</code>方法抛出的错误，可以被函数体内的<code>try...catch</code>代码块捕获</ins>。这意味着，<ins>出错的代码与处理错误的代码，实现了时间和空间上的分离，这对于异步编程无疑是很重要的</ins>。</p><hr><h3 id="19-3-异步任务的封装"><a href="#19-3-异步任务的封装" class="headerlink" title="19.3 异步任务的封装"></a>19.3 异步任务的封装</h3><p>使用<code>Generator</code>封装异步操作的核心思路：</p><ul><li>在异步任务执行时，使用<code>yield</code>交出执行权。</li><li>在异步任务结束后，使用<code>next</code>交还执行权。</li></ul><p>下面看看如何使用 <code>Generator</code> 函数，执行一个真实的异步任务。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 首先写一个异步任务,在一秒后返回特定字符串</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">asyncTask</span>(<span class="params">callback</span>)&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="title function_">callback</span>(<span class="string">&#x27;Hello World&#x27;</span>)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 接下来写出期望执行的顺序</span></span><br><span class="line"><span class="keyword">function</span>* <span class="title function_">runTask</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> text = <span class="keyword">yield</span> asyncTask</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(text) <span class="comment">// 我们期望这里正常输出 Hello World</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 按照期望值执行函数</span></span><br><span class="line"><span class="keyword">const</span> gen = <span class="title function_">runTask</span>()<span class="comment">// 此时执行权已经交出</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里 gen.next().value 就是 asyncTask，执行 asyncTask</span></span><br><span class="line"><span class="comment">// 关键点在于 callback 里调用 next 交还执行权</span></span><br><span class="line"><span class="comment">// 由于 next 方法带有参数 text，且是 callback 的返回值，所以有终端输出。</span></span><br><span class="line">gen.<span class="title function_">next</span>().<span class="title function_">value</span>(<span class="keyword">function</span> (<span class="params">text</span>) &#123;</span><br><span class="line">    gen.<span class="title function_">next</span>(text)</span><br><span class="line">&#125;) </span><br></pre></td></tr></table></figure><p>上面代码虽然很粗糙，但是已经反映了使用<code>Generator</code>封装异步任务的核心思想。最直观的受益就是，<code>runTask</code>的内容与同步代码相似，条理清晰，很适合阅读。</p><p>可以看到，虽然 <code>Generator</code> 函数将异步操作表示得很简洁，但是上面代码中第三部分的流程管理却不方便，即何时执行第一阶段、何时执行第二阶段。</p><hr><h3 id="19-4-Thunk-函数"><a href="#19-4-Thunk-函数" class="headerlink" title="19.4 Thunk 函数"></a>19.4 Thunk 函数</h3><p><code>Thunk</code> 函数是自动执行 <code>Generator</code> 函数的一种方法。</p><p><strong>（1）参数的求值策略</strong> </p><p><code>Thunk</code> 函数早在上个世纪 <code>60</code> 年代就诞生了。那时，编程语言刚刚起步，计算机学家还在研究，编译器怎么写比较好。一个争论的焦点是”求值策略”，即函数的参数到底应该何时求值。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">m</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> m * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">f</span>(x + <span class="number">5</span>)；</span><br></pre></td></tr></table></figure><p>上面代码先定义函数<code>f</code>，然后向它传入表达式<code>x + 5</code>。请问，这个表达式应该何时求值？</p><p>一种意见是<ins>“传值调用”</ins>，即在进入函数体之前，就计算<code>x + 5</code>的值，再将这个值传入函数<code>f</code>。<code>C</code> 语言就采用这种策略。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">f</span>(x + <span class="number">5</span>)</span><br><span class="line"><span class="comment">// 传值调用时，等同于</span></span><br><span class="line"><span class="title function_">f</span>(<span class="number">6</span>)</span><br></pre></td></tr></table></figure><p>另一种意见是<ins>“传名调用”</ins>，即直接将表达式<code>x + 5</code>传入函数体，只在用到它的时候求值。<code>Haskell</code> 语言采用这种策略。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">f</span>(x + <span class="number">5</span>)</span><br><span class="line"><span class="comment">// 传名调用时，等同于</span></span><br><span class="line">(x + <span class="number">5</span>) * <span class="number">2</span></span><br></pre></td></tr></table></figure><p>传值调用和传名调用，哪一种比较好？回答是各有利弊。传值调用比较简单，但是对参数求值的时候，实际上还没用到这个参数，有可能造成性能损失。</p><p><strong>（2）Thunk 函数的含义</strong> </p><p>编译器“传名调用”的实现，往往是将参数放到一个临时函数之中，再将这个临时函数传入函数体。这个临时函数就叫做 <code>Thunk</code> 函数。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">m</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> m * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">f</span>(x + <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> thunk = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> x + <span class="number">5</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">thunk</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">thunk</span>() * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，函数 <code>f</code> 的参数<code>x + 5</code>被一个函数替换了。凡是用到原参数的地方，对<code>Thunk</code>函数求值即可。这就是 <code>Thunk</code> 函数的定义，<ins>它是“传名调用”的一种实现策略，用来替换某个表达式</ins>。</p><p><strong>（3）JS 语言的 Thunk 函数</strong> </p><p><ins><code>JavaScript</code> 是传值调用</ins>，它的 <code>Thunk</code> 函数含义有所不同。在 <code>JavaScript</code> 中，<code>Thunk</code> 函数替换的不是表达式，而是多参数函数，将其替换成一个只接受回调函数作为参数的单参数函数。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 正常版本的 readFile（多参数版本）</span></span><br><span class="line">fs.<span class="title function_">readFile</span>(fileName, callback);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Thunk版本的 readFile（单参数版本）</span></span><br><span class="line"><span class="keyword">let</span> <span class="title class_">Thunk</span> = <span class="keyword">function</span> (<span class="params">fileName</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">callback</span>) &#123; <span class="comment">// 注意</span></span><br><span class="line">    <span class="keyword">return</span> fs.<span class="title function_">readFile</span>(fileName, callback);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> readFileThunk = <span class="title class_">Thunk</span>(fileName);</span><br><span class="line"><span class="title function_">readFileThunk</span>(callback);</span><br></pre></td></tr></table></figure><p>上面代码中，<code>fs</code>模块的<code>readFile</code>方法是一个多参数函数，两个参数分别为文件名和回调函数。经过转换器处理，它变成了一个单参数函数，只接受回调函数作为参数。这个单参数版本，就叫做 <code>Thunk</code> 函数。</p><p>任何函数，只要参数有回调函数，就能写成 <code>Thunk</code> 函数的形式。（<a href="https://zhuanlan.zhihu.com/p/404060484">推荐阅读</a>）</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Thunk</span> = <span class="keyword">function</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">...args</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">callback</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> fn.<span class="title function_">call</span>(<span class="variable language_">this</span>, ...args, callback);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>（4）Thunkify 模块</strong> </p><p><code>Thunkify</code> 模块的使用方式如下。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> thunkify = <span class="built_in">require</span>(<span class="string">&#x27;thunkify&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> read = <span class="title function_">thunkify</span>(fs.<span class="property">readFile</span>);</span><br><span class="line"><span class="title function_">read</span>(<span class="string">&#x27;package.json&#x27;</span>)(<span class="keyword">function</span>(<span class="params">err, str</span>)&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>Thunkify</code> 的源码与上一节那个简单的转换器非常像。（<a href="https://segmentfault.com/a/1190000010414406">源码解读</a>）</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">thunkify</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> args = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="variable language_">arguments</span>.<span class="property">length</span>);</span><br><span class="line">    <span class="keyword">let</span> ctx = <span class="variable language_">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; args.<span class="property">length</span>; ++i) &#123;</span><br><span class="line">      args[i] = <span class="variable language_">arguments</span>[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">done</span>) &#123;</span><br><span class="line">      <span class="keyword">let</span> called;</span><br><span class="line"></span><br><span class="line">      args.<span class="title function_">push</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (called)&#123;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        called = <span class="literal">true</span>;</span><br><span class="line">        done.<span class="title function_">apply</span>(<span class="literal">null</span>, <span class="variable language_">arguments</span>);</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        fn.<span class="title function_">apply</span>(ctx, args);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">        <span class="title function_">done</span>(err);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>它的源码主要多了一个检查机制，变量<code>called</code>确保回调函数只运行一次。这样的设计与下面的 <code>Generator</code> 函数相关。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">a, b, callback</span>)&#123;</span><br><span class="line">  <span class="keyword">let</span> sum = a + b;</span><br><span class="line">  <span class="title function_">callback</span>(sum);</span><br><span class="line">  <span class="title function_">callback</span>(sum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> ft = <span class="title function_">thunkify</span>(f);</span><br><span class="line"><span class="keyword">let</span> print = <span class="variable language_">console</span>.<span class="property">log</span>.<span class="title function_">bind</span>(<span class="variable language_">console</span>);</span><br><span class="line"><span class="title function_">ft</span>(<span class="number">1</span>, <span class="number">2</span>)(print);</span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>上面代码中，由于<code>thunkify</code>只允许回调函数执行一次，所以只输出一行结果。</p><p><strong>（5）Generator 函数的流程管理</strong> </p><p><code>Thunk</code> 函数可以用于 <code>Generator</code> 函数的自动流程管理。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">gen</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> g = <span class="title function_">gen</span>();</span><br><span class="line"><span class="keyword">let</span> res = g.<span class="title function_">next</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(!res.<span class="property">done</span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res.<span class="property">value</span>);</span><br><span class="line">  res = g.<span class="title function_">next</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>Generator</code> 函数<code>gen</code>会自动执行完所有步骤。</p><p>但是，这不适合异步操作。<ins>如果必须保证前一步执行完，才能执行后一步，上面的自动执行就不可行</ins>。这时，<code>Thunk</code> 函数就能派上用处。</p><p>以读取文件为例。下面的 <code>Generator</code> 函数封装了两个异步操作。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> thunkify = <span class="built_in">require</span>(<span class="string">&#x27;thunkify&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> readFileThunk = <span class="title function_">thunkify</span>(fs.<span class="property">readFile</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> gen = <span class="keyword">function</span>* ()&#123;</span><br><span class="line">  <span class="keyword">let</span> r1 = <span class="keyword">yield</span> <span class="title function_">readFileThunk</span>(<span class="string">&#x27;/etc/fstab&#x27;</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(r1.<span class="title function_">toString</span>());</span><br><span class="line">  <span class="keyword">let</span> r2 = <span class="keyword">yield</span> <span class="title function_">readFileThunk</span>(<span class="string">&#x27;/etc/shells&#x27;</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(r2.<span class="title function_">toString</span>());</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面代码中，<ins><code>yield</code>命令用于将程序的执行权移出 <code>Generator</code> 函数，那么就需要一种方法，将执行权再交还给 <code>Generator</code> 函数</ins>。</p><p>这种方法就是 <code>Thunk</code> 函数，<ins>因为它可以在回调函数里，将执行权交还给 <code>Generator</code> 函数</ins>。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> g = <span class="title function_">gen</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> r1 = g.<span class="title function_">next</span>();</span><br><span class="line">r1.<span class="title function_">value</span>(<span class="keyword">function</span> (<span class="params">err, data</span>) &#123; <span class="comment">// r1.value 就是 readFileThunk 方法</span></span><br><span class="line">  <span class="keyword">if</span> (err)&#123;</span><br><span class="line">    <span class="keyword">throw</span> err; <span class="comment">// 错误处理</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> r2 = g.<span class="title function_">next</span>(data); <span class="comment">// 如果 data 从 readFileThunk 方法回调出来</span></span><br><span class="line">                         <span class="comment">// 归还执行权，r1 赋值成功，运行至下一个 yield</span></span><br><span class="line">  r2.<span class="title function_">value</span>(<span class="keyword">function</span> (<span class="params">err, data</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (err)&#123;</span><br><span class="line">      <span class="keyword">throw</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">    g.<span class="title function_">next</span>(data); </span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，变量<code>g</code>是 <code>Generator</code> 函数的内部指针，表示目前执行到哪一步。<code>next</code>方法负责将指针移动到下一步，并返回该步的<code>value</code>属性和<code>done</code>属性。</p><p>仔细看上面的代码，可以发现 <code>Generator</code> 函数的执行过程，其实是<ins>将同一个回调函数，反复传入<code>next</code>方法的<code>value</code>属性</ins>。这使得我们可以用递归来自动完成这个过程。（理论上）</p><p><strong>（6）Thunk 函数的自动流程管理</strong> </p><p><code>Thunk</code> 函数真正的威力，在于可以自动执行 <code>Generator</code> 函数。下面就是一个基于 <code>Thunk</code> 函数的 <code>Generator</code> 执行器。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">run</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> gen = <span class="title function_">fn</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">next</span>(<span class="params">err, data</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> result = gen.<span class="title function_">next</span>(data);</span><br><span class="line">    <span class="keyword">if</span> (result.<span class="property">done</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    result.<span class="title function_">value</span>(next);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">next</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span>* <span class="title function_">g</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">run</span>(g);</span><br></pre></td></tr></table></figure><p>上面代码的<code>run</code>函数，就是一个 <code>Generator</code> 函数的自动执行器。内部的<code>next</code>函数就是 <code>Thunk</code> 的回调函数。<code>next</code>函数先将指针移到 <code>Generator</code> 函数的下一步（<code>gen.next</code>方法），然后判断 <code>Generator</code> 函数是否结束（<code>result.done</code>属性），如果没结束，就将<code>next</code>函数再传入 <code>Thunk</code> 函数（<code>result.value</code>属性），否则就直接退出。</p><p>有了这个执行器，执行 <code>Generator</code> 函数方便多了。不管内部有多少个异步操作，直接把 <code>Generator</code> 函数传入<code>run</code>函数即可。注意，<ins>前提是每一个异步操作，都要是 <code>Thunk</code> 函数，也就是说，跟在<code>yield</code>命令后面的必须是 <code>Thunk</code> 函数</ins>。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> g = <span class="keyword">function</span>* ()&#123;</span><br><span class="line">  <span class="keyword">let</span> f1 = <span class="keyword">yield</span> <span class="title function_">readFileThunk</span>(<span class="string">&#x27;fileA&#x27;</span>);</span><br><span class="line">  <span class="keyword">let</span> f2 = <span class="keyword">yield</span> <span class="title function_">readFileThunk</span>(<span class="string">&#x27;fileB&#x27;</span>);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">let</span> fn = <span class="keyword">yield</span> <span class="title function_">readFileThunk</span>(<span class="string">&#x27;fileN&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">run</span>(g);</span><br></pre></td></tr></table></figure><p>上面代码中，函数<code>g</code>封装了<code>n</code>个异步的读取文件操作，只要执行<code>run</code>函数，这些操作就会自动完成。这样一来，异步操作不仅可以写得像同步操作，而且一行代码就可以执行。</p><p><code>Thunk</code> 函数并不是 <code>Generator</code> 函数自动执行的唯一方案。因为自动执行的关键是，必须有一种机制，自动控制 <code>Generator</code> 函数的流程，接收和交还程序的执行权。回调函数可以做到这一点，<code>Promise</code> 对象也可以做到这一点。</p><hr><h3 id="19-5-co-模块"><a href="#19-5-co-模块" class="headerlink" title="19.5 co 模块"></a>19.5 co 模块</h3><p>下面是一个 <code>Generator</code> 函数，用于依次读取两个文件。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> gen = <span class="keyword">function</span>* () &#123;</span><br><span class="line">  <span class="keyword">let</span> f1 = <span class="keyword">yield</span> <span class="title function_">readFile</span>(<span class="string">&#x27;/etc/fstab&#x27;</span>);</span><br><span class="line">  <span class="keyword">let</span> f2 = <span class="keyword">yield</span> <span class="title function_">readFile</span>(<span class="string">&#x27;/etc/shells&#x27;</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(f1.<span class="title function_">toString</span>());</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(f2.<span class="title function_">toString</span>());</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/tj/co">co 模块</a>可以用于 <code>Generator</code> 函数的自动执行，不用再编写 <code>Generator</code> 函数的执行器。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> co = <span class="built_in">require</span>(<span class="string">&#x27;co&#x27;</span>);</span><br><span class="line"><span class="title function_">co</span>(gen);</span><br></pre></td></tr></table></figure><p>上面代码中，<code>Generator</code> 函数只要传入<code>co</code>函数，就会自动执行。</p><p><code>co</code>函数返回一个<code>Promise</code>对象，因此可以用<code>then</code>方法添加回调函数。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">co</span>(gen).<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params"></span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Generator 函数执行完成&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，等到 <code>Generator</code> 函数执行结束，就会输出一行提示。</p><p><strong>（1）co 模块的原理</strong></p><p>为什么 <code>co</code> 可以自动执行 <code>Generator</code> 函数？</p><p>前面说过，<ins><code>Generator</code> 就是一个异步操作的容器。它的自动执行需要一种机制，当异步操作有了结果，能够自动交回执行权</ins>。</p><p>两种方法可以做到这一点：</p><ul><li>回调函数。将异步操作包装成 <code>Thunk</code> 函数，在回调函数里面交回执行权。</li><li><code>Promise</code> 对象。将异步操作包装成 <code>Promise</code> 对象，用<code>then</code>方法交回执行权。</li></ul><p><code>co</code> 模块其实就是将两种自动执行器（<code>Thunk</code> 函数和 <code>Promise</code> 对象），包装成一个模块。</p><ul><li>使用 <code>co</code> 的前提条件是，<code>Generator</code> 函数的<code>yield</code>命令后面，只能是 <code>Thunk</code> 函数或 <code>Promise</code> 对象。如果数组或对象的成员，全部都是 <code>Promise</code> 对象，也可以使用 <code>co</code>。</li></ul><p><strong>（2）基于 Promise 对象的自动执行</strong></p><p>沿用上面的例子。首先，把<code>fs</code>模块的<code>readFile</code>方法包装成一个 <code>Promise</code> 对象。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> readFile = <span class="keyword">function</span> (<span class="params">fileName</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>)&#123; <span class="comment">// Promise 新建后立即执行</span></span><br><span class="line">    fs.<span class="title function_">readFile</span>(fileName, <span class="keyword">function</span>(<span class="params">error, data</span>)&#123;</span><br><span class="line">      <span class="keyword">if</span> (error)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">reject</span>(error);</span><br><span class="line">      &#125; </span><br><span class="line">      <span class="title function_">resolve</span>(data); <span class="comment">// 读取成功，传 data 进 then 方法</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> gen = <span class="keyword">function</span>* ()&#123;</span><br><span class="line">  <span class="keyword">let</span> f1 = <span class="keyword">yield</span> <span class="title function_">readFile</span>(<span class="string">&#x27;/etc/fstab&#x27;</span>);</span><br><span class="line">  <span class="keyword">let</span> f2 = <span class="keyword">yield</span> <span class="title function_">readFile</span>(<span class="string">&#x27;/etc/shells&#x27;</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(f1.<span class="title function_">toString</span>());</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(f2.<span class="title function_">toString</span>());</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后，手动执行上面的 <code>Generator</code> 函数。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> g = <span class="title function_">gen</span>();</span><br><span class="line"><span class="comment">// 注意，此时 gen.next().value 是 readFile 返回的 Promise 对象</span></span><br><span class="line"><span class="comment">// resolve 返回的 data 进入回调函数</span></span><br><span class="line">g.<span class="title function_">next</span>().<span class="property">value</span>.<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">data</span>)&#123; </span><br><span class="line">  g.<span class="title function_">next</span>(data).<span class="property">value</span>.<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">data</span>)&#123;</span><br><span class="line">    g.<span class="title function_">next</span>(data);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>手动执行就是用<code>then</code>方法，层层添加回调函数。理解了这一点，就可以写出一个自动执行器。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">run</span>(<span class="params">gen</span>)&#123;</span><br><span class="line">  <span class="keyword">let</span> g = <span class="title function_">gen</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">next</span>(<span class="params">data</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> result = g.<span class="title function_">next</span>(data);</span><br><span class="line">    <span class="keyword">if</span> (result.<span class="property">done</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> result.<span class="property">value</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    result.<span class="property">value</span>.<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">data</span>)&#123;</span><br><span class="line">      <span class="title function_">next</span>(data);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">next</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">run</span>(gen);</span><br></pre></td></tr></table></figure><p>上面代码中，只要 <code>Generator</code> 函数还没执行到最后一步，<code>next</code>函数就调用自身，实现自动执行。</p><p><strong>（3）co 模块的源码</strong></p><p>首先，<code>co</code> 函数接受 <code>Generator</code> 函数作为参数，返回一个 <code>Promise</code> 对象。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">co</span>(<span class="params">gen</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> ctx = <span class="variable language_">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在返回的 <code>Promise</code> 对象里面，<code>co</code> 先检查参数<code>gen</code>是否为 <code>Generator</code> 函数。如果是，就执行该函数，得到一个内部指针对象；如果不是就返回，并将 <code>Promise</code> 对象的状态改为<code>resolved</code>。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">co</span>(<span class="params">gen</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> ctx = <span class="variable language_">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> gen === <span class="string">&#x27;function&#x27;</span>)&#123;</span><br><span class="line">      gen = gen.<span class="title function_">call</span>(ctx);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!gen || <span class="keyword">typeof</span> gen.<span class="property">next</span> !== <span class="string">&#x27;function&#x27;</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">resolve</span>(gen);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着，<code>co</code> 将 <code>Generator</code> 函数的内部指针对象的<code>next</code>方法，包装成<code>onFulfilled</code>函数。这主要是为了能够捕捉抛出的错误。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">co</span>(<span class="params">gen</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> ctx = <span class="variable language_">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> gen === <span class="string">&#x27;function&#x27;</span>)&#123;</span><br><span class="line">      gen = gen.<span class="title function_">call</span>(ctx);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!gen || <span class="keyword">typeof</span> gen.<span class="property">next</span> !== <span class="string">&#x27;function&#x27;</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">resolve</span>(gen);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">onFulfilled</span>();</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">onFulfilled</span>(<span class="params">res</span>) &#123;</span><br><span class="line">      <span class="keyword">let</span> ret;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        ret = gen.<span class="title function_">next</span>(res);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">reject</span>(e);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="title function_">next</span>(ret);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，就是关键的<code>next</code>函数，它会反复调用自身。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">next</span>(<span class="params">ret</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (ret.<span class="property">done</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">resolve</span>(ret.<span class="property">value</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> value = toPromise.<span class="title function_">call</span>(ctx, ret.<span class="property">value</span>);</span><br><span class="line">  <span class="keyword">if</span> (value &amp;&amp; <span class="title function_">isPromise</span>(value))&#123;</span><br><span class="line">    <span class="keyword">return</span> value.<span class="title function_">then</span>(onFulfilled, onRejected);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">onRejected</span>(</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">TypeError</span>(</span><br><span class="line">      <span class="string">&#x27;You may only yield a function, promise, generator, array, or object, &#x27;</span></span><br><span class="line">      + <span class="string">&#x27;but the following object was passed: &quot;&#x27;</span></span><br><span class="line">      + <span class="title class_">String</span>(ret.<span class="property">value</span>)</span><br><span class="line">      + <span class="string">&#x27;&quot;&#x27;</span></span><br><span class="line">    )</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>next</code>函数的内部代码，一共只有四行命令。</p><ul><li>检查当前是否为 <code>Generator</code> 函数的最后一步，如果是就返回。</li><li>确保每一步的返回值，是 <code>Promise</code> 对象。</li><li><code>then</code>方法为返回值加上回调函数，然后通过<code>onFulfilled</code>函数再次调用<code>next</code>函数。</li><li>在参数不符合要求的情况下（参数非 <code>Thunk</code> 函数和 <code>Promise</code> 对象），将 <code>Promise</code> 对象的状态改为<code>rejected</code>，从而终止执行。</li></ul><p><strong>（4）处理并发的异步操作</strong></p><p><code>co</code> 支持并发的异步操作，即允许某些操作同时进行，等到它们全部完成，才进行下一步。这时，要把并发的操作都放在数组或对象里面，跟在<code>yield</code>语句后面。（<a href="https://es6.ruanyifeng.com/#docs/generator-async#%E5%AE%9E%E4%BE%8B%EF%BC%9A%E5%A4%84%E7%90%86-Stream">例子</a>）</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数组的写法</span></span><br><span class="line"><span class="title function_">co</span>(<span class="keyword">function</span>* () &#123;</span><br><span class="line">  <span class="keyword">let</span> res = <span class="keyword">yield</span> [</span><br><span class="line">    <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">1</span>),</span><br><span class="line">    <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">2</span>)</span><br><span class="line">  ];</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br><span class="line">&#125;).<span class="title function_">catch</span>(onerror);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象的写法</span></span><br><span class="line"><span class="title function_">co</span>(<span class="keyword">function</span>* () &#123;</span><br><span class="line">  <span class="keyword">let</span> res = <span class="keyword">yield</span> &#123;</span><br><span class="line">    <span class="number">1</span>: <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">1</span>),</span><br><span class="line">    <span class="number">2</span>: <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">2</span>),</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br><span class="line">&#125;).<span class="title function_">catch</span>(onerror);</span><br></pre></td></tr></table></figure><hr><h3 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h3><blockquote><p>该学习笔记的所有章节均保存在<a href="https://github.com/Hongda-OSU/ES6-Journey">Github</a>中，如有需要，可下载并在<a href="https://typora.io/">Typora</a>中阅读。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> ES6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ES6学习笔记 • 上</title>
      <link href="/posts/fbe58254.html"/>
      <url>/posts/fbe58254.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>本读书笔记节选自阮一峰编写的 <a href="https://es6.ruanyifeng.com/">《ECMAScript 6 入门教程》</a>。适合已经掌握 <code>ES5</code> 的读者，用来了解这门语言的最新发展。笔记内容仅包括日常开发中可能会用到的概念，剩余部分请自行阅读。</p></blockquote><hr><h2 id="1-let-和-const-命令"><a href="#1-let-和-const-命令" class="headerlink" title="1. let 和 const 命令"></a>1. let 和 const 命令</h2><h3 id="1-1-let-命令"><a href="#1-1-let-命令" class="headerlink" title="1.1 let 命令"></a>1.1 let 命令</h3><p><code>let</code>的用法类似于<code>var</code>，但所声明的变量只在<code>let</code>命令所在的代码块（即 <code>&#123;&#125;</code> 包裹起来的内容）内有效。而<code>var</code>所声明的变量在全局范围内都有效。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">var</span> b = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">a <span class="comment">// ReferenceError: a is not defined.</span></span><br><span class="line">b <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p><strong>（1）不存在变量提升</strong></p><p><code>var</code>命令会发生<ins>“变量提升”现象，即变量可以在声明之前使用，值为<code>undefined</code></ins>。为了纠正这种现象，<code>let</code>命令改变了语法行为，它所声明的变量一定要在声明后使用。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// var 的情况</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(foo); <span class="comment">// 输出 undefined</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// let 的情况</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(bar); <span class="comment">// 报错 ReferenceError</span></span><br><span class="line"><span class="keyword">let</span> bar = <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p><strong>（2）暂时性死区</strong></p><p>只要<a href="https://blog.poetries.top/browser-working-principle/guide/part2/lesson09.html#%E4%BD%9C%E7%94%A8%E5%9F%9F-scope">块级作用域</a>内存在<code>let</code>和<code>const</code>命令，它所声明的变量就“绑定”（<code>binding</code>）这个区域，不再受外部的影响。凡是在声明之前就使用这些变量，就会报错。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> tmp = <span class="number">123</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="comment">// TDZ 开始</span></span><br><span class="line">  tmp = <span class="string">&#x27;abc&#x27;</span>; <span class="comment">// ReferenceError</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(tmp); <span class="comment">// ReferenceError</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> tmp; <span class="comment">// TDZ 结束</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(tmp); <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line">  tmp = <span class="number">123</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(tmp); <span class="comment">// 123</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="1-2-块级作用域"><a href="#1-2-块级作用域" class="headerlink" title="1.2 块级作用域"></a>1.2 块级作用域</h3><p><code>ES5</code> 只有全局作用域和函数作用域，没有块级作用域，这带来很多不合理的情况：</p><p><strong>（1）内层变量覆盖外层变量</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> tmp = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(tmp);</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> tmp = <span class="string">&#x27;hello world&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">f</span>(); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>上面代码的原意是，<code>if</code>代码块的外部使用外层的<code>tmp</code>变量，内部使用内层的<code>tmp</code>变量。但是函数<code>f</code>执行后，输出结果却为<code>undefined</code>。</p><p><ins>原因其实就是变量提升，导致内层的<code>tmp</code>变量覆盖了外层的<code>tmp</code>变量</ins>。实际中的代码如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> tmp = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> tmp; <span class="comment">// 声明但未赋值 undefined</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(tmp); <span class="comment">// 输出 undefined</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">    tmp = <span class="string">&#x27;hello world&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">f</span>(); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p><strong>（2）用来计数的循环变量泄露为全局变量</strong></p><p>下面代码中，变量<code>i</code>只用来控制循环，但是循环结束后，它并没有消失，泄露成了全局变量。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; s.<span class="property">length</span>; i++) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(s[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(i); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure><p>为了应对上面这些情况，<code>ES6</code> 新增了块级作用域，<ins>外层作用域无法获取到内层作用域</ins>。<ins>即使外层和内层都使用相同变量名，也都互不干扰</ins>。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f1</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> n = <span class="number">5</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> n = <span class="number">10</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(n); <span class="comment">// 5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的函数有两个代码块，都声明了变量<code>n</code>，运行后输出 <code>5</code>。这表示外层代码块不受内层代码块的影响。如果两次都使用<code>var</code>定义变量<code>n</code>，最后输出的值就是 <code>10</code>。</p><hr><h3 id="1-3-const-命令"><a href="#1-3-const-命令" class="headerlink" title="1.3 const 命令"></a>1.3 const 命令</h3><p><code>const</code>声明一个只读常量。一旦声明，常量的值就不能改变，<ins>且必须立即初始化</ins>。（与 <code>let</code> 一样，<code>const</code> 不存在变量提升，存在暂时性死区）</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">PI</span> = <span class="number">3.1415</span>;</span><br><span class="line"><span class="variable constant_">PI</span> <span class="comment">// 3.1415</span></span><br><span class="line"><span class="variable constant_">PI</span> = <span class="number">3</span>;</span><br><span class="line"><span class="comment">// TypeError: Assignment to constant variable.</span></span><br></pre></td></tr></table></figure><p><code>const</code>保证的，并不是变量的值不得改动，<ins>而是变量指向的那个内存地址所保存的数据不得改动</ins>。</p><ul><li>对于简单类型的数据（比如数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。</li><li>但对于复合类型的数据（比如对象、数组），变量指向的内存地址，保存的只是一个指向实际数据的指针。<code>const</code>只能保证这个指针是固定的，至于它指向的数据结构是不是可变的，就完全不能控制了。</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为 foo 添加一个属性</span></span><br><span class="line">foo.<span class="property">prop</span> = <span class="number">123</span>;</span><br><span class="line">foo.<span class="property">prop</span> <span class="comment">// 123</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 foo 指向另一个对象，报错</span></span><br><span class="line">foo = &#123;&#125;; <span class="comment">// TypeError: &quot;foo&quot; is read-only</span></span><br></pre></td></tr></table></figure><hr><h2 id="2-变量的解构赋值"><a href="#2-变量的解构赋值" class="headerlink" title="2. 变量的解构赋值"></a>2. 变量的解构赋值</h2><h3 id="2-1-数组的解构赋值"><a href="#2-1-数组的解构赋值" class="headerlink" title="2.1 数组的解构赋值"></a>2.1 数组的解构赋值</h3><p>从数组或对象中提取值，按照对应位置, 对变量进行赋值，这被称为解构。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [a, b, c] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br></pre></td></tr></table></figure><p>这种写法属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [foo, [[bar], baz]] = [<span class="number">1</span>, [[<span class="number">2</span>], <span class="number">3</span>]];</span><br><span class="line">foo <span class="comment">// 1</span></span><br><span class="line">bar <span class="comment">// 2</span></span><br><span class="line">baz <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [ , , third] = [<span class="string">&quot;foo&quot;</span>, <span class="string">&quot;bar&quot;</span>, <span class="string">&quot;baz&quot;</span>];</span><br><span class="line">third <span class="comment">// &quot;baz&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [head, ...tail] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">head <span class="comment">// 1</span></span><br><span class="line">tail <span class="comment">// [2, 3, 4]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [x, y, ...z] = [<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">x <span class="comment">// &quot;a&quot;</span></span><br><span class="line">y <span class="comment">// undefined</span></span><br><span class="line">z <span class="comment">// []</span></span><br></pre></td></tr></table></figure><p>数组的解构赋值有两种特殊情况：</p><ul><li>解构不成功，那么对应变量的值就等于<code>undefined</code>。</li><li>不完全解构，等号左边的模式，只会匹配一部分的等号右边的数组。</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [foo] = []; <span class="comment">// foo == undefined</span></span><br><span class="line"><span class="keyword">let</span> [bar, foo] = [<span class="number">1</span>]; <span class="comment">// foo == undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [a, [b], d] = [<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>], <span class="number">4</span>];</span><br><span class="line">a <span class="comment">// 1</span></span><br><span class="line">b <span class="comment">// 2</span></span><br><span class="line">d <span class="comment">// 4</span></span><br></pre></td></tr></table></figure><p>事实上，只要某种数据结构具有 <code>Iterator</code> 接口，都可以采用数组形式的解构赋值。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [x, y, z] = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]); <span class="comment">// Set 原生带有 Iterator 接口</span></span><br><span class="line">x <span class="comment">// &quot;a&quot;</span></span><br></pre></td></tr></table></figure><p>数组的解构赋值可以指定默认值，并且<ins>必须严格等于<code>undefined</code></ins>才会生效。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [foo = <span class="literal">true</span>] = [];</span><br><span class="line">foo <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [x, y = <span class="string">&#x27;b&#x27;</span>] = [<span class="string">&#x27;a&#x27;</span>]; <span class="comment">// x=&#x27;a&#x27;, y=&#x27;b&#x27;</span></span><br><span class="line"><span class="keyword">let</span> [x, y = <span class="string">&#x27;b&#x27;</span>] = [<span class="string">&#x27;a&#x27;</span>, <span class="literal">undefined</span>]; <span class="comment">// x=&#x27;a&#x27;, y=&#x27;b&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [x = <span class="number">1</span>] = [<span class="literal">undefined</span>];</span><br><span class="line">x <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [x = <span class="number">1</span>] = [<span class="literal">null</span>];</span><br><span class="line">x <span class="comment">// null</span></span><br></pre></td></tr></table></figure><hr><h3 id="2-2-对象的解构赋值"><a href="#2-2-对象的解构赋值" class="headerlink" title="2.2 对象的解构赋值"></a>2.2 对象的解构赋值</h3><p>对象的解构与数组有一个重要的不同。<ins>数组的元素是按次序排列的，变量的取值由它的位置决定</ins>。<ins>而对象的属性没有次序，变量必须与属性同名，才能取到正确的值</ins>。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; bar, foo &#125; = &#123; <span class="attr">foo</span>: <span class="string">&#x27;aaa&#x27;</span>, <span class="attr">bar</span>: <span class="string">&#x27;bbb&#x27;</span> &#125;;</span><br><span class="line">foo <span class="comment">// &quot;aaa&quot;</span></span><br><span class="line">bar <span class="comment">// &quot;bbb&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; baz &#125; = &#123; <span class="attr">foo</span>: <span class="string">&#x27;aaa&#x27;</span>, <span class="attr">bar</span>: <span class="string">&#x27;bbb&#x27;</span> &#125;;</span><br><span class="line">baz <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>如果<ins>变量名与属性名不一致</ins>，必须写成下面这样。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">first</span>: <span class="string">&#x27;hello&#x27;</span>, <span class="attr">last</span>: <span class="string">&#x27;world&#x27;</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">first</span>: f, <span class="attr">last</span>: l &#125; = obj;</span><br><span class="line">f <span class="comment">// &#x27;hello&#x27;</span></span><br><span class="line">l <span class="comment">// &#x27;world&#x27;</span></span><br></pre></td></tr></table></figure><p>上面的代码可以看出，对象的解构赋值的机制，是<ins>先找到同名属性，然后再赋给对应的变量</ins>，<mark class="hl-label red">真正被赋值的是后者，而不是前者</mark> 。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; <span class="attr">foo</span>: foo, <span class="attr">bar</span>: bar &#125; = &#123; <span class="attr">foo</span>: <span class="string">&#x27;aaa&#x27;</span>, <span class="attr">bar</span>: <span class="string">&#x27;bbb&#x27;</span> &#125;; </span><br><span class="line"><span class="comment">// let &#123;foo, bar&#125; = &#123; foo: &#x27;aaa&#x27;, bar: &#x27;bbb&#x27; &#125;; </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">foo</span>: baz &#125; = &#123; <span class="attr">foo</span>: <span class="string">&#x27;aaa&#x27;</span>, <span class="attr">bar</span>: <span class="string">&#x27;bbb&#x27;</span> &#125;;</span><br><span class="line">baz <span class="comment">// &quot;aaa&quot;</span></span><br><span class="line">foo <span class="comment">// error: foo is not defined</span></span><br></pre></td></tr></table></figure><p>解构也可以用于嵌套结构的对象。下面代码分别对<code>p</code>，<code>x</code>，<code>y</code>三个属性进行解构赋值。注意，在对<code>x</code>，<code>y</code>属性的解构赋值之中，<code>x</code>，<code>y</code>是变量，<code>p</code>是模式。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="attr">p</span>: [</span><br><span class="line">    <span class="string">&#x27;Hello&#x27;</span>,</span><br><span class="line">    &#123; <span class="attr">y</span>: <span class="string">&#x27;World&#x27;</span> &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; p, <span class="attr">p</span>: [x, &#123; y &#125;] &#125; = obj;</span><br><span class="line">p <span class="comment">// [&quot;Hello&quot;, &#123;y: &quot;World&quot;&#125;]</span></span><br><span class="line">x <span class="comment">// &quot;Hello&quot;</span></span><br><span class="line">y <span class="comment">// &quot;World&quot;</span></span><br></pre></td></tr></table></figure><p>对象的解构也可以指定默认值，并且必须严格等于<code>undefined</code>才会生效。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;x = <span class="number">3</span>&#125; = &#123;&#125;;</span><br><span class="line">x <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123;x, y = <span class="number">5</span>&#125; = &#123;<span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="literal">undefined</span>&#125;;</span><br><span class="line">x <span class="comment">// 1</span></span><br><span class="line">y <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">x</span>: y = <span class="number">3</span>&#125; = &#123;&#125;;</span><br><span class="line">y <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">x</span>: y = <span class="number">3</span>&#125; = &#123;<span class="attr">x</span>: <span class="number">5</span>&#125;;</span><br><span class="line">y <span class="comment">// 5</span></span><br></pre></td></tr></table></figure><hr><h3 id="2-3-函数参数的解构赋值"><a href="#2-3-函数参数的解构赋值" class="headerlink" title="2.3 函数参数的解构赋值"></a>2.3 函数参数的解构赋值</h3><p>函数的参数也可以使用解构赋值。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">move</span>(<span class="params">&#123;x = <span class="number">0</span>, y = <span class="number">0</span>&#125; = &#123;&#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> [x, y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">move</span>(&#123;<span class="attr">x</span>: <span class="number">3</span>, <span class="attr">y</span>: <span class="number">8</span>&#125;); <span class="comment">// [3, 8]</span></span><br><span class="line"><span class="title function_">move</span>(&#123;<span class="attr">x</span>: <span class="number">3</span>&#125;); <span class="comment">// [3, 0]</span></span><br><span class="line"><span class="title function_">move</span>(&#123;&#125;); <span class="comment">// [0, 0]</span></span><br><span class="line"><span class="title function_">move</span>(); <span class="comment">// [0, 0]</span></span><br></pre></td></tr></table></figure><p>上面代码中，函数<code>move</code>的参数是一个对象。通过对这个对象进行解构，得到变量<code>x</code>和<code>y</code>的值。如果解构失败，<code>x</code>和<code>y</code>等于默认值。</p><p>注意，下面的写法会得到与上面不一样的结果。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">move</span>(<span class="params">&#123;x, y&#125; = &#123; x: <span class="number">0</span>, y: <span class="number">0</span> &#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> [x, y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">move</span>(&#123;<span class="attr">x</span>: <span class="number">3</span>, <span class="attr">y</span>: <span class="number">8</span>&#125;); <span class="comment">// [3, 8]</span></span><br><span class="line"><span class="title function_">move</span>(&#123;<span class="attr">x</span>: <span class="number">3</span>&#125;); <span class="comment">// [3, undefined]</span></span><br><span class="line"><span class="title function_">move</span>(&#123;&#125;); <span class="comment">// [undefined, undefined]</span></span><br><span class="line"><span class="title function_">move</span>(); <span class="comment">// [0, 0]</span></span><br></pre></td></tr></table></figure><p>上面代码<ins>为函数<code>move</code>的参数指定默认值，而不是为变量<code>x</code>和<code>y</code>指定默认值</ins>。当参数为<code>undefined</code>时，参数默认值启用。</p><hr><h3 id="2-4-解构赋值的用途"><a href="#2-4-解构赋值的用途" class="headerlink" title="2.4 解构赋值的用途"></a>2.4 解构赋值的用途</h3><p><strong>（1）交换变量的值</strong></p><p>下面代码交换变量<code>x</code>和<code>y</code>的值，这样的写法简洁易读，语义清晰。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> y = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">[x, y] = [y, x]; <span class="comment">// x = 2, y = 1</span></span><br></pre></td></tr></table></figure><p><strong>（2）从函数返回多个值</strong></p><p>函数只能返回一个值，如果要返回多个值，只能将它们放在数组或对象里返回。有了解构赋值，取出这些值就非常方便。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回一个数组</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">example</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> [a, b, c] = <span class="title function_">example</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回一个对象</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">example</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">foo</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">bar</span>: <span class="number">2</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> &#123; foo, bar &#125; = <span class="title function_">example</span>();</span><br></pre></td></tr></table></figure><p><strong>（3）提取 JSON 数据</strong></p><p>解构赋值对提取 <code>JSON</code> 对象中的数据，尤其有用。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> jsonData = &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="number">42</span>,</span><br><span class="line">  <span class="attr">status</span>: <span class="string">&quot;OK&quot;</span>,</span><br><span class="line">  <span class="attr">data</span>: [<span class="number">867</span>, <span class="number">5309</span>]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; id, status, <span class="attr">data</span>: number &#125; = jsonData;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(id, status, number);</span><br><span class="line"><span class="comment">// 42, &quot;OK&quot;, [867, 5309]</span></span><br></pre></td></tr></table></figure><p><strong>（4）函数参数的定义</strong></p><p>解构赋值可以方便地将一组参数与变量名对应起来。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参数是一组有次序的值</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">[x, y, z]</span>) &#123; ... &#125;</span><br><span class="line"><span class="title function_">f</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数是一组无次序的值</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">&#123;x, y, z&#125;</span>) &#123; ... &#125;</span><br><span class="line"><span class="title function_">f</span>(&#123;<span class="attr">z</span>: <span class="number">3</span>, <span class="attr">y</span>: <span class="number">2</span>, <span class="attr">x</span>: <span class="number">1</span>&#125;);</span><br></pre></td></tr></table></figure><p><strong>（5）遍历 Map 结构</strong></p><p>前面提到，任何部署了 <code>Iterator</code> 接口的对象，都可以用<code>for...of</code>循环遍历。<code>Map</code> 结构原生支持 <code>Iterator</code> 接口，配合变量的解构赋值，获取键名和键值就非常方便。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">map.<span class="title function_">set</span>(<span class="string">&#x27;first&#x27;</span>, <span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line">map.<span class="title function_">set</span>(<span class="string">&#x27;second&#x27;</span>, <span class="string">&#x27;world&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> map) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(key + <span class="string">&quot; is &quot;</span> + value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// first is hello</span></span><br><span class="line"><span class="comment">// second is world</span></span><br></pre></td></tr></table></figure><hr><h2 id="3-字符串的扩展"><a href="#3-字符串的扩展" class="headerlink" title="3. 字符串的扩展"></a>3. 字符串的扩展</h2><p><a href="https://es6.ruanyifeng.com/#docs/string">本章</a>内容复杂，故先跳过一部分。</p><h3 id="3-1-模板字符串"><a href="#3-1-模板字符串" class="headerlink" title="3.1 模板字符串"></a>3.1 模板字符串</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&#x27;#result&#x27;</span>).<span class="title function_">append</span>(<span class="string">`</span></span><br><span class="line"><span class="string">  There are &lt;b&gt;<span class="subst">$&#123;basket.count&#125;</span>&lt;/b&gt; items</span></span><br><span class="line"><span class="string">   in your basket, &lt;em&gt;<span class="subst">$&#123;basket.onSale&#125;</span>&lt;/em&gt;</span></span><br><span class="line"><span class="string">  are on sale!</span></span><br><span class="line"><span class="string">`</span>);</span><br></pre></td></tr></table></figure><p>模板字符串（<code>template string</code>）是增强版的字符串。它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 字符串中嵌入变量</span></span><br><span class="line"><span class="keyword">let</span> name = <span class="string">&quot;Bob&quot;</span>, time = <span class="string">&quot;today&quot;</span>;</span><br><span class="line"><span class="string">`Hello <span class="subst">$&#123;name&#125;</span>, how are you <span class="subst">$&#123;time&#125;</span>?`</span></span><br></pre></td></tr></table></figure><p>注意，如果使用模板字符串表示多行字符串，所有的空格，换行，缩进都会被保留在输出之中。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str1 = <span class="string">&#x27;Hello&#x27;</span> +</span><br><span class="line">    <span class="string">&#x27;World&#x27;</span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">let</span> str2 = <span class="string">`Hello</span></span><br><span class="line"><span class="string">World`</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str1); <span class="comment">// HelloWorld</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str2); <span class="comment">// Hello</span></span><br><span class="line">                   <span class="comment">// World 换行被保留</span></span><br></pre></td></tr></table></figure><hr><h3 id="3-2-标签模板"><a href="#3-2-标签模板" class="headerlink" title="3.2 标签模板"></a>3.2 标签模板</h3><p>模板字符串可以紧跟在一个函数名后面，该函数将被调用来处理这个模板字符串。这被称为“标签模板”功能（<code>tagged template</code>）。</p><ul><li>标签模板不是模板，而是函数调用的一种特殊形式。“标签”指的是函数，它的参数是紧跟在后面的模板字符串。</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">alert<span class="string">`hello`</span></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="title function_">alert</span>([<span class="string">&#x27;hello&#x27;</span>])</span><br></pre></td></tr></table></figure><p>如果模板字符里面有变量，就不是直接调用了。会先将模板字符串先处理成多个参数，再调用函数。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">tag</span>(<span class="params">stringArr, ...values</span>)&#123; ... &#125;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">tag</span>(<span class="params">stringArr, value1, value2</span>)&#123; ... &#125;</span><br><span class="line"></span><br><span class="line">tag<span class="string">`Hello <span class="subst">$&#123; a + b &#125;</span> world <span class="subst">$&#123; a * b &#125;</span>`</span>;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="title function_">tag</span>([<span class="string">&#x27;Hello &#x27;</span>, <span class="string">&#x27; world &#x27;</span>, <span class="string">&#x27;&#x27;</span>], <span class="number">15</span>, <span class="number">50</span>); </span><br></pre></td></tr></table></figure><hr><h2 id="4-字符串的新增方法"><a href="#4-字符串的新增方法" class="headerlink" title="4. 字符串的新增方法"></a>4. 字符串的新增方法</h2><h3 id="4-1-新增方法"><a href="#4-1-新增方法" class="headerlink" title="4.1 新增方法"></a>4.1 新增方法</h3><p><strong>实例方法 1：</strong><code>ES5</code> 中只有<code>indexOf()</code>方法可以用来确定一个字符串是否包含在另一个字符串中。<code>ES6</code> 又提供了三种新方法：</p><ul><li><code>includes()</code>：返回布尔值，表示是否找到了参数字符串。</li><li><code>startsWith()</code>：返回布尔值，表示参数字符串是否在原字符串的头部。</li><li><code>endsWith()</code>：返回布尔值，表示参数字符串是否在原字符串的尾部。</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">&#x27;Hello world!&#x27;</span>;</span><br><span class="line"></span><br><span class="line">s.<span class="title function_">startsWith</span>(<span class="string">&#x27;Hello&#x27;</span>) <span class="comment">// true</span></span><br><span class="line">s.<span class="title function_">endsWith</span>(<span class="string">&#x27;!&#x27;</span>) <span class="comment">// true</span></span><br><span class="line">s.<span class="title function_">includes</span>(<span class="string">&#x27;o&#x27;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>这三个方法都支持第二个参数，表示开始搜索的位置。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">&#x27;Hello world!&#x27;</span>;</span><br><span class="line"></span><br><span class="line">s.<span class="title function_">startsWith</span>(<span class="string">&#x27;world&#x27;</span>, <span class="number">6</span>) <span class="comment">// true</span></span><br><span class="line">s.<span class="title function_">endsWith</span>(<span class="string">&#x27;Hello&#x27;</span>, <span class="number">5</span>) <span class="comment">// true</span></span><br><span class="line">s.<span class="title function_">includes</span>(<span class="string">&#x27;Hello&#x27;</span>, <span class="number">6</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>上面代码中，使用第二个参数<code>n</code>时，<code>endsWith()</code>的行为与其他两个方法不同。它针对前<code>n</code>个字符，而其他两个方法针对从第<code>n</code>个位置直到字符串结束。</p><p><strong>实例方法 2：</strong><code>repeat()</code>方法返回一个新字符串，将原字符串重复<code>n</code>次。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;na&#x27;</span>.<span class="title function_">repeat</span>(<span class="number">3</span>) <span class="comment">// &quot;nana&quot;</span></span><br><span class="line"><span class="string">&#x27;na&#x27;</span>.<span class="title function_">repeat</span>(<span class="string">&#x27;2&#x27;</span>) <span class="comment">// &quot;nana&quot; 转换成数字</span></span><br><span class="line"><span class="string">&#x27;na&#x27;</span>.<span class="title function_">repeat</span>(<span class="number">0</span>) <span class="comment">// &quot;&quot;</span></span><br><span class="line"><span class="string">&#x27;na&#x27;</span>.<span class="title function_">repeat</span>(<span class="number">2.9</span>) <span class="comment">// &quot;nana&quot; 取整</span></span><br><span class="line"><span class="string">&#x27;na&#x27;</span>.<span class="title function_">repeat</span>(-<span class="number">1</span>) <span class="comment">// RangeError</span></span><br></pre></td></tr></table></figure><p><strong>实例方法 3：</strong><code>ES6</code> 引入字符串补全长度功能，能在某个字符串不够指定长度时，往头部或尾部补全。<code>padStart()</code>用于头部补全，<code>padEnd()</code>用于尾部补全。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;x&#x27;</span>.<span class="title function_">padStart</span>(<span class="number">5</span>, <span class="string">&#x27;ab&#x27;</span>) <span class="comment">// &#x27;ababx&#x27; 补到length == 5</span></span><br><span class="line"><span class="string">&#x27;abc&#x27;</span>.<span class="title function_">padStart</span>(<span class="number">10</span>, <span class="string">&#x27;0123456789&#x27;</span>)</span><br><span class="line"><span class="comment">// &#x27;0123456abc&#x27; 如果两者的长度之和超过了最大长度，则会截去超出的位数</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;x&#x27;</span>.<span class="title function_">padEnd</span>(<span class="number">5</span>, <span class="string">&#x27;ab&#x27;</span>) <span class="comment">// &#x27;xabab&#x27;</span></span><br><span class="line"><span class="string">&#x27;x&#x27;</span>.<span class="title function_">padEnd</span>(<span class="number">4</span>, <span class="string">&#x27;ab&#x27;</span>) <span class="comment">// &#x27;xaba&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>实例方法 4：</strong><code>ES6</code> 新增了<code>trimStart()</code>和<code>trimEnd()</code>两个方法。它们的行为与<code>trim()</code>一致，<code>trimStart()</code>消除字符串头部的空格，<code>trimEnd()</code>消除尾部的空格。它们返回的都是新字符串，不会修改原始字符串。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="string">&#x27;  abc  &#x27;</span>;</span><br><span class="line"></span><br><span class="line">s.<span class="title function_">trim</span>() <span class="comment">// &quot;abc&quot;</span></span><br><span class="line">s.<span class="title function_">trimStart</span>() <span class="comment">// &quot;abc  &quot;</span></span><br><span class="line">s.<span class="title function_">trimEnd</span>() <span class="comment">// &quot;  abc&quot;</span></span><br></pre></td></tr></table></figure><p><strong>实例方法 5：</strong><code>ES5</code>中，<code>replace()</code>只能替换第一个匹配。如果要替换所有的匹配，需要使用正则表达式的<code>g</code>修饰符。<code>ES6</code>引入了<code>replaceAll()</code>方法，可以一次性替换所有匹配。它返回的是新字符串，不会修改原始字符串。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;aabbcc&#x27;</span>.<span class="title function_">replace</span>(<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;_&#x27;</span>)</span><br><span class="line"><span class="comment">// &#x27;aa_bcc&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;aabbcc&#x27;</span>.<span class="title function_">replace</span>(<span class="regexp">/b/g</span>, <span class="string">&#x27;_&#x27;</span>)</span><br><span class="line"><span class="comment">// &#x27;aa__cc&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;aabbcc&#x27;</span>.<span class="title function_">replaceAll</span>(<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;_&#x27;</span>)</span><br><span class="line"><span class="comment">// &#x27;aa__cc&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>实例方法 6：</strong><code>ES6</code> 增加了<code>matchAll()</code>方法，可以一次性取出字符串里面所有匹配。但是，它返回的是一个遍历器，而不是数组。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> string = <span class="string">&#x27;test1test2test3&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> regex = <span class="regexp">/t(e)(st(\d?))/g</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> match <span class="keyword">of</span> string.<span class="title function_">matchAll</span>(regex)) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(match);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// [&quot;test1&quot;, &quot;e&quot;, &quot;st1&quot;, &quot;1&quot;, index: 0, input: &quot;test1test2test3&quot;]</span></span><br><span class="line"><span class="comment">// [&quot;test2&quot;, &quot;e&quot;, &quot;st2&quot;, &quot;2&quot;, index: 5, input: &quot;test1test2test3&quot;]</span></span><br><span class="line"><span class="comment">// [&quot;test3&quot;, &quot;e&quot;, &quot;st3&quot;, &quot;3&quot;, index: 10, input: &quot;test1test2test3&quot;]</span></span><br></pre></td></tr></table></figure><p>遍历器转为数组是非常简单的，使用<code>...</code>运算符和<code>Array.from()</code>方法就可以。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 转为数组的方法一</span></span><br><span class="line">[...string.<span class="title function_">matchAll</span>(regex)]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转为数组的方法二</span></span><br><span class="line"><span class="title class_">Array</span>.<span class="title function_">from</span>(string.<span class="title function_">matchAll</span>(regex))</span><br></pre></td></tr></table></figure><hr><h2 id="5-正则的扩展"><a href="#5-正则的扩展" class="headerlink" title="5. 正则的扩展"></a>5. 正则的扩展</h2><p><a href="https://es6.ruanyifeng.com/#docs/regex">本章</a>内容复杂，故先跳过一部分。</p><h3 id="5-1-具名组匹配"><a href="#5-1-具名组匹配" class="headerlink" title="5.1 具名组匹配"></a>5.1 具名组匹配</h3><p>正则表达式使用圆括号进行<a href="https://segmentfault.com/a/1190000021043947">组匹配</a>。使用<code>exec</code>方法，就可以将这匹配结果提取出来。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">RE_DATE</span> = <span class="regexp">/(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> matchObj = <span class="variable constant_">RE_DATE</span>.<span class="title function_">exec</span>(<span class="string">&#x27;1999-12-31&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> year = matchObj[<span class="number">1</span>]; <span class="comment">// 1999</span></span><br><span class="line"><span class="keyword">const</span> month = matchObj[<span class="number">2</span>]; <span class="comment">// 12</span></span><br><span class="line"><span class="keyword">const</span> day = matchObj[<span class="number">3</span>]; <span class="comment">// 31</span></span><br></pre></td></tr></table></figure><p>组匹配的一个问题是，每一组的匹配含义不容易看出来，而且只能用数字序号<code>XXX[1]</code>引用，要是组的顺序变了，引用的时候就必须修改序号。</p><p><code>ES6</code> 引入了具名组匹配（<code>Named Capture Groups</code>），允许为每一个组匹配指定一个名字，既便于阅读代码，又便于引用。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">RE_DATE</span> = <span class="regexp">/(?&lt;year&gt;\d&#123;4&#125;)-(?&lt;month&gt;\d&#123;2&#125;)-(?&lt;day&gt;\d&#123;2&#125;)/</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> matchObj = <span class="variable constant_">RE_DATE</span>.<span class="title function_">exec</span>(<span class="string">&#x27;1999-12-31&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> year = matchObj.<span class="property">groups</span>.<span class="property">year</span>; <span class="comment">// &quot;1999&quot;</span></span><br><span class="line"><span class="keyword">const</span> month = matchObj.<span class="property">groups</span>.<span class="property">month</span>; <span class="comment">// &quot;12&quot;</span></span><br><span class="line"><span class="keyword">const</span> day = matchObj.<span class="property">groups</span>.<span class="property">day</span>; <span class="comment">// &quot;31&quot;</span></span><br></pre></td></tr></table></figure><hr><h2 id="6-数值的扩展"><a href="#6-数值的扩展" class="headerlink" title="6. 数值的扩展"></a>6. 数值的扩展</h2><p><a href="https://es6.ruanyifeng.com/#docs/number">本章</a>内容复杂，故先跳过一部分。</p><h3 id="6-1-BigInt-数据类型"><a href="#6-1-BigInt-数据类型" class="headerlink" title="6.1 BigInt 数据类型"></a>6.1 BigInt 数据类型</h3><p><code>ES5</code> 中所有数字都保存成 <code>64</code> 位浮点数，这给数值的表示带来了两大限制：</p><ul><li>数值的精度只能到 <code>53</code> 个二进制位，相当于 <code>16</code> 个十进制位，大于这个范围的整数，无法精确表示。 （不适合进行科学和金融方面的精确计算）</li><li>大于或等于<code>2</code>的<code>1024</code>次方的数值无法表示，会返回<code>Infinity</code>。</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 超过 53 个二进制位的数值，无法保持精度</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">pow</span>(<span class="number">2</span>, <span class="number">53</span>) === <span class="title class_">Math</span>.<span class="title function_">pow</span>(<span class="number">2</span>, <span class="number">53</span>) + <span class="number">1</span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 超过 2 的 1024 次方的数值，无法表示</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">pow</span>(<span class="number">2</span>, <span class="number">1024</span>) <span class="comment">// Infinity</span></span><br></pre></td></tr></table></figure><p><code>ES6</code> 引入了一种新的数据类型 <code>BigInt</code>，来解决这个问题，这是 <code>ECMAScript</code> 的<a href="https://juejin.cn/post/6954892721173561358">第八种数据类型</a>。<code>BigInt</code> <ins>只用来表示整数</ins>，没有位数的限制，任何位数的整数都可以精确表示。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="number">2172141653n</span>;</span><br><span class="line"><span class="keyword">const</span> b = <span class="number">15346349309n</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// BigInt 可以保持精度</span></span><br><span class="line">a * b <span class="comment">// 33334444555566667777n</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通整数无法保持精度</span></span><br><span class="line"><span class="title class_">Number</span>(a) * <span class="title class_">Number</span>(b) <span class="comment">// 33334444555566670000</span></span><br></pre></td></tr></table></figure><p><code>BigInt</code> 与普通整数是两种值，它们之间并不相等，且不能进行混合运算。为了与 <code>Number</code> 类型区别，<code>BigInt</code> 类型的数据必须添加后缀<code>n</code>。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">42n</span> === <span class="number">42</span> <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="number">1n</span> + <span class="number">1.3</span> <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><hr><h2 id="7-函数的扩展"><a href="#7-函数的扩展" class="headerlink" title="7. 函数的扩展"></a>7. 函数的扩展</h2><h3 id="7-1-函数参数的默认值"><a href="#7-1-函数参数的默认值" class="headerlink" title="7.1 函数参数的默认值"></a>7.1 函数参数的默认值</h3><p><code>ES6</code> 允许为函数的参数设置默认值，可以直接写在参数定义的后面（通常是函数的尾参数）。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Point</span>(<span class="params">x = <span class="number">0</span>, y = <span class="number">0</span></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">x</span> = x; <span class="comment">// this.x = x || 0 （ES5 写法）</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">y</span> = y; <span class="comment">// this.y = y || 0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Point</span>();</span><br><span class="line">p <span class="comment">// &#123; x: 0, y: 0 &#125;</span></span><br></pre></td></tr></table></figure><p>函数参数的默认值有两个好处：</p><ul><li>阅读代码的人，可以立刻意识到哪些参数是可以省略的，不用查看函数体或文档。</li><li>有利于将来的代码优化，即使未来的版本在对外接口中，彻底拿掉这个参数，也不会导致以前的代码无法运行。</li></ul><p>参数默认值可以与解构赋值的默认值结合使用。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fetch</span>(<span class="params">url, &#123; body = <span class="string">&#x27;&#x27;</span>, method = <span class="string">&#x27;GET&#x27;</span>, headers = &#123;&#125; &#125;</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(method);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">fetch</span>(<span class="string">&#x27;http://example.com&#x27;</span>, &#123;&#125;)</span><br><span class="line"><span class="comment">// &quot;GET&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">fetch</span>(<span class="string">&#x27;http://example.com&#x27;</span>)</span><br><span class="line"><span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><p>上面代码中，函数<code>fetch</code>的第二个参数是一个对象，它的三个属性都有默认值。这种写法不能省略第二个参数，如果结合函数参数的默认值，就可以省略第二个参数。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fetch</span>(<span class="params">url, &#123; body = <span class="string">&#x27;&#x27;</span>, method = <span class="string">&#x27;GET&#x27;</span>, headers = &#123;&#125; &#125; = &#123;&#125;</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(method);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">fetch</span>(<span class="string">&#x27;http://example.com&#x27;</span>)</span><br><span class="line"><span class="comment">// &quot;GET&quot;</span></span><br></pre></td></tr></table></figure><p>上面代码中，当函数<code>fetch</code>没有第二个参数时，函数参数的默认值就会生效，然后才是解构赋值的默认值生效，变量<code>method</code>才会取到默认值<code>GET</code>。</p><p>注意，函数参数的默认值生效以后，参数解构赋值依然会进行。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">&#123; a, b = <span class="string">&#x27;world&#x27;</span> &#125; = &#123; a: <span class="string">&#x27;hello&#x27;</span> &#125;</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">f</span>() <span class="comment">// world</span></span><br></pre></td></tr></table></figure><hr><h3 id="7-2-rest-参数"><a href="#7-2-rest-参数" class="headerlink" title="7.2 rest 参数"></a>7.2 rest 参数</h3><p><code>rest</code> 参数可以代替<code>arguments</code>对象，去获取函数的多余参数。<code>rest</code> 参数之后不能再有其他参数，它只能是最后一个参数。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// arguments变量的写法</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sortNumbers</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Array</span>.<span class="title function_">from</span>(<span class="variable language_">arguments</span>).<span class="title function_">sort</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">sortNumbers</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">3</span>))</span><br><span class="line"><span class="comment">// [1,2,3,5]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// rest参数的写法</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">sortNumbers</span> = (<span class="params">...numbers</span>) =&gt; numbers.<span class="title function_">sort</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">sortNumbers</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">3</span>)) </span><br><span class="line"><span class="comment">// [1,2,3,5]</span></span><br></pre></td></tr></table></figure><p>上面代码的两种写法，比较后可以发现，<code>rest</code> 参数的写法更自然也更简洁。</p><hr><h3 id="7-3-箭头函数"><a href="#7-3-箭头函数" class="headerlink" title="7.3 箭头函数"></a>7.3 箭头函数</h3><p><code>ES6</code> 允许使用“箭头” <code>=&gt;</code> 定义函数。</p><ul><li>如果箭头函数不需要参数或需要多个参数，就使用一个圆括号代表参数部分。</li><li>如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用<code>return</code>语句返回。</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title function_">f</span> = (<span class="params"></span>) =&gt; <span class="number">5</span>;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">let</span> f = <span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="keyword">return</span> <span class="number">5</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="title function_">sum</span> = (<span class="params">num1, num2</span>) =&gt; num1 + num2;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">let</span> <span class="title function_">sum</span> = (<span class="params">num1, num2</span>) =&gt; &#123; <span class="keyword">return</span> num1 + num2; &#125;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">let</span> sum = <span class="keyword">function</span>(<span class="params">num1, num2</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>箭头函数可以与变量解构结合使用。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">full</span> = (<span class="params">&#123; first, last &#125;</span>) =&gt; first + <span class="string">&#x27; &#x27;</span> + last;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">full</span>(<span class="params">person</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> person.<span class="property">first</span> + <span class="string">&#x27; &#x27;</span> + person.<span class="property">last</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>箭头函数还可以和上面的 <code>rest</code> 参数结合使用。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">numbers</span> = (<span class="params">...nums</span>) =&gt; nums;</span><br><span class="line"></span><br><span class="line"><span class="title function_">numbers</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line"><span class="comment">// [1,2,3,4,5]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">headAndTail</span> = (<span class="params">head, ...tail</span>) =&gt; [head, tail];</span><br><span class="line"></span><br><span class="line"><span class="title function_">headAndTail</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line"><span class="comment">// [1,[2,3,4,5]]</span></span><br></pre></td></tr></table></figure><p>箭头函数的重要用处是简化<a href="https://segmentfault.com/a/1190000021942060">回调函数</a>。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 普通函数写法</span></span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].<span class="title function_">map</span>(<span class="keyword">function</span> (<span class="params">x</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 箭头函数写法</span></span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].<span class="title function_">map</span>(<span class="function"><span class="params">x</span> =&gt;</span> x * x);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通函数写法</span></span><br><span class="line"><span class="keyword">let</span> result = values.<span class="title function_">sort</span>(<span class="keyword">function</span> (<span class="params">a, b</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> a - b;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 箭头函数写法</span></span><br><span class="line"><span class="keyword">let</span> result = values.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br></pre></td></tr></table></figure><p>箭头函数有几个使用<a href="https://es6.ruanyifeng.com/#docs/function#%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E7%82%B9">注意点</a>，其中最重要的是，箭头函数没有自己的<code>this</code>对象。</p><ul><li>对于<ins>普通函数来说，内部的<code>this</code>指向函数运行时所在的对象</ins>，但是<ins>这一点对箭头函数不成立。它没有自己的<code>this</code>对象，内部的<code>this</code>就是定义时上层作用域中的<code>this</code></ins>。也就是说，<ins>箭头函数内部的<code>this</code>指向是固定的</ins>，相比之下，<ins>普通函数的<code>this</code>指向是可变的</ins>。</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Timer</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">s1</span> = <span class="number">0</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">s2</span> = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 箭头函数</span></span><br><span class="line">  <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> <span class="variable language_">this</span>.<span class="property">s1</span>++, <span class="number">1000</span>);</span><br><span class="line">  <span class="comment">// 普通函数</span></span><br><span class="line">  <span class="built_in">setInterval</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">s2</span>++;</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> timer = <span class="keyword">new</span> <span class="title class_">Timer</span>(); <span class="comment">// 注意</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;s1: &#x27;</span>, timer.<span class="property">s1</span>), <span class="number">3100</span>);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;s2: &#x27;</span>, timer.<span class="property">s2</span>), <span class="number">3100</span>);</span><br><span class="line"><span class="comment">// s1: 3</span></span><br><span class="line"><span class="comment">// s2: 0</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>Timer</code>函数内部设置了两个定时器，分别使用了箭头函数和普通函数。<ins>前者的<code>this</code>绑定定义时所在的作用域，即<code>Timer</code>函数，后者的<code>this</code>指向运行时所在的作用域，即全局对象</ins>。所以，<code>3100</code> 毫秒之后，<code>timer.s1</code>被更新了 <code>3</code> 次，而<code>timer.s2</code>一次都没更新。</p><hr><h2 id="8-数组的扩展"><a href="#8-数组的扩展" class="headerlink" title="8. 数组的扩展"></a>8. 数组的扩展</h2><h3 id="8-1-扩展运算符"><a href="#8-1-扩展运算符" class="headerlink" title="8.1 扩展运算符"></a>8.1 扩展运算符</h3><p>扩展运算符 <code>...</code>，将一个数组转为用逗号分隔的参数序列。类似 <code>rest</code> 参数的逆运算。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(...[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="comment">// 1 2 3</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>, ...[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], <span class="number">5</span>)</span><br><span class="line"><span class="comment">// 1 2 3 4 5</span></span><br><span class="line"></span><br><span class="line">[...<span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;div&#x27;</span>)]</span><br><span class="line"><span class="comment">// [&lt;div&gt;, &lt;div&gt;, &lt;div&gt;]</span></span><br></pre></td></tr></table></figure><p>扩展运算符主要用于函数调用，可以代替<code>apply()</code>方法将数组转为函数的参数。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ES5 的写法</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">x, y, z</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> args = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">f.<span class="title function_">apply</span>(<span class="literal">null</span>, args);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6 的写法</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">x, y, z</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> args = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="title function_">f</span>(...args);</span><br></pre></td></tr></table></figure><hr><h3 id="8-2-扩展运算符的应用"><a href="#8-2-扩展运算符的应用" class="headerlink" title="8.2 扩展运算符的应用"></a>8.2 扩展运算符的应用</h3><p><strong>（1）复制数组</strong></p><p>数组是复合的数据类型，直接复制的话，只是复制了指向底层数据结构的指针，而不是克隆一个全新的数组。扩展运算符提供了复制数组的简便写法。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a1 = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">const</span> a2 = a1;</span><br><span class="line"></span><br><span class="line">a2[<span class="number">0</span>] = <span class="number">2</span>;</span><br><span class="line">a1 <span class="comment">// [2, 2]，浅拷贝</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="keyword">const</span> a2 = [...a1];</span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="keyword">const</span> [...a2] = a1;</span><br></pre></td></tr></table></figure><p><strong>（2）合并数组</strong></p><p>扩展运算符提供了数组合并的新写法。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr1 = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>];</span><br><span class="line"><span class="keyword">const</span> arr2 = [<span class="string">&#x27;c&#x27;</span>];</span><br><span class="line"><span class="keyword">const</span> arr3 = [<span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES5 的合并数组</span></span><br><span class="line">arr1.<span class="title function_">concat</span>(arr2, arr3);</span><br><span class="line"><span class="comment">// [ &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27; ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6 的合并数组</span></span><br><span class="line">[...arr1, ...arr2, ...arr3]</span><br><span class="line"><span class="comment">// [ &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27; ]</span></span><br></pre></td></tr></table></figure><p>不过两种方法都是<a href="https://vue3js.cn/interview/JavaScript/copy.html">浅拷贝</a>，使用的时候需要特别小心。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a1 = [&#123; <span class="attr">foo</span>: <span class="number">1</span> &#125;];</span><br><span class="line"><span class="keyword">const</span> a2 = [&#123; <span class="attr">bar</span>: <span class="number">2</span> &#125;];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a3 = a1.<span class="title function_">concat</span>(a2);</span><br><span class="line"><span class="keyword">const</span> a4 = [...a1, ...a2];</span><br><span class="line"></span><br><span class="line">a3[<span class="number">0</span>] === a1[<span class="number">0</span>] <span class="comment">// true</span></span><br><span class="line">a4[<span class="number">0</span>] === a1[<span class="number">0</span>] <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>a3</code>和<code>a4</code>是用两种不同方法合并而成的新数组，但是它们的成员都是对原数组成员的引用，这就是浅拷贝。<ins>如果修改了引用指向的值，会同步反映到新数组</ins>。</p><p><strong>（3）与解构赋值结合</strong></p><p>扩展运算符可以与解构赋值结合起来，用于生成数组。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> [first, ...rest] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">first <span class="comment">// 1</span></span><br><span class="line">rest  <span class="comment">// [2, 3, 4, 5]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> [first, ...rest] = [];</span><br><span class="line">first <span class="comment">// undefined</span></span><br><span class="line">rest  <span class="comment">// []</span></span><br></pre></td></tr></table></figure><p><strong>（4）具有 Iterator 接口的对象</strong></p><p>扩展运算符调用的是数据结构的 <code>Iterator</code> 接口，因此只要具有 <code>Iterator</code> 接口的对象，都可以使用扩展运算符。比如字符串，<code>Map</code>和<code>Set</code>，<code>Generator</code>函数返回的遍历器对象。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[...<span class="string">&#x27;hello&#x27;</span>]</span><br><span class="line"><span class="comment">// [ &quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot; ]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>([</span><br><span class="line">  [<span class="number">1</span>, <span class="string">&#x27;one&#x27;</span>],</span><br><span class="line">  [<span class="number">2</span>, <span class="string">&#x27;two&#x27;</span>],</span><br><span class="line">  [<span class="number">3</span>, <span class="string">&#x27;three&#x27;</span>],</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = [...map.<span class="title function_">keys</span>()]; <span class="comment">// [1, 2, 3]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> go = <span class="keyword">function</span>*()&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">[...<span class="title function_">go</span>()] <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure><hr><h3 id="8-3-新增方法"><a href="#8-3-新增方法" class="headerlink" title="8.3 新增方法"></a>8.3 新增方法</h3><p><strong>静态方法 1：</strong><code>Array.from()</code>方法用于将两类对象转为真正的数组，类似数组的对象和可遍历的对象。（包括 <code>ES6</code> 新增的数据结构 <code>Set</code> 和 <code>Map</code>，和部署了 <code>Iterator</code> 接口的数据结构）</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arrayLike = &#123;</span><br><span class="line">    <span class="string">&#x27;0&#x27;</span>: <span class="string">&#x27;a&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;1&#x27;</span>: <span class="string">&#x27;b&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;2&#x27;</span>: <span class="string">&#x27;c&#x27;</span>,</span><br><span class="line">    <span class="attr">length</span>: <span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES5 的写法</span></span><br><span class="line"><span class="keyword">var</span> arr1 = [].<span class="property">slice</span>.<span class="title function_">call</span>(arrayLike); <span class="comment">// [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6 的写法</span></span><br><span class="line"><span class="keyword">let</span> arr2 = <span class="title class_">Array</span>.<span class="title function_">from</span>(arrayLike); <span class="comment">// [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]</span></span><br></pre></td></tr></table></figure><p><code>Array.from()</code>还可以接受一个函数作为第二个参数，作用类似于数组的<code>map()</code>方法，用来对每个元素进行处理，将处理后的值放入返回的数组。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="title function_">from</span>(arrayLike, <span class="function"><span class="params">x</span> =&gt;</span> x * x);</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="title class_">Array</span>.<span class="title function_">from</span>(arrayLike).<span class="title function_">map</span>(<span class="function"><span class="params">x</span> =&gt;</span> x * x);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Array</span>.<span class="title function_">from</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="function">(<span class="params">x</span>) =&gt;</span> x * x)</span><br><span class="line"><span class="comment">// [1, 4, 9]</span></span><br></pre></td></tr></table></figure><p><strong>静态方法 2：</strong><code>Array.of()</code>方法用于将一组值，转换为数组。它可以替代<code>Array()</code>或<code>new Array()</code>，并且不存在由于参数不同而导致的重载。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="title function_">of</span>(<span class="number">3</span>, <span class="number">11</span>, <span class="number">8</span>) <span class="comment">// [3,11,8]</span></span><br><span class="line"><span class="title class_">Array</span>.<span class="title function_">of</span>(<span class="number">3</span>) <span class="comment">// [3]</span></span><br><span class="line"><span class="title class_">Array</span>.<span class="title function_">of</span>(<span class="number">3</span>).<span class="property">length</span> <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载</span></span><br><span class="line"><span class="title class_">Array</span>() <span class="comment">// []</span></span><br><span class="line"><span class="title class_">Array</span>(<span class="number">3</span>) <span class="comment">// [, , ,]</span></span><br><span class="line"><span class="title class_">Array</span>(<span class="number">3</span>, <span class="number">11</span>, <span class="number">8</span>) <span class="comment">// [3, 11, 8]</span></span><br></pre></td></tr></table></figure><p><strong>实例方法 1：</strong><code>find()</code>方法，用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为<code>true</code>的成员，然后返回该成员。如果没有符合条件的成员，则返回<code>undefined</code>。</p><p><code>findIndex()</code>方法的用法与<code>find()</code>方法类似，返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回<code>-1</code>。<code>find()</code>和<code>findIndex()</code>都是从数组的<code>0</code>号位，依次向后检查。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">4</span>, -<span class="number">5</span>, <span class="number">10</span>].<span class="title function_">find</span>(<span class="function">(<span class="params">n</span>) =&gt;</span> n &lt; <span class="number">0</span>)</span><br><span class="line"><span class="comment">// -5</span></span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>].<span class="title function_">findIndex</span>(<span class="keyword">function</span>(<span class="params">value, index, arr</span>) &#123; <span class="comment">// 当前的值、当前的位置和原数组</span></span><br><span class="line">  <span class="keyword">return</span> value &gt; <span class="number">9</span>;</span><br><span class="line">&#125;) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>与之相反，<code>findLast()</code>和<code>findLastIndex()</code>是从数组的最后一个成员开始，依次向前检查，其他都保持不变。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> array = [</span><br><span class="line">  &#123; <span class="attr">value</span>: <span class="number">1</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">value</span>: <span class="number">2</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">value</span>: <span class="number">3</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">value</span>: <span class="number">4</span> &#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">array.<span class="title function_">findLast</span>(<span class="function"><span class="params">n</span> =&gt;</span> n.<span class="property">value</span> % <span class="number">2</span> === <span class="number">1</span>); <span class="comment">// &#123; value: 3 &#125;</span></span><br><span class="line">array.<span class="title function_">findLastIndex</span>(<span class="function"><span class="params">n</span> =&gt;</span> n.<span class="property">value</span> % <span class="number">2</span> === <span class="number">1</span>); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p><strong>实例方法 2：</strong><code>fill()</code>方法使用给定值，填充一个数组。它还可以接受第二个和第三个参数，用于指定填充的起始位置和结束位置。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>].<span class="title function_">fill</span>(<span class="number">7</span>)</span><br><span class="line"><span class="comment">// [7, 7, 7]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">3</span>).<span class="title function_">fill</span>(<span class="number">7</span>)</span><br><span class="line"><span class="comment">// [7, 7, 7]</span></span><br><span class="line"></span><br><span class="line">[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>].<span class="title function_">fill</span>(<span class="number">7</span>, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="comment">// [&#x27;a&#x27;, 7, &#x27;c&#x27;]</span></span><br></pre></td></tr></table></figure><p><strong>实例方法 3：</strong><code>ES6</code> 提供三个新的方法用于遍历数组。<code>keys()</code>是对键名的遍历，<code>values()</code>是对键值的遍历，<code>entries()</code>是对键值对的遍历。它们都可以用<code>for...of</code>循环进行遍历。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> index <span class="keyword">of</span> [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>].<span class="title function_">keys</span>()) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(index);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> elem <span class="keyword">of</span> [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>].<span class="title function_">values</span>()) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(elem);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &#x27;a&#x27;</span></span><br><span class="line"><span class="comment">// &#x27;b&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [index, elem] <span class="keyword">of</span> [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>].<span class="title function_">entries</span>()) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(index, elem);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0 &quot;a&quot;</span></span><br><span class="line"><span class="comment">// 1 &quot;b&quot;</span></span><br></pre></td></tr></table></figure><p><strong>实例方法 4：</strong><code>includes()</code>方法返回一个布尔值，表示某个数组是否包含给定的值。该方法的第二个参数表示搜索的起始位置，默认为<code>0</code>。如果第二个参数为负数，则表示倒数的位置。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].<span class="title function_">includes</span>(<span class="number">2</span>)     <span class="comment">// true</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].<span class="title function_">includes</span>(<span class="number">4</span>)     <span class="comment">// false</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="title class_">NaN</span>].<span class="title function_">includes</span>(<span class="title class_">NaN</span>) <span class="comment">// true</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].<span class="title function_">includes</span>(<span class="number">3</span>, -<span class="number">1</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><strong>实例方法 5：</strong>数组的成员有时还是数组，<code>flat()</code>方法用于将嵌套的数组“拉平”，变成一维的数组。该方法返回一个新数组，对原数据没有影响。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>]].<span class="title function_">flat</span>()</span><br><span class="line"><span class="comment">// [1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure><p><code>flat()</code>方法默认只会“拉平”一层，如果想要“拉平”多层的嵌套数组，可以指定<code>flat()</code>方法的参数，表示想要拉平的层数，默认为<code>1</code>。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>]]].<span class="title function_">flat</span>()</span><br><span class="line"><span class="comment">// [1, 2, 3, [4, 5]]</span></span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>]]].<span class="title function_">flat</span>(<span class="number">2</span>)</span><br><span class="line"><span class="comment">// [1, 2, 3, 4, 5]</span></span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>, [<span class="number">2</span>, [<span class="number">3</span>]]].<span class="title function_">flat</span>(<span class="title class_">Infinity</span>)</span><br><span class="line"><span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure><p><code>flatMap()</code>方法对原数组的每个成员执行一个函数（相当于执行<code>map()</code>）, 然后对返回值组成的数组执行<code>flat()</code>方法。注意，<code>flatMap()</code>只能展开一层数组。该方法返回一个新数组，不改变原数组。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 相当于 [[2, 4], [3, 6], [4, 8]].flat()</span></span><br><span class="line">[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>].<span class="title function_">flatMap</span>(<span class="function">(<span class="params">x</span>) =&gt;</span> [x, x * <span class="number">2</span>])</span><br><span class="line"><span class="comment">// [2, 4, 3, 6, 4, 8]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 相当于 [[[2]], [[4]], [[6]], [[8]]].flat()</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>].<span class="title function_">flatMap</span>(<span class="function"><span class="params">x</span> =&gt;</span> [[x * <span class="number">2</span>]])</span><br><span class="line"><span class="comment">// [[2], [4], [6], [8]]</span></span><br></pre></td></tr></table></figure><p><strong>实例方法 6：</strong><code>ES5</code> 不支持数组的负索引，如果要引用数组的最后一个成员，不能写成<code>arr[-1]</code>，只能使用<code>arr[arr.length - 1]</code>。<code>ES6</code> 为数组实例增加了<code>at()</code>方法，接受一个整数作为参数，返回对应位置的成员，并支持负索引。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">5</span>, <span class="number">12</span>, <span class="number">8</span>, <span class="number">130</span>, <span class="number">44</span>];</span><br><span class="line"></span><br><span class="line">arr[-<span class="number">2</span>] <span class="comment">// Error</span></span><br><span class="line">arr.<span class="title function_">at</span>(<span class="number">2</span>) <span class="comment">// 8</span></span><br><span class="line">arr.<span class="title function_">at</span>(-<span class="number">2</span>) <span class="comment">// 130</span></span><br></pre></td></tr></table></figure><hr><h2 id="9-对象的扩展"><a href="#9-对象的扩展" class="headerlink" title="9. 对象的扩展"></a>9. 对象的扩展</h2><p><a href="https://es6.ruanyifeng.com/#docs/object">本章</a>内容复杂，故先跳过一部分。</p><h3 id="9-1-属性的简洁表示法"><a href="#9-1-属性的简洁表示法" class="headerlink" title="9.1 属性的简洁表示法"></a>9.1 属性的简洁表示法</h3><p><code>ES6</code> 允许在大括号里面，直接写入变量和函数，作为对象的属性和方法。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> birth = <span class="string">&#x27;2000/01/01&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Person</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;张三&#x27;</span>,</span><br><span class="line">  birth, <span class="comment">// 等同于 birth: birth</span></span><br><span class="line">  <span class="title function_">hello</span>(<span class="params"></span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;我的名字是&#x27;</span>, <span class="variable language_">this</span>.<span class="property">name</span>); &#125;  </span><br><span class="line">  <span class="comment">// 等同于 hello: function ()...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h3 id="9-2-super-关键字"><a href="#9-2-super-关键字" class="headerlink" title="9.2 super 关键字"></a>9.2 super 关键字</h3><p>众所周知，<ins><code>this</code>关键字总是指向函数所在的当前对象</ins>，<code>ES6</code> 又新增了另一个类似的关键字<ins><code>super</code>，指向当前对象的原型对象</ins>。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> proto = &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="string">&#x27;hello&#x27;</span>,</span><br><span class="line">  <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">x</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="string">&#x27;world&#x27;</span>,</span><br><span class="line">  <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>.<span class="title function_">foo</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(obj, proto);</span><br><span class="line">obj.<span class="title function_">foo</span>() <span class="comment">// &quot;world&quot;</span></span><br></pre></td></tr></table></figure><p>上面代码中，对象<code>obj.foo()</code>方法之中，通过<code>super.foo</code>引用了原型对象<code>proto</code>的<code>foo</code>方法。<ins>但是绑定的<code>this</code>却还是当前对象<code>obj</code>，因此输出的就是<code>world</code></ins>。</p><p>注意，<code>super</code>关键字表示原型对象时，<ins>只能用在对象的方法之中</ins>，用在其他地方都会报错。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">/ 报错</span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">foo</span>: <span class="variable language_">super</span>.<span class="property">foo</span> <span class="comment">// 对象属性</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">foo</span>: <span class="function">() =&gt;</span> <span class="variable language_">super</span>.<span class="property">foo</span> <span class="comment">// 对象属性 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">foo</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="comment">// 对象属性</span></span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">super</span>.<span class="property">foo</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="9-3-对象的扩展运算符"><a href="#9-3-对象的扩展运算符" class="headerlink" title="9.3 对象的扩展运算符"></a>9.3 对象的扩展运算符</h3><p><strong>（1）解构赋值</strong></p><p>对象的解构赋值用于从一个对象取值，将目标对象所有<a href="https://es6.ruanyifeng.com/#docs/object#%E5%B1%9E%E6%80%A7%E7%9A%84%E5%8F%AF%E6%9E%9A%E4%B8%BE%E6%80%A7%E5%92%8C%E9%81%8D%E5%8E%86">可遍历</a>的、但尚未被读取的属性，分配到指定的对象上面。（注意，解构赋值必须是最后一个参数，且等号右边不能是<code>undefined</code>或<code>null</code>）</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; x, y, ...z &#125; = &#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span>, <span class="attr">a</span>: <span class="number">3</span>, <span class="attr">b</span>: <span class="number">4</span> &#125;;</span><br><span class="line">x <span class="comment">// 1</span></span><br><span class="line">y <span class="comment">// 2</span></span><br><span class="line">z <span class="comment">// &#123; a: 3, b: 4 &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> z = &#123; <span class="attr">a</span>: <span class="number">3</span>, <span class="attr">b</span>: <span class="number">4</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> n = &#123; ...z &#125;;</span><br><span class="line">n <span class="comment">// &#123; a: 3, b: 4 &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; ...x, y, z &#125; = someObject; <span class="comment">// 句法错误</span></span><br></pre></td></tr></table></figure><p>解构赋值的拷贝是<a href="https://vue3js.cn/interview/JavaScript/copy.html">浅拷贝</a>，即<ins>如果一个键的值是复合类型的值（如数组、对象、函数），那么解构赋值拷贝的是这个值的引用，而不是这个值的副本</ins>。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">a</span>: &#123; <span class="attr">b</span>: <span class="number">1</span> &#125; &#125;;</span><br><span class="line"><span class="keyword">let</span> &#123; ...x &#125; = obj;</span><br><span class="line">obj.<span class="property">a</span>.<span class="property">b</span> = <span class="number">2</span>;</span><br><span class="line">x.<span class="property">a</span>.<span class="property">b</span> <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>x</code>是解构赋值所在的对象，拷贝了对象<code>obj</code>的<code>a</code>属性。<code>a</code>属性引用了一个对象，修改这个对象的值，会影响到解构赋值对它的引用。</p><p>解构赋值的一个用处，是扩展某个函数的参数，引入其他操作。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">baseFunction</span>(<span class="params">&#123; a, b &#125;</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">wrapperFunction</span>(<span class="params">&#123; x, y, ...restConfig &#125;</span>) &#123;</span><br><span class="line">  <span class="comment">// 使用 x 和 y 参数进行操作</span></span><br><span class="line">  <span class="comment">// 其余参数传给原始函数</span></span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">baseFunction</span>(restConfig);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，原始函数<code>baseFunction</code>接受<code>a</code>和<code>b</code>作为参数，函数<code>wrapperFunction</code>在<code>baseFunction</code>的基础上进行了扩展，能够接受多余的参数，并且保留原始函数的行为。</p><p><strong>（2）扩展运算符</strong></p><p>对象的扩展运算符 <code>...</code> 用于取出参数对象的所有可遍历属性，拷贝到当前对象之中。（扩展运算符不需要是最后一个参数）</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> z = &#123; <span class="attr">a</span>: <span class="number">3</span>, <span class="attr">b</span>: <span class="number">4</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> n = &#123; ...z &#125;;</span><br><span class="line">n <span class="comment">// &#123; a: 3, b: 4 &#125;</span></span><br><span class="line"></span><br><span class="line">&#123;...&#123;&#125;, <span class="attr">a</span>: <span class="number">1</span>&#125;</span><br><span class="line"><span class="comment">// &#123; a: 1 &#125;</span></span><br></pre></td></tr></table></figure><p>扩展运算符还可以用于合并两个对象。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> ab = &#123; ...a, ...b &#125;;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">let</span> ab = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, a, b);</span><br></pre></td></tr></table></figure><p>如果用户自定义的属性，放在扩展运算符后面，则扩展运算符内部的同名属性会被覆盖掉。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> aWithOverrides = &#123; ...a, <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">let</span> aWithOverrides = &#123; ...a, ...&#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span> &#125; &#125;;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">let</span> x = <span class="number">1</span>, y = <span class="number">2</span>, aWithOverrides = &#123; ...a, x, y &#125;;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">let</span> aWithOverrides = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, a, &#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span> &#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，<code>a</code>对象的<code>x</code>属性和<code>y</code>属性，拷贝到新对象后会被覆盖掉。</p><hr><h2 id="10-对象的新增方法"><a href="#10-对象的新增方法" class="headerlink" title="10. 对象的新增方法"></a>10. 对象的新增方法</h2><p><a href="https://es6.ruanyifeng.com/#docs/object-methods">本章</a>内容复杂，故先跳过一部分。</p><h3 id="10-1-静态方法"><a href="#10-1-静态方法" class="headerlink" title="10.1 静态方法"></a>10.1 静态方法</h3><p><code>ES5</code> 中比较两个值是否相等，只有两个运算符，相等运算符<code>==</code>和严格相等运算符<code>===</code>。它们都有缺点，前者会自动转换数据类型，后者的<code>NaN</code>不等于自身，以及<code>+0</code>等于<code>-0</code>。</p><p><strong>静态方法 1：</strong><code>Object.is()</code>方法用来比较两个值是否严格相等，与严格比较运算符<code>===</code>的行为基本一致。不同之处只有两个，一是<code>+0</code>不等于<code>-0</code>，二是<code>NaN</code>等于自身。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">is</span>(<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">is</span>(&#123;&#125;, &#123;&#125;)</span><br><span class="line"><span class="comment">// false</span></span><br></pre></td></tr></table></figure><p><strong>静态方法 2：</strong><code>Object.assign()</code>方法用于对象的合并，将源对象<code>source</code>的所有可枚举属性，复制到目标对象<code>target</code>。它的第一个参数是目标对象，后面的参数都是源对象。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> source1 = &#123; <span class="attr">b</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> source2 = &#123; <span class="attr">c</span>: <span class="number">3</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">assign</span>(target, source1, source2);</span><br><span class="line">target <span class="comment">// &#123;a:1, b:2, c:3&#125;</span></span><br></pre></td></tr></table></figure><p><code>Object.assign()</code>有以下几个使用注意点。</p><p><strong>（1）浅拷贝</strong></p><p><code>Object.assign()</code>方法实行的是浅拷贝，而不是深拷贝。也就是说，如果源对象某个属性的值是对象，那么目标对象拷贝得到的是这个对象的引用（指针）。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const obj1 = &#123;a: &#123;b: 1&#125;&#125;;</span><br><span class="line">const obj2 = Object.assign(&#123;&#125;, obj1);</span><br><span class="line"></span><br><span class="line">obj1.a.b = 2;</span><br><span class="line">obj2.a.b // 2</span><br></pre></td></tr></table></figure><p>上面代码中，源对象<code>obj1</code>的<code>a</code>属性的值是一个对象，<code>Object.assign()</code>拷贝得到的是这个对象的引用。这个对象的任何变化，都会反映到目标对象上面。</p><p><strong>（2）同名属性的替换</strong></p><p>对于嵌套的对象，一旦遇到同名属性，<code>Object.assign()</code>的处理方法是替换，而不是添加。这通常不是我们想要的，需要特别小心。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123; <span class="attr">a</span>: &#123; <span class="attr">b</span>: <span class="string">&#x27;c&#x27;</span>, <span class="attr">d</span>: <span class="string">&#x27;e&#x27;</span> &#125; &#125;</span><br><span class="line"><span class="keyword">const</span> source = &#123; <span class="attr">a</span>: &#123; <span class="attr">b</span>: <span class="string">&#x27;hello&#x27;</span> &#125; &#125;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">assign</span>(target, source)</span><br><span class="line"><span class="comment">// &#123; a: &#123; b: &#x27;hello&#x27; &#125; &#125;</span></span><br></pre></td></tr></table></figure><p><strong>静态方法 3：</strong>对于普通对象，我们可以用下面的方法对对象进行遍历。</p><ul><li><code>Object.keys()</code>返回一个数组，成员是参数对象自身的所有可遍历属性的键名。</li><li><code>Object.values()</code>返回一个数组，成员是参数对象自身的所有可遍历属性的键值。</li><li><code>Object.entries()</code>返回一个数组，成员是参数对象自身的所有可遍历属性的键值对数组。</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">foo</span>: <span class="string">&#x27;bar&#x27;</span>, <span class="attr">baz</span>: <span class="number">42</span> &#125;;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">keys</span>(obj)</span><br><span class="line"><span class="comment">// [&quot;foo&quot;, &quot;baz&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">foo</span>: <span class="string">&#x27;bar&#x27;</span>, <span class="attr">baz</span>: <span class="number">42</span> &#125;;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">values</span>(obj)</span><br><span class="line"><span class="comment">// [&quot;bar&quot;, 42]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">foo</span>: <span class="string">&#x27;bar&#x27;</span>, <span class="attr">baz</span>: <span class="number">42</span> &#125;;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">entries</span>(obj)</span><br><span class="line"><span class="comment">// [ [&quot;foo&quot;, &quot;bar&quot;], [&quot;baz&quot;, 42] ]</span></span><br></pre></td></tr></table></figure><hr><h2 id="11-运算符的扩展"><a href="#11-运算符的扩展" class="headerlink" title="11. 运算符的扩展"></a>11. 运算符的扩展</h2><h3 id="11-1-链判断运算符"><a href="#11-1-链判断运算符" class="headerlink" title="11.1 链判断运算符"></a>11.1 链判断运算符</h3><p>当我们打算读取对象内部的某个属性时，往往需要判断一下属性的上层对象是否存在。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误的写法</span></span><br><span class="line"><span class="keyword">const</span> firstName = message.<span class="property">body</span>.<span class="property">user</span>.<span class="property">firstName</span> || <span class="string">&#x27;default&#x27;</span>; <span class="comment">// 无法保证 message.body 存在...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确的写法</span></span><br><span class="line"><span class="keyword">const</span> firstName = (message</span><br><span class="line">  &amp;&amp; message.<span class="property">body</span></span><br><span class="line">  &amp;&amp; message.<span class="property">body</span>.<span class="property">user</span></span><br><span class="line">  &amp;&amp; message.<span class="property">body</span>.<span class="property">user</span>.<span class="property">firstName</span>) || <span class="string">&#x27;default&#x27;</span>;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>firstName</code>属性在对象的第四层，所以需要判断四次，每一层是否有值。这样的层层判断非常麻烦，因此 <code>ES6</code> 引入了“链判断运算符” <code>?.</code>，用来简化上面的写法。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> firstName = message?.<span class="property">body</span>?.<span class="property">user</span>?.<span class="property">firstName</span> || <span class="string">&#x27;default&#x27;</span>;</span><br></pre></td></tr></table></figure><p>上面代码使用了<code>?.</code>运算符，直接在链式调用的时候判断，左侧的对象是否为<code>null</code>或<code>undefined</code>。如果是的，就不再往下运算，而是返回<code>undefined</code>。</p><p>下面是 <code>?.</code> 运算符常见形式，以及不使用该运算符时的等价形式。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">a?.<span class="property">b</span></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">a == <span class="literal">null</span> ? <span class="literal">undefined</span> : a.<span class="property">b</span></span><br><span class="line"></span><br><span class="line">a?.[x]</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">a == <span class="literal">null</span> ? <span class="literal">undefined</span> : a[x]</span><br><span class="line"></span><br><span class="line">a?.<span class="title function_">b</span>()</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">a == <span class="literal">null</span> ? <span class="literal">undefined</span> : a.<span class="title function_">b</span>()</span><br><span class="line"></span><br><span class="line">a?.()</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">a == <span class="literal">null</span> ? <span class="literal">undefined</span> : <span class="title function_">a</span>()</span><br></pre></td></tr></table></figure><hr><h3 id="11-2-Null-判断运算符"><a href="#11-2-Null-判断运算符" class="headerlink" title="11.2 Null 判断运算符"></a>11.2 Null 判断运算符</h3><p>读取对象属性的时候，如果某个属性的值是<code>null</code>或<code>undefined</code>，有时候需要为它们指定默认值。常见做法是通过<code>||</code>运算符指定默认值。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> headerText = response.<span class="property">settings</span>.<span class="property">headerText</span> || <span class="string">&#x27;Hello, world!&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> animationDuration = response.<span class="property">settings</span>.<span class="property">animationDuration</span> || <span class="number">300</span>;</span><br><span class="line"><span class="keyword">const</span> showSplashScreen = response.<span class="property">settings</span>.<span class="property">showSplashScreen</span> || <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><p>但是属性的值如果为空字符串或<code>false</code>或<code>0</code>，默认值也会生效。为此，<code>ES6</code> 引入了一个新的 <code>Null</code> 判断运算符<code>??</code>。它的行为类似<code>||</code>，但是只有运算符左侧的值为<code>null</code>或<code>undefined</code>时，才会返回右侧的值。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> animationDuration = response.<span class="property">settings</span>?.<span class="property">animationDuration</span> ?? <span class="number">300</span>;</span><br></pre></td></tr></table></figure><p>上面代码中，如果<code>response.settings</code>是<code>null</code>或<code>undefined</code>，或者<code>response.settings.animationDuration</code>是<code>null</code>或<code>undefined</code>，就会返回默认值<code>300</code>。</p><hr><h2 id="12-Symbol-数据类型"><a href="#12-Symbol-数据类型" class="headerlink" title="12. Symbol 数据类型"></a>12. Symbol 数据类型</h2><p><a href="https://es6.ruanyifeng.com/#docs/symbol">本章</a>内容复杂，故先跳过一部分。</p><h3 id="12-1-Symbol-概述"><a href="#12-1-Symbol-概述" class="headerlink" title="12.1 Symbol 概述"></a>12.1 Symbol 概述</h3><p><code>ES6</code> 引入了一种新的原始数据类型 <code>Symbol</code>，表示独一无二的值。</p><p><code>Symbol</code> 通过 <code>Symbol()</code> 函数生成，可以用于为对象添加新的方法，且不存在属性名冲突。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="title class_">Symbol</span>(); <span class="comment">// Symbol() 函数前不能使用 new 命令</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> s</span><br><span class="line"><span class="comment">// &quot;symbol&quot;</span></span><br></pre></td></tr></table></figure><p><code>ES6</code> 提供了一个 <code>Symbol</code> 值的实例属性<code>description</code>，直接返回 <code>Symbol</code> 值的描述。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> sym = <span class="title class_">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>); <span class="comment">// 字符串作为参数</span></span><br><span class="line"></span><br><span class="line">sym <span class="comment">// [object Symbol] &#123; ... &#125;</span></span><br><span class="line">sym.<span class="title function_">toString</span>() <span class="comment">// &quot;Symbol(foo)&quot;</span></span><br><span class="line"></span><br><span class="line">sym.<span class="property">description</span> <span class="comment">// &quot;foo&quot;</span></span><br></pre></td></tr></table></figure><p>因为 <code>Symbol</code> 值都是不相等的（就算是相同描述，除非使用 <a href="https://es6.ruanyifeng.com/#docs/symbol#Symbol-for%EF%BC%8CSymbol-keyFor"><code>Symbol.for</code></a>），使用 <code>Symbol</code> 值作为标识符，用于对象的属性名，就能保证不会出现同名的属性。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> mySymbol = <span class="title class_">Symbol</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一种写法</span></span><br><span class="line"><span class="keyword">let</span> a = &#123;&#125;;</span><br><span class="line">a[mySymbol] = <span class="string">&#x27;Hello!&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种写法</span></span><br><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">  [mySymbol]: <span class="string">&#x27;Hello!&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以上写法都得到同样结果</span></span><br><span class="line">a[mySymbol] <span class="comment">// &quot;Hello!&quot;</span></span><br></pre></td></tr></table></figure><hr><h2 id="13-Set-和-Map-数据结构"><a href="#13-Set-和-Map-数据结构" class="headerlink" title="13. Set 和 Map 数据结构"></a>13. Set 和 Map 数据结构</h2><p><a href="https://es6.ruanyifeng.com/#docs/set-map">本章</a>跳过 <code>WeakSet</code> 和 <code>WeakMap</code> 部分。</p><h3 id="13-1-Set-基本用法"><a href="#13-1-Set-基本用法" class="headerlink" title="13.1 Set 基本用法"></a>13.1 Set 基本用法</h3><p><code>ES6</code>提供了新的数据结构 <code>Set</code>。它类似于数组，但是<ins>成员的值都是唯一的，没有重复的值</ins>。它可以接受一个数组，或者具有 <code>iterable</code> 接口的其他数据结构，作为参数初始化。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line"></span><br><span class="line">[<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">2</span>].<span class="title function_">forEach</span>(<span class="function"><span class="params">x</span> =&gt;</span> s.<span class="title function_">add</span>(x));</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> s) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2 3 5 4</span></span><br></pre></td></tr></table></figure><p>下面介绍 <code>Set</code> 实例的属性和方法：</p><ul><li><code>Set.prototype.size</code>：返回<code>Set</code>实例的成员总数。</li><li><code>Set.prototype.add(value)</code>：添加某个值，返回 <code>Set</code> 结构本身。</li><li><code>Set.prototype.delete(value)</code>：删除某个值，返回一个布尔值，表示删除是否成功。</li><li><code>Set.prototype.has(value)</code>：返回一个布尔值，表示该值是否为<code>Set</code>的成员。</li><li><code>Set.prototype.clear()</code>：清除所有成员，没有返回值。</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line">s.<span class="title function_">add</span>(<span class="number">1</span>).<span class="title function_">add</span>(<span class="number">2</span>).<span class="title function_">add</span>(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 注意2被加入了两次</span></span><br><span class="line"></span><br><span class="line">s.<span class="property">size</span> <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">s.<span class="title function_">has</span>(<span class="number">1</span>) <span class="comment">// true</span></span><br><span class="line">s.<span class="title function_">has</span>(<span class="number">2</span>) <span class="comment">// true</span></span><br><span class="line">s.<span class="title function_">has</span>(<span class="number">3</span>) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">s.<span class="title function_">delete</span>(<span class="number">2</span>);</span><br><span class="line">s.<span class="title function_">has</span>(<span class="number">2</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p><code>Set</code> 结构的实例默认可遍历, 可以直接用<code>for...of</code>循环遍历 <code>Set</code>。也可以用<code>forEach</code>方法，用于对每个成员执行某种操作，没有返回值。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">of</span> set) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// red</span></span><br><span class="line"><span class="comment">// green</span></span><br><span class="line"><span class="comment">// blue</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>]);</span><br><span class="line">set.<span class="title function_">forEach</span>(<span class="function">(<span class="params">value, key</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(key + <span class="string">&#x27; : &#x27;</span> + value))</span><br><span class="line"><span class="comment">// 1 : 1</span></span><br><span class="line"><span class="comment">// 4 : 4</span></span><br><span class="line"><span class="comment">// 9 : 9</span></span><br></pre></td></tr></table></figure><p>上面代码中<code>forEach</code>方法的参数是一个处理函数。但是因为 <code>Set</code> 结构的键名就是键值，因此第一个参数与第二个参数的值永远都是一样的。</p><hr><h3 id="13-2-Set-遍历的应用"><a href="#13-2-Set-遍历的应用" class="headerlink" title="13.2 Set 遍历的应用"></a>13.2 Set 遍历的应用</h3><p>扩展运算符和 <code>Set</code> 结构相结合，可以去除数组的重复成员。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 去除数组的重复成员</span></span><br><span class="line">[...<span class="keyword">new</span> <span class="title class_">Set</span>(array)]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 去除字符串里面的重复字符</span></span><br><span class="line">[...<span class="keyword">new</span> <span class="title class_">Set</span>(<span class="string">&#x27;ababbc&#x27;</span>)].<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"><span class="comment">// &quot;abc&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用Array.from方法可以将 Set 结构转为数组。</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">dedupe</span>(<span class="params">array</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Array</span>.<span class="title function_">from</span>(<span class="keyword">new</span> <span class="title class_">Set</span>(array));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">dedupe</span>([<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]) <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure><p>数组的<code>map</code>和<code>filter</code>方法也可以间接用于 <code>Set</code>。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line">set = <span class="keyword">new</span> <span class="title class_">Set</span>([...set].<span class="title function_">map</span>(<span class="function"><span class="params">x</span> =&gt;</span> x * <span class="number">2</span>));</span><br><span class="line"><span class="comment">// 返回Set结构：&#123;2, 4, 6&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]);</span><br><span class="line">set = <span class="keyword">new</span> <span class="title class_">Set</span>([...set].<span class="title function_">filter</span>(<span class="function"><span class="params">x</span> =&gt;</span> (x % <span class="number">2</span>) == <span class="number">0</span>));</span><br><span class="line"><span class="comment">// 返回Set结构：&#123;2, 4&#125;</span></span><br></pre></td></tr></table></figure><hr><h3 id="13-3-Map-基本用法"><a href="#13-3-Map-基本用法" class="headerlink" title="13.3 Map 基本用法"></a>13.3 Map 基本用法</h3><p><code>Map</code> 数据结构类似于对象，是键值对的集合，但是各种类型的值（包括对象）都可以当作键。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>([</span><br><span class="line">  [<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;张三&#x27;</span>],</span><br><span class="line">  [<span class="string">&#x27;title&#x27;</span>, <span class="string">&#x27;Author&#x27;</span>]</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line">map.<span class="property">size</span> <span class="comment">// 2</span></span><br><span class="line">map.<span class="title function_">has</span>(<span class="string">&#x27;name&#x27;</span>) <span class="comment">// true</span></span><br><span class="line">map.<span class="title function_">get</span>(<span class="string">&#x27;name&#x27;</span>) <span class="comment">// &quot;张三&quot;</span></span><br><span class="line">map.<span class="title function_">has</span>(<span class="string">&#x27;title&#x27;</span>) <span class="comment">// true</span></span><br><span class="line">map.<span class="title function_">get</span>(<span class="string">&#x27;title&#x27;</span>) <span class="comment">// &quot;Author&quot;</span></span><br></pre></td></tr></table></figure><p>下面介绍 <code>Map</code> 实例的属性和方法：</p><ul><li><code>Map.prototype.size</code>：返回 <code>Map</code> 结构的成员总数。</li><li><code>Map.prototype.set(key, value)</code>：设置键名<code>key</code>对应的键值为<code>value</code>，然后返回整个 <code>Map</code> 结构。如果<code>key</code>已经有值，则键值会被更新，否则就新生成该键。</li><li><code>Map.prototype.get(key)</code>：读取<code>key</code>对应的键值，如果找不到<code>key</code>，返回<code>undefined</code>。</li><li><code>Map.prototype.has(key)</code>：返回一个布尔值，表示某个键是否在当前 <code>Map</code> 对象之中。</li><li><code>Map.prototype.delete(key)</code>：删除某个键，返回<code>true</code>。如果删除失败，返回<code>false</code>。</li><li><code>Map.prototype.clear()</code>：清除所有成员，没有返回值。</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">map.<span class="title function_">set</span>(<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line">map.<span class="title function_">set</span>(<span class="string">&#x27;bar&#x27;</span>, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">map.<span class="property">size</span> <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">map.<span class="title function_">get</span>(<span class="string">&#x27;foo&#x27;</span>) <span class="comment">// hello</span></span><br><span class="line">map.<span class="title function_">has</span>(<span class="string">&#x27;foo&#x27;</span>) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">map.<span class="title function_">delete</span>(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line">map.<span class="title function_">has</span>(<span class="string">&#x27;foo&#x27;</span>) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">map.<span class="title function_">clear</span>()</span><br><span class="line">map.<span class="property">size</span> <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><p>下面介绍 <code>Map</code> 结构原生提供三个遍历器生成函数和一个遍历方法：</p><ul><li><code>Map.prototype.keys()</code>：返回键名的遍历器。</li><li><code>Map.prototype.values()</code>：返回键值的遍历器。</li><li><code>Map.prototype.entries()</code>：返回所有成员的遍历器。</li><li><code>Map.prototype.forEach()</code>：遍历 <code>Map</code> 的所有成员。</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>([</span><br><span class="line">  [<span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;no&#x27;</span>],</span><br><span class="line">  [<span class="string">&#x27;T&#x27;</span>,  <span class="string">&#x27;yes&#x27;</span>],</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> map.<span class="title function_">keys</span>()) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &quot;F&quot;</span></span><br><span class="line"><span class="comment">// &quot;T&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> map.<span class="title function_">values</span>()) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &quot;no&quot;</span></span><br><span class="line"><span class="comment">// &quot;yes&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> map.<span class="title function_">entries</span>()) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(item[<span class="number">0</span>], item[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &quot;F&quot; &quot;no&quot;</span></span><br><span class="line"><span class="comment">// &quot;T&quot; &quot;yes&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> map.<span class="title function_">entries</span>()) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(key, value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &quot;F&quot; &quot;no&quot;</span></span><br><span class="line"><span class="comment">// &quot;T&quot; &quot;yes&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于使用map.entries()</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> map) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(key, value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &quot;F&quot; &quot;no&quot;</span></span><br><span class="line"><span class="comment">// &quot;T&quot; &quot;yes&quot;</span></span><br><span class="line"></span><br><span class="line">map.<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">value, key, map</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Key: %s, Value: %s&quot;</span>, key, value);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>需要特别注意的是，<code>Map</code> 的遍历顺序就是插入顺序。</p><hr><h3 id="13-4-Map-与其他数据结构转换"><a href="#13-4-Map-与其他数据结构转换" class="headerlink" title="13.4 Map 与其他数据结构转换"></a>13.4 Map 与其他数据结构转换</h3><p><strong>（1）Map 转为数组</strong></p><p><code>Map</code> 转为数组最方便的方法，就是使用扩展运算符<code>...</code>。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> myMap = <span class="keyword">new</span> <span class="title class_">Map</span>()</span><br><span class="line">  .<span class="title function_">set</span>(<span class="literal">true</span>, <span class="number">7</span>)</span><br><span class="line">  .<span class="title function_">set</span>(&#123;<span class="attr">foo</span>: <span class="number">3</span>&#125;, [<span class="string">&#x27;abc&#x27;</span>]);</span><br><span class="line">[...myMap]</span><br><span class="line"><span class="comment">// [ [ true, 7 ], [ &#123; foo: 3 &#125;, [ &#x27;abc&#x27; ] ] ]</span></span><br></pre></td></tr></table></figure><p>结合数组的<code>map</code>方法、<code>filter</code>方法，就可以实现 <code>Map</code> 的遍历和过滤。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> map0 = <span class="keyword">new</span> <span class="title class_">Map</span>()</span><br><span class="line">  .<span class="title function_">set</span>(<span class="number">1</span>, <span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">  .<span class="title function_">set</span>(<span class="number">2</span>, <span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">  .<span class="title function_">set</span>(<span class="number">3</span>, <span class="string">&#x27;c&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> map1 = <span class="keyword">new</span> <span class="title class_">Map</span>(</span><br><span class="line">  [...map0].<span class="title function_">filter</span>(<span class="function">(<span class="params">[k, v]</span>) =&gt;</span> k &lt; <span class="number">3</span>)</span><br><span class="line">);</span><br><span class="line"><span class="comment">// 产生 Map 结构 &#123;1 =&gt; &#x27;a&#x27;, 2 =&gt; &#x27;b&#x27;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> map2 = <span class="keyword">new</span> <span class="title class_">Map</span>(</span><br><span class="line">  [...map0].<span class="title function_">map</span>(<span class="function">(<span class="params">[k, v]</span>) =&gt;</span> [k * <span class="number">2</span>, <span class="string">&#x27;_&#x27;</span> + v])</span><br><span class="line">);</span><br><span class="line"><span class="comment">// 产生 Map 结构 &#123;2 =&gt; &#x27;_a&#x27;, 4 =&gt; &#x27;_b&#x27;, 6 =&gt; &#x27;_c&#x27;&#125;</span></span><br></pre></td></tr></table></figure><p><strong>（2）数组 转为 Map</strong></p><p>将数组传入 <code>Map</code> 构造函数，就可以转为 <code>Map</code>。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Map</span>([</span><br><span class="line">  [<span class="literal">true</span>, <span class="number">7</span>],</span><br><span class="line">  [&#123;<span class="attr">foo</span>: <span class="number">3</span>&#125;, [<span class="string">&#x27;abc&#x27;</span>]]</span><br><span class="line">])</span><br><span class="line"><span class="comment">// Map &#123;</span></span><br><span class="line"><span class="comment">//   true =&gt; 7,</span></span><br><span class="line"><span class="comment">//   Object &#123;foo: 3&#125; =&gt; [&#x27;abc&#x27;]</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure><p><strong>（3）Map 转为对象</strong></p><p>如果所有 <code>Map</code> 的键都是字符串，它可以无损地转为对象。如果有非字符串的键名，那么这个键名会被转成字符串，再作为对象的键名。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">strMapToObj</span>(<span class="params">strMap</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> obj = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> [k,v] <span class="keyword">of</span> strMap) &#123;</span><br><span class="line">    obj[k] = v;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> myMap = <span class="keyword">new</span> <span class="title class_">Map</span>()</span><br><span class="line">  .<span class="title function_">set</span>(<span class="string">&#x27;yes&#x27;</span>, <span class="literal">true</span>)</span><br><span class="line">  .<span class="title function_">set</span>(<span class="string">&#x27;no&#x27;</span>, <span class="literal">false</span>);</span><br><span class="line"><span class="title function_">strMapToObj</span>(myMap)</span><br><span class="line"><span class="comment">// &#123; yes: true, no: false &#125;</span></span><br></pre></td></tr></table></figure><p><strong>（4）对象转为 Map</strong></p><p>对象转为 <code>Map</code> 可以通过 <code>Object.entries()</code>。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;<span class="string">&quot;a&quot;</span>:<span class="number">1</span>, <span class="string">&quot;b&quot;</span>:<span class="number">2</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>(<span class="title class_">Object</span>.<span class="title function_">entries</span>(obj));</span><br></pre></td></tr></table></figure><p><strong>（5）Map 转为 JSON</strong></p><p><code>Map</code> 转为 <code>JSON</code> 要区分两种情况。</p><p>一种情况是，<code>Map</code> 的键名都是字符串，这时可以选择转为对象 <code>JSON</code>。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">strMapToJson</span>(<span class="params">strMap</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(<span class="title function_">strMapToObj</span>(strMap));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myMap = <span class="keyword">new</span> <span class="title class_">Map</span>().<span class="title function_">set</span>(<span class="string">&#x27;yes&#x27;</span>, <span class="literal">true</span>).<span class="title function_">set</span>(<span class="string">&#x27;no&#x27;</span>, <span class="literal">false</span>);</span><br><span class="line"><span class="title function_">strMapToJson</span>(myMap)</span><br><span class="line"><span class="comment">// &#x27;&#123;&quot;yes&quot;:true,&quot;no&quot;:false&#125;&#x27;</span></span><br></pre></td></tr></table></figure><p>另一种情况是，<code>Map</code> 的键名有非字符串，这时可以选择转为数组 <code>JSON</code>。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">mapToArrayJson</span>(<span class="params">map</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">JSON</span>.<span class="title function_">stringify</span>([...map]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myMap = <span class="keyword">new</span> <span class="title class_">Map</span>().<span class="title function_">set</span>(<span class="literal">true</span>, <span class="number">7</span>).<span class="title function_">set</span>(&#123;<span class="attr">foo</span>: <span class="number">3</span>&#125;, [<span class="string">&#x27;abc&#x27;</span>]);</span><br><span class="line"><span class="title function_">mapToArrayJson</span>(myMap)</span><br><span class="line"><span class="comment">// &#x27;[[true,7],[&#123;&quot;foo&quot;:3&#125;,[&quot;abc&quot;]]]&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>（6）JSON 转为 Map</strong></p><p><code>JSON</code> 转为 <code>Map</code>，正常情况下，所有键名都是字符串。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">objToStrMap</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> strMap = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> k <span class="keyword">of</span> <span class="title class_">Object</span>.<span class="title function_">keys</span>(obj)) &#123;</span><br><span class="line">    strMap.<span class="title function_">set</span>(k, obj[k]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> strMap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">jsonToStrMap</span>(<span class="params">jsonStr</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">objToStrMap</span>(<span class="title class_">JSON</span>.<span class="title function_">parse</span>(jsonStr)); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">jsonToStrMap</span>(<span class="string">&#x27;&#123;&quot;yes&quot;: true, &quot;no&quot;: false&#125;&#x27;</span>)</span><br><span class="line"><span class="comment">// Map &#123;&#x27;yes&#x27; =&gt; true, &#x27;no&#x27; =&gt; false&#125;</span></span><br></pre></td></tr></table></figure><p>如果整个 <code>JSON</code> 就是一个数组，且每个数组成员本身，又是一个有两个成员的数组。这时，它可以直接转为 <code>Map</code>。（类似 <code>Map</code> 转为数组 <code>JSON</code> 的逆操作）</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">jsonToMap</span>(<span class="params">jsonStr</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Map</span>(<span class="title class_">JSON</span>.<span class="title function_">parse</span>(jsonStr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">jsonToMap</span>(<span class="string">&#x27;[[true,7],[&#123;&quot;foo&quot;:3&#125;,[&quot;abc&quot;]]]&#x27;</span>)</span><br><span class="line"><span class="comment">// Map &#123;true =&gt; 7, Object &#123;foo: 3&#125; =&gt; [&#x27;abc&#x27;]&#125;</span></span><br></pre></td></tr></table></figure><hr><h2 id="14-Proxy"><a href="#14-Proxy" class="headerlink" title="14. Proxy"></a>14. Proxy</h2><p><a href="https://es6.ruanyifeng.com/#docs/proxy">本章</a>内容复杂，故先跳过一部分。</p><h3 id="14-1-Proxy-概述"><a href="#14-1-Proxy-概述" class="headerlink" title="14.1 Proxy 概述"></a>14.1 Proxy 概述</h3><p><code>Proxy</code> 可以理解成，<ins>在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写</ins>。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> <span class="title class_">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">  <span class="attr">get</span>: <span class="keyword">function</span> (<span class="params">target, propKey, receiver</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`getting <span class="subst">$&#123;propKey&#125;</span>!`</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, propKey, receiver);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">set</span>: <span class="keyword">function</span> (<span class="params">target, propKey, value, receiver</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`setting <span class="subst">$&#123;propKey&#125;</span>!`</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">set</span>(target, propKey, value, receiver);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码对一个空对象架设了一层拦截，重定义了属性的读取<code>get</code>和设置<code>set</code>行为。对设置了拦截行为的对象<code>obj</code>读写它的属性，就会得到下面的结果。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">obj.<span class="property">count</span> = <span class="number">1</span></span><br><span class="line"><span class="comment">//  setting count!</span></span><br><span class="line">++obj.<span class="property">count</span></span><br><span class="line"><span class="comment">//  getting count!</span></span><br><span class="line"><span class="comment">//  setting count!</span></span><br><span class="line"><span class="comment">//  2</span></span><br></pre></td></tr></table></figure><p>这里可以看出，<code>Proxy</code> 实际上重载<code>overload</code>了点运算符，即用自己的定义覆盖了语言的原始定义。(类似<code>C++</code>的重载)</p><p><code>ES6</code> 原生提供 <code>Proxy</code> 构造函数，用来生成 <code>Proxy</code> 实例。<code>target</code>参数表示所要拦截的目标对象，<code>handler</code>参数也是一个对象，用来定制拦截行为。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler);</span><br></pre></td></tr></table></figure><p>下面是另一个拦截读取属性行为的例子。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">  <span class="attr">get</span>: <span class="keyword">function</span>(<span class="params">target, propKey</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">35</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">proxy.<span class="property">time</span> <span class="comment">// 35</span></span><br><span class="line">proxy.<span class="property">name</span> <span class="comment">// 35</span></span><br><span class="line">proxy.<span class="property">title</span> <span class="comment">// 35</span></span><br></pre></td></tr></table></figure><p>上面代码中，作为构造函数，<code>Proxy</code>接受两个参数。第一个参数是所要代理的目标对象。第二个参数是一个配置对象，对于每一个被代理的操作，需要提供一个对应的处理函数，该函数将拦截对应的操作。</p><p>注意，要使得<code>Proxy</code>起作用，必须针对<code>Proxy</code>实例进行操作，而不是针对目标对象进行操作。</p><hr><h3 id="14-2-Proxy-的实例方法"><a href="#14-2-Proxy-的实例方法" class="headerlink" title="14.2 Proxy 的实例方法"></a>14.2 Proxy 的实例方法</h3><p><code>Proxy</code> 支持的拦截操作一共 <code>13</code> 种。(剩下的可以在<a href="https://es6.ruanyifeng.com/#docs/proxy#Proxy-%E5%AE%9E%E4%BE%8B%E7%9A%84%E6%96%B9%E6%B3%95">这里</a>找到)</p><p><strong>实例方法 1：</strong><code>get()</code>方法用于拦截某个属性的读取操作，可以接受三个参数，依次为目标对象、属性名和 <code>proxy</code> 实例本身。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;张三&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(person, &#123;</span><br><span class="line">  <span class="attr">get</span>: <span class="keyword">function</span>(<span class="params">target, propKey</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (propKey <span class="keyword">in</span> target) &#123;</span><br><span class="line">      <span class="keyword">return</span> target[propKey];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ReferenceError</span>(<span class="string">&quot;Prop name \&quot;&quot;</span> + propKey + <span class="string">&quot;\&quot; does not exist.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">proxy.<span class="property">name</span> <span class="comment">// &quot;张三&quot;</span></span><br><span class="line">proxy.<span class="property">age</span> <span class="comment">// 抛出一个错误</span></span><br></pre></td></tr></table></figure><p><strong>实例方法 2：</strong> <code>set()</code>方法用来拦截某个属性的赋值操作，可以接受四个参数，依次为目标对象、属性名、属性值和 <code>Proxy</code> 实例本身。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> validator = &#123;</span><br><span class="line">  <span class="attr">set</span>: <span class="keyword">function</span>(<span class="params">obj, prop, value</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (prop === <span class="string">&#x27;age&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="title class_">Number</span>.<span class="title function_">isInteger</span>(value)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;The age is not an integer&#x27;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (value &gt; <span class="number">200</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RangeError</span>(<span class="string">&#x27;The age seems invalid&#x27;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对于满足条件的 age 属性以及其他属性，直接保存</span></span><br><span class="line">    obj[prop] = value;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> <span class="title class_">Proxy</span>(&#123;&#125;, validator);</span><br><span class="line">person.<span class="property">age</span> = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">person.<span class="property">age</span> <span class="comment">// 100</span></span><br><span class="line">person.<span class="property">age</span> = <span class="string">&#x27;young&#x27;</span> <span class="comment">// 报错</span></span><br><span class="line">person.<span class="property">age</span> = <span class="number">300</span> <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><hr><h2 id="15-Reflect"><a href="#15-Reflect" class="headerlink" title="15. Reflect"></a>15. Reflect</h2><h3 id="15-1-Reflect-概述"><a href="#15-1-Reflect-概述" class="headerlink" title="15.1 Reflect 概述"></a>15.1 Reflect 概述</h3><p><code>Reflect</code>对象与<code>Proxy</code>对象一样，也是 <code>ES6</code> 为了操作对象而提供的新 <code>API</code>。<code>Reflect</code>对象的设计目的有这样几个。</p><p>（1）将<code>Object</code>对象的一些属于语言内部的方法（比如<code>Object.defineProperty</code>），放到<code>Reflect</code>对象上。也就是说，未来可以从<code>Reflect</code>对象上拿到语言内部的方法。</p><p>（2）修改某些<code>Object</code>方法的返回结果，让其变得更合理。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 老写法</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(target, property, attributes);</span><br><span class="line">  <span class="comment">// success</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123; <span class="comment">// 报错</span></span><br><span class="line">  <span class="comment">// failure</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新写法</span></span><br><span class="line"><span class="keyword">if</span> (<span class="title class_">Reflect</span>.<span class="title function_">defineProperty</span>(target, property, attributes)) &#123;</span><br><span class="line">  <span class="comment">// success</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">// 直接返回 false</span></span><br><span class="line">  <span class="comment">// failure</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（3）让<code>Object</code>操作都变成函数行为。比如<code>name in obj</code>和<code>delete obj[name]</code>，而<code>Reflect.has(obj, name)</code>和<code>Reflect.deleteProperty(obj, name)</code>让它们变成了函数行为。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 老写法</span></span><br><span class="line"><span class="string">&#x27;assign&#x27;</span> <span class="keyword">in</span> <span class="title class_">Object</span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 新写法</span></span><br><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">has</span>(<span class="title class_">Object</span>, <span class="string">&#x27;assign&#x27;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>（4）让<code>Reflect</code>对象的方法与<code>Proxy</code>对象的方法对应，只要是<code>Proxy</code>对象的方法，就能在<code>Reflect</code>对象上找到对应的方法。这就让<code>Proxy</code>对象可以方便地调用对应的<code>Reflect</code>方法，完成默认行为，作为修改行为的基础。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> loggedObj = <span class="keyword">new</span> <span class="title class_">Proxy</span>(obj, &#123;</span><br><span class="line">  <span class="title function_">get</span>(<span class="params">target, name</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;get&#x27;</span>, target, name);</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, name);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">deleteProperty</span>(<span class="params">target, name</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;delete&#x27;</span> + name);</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">deleteProperty</span>(target, name);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">has</span>(<span class="params">target, name</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;has&#x27;</span> + name);</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">has</span>(target, name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，每一个<code>Proxy</code>对象的拦截操作<code>get</code>、<code>delete</code>、<code>has</code>，内部都调用对应的<code>Reflect</code>方法，保证原生行为能够正常执行。</p><p>简单来说，有了<code>Reflect</code>对象以后，很多操作会更易读。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 老写法</span></span><br><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">apply</span>.<span class="title function_">call</span>(<span class="title class_">Math</span>.<span class="property">floor</span>, <span class="literal">undefined</span>, [<span class="number">1.75</span>]) <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 新写法</span></span><br><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">apply</span>(<span class="title class_">Math</span>.<span class="property">floor</span>, <span class="literal">undefined</span>, [<span class="number">1.75</span>]) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><hr><h3 id="15-2-Reflect-静态方法"><a href="#15-2-Reflect-静态方法" class="headerlink" title="15.2 Reflect 静态方法"></a>15.2 Reflect 静态方法</h3><p><code>Reflect</code>对象也有 <code>13</code> 个静态方法。(剩下的可以在<a href="https://es6.ruanyifeng.com/#docs/reflect#%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95">这里</a>找到)</p><p><strong>静态方法 1：</strong><code>Reflect.get</code>方法查找并返回<code>target</code>对象的<code>name</code>属性。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> myObject = &#123;</span><br><span class="line">  <span class="attr">foo</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">bar</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">baz</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">foo</span> + <span class="variable language_">this</span>.<span class="property">bar</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">get</span>(myObject, <span class="string">&#x27;foo&#x27;</span>) <span class="comment">// 1</span></span><br><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">get</span>(myObject, <span class="string">&#x27;bar&#x27;</span>) <span class="comment">// 2</span></span><br><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">get</span>(myObject, <span class="string">&#x27;baz&#x27;</span>) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p><strong>静态方法 2：</strong><code>Reflect.set</code>方法设置<code>target</code>对象的<code>name</code>属性等于<code>value</code>。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> myObject = &#123;</span><br><span class="line">  <span class="attr">foo</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="keyword">set</span> <span class="title function_">bar</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">foo</span> = value;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">myObject.<span class="property">foo</span> <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">set</span>(myObject, <span class="string">&#x27;foo&#x27;</span>, <span class="number">2</span>);</span><br><span class="line">myObject.<span class="property">foo</span> <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">set</span>(myObject, <span class="string">&#x27;bar&#x27;</span>, <span class="number">3</span>)</span><br><span class="line">myObject.<span class="property">foo</span> <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><hr><h3 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h3><blockquote><p>该学习笔记的所有章节均保存在<a href="https://github.com/Hongda-OSU/ES6-Journey">Github</a>中，如有需要，可下载并在<a href="https://typora.io/">Typora</a>中阅读。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> ES6 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
