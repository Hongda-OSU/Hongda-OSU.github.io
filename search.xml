<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Threejs学习笔记</title>
      <link href="/posts/31bc7ecf.html"/>
      <url>/posts/31bc7ecf.html</url>
      
        <content type="html"><![CDATA[<h3 id="还在布置中"><a href="#还在布置中" class="headerlink" title="还在布置中"></a>还在布置中</h3><blockquote><p>有需要请前往 <a href="https://github.com/Hongda-OSU/Threejs-Journey">Threejs</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Threejs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TS学习笔记</title>
      <link href="/posts/2caddd77.html"/>
      <url>/posts/2caddd77.html</url>
      
        <content type="html"><![CDATA[<h3 id="还在布置中"><a href="#还在布置中" class="headerlink" title="还在布置中"></a>还在布置中</h3><blockquote><p>有需要请前往 <a href="https://github.com/Hongda-OSU/TS-Journey">TS</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TypeScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ES6学习笔记</title>
      <link href="/posts/fbe58254.html"/>
      <url>/posts/fbe58254.html</url>
      
        <content type="html"><![CDATA[<h1 id="Chapter1-let-和-const-命令"><a href="#Chapter1-let-和-const-命令" class="headerlink" title="Chapter1: let 和 const 命令"></a>Chapter1: let 和 const 命令</h1><h2 id="let-命令"><a href="#let-命令" class="headerlink" title="let 命令"></a>let 命令</h2><ol><li>基本用法<blockquote><p><code>let</code>的用法类似于<code>var</code>，但是所声明的变量，只在<code>let</code>命令所在的代码块内有效</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">var</span> b = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">a <span class="comment">// ReferenceError: a is not defined.</span></span><br><span class="line">b <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><blockquote><p><code>for</code>循环的计数器，合适使用<code>let</code>命令 (因为<code>i</code>只在<code>for</code>循环体内有效）</p></blockquote></li><li>let 不存在变量提升<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// var 的情况</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(foo); <span class="comment">// 输出undefined</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// let 的情况</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(bar); <span class="comment">// 报错ReferenceError</span></span><br><span class="line"><span class="keyword">let</span> bar = <span class="number">2</span>;</span><br></pre></td></tr></table></figure></li><li>暂时性死区<blockquote><p>ES6 明确规定，如果区块中存在<code>let</code>和<code>const</code>命令，这个区块对这些命令声明的变量，<br>从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。(简单说，在区块内先声明，再使用)</p></blockquote></li></ol><hr><h3 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h3><ol><li>ES6 的块级作用域<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f1</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> n = <span class="number">5</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> n = <span class="number">10</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(n); <span class="comment">// 5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>上面的函数有两个代码块，都声明了变量<code>n</code>，运行后输出 5。这表示外层代码块不受内层代码块的影响。<br>如果两次都使用<code>var</code>定义变量<code>n</code>，最后输出的值才是 10。</p></blockquote></li><li>块级作用域与函数声明<blockquote><p>块级作用域内部，优先使用函数表达式</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="string">&#x27;secret&#x27;</span>;</span><br><span class="line">  <span class="keyword">let</span> f = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>ES6 的块级作用域必须有大括号，如果没有大括号，JavaScript 引擎就认为不存在块级作用域。</p></blockquote></li></ol><hr><h3 id="const-命令"><a href="#const-命令" class="headerlink" title="const 命令"></a>const 命令</h3><ol><li>基本用法 (和let类似）<blockquote><p><code>const</code>声明一个只读的常量。一旦声明，常量的值就不能改变。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">PI</span> = <span class="number">3.1415</span>;</span><br><span class="line"><span class="variable constant_">PI</span> <span class="comment">// 3.1415</span></span><br><span class="line"><span class="variable constant_">PI</span> = <span class="number">3</span>;</span><br><span class="line"><span class="comment">// TypeError: Assignment to constant variable.</span></span><br></pre></td></tr></table></figure><blockquote><p><code>const</code>一旦声明变量，就必须立即初始化，不能留到以后赋值。</p></blockquote></li><li>本质<blockquote><p><code>const</code>实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动 \</p><ol><li>对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。</li><li>但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指向实际数据的指针，<br><code>const</code>只能保证这个指针是固定的, 至于它指向的数据结构是不是可变的，就完全不能控制了。</li><li><code>Object.freez</code>只能冻结对象，不能冻结属性。</li></ol></blockquote></li><li>ES6 声明变量的六种方法<blockquote><p><code>var, function, let, const, import, class</code></p></blockquote></li><li>顶层对象的属性<blockquote><p>顶层对象，在浏览器环境指的是window对象，在 Node 指的是global对象。<br>但在ES6中，<code>let</code>命令、<code>const</code>命令、<code>class</code>命令声明的全局变量，不属于顶层对象的属性。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 如果在 Node 的 REPL 环境，可以写成 global.a</span></span><br><span class="line"><span class="comment">// 或者采用通用方法，写成 this.a</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">a</span> <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="number">1</span>;</span><br><span class="line"><span class="variable language_">window</span>.<span class="property">b</span> <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> ES6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hello</title>
      <link href="/posts/3610a686.html"/>
      <url>/posts/3610a686.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
